- en: Special API for Special Cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The MobX API surface is very lean and exposes the right abstractions for dealing
    with your state management logic. In most situations, the APIs we have seen thus
    far will suffice. However, there will always be those gnarly edge cases that demand
    a slight deviation from the well-trodden path. It is for these by-lanes for which
    MobX gives you some special APIs. We will look at some of these in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we will cover in this chapter include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Direct manipulation with the object API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `inject()` and `observe()` to hook into the internal MobX eventing system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special utility functions and tools that will help in debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quick mention of some miscellaneous APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be required to have JavaScript programming language. Finally, to use
    the Git repository of this book, the user needs to install Git.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Mobx-Quick-Start-Guide/tree/master/src/Chapter07](https://github.com/PacktPublishing/Mobx-Quick-Start-Guide/tree/master/src/Chapter07)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2A1Or6V](http://bit.ly/2A1Or6V)'
  prefs: []
  type: TYPE_NORMAL
- en: Direct manipulation with the object API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When deciding on the data structures for your observable state, your natural
    choice should be to reach out for `observable.object()`, `observable.array()`,
    `observable.map()`, `observable.box()`, or to use the convenient `observable()`
    API. Manipulating these data structures is as simple as mutating the properties
    directly or adding and removing elements as needed.
  prefs: []
  type: TYPE_NORMAL
- en: MobX gives you yet another way to surgically make changes to your data structures.
    It exposes a granular object API that can mutate these data structures at runtime.
    In fact, it gives you some capabilities that are not even possible with the original
    data structures. For example, adding new properties to observable objects and
    also keeping it reactive.
  prefs: []
  type: TYPE_NORMAL
- en: Granular reads and writes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The object API is focused on giving you granular control over the observable
    properties of top-level data structures: objects, arrays, and maps. In doing so,
    they continue to play well with the MobX reactive system and ensure the granular
    changes you make are picked up by the *reactions*. The following APIs apply to
    observable objects/arrays/maps:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get(thing, key)`: Retrieves the value under the key. This key can even be
    non-existent. When used in a reaction, it will trigger a re-execution when that
    key becomes available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set(thing, key, value)` or `set(thing, { key: value })`: sets a value for
    the key. The second form is better for setting multiple *key-value* pairs at once.
    Conceptually, it is very similar to `Object.assign()`, but with the addition of
    being reactive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`has(thing, key)`: Gives back a boolean indicating if the key is present.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove(thing, key)`: Removes the given key and its value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`values(thing)`: Gives an array of values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`keys(thing)`: Gives an array containing all the keys. Note that this only
    applies to observable objects and maps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`entries(thing)`: Gives back an array of key-value pairs, where each pair is
    an array of two elements (`[key, value]`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following snippet exercises all of these APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: By using these APIs, you can target specific properties of the observables and
    update them as necessary. Reading and writing to keys that *don't exist* is considered
    valid with the object API. Notice how we read the `metadata` property of `firstTodo`
    in `autorun()`, which does not exist at the time of the call. However, MobX still
    tracks this key due to the use of the `get()` API. When we `set()` the `metadata`
    later in an action, `autorun()` is re-triggered to print it out on the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be seen in the following console output. Notice how the `metadata`
    check goes from `false` to `true` and back to `false` when removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: From MobX to JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of the observable types are special classes created by MobX that not only
    store data but also a bunch of housekeeping to track changes. We will explore
    this housekeeping in a later chapter, but for our discussion now, it suffices
    to say that these MobX types are not always compatible with other third-party
    APIs, especially when using MobX 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'When interfacing with external libraries, you may need to send the raw JavaScript
    values instead of the MobX-typed values. This is where you need the `toJS()` function.
    It will convert the MobX observables to raw JavaScript values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`toJS(source, options?)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`source`: Any observable box, object, array, map, or primitives.'
  prefs: []
  type: TYPE_NORMAL
- en: '`options`: An optional argument to control behavior, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`exportMapsAsObject` (*boolean*): Whether to serialize the observable maps
    as objects (when `true`) or as JavaScript Maps (when `false`). Default is `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`detectCycles` (*boolean*): This is set to `true` by default. It detects cyclic
    references during serialization and reuses the already serialized object. This
    is a good default in most cases, but for performance reasons this can be set to
    `false` when you are sure of no cyclic references.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An important point to note with `toJS()` is that it does not serialize *computed
    properties*. This makes sense since it's purely derived information that can always
    be recomputed. The purpose of `toJS()` is to serialize the core observable state
    only. Similarly, any non-enumerable properties of the observable will not be serialized
    nor will they recurse into any non-observable data structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, you can see how the `toJS()` API is applied to observables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The console output shows you the `cart` observable before and after applying
    the `toJS()` API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Watching the events flow by
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The APIs we have seen in the previous chapters allow you to create observables
    and react to the changes via *reactions*. MobX also gives you a way to tap into
    the events that flow internally to make the reactive system work. By attaching
    listeners to these events, you can fine-tune the use of some expensive resources
    or control which updates are allowed to be applied to the observables.
  prefs: []
  type: TYPE_NORMAL
- en: Hooking into the observability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Normally, *reactions* are the place where we read *observables* and apply some
    side effects. This tells MobX to start tracking the observable and re-trigger
    the reaction on changes. However, if we look at this from the *perspe*ctive of
    the observable, how does it know when it is being used by a reaction? How can
    it do a one-time setup when it is read in a reaction and also clean up when it's
    no longer being used?
  prefs: []
  type: TYPE_NORMAL
- en: 'What we need here is the ability to know when an observable becomes *observed*
    and when it becomes *unobserved*: the two points in time where it becomes active
    and inactive in the MobX reactive system. For that, we have the following aptly
    named APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`disposer = onBecomeObserved(observable, property?: string, listener: () =>
    void)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`disposer = onBecomeUnobserved(observable, property?: string, listener: ()
    => void)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`observable`: Can be a boxed observable, an observable object/array/map.'
  prefs: []
  type: TYPE_NORMAL
- en: '`property:` An optional property of the observable. Specifying a property is
    fundamentally different than referencing the property directly. For example, `onBecomeObserved(cart,
    ''totalPrice'', () => {})` is different compared to `onBecomeObserved(cart.totalPrice,
    () => {})`. In the first case, MobX will be able to track the observable property
    but in the second case it won''t, since it is only receiving the value rather
    than the property. In fact, MobX will throw an `Error`, indicating that there
    is nothing to track in the case of `cart.totalPrice`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding error may not make much sense now, especially the term atom. We
    will look atoms in more detail in [Chapter 9](part0165.html#4TBCQ0-58c2559ca4304cecab9bc46f496bc070),
    *Mobx Internals*.
  prefs: []
  type: TYPE_NORMAL
- en: '`disposer`: The return value of these handlers. This is a function that can
    be used to dispose these handlers and clean up the event wiring.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows these APIs in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, the `onBecomeObserved()` handlers will be called
    when `autorun()` executes for the first time. Upon calling the `disposer` function,
    the `onBecomeUnobserved()` handlers are invoked. This can be seen in the following
    console output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`onBecomeObserved()` and `onBecomeUnobserved()` are great hooks to lazily set
    up (and tear down) an observable on its first use (and last use). This is useful
    in cases where there might be an expensive operation that is required to set the
    initial value of the observable. Such operations can be lazily performed by deferring
    until it is actually used somewhere.'
  prefs: []
  type: TYPE_NORMAL
- en: Lazy loading the temperature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take an example where we will lazy load the *temperature* for a city,
    but only when it is accessed. This can be done by modeling the observable property
    with the hooks for `onBecomeObserved()` and `onBecomeUnobserved()`. The following
    snippet shows this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding console output shows you the activation and deactivation for
    the `temperature` observable. It is activated in `autorun()` and after 15 seconds,
    it gets *deactivated*. We kick off the timer that keeps updating the *temperature*
    in the `onBecomeObserved()` handler and clear it in the `onBecomeUnobserved()` handler.
    The *timer* is the resource we manage that is created only when the `temperature`
    is accessed and not before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Gatekeeper of changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The changes you make to an observable are not applied immediately by MobX.
    Instead, they go through a layer of interceptors that have the ability to keep
    the change, modify it, or even discard it completely. This is all possible with
    the `intercept()` API. The signature is very similar to `onBecomeObserved` and
    `onBecomeUnobserved`, with the callback function (*interceptor*) giving you the
    change object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`disposer = intercept(observable, property?, interceptor: (change) => change
    | null )`'
  prefs: []
  type: TYPE_NORMAL
- en: '`observable`: A boxed observable or an observable object/array/map.'
  prefs: []
  type: TYPE_NORMAL
- en: '`property`: The optional string name of the property you want to intercept
    on the observable. As we saw earlier for `onBecomeObserved` and `onBecomeUnobserved`,
    there is a difference between `intercept(cart, ''totalPrice'', (change) => {})`
    and `intercept(cart.totalPrice, () => {})`. For the latter (`cart.totalPrice`),
    you are intercepting a value instead of the observable property. MobX will throw
    an error, stating that you haven''t passed the correct type.'
  prefs: []
  type: TYPE_NORMAL
- en: '`interceptor`: A callback that receives the change object and is expected to
    return the final change; apply as-is, modify, or discard (`null`). It is also
    valid to throw an error in the interceptor to notify exceptional updates.'
  prefs: []
  type: TYPE_NORMAL
- en: '`disposer`: Gives back a function, which when called will cancel this interceptor.
    This is very similar to what we have seen with `onBecomeObserved()`, `onBecomeUnobserved()`,
    and even reactions like `autorun()`, `reaction()`, and `when()`.'
  prefs: []
  type: TYPE_NORMAL
- en: Intercepting the change
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The change argument that is received has some known fields that give the details.
    The most important of these are the `type` field, which tells you the *type of
    change*, and `object`, which gives the *object on which the change happened*.
    Depending upon the `type`, a few other fields add more context to the change:'
  prefs: []
  type: TYPE_NORMAL
- en: '`type`: Can be one of add, delete, or update'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`object`: A boxed observable or the observable object/array/map instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`newValue`: When the type is add or update, this fields contains the new value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`oldValue`: When the type is delete or update, this field carries the previous
    value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inside the interceptor callback, you have the opportunity to finalize the type
    of change you actually want to apply. You can do one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Return null and discard the change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update with a different value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throw an error indicating an exceptional value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return as-is and apply the change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take an example of intercepting the theme changes and ensuring that
    only valid updates are applied. In the following snippet, you can see how we intercept
    the `color` property of the theme observable. The color can either be *light*
    or *dark*, or have a shorthand value of `l` or `d`. For any other value, we throw
    an error. We also guard against unsetting the color by returning `null` and discarding
    the change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: observe() the changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The utility that acts as the counterpart of `intercept()` is `observe()`. `observe()`,
    as the name suggests, allows you to make granular observations on observables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`observe(observable, property?, observer: (change) => {})`'
  prefs: []
  type: TYPE_NORMAL
- en: The signature is exactly like `intercept()`, but the behavior is quite different.
    `observe()` is invoked *after the change* has been applied to the observable.
  prefs: []
  type: TYPE_NORMAL
- en: An interesting characteristic is that `observe()` is immune to *transactions*.
    What this means is that the *observer callback* is invoked immediately after a
    mutation and does not wait until the transaction completes. As you are aware,
    *actions* are the places where a mutation happens. MobX optimizes the notifications
    by firing them, but only after the top-most *action* completes. With `observe()`,
    you get an unfiltered view of the mutations as and when they happen.
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended to use `autorun()` whenever you feel a need for `observe()`.
    Use it only when you think you need immediate notification for a mutation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows the various details you can observe on mutating
    an observable. As you can see, the `change` argument is exactly like `intercept()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Development utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you scale your applications with more features, it becomes mandatory to understand
    how and when the MobX reactive system is being used. MobX comes with a set of
    debugging utilities that help you monitor and trace the various activities happening
    inside it. These give you a real-time view of all the observable changes, actions,
    and reactions firing inside the system.
  prefs: []
  type: TYPE_NORMAL
- en: Using spy() to track the reactivity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Earlier, we saw the `observe()` function, which allows you to *"observe"* the
    changes happening to a single observable. But what if you wanted to observe changes
    happening across all observables without having to individually set up the `observe()`
    handlers? That is where `spy()` comes in. It gives you insight into how the various
    observables in your system are changing over time:'
  prefs: []
  type: TYPE_NORMAL
- en: '`disposer = spy(listener: (event) => { })`'
  prefs: []
  type: TYPE_NORMAL
- en: 'It takes in a *listener function* that receives an event object carrying all
    the details. The *event* has properties very similar to the `observe()` handler.
    There is a `type` field that tells you about the type of the event. The type can
    be one of:'
  prefs: []
  type: TYPE_NORMAL
- en: '**update**: For object, array, map'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**add**: For object, array, map'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**delete**: For map'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**create**: For boxed observables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**action**: When an action fires'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**reaction**: Upon execution of `autorun()`, `reaction()`, or `when()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**compute**: For computed properties'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**error**: In case of any caught exceptions inside actions or reactions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a snippet of code that sets up a `spy()` and prints the output to the
    console. We are also disposing this spy after five seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Some of the spy events may be accompanied by `spyReportStart` or `spyReportEnd`
    properties. These mark a group of events that are related.
  prefs: []
  type: TYPE_NORMAL
- en: Using `spy()` directly is probably not your best option during development.
    It is better to rely on the visual debugger (discussed in the following section),
    which makes use of `spy()` to give you more readable logs. Note that the calls
    to `spy()` are a *no-op* for production builds when you set the `NODE_ENV` environment
    variable to *"production"*.
  prefs: []
  type: TYPE_NORMAL
- en: Tracing a reaction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While `spy()` gives you a lens to observe all changes happening in MobX, `trace()`
    is a utility that is specifically focused on computed properties, reactions, and
    component renders. You can find out why a *computed property*, *reaction,* or
    a *component render* is being invoked by simply placing a `trace()` statement
    inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`trace(thing?, property?, enterDebugger?)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'It has three *optional* arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`thing`: An observable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`property`: An observable property'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enterDebugger`: A Boolean flag indicating whether you want to step into the
    debugger automatically'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is quite common to invoke a trace with: `trace(true)`, which will pause
    inside the debugger upon invocation. For the book search example (from [Chapter
    3](part0055.html#1KEEU0-58c2559ca4304cecab9bc46f496bc070), *A React App with MobX*),
    we can place a trace statement right inside the `render()` of the `SearchTextField`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When the debugger is paused, you get a complete root-cause analysis of why
    this computed property, reaction, or render got executed. Inside the Chrome devtools,
    you can see these details like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00035.jpeg)Details on the Chrome devtools'
  prefs: []
  type: TYPE_NORMAL
- en: Visual debugging with mobx-react-devtools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`spy()` and `trace()` are great for getting a code-level insight into the MobX
    reactive system. However, when starting out your analysis of improving performance,
    visual debugging is quite handy. MobX has a sister NPM package called `mobx-react-devtools`,
    which gives you a simple `<DevTools />` component that can help you visualize
    how your component tree reacts to the observables. By including this component
    at the top of your app, you will see a toolbar at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The screenshot below shows the MobX DevTools toolbar showing up in the *top-right*
    corner of the screen.![](../images/00036.jpeg)
  prefs: []
  type: TYPE_NORMAL
- en: By enabling the buttons, you can see which components render upon changes in
    observables, see the dependency tree of observables connected to a DOM element,
    and print console logs whenever an *action*/*reaction* executes. Components will
    flash with a colored rectangle whenever they render. The color of the rectangle
    is an indication of how long it takes to render, *green* being the fastest and
    *red* being the slowest. You can observe the flashing rectangles to ensure that
    only the parts you intended to change are re-rendering. This is a great way to
    identify components that are rendering unnecessarily and possibly make more granular
    observers.
  prefs: []
  type: TYPE_NORMAL
- en: The `mobx-react-devtools` package relies on `spy()` to print the console logs
    for executing actions and reactions.
  prefs: []
  type: TYPE_NORMAL
- en: A few other APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some miscellaneous APIs that are provided by MobX that are not that
    frequently used. It is still worth mentioning them here for the sake of completeness.
  prefs: []
  type: TYPE_NORMAL
- en: Querying the reactive system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When dealing with the various abstractions in MobX (observables, actions, reactions),
    it is sometimes useful to know if a certain object, function, or value is of a
    certain kind. MobX has a set of *isXXX* APIs that help you to determine the type
    of the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '`isObservableObject(thing)`, `isObservableArray(thing)`, `isObservableMap(thing)`:
    Tells you whether the passed in value is an observable object, array, or map'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isObservable(thing)` and `isObservableProp(thing, property?)`: Similar to
    the preceding point but more generalized check for an observable value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isBoxedObservable(thing)`: Whether the value is a boxed observable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isAction(func)`: Returns `true` if the function is wrapped by an action'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isComputed(thing)` and `isComputedProp(thing, property?)`: Checks whether
    the value is a computed property'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Probing deeper into the reactive system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MobX builds up a reactive fabric internally that keeps all of the observables
    and reactions connected. We will be exploring these internals in [Chapter 9](part0165.html#4TBCQ0-58c2559ca4304cecab9bc46f496bc070),
    *Mobx Internals*, where we will see the mention of certain terms like *atoms*.
    For now, let''s take a quick look at the APIs that give you the internal representation
    of the observables and reactions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getAtom(thing, property?)`: At the heart of every observable is an `Atom`,
    which keeps track of the observers that depend on the observable value. Its purpose
    is to report whenever anyone reads or writes to the observable value. With this
    API, you get the instance of the `Atom` that backs the observable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getDependencyTree(thing, property?)`: This gives you the tree of dependencies
    that the given thing depends on. It can be used to get the dependencies for a
    computed property or a reaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getObserverTree(thing, property?)`: This is a counterpart of `getDependencyTree()`,
    which gives you the observers that depend on the given thing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although there is a lean outer-level API for MobX, there is also a set of APIs
    for more fine-grained observation and mutation. We saw how the Object API can
    be used to make very surgical changes in your observable tree. With `observe()`
    and `intercept()`, you can track the changes happening in an observable and also
    intercept to modify the change.
  prefs: []
  type: TYPE_NORMAL
- en: '`spy()` and `trace()` are your friends during debugging, and coupled with ***mobx-react-devtools***,
    you have a visual debugger for identifying and improving render performance. These
    tools and utilities give you a rich Developer eXperience (DX) when working with
    MobX.'
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](part0143.html#48C0E0-58c2559ca4304cecab9bc46f496bc070), *Exploring
    mobx-utils and mobx-state-tree*, we will raise the bar on using MobX with the
    special packages `mobx-utils` and `mobx-state-tree`.
  prefs: []
  type: TYPE_NORMAL
