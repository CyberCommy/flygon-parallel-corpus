- en: Error Handling and Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Effective error handling and logging are essential parts of an application.
    Early versions of PHP lacked the support for exceptions and only used errors to
    flag faulty application states. The PHP 5 version brought forth the OOP features
    to the language and, with it, the exception model. This empowered PHP with the `try...catch`
    blocks like other programming languages. Later, the PHP 5.5 version brought support
    for the `finally` block, which always executed after the `try...catch` blocks, regardless
    of whether an exception was thrown or not.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, the PHP language differentiates errors and exceptions as faulty states
    of an application. Both are raised as unexpected to our application logic. There
    are numerous types of errors, such as `E_ERROR`, `E_WARNING`, `E_NOTICE`, and
    others. When speaking of errors, we default to the `E_ERROR` type that tends to
    signal the end of our application, an unexpected state that an application should
    not try to catch and continue executing. This might be due to a lack of memory,
    IO errors, TCP/IP errors, null reference errors and many others. Exceptions, on
    the other hand, indicate an unexpected state that an application might want to
    catch and still carry on executing. This might be due to the inability to save
    an entry in a database at a given time, an unexpected e-mail sending failure,
    and many others. This helps to think of an exception as an OO concept of an error.
  prefs: []
  type: TYPE_NORMAL
- en: PHP has its own mechanisms that allow interaction with some of the error types
    and exceptions. Using `set_error_handler`, we can define the custom error handler
    to possibly log or display an appropriate message to the user. Using the `try...catch...finally`
    blocks, we can safely catch possible exceptions and continue executing the application.
    The exceptions we don't catch automatically turn into a standard error and break
    our application execution.
  prefs: []
  type: TYPE_NORMAL
- en: Handling errors would not really be complete without proper logging mechanism.
    While PHP itself provides an interesting and useful `error_log()` function, there
    are far more robust logging solutions available in the form of free community
    libraries, such as Mongo.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving forward, we will take a detailed look into the following areas of error
    handling and logging:'
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ArithmeticError`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DivisionByZeroError`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AssertionError`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ParseError`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TypeError`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Native logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging with Monolog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NASA lost a $125 million Mars orbiter on September 1999 because engineers failed
    to convert units from English to metric. While the system had nothing to do with
    PHP or the fatal runtime errors as such, it goes to say how great the impact a
    faulty software might have in real life.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having errors and exceptions as two different error handling system introduces
    a certain level of confusion among developers. The older versions of PHP made
    it difficult to reason with `E_ERROR` as they could not be caught with custom
    error handlers. The PHP 7 version tried to address this confusion by introducing
    the `Throwable` interface, which is summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Throwable` interface is now the base interface for `Error`, `Exception`,
    and any other object that can be thrown via a `throw` statement. The methods defined
    in this interface are nearly identical to those of `Exception`. The PHP classes
    themselves cannot implement the `Throwable` interface directly or extend from
    `Error`; they can only extend `Exception`, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s happening here is that the `Glitch` class is trying to extend the `Error` class,
    which is not allowed and results in a `Fatal error` that does not get caught by
    our `try...catch` block here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example is a valid use of PHP `Throwable`, whereas, our custom
    `Flaw` class extends the `Exception` class. The `catch` block is triggered, resulting
    in the following output message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The new exception hierarchy in PHP 7 is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The obvious benefit of the new `Throwable` interface is that we can now easily
    catch both `Exception` and `Error` objects in a single `try...catch` block, as
    per the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`AssertionError` extends `Error`, which in turn implements the `Throwable`
     interface. The signature of the preceding `catch` block targets the `Throwable`
    interface, so the thrown `ArithmeticError` would be caught and the output of `Missing
    numbers!` shown.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Though our classes cannot implement the `Throwable` interface, we can define
    the interface that extends it. Such an interface can then only be implemented
    by a class extending either `Exception` or `Error`, as per the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: While it might not be a common practice, such an approach might be useful with package-specific
    interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Error
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Error` class is the base class for internal PHP errors in PHP 7. Nearly
    all fatal and recoverable fatal errors in PHP 5.x now throw instances of the `Error`
    object, making themselves catchable via the `try...catch` blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Error` class implements the `Throwable` interface, as per the following
    class synopsis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example demonstrates the use of the `Error` instance in the `catch`
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'However, there are still cases where some errors are not catchable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example triggers the `PHP Fatal error: Allowed memory size of
    2097152 bytes exhausted...` error.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, even warnings get passed by, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example triggers the `PHP Warning:  str_pad(): Padding length
    is too long...` error.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It goes to say that we should be careful with our expectations towards catching
    core language errors, as some might slip through. Those that get caught are usually
    of the base `Error` class. However, some errors will throw a more specific subclass
    of `Error`: `ArithmeticError`, `DivisionByZeroError`, `AssertionError`, `ParseError`,
    and `TypeError`.'
  prefs: []
  type: TYPE_NORMAL
- en: ArithmeticError
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ArithmeticError` class addresses the possibly faulty outcomes of performing
    mathematical operations. PHP uses it for two situations--bit shifting by a negative
    number or calling `intdiv()` with a dividend of `PHP_INT_MIN` and a divisor of
    `-1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ArithmeticError` class has no methods of its own; they are all inherited
    from the parent `Error` class, as per the following class synopsis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example demonstrates the `try...catch` block with `ArithmeticError`
    being thrown for bit shifting by a negative number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting output is as follows :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example demonstrates the `try...catch` block with `ArithmeticError`
    being thrown for calling `intdiv()` with a dividend of `PHP_INT_MIN` and divisor
    of `-1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: DivisionByZeroError
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Division by zero is an undefined mathematical expression, at least in elementary
    arithmetic; hence, PHP needed a way to respond to such cases. `DivisionByZeroError`
    is thrown when we try to divide a number by zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `DivisionByZeroError` class has no methods of its own, they are all inherited
    from the parent `ArithmeticError` class, as per the following class synopsis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to be careful what expression we are using for division. Simply dividing dividend
    number with `0` divisor number using the `/` operator will not yield the same
    result as using the `intdiv()` function. Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example will not trigger the `DivisionByZeroError` catch block.
    Instead, the following warning is raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `intdiv()` function instead of the `/` operator will trigger the `catch`
    block as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `intdiv()` function throws the `DivisionByZeroError` exception if the divisor
    is `0`. If the dividend is `PHP_INT_MIN` and the divisor is `-1`, then an `ArithmeticError`
    exception is thrown, as shown in the preceding section.
  prefs: []
  type: TYPE_NORMAL
- en: AssertionError
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Assertions are runtime checks used as a debugging feature. Using the PHP 7 `assert()` language
    construct, we can confirm whether certain PHP expressions are true or false. Whenever
    the assertion fails, `AssertionError` is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AssertionError` class has no methods of its own, they are all inherited
    from the parent `Error` class, as per the following class synopsis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'PHP 7 provides two configuration directives to control the behavior of `assert()`--`zend.assertions`
    and `assert.exception`. The `assert()` function will only get executed and possibly
    throw `AssertionError` if `zend.assertions = 1` and `assert.exception = 1`, as
    per the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming the configuration directives are all set, the preceding code will
    output the `Caught: assert(''developer'' === ''programmer'')` message. If only `zend.assertions
    = 1` but `assert.exception = 0`, then the `catch` block will have no effect and
    the following warning is raised: `Warning: assert(): assert(''developer'' ===
    ''programmer'') failed`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `zend.assertions` derivative may be completely enabled or disabled only
    in the `php.ini` file.
  prefs: []
  type: TYPE_NORMAL
- en: ParseError
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `eval()` language construct enables us to execute any arbitrary PHP code.
    The only requirement is that the code must not be wrapped in opening and closing
    PHP tags. Apart from that, the passed code itself must be a valid PHP code. If
    it happens that the passed code is invalid, then `ParseError` is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ParseError` class has no methods of its own, they are all inherited from
    the parent `Error` class, as per the following class synopsis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet demonstrates the valid `eval()` expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code block demonstrates a parse error in the evaluated code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Seeming nearly identical as a working example, you can notice the lack of the
    opening and closing (`''`) character around the date function parameter. This
    breaks the eval function, triggering the `ParseError` catch block with the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are not using the `eval()` expression, but have intentionally broken
    the code. The resulting output triggers the parse error, but this time not through
    reacting to the `catch` block, which is sort of expected. It is highly unlikely
    that this specific case would even happen in the modern IDE environments, such
    as PhpStorm, Netbeans, and alike, as they automatically alert us on broken syntax.
  prefs: []
  type: TYPE_NORMAL
- en: TypeError
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PHP 7 brought forth the *function type parameters* and *function return types*. This,
    in turn, implied the need to properly handle errors around their misuse. `TypeError`
    was introduced to target these errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `TypeError` class has no methods of its own, they are all inherited from
    the parent `Error` class, as per the following class synopsis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'There are at least three possible error scenarios that throw `TypeError`, which
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The type of argument passed to a function does not match the declared type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function return value does not match the declared function return type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An invalid number of arguments is being passed to a built-in PHP function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code demonstrates the wrong function argument type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we defined the `hello()` function that expects to receive a single string
    argument. However, the function is passed to the integer value. The  `declare(strict_types
    = 1);` expression is required if we want the `catch` block to actually catch `TypeError`.
    The preceding example results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code demonstrates the wrong function return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the defined `hello()` function has no specific argument types defined,
    but it does have a function return type defined. To simulate the faulty scenario,
    we changed the body of the function to return the integer value rather than the
    string. Same as with the previous example, the `strict_types = 1` declaration
    was needed to trigger `TypeError`, resulting in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code demonstrates the invalid number of arguments that are passed
    to a built-in PHP function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are calling the `strlen()` function with two parameters. Though this core
    PHP function itself is defined such that it accepts only one parameter, the `strict_types
    = 1` declaration turns the standard warning into `TypeError`, thus triggering
    the `catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: Uncaught error handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While a great deal of `Error` can now be caught via `try...catch`, there is
    also an extra mechanism to handle errors. PHP provides a mechanism in the form
    of a `set_error_handler()` function that allows us to define a custom handler
    function for all uncaught errors. The `set_error_handler()` function accepts two parameters,
    as per the following description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `$error_handler` function is either a handler function name passed as string,
    or entire anonymous handler function, whereas `$error_types` is one or more (separated
    by `|`) masks specifying the type of error. The handler function itself also accepts
    several parameters, as per the following description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the following two examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: These examples are nearly identical. The first one is using a separately defined
    handler function, which is then passed as a string argument to `set_error_handler()`.
    The second example uses the anonymous function with the same definition. Both
    examples use the `trigger_error()` function, one triggering `E_USER_ERROR` and
    the other  `E_USER_WARNING`. When executed, both outputs will contain the `end`
    string.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the custom handler function enables us to handle all sorts of runtime
    errors, there are some errors we cannot handle. The following error types cannot
    be handled with a user-defined function: `E_ERROR`, `E_PARSE`, `E_CORE_ERROR`,
    `E_CORE_WARNING`, `E_COMPILE_ERROR`, `E_COMPILE_WARNING`, and most of `E_STRICT`
    raised in the file where `set_error_handler()` is called.'
  prefs: []
  type: TYPE_NORMAL
- en: Triggering errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The PHP `trigger_error()` function provides a way to trigger a user-level error/warning/notice
    message. It can be used in conjunction with the built-in error handler, or with
    a user-defined error handler, as we saw in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `trigger_error()` function accepts two parameters, as per the following
    description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `$error_msg` parameter has a limitation of 1024 bytes, whereas `$error_type`
    is limited to the `E_USER_ERROR`, `E_USER_WARNING`, `E_USER_NOTICE`, and `E_USER_DEPRECATED` constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have four different `trigger_error()` function calls, each accepting
    different error types. The custom error handler kicks in for all four errors,
    and our code continues executing all the way to show `end` as the output.
  prefs: []
  type: TYPE_NORMAL
- en: There are certain conceptual similarities between **error model** (`set_error_handler`
    and `trigger_error`) on one side and **throwable model** (`try...catch` and `throw
    new ...`) on the other. Seemingly, both can catch and trigger errors. The main
    difference is that the throwable model is a more modern, object-oriented way.
    That being said, we should limit our use of `trigger_error()` to when it's absolutely
    needed for some contextual reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Exception
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exceptions were originally introduced in PHP 5, which brought forth the OOP
    model as well. They remain pretty much unchanged throughout the time. Among significant
    changes was the one added by PHP 5.5, which added the `finally` block, and PHP
    7, which added the possibility to use the `|` operator in order to catch multiple
    exception types via a single `catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: '`Exception` is the base class for all user exceptions in PHP 7\. Same as `Error`,
    `Exception` implements the `Throwable` interface, as per the following class synopsis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Exceptions remain the backbone of OO error handling. The simplicity of extending,
    throwing, and catching exceptions makes them easy to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom exception handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By extending the built-in `Exception` class, PHP lets us throw any object as
    if it were an exception. Let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Here, we defined two custom exceptions, `UsernameException` and `PasswordException`.
    They merely extended the built-in `Exception`, not really introducing any new
    methods or functionality. We then defined two variables, `$username` and `$password`.
    The `$password` variable was set to be an empty string. Finally, we set the `try...catch...finally`
    blocks, with three different `catch` blocks. The first two `catch` blocks are
    targeted to our custom exceptions, and the third targets the built-in `Exception`.
    Due to an empty password, the preceding example would throw `new PasswordException`,
    and, therefore, output the `Caught PasswordException. Finally.` string.
  prefs: []
  type: TYPE_NORMAL
- en: Rethrowing exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rethrowing exceptions is a relatively common practice in development. Sometimes,
    we wish to catch an exception, look into it, do a bit of an extra logic, and then
    rethrow the exception back so that the parent `catch` block might handle it further.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we defined three simple exceptions--`FileNotExistException`, `FileReadException`,
    and `FileEmptyException`. These correspond to three different faulty outcomes
    we might expect when dealing with our file. We then added some logic around the
    `file_get_contents` function call, trying to wrap it in the `try...catch` blocks.
    The `file_get_contents` function results in Boolean `false` if the file cannot
    be read. Knowing that, and knowing that `empty` function call results in `false`
    if the file is found empty, we can easily check if the file is alright or not in
    a single `if (!$content)` statement. There are several possible scenarios once
    the general `Exception` is thrown. The first and the most obvious one is the missing
    file. Surprisingly, even with the `try...catch` blocks in place, if the file is
    missing, PHP would output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We can clearly see that the core PHP language `Warning` has been raised, along
    with triggering the proper `catch` and `finally` block. Ideally, we would like
    to get away with the warning output. One possible way is to use the error control
    operator--the at sign (`@`). It suppresses both errors and warnings. This is quite
    dangerous and should be used with the utmost care. Generally speaking, errors
    and warnings are triggered to be handled, not to be suppressed. However, in this
    case, we might just call it justified, as we are wrapping everything in `try...catch`
    blocks. The last general `catch` block is merely there to catch an unexpected
    faulty state that is not covered by our three custom exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Uncaught Exception handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PHP provides a mechanism in the form of a `set_exception_handler` function that
    allows us to define a custom handler function for all uncaught throwables, including
    exceptions. The `set_exception_handler` function accepts a single callable parameter--either
    a *function name passed as string*, or an entire *anonymous function*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following *function name passed as string* example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the following *anonymous function* example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Both of these code examples do the same thing, there is no difference to them.
    Other than the second example being more ascetically pleasing, as there is no
    need to define a separate function like `throwableHandler()` that will only get
    used in one place. The important thing to note here is that unlike the `try...catch`
    blocks, the call to the handler function is the last thing that our application
    executes, which, in this case, means that we will never see the `end` string on
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logging is an important aspect of every application. Knowing how to catch errors does
    not necessarily mean we are handling the faulty situation as best as we should.
    If we are not logging the right details, and passing them on to the right consumer,
    then we are not really handling the situation right.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following catch and generate user message example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Both examples react to the exception by storing the message into a `$messages`
    variable, which is later shown on screen to the current user. This is great as
    the application does not crash, the user is shown what happened, and the application
    is allowed to execute. However, is it great? The examples are nearly identical,
    aside from one minor detail. The first example merely responds to the error and
    reacts to it in the moment. The second example uses the `$this->logger->critical($e);`
    expression to log the error, presumably, but necessarily, to a file. By logging
    the error, we make it possible for the consumer to review it later. The consumer
    is most likely a developer who might take a look into log files every now and
    then. Notice how the `$messages` array is not passed directly to the `$e` variable,
    rather, a custom message that fits the user situation. This is because the user
    should never be shown the level of detail we might pass onto our logs. The more
    details we pass to our log, the easier it gets to troubleshoot our application.
    By logging an entire exception instance object, in this case, we pretty much provide
    all the details the developer needs to know to try and prevent an error in the
    future.
  prefs: []
  type: TYPE_NORMAL
- en: Thoughtfully used, logging can provide quality analytics insight upon which
    we might periodically reiterate over our codebase and prevent issues that might
    not be visible during initial development. Aside from logging errors, we could
    easily log other analytical, or otherwise important bits.
  prefs: []
  type: TYPE_NORMAL
- en: The open source Elastic stack, available at [https://www.elastic.co](https://www.elastic.co),
    enables us to reliably and securely take data from any source, in any format,
    and search, analyse, and visualize it in real time. The Kibana product, available
    at [https://www.elastic.co/products/kibana](https://www.elastic.co/products/kibana),
    gives shape to our data through its interactive visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: Native logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PHP has a built-in `error_log()` function that sends an error message to the
    defined error handling routines; thus, providing an out-of-the-box solution for
    simple logging.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet describes the `error_log()` function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameters are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$message`: This is a string type value, and a message we want to log'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$message_type`: This is an integer type value; it has one of four possible
    values, which are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0`: This is an operating system logging mechanism'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1`: This is sent by e-mail to the address in the destination parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2`: This is no longer an option'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3`: This message is appended to the file destination'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`4`: This is sent directly to the SAPI logging handler'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$destination`: This string type value kicks in only for `$message_type = 1` and
    denotes an e-mail address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$extra_headers`: This string type value kicks in only for `$message_type =
    1` and denotes e-mail headers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `error_log()` function works closely with the `log_errors` and `error_log` configuration
    options defined in `php.ini`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`log_errors`: This is a boolean type configuration option. It tells if error
    messages should be logged to the server error log or `error_log`. To log to a file
    specified with the `error_log` configuration option, set this to `1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`error_log`: This is a string type configuration option. It specifies the name
    of the file where errors should be logged. If `syslog` is used, errors are logged
    to the system logger. If no value is set, errors are sent to the SAPI error logger,
    which is most likely an error log in Apache or stderr in CLI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example demonstrates logging to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `log_errors` and `error_log` options might be defined in the `.php` file
    itself; however, it is recommended to do so in `php.ini`, otherwise, logging won''t log
    any errors if the script has parse errors or cannot be run at all. The resulting
    output of the preceding example would be an `app-error.log` file, located in the
    same directory as the executing script itself with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example demonstrates logging to an e-mail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are first building the raw `$headers` string, which we then pass to
    the `error_log()` function, along with the destination e-mail address. This is
    an obvious downside of the `error_log()` function, as we are required to be familiar
    with e-mail message headers standards.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `error_log()` function is not binary-safe, which means the `$message` argument
    should not contain a null character, otherwise, it will be truncated. To bypass
    this limitation, we can use one of the conversion/escape functions, such as `base64_encode()`,
    `rawurlencode()`, or `addslashes()` before calling `error_log()`. The following
    RFCs might be useful for dealing with e-mail message headers: RFC 1896, RFC 2045,
    RFC 2046, RFC 2047, RFC 2048, RFC 2049, and RFC 2822.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Understanding the `error_log()` function, we can easily wrap it into a custom
    function of ours, let''s say `app_error_log()`, thus abstracting the entire e-mails''
    boilerplate, such as the address and headers. We can also make our `app_error_log()`
    function log into file and e-mail at once, thus making for a simple, one-line
    logging expression such as the following, possibly across our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Writing simple loggers such as these is quite easy. However, simplicity in development
    usually comes with the cost of reduced modularity. Luckily, there are third-party
    libraries out there that are quite robust when it comes to logging features. Best
    of all, they comply to a certain logging standard, as we will see in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Logging with Monolog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The PHP community provides several logging libraries for us to choose, such
    as Monolog, Analog, KLogger, Log4PHP, and others. Choosing the right library can
    be a daunting task. More so because we might decide to change the logging mechanism
    later on, which might leave us with a substantial amount of code to change. This
    is where the PSR-3 logging standard helps. Choosing a library that is standards-compliant
    makes it easier to reason with.
  prefs: []
  type: TYPE_NORMAL
- en: Monolog is one of the most popular PHP logging libraries. It is a free, MIT-licensed
    library that implements the PSR-3 logging standard. It allows us to easily sends
    our logs to files, sockets, inboxes, databases, and various web services.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily install the Monolog library as a `composer` package by running
    the following console command within our projects folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: If `composer` is not an option, we can download Monolog from the GitHub at [https://github.com/Seldaek/monolog](https://github.com/Seldaek/monolog).
    Those using leading PHP frameworks, such as Symfony or Laravel, get the Monolog
    out-of-the-box.
  prefs: []
  type: TYPE_NORMAL
- en: 'The compliance to the PSR-3 logging standard also means that Monolog supports
    the logging levels described by RFC 5424, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DEBUG (100)`: Debug-level messages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INFO (200)`: Informational messages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NOTICE (250)`: Normal but significant condition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WARNING (300)`: Warning conditions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ERROR (400)`: Error conditions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CRITICAL (500)`: Critical conditions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ALERT (550)`: Action must be taken immediately'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EMERGENCY (600)`: System is unusable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These constants are defined as part of the `vendor/monolog/monolog/src/Monolog/Logger.php`
    file, alongside a practical use case example for most of them.
  prefs: []
  type: TYPE_NORMAL
- en: The core concept behind every Monolog logger instance is that the instance itself has
    a channel (name) and a stack of handlers. We can instantiate multiple loggers,
    each defining a certain channel (db, request, router, and alike). Each channel can
    combine various handlers. The handlers themselves can be shared across channels.
    The channel is reflected in the logs and allows us to easily see or filter records.
    Finally, each handler also has a formatter. The formatter normalizes and formats
    incoming records so that they can be used by the handlers to output useful information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram visualizes this logger-channel-formatter structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/097c18e6-815f-427d-8fe3-96e011f9a995.png)'
  prefs: []
  type: TYPE_IMG
- en: Monolog provides quite an extensive list of loggers and formatters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Loggers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log to files and syslog (`StreamHandler`, `RotatingFileHandler`, `SyslogHandler`,
    ...)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send alerts and e-mails (`SwiftMailerHandler`, `SlackbotHandler`, `SendGridHandler`,
    ...)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log-specific servers and networked logging (`SocketHandler`, `CubeHandler`,
    `NewRelicHandler`, ...)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging in development (`FirePHPHandler`, `ChromePHPHandler`, `BrowserConsoleHandler`,
    ...)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log to databases (`RedisHandler`, `MongoDBHandler`, `ElasticSearchHandler`,
    ...)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Formatters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LineFormatter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HtmlFormatter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JsonFormatter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '...'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A full list of Monolog loggers and formatters can be obtained through the official
    Monolog project page at [https://github.com/Seldaek/monolog](https://github.com/Seldaek/monolog).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are creating an instance of `Logger` and naming it `foggyline`.  We
    then use the `pushHandler` method to push inline instantiated instances of two
    different handlers.
  prefs: []
  type: TYPE_NORMAL
- en: The `RotatingFileHandler`  logs records to a file and creates one log file per
    day. It also deletes files older than the `$maxFiles` argument, which, in our
    example, is set to `7`. Regardless of the log file name being set to `foggyline.log`,
    the actual log file created by `RotatingFileHandler` contains the timestamp in
    it, resulting in a name such as `foggyline-2016-12-26.log`. When we think about
    it, the role of this handler is remarkable. Aside from just creating new log entries,
    it also takes care of deleting old logs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an output of our `foggyline-2016-12-26.log` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The second handler we pushed to stack, `BrowserConsoleHandler`, sends logs
    to the browser''s JavaScript console with no browser extension required. This
    works on most modern browsers that support the console API. The resulting output
    of this handler is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/464af28d-9107-4de6-9c85-dae25805202e.png)'
  prefs: []
  type: TYPE_IMG
- en: With these few simple lines of code, we have added quite an impressive set of
    logging capabilities to our application. `RotatingFileHandler` seems perfect for
    a later state analysis of a production running application, while `BrowserConsoleHandler` might
    serve as a convenient way to speed up ongoing development. Goes to say that logs
    serve a wider purpose of just logging for errors. Logging various pieces of information
    at various log levels, we can easily use the Monolog library as sort of an analytics
    bridge. All it takes is to push proper handlers to the stack, which in turn push
    logs to various destinations, such as Elasticsearch and alike.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we took a detailed look through the PHP error handling
    mechanism. PHP 7 made quite a cleanup of its error handling model by wrapping
    most of it under the `Throwable` interface. This makes it possible to catch core
    errors via `try...catch` blocks that were, prior to PHP 7, reserved for `Exception`
    only. This leaves a bit of a terminology fuzz to digest now, as we come across `Throwable`,
    `Error`, `Exception`, system-errors, user-errors, notices, warnings and alike.
    Speaking high level, we might say that any faulty state is error. More specifically,
    we now have throwables on one side and errors on the other. Throwables encompass
    thrown and catchable instances of `Error` and `Exception`, whereas, errors encompass basically
    anything not catchable as `Throwable`.
  prefs: []
  type: TYPE_NORMAL
- en: Handling faulty states would not really be complete without proper logging. While
    the built-in `error_log()` function provides enough to get us started, more robust
    solutions are available in the form of various third-party libraries. The Monolog
    library is among the most popular ones and is used across dozens of community
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, we will look into the magic methods and the enormous power they
    bring to the PHP language.
  prefs: []
  type: TYPE_NORMAL
