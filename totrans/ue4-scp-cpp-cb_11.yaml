- en: Chapter 11. Custom Materials and Shaders
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Material definition and creation tools in UE4 are fantastic, not to mention
    its real-time rendering performance. When you see your first glittering gold shader,
    you will be amazed at UE4''s Material shading capabilities, which are possible
    with a bit of math. We will show you how to use these tools through the following
    recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Modifying color using a basic Material
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying position using a Material
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shader code via Custom node
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Material function
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shader parameters and Material instances
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Glimmer
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leaves and Wind
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reflectance dependent on the viewing angle
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Randomness – Perlin noise
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shading a Landscape
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In computer graphics, a **shader** is used to color something. Traditionally,
    shaders were so called since they defined the shade that an object got based on
    its original color and light source position.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, shaders aren't really thought of as providing shading to an object
    as much as a textured, final color.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](img/00261.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Shaders are about determining the final color of an object given the light source,
    geometric positions, and initial colors (including textures, and more expensively,
    material properties).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two flavors of shader: vertex shaders and pixel shaders.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '**Vertex shaders**: Color at the vertex (point in the mesh), and smoothly shade
    from one 3-space point to another 3-space point.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pixel shaders**: Color at the pixel (point on the screen). The 3-space physical
    location of a pixel (aka fragment) is calculated using some simple math.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In UE4, we just call a shader a Material. Materials abstract the vertex and
    fragment processing pipelines into block-programmable functions, so you don't
    have to think about the GPU or code to get the graphical output you desire. You
    simply think in terms of blocks and pictures. You can construct Materials and
    build GPU shading functionality without ever writing a line of **High Level Shading
    Language** (**HLSL**), **OpenGL Shading Language** (**GLSL**), or Cg (C for graphics)
    code!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will commonly hear of three major GPU programming languages: HLSL, GLSL,
    and Cg. GLSL is OpenGL''s GPU programming language, while HLSL is Microsoft''s
    offering. After battling it out for popularity through the 90s and the first decade
    of the twenty-first century, Cg was born in an attempt to unify all GPU programming
    under it. Cg is still popular, but GLSL and HLSL also remain in popular use.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Modifying color using a basic Material
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary usage of Materials is to make surfaces appear in the color you want
    them. In your scene, you will have light sources and surfaces. Surfaces are coated
    in materials that reflect and refract the light, which you then see using the
    camera's eye. The basic thing to do with a material is to modify the color of
    a surface.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not ignore the importance of tuning your light sources to make materials
    look as you wish them to look!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Getting used to the Material Editor takes some practice, but once you get used
    to it, you can do amazing things with it. In this recipe, we'll just use some
    of the very basic functionality to construct a wooden textured material.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Texture versus Material: Keep in mind that there is a big difference between
    the terms texture and material. A texture is just an image file (such as a photograph
    of some `wood.png`); a material, on the other hand, is a combination of textures,
    colors, and mathematical formulae for describing how a surface appears under light.
    Materials will account for surface properties, such as color absorption, reflectance,
    and shininess, while a texture is just a group of colored pixels (or texels, as
    the GPU calls them).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Shaders are programmed just like normal C++ code, only far more restricted.
    There are several parameter types you can choose from. Most of them will be floats
    or packages of floats arranged in a vector format (`float`, `float2`, `float3`,
    `float4`). For things such as positions and colors, you'll use `float3` or `float4`;
    for things such as texture coordinates, you'll use `float2`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need a clean UE4 project into which you want to place your new material.
    Install the **GameTexture Materials** pack from the UE4 Marketplace (Epic Games
    Launcher Application) in your UE4 project. It contains some required textures
    that we'll need for this recipe. You also need a piece of simple geometry to show
    the results of your shader.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create a basic material, right-click in the **Content Browser,** and create
    a **Material** (available from the top four Basic Asset elements).![How to do
    it...](img/00262.jpeg)
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name your material (for example, `GoldenMaterial`), then double-click on it
    to edit it.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Welcome to the Material Editor:![How to do it...](img/00263.jpeg)
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can tell it is the Material Editor because of the presence of the Material
    output node on the right. To the left is a 3D rendered sphere demonstrating what
    your material looks like. Materials start out as a kind of coal-ish black semi-shiny
    material. We can adjust all the material parameters, believe it or not, to make
    anything from a material that emits light like the Sun, to water, or to the texture
    of a unit's armor. Let us begin by adjusting the output colors of the material
    to create a gold-colored metallic material.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the **Base Color** to yellow by right-clicking on any blank spot in the
    Material Editor window and choosing a **Constant3Vector** (which represents an
    RGB color). Adjust the color by double-clicking on the node and dragging around
    the value of the color swatches. Connect the output of the Constant3Vector to
    **Base Color,** and wait for the 3D picture on the left to reload with your new
    material's appearance. Connect the output of the Constant3Vector to the **Base
    Color** to give the material a yellow appearance as shown in the following screenshot:![How
    to do it...](img/00264.jpeg)
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a metallicness level for all channels by attaching a constant value to
    the **Metallic** input, and setting it to 1\. 1 is very metallic, and 0 is not
    metallic at all (and so will look plasticy, like the material shown in the next
    screenshot).![How to do it...](img/00265.jpeg)
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose a **Specular** value for the material, again between 0 and 1\. **Specular**
    materials are shiny, while non-specular ones are not.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose a **Roughness** value for the material. **Roughness** refers to how spread
    out the specular highlight is. If **Roughness** is high (near 1.0), then the surface
    is clay-like, with almost specular highlight. The specular highlight appears fat
    and wide near the values 0.7 or 0.8\. When roughness is near 0, then the specular
    highlight is very sharp and thin (extremely shiny/mirror-like surface).
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/00266.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The material on the left has roughness = 0, and the material on the right has
    roughness = 1.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Apply your material to an object in your scene by clicking and dragging the
    material onto the model mesh that you want the material to apply to. Alternatively,
    select a model mesh component, and the new material that you have created by name
    in the **Details** panel.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, create a light in the scene to examine your material's response properties
    further. Without a light, every material appears black (unless its an emissive
    material). Add a light via **Modes** | **Lights**.![How to do it...](img/00267.jpeg)
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modifying position using a Material
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A less common thing to do is to use a Material to modify an object's position.
    This is commonly done in things such as water shaders. We do it using the **World
    Position Offset** node inside the Material's output.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '![Modifying position using a Material](img/00268.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
- en: We can modulate the output position of a vertex using some GPU math. This lightens
    the load of rendering realistic water on the CPU by a significant amount.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a piece of geometry in your world. Construct a new shader called `Bob`,
    which we'll edit to produce a simple bobbing motion for objects rendered with
    the material.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In your new Material (named `Bob`), right-click and add **Texcoord** and **Time
    Input** nodes.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cascade the sum of the **Texcoord** (for spatial) and **Time Input** nodes through
    a `sin()` function call to create some wavy displacement. Multiply the output
    of the `sin()` function, and pass as Z-inputs to **World Displacement**.![How
    to do it...](img/00269.jpeg)
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Part of the simple water shader given in the code of `Chapter11` that produces
    the displacement.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Select **PN Triangles** under **Tessellation** | **D3D11Tessellation Mode**,
    and set **Tessellation Multiplier** in the material to 1.0.![How to do it...](img/00270.jpeg)
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Normally, specularity and translucency cannot be combined in UE4 shaders. However,
    the Surface Perpixel (experimental, limited features) Lighting Mode does allow
    you to enable both. In addition to selecting this lighting mode, you must remember
    to ensure to press [PRE0]
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: return float3( x*x, y*y, z*z );
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/00272.jpeg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
- en: Tip
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What this does is construct a 3-float vector, and return the square of *X* in
    the `x` value, the square of *Y* in the `y` value, and the square of *Z* in the
    `z` value.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: To return different values for *X*, *Y*, *Z* components of a vector type, we
    had to return a call to a `float3` or `float4` constructor. If you're not returning
    a vector type, you can just use a `return` statement (without calling a `float`
    constructor).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A custom node is really just a bit of HLSL code. Any valid HLSL code can be
    used in the code text field. A vertex or pixel shader program has several standard
    inputs in it. These standard inputs have been defined for a very long time, and
    they are the parameters you can use to change the way your geometry renders.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/00273.jpeg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
- en: HLSL and Cg have a concept called semantics, which attaches a kind of concrete
    typing to a float. This is done so that the external program calling the shader
    knows where to put which input when calling your vertex or pixel shading program.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: In the following Cg function signature, in addition to being a `float` variable,
    `inPosition` is semantically a `POSITION` typed variable `inTexcoord` a `TEXCOORD`
    typed variable, and `inColor` a `COLOR` typed variable. Inside the shader, you
    can use the variables for anything you want, the semantics are simply for routing
    the correct input to the correct variable (to make sure that the color comes in
    on the `COLOR` typed variable—otherwise, we'd have to do something like track
    the order in which the parameters are specified or something!)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: The output parameters of the function specify how the output of the shader is
    to be interpreted. Interpretation is only for the recipient of the output data
    of your program (the next step in the rendering pipeline). Inside your shader
    program you know you are just writing out a bunch of floats to the shader pipeline.
    There's nothing that forbids you from mixing different types of semantics inside
    the shader. A `COLOR` semantic variable can be multiplied by a `POSITION` semantic
    input, and sent out as a `TEXCOORD` semantic output if you so desired.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: The Material function
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As always, **modularity** is one of the best practices in programming. Material
    shaders are no exception: it is far better if your shader blocks are modular,
    and can be boxed out and identified as named functions. This way, not only are
    your shader blocks clearer, but they can also be reused in multiple Material shaders,
    or even exported to your local UE4 library for future use in other projects.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A reusable or repeatable block of shader functionality can be factored out of
    your custom material shader program. In this example, we'll write a simple function
    series—`Square`, `Square2`, `Square3`, and `Square4`—that squares input values.
    Get ready to perform the work in this recipe by opening a UE4 project and navigating
    to the **Content Browser**.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Right-click in the **Content Browser,** and select **Materials & Textures**
    | **Material Function**.![How to do it...](img/00274.jpeg)
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name your **Material Function** `Square`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on **Material Function**.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As soon as you open **Material Function**, deselect the **Output Result** node
    by left-clicking anywhere in the blank canvas space of the Material Editor. Take
    a look at the **Details** panel, and note that the Function's exposure to the
    UE4 library is optionally available:![How to do it...](img/00275.jpeg)
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Expose to Library** checkbox appears in the **Details** panel when no
    nodes are selected in the **Material Function** Editor screen.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click anywhere in the blank space in the **Material Function** editor,
    and select **Input**. Name your input. Notice how **Input** nodes are only available
    in the **Material Functions** editor, not in the normal Material editing view.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From any regular Material, invoke your function by doing one of the following:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click in the blank space, and select `MaterialFunction`, then select your
    `MaterialFunction` from the drop-down menu.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click and type the name of your **Material Function** (this requires you
    to have exposed your **Material Function** previously).
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you don't want to expose your **Material Function** to the UE4 library, then
    you have to use a `MaterialFunction` block to call your custom function.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click anywhere in the **Material Function** editor, and select **Output**.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Material Function**s are some of the most useful blocks you can create. With
    them, you can modularize your shader code to be much more neat, compact, and reusable.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Migrating your functionality to the shader library is a good idea. You can make
    your custom function appear in the function library by choosing **Expose to Library**
    in the root of the shader (provided you have nothing selected in the Material
    Editor window).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: When developing a **Material Function**, sometimes, it's helpful to change the
    Material Preview node to a node other than the output node. Preview a specific
    node's output by right-clicking the output jack for any node and selecting **Start
    Previewing Node**.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more…](img/00276.jpeg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
- en: The window in the top-left corner of the Material Editor will now show the output
    of the node you are previewing. In addition, the text **Previewing** will be added
    to the node you are previewing (if it's not the final output node). Ensure that
    **Live Preview** is enabled in the menu bar at the top of the Material Editor.
    Typically, you would want the final output to be previewed.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Shader parameters and Material instances
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A parameter to a shader is going to be a variable input to that shader. You
    can configure scalars or vectors to be used as input parameters to your shader.
    Some materials within UE4 come preprogrammed with material parameters exposed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to set up a parameter to a shader, you first need a shader with something
    that you want to modify with a variable. A good thing to modify with a variable
    is the suit color of a character. We can expose the color of the suit as a shader
    parameter that we multiply suit color by.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Construct a new Material.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the Material, create a `VectorParameter`. Give the parameter a name,
    such as `Color`. Give it a default value, such as blue or black.![How to do it...](img/00277.jpeg)
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the Material.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Content Browser**, right-click on the Material with the parameter in it,
    and select **Create Material Instance**.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on your Material instance. Check the box beside your `VectorParameter`
    name, and voila! Your `VectorParameter` is customizable without further affecting
    the base functionality of the Material.![How to do it...](img/00278.jpeg)
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further, if you change the base functionality of the Material, the Material
    instance will inherit those changes without needing any further configurations.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Material Parameters allow you to edit the value of variables sent to a Material
    without editing the Material itself. In addition, you can also change a Material
    instance's values from C++ code quite easily. This is useful for things such as
    team colors, and the like.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Glimmer
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some shader functionality is easily accessible using the standard nodes inside
    the UE4 Material Editor. You can come up with some neat speckled effects, such
    as the glittering gold shader we show you how to construct in the following recipe.
    The purpose of this recipe is to familiarize you with the Material Editor's base
    functions so that you can learn to construct your own material shaders.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create an asset (such as a treasure chest) that you want to glow, or open the
    the source code package of `Chapter11` to find the `treasureChest.fbx` model.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: What we'll do is move a plane across the object of a certain thickness *W*.
    When the plane passes over the geometry, the emissive color channel is activated,
    and a glimmer effect is created across the treasure.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: We expose several parameters to control the glimmer, including **Speed**, **Period**
    (time between glimmers), **Width**, **Gain**, **PlaneDirection**, and finally,
    **Color**.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new Material by right-clicking in the **Content Browser,** and selecting
    **Material**.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add input parameters to scale time as shown in the following image, pulling
    in a `Time` input, and making it periodic by calling `Fmod` with the period of
    time:![How to do it...](img/00279.jpeg)
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Fmod` with period will make time follow a sawtooth pattern. The value of time
    read will not increase past the **Period**, because we will keep kicking it down
    to 0 using the `fmod` operation.'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide the `OnPlane` function in a separate file. The `OnPlane` function uses
    the Plane Equation *Ax + By + Cz + D = 0* to determine if an input point is on
    a plane or not. Pass the `LocalPosition` coordinates into the `OnPlane` function
    to determine if, in the given frame, this section should be highlighted with emissive
    glow in the geometry or not.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An imaginary plane of light passes through the geometry at the speed specified
    by speed, once every **Period** seconds. The plane starts at the corner of a bounding
    box, in the direction specified by **PlaneDirection**. The plane always starts
    at the corner of the box where it will pass through the entire volume when the
    plane is shifted forward with time.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Leaves and Wind
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll write a simple particle shader demonstrating how to create
    leaves in wind. We can do so using a **Particle Emitter** combined with a Material
    Shader that "shades" our leaves to give them the appearance of blowing in the
    wind.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '![Leaves and Wind](img/00280.jpeg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To begin, you'll need a leaf texture as well as a scene in which to place the
    falling leaves. In the `Chapter11` code package, you'll find a scene called `LeavesAndTree`
    that contains a deciduous tree that you can use.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new particle emitter by right-clicking in the **Content Browser,**
    and choosing **Particle System**.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Construct a new Material shader by right-clicking in the **Content Browser**
    and choosing **Material**. Your leaf material should contain a texture of a leaf
    in the `BaseColor` component. We'll edit the **World Position** of the leaf in
    a later step to represent a jitter in motion represented by the wind.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a couple of parameters to modify the Leaves particle emitter:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Spawn** should have a nice high rate of about 100.'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Initial Location** can be distributed in a cube of 100 units per side.'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Lifetime** can be 4-5 seconds.'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Initial Velocity** should be something like ranging from (-50,-50,-100) to
    (25,25,-10).'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Initial Color** can be a distribution vector with values at green, yellow,
    and red.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Acceleration** can be (0,0,-20).'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Initial Rotation Rate** can be 0.25 (max).'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An **Orbit** parameter can be added with distribution (0,0,0) to (0,10,10).
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Wind**: Create a **Material Parameter Collection** (**MPC**) by right-clicking
    anywhere in the blank space in **Content Browser** and selecting **New Material
    Parameter Collection**.'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click to edit your new Material Parameter Collection, and enter a new
    parameter `TheWind`. Give it initial values of `(1, 1, 1)`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In your level Blueprint (**Blueprints** | **Level Blueprint**), create a client-side
    variable called `TheWind`. We will send this variable down to the GPU in each
    frame after we change it locally at the CPU. Initialize the `TheWind` variable
    to `(1, 1, 1)` in event `BeginPlay`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Event `Tick`, modify the wind to your liking. In my version of the wind,
    I have multiplied the wind in each frame by a random vector with values between
    [-1,1] in three dimensions. This gives the wind a nice jittery look per-frame.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send the wind variable update down to the GPU by choosing a **Set Vector Parameter
    Value** node immediately after you modify the wind vector. The **Set Vector Parameter
    Value** must reference a variable inside a Material Parameter Collection, so reference
    `TheWind` variable inside the Material Parameter Collection that we created in
    *STEP 4*.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify `WorldPositionOffset` by some multiple of `TheWind` each frame. Since
    `TheWind` variable varies slowly, the modification presented in each frame will
    be a slight variation of the modification presented in the last frame, producing
    a smooth leaf motion.![How to do it...](img/00281.jpeg)
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The leaves fall at more or less a constant rate with additional light gravity,
    but they are pulled around by a constantly varying wind vector inside the shader.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Reflectance dependent on the viewing angle
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The tendency of the reflectance of a material to depend on the viewing angle
    is called the **Fresnel** effect. A material may be more specular from a grazing
    angle than from a head-on angle.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '![Reflectance dependent on the viewing angle](img/00282.jpeg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Fresnel effect has magnitude at a grazing angle. This water material seen
    in the preceding screenshot has high specularity and opacity at a grazing angle
    due to use of the Fresnel effect.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: UE4 has a specially built-in capability to account for this. We'll construct
    a water shader that has view-angle dependence for translucency to give an example
    of how to use the Fresnel effect realistically.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need a new shader to which you want to add the Fresnel effect. Preferably,
    select a material that you want to look a bit different depending on the viewing
    angle.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inside your material, drive a channel (either Opacity, Specularity, or a diffuse
    color) by the output of a Fresnel node.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Fresnel node''s parameters Exponent and Base Reflect Fraction can be adjusted
    as follows:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Exponent**: Describes how Fresnel the material is. Higher values here exaggerate
    the Fresnel effect.'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Base Reflect Fraction**: Lower numbers exaggerate the Fresnel Effect. For
    a value of 1.0, the Fresnel effect will not manifest.'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a fair bit of math behind implementing the Fresnel effect, but using
    it to drive a component in a material is fairly easy, and can help you come up
    with some very beautiful looking materials.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Randomness – Perlin noise
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some shaders benefit from the ability to use random values. Each Material has
    a few nodes that can help add randomness to a shader. Randomness from a **Perlin**
    noise texture can be used to generate interesting-looking materials such as marbled
    materials. The noise can also be used to drive bump maps, height maps, and displacement
    fields for some neat effects.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Choose a material to which you'd like to add some randomness. Open the Material
    in the Material Editor, and follow the steps.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Insert a **Noise** node into your Material Editor window.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Normalize the coordinates of the object you're adding the noise to. You can
    use math such as the following to do so:![How to do it...](img/00283.jpeg)
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Subtract the minimum from each processed vertex in the system to take the object
    to sit at the origin.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Divide the vertex by the size of the object to put the object in a unit box.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Multiply the vertex value by 2 to expand the unit box from 1x1 to 2x2.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Subtract 1 from the vertex values to move the unit to being centered in the
    origin with values from *[-1,-1,-1]* to *[+1,+1,+1]*.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a value from which to draw noise. Keep in mind that noise works extremely
    well with input values between ![How to do it...](img/00284.jpeg). Outside of
    this range, Perlin's noise starts to appear snowy when zoomed out (because there
    will be too much variation in the output values over your input *x*).
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Perlin's noise can help you produce some beautiful marbly textures and patterns.
    Besides using it in graphics, you can also use Perlin noise to drive motion and
    other phenomena in a natural looking way.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Shading a Landscape
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Landscape shaders are relatively easy to construct. They allow you to specify
    multi-texturing for a very large custom piece of geometry called a Landscape.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Landscape objects are fantastic for use as a ground plane for your game world
    level. You can construct multiple landscapes in the same level using the Landscape
    tab. Access the Landscape palette in the **Modes** panel by clicking on the picture
    of a mountain, as shown in the following screenshot:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/00285.jpeg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Construct a new Landscape object by clicking on **Modes** | Landscape. Under
    the **New Landscape** heading, select the **Create New** radio button. You will
    see a green wireframe overlay proposing the new landscape. You can adjust its
    size using the **Section Size** and **Sections Per Component** settings.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The landscape will tile the textures we select for it **Section Size** * **Sections
    Per Component** * **Number of Components** times when we finally texture. You
    can keep note of this number if you want to make the landscape texture tile fewer
    times—simply divide the UV coordinates fed to the textures by the number computed
    in the preceding line.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Do not click on anything else in this dialog yet, as we still have to construct
    our Landscape Material. This is outlined in the following steps.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Content Browser** and create a new Material for use by your landscape.
    Call it `LandscapeMaterial`.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit your `LandscapeMaterial` by double-clicking on it. Right-click anywhere
    in the blank space and select a `LandscapeCoordinate` node to feed the UV coordinates
    through the textures that we're about to apply.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To reduce the tiling on the Landscape, you'll need to divide the output of the
    `LandscapeCoordinate` node by the total size of the landscape (**Section Size**
    * **Sections Per Component** * **Number of Components**) (as described in a tip
    in *Step 1*)
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a `LandscapeLayerBlend` node to the canvas. Lead the output of the node
    to the **Base Color** layer.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the `LandscapeLayerBlend` node, and add a few Layers to the element
    in the **Details** tab. This will allow you to blend between the textures using
    **Texture Painting**. Name each, and select the method for blending from among
    the following options:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By painted weight (LB Weight Blend).
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By alpha value inside the texture (LB Alpha Blend).
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过纹理内的alpha值（LB Alpha混合）。
- en: By height (LB Height Blend).
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按高度（LB高度混合）。
- en: Set other parameters for each `LandscapeLayer` you're adding as you desire.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需要设置每个添加的`LandscapeLayer`的其他参数。
- en: Feed in the textures, one for each layer of Landscape blend.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个景观混合层提供纹理。
- en: Reduce the specularity of the landscape to 0 by adding a constant 0 input to
    the Specular input.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将恒定的0输入添加到镜面输入中，将景观的高光减少到0。
- en: Save and close your material.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭您的材质。
- en: Go to the **Modes** | Landscape tab now, and select your newly created `LandscapeMaterial`
    in the drop-down menu.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，转到**模式** | 景观选项卡，并在下拉菜单中选择您新创建的`LandscapeMaterial`。
- en: Under the **Layers** section, click on the **+** icon beside each of the Landscape
    layers that are available. Create and save a Target Layer object for each Landscape
    layer that you have.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**图层**部分，点击每个可用的景观图层旁边的**+**图标。为每个景观图层创建并保存一个目标图层对象。
- en: Finally, scroll down the Landscape tab, and click on the **Create** button.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，向下滚动到景观选项卡，点击**创建**按钮。
- en: Click on the Paint tab, select a brush size and a texture to paint with, and
    begin texture painting your landscape.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击绘画选项卡，选择画笔大小和纹理，开始绘制景观纹理。
- en: How it works…
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Landscape materials can be blended either by height, or by manual artistry,
    as shown in this recipe.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 景观材质可以通过高度或手工艺进行混合，如本教程所示。
