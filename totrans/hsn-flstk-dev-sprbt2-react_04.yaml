- en: Securing and Testing Your Backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explains how to secure and test your Spring Boot backend. We will
    use the database application that we created in the previous chapter as a starting
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to secure your Spring Boot backend with Spring Boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to secure your Spring Boot backend with JWT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to test your backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spring Boot application that was created in previous chapters is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Security ([https://spring.io/projects/spring-security](https://spring.io/projects/spring-security))
    provides security services for Java-based web applications. The Spring Security
    project started in 2003 and was previously named *The Acegi Security System for
    Spring*.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Spring Security enables the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: An `AuthenticationManager` bean with an in-memory single user. The username
    is `user` and the password is printed to the console output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ignored paths for common static resource locations, such as `/css`, `/images`,
    and more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP basic security for all other endpoints.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security events published to Spring `ApplicationEventPublisher`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common low-level features are on by default (HSTS, XSS, CSRF, and so forth).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can include Spring Security in your application by adding the following
    dependency to the `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When you start your application, you can see from the console that Spring Security
    has created an in-memory user with the username `user`. The user''s password can
    be seen in the console output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/018a154a-75b2-4e7e-9eab-1a83275a29ed.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you make a `GET` request to your API endpoint, you will see that it is now
    secure, and you will get a `401 Unauthorized` error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e3bb567-1e85-40b8-b687-38e415595f20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To be able to make a successful `GET` request, we have to use basic authentication.
    The following screenshot shows how to do it with Postman. Now, with authentication
    we can see that status is 200 OK and the response is sent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/96f9e18a-e8cc-4ff4-bc61-b48ab790a4bf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To configure how Spring Security behaves, we have to add a new configuration
    class that extends the `WebSecurityConfigurerAdapter`. Create a new class called
    `SecurityConfig` in your application root package. The following source code shows
    the structure of the security configuration class. The `@Configration` and `@EnableWebSecurity`
    annotations switch off the default web security configuration and we can define
    our own configuration in this class. Inside the `configure(HttpSecurity http)` method,
    we can define which endpoints in our application are secured and which are not.
    We actually don''t need this method yet because we can use the default settings
    where all endpoints are secured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We also can add in-memory users to our application by adding the `userDetailsService()`
    method into our `SecurityConfig` class. The following is the source code of the
    method and it will create an in-memory user with the username `user` and password
    `password`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The usage of in-memory users is good in the development phase, but the real
    application should save the users in the database. To save the users to the database,
    you have to create a user entity class and repository. Passwords shouldn''t be
    saved to the database in plain text format. Spring Security provides multiple
    hashing algorithms, such as BCrypt, that you can use to hash passwords. The following
    steps show how to implement that:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class called `User` in the `domain` package. Activate the `domain`
    package and right click your mouse. Select New | Class from the menu and give
    the name `User` to a new class. After that, your project structure should look
    like the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a149cf61-44de-432d-9180-a74600669ab2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Annotate the `User` class with the `@Entity` annotation. Add the class fields—ID,
    username, password, and role. Finally, add the constructors, getters, and setters. 
    We will set all fields to be nullable and that the username must be unique, by
    using the `@Column` annotation. See the following `User.java` source code of the
    fields and constructors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the rest of the `User.java` source code with the getters and
    setters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Create a new class called `UserRepository` in the `domain` package. Activate
    the `domain` package and right click your mouse. Select New | Class from the menu
    and give the name `UserRepository` to the new class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code of the repository class is similar to what we have done in
    the previous chapter, but there is one query method, `findByUsername`, that we
    need in the next steps. See the following `UserRepository` source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create a class that implements the `UserDetailsService` interface
    provided by Spring Security. Spring Security uses this for user authentication
    and authorization. Create a new package in the root package called `service`. Activate
    the root package and right click your mouse. Select New | Package from the menu
    and give the name `service` to a new package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c4fbe47c-e3df-4bae-8125-ae4e9e40db61.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a new class called `UserDetailServiceImpl` in the `service` package
    we just created. Now your project structure should look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/65caec36-f8b2-485c-a505-120a0a443068.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have to inject the `UserRepository` class into the `UserDetailServiceImpl` class
    because that is needed to fetch the user from the database when Spring Security
    handles authentication. The `loadByUsername` method returns the `UserDetails` object,
    which is needed for authentication. Following is the source code of `UserDetailServiceImpl.java`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In our security configuration class, we have to define that Spring Security
    should use users from the database instead of in-memory users. Delete the `userDetailsService()` method
    from the `SecurityConfig` class to disable in-memory users. Add a new `configureGlobal` method
    to enable users from the database. We shouldn''t ever save the password as plain
    text to the database. Therefore, we will define a password hashing algorithm in
    the `configureGlobal` method. In this example, we are using the BCrypt algorithm.
    This can be easily implemented with the Spring Security `BCryptPasswordEncoder` class.
    Following is the `SecurityConfig.java` source code. Now, the password must be
    hashed using BCrypt before it''s saved to the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can save a couple of test users to the database in our `CommandLineRunner`.
    Open the `CardatabaseApplication.java` file and add following code at the beginning
    of the class to inject `UserRepository` into the main class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the users to the database with hashed passwords. You can use any BCrypt
    calculator found on the internet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'After running your application, you see that there is now a `user` table in
    the database and two user records are saved:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2acbb3e-93d2-4b8a-9033-7da7536584c7.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, you will get a `401 Unauthorized` error if you try to send a `GET` request
    to the `/api` endpoint without authentication. You should authenticate to be able
    to send a successful request. The difference to the previous example is that we
    are using the users from the database to authenticate.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see a `GET` request to the `/api` endpoint using the `admin` user in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e5bc254-4f49-4fef-a52e-0c3c8146f97b.png)'
  prefs: []
  type: TYPE_IMG
- en: Securing your backend using JWT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we covered how to use basic authentication with the
    RESTful web service. That is not usable when we are going to develop our own frontend
    with React. We are going to use the **JSON Web Tokens** (**JWT**) authentication
    in our application. JWT is a compact way to implement authentication in modern
    web applications. JWT is really small in size and therefore it can be sent in
    the URL, in the `POST` parameter, or inside the header. It also contains all required
    information about the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JSON web token contains three different parts separated by dots. The first
    part is the header that defines the type of the token and the hashing algorithm.
    The second part is the payload that, typically, in the case of authentication,
    contains information about the user. The third part is the signature that is used
    to verify that the token hasn''t been changed along the way. You can see the following
    example of a JWT token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram shows the main idea of the JWT authentication process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5489d53-929b-4830-af03-89e4814bbf9f.png)'
  prefs: []
  type: TYPE_IMG
- en: After successful authentication, the requests sent by the user should always
    contain the JWT token that was received in the authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the Java JWT library ([https://github.com/jwtk/jjwt](https://github.com/jwtk/jjwt)),
    which is the JSON Web Token library for Java and Android; therefore, we have to
    add the following dependency to the `pom.xml` file. The JWT library is used for
    creating and parsing JWT tokens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following steps show how to enable JWT authentication in our backend:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class called `AuthenticationService` in the `service` package.
    In the beginning of the class we will define a few constants; `EXPIRATIONTIME`
    defines the expiration time of the token in milliseconds. `SIGNINGKEY` is an algorithm-specific
    signing key used to digitally sign the JWT. You should use a base64 encoded string.
    PREFIX defines the prefix of the token and the Bearer schema is typically used.
    The `addToken` method creates the token and adds it to the request''s `Authorization`
    header. The signing key is encoded using the SHA-512 algorithm. The method also
    adds `Access-Control-Expose-Headers`  to the header with the `Authorization` value.
    This is needed because we are not able to access the `Authorization` header through
    a JavaScript frontend by default. The `getAuthentication` method gets the token
    from the response `Authorization` header using the `parser()` method provided
    by the `jjwt` library. The whole `AuthenticationService` source code can be seen
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will add a new simple POJO class to keep credentials for authentication.
    Create a new class called `AccountCredentials` in the `domain` package. The class
    has two fields—`username` and `password`. The following is the source code of
    the class. This class doesn''t have the `@Entity` annotation because we don''t
    have to save credentials to the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use filter classes for login and authentication. Create a new class
    called `LoginFilter`  in the root package that handles `POST` requests to the `/login`
    endpoint. The `LoginFilter` class extends the Spring Security `AbstractAuthenticationProcessingFilter`,
    which requires that you set the `authenticationManager` property. Authentication
    is performed by the `attemptAuthentication` method. If the authentication is successful,
    the `succesfulAuthentication` method is executed. This method will then call the `addToken`
    method in our service class and the token will be added to the `Authorization`
    header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new class called `AuthenticationFilter` in the root package. The class
    extends `GenericFilterBean`, which is a generic superclass for any type of filter.
    This class will handle authentication in all other endpoints except `/login`.
    The `AuthenticationFilter` uses the `addAuthentication` method from our service
    class to get a token from the request `Authorization` header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to make changes to our `SecurityConfig` class''s `configure`
    method. There, we define that the `POST` method request to the `/login` endpoint
    is allowed without authentication and that requests to all other endpoints need
    authentication. We also define the filters to be used in the `/login` and other
    endpoints by using the `addFilterBefore` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also add a **CORS** (**Cross-Origin Resource Sharing**) filter in our
    security configuration class. This is needed for the frontend, that is sending
    requests from the other origin. The CORS filter intercepts requests, and if these
    are identified as cross origin, it adds proper headers to the request. For that,
    we will use Spring Security''s `CorsConfigurationSource` interface. In this example,
    we will allow all HTTP methods and headers. You can define the list of allowed
    origins, methods, and headers here, if you need more finely graded definition.
    Add the following source into your `SecurityConfig` class to enable the CORS filter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, after you run the application, we can call the `/login` endpoint with
    the `POST` method and, in the case of a successful login, we will receive a JWT
    token in the `Authorization` header:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6b3b37a-a2ca-40b9-aa7c-20c512c6dc47.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After successful login, we can call the other RESTful service endpoints by
    sending the JWT token received from the login in the `Authorization` header. See
    the example in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2b23561-369a-4d47-9d19-35ad998e3073.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, all the functionalities that are needed have been implemented to our backend.
    Next, we will continue with backend unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: Testing in Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Spring Boot test starter package is added to `pom.xml` by Spring Initializr
    when we created our project. That is added automatically without any selection
    in the Spring Initializr page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The Spring Boot test starter provides lot of handy libraries for testing, such
    as JUnit, Mockito, AssertJ, and more. If you look, your project structure already
    has its own package created for test classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39d91eed-cc54-42bb-8a37-3db63c79f0bf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By default, Spring Boot uses an in-memory database for testing. We are now
    using MariaDB, but H2 can also be used for testing by adding the following dependency
    to the `pom.xml` file. The scope defines that the H2 database will be used only
    for running tests; otherwise, the application will use the MariaDB database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If you also want to use the default database for testing, you can use the `@AutoConfigureTestDatabase`
    annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Creating unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For unit testing, we are using a JUnit, which is a popular Java-based unit
    testing library. The following source code shows the example skeleton of the Spring
    Boot test class. The `@SpringBootTest` annotation specifies that the class is
    a regular test class that runs Spring Boot based tests. The `@Test` annotation
    before the method defines to JUnit that the method can be run as a test case.
    The `@RunWith(SpringRunner.class)` annotation provides Spring `ApplicationContext`
    and get beans injected into your test instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we will create our first test case, which will test the major functionality
    of your application before creating any formal test cases. Open the `CardatabaseApplicationTest`
    test class that has already been made for your application. There is one test
    method called `contextLoads` where we will add the test. The following test checks
    that the instance of controller was created and injected successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To run tests in Eclipse, activate the test class in the Project Explorer and
    right-click your mouse. Select Run  As | JUnit test from the menu. You should
    now see the JUnit tab in the lower part of the Eclipse workbench. The test results
    are shown in this tab and the test case has been passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/22eec50f-35aa-4b81-ad41-ade87dd66484.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we will create unit tests for our car repository to test CRUD operations.
    Create a new class called `CarRepositoryTest` in the root test package. Instead
    of the `@SpringBootTest` annotation, the `@DataJpaTest` can be used if the test
    focuses only on JPA components. When using this annotation the H2 database, Hibernate,
    and Spring Data are configured automatically for testing. SQL logging will be
    also turned on. The tests are transactional by default and roll back at the end
    of the test case.  `TestEntityManager` is used to handle the persist entities
    and it is designed to be used in testing. You can see in the following, the source
    code of the JPA test class skeleton:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We will add out first test case to test the addition of a new car to database.
    A new `car` object is created and saved to the database with the `persistAndFlush`
    method provided by `TestEntityManager`. Then, we check that the car ID cannot
    be null if it is saved successfully. The following source code shows the test
    case method. Add the following method code into your `CarRepositoryTest` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The second test case will test the deletion of cars from the database. A new
    `car` object is created and saved to the database. Then, all cars are deleted
    from the database, and finally, the `findAll()` query method should return an
    empty list. The following source code shows the test case method. Add the following
    method code into your `CarRepositoryTest` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the test cases and check on the Eclipse JUnit tab that the tests were passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f5825b7-bea8-459e-9302-7e19c896e6fe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we will show how to test your RESTful web service JWT authentication
    functionality. For testing the controllers or any endpoint that is exposed, we
    can use a `MockMvc`. By using the `MockMvc`, the server is not started but the
    tests are performed in the layer where Spring handles HTTP requests, and therefore
    it mocks the real situation. `MockMvc` provides the `perform` method to send the
    requests. To test authentication, we have to add credentials to the request body.
    We perform two requests; the first has the correct credentials and we check that
    the status is OK. The second request contains incorrect credentials and we check
    that we get a 4XX HTTP error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we run the authentication tests, we can see that the test passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6976c26-8eda-4b6c-a6a6-7aaf5ff0508e.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we have covered the basics of testing in the Spring Boot application, and
    you should have the knowledge required to implement more test cases for your application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we focused on securing and testing the Spring Boot backend.
    Securing was first done with Spring Security. The frontend will be developed with
    React in upcoming chapters; therefore, we implemented JWT authentication, which
    is a lightweight authentication method suitable for our needs. We also covered
    the basics of testing a Spring Boot application. We used JUnit for unit testing
    and implemented test cases for JPA and RESTful web service authentication. In
    the next chapter, we will setup the environment and tools for the frontend development.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is Spring Security?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you secure your backend with Spring Boot?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is JWT?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you secure your backend with JWT?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you create unit tests with Spring Boot?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you run and check the results of unit tests?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Packt has other great resources for learning about Spring Security and Testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/application-development/spring-security-third-edition](https://www.packtpub.com/application-development/spring-security-third-edition)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/web-development/mastering-software-testing-junit-5](https://www.packtpub.com/web-development/mastering-software-testing-junit-5)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
