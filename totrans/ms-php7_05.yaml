- en: The Realm of CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A great deal of modern application development evolves around visible bits and
    pieces. Whether we are talking about the server infrastructure, development tools,
    or the resulting application itself, graphical interfaces dominate our experience
    nowadays. While the diversity and overall list of available GUI tools seems endless,
    the console still remains an important part of development that any self-respectful
    developer should be familiar with.
  prefs: []
  type: TYPE_NORMAL
- en: There are countless reasons why the console is simply the right tool for the
    job. Take large database backups, for example. Trying to backup gigabytes of MySQL
    data via the GUI tool is likely to result in a complete failure or a corrupt backup
    file, whereas the console-based `mysqldump` tool is impervious to the size of
    the backup or the time it takes for it to execute. Things such as large and time-consuming
    data imports, data exports, data synchronizations, and so on are common operations
    of many PHP applications. These are just some of the operations we would want
    to move away from the browser and into the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will take a look at the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding PHP CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Console component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input/output streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Process control:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ticks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alarms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiprocessing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding PHP CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with the console in PHP is quite easy via the help of PHP CLI SAPI,
    or just PHP CLI for short. PHP CLI was first introduced in PHP 4.2.0 as an experimental
    feature, and, soon after, it became fully supported and enabled by default in
    the later versions of PHP. The great thing about it is that it is available on
    all popular operating systems (Linux, Windows, OSX, Solaris). This makes it easy
    to write console applications that execute pretty much on any platform.
  prefs: []
  type: TYPE_NORMAL
- en: Check out [https://en.wikipedia.org/wiki/Command-line_interface](https://en.wikipedia.org/wiki/Command-line_interface)
    and [https://en.wikipedia.org/wiki/Server_Application_Programming_Interface](https://en.wikipedia.org/wiki/Server_Application_Programming_Interface)
    for more elaborate descriptions of general CLI and SAPI abbreviations.
  prefs: []
  type: TYPE_NORMAL
- en: PHP CLI is not the only SAPI interface supported by PHP. Using the `php_sapi_name()`
    function, we can get a name of the current interface that PHP is using. Other
    possible interfaces include aolserver, apache, apache2handler, cgi, cgi-fcgi,
    cli, cli-server, continuity, embed, fpm-fcgi, and others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running a simple `php -v` command within our operating system console should
    give us an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This should serve as confirmation that PHP CLI SAPI is up and running. The
    CLI version of PHP has its own `php.ini` configuration, separate from other SAPI
    interfaces. Running the `php --ini` command on console will expose the following
    details about the currently used `php.ini` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see the location of the main configuration file (`php.ini`) and
    extension-specific configuration files. Chaining the configuration of these configuration
    files takes immediate effect, as they are loaded each time we invoke PHP.
  prefs: []
  type: TYPE_NORMAL
- en: The Console component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A number of popular PHP frameworks and platforms utilize some sort of console
    application in order to assist with development, deployment, and maintenance of
    our projects. The Symfony framework, for example, comes with its own console application
    empowered with dozens of nifty commands. These can be accessed by executing the
    `php bin/console` command within the root directory of a Symfony project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/086af8a0-b484-4fb2-bec4-888e392047ae.png)'
  prefs: []
  type: TYPE_IMG
- en: Each of the listed commands executes a very specific purpose; therefore, assisting
    our project in various ways. While the Symfony framework installation and overall
    details are out of the scope of this book, there is a component within it that
    we are interested in. The Console component, while part of the Symfony framework,
    can also be used as a standalone component to build these types of console applications.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Console component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Console component is available in two flavors:'
  prefs: []
  type: TYPE_NORMAL
- en: Composer package (`symfony/console` on Packagist)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git repository ([https://github.com/symfony/console](https://github.com/symfony/console))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Given that Composer is a de facto standard when it comes to dealing with PHP
    components, we will use the `composer require` command to quickly kick off our
    first console application, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this command triggers the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b36d8c6f-3084-456e-b8b1-e3e52611e179.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Upon completion, Composer generates the following structure within our `foggyline`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/395e36f6-a466-45c8-a0ee-8034db47b8f3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'All it takes for us now is to create an application entry file, let''s say, `app.php`,
    and include the `vendor/autoload.php` file generated by Composer, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/af3d0eb5-355b-41f4-8a36-59865f0a107f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The very first line of our file, known as *shebang*, contains the instructions
    required for autodetection of the type of script. While the line itself is not
    really necessary, it makes a difference between normally running `php app.php`
    or just `./app.php` in order to execute our application script. Following the
    *shebang* line is the PHP code that deals with the inclusion of `autoload.php` and
    instantiation of the `Console\Application` class. The `Console\Application` class
    accepts two parameters: the name of the application and the version we wish to
    assign to it. In between instantiating and running the app, we have a few commented-out
    lines that merely demonstrate where we would normally register our individual
    application commands.'
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about the *shebang* character sequence, check out the Wikipedia
    article at [https://en.wikipedia.org/wiki/Shebang_(Unix)](https://en.wikipedia.org/wiki/Shebang_(Unix)).
  prefs: []
  type: TYPE_NORMAL
- en: 'To put the *shebang* line into effect, the `app.php` file needs to be flagged
    as :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With these four lines of PHP code in place, we already have enough to execute
    our
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3c023b4e-5e48-4cb3-9f95-af17274c9224.png)'
  prefs: []
  type: TYPE_IMG
- en: The output comes out colored and nicely formatted, just as we would expect from
    modern console applications. This is merely but a fraction of things that the
    Console component takes care for us. With this, we conclude our Console component
    setup. We can now go ahead and start registering our application commands using
    the `add()` method of an `$app` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a console command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our *barebone* console application set up, let''s create three
    commands to handle the following imaginary actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Customer register
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customer status set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customer export
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The word imaginary simply flags that we will not actually concern ourselves
    with the inner details of the executed commands, as our focus is understanding
    how to reuse the Console component.
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating `CustomerRegisterCommand.php`, `CustomerStatusSetCommand.php`,
    and `CustomerExportCommand.php` within our project's `src/Foggyline/Console/Command/`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: '`CustomerRegisterCommand.php` file has the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`CustomerStatusSetCommand.php` file has the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`CustomerExportCommand.php` file has the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that all three commands extend `Symfony\Component\Console\Command\Command`
    and provide their own implementation of the `configure()` and `execute()` methods.
    The `configure()` method is sort of like the constructor, where we would place
    our initial configuration, such as name of the command, its description, options,
    arguments, and so on. The `execute()` method is where our actual command logic
    needs to be implemented, or called if implemented elsewhere. With these three
    commands in place, we need to go back to the `app.php` file and modify its content
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Compared to our initial `app.php` file, there are a few changes here. Notice
    the line where we require the `autoload.php` file. If we actually took a look
    at that file, we would see it returns an instance of the `Composer\Autoload\ClassLoader`
    class. This is the Composer's PSR-0, PSR-4, and classmap class loader that we
    can use to our advantage to load our commands. This is exactly what the `$loader->add('Foggyline'...`
    line is doing. Finally, we register our newly created commands using the application's
    `add()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these changes in place, executing our application yields the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/079ca9bf-07c3-4f8f-bcd3-5ad1163b7797.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Our three commands are now appearing on the list of available commands. The
    `name` and `description` values we set within the command class `configure()`
    method are being shown for each command. We can now easily execute one these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7cdae145-6fd9-4045-8634-f60bddbda2b7.png)'
  prefs: []
  type: TYPE_IMG
- en: The `Customer disabled.` label confirms the execution of our `CustomerStatusSetCommand`
    `execute()` method. While the overall concept of our console application and its
    commands was fairly easy to grasp so far, our commands are hardly useful at the
    moment, as we are not passing any inputs to them.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with inputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Making practical and useful commands usually requires the ability to pass on
    the dynamic information from the operating system console to our application command. The
    Console component differentiates two types of inputs--`arguments` and `options`:'
  prefs: []
  type: TYPE_NORMAL
- en: Arguments are ordered, space-separated (`John Doe`), optional or required, string
    types of information. Assignment of arguments comes after the command name itself.
    We use the `addArgument()` method of the `Symfony\Component\Console\Command\Command` instance
    to assign arguments to our custom command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Options are unordered, two-dashes-separated (`--name=John --surname=Doe`), always
    optional, assigned type of information. The assignment of options comes after
    the command name itself. We use the `addOption()` method of the `Symfony\Component\Console\Command\Command` instance
    to assign options to our custom command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `addArgument()` method accepts four parameters, as per the following synopsis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Whereas, the `addArgument()` method parameters have the following meanings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$name`: This is the argument name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$mode`: This is the argument mode, which can be `InputArgument::REQUIRED`
    or `InputArgument::OPTIONAL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$description`: This is the description text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$default`: This is the default value (for the `InputArgument::OPTIONAL` mode
    only)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `addOption()` method accepts five parameters, as per the following synopsis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Whereas, the `addOption()` method parameters have the following meanings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$name`: This is the option name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$shortcut`: This is the shortcut (it can be `null`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$mode`: This is the option mode, which is one of the `InputOption::VALUE_*`
    constants'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$description`: This is the description text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$default`: This is the default value (must be `null` for `InputOption::VALUE_NONE`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could easily build our commands such that they use the two input types together,
    as they do not exclude each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and modify our `src\Foggyline\Console\Command\CustomerRegisterCommand.php`
    file with the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Our modifications mainly extend the *group use* declaration and the `configure()`
    method. Within the `configure()` method, we are utilizing the `addArgument()`
    and `addOption()` instance methods to add the number of inputs to our command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Trying to execute our console command now, with no arguments, would trigger `RuntimaException`,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/db5aefff-19f3-4d51-8cbf-ae4c4d7486b7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The error is descriptive enough to provide a list of missing arguments. However,
    it does not trigger our own argument and option descriptions. To get those to
    show up, we could easily run a `./app.php customer:register --help` command. This
    tells the Console component to show the command details we specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/40788798-82a1-4754-a4e8-6e6e03806baa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we see the exact descriptions behind our arguments and options, we
    can issue a more valid command that would not trigger an error, such as `./app.php
    customer:register John Doe --log=true`. Passing all required arguments progresses
    us to the `execute()` method, which has been modified to do a raw dump of the
    passed on values for our inspection, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3b6b941a-3d2b-4c9c-b7a2-551bc977b841.png)'
  prefs: []
  type: TYPE_IMG
- en: We now have a simple, but working version of a command that is able to accept
    inputs. The `addArgument()` and `addOption()` methods made it really easy to define
    and describe these inputs via a single expression. The Console component has proven
    itself to be a really handy addition to our console application.
  prefs: []
  type: TYPE_NORMAL
- en: Using Console component helpers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding arguments and options is a first step towards utilizing the Console
    component. Once we understand how to deal with inputs, we turn our attention to
    other, more advanced features. The helpers feature helps us ease the common tasks,
    such as format outputs, show running processes, show updatable progress information,
    provide interactive QA process, display tabular data, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are several Console component helpers available for us to use:'
  prefs: []
  type: TYPE_NORMAL
- en: Formatter Helper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process Helper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Progress Bar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Question Helper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debug Formatter Helper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see the full helper implementations within our project's `vendor\symfony\console\Helper`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: To showcase the ease of use of these helpers, let's go ahead and implement the
    simple *progress bar* and *table* helper within our *customer export* command.
  prefs: []
  type: TYPE_NORMAL
- en: 'We do so by modifying the `execute()` method of the `src\Foggyline\Console\Command\CustomerExportCommand.php`
    class file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We start our code by adding a fake customer data. We then instantiate `ProgressBar`,
    passing it the count of entries in our fake customer data array. The progress
    bar instance requires explicit `start()`, `advance()`, and `finish()` method calls
    to actually advance the progress bar. Once the progress bar is done, we instantiate `Table`,
    passing it proper headers and the row data from our customer data array.
  prefs: []
  type: TYPE_NORMAL
- en: The console component helpers provide great deal of configuration options. To
    find out more, check out [http://symfony.com/doc/current/components/console/helpers/index.html](http://symfony.com/doc/current/components/console/helpers/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'With the preceding changes in place, triggering the `./app.php customer:export`
    command on console should now give the following output whilst the command is
    executing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c98e8d9b-b290-41b5-904e-9914b59fbd21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will first see the progress par kicking in, showing the exact progress.
    Once the progress bar is done, the table helper kicks in, making for the final
    output, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/23d67443-8fce-4e45-a208-fe95408d7e53.png)'
  prefs: []
  type: TYPE_IMG
- en: Using helpers impacts our console application user experience for better. We
    are now able to write applications that provide informative and structured feeedback
    for user.
  prefs: []
  type: TYPE_NORMAL
- en: Input/output streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Quite early in development, every programmer stumbles upon the **streams**
    term. This seemingly frightening term represents a form of data. Unlike the typical
    finite type of data, streams represent a potentially unlimited *sequence* of data.
    In PHP terms, a stream is a resource object exhibiting streamable behavior. Using
    various wrappers, the PHP language supports a wide range of streams. The `stream_get_wrappers()`
    function can retrieve a list of all the registered stream wrappers available on
    the currently running system, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`php`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`file`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`glob`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ftp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zip`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compress.zlib`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compress.bzip2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`https`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ftps`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`phar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The list of wrappers is quite extensive, but not finite. We can also register
    our own wrappers using the `stream_wrapper_register()` function. Each wrapper
    tells the stream how to handle specific protocols and encodings. Each stream is
    therefore accessed through the `scheme://target` syntax, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`php://stdin`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`file:///path/to/file.ext`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`glob://var/www/html/*.php`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data://text/plain;base64,Zm9nZ3lsaW5l`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://foggyline.net/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `scheme` part of the syntax indicates the name of the wrapper to be used,
    while the `target` part depends on the wrapper used. As a part of this section,
    we are interested in the `php` wrapper and its target values because they deal
    with the standard streams.
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard streams are the following three I/O connections made available
    to all programs:'
  prefs: []
  type: TYPE_NORMAL
- en: standard input (`stdin`) - file descriptor `0`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: standard output (`stdout`) - file descriptor `1`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: standard error (`stderr`) - file descriptor `2`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The file descriptor is an integer representing a handle used to access an I/O resource.
    As a part of the POSIX application programming interface, Unix processes are expected
    to have these three file descriptors. Knowing the file descriptor value, we could
    use `php://fd` to gain direct access to the given file descriptor, such as `php://fd/1`.
    However, there is a more elegant way of doing it.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about POSIX, check out [https://en.wikipedia.org/wiki/POSIX](https://en.wikipedia.org/wiki/POSIX).
  prefs: []
  type: TYPE_NORMAL
- en: 'Out of the box, the PHP CLI SAPI provides three constants for these three standard
    streams:'
  prefs: []
  type: TYPE_NORMAL
- en: '`define(''STDIN'', fopen(''php://stdin'', ''r''));`: This represents an already
    opened stream to `stdin`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`define(''STDOUT'', fopen(''php://stdout'', ''w''));`: This represents an already
    opened stream to `stdout`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`define(''STDERR'', fopen(''php://stderr'', ''w''));`: This represents an already
    opened stream to `stderr`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following simple code snippet demonstrates the use of these standard streams:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing it, we would first see Type something: on screen, after which, we would
    need to provide a string and hit *Enter*, which finally gives the following an
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d6efa063-fe02-445e-b39b-27e0de5ba669.png)'
  prefs: []
  type: TYPE_IMG
- en: While the example itself is ultimately simplified, it does showcase the ease
    of obtaining the stream handles. What we do with those streams, further depends
    on the functions that utilize the streams (`fopen()`, `fputs()`, and so on) and
    the actual stream functions.
  prefs: []
  type: TYPE_NORMAL
- en: PHP provides over forty stream functions, as well as the `streamWrapper` class
    prototype. These provide us with a means of creating and manipulating streams
    in pretty much any way imaginable. Check out [http://php.net/manual/en/book.stream.php](http://php.net/manual/en/book.stream.php)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Process control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building CLI applications quite often implies working with the system processes.
    PHP provides a **powerful process control extension** called **PCNTL**. The extension
    allows us to handle process creation, program execution, signal handling, and
    process termination. It only works on Unix-like machines, where PHP is compiled
    with the `--enable-pcntl` configuration option.
  prefs: []
  type: TYPE_NORMAL
- en: 'To confirm that PCNTL is available on our system, we can execute the following
    console command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Given the power it bares, the use of the PCNTL extension is discouraged in production
    web environments. Writing PHP daemons scripts for command-line applications is
    what we want to use it for.
  prefs: []
  type: TYPE_NORMAL
- en: To start putting things into perspective, let's go ahead and see how we would use
    the PCNTL features to handle process signals.
  prefs: []
  type: TYPE_NORMAL
- en: Ticks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'PCNTL relies on ticksfor its signal handling callback mechanism. The official
    definition ([http://php.net/manual/en/control-structures.declare.php](http://php.net/manual/en/control-structures.declare.php))
    of a tick says:'
  prefs: []
  type: TYPE_NORMAL
- en: A tick is an event that occurs for every N low-level tickable statements executed
    by the parser within the declare block. The value for N is specified using ticks=N
    within the declare block's directive section.
  prefs: []
  type: TYPE_NORMAL
- en: To elaborate on that, a tick is an event. Using the `declare()` language construct,
    we control how many statements it takes to set off a tick. We then use `register_
    tick_ function()` to execute our function upon each *fired tick*. Ticks are basically
    a side-effect of a number of evaluated expressions; the side effect we can react
    to with our custom functions. While most of the statements are tickable, certain condition
    expressions and argument expressions are not.
  prefs: []
  type: TYPE_NORMAL
- en: A *statement* is executed, while an *expression* is evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alongside the `declare()` language construct, PHP provides the following two
    functions to work with ticks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`register_ tick_ function()`: This registers a function to be executed on each
    tick'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unregister_ tick_ function()`: This deregisters a previously registered function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following example, where the `declare()` construct
    uses the `{}` blocks to wrap the expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is pretty much what we would expect, based on the carefully wrapped expressions
    within the `{}` blocks of the `declare()` construct. A tick is being nicely fired
    every second iteration of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following example, where the `declare()` construct
    is added as the first line of the PHP script without any `{}` blocks to wrap the
    expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The output here is not what we might expect at first. The *N* value, `ticks
    = 2`, does not seem to be respected as the tick seems to be fired after each and
    every statement. Even the last finished output is followed by one more tick.
  prefs: []
  type: TYPE_NORMAL
- en: Ticks provide the type of feature that may be useful to run monitoring, cleanup,
    notification, debugging, or other similar tasks. They should be used with utmost care,
    or else we might get some unexpected results, as we saw in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: Signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Signals are asynchronous messages sent to a running process within the POSIX-compliant
    operating systems. They can be sent both by users of programs. The following is
    a list of Linux-supported standard signals:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SIGHUP`: Hangup (POSIX)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGINT`: Terminal interrupt (ANSI)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGQUIT`: Terminal quit (POSIX)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGILL`: Illegal instruction (ANSI)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGTRAP`: Trace trap (POSIX)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGIOT`: IOT Trap (4.2 BSD)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGBUS`: BUS error (4.2 BSD)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGFPE`: Floating point exception (ANSI)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGKILL`: Kill (can''t be caught or ignored) (POSIX)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGUSR1`: User-defined signal 1 (POSIX)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGSEGV`: Invalid memory segment access (ANSI)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGUSR2`: User-defined signal 2 (POSIX)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGPIPE`: Write on a pipe with no reader, Broken pipe (POSIX)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGALRM`: Alarm clock (POSIX)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGTERM`: Termination (ANSI)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGSTKFLT`: Stack fault'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGCHLD`: Child process has stopped or exited, changed (POSIX)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGCONT`: Continue executing, if stopped (POSIX)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGSTOP`: Stop executing (can''t be caught or ignored) (POSIX)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGTSTP`: Terminal stop signal (POSIX)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGTTIN`: Background process trying to read, from TTY (POSIX)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGTTOU`: Background process trying to write, to TTY (POSIX)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGURG`: Urgent condition on socket (4.2 BSD)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGXCPU`: CPU limit exceeded (4.2 BSD)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGXFSZ`: File size limit exceeded (4.2 BSD)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGVTALRM`: Virtual alarm clock (4.2 BSD)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGPROF`: Profiling alarm clock (4.2 BSD)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGWINCH`: Window size change (4.3 BSD, Sun)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGIO`: I/O now possible (4.2 BSD)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGPWR`: Power failure restart (System V)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user can initiate a signal message from the console manually using the `kill` command,
    such as `kill -SIGHUP 4321`.
  prefs: []
  type: TYPE_NORMAL
- en: The signals `SIGKILL` and `SIGSTOP` are the ultimate kill switch as they cannot
    be caught, blocked, or ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'PHP provides several functions to work with signals, some of which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pcntl_ signal()`: This installs a signal handler'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pcntl_ signal_ dispatch()`: This calls signal handlers for pending signals'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pcntl_ sigprocmask()`: This sets and retrieves blocked signals'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pcntl_ sigtimedwait()`: This waits for signals, with a timeout'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pcntl_ sigwaitinfo()`: This waits for signals'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `pcntl_ signal()` function is the most interesting one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example utilizing the `pcntl_ signal()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We start our code with the *declare ticks* definition. Without it, the installation
    of our custom `signalHandler` function via the `pcntl_signal()` function would
    have no effect. The `pcntl_signal()` function itself installs the `signalHandler()`
    function for the `SIGINT` signal. Running the preceding code will yield the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `^C` string indicates the moment when we hit *Ctrl* + *C* on our keyboard. We
    can see that it was immediately followed by a `Triggered signalHandler: *N*` output
    from our custom `signalHandler()` function. While we were successful at catching
    the `SIGINT` signal, we did not follow up and actually execute it once we were
    done with our `signalHandler()` function, which left the signal to be ignored,
    and allowed our program to continue executing. As it turns out, we just killed
    the default operating system functionality by allowing the program to keep executing
    after *Ctrl* + *C* is pressed.'
  prefs: []
  type: TYPE_NORMAL
- en: How do signals help us out? First of, a simple `exit;` call within the `signalHandler()`
    function would sort out the broken functionality in this case. Beyond that, we
    are left with a powerful mechanism where we get to tap into (almost) any system
    signal and execute any arbitrary code we choose to.
  prefs: []
  type: TYPE_NORMAL
- en: Alarms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `pcntl_alarm()` function enriches the PHP signals functionality by providing
    an alarm clock for delivery of a signal. Simply put, it creates a timer that sends
    a `SIGALRM` signal to the process after a given number of seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Once the alarm is fired, the signal handler function kicks in. Once the signal
    handler function code is done executing, we are taken back to the point in code
    where the application stopped before jumping into a signal handler function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using the `pcntl_signal()` function to register `signalHandler` as a
    signal handler function for the `SIGALRM` signal. We then call the `pcntl_alarm()`
    function, passing it the integer value of 7 seconds. The while loop is set to
    merely output something to the console, in order for us to understand the alarm
    behavior more easily. Once executed, the following output is shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the `Triggered signalHandler: 14` string is shown only once.
    This is because the alarm was triggered only once. The timing shown in the output
    indicates the exact seven seconds of delay between the first loop iteration and
    the alarm. We could easily fire another `pcntl_alarm()` function call within the `signalHandler()`
    function itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This would then transform our output into something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Though specifying multiple alarms is possible, doing so before the previous
    alarm was reached, makes the new alarm replace the old alarm. The usefulness of
    alarms becomes obvious when performing a non-linear processing inside our application.
    The `pcntl_alarm()` function is non-blocking, making it easy to toss around, without
    worrying about blocking the program execution.
  prefs: []
  type: TYPE_NORMAL
- en: Multiprocessing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When speaking of **multiprocessing**, we often come across two seemingly colliding terms:
    **process** and **thread**. Where the process can be thought of as a currently
    running instance of an application, a thread is a path of execution within a process.
    A thread can do pretty much anything a process can do. However, given that threads
    reside within the process, we look at them as a solution for lightweight tasks,
    or at least tasks lighter than those employed by a process.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The PHP language leaves a lot to be desired in terms of multiprocessing/multithreading.
    The following two stand out as the most popular solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pcntl_fork()`: This is a function that forks the currently running process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pthreads`: This is an object-orientated API that provides multithreading based
    on Posix threads'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `pcntl_fork()` function is a part of the PCNTL extension, whose functions
    we used in previous sections as well. The function only forks processes and cannot
    make threads. While `pthreads` is a more modern and OOP-aligned solution, we will
    continue our journey throughout this section with the `pcntl_fork()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the `pcntl_fork()` function, it creates a child process for us.
    This child process differs from the parent process only by its `PID` and `PPID`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PID`: This is the Process ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PPID`: This is the Parent Process ID, the one that launched this PID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While the actual process forking with the `pcntl_fork()` function is quite easy,
    it leaves several challenges for us to tackle. Challenges such as *communication
    between processes* and *zombie children processes* make it tedious to deliver
    stable applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following use of the `pcntl_fork()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The console returned the control immediately, despite having five children processes running.
    The control was first returned right before the Child 1 string was outputted,
    and then, a few seconds later, all of the Child strings were outputted and the
    console returned the control once again. The output clearly shows that the children
    are not necessarily executed in the order they are forked in. The operating system
    decides on this, not us. We can further tune the behavior using the `pcntl_waitpid()`
    and `pcntl_wexitstatus()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pcntl_waitpid()` function instructs PHP to wait for a child, whereas the
    `pcntl_wexitstatus()` function fetches the value returned by a terminated child.
    The following example demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: While the majority of this example is similar to the previous one, notice the
    whole `while` loop at the bottom. The `while` loop will loop until the `pcntl_waitpid()`
    function returns `-1` (no children left). Each iteration of the `while` loop checks
    for the return code of a terminated child, and stores it into the `$status` variable,
    which is then again evaluated in the `while` loop expression.
  prefs: []
  type: TYPE_NORMAL
- en: Check out [http://php.net/manual/en/ref.pcntl.php](http://php.net/manual/en/ref.pcntl.php)
    for more details about the `pcntl_fork()`, `pcntl_waitpid()`, and `pcntl_wexitstatus()`
    function parameters and return values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The console did not return the control now until all of the children finished
    executing, which is probably the preferred solution for most of the tasks we might
    be doing.
  prefs: []
  type: TYPE_NORMAL
- en: Though process forking opens up several possibilities for us, we need to ask ourselves,
    Is it really worth the effort? If simply restructuring our application to use
    more message queues, CRONs, and other simpler technologies can yield a similar performance
    with the benefit of easier scaling, maintenance, and debugging, then we should
    probably avoid forking.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we have familiarized ourselves with some of the interesting
    features and tooling around PHP CLI. This chapter started with a basic introduction
    to PHP CLI SAPI, as one of the many SAPI interfaces in PHP. We then took a look
    into a simple but powerful Console component, learning how easy it is to create
    our own console applications. The I/O streams section helped us understand the
    standard streams, and how they are handled by PHP. Finally, we looked into the
    process control functions offered by the PCNTL extension. Combined together, these
    functions open up a wide range of possibilities to write our console applications.
    While the overall console application development might not seem interesting enough
    in comparison to more browser-facing applications, it certainly has its role in
    modern development. The CLI environment simply allows much greater control of
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, we will take a look into one of the most important and interesting
    OOP features in PHP.
  prefs: []
  type: TYPE_NORMAL
