- en: Rendering with JSX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will introduce you to JSX. We''ll start by covering the basics:
    what is JSX? Then, you''ll see that JSX has built-in support for HTML tags, as
    you would expect, so we''ll run through a few examples here. After having looked
    at some JSX code, we''ll discuss how it makes describing the structure of UIs
    easy for us. Then, we''ll jump into building our own JSX elements, and using JavaScript
    expressions for dynamic content. Finally, you''ll learn how to use fragments to
    produce less HTML—a new React 16 feature.'
  prefs: []
  type: TYPE_NORMAL
- en: Ready?
  prefs: []
  type: TYPE_NORMAL
- en: What is JSX?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll implement the obligatory *hello world* JSX application.
    At this point, we're just dipping our toes into the water; more in-depth examples
    will follow. We'll also discuss what makes this syntax work well for declarative
    UI structures.
  prefs: []
  type: TYPE_NORMAL
- en: Hello JSX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Without further ado, here''s your first JSX application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let's walk through what's happening here. First, we need to import the relevant
    bits. The `render()` function is what really matters in this example, as it takes
    JSX as the first argument and renders it to the DOM node passed as the second
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: The actual JSX content in this example renders a paragraph with some bold text
    inside. There's nothing fancy going on here, so we could have just inserted this
    markup into the DOM directly as a plain string. However, there's a lot more to
    JSX than what's shown here. The aim of this example was to show the basic steps
    involved in getting JSX rendered onto the page. Now, let's talk a little bit about
    declarative UI structure.
  prefs: []
  type: TYPE_NORMAL
- en: JSX is transpiled into JavaScript statements; browsers have no idea what JSX
    is. I would highly recommend downloading the companion code for this book from
    [https://github.com/PacktPublishing/React-and-React-Native-Second-Edition](https://github.com/PacktPublishing/React-and-React-Native-Second-Edition), and
    running it as you read along. Everything transpiles automatically for you; you
    just need to follow the simple installation steps.
  prefs: []
  type: TYPE_NORMAL
- en: Declarative UI structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we continue forward with our code examples, let's take a moment to reflect
    on our *hello world* example. The JSX content was short and simple. It was also
    **declarative**, because it described what to render, not how to render it. Specifically,
    by looking at the JSX, you can see that this component will render a paragraph,
    and some bold text within it. If this were done imperatively, there would probably
    be some more steps involved, and they would probably need to be performed in a
    specific order.
  prefs: []
  type: TYPE_NORMAL
- en: The example we just implemented should give you a feel for what declarative
    React is all about. As we move forward in this chapter and throughout the book,
    the JSX markup will grow more elaborate. However, it's always going to describe
    what is in the user interface. Let's move on.
  prefs: []
  type: TYPE_NORMAL
- en: Just like HTML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the end of the day, the job of a React component is to render HTML into the
    DOM browser. This is why JSX has support for HTML tags, out of the box. In this
    section, we'll look at some code that renders a few of the available HTML tags.
    Then, we'll cover some of the conventions that are typically followed in React
    projects when HTML tags are used.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in HTML tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we render JSX, element tags are referencing React components. Since it
    would be tedious to have to create components for HTML elements, React comes with
    HTML components. We can render any HTML tag in our JSX, and the output will be
    just as we''d expect. Now, let''s try rendering some of these tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Don't worry about the rendered output for this example; it doesn't make sense.
    All we're doing here is making sure that we can render arbitrary HTML tags, and
    they render as expected.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed the surrounding `<div>` tag, grouping together all of the
    other tags as its children. This is because React needs a root component to render.
    Later in the chapter, you'll learn how to render adjacent elements without wrapping
    them in a parent element.
  prefs: []
  type: TYPE_NORMAL
- en: HTML tag conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you render HTML tags in JSX markup, the expectation is that you'll use
    lowercase for the tag name. In fact, capitalizing the name of an HTML tag will
    fail. Tag names are case sensitive and non-HTML elements are capitalized. This
    way, it's easy to scan the markup and spot the built-in HTML elements versus everything
    else.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also pass HTML elements any of their standard properties. When you
    pass them something unexpected, a warning about the unknown property is logged.
    Here''s an example that illustrates these ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Later on in the book, I'll cover property validation for the components that
    you make. This avoids silent misbehavior as seen with the `foo` property in this
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Describing UI structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JSX is the best way to describe complex UI structures. Let''s look at some
    JSX markup that declares a more elaborate structure than a single paragraph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there are a lot of semantic elements in this markup, describing
    the structure of the UI. The key is that this type of complex structure is easy
    to reason about, and we don't need to think about rendering specific parts of
    it. But before we start implementing dynamic JSX markup, let's create some of
    our own JSX components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what the rendered content looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7c723ef2-ec1d-43ba-987f-d6703b8193f6.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating your own JSX elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Components are the fundamental building blocks of React. In fact, components
    are the vocabulary of JSX markup. In this section, we'll see how to encapsulate
    HTML markup within a component. We'll build examples that show you how to nest
    custom JSX elements and how to namespace your components.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulating HTML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The reason that you want to create new JSX elements is so that we can encapsulate
    larger structures. This means that instead of having to type out complex markup,
    you can use your custom tag. The React component returns the JSX that replaces
    the element. Let''s look at an example now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what the rendered output looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/70ef79a1-882c-478e-a6d4-cc8fd5fb9e8d.png)'
  prefs: []
  type: TYPE_IMG
- en: This is the first React component that you've implemented, so let's take a moment
    to dissect what's going on here. You've created a class called `MyComponent` that
    extends the `Component` class from React. This is how you create a new JSX element.
    As you can see in the call to `render()`, you're rendering a `<MyComponent>` element.
  prefs: []
  type: TYPE_NORMAL
- en: The HTML that this component encapsulates is returned by the `render()` method.
    In this case, when the JSX `<MyComponent>` is rendered by `react-dom`, it's replaced
    by a `<section>` element, and everything within it.
  prefs: []
  type: TYPE_NORMAL
- en: When React renders JSX, any custom elements that you use must have their corresponding
    React component within the same scope. In the preceding example, the `MyComponent` class
    was declared in the same scope as the call to `render()`, so everything worked
    as expected. Usually, you'll import components, adding them to the appropriate
    scope. You'll see more of this as you progress through the book.
  prefs: []
  type: TYPE_NORMAL
- en: Nested elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using JSX markup is useful for describing UI structures that have parent-child
    relationships. For example, a `<li>` tag is only useful as the child of a `<ul>`
    or `<ol>` tag—you''re probably going to make similar nested structures with your
    own React components. For this, you need to use the `children` property. Let''s
    see how this works. Here''s the JSX markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You''re importing two of your own React components: `MySection` and `MyButton`.
    Now, if you look at the JSX markup, you''ll notice that `<MyButton>` is a child
    of `<MySection>`. You''ll also notice that the `MyButton` component accepts text
    as its child, instead of more JSX elements. Let''s see how these components work,
    starting with `MySection`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This component renders a standard `<section>` HTML element, a heading, and then
    `{this.props.children}`. It's this last construct that allows components to access
    nested elements or text, and to render it.
  prefs: []
  type: TYPE_NORMAL
- en: The two braces used in the preceding example are used for JavaScript expressions.
    I'll touch on more details of the JavaScript expression syntax found in JSX markup
    in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the `MyButton` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This component is using the exact same pattern as `MySection`; take the `{this.props.children}`
    value, and surround it with meaningful markup. React handles the messy details
    for you. In this example, the button text is a child of `MyButton`, which is,
    in turn, a child of `MySection`. However, the button text is transparently passed
    through `MySection`. In other words, we didn''t have to write any code in `MySection`
    to make sure that `MyButton` got its text. Pretty cool, right? Here''s what the
    rendered output looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/8ac4edd8-81cc-432a-b3ed-55d7e862e629.png)'
  prefs: []
  type: TYPE_IMG
- en: Namespaced components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The custom elements that you've created so far have used simple names. Sometimes,
    you might want to give a component a namespace. Instead of writing `<MyComponent>`
    in your JSX markup, you would write `<MyNamespace.MyComponent>`. This makes it
    clear to anyone that `MyComponent` is part of `MyNamespace`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, `MyNamespace` would also be a component. The idea with **namespacing**
    is to have a namespace component render its child components using the namespace
    syntax. Let''s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This markup renders a `<MyComponent>` element with two children. The key here
    is that instead of writing `<First>`, we write `<MyComponent.First>`, and the
    same with `<MyComponent.Second>`. The idea is that we want to explicitly show
    that `First` and `Second` belong to `MyComponent`, within the markup.
  prefs: []
  type: TYPE_NORMAL
- en: I personally don't depend on namespaced components like these, because I'd rather
    see which components are in use by looking at the `import` statements at the top
    of the module. Others would rather import one component and explicitly mark the
    relationship within the markup. There is no correct way to do this; it's a matter
    of personal taste.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the `MyComponent` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This module declares `MyComponent` as well as the other components that fall
    under this namespace (`First` and `Second`). The idea is to assign the components
    to the namespace component (`MyComponent`) as class properties. There are a number
    of things that you could change in this module. For example, you don't have to
    directly export `First` and `Second` since they're accessible through `MyComponent`.
    You also don't need to define everything in the same module; you could import
    `First` and `Second` and assign them as class properties. Using namespaces is
    completely optional, and if you use them, you should use them consistently.
  prefs: []
  type: TYPE_NORMAL
- en: Using JavaScript expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you saw in the preceding section, JSX has special syntax that allows you
    to embed JavaScript expressions. Any time React renders JSX content, expressions
    in the markup are evaluated. This is the dynamic aspect of JSX, and in this section,
    you'll learn how to use expressions to set property values and element text content.
    You'll also learn how to map collections of data to JSX elements.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic property values and text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some HTML property or text values are static, meaning that they don''t change
    as the JSX is re-rendered. Other values, the values of properties or text, are
    based on data that''s found elsewhere in the application. Remember, React is just
    the view layer. Let''s look at an example so that you can get a feel for what
    the JavaScript expression syntax looks like in JSX markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Anything that is a valid JavaScript expression, including nested JSX, can go
    in between the braces: `{}`. For properties and text, this is often a variable
    name or object property. Notice in this example that the `!enabled` expression
    computes a Boolean value. Here''s what the rendered output looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/219285aa-1d17-4bcd-8f4a-d210c2c8466a.png)If you''re following along
    with the downloadable companion code, which I strongly recommend doing, try playing
    with these values, and seeing how the rendered HTML changes.'
  prefs: []
  type: TYPE_NORMAL
- en: Mapping collections to elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you need to write JavaScript expressions that change the structure
    of your markup. In the preceding section, you learned how to use JavaScript expression
    syntax to dynamically change the property values of JSX elements. What about when
    you need to add or remove elements based on JavaScript collections?
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the book, when I refer to a JavaScript **collection**, I'm referring
    to both plain objects and arrays. Or, more generally, anything that's iterable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way to dynamically control JSX elements is to map them from a collection.
    Let''s look at an example of how this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first collection is an array called `array`, populated with string values.
    Moving down to the JSX markup, you can see the call to `array.map()`, which will
    return a new array. The mapping function is actually returning a JSX element (`<li>`),
    meaning that each item in the array is now represented in the markup.
  prefs: []
  type: TYPE_NORMAL
- en: The result of evaluating this expression is an array. Don't worry; JSX knows
    how to render arrays of elements.
  prefs: []
  type: TYPE_NORMAL
- en: The object collection uses the same technique, except you have to call `Object.keys()`
    and then map this array. What's nice about mapping collections to JSX elements
    on the page is that you can drive the structure of React components based on collection
    data. This means that you don't have to rely on imperative logic to control the
    UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the rendered output looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/56381615-16d4-4762-b848-03fee269794e.png)'
  prefs: []
  type: TYPE_IMG
- en: Fragments of JSX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React 16 introduces the concept of **JSX fragments**. Fragments are a way to
    group together chunks of markup without having to add unnecessary structure to
    your page. For example, a common approach is to have a React component return
    content wrapped in a `<div>` element. This element serves no real purpose and
    adds clutter to the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example. Here are two versions of a component. One uses a
    wrapper element and one uses the new fragment feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The two elements rendered are `<WithoutFragments>` and `<WithFragments>`. Here''s
    what they look like when rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c8442577-0a54-49a6-a35c-121afc44bc51.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's compare the two approaches now.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapper elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first approach is to wrap sibling elements in a `<div>`. Here''s what the
    source looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The essence of this component are the `<h1>` and the `<p>` tags. Yet, in order
    to return them from `render()`, you have to wrap them with a `<div>`. Indeed,
    inspecting the DOM using your browser dev tools reveals that this `<div>` does
    nothing but add another level of structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c91d419c-89ef-4e2f-af12-b4c7bb13bbbc.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, imagine an app with lots of these components—that's a lot of pointless
    elements!
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding unnecessary tags using fragments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `WithFragments` component now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of wrapping the component content in a `<div>`, the `<Fragment>` element
    is used. This is a special type of element that indicates that only its children
    need to be rendered. You can see the difference compared to the `WithoutFragments`
    component if you inspect the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/4aa026e6-9dc9-42bb-a7bb-80bc05082936.png)Notice how you had to import
    `Fragment` from React in the previous example? This is because not all transpilers
    such as Babel understand the Fragment element yet. In future versions, there will
    actually be a shorthand way to express fragments in JSX: `<>My Content</>`. But
    for now, `React.Fragment` should work with all React tooling.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the basics of JSX, including its declarative structure
    and why this is a good thing. Then, you wrote some code to render some basic HTML
    and learned about describing complex structures using JSX.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you spent some time learning about extending the vocabulary of JSX markup
    by implementing your own React components, the fundamental building blocks of
    your UI. Then, you learned how to bring dynamic content into JSX element properties,
    and how to map JavaScript collections to JSX elements, eliminating the need for
    imperative logic to control the UI display. Finally, you learned how to render
    fragments of JSX content using new React 16 functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a feel for what it's like to render UIs by embedding declarative
    XML in your JavaScript modules, it's time to move on to the next chapter, where
    we'll take a deeper look at component properties and state.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Can you use all of the standard HTML tags as JSX elements?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, but you have to import any HTML tags that you want to use from react-dom
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, you have to implement your own React components that render HTML content
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, React supports this out of the box
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you access child elements from your component?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Child JSX elements are always accessible via the `children` property
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Child JSX elements are passed as arguments to the `render()` method
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is no way to access child elements from within a component
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the `Fragment` component from React do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It renders its children more efficiently
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It creates a reusable piece of markup that can then be reused throughout the
    app
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It acts as a container component by negating the need to render pointless elements,
    such as container divs
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Check out the following links for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://reactjs.org/docs/introducing-jsx.html](https://reactjs.org/docs/introducing-jsx.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://reactjs.org/docs/fragments.html](https://reactjs.org/docs/fragments.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
