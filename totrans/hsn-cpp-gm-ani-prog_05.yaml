- en: '*Chapter 5*: Implementing Transforms'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will implement a structure that holds position, rotation,
    and scale data. This structure is a transform. A transform maps from one space
    to another space. Position, rotation, and scale could also be stored in a 4x4
    matrix, so why would you want to use an explicit transform struct instead of a
    matrix? The answer is interpolation. Matrices don't interpolate well, but transform
    structures do.
  prefs: []
  type: TYPE_NORMAL
- en: Interpolating between two matrices is difficult because rotation and scale are
    stored in the same components of the matrix. Because of this, interpolating between
    two matrices doesn't yield the result you would expect. Transforms solve this
    problem by storing the position, rotation, and scale components separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will implement a transform structure and the common operations
    that you need to be able to perform in transforms. By the end of this chapter,
    you should be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand what a transform is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand how to combine transforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convert between transforms and matrices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand how to apply transforms to points and vectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important information
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will implement a transform structure that represents position,
    rotation, and scale. To find out more about transforms, how they relate to matrices,
    and how they fit into game hierarchies, check out [http://gabormakesgames.com/transforms.html](http://gabormakesgames.com/transforms.html).
  prefs: []
  type: TYPE_NORMAL
- en: Creating the transform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Transforms are simple structures. A transform contains a position, rotation,
    and scale. Position and scale are vectors and rotation is a quaternion. Transforms
    can be combined hierarchically, but this parent-child relationship should not
    be a part of the actual transform structure. The following steps will guide you
    through creating a transform structure:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file, `Transform.h`. This file is required to declare the transform
    structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Begin declaring the `Transform` structure in this new file. Start with the
    properties of the transform—`position`, `rotation`, and `scale`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a constructor that takes a position, rotation, and scale. This constructor
    should assign these values to the appropriate members of the Transform struct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A blank transform should have no position or rotation and a scale of one. By
    default, the `scale` component will be created as `(0, 0, 0)`. To solve this,
    the default constructor of the `Transform` struct needs to initialize the `scale`
    to the correct value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `Transform` structure is fairly straightforward; all of its members are
    public. A transform has a position, rotation, and scale. The default constructor
    sets the position vector to *0*, the rotation quaternion to identity, and the
    scale vector to *1*. The transformation created by the default constructor has
    no effect.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn how to combine transforms in a similar way
    to matrices or quaternions.
  prefs: []
  type: TYPE_NORMAL
- en: Combining transforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consider a skeleton, as an example. At each joint, you could place a transform
    to describe the motion of the joint. When you rotate your shoulder, the elbow
    attached to that shoulder also moves. To apply the shoulder transformation to
    all connected joints, the transform on each joint must be combined with its parent
    joint's transform.
  prefs: []
  type: TYPE_NORMAL
- en: Transforms can be combined in the same way as matrices and quaternions and the
    effects of two transforms can be combined into one transform. To keep things consistent,
    combining transforms should maintain a right-to-left combination order. Unlike
    matrices and quaternions, this `combine` function will not be implemented as a
    multiplication function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Combining the scale and rotation of two transforms is simple—multiply them
    together. Combining the position is a bit harder. The combined position needs
    to be affected by the `rotation` and `scale` components as well. When finding
    the combined position, remember the order of transformations: scale first, rotate
    second, and translate last.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, `Transform.cpp`. Implement the `combine` function and don''t
    forget to add the function declaration to `Transform.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In later chapters, the `combine` function will be used to organize transforms
    into a hierarchy. In the next section, you will learn how to invert transforms,
    which is again similar to inverting matrices and quaternions.
  prefs: []
  type: TYPE_NORMAL
- en: Inverting transforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You already know that a transform maps from one space into another space. It's
    possible to reverse that mapping and map the transform back into the original
    space. As with matrices and quaternions, transforms can also be inverted.
  prefs: []
  type: TYPE_NORMAL
- en: When inverting scale, keep in mind that 0 can't be inverted. The case where
    scale is 0 will need to be treated specially
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `inverse` transform method in `Transform.cpp`. Don''t forget
    to declare the method in `Transform.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Inverting a transform can be done to remove the effects of one transform from
    another transform. Consider a character moving through a level. Once the level
    is over, you might want to move the character back to the origin before starting
    the next level. You could multiply the transform of the character by its inverse.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn how to mix two or more transforms together.
  prefs: []
  type: TYPE_NORMAL
- en: Mixing transforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have transforms that represent joints at two specific points in time. To
    make the model appear animated, you need to interpolate or mix between the transformation
    of these frames.
  prefs: []
  type: TYPE_NORMAL
- en: It's possible to interpolate between vectors and quaternions, the building blocks
    of a transform. So it's possible to interpolate between transforms as well. Instead
    of interpolation, this operation is typically called blend or mix. When mixing
    two transforms together, linearly interpolate the position, rotation, and scale
    of the input transforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `mix` function in `Transform.cpp`. Don''t forget to declare the
    function in `Transform.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Being able to mix transformations together is important for creating smooth
    transitions between animations. Here, you implemented a linear blend between transforms.
    In the next section, you will learn how to convert a `transform` into a `mat4`.
  prefs: []
  type: TYPE_NORMAL
- en: Converting transforms to matrices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shader programs work well with matrices. They don't have a native representation
    of a transform structure. You could port the transform code into GLSL, but that's
    not the best solution. Instead, you could convert a transform into a matrix right
    before submitting it as a shader uniform.
  prefs: []
  type: TYPE_NORMAL
- en: Since transforms encode data that could be stored in matrices, it's possible
    to convert a transform into a matrix. To convert a transform into a matrix, the
    matrix needs to be thought of in terms of vectors.
  prefs: []
  type: TYPE_NORMAL
- en: First, find the basis vectors by multiplying the orientation of the global basis
    vectors by the transform's rotation. Next, scale the basis vectors by the scale
    of the transform. This yields the final basis vectors to fill the upper 3x3 sub-matrix.
    The position goes directly into the last column of the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the from `Transform` method in `Transform.cpp`. Don''t forget to
    add the function declaration to `Transform.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Graphics APIs work with matrices not transforms. In later chapters, transforms
    will be converted into matrices before being sent to a shader. In the next section,
    you will learn how to do the opposite, which is converting matrices into transforms.
  prefs: []
  type: TYPE_NORMAL
- en: Converting matrices into transforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: External file formats might store transformation data as matrices. glTF, for
    example, can store the transform of a node as the position, rotation, and scale,
    or as a single 4x4 matrix. To make the transform code robust, you need to be able
    to convert matrices to transforms.
  prefs: []
  type: TYPE_NORMAL
- en: Converting a matrix to a transform is more difficult than converting a transform
    to a matrix. Extracting the rotation of the matrix is simple; you have already
    implemented a function to turn a 4x4 matrix into a quaternion. Extracting the
    position is also simple; copy the last column of the matrix into a vector. Extracting
    the scale is more difficult.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that the order of operations for a transform is to scale, rotate, and
    then translate. This means that if you had three matrices—*S*, *R*, and *T*—that
    represent scale, rotation, and translation, respectively, they would combine into
    a transform matrix, *M*, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*M = SRT*'
  prefs: []
  type: TYPE_NORMAL
- en: To find the scale, first, ignore the translation part of the matrix, *M* (zero
    out the translation vector). This leaves you with *M = SR*. To remove the rotation
    component of the matrix, multiply *M* by the inverse of *R*. That should leave
    only the scale component. Well, not exactly. The result would leave a matrix that
    contains a scale and some skew information.
  prefs: []
  type: TYPE_NORMAL
- en: The way we will extract the scale from this scale-skew matrix is to simply take
    the main diagonal as the scale-skew matrix. While this will work most of the time,
    it's not perfect. The scale that is acquired should be considered a lossy scale,
    as the value can contain skew data as well, which makes the scale inaccurate.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to decompose a matrix into translation, rotation, scale, skew,
    and the sign of the determinant. However, this decomposition is expensive and
    not well suited to real-time applications. To learn more, check out *Matrix  Animation  and  Polar  Decomposition*
    by Ken Shoemake and Tom Duff at [https://research.cs.wisc.edu/graphics/Courses/838-s2002/Papers/polar-decomp.pdf](https://research.cs.wisc.edu/graphics/Courses/838-s2002/Papers/polar-decomp.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `toTransform` function in `Transform.cpp`. Don''t forget to add
    the function declaration to `Transform.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It's important that you're able to convert matrices to transforms because you
    don't always control what format the data you are dealing with comes in. For example,
    a model format might store matrices instead of transforms.
  prefs: []
  type: TYPE_NORMAL
- en: By now, you have probably noticed that transforms and matrices can generally
    do the same things. In the next section, you will learn how to transform points
    and vectors using transforms, in a similar way to how it's done with matrices.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming points and vectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Transform` structure can be used to move points and vectors in space. Imagine
    a ball bouncing up and down. The bounce of the ball is derived from the `Transform`
    structure, but how do you know where to move each vertex of the ball? You need
    to transform all the vertices using the `Transform` structure (or a matrix) to
    properly display the ball.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a transform to modify points and vectors is like combining two transforms.
    To transform a point, first, apply the scale, then rotation, and finally, the
    translation of the transform. To transform a vector, follow the same steps, but
    don''t add the position:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `transformPoint` function in `Transform.cpp`. Don''t forget to
    add the function declaration to `Transform.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `transformVector` function in `Transform.cpp`. Don''t forget
    to add the function declaration to `Transform.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `transformPoint` function does the same thing that multiplying a matrix
    and a point does, just one step at a time. `scale` is applied first, then `rotation`,
    and `translation`, last. When you're dealing with a vector instead of a point,
    the same order applies, except the translation is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to implement a transformation as a discreet
    structure that contains a position, rotation, and scale. In many ways, the `Transform`
    class holds the same data that you would normally store in a matrix.
  prefs: []
  type: TYPE_NORMAL
- en: You learned how to combine, invert, and mix between transforms, as well as how
    to use transforms to move points and rotate vectors. Transforms are going to be
    essential moving forward, as they are used to animate the armature or skeleton
    of game models.
  prefs: []
  type: TYPE_NORMAL
- en: The reason you need an explicit `Transform` struct is that matrices don't interpolate
    well. Interpolating transforms is very important for animation. It's how you create
    in-between poses to display two given keyframes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to write a light abstraction layer on
    top of OpenGL to make rendering in future chapters easier.
  prefs: []
  type: TYPE_NORMAL
