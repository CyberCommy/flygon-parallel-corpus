- en: Stacks and Queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, you have learned a lot about arrays and lists. However, these structures
    are not the only ones available. Among others, there is also a group of more specialized
    data structures, which are called **limited access data structures**.
  prefs: []
  type: TYPE_NORMAL
- en: What does this mean? To explain the name, let's return to the topic of arrays
    for the moment, which belong to the group of **random access data structures**.
    The difference between them is only one word, that is, limited or random. As you
    already know, arrays allow you to store data and get access to various elements
    using indices. Thus, you can easily get the first, the middle, the *n*^(th), or
    the last element from the array. For this reason, it can be named as the random
    access data structure.
  prefs: []
  type: TYPE_NORMAL
- en: However, what does *limited* mean? The answer is very simple—with a limited
    access data structure, you cannot access every element from the structure. Thus,
    the way of getting elements is strictly specified. For example, you can get only
    the first or the last element, but you cannot get the *n*^(th) element from the
    data structure. The popular representatives of limited access data structures
    are stacks and queues.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, the following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Stacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Priority queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To begin, let's talk about a **stack**. It is an easy-to-understand data structure
    and can be represented using the example of a pile of many plates, each placed
    on top of the other. You can only add a new plate to the top of the pile, and
    you can only get a plate from the top of the pile. You cannot remove the seventh
    plate without taking the previous six from the top, and you cannot add a plate
    to the middle of the pile.
  prefs: []
  type: TYPE_NORMAL
- en: The stack operates in exactly the same way! It allows you to add a new element
    at the top (the **push** operation) and get an element by removing it from the
    top (the **pop** operation). For this reason, a stack is consistent with the **LIFO**
    principle, which stands for **Last-In First-Out**. According to our example of
    the pile of plates, the last added plate (last-in) will be removed from the pile
    first (first-out).
  prefs: []
  type: TYPE_NORMAL
- en: 'The diagram of a stack with push and pop operations is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4fcda16-874b-42c5-afb0-e7012d152bcd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It seems to be very easy, doesn''t it? It really is, and you can benefit from
    the features of stacks using the built-in generic `Stack` class from the `System.Collections.Generic`
    namespace. It is worth mentioning three methods from this class, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Push`, to insert an element at the top of the stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pop`, to remove an element from the top of the stack and return it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Peek`, to return an element from the top of the stack without removing it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, you also have access to other methods, such as for removing all elements
    from the stack (`Clear`) or for checking whether a given element is available
    in the stack (`Contains`). You can get the number of elements in the stack using
    the `Count` property.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that the `Push` method is an *O(1)* operation, if the capacity
    does not need to increase, or *O(n) *otherwise, where *n* is the number of elements
    in the stack. Both `Pop` and `Peek` are *O(1)* operations.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about the `Stack` generic class at [https://msdn.microsoft.com/library/3278tedw.aspx](https://msdn.microsoft.com/library/3278tedw.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: It is high time to take a look at some examples. Let's go!
  prefs: []
  type: TYPE_NORMAL
- en: Example – reversing words
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the first example, let''s try to reverse a word using a stack. You can
    do this by iterating through characters that form a string, adding each at the
    top of the stack, and then removing all elements from the stack. At the end, you
    receive the reversed word, as shown in the following diagram, which presents the
    process of reversing the **MARCIN** word:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a555d667-5a6c-4e2d-b410-bcede9eda7cc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The implementation code, which should be added to the `Main` method within
    the `Program` class, is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the first line, a new instance of the `Stack` class is created. It is worth
    mentioning that in this scenario, the stack can contain only `char` elements.
    Then, you iterate through all characters using the `foreach` loop and insert each
    character at the top of the stack by calling the `Push` method on the `Stack`
    instance. The remaining part of the code consists of the `while` loop, which is
    executed until the stack is empty. This condition is checked using the `Count`
    property. In each iteration, the top element is removed from the stack (by calling
    `Pop`) and written in the console (using the `Write` static method of the `Console`
    class).
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the code, you will receive the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Example – Tower of Hanoi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next example is a significantly more complex application of stacks. It
    is related to the mathematical game **Tower of Hanoi**. Let''s start with the
    rules. The game requires three rods, onto which you can put discs. Each disc has
    a different size. At the beginning, all discs are placed on the first rod, forming
    the stack, ordered from the smallest (at the top) to the biggest (at the bottom),
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/48184ab8-6fd5-4a9e-bb5d-7a656bc8591d.png)'
  prefs: []
  type: TYPE_IMG
- en: The aim of the game is to move all the discs from the first rod (**FROM**) to
    the second one (**TO**). However, during the whole game, you cannot place a bigger
    disc on a smaller one. Moreover, you can only move one disc at a time and, of
    course, you can only take a disc from the top of any rod. How could you move discs
    between the rods to comply with the afore mentioned rules? The problem can be
    divided into sub problems.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the example of moving only one disc. Such a case is trivial
    and you just need to move a disc from the **FROM** rod to the **TO** one, without
    using the **AUXILIARY** rod.
  prefs: []
  type: TYPE_NORMAL
- en: A bit more complex scenario is moving two discs. In such a case, you should
    move one disc from the **FROM** rod to the **AUXILIARY** one. Then, you move the
    remaining disc from **FROM** to **TO**. At the end, you only need to move a disc
    from **AUXILIARY** to **TO**.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to move three discs, you should start by moving two discs from **FROM**
    to **AUXILIARY**, using the mechanism described earlier. The operation will involve
    the **TO** rod as the auxiliary one. Then, you move the remaining disc from **FROM**
    to **TO**, and then move two discs from **AUXILIARY** to the **TO** rod, using
    **FROM** as the auxiliary rod.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, you can solve the problem of moving *n* discs by moving *n-1*
    discs from **FROM** to **AUXILIARY**, using **TO** as the auxiliary rod. Then,
    you should move the remaining disc from **FROM** to **TO**. At the end, you just
    need to move *n-1* discs from **AUXILIARY** to the **TO** rod, using **FROM**
    as the auxiliary rod.
  prefs: []
  type: TYPE_NORMAL
- en: That's all! Now that you know the basic rules, let's proceed to the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s focus on the `HanoiTower` class, which contains the logic related
    to the game. A part of the code is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The class contains five properties, storing the overall number of discs (`DiscsCount`),
    the number of performed moves (`MovesCount`), and the representations for the
    three rods (`From`, `To`, `Auxiliary`). The `MoveCompleted` event is declared
    as well. It will be fired after each move to inform that the user interface should
    be refreshed. Therefore, you can show the proper content, illustrating the current
    state of the rods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the properties and the event, the class also has the following constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The constructor takes only one parameter, namely the number of discs (`discs`),
    and sets it as a value of the `DiscsCount` property. Then, new instances of the
    `Stack` class are created and references to them are stored in the `From`, `To`,
    and `Auxiliary` properties. At the end, the `for` loop is used to create the necessary
    number of discs and to add elements to the first stack (`From`). It is worth noting
    that `From`, `To`, and `Auxiliary` stacks only store integer values (`Stack<int>`).
    Each integer value represents a size of a particular disc. Such data is crucial
    due to the rules of moving discs between rods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The operation of the algorithm is started by calling the `Start` method, whose
    code is shown in the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The method just calls the `Move` recursive method, passing the overall number
    of discs and references to three stacks as parameters. However, what happens in
    the `Move` method? Let''s look inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you already know, this method is called recursively. For this reason, it
    is necessary to specify some exit conditions to prevent the method being called
    infinitely. In this case, the method will not call itself when the value of the
    `discs` parameter is equal to or lower than zero. If such a value is greater than
    zero, then the `Move` method is called, but the order of stacks is changed. Then,
    the element is removed from the stack represented by the second parameter (`from`)
    and inserted at the top of the stack represented by the third parameter (`to`).
    In the following lines, the number of moves (`MovesCount`) is incremented and
    the `MoveCompleted` event is fired. At the end, the `Move` method is called again,
    with another configuration of rod order. By calling this method several times,
    the discs will be moved from the first (`From`) to the second (`To`) rod. The
    operations performed in the `Move` method are consistent with the description
    of the problem of moving *n* discs between rods, as explained in the introduction
    to this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the class with the logic regarding the Tower of Hanoi game is created,
    let''s see how to create the user interface that allows you to present the following
    moves of the algorithm. The necessary changes in the `Program` class are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: First, two constants are declared, namely with the overall number of discs (`DISCS_COUNT`,
    set to `10`) and the delay (in milliseconds) between two following moves of the
    algorithm (`DELAY_MS`, set to `250`). Moreover, the private static field is declared,
    which represents the number of characters used to present a single rod (`_columnSize`,
    set to `30`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Main` method in the `Program` class is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: First, the width of a single column (representing a rod) is calculated with
    the use of the auxiliary `GetDiscWidth` method, whose code will be shown later.
    Then, a new instance of the `HanoiTower` class is created and it is indicated
    that the `Algorithm_Visualize` method will be called when the `MoveCompleted`
    event is fired. Next, the afore mentioned `Algorithm_Visualize` method is called
    to present the initial state of the game. Finally, the `Start` method is called
    to start moving discs between rods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code of the `Algorithm_Visualize` method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The visualization of the algorithm should present the current state of the game
    in the console. Thus, whenever a refresh is necessary, the `Algorithm_Visualize`
    method clears the current content of the console (by calling the `Clear` method).
    Then, it calls the `InitializeVisualization` method to prepare the jagged array
    with content that should be written in the console. Such content consists of three
    columns, which are prepared by calling the `PrepareColumn` method. After calling
    it, the `visualization` array contains data that should just be presented in the
    console, without any additional transformations. To do so, the `DrawVisualization`
    method is called. Of course, the header and additional explanations are written
    to the console using the `WriteLine` method of the `Console` class.
  prefs: []
  type: TYPE_NORMAL
- en: The important role is performed by the last line of code, where the `Sleep`
    method of the `Thread` class (from the `System.Threading` namespace) is called.
    It suspends the current thread for `DELAY_MS` milliseconds. Such a line is added
    to present the following steps of the algorithm in a convenient way for the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the code for the `InitializeVisualization` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The method declares the jagged array, with the number of rows equal to the overall
    number of discs (the `DiscsCount` property). The number of columns is equal to
    the value of the `_columnSize` field multiplied by `3` (to present three rods).
    Within the method, two `for` loops are used to iterate through the following rows
    (the first `for` loop) and through all columns (the second `for` loop). By default,
    all elements in the array are initialized with single spaces. Finally, the initialized
    array is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fill the afore mentioned jagged array with the illustration of the current
    state of the rod, you need to call the `PrepareColumn` method, whose code is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: First, the left margin is calculated to add data in the correct section within
    the overall array, that is, within the correct range of columns. However, the
    main part of the method is the `for` loop, where the number of iterations is equal
    to the number of discs located in the given stack. In each iteration, the size
    of the current disc is read using the `ElementAt` extension method (from the `System.Linq`
    namespace). Next, you calculate an index of a row, where the disc should be shown,
    as well as the start and end indices for the columns. Finally, the `for` loop
    is used to insert the equals sign (`=`) in proper locations in the jagged array,
    passed as the `visualization` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next visualization-related method is `DrawVisualization`, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The method just iterates through all elements of the jagged array passed as
    the `visualization` parameter and calls the `WriteLine` method for each array
    located within the jagged array. As a result, data located in the whole array
    are written to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the auxiliary methods is `Center`. Its aim is to add additional spaces
    before and after the text, passed as the parameter, to center the text in the
    column. The code of this method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Another method is `GetDiscWidth`, which just returns the number of characters
    necessary to present the disc with the size specified by the parameter. Its code
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You have already added the necessary code to run the application, which will
    present the following moves in the Tower of Hanoi mathematical game. Let's launch
    the application and see it in action!
  prefs: []
  type: TYPE_NORMAL
- en: 'Just after starting the program, you will see a result similar to the following,
    where all discs are located in the first rod (`FROM`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next step, the smallest disc is moved from the top of the first rod
    (`FROM`) to the top of the third rod (`AUXILIARY`), as shown in the following
    illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'While making many other moves, you can see how discs are moved between all
    three rods. One of the intermediate states is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When the necessary moves are completed, all discs are moved from the first
    disc (`FROM`) to the second one (`TO`). The final result is presented in the following
    illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Finally, it is worth mentioning the number of moves necessary to complete the
    Tower of Hanoi game. In the case of 10 discs, the number of moves is 1,023\. If
    you use only three discs, the number of moves is only seven. Generally speaking,
    the number of moves can be calculated with the formula *2^n-1*, where *n* is the
    number of discs.
  prefs: []
  type: TYPE_NORMAL
- en: That's all! In this section, you have learned the first limited access data
    structure, namely a stack. Now, it is high time that you get to know more about
    queues. Let's start!
  prefs: []
  type: TYPE_NORMAL
- en: Queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **queue** is a data structure that can be presented using the example of a
    line of people waiting in a shop at the checkout. New people stand at the end
    of the line, and the next person is taken to the checkout from the beginning of
    the line. You are not allowed to choose a person from the middle and serve him
    or her in a different order.
  prefs: []
  type: TYPE_NORMAL
- en: The queue data structure operates in exactly the same way. You can only add
    new elements at the end of the queue (the **enqueue** operation) and remove an
    element from the queue only from the beginning of the queue (the **dequeue** operation).
    For this reason, this data structure is consistent with the **FIFO** principle,
    which stands for **First-In First-Out**. In the example regarding a line of people
    waiting in a shop at the checkout, people who come first (first-in) will be served
    before those who come later (first-out).
  prefs: []
  type: TYPE_NORMAL
- en: 'The operation of a queue is presented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f5f553b-30ad-467b-bc7e-54e3f368fd89.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It is worth mentioning that a queue is a **recursive data structure**, similarly
    as a stack. This means that a queue can be either empty or consists of the first
    element and the rest of the queue, which also forms a queue, as shown in the following
    diagram (the beginning of the queue is marked in gray):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/64556717-48c1-4468-b84a-4b91eec6cce8.png)'
  prefs: []
  type: TYPE_IMG
- en: The queue data structure seems to be very easy to understand, as well as similar
    to a stack, apart from the way of removing an element. Does this mean that you
    can also use a built-in class to use a queue in your programs? Fortunately, yes!
    The available generic class is named `Queue` and is defined in the `System.Collections.Generic`
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Queue` class contains a set of methods, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Enqueue`, to add an element at the end of the queue'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dequeue`, to remove an element from the beginning and return it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Peek`, to return an element from the beginning without removing it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Clear`, to remove all elements from the queue'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Contains`, to check whether the queue contains the given element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Queue` class also contains the `Count` property, which returns the total
    number of elements located in the queue. It can be used to easily check whether
    the queue is empty.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that the `Enqueue` method is an *O(1)* operation, if
    the internal array does not need to be reallocated, or *O(n) *otherwise, where
    *n* is the number of elements in the queue. Both `Dequeue` and `Peek` are *O(1)*
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about the `Queue` class at [https://msdn.microsoft.com/library/7977ey2c.aspx](https://msdn.microsoft.com/library/7977ey2c.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: 'The additional comment is necessary for the scenarios where you want to use
    a queue concurrently from many threads. In such a case, it is necessary to choose
    the thread-safe variant of the queue, which is represented by the `ConcurrentQueue`
    generic class from the `System.Collections.Concurrent` namespace. This class contains
    a set of built-in methods to perform various operations of the thread-safe queue,
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Enqueue`, to add an element at the end of the queue'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TryDequeue`, to try to remove an element from the beginning and return it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TryPeek`, to try to return an element from the beginning without removing
    it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is worth mentioning that both `TryDequeue` and `TryPeek` have a parameter
    with the `out` keyword. If the operation is successful, such methods return `true`
    and the result is returned as a value of the `out` parameter. Moreover, the `ConcurrentQueue`
    class also contains two properties, namely `Count` to get the number of elements
    stored in the collection, and `IsEmpty` to return a value indicating whether the
    queue is empty.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about the `ConcurrentQueue` class at [https://msdn.microsoft.com/library/dd267265.aspx](https://msdn.microsoft.com/library/dd267265.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: After this short introduction, you should be ready to proceed to two examples
    representing a queue in the context of a call center, with many callers and one
    or many consultants.
  prefs: []
  type: TYPE_NORMAL
- en: Example – call center with a single consultant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This first example represents the simple approach to the call center solution,
    where there are many callers (with different client identifiers), and only one
    consultant, who answers waiting calls in the same order in which they appear.
    This scenario is presented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ac923287-81b8-49c7-87d8-cff86e481094.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the preceding diagram, four calls are performed by callers.
    They are added to the queue with waiting phone calls, namely from clients **#1234**,
    **#5678**, **#1468**, and **#9641**. When the consultant is available, he or she
    answers the phone. When the call ends, the consultant can answer the next waiting
    call. According to this rule, the consultant will talk with clients in the following
    order: **#1234**, **#5678**, **#1468**, and **#9641**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the code of the first class, named `IncomingCall`, which
    represents a single incoming call performed by a caller. Its code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The class contains six properties representing an identifier of a call (`Id`),
    a client identifier (`ClientId`), the date and time when the call was started
    (`CallTime`), when it was answered (`StartTime`), and when it was ended (`EndTime`),
    as well as the name of the consultant (`Consultant`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important part of this implementation is related to the `CallCenter`
    class, which represents call-related operations. Its fragment is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `CallCenter` class contains the `_counter` field with the identifier of
    the last call, as well as the `Calls` queue (with `IncomingCall` instances), where
    data of waiting calls are stored. In the constructor, a new instance of the `Queue`
    generic class is created, and its reference is assigned to the `Calls` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, the class also contains some methods, such as `Call`, with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, you create a new instance of the `IncomingCall` class and set values of
    its properties, namely its identifier (together with pre-incrementing the `_counter`
    field), the client identifier (using the `clientId` parameter), and the call time.
    The created instance is added to the queue by calling the `Enqueue` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next method is `Answer`, which represents the operation of answering the
    call, from the person waiting in the queue for the longest time, that is, which
    is located at the beginning of the queue. The `Answer` method is shown in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Within this method, you check whether the queue is empty. If so, the method
    returns `null`, which means that there are no phone calls that can be answered
    by the consultant. Otherwise, the call is removed from the queue (using the `Dequeue`
    method), and its properties are updated by setting the consultant name (using
    the `consultant` parameter) and start time (to the current date and time). At
    the end, the data of the call is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the `Call` and `Answer` methods, you should also implement the `End`
    method, which is called whenever the consultant ends a call with a particular
    client. In such a case, you just set the end time, as shown in the following piece
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The last method in the `CallCenter` class is named `AreWaitingCalls`. It returns
    a value indicating whether there are any waiting calls in the queue, using the
    `Count` property of the `Queue` class. Its code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s proceed to the `Program` class and its `Main` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you create a new instance of the `Random` class (for getting random numbers),
    as well as an instance of the `CallCenter` class. Then, you simulate making a
    few calls by callers, namely with the following client identifiers: `1234`, `5678`,
    `1468`, and `9641`. The most interesting part of the code is located in the `while`
    loop, which is executed until there are no waiting calls in the queue. Within
    the loop, the consultant answers the call (using the `Answer` method) and the
    log is generated (using the `Log` auxiliary method). Then, the thread is suspended
    for a random number of milliseconds (between 1,000 and 10,000) to simulate the
    various length of a call. When this has elapsed, the call ends (by calling the
    `End` method) and the proper log is generated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of code necessary for this example is the `Log` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the example, you will receive a result similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: That's all! You have just completed the first example regarding the queue data
    structure. If you want to learn more about the thread-safe version of the queue,
    let's proceed to the next section and take a look at the next example.
  prefs: []
  type: TYPE_NORMAL
- en: Example – call center with many consultants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The example shown in the preceding section has been intentionally simplified
    to make understanding a queue much simpler. However, it is high time you make
    it more related to real-world problems. In this section, you will see how to expand
    it to support many consultants, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/40966381-d05b-420f-bf0e-78608de68883.png)'
  prefs: []
  type: TYPE_IMG
- en: What is important is that both callers and consultants will work at the same
    time. If there are more incoming calls than available consultants, a new call
    will be added to the queue and will wait until there is a consultant who can answer
    the call. If there are too many consultants and few calls, the consultants will
    wait for a call. To perform this task, you will create a few threads, which will
    access the queue. Therefore, you need to use the thread-safe version of the queue
    using the `ConcurrentQueue` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the code! First, you need to declare the `IncomingCall`
    class, of which the code is exactly the same as in the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'There are various modifications necessary in the `CallCenter` class, such as
    replacing an instance of the `Queue` class with an instance of the `ConcurrentQueue`
    generic class. The suitable fragment is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As the `Enqueue` method is available in both the `Queue` and `ConcurrentQueue`
    classes, no changes are necessary in the most important part of the `Call` method.
    However, the small modification is introduced to return the number of waiting
    calls after adding a new call to the queue. The modified code is follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Dequeue` method does not exist in the `ConcurrentQueue` class. For this
    reason, you need to slightly modify the `Answer` method to use the `TryDequeue`
    method, which returns a value indicating whether the element is removed from the
    queue. The removed element is returned using the `out` parameter. The suitable
    part of code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'No further modifications are necessary in the remaining methods declared in
    the `CallCenter` class, namely `End` and `AreWaitingCalls`. Their code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Significantly more changes are required in the `Program` class. Here, you need
    to start four threads. The first represents callers, while the other three represent
    consultants. First, let''s take a look at the code of the `Main` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, just after the creation of the `CallCenter` instance, you start the execution
    of four actions, namely representing callers and three consultants, using the
    `Invoke` static method of the `Parallel` class from the `System.Threading.Tasks`
    namespace. The lambda expressions are used to specify methods that will be called,
    namely `CallersAction` for callers-related operations and `ConsultantAction` for
    consultant-related tasks. You can also specify additional parameters, such as
    a name and color for a given consultant.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CallersAction` method represents operations performed in a cyclical way
    by many callers. Its code is shown in the following block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The most important part of the code is the `while` loop, which is executed infinitely.
    Within it, you get a random number as an identifier of a client (`clientId`) and
    the `Call` method is called. The number of waiting calls is logged, together with
    the client identifier. At the end, the callers-related thread is suspended for
    a random number of milliseconds in the range between 1,000 ms and 5,000 ms, that
    is, between 1 and 5 seconds, to simulate the delay between another call made by
    a caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next method is named `ConsultantAction` and is executed on a separate thread
    for each consultant. The method takes three parameters, namely an instance of
    the `CallCenter` class, as well as a name and color for the consultant. The code
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the `CallersAction` method, the most important and interesting operations
    are performed in the infinite `while` loop. Within it, the consultant tries to
    answer the first waiting call using the `Answer` method. If there are no waiting
    calls, the thread is suspended for 100 ms. Otherwise, the log is presented in
    the proper color, depending on the current consultant. Then, the thread is suspended
    for a random period of time between 1 and 10 seconds. After this time, the consultant
    ends the call, which is indicated by calling the `End` method, and generates the
    log. At the end, the thread is suspended for the random time between 500 ms and
    1,000 ms, which represents the delay between the end of a call and the start of
    another one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last auxiliary method is named `Log` and is exactly the same as in the
    previous example. Its code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the program and wait for some time, you will receive a result
    similar to the one shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a800625-5b63-44b0-a245-6919a7f84ff7.png)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations! You have just completed two examples representing the application
    of a queue in the case of a call center scenario.
  prefs: []
  type: TYPE_NORMAL
- en: It is a good idea to modify various parameters of the program, such as the number
    of consultants, as well as delay times, especially the delay between the following
    calls performed by the callers. Then, you will see how the algorithm works in
    the case when there are too many callers or consultants.
  prefs: []
  type: TYPE_NORMAL
- en: However, how can you handle clients with priority support? In the current solution,
    they will wait in the same queue as clients with the standard support plan. Do
    you need to create two queues and first take clients from the prioritized queue?
    If so, what should happen if you introduce another support plan? Do you need to
    add another queue and introduce such modifications in the code? Fortunately, no!
    You can use another data structure, namely a priority queue, to support such a
    scenario, as explained in detail in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Priority queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **priority queue** makes it possible to extend the concept of a queue by
    setting **priority** for each element in the queue. It is worth mentioning that
    the priority can be specified simply as an integer value. However, it depends
    on the implementation whether smaller or greater values indicate higher priority.
    Within this chapter, it is assumed that the highest priority is equal to 0, while
    lower priority is specified by 1, 2, 3, and so on. Thus, the **dequeue** operation
    will return the element with the highest priority, which has been added first
    to the queue, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc121dc6-2124-4ec7-8ba1-033cd63f35e9.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's analyze the diagram. First, the priority queue contains two elements with
    the same priority (equal to **1**), namely **Marcin** and **Lily**. Then, the
    **Mary** element is added with higher priority (**0**), which means that this
    element is placed at the beginning of the queue, that is, before **Marcin**. In
    the next step, the **John** element is added with the lowest priority (**2**),
    so it is added at the end of the priority queue. The third column presents the
    addition of the **Emily** element with a priority equal to **1**, that is, the
    same as **Marcin** and **Lily**. For this reason, the **Emily** element is added
    just after **Lily**. According to the afore mentioned rules, you add the following
    elements, namely **Sarah** with a priority set to **0** and **Luke** with a priority
    equal to **1**. The final order is shown on the right-hand side of the preceding
    diagram.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, it is possible to implement the priority queue on your own. However,
    you can simplify this task by using one of the available NuGet packages, namely
    `OptimizedPriorityQueue`. More information about this package is available at [https://www.nuget.org/packages/OptimizedPriorityQueue](https://www.nuget.org/packages/OptimizedPriorityQueue).
  prefs: []
  type: TYPE_NORMAL
- en: 'Do you know how you can add this package to your project? If not, you should
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select Manage NuGet Packages from the context menu of the project node in the
    Solution Explorer window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the Browse tab in the opened window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `OptimizedPriorityQueue` in the search box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the OptimizedPriorityQueue item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the Install button on the right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on OK in the Preview Changes window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait until the Finished message is shown in the Output window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `OptimizedPriorityQueue` library significantly simplifies the application
    of a priority queue in various applications. Within it, the `SimplePriorityQueue`
    generic class is available, which contains a few useful methods, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Enqueue`, to add an element to the priority queue'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dequeue`, to remove an element from the beginning and return it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetPriority`, to return the priority of an element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UpdatePriority`, to update the priority of an element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Contains`, to check whether an element exists in the priority queue'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Clear`, to remove all elements from the priority queue'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can get the number of elements in the queue using the `Count` property.
    If you want to get an element from the beginning of the priority queue without
    removing it, you can use the `First` property. Moreover, the class contains a
    set of methods, which can be useful in multithreading scenarios, such as `TryDequeue`
    and `TryRemove`. It is worth mentioning that both the `Enqueue` and `Dequeue`
    methods are *O(log n)* operations.
  prefs: []
  type: TYPE_NORMAL
- en: After this short introduction to the topic of priority queues, let's proceed
    to the example of a call center with priority support, which is described in the
    following section.
  prefs: []
  type: TYPE_NORMAL
- en: Example – call center with priority support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As an example of a priority queue, let's present a simple approach to the call
    center example, where there are many callers (with different client identifiers),
    and only one consultant, who answers waiting calls, first from the priority queue
    and then from the clients with the standard support plan.
  prefs: []
  type: TYPE_NORMAL
- en: 'The afore mentioned scenario is presented in the following diagram. Calls with
    the standard priority are marked with **-**, while calls with priority support
    are indicated by *****, as shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/207dd920-227c-43c6-aa0d-851366641327.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a look at the order of elements in the priority queue. Currently,
    it contains only three elements, which will be served in the following order:
    **#5678** (who has priority support), **#1234**, and **#1468**. However, the call
    from the client with the identifier **#9641** causes the order to change to **#5678**,
    **#9641** (due to the priority support), **#1234**, and **#1468**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is high time to write some code! First, do not forget to add the `OptimizedPriorityQueue`
    package to the project, as explained earlier. When the library is configured properly,
    you can proceed to the implementation of the `IncomingCall` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Here, there is only one change in comparison to the previously presented scenario
    of the simple call center application, namely the `IsPriority` property is added.
    It indicates whether the current call has priority support (`true`) or standard
    support (`false`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Some modifications are also necessary in the `CallCenter` class, whose fragment
    is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the type of the `Calls` property has been changed from `Queue`
    to the `SimplePriorityQueue` generic class. The following changes are necessary
    in the `Call` method, with the code being presented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Within this method, a value of the `IsPriority` property (mentioned earlier)
    is set using the parameter. Moreover, while calling the `Enqueue` method, two
    parameters are used, not only the value of the element (an instance of the `IncomingCall`
    class), but also an integer value of the priority, namely `0` in the case of priority
    support, or `1` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'No more changes are necessary in the methods of the `CallCenter` class, namely
    in `Answer`, `End`, and `AreWaitingCalls`. The relevant code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s take a look at the code of the `Main` and `Log` methods in
    the `Program` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: You may be surprised to learn that only two changes are necessary in this part
    of the code! The reason for this is that the logic regarding the used data structure
    is hidden in the `CallCenter` class. Within the `Program` class, you call some
    methods and use properties exposed by the `CallCenter` class. You just need to
    modify how you add calls to the queue, as well as adjust the log presented when
    the call is answered by the consultant to also present the call's priority. That's
    all!
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the application, you will receive a result similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the calls are served in the correct order. This means that the
    calls from clients with priority support are served earlier than calls from clients
    with the standard support plan, despite the fact that such calls need to wait
    much longer to be answered.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned about three limited access data structures,
    namely stacks, queues, and priority queues. It is worth remembering that such
    data structures have strictly specified ways of accessing elements. All of them
    also have various real-world applications, and some have been mentioned and described
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: First, you saw how the stack operates according to the LIFO principle. In this
    case, you can only add an element at the top of the stack (the push operation),
    and only remove an element from the top (the pop operation). The stack has been
    shown in two examples, namely for reversing a word and for solving the Tower of
    Hanoi mathematical game.
  prefs: []
  type: TYPE_NORMAL
- en: In the following part of the chapter, you got to know the queue as a data structure,
    which operates according to the FIFO principle. In this case, enqueue and dequeue
    operations were presented. The queue has been explained using two examples, both
    regarding the application simulating a call center. Furthermore, you have learned
    how to run a few threads, as well as how to use the thread-safe variant of the
    queue, which is available while developing applications in the C# language.
  prefs: []
  type: TYPE_NORMAL
- en: The third data structure shown in this chapter is named the priority queue and
    is an extension of the queue that supports priorities of particular elements.
    To make using this data structure easier, you have been shown how to use the external
    NuGet package. As an example, the call center scenario has been extended to handle
    two support plans.
  prefs: []
  type: TYPE_NORMAL
- en: This is just the third chapter of this book and you have already learned a lot
    about various data structures and algorithms which are useful while developing
    applications in C#! Are you interested in increasing your knowledge by learning
    about dictionaries and sets? If so, let's proceed to the next chapter and learn
    more about such data structures!
  prefs: []
  type: TYPE_NORMAL
