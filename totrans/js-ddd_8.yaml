- en: Chapter 8. Seeing It All Come Together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All software projects are special and there can never be a "one size fits all"
    approach, but as we have seen, a lot of thought has gone into all kinds of different
    approaches to development. A project goes through many stages of development,
    often it starts out exploring the basic ideas, sometimes we can not even be sure
    at that stage what the domain of the project will be. We then begin to factor
    out a certain core competency of the application and a core domain starts to evolve.
    At this stage the involvement of the business experts is crucial to make sure
    the domain aligns with the business needs, and the project does not get sidetracked
    due to misunderstandings, while the ubiquitous language is evolving along the
    way. The project tends to grow from one or two developers to a larger team, and
    team organization becomes more important since we need to start thinking about
    the communication overhead involved in the development as the assumption that
    everybody is familiar with more or less everything in the codebase no longer holds
    true. At this point a team can decide to go for a domain-driven approach and start
    to really model the now established domain in more detail. Even though the involvement
    of the business experts might not be needed every day in the later stages, a consistent
    involvement is important to make sure a project does not depart from the core
    domain needs.
  prefs: []
  type: TYPE_NORMAL
- en: This idealized form of project growth is dependent on multiple environmental
    factors, not only does the team have to be set up to make the choices described,
    the application also needs to be ready for the approach. We've seen previously
    that not all projects work well with a domain-driven approach, and there are many
    different kinds of JavaScript projects, which can fit the approach at different
    stages of development.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we are taking a look at the different projects, some domains,
    and how those two things, together with domain-driven design, fit the whole picture.
    We will be exploring:'
  prefs: []
  type: TYPE_NORMAL
- en: The different kind of project, that involve JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How client- and server-side development influences projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The different problems and their suitability for domain-driven design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example domains for domain-driven design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The different kinds of JavaScript project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript, as a very versatile language, made its way through the different
    stages of development. Originally conceived as a way to enable more dynamic behavior
    in the browser, it has conquered not only the complex field of developing, almost
    thick with client-like applications using the browser as the platform and runtime,
    but it is now also seen in server-side applications most prominently using Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Going all the way from making a document look more interactive by incorporating
    effects, to rendering a whole application on the client side is a wide spectrum
    of complexity and applications. Some may warrant an approach with a larger focus
    on application-design, some might best be served by smaller script-like approaches
    keeping the logic simple and local for the best maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing the user experience
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many business applications are perfectly well served by an application comprised
    of a number of pages all rendered on the server side. For the longest times this
    has been the way to go, and still is most likely the simplest approach as it keeps
    the stack of technologies to a minimum. As soon as the pages start to get complex
    it can help the user experience a lot to add some dynamic elements. Those elements
    can be for pointing out features or to guide the user. It can be very useful to
    do some client-side validation of the input for example, so the user does not
    send an obvious invalid request and has to wait for a slow response from the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A form like this can be seen often, we want to prevent the user from being
    able to click the button until a checkbox is checked, and also maybe something
    needs to be agreed on before the request is valid. Having the validation on the
    server side is important, but giving some feedback to the user before hitting
    the button will be a great enhancement. A small JavaScript function, such as the
    following, can easily accomplish that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We check the value of the checkbox and deactivate or activate the button as
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: This is a business rule and we want to see it reflected in the code; on the
    other hand, the rule is also enforced on the server side, so the need to make
    it work beyond any doubt does not arise. Problems like these arise often in applications,
    and we don't want to reach for overpowered tools straight away. If we, for example,
    start designing the form object as a business object, and encapsulating the rule
    for whether the form is *send-able* or not, we would arrive at an arguably cleaner
    design, at the readability cost of the code. This is the constant trade-off present
    at projects that are largely UX enhancements. In general, mixing view-code with
    business rules is not good; on the other hand, over-engineering very small enhancements,
    such as the preceding code, gets easily lost in the overhead of creating a more
    complex infrastructure for a cleaner model.
  prefs: []
  type: TYPE_NORMAL
- en: UX enhancements like this one don't lend themselves nicely to a domain-driven
    approach, since the knowledge about the business logic will have to be replicated,
    with a separate adapter for the HTML representation and the server-model representation.
    Adapters like this create some overhead and, depending on the amount of functionality
    encapsulated, they do not necessarily make sense. As the code on the client side
    grows and moves more toward an application, it starts to make more sense.
  prefs: []
  type: TYPE_NORMAL
- en: Single-page applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In recent years, the concept of a thick client application has become more common
    again. In the early days of the Web, websites were static and later were enhanced
    using JavaScript to ease navigation or basic user interactions. In recent years,
    client-side applications in the browser started to grow to a level where a lot
    of business logic lived on the frontend, and the frontend itself became a true
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A long time ago, when the world still revolved around Mainframes, clients in
    a computing environment were often dumb terminals accepting the user input and
    showing the output. As the hardware grew more powerful, more and more business
    logic was moved to the client for processing, until we reached true client-side
    applications such as running Microsoft Office. We can see the same again in the
    browser now, as applications have become more complex and the browsers more capable.
  prefs: []
  type: TYPE_NORMAL
- en: A one-page application often implements large pieces of the business logic all
    implemented in JavaScript to serve as the thick client querying the server. Examples
    for such applications are plenty, ranging from the more traditional document-oriented
    style all the way to in-browser applications using HTML, CSS, and JavaScript as
    their runtime environment, taking over the browser more or less completely.
  prefs: []
  type: TYPE_NORMAL
- en: When developing an in-browser application, the structure of the underlying code
    matters a lot more than when enhancing some functionality of a webpage. The problem
    space is divided into several pieces. First, the code needs to be organized in
    such a way that it stays maintainable over a longer period of time as the applications
    grow and change. As the frontend application code now realizes bigger parts of
    the business logic, the maintenance burden grows and the risk of rewriting bigger
    parts grows with it. The application presents a major investment in the system.
    Second, even though the technology stack in the client seems fairly fixed with
    HTML, CSS, and JavaScript, best practices and browser support for features are
    evolving at a rapid pace. At the same time, backwards compatibility is crucial
    as developers don't have much control over the upgrade process of the users. Third,
    the performance aspect of a client-side application is important. Even though
    there have been massive strides in the speedup of JavaScript runtime engines,
    the users are expecting more and more from the applications and, more importantly,
    are running more and more applications in parallel as well. We can't expect our
    one-page application to own large parts of the machine it is running on, but we
    must be careful about spending resources.
  prefs: []
  type: TYPE_NORMAL
- en: The contrast of increased need for performance versus the need for flexibility
    is a driving factor in the development of frameworks and techniques to support
    the development of client-side applications. We want a framework to be flexible
    while at the same time refraining from over-abstraction, which may be costly in
    terms of performance for our applications. On the other hand, our users expect
    an increased amount of interactivity that requires more and more complex application
    code to manage as the client-side applications grow.
  prefs: []
  type: TYPE_NORMAL
- en: Different frameworks and their implications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The world of JavaScript frameworks is very vast, new frameworks with different
    promises are released constantly and abandoned constantly as well. All frameworks
    have their use cases and, while advocating different architectures, all consider
    providing a way to organize your JavaScript application essential.
  prefs: []
  type: TYPE_NORMAL
- en: On one side, there are small frameworks, or micro-frameworks, that are almost
    library-like, providing just a bare minimum of organization and abstraction. The
    most well known and probably most widely used of these is Backbone. The goal is
    to provide a way to route a user on the client side—handling the URL, and rewriting
    and updating the application state in the browser. On the other hand, the state
    is encapsulated into models, providing and abstracting the data access to the
    internal client-side state, as well as the remote server-side state, so a sync
    of these two can be managed.
  prefs: []
  type: TYPE_NORMAL
- en: On the other end of the spectrum, we find larger application frameworks, a popular
    one being Ember, providing a more integrated development experience in the browser.
    Handling data sync, routing too many different controllers in application pages,
    as well as an advanced view layer rendering different objects to the browser via
    templates including data binding between the interface and the backend model representation.
    This is very much along the lines of the old school approach of Smalltalk, such
    as the Model View Controller pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple application using Ember for giving names to our orcs could work like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A top-level application manages the context, and we then define routes and
    controllers like we do in most MVC applications. This model scales quite well
    and allows for very different applications. The advantage is that we can rely
    a lot on prebuilt infrastructure. For example, in the preceding code, the wiring
    between the route and the controller can be setup quite easily, with the declarative
    assigning `templateName` and `controllerName` to use. Also, the wiring with the
    view is almost done, allowing us to define the main application template as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Using `Handlebars.js` for templating, and using the `preassign` model for interaction,
    Ember is designed to scale quite large frontend applications, taking over the
    browser interactions and providing a complete application framework.
  prefs: []
  type: TYPE_NORMAL
- en: Along the lines of this, we can find almost everything in between. In a world
    of domain-driven development, we now have to choose what best suits our application
    and our style of development. It may seem like a smaller framework is better suited
    to domain-driven design, as it allows the developer to have more influence, this
    is not necessarily the case. The important thing for us should be the way we can
    hook into the framework. The same way we interact with it server-side, we want
    to abstract our code as simple JavaScript objects, seeing the framework as a layer
    for us to get the content for the user displayed and the input from the user back
    in our domain layer. We want our domain layer to be separated from the framework
    as best as possible. With the growing prevalence of model-view-controller and
    alike organizations in today's developments, the frameworks allow for a better
    separation organization-wise as long as we don't fall into the trap of developing
    around the framework, but stick with the discussed organization as plain objects
    outside the framework hooking in to the framework as an implementation of a needed
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering on the client side
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Depending on the application we are developing, going for a full client-side
    application might not be the way to go. Most business applications are, in the
    end, very task oriented, manipulating data via forms and triggering some logic
    based on this input. The result of the operations is then reflected in a document-like
    fashion. This represents how most business is done, it involves a process to accomplish
    a task, and ends with a report. Thinking about the application we have been working
    on throughout the book, we see a similar pattern. The part of the application
    we have been working on the most consists of several steps involving the dungeon
    master triggering a certain action by filling in details about a transport that
    is supposed to take place. The backend then decides if the conditions are met
    and if the request can be fulfilled and triggers the appropriate action. Most
    of the logic lives on the server side of the application, and due to consistency
    concerns, needs to live there as well. On the other hand, the client side is very
    form-oriented, the tasks involve one or more form steps that need to be accomplished
    according to the process for a given task. The logic for the process and the task
    is on the server, so a full client-side application will need to duplicate a lot
    of the server knowledge to give a client-side application feeling, but then we
    will still need to check with the backend for confirmation. This obviates the
    benefit of moving logic to the client side to a large degree.
  prefs: []
  type: TYPE_NORMAL
- en: 'In situations like this, a middle ground approach can make a lot of sense,
    ensuring that the advanced debugging capabilities and monitoring of the server
    side can be leveraged while still giving a more fluid feeling to the application.
    The idea is to render the snippets of HTML to be placed on the page, but place
    them on the page via JavaScript, making full page replacements unnecessary. The
    most common library used to achieve this is **pjax** for requesting the HTML snippets,
    which in turn uses jQuery to place the snippets on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The pjax requires the server to send an HTML snippet to be placed on a page
    as the result for a request in this example. It is just a paragraph tag containing
    some information about a Rambo movie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: On the client side, we only need to let pjax highjack all the links inside the
    container, making it sent a pjax request and insert the appropriate content. The
    end result is a page that acts like a normal HTML page with links, but the page
    will not totally refresh on a click. It will just reload the appropriate piece
    and update the window location.
  prefs: []
  type: TYPE_NORMAL
- en: This approach can be very useful when building server-heavy apps and still being
    able to maintain a fluid app-like interface without a lot of the build overhead
    involved in full client-side rendering. Again, we can see a big difference here,
    making the frontend more of a thin client, therefore this is maybe not a prime
    candidate for a domain-driven approach, but working closely with a backend build
    using such an approach because it now is the single source of truth about the
    application logic in general.
  prefs: []
  type: TYPE_NORMAL
- en: Using JavaScript server side
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript as a language, even though it has been developed for the browser,
    is not bound to only being executed in a browser context. A browser just naturally
    contains an environment for the execution of JavaScript in the context of a page.
    When we want to run JavaScript outside the browser, there is always the option
    to just execute it directly via a JavaScript engine. There are multiple different
    engines available, such as **Spidermonkey** from Mozilla or **V8** from Google.
    Just having JavaScript available is obviously not enough, so we need access to
    files, sockets, and a multitude of other things to be able to productively work
    with server-side code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Node.js has taken over this part, bundling the Google V8 engine with the standard
    POSIX functions for access to the system-level part. It is by no means the first,
    there is also **Rhino** from Mozilla, bundling the Java ecosystem with Java for
    allowing access to all the parts outside the JavaScript standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The same thing in Node.js looks a little different, and a little bit more like
    what we expect from JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With the basics of interaction being available, we can build complex server-side
    applications and leverage the nature of server-side development where it makes
    sense, as we have done throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the upcoming ECMAScript 6 standard, a new module syntax will be introduced
    to increase the modularity of JavaScript applications both on the client and server
    side. ECMAScript 6 is almost finished, but at the time of writing it was not available
    everywhere. A good source for upcoming changes, and explicitly for the ECMAScript
    6 modules, is [http://www.2ality.com/2014/09/es6-modules-final.html](http://www.2ality.com/2014/09/es6-modules-final.html).
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of a controlled environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The reason large parts of the book rely on Node.js as the execution environment
    is the fact that it provides a fixed set of features we can count on. The browser,
    on the other hand, has always been very flexible and changeable. This is a big
    advantage when it comes to the development of business applications. As developers,
    we of course always want to leverage the latest and greatest, and it can make
    a lot of sense to rely on these technologies where it makes sense, but we also
    need to be aware of where a stable platform is of a big advantage.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to model the business logic of an application, we hardly count on
    any new technologies. We need a stable environment where we can execute what we
    have and what is here to stay. The advantage of JavaScript, of course, is that
    we can execute on the client and the server side, which means that if we later
    decide to roll certain logic onto the client side, we can do so, and still fall-back
    to server-side execution of the rules for verification, if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced modularization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the past, JavaScript has always been known as the browser language and, for
    the longest time, loading scripts was outside of the scope of the language itself,
    but was handled by the HTML part of the environment via script tags.
  prefs: []
  type: TYPE_NORMAL
- en: The rise of more advanced applications on the client side and the rise of server-side
    JavaScript has changed the language. This is evolving to include a module standard
    in the next version. For now, there are multiple ways to load other resources
    and to use one of them is a good idea, what exactly is most likely not important.
    The important bit here is that loading external modules allows us to better separate
    our code into logical units, getting away from the 1000+ lines file a lot of the
    client-side JavaScript programs look like. On the server side, this is a solved
    problem and the client side is not far behind.
  prefs: []
  type: TYPE_NORMAL
- en: With these different kinds of JavaScript programs and challenges in mind, we
    can think about what we are aiming for when designing a business application in
    general and how we have seen domain-driven design take a role in the development
    process.
  prefs: []
  type: TYPE_NORMAL
- en: The different kinds of complexity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every business application is faced with different kinds of problems throughout
    the development. The goal of domain-driven design is to isolate the complexity
    of an application, making it easy to change and maintain, by providing a language
    as well as a set of rules for the interaction of objects in the domain.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen throughout the book, domain-driven design is all about modeling
    business logic, so it can be accessible for domain experts to judge and evaluate.
    This is an important part of an application and, if done right, it can save a
    lot of trouble throughout the development cycle. When driving an application through
    domain-driven design, we need to identify the core domain and its subdomains.
    Depending on what our domain is about, the pure business complexity that is there
    to model is, not the only complexity so.
  prefs: []
  type: TYPE_NORMAL
- en: Neither is every application complex for the business rules, nor does every
    application lend itself nicely to being modeled in an object-oriented approach
    like we've seen throughout. There are complexities that are of a different nature,
    more often closer to what the hard computer science thinks about as its core problem
    domain, and as with every domain it has its specific ways to talk and model those
    parts very, clearly and we should use this as well when we come across it.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Making computer science another business domain is a way of abstracting away
    the intricacies that we come across when dealing with computer science problems.
    More often than not, trying to expose these problems to the business domain itself
    is not useful and will lead to more confusion. We can think about computer-science
    related topics just as a core we interact with to solve very specific problems
    and develop it as such if we want to isolate it.
  prefs: []
  type: TYPE_NORMAL
- en: Algorithmic complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '|   | *In mathematics and computer science, an algorithm (i/ˈælɡərɪðəm/ AL-gə-ri-dhəm),
    is a self-contained step-by-step set of operations to be performed.* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Wikipedia* |'
  prefs: []
  type: TYPE_TB
- en: At their core, all the things we do can be described as algorithms. They may
    be very short and very unique, but they are a sequence of steps nonetheless. We
    have encountered algorithms in our business applications as a sequence of steps
    that have to take place to initiate the prisoner transport, for example. The algorithms
    we encountered are business rules, and best modeled as part of the domain itself
    since they involve the domain objects directly. However, there are other algorithms
    that we may reuse from mathematics or computer science that are more abstract
    and therefore don't fit well in the business domain.
  prefs: []
  type: TYPE_NORMAL
- en: When we talk about algorithmic complexity, we most often refer to well-known
    algorithms such as tree-searching or algorithmic data structures such as lists
    or skip-lists. These kind of abstract ideas don't lend themselves well to fitting
    into the domain we are modeling, but are somewhere outside. When we encounter
    a problem in the domain and it is well served by a known algorithm, we should
    take advantage of that fact and not muddy the domain with such knowledge but keep
    it separate.
  prefs: []
  type: TYPE_NORMAL
- en: There are applications, which are bound to have a high algorithmic complexity,
    and these are most likely not prime candidates for domain-driven design. An example
    for this may be search, where a lot of knowledge resides in the data structures
    making searching efficient and therefore useable on a larger scale. The important
    idea is that in such domains, the business experts are the developers and we should
    treat the domain in such a way that the developers can communicate best. The most
    fundamental idea stays the same—that we may want to foster communication through
    common terms, but in such a case, the common terms are developer specific, and
    the best way to express it is in code, so the approach is to write code and try
    it out.
  prefs: []
  type: TYPE_NORMAL
- en: Logical complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another field closely related to algorithmic problems is logical problems. Depending
    on the domain, these can appear frequently and with a varying degree of complexity.
    A good example for such problems are configurators of any type, for example, an
    application allowing you to order a car involves the problem that the extras can
    conflict. Depending on how many different extras and conflicts there are, the
    problem can get out of hand quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In logical programming, we state facts and let the engine derive possible solutions
    for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the configurator is backed by a rules engine, which
    allows it to determine potential conflicts in the configuration and reports them
    back to the user. For this to work, we create a list of facts or constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With this, a rules engine can check if the constraints are satisfied when we
    want to order the car.
  prefs: []
  type: TYPE_NORMAL
- en: Solving logical problems in applications is similar to algorithmic ones, best
    suited for a separate system built for that purpose, exposing a domain-specific
    logical language to express the problem clearly in logical terms, which is then
    wrapped in the domain.
  prefs: []
  type: TYPE_NORMAL
- en: The business rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we develop the business software, the complexities we are faced with most
    often are the business rules defined by the clients to which we develop the software.
    The complexity in these rules often does not stem from the fact that the rule
    itself has a high complexity, but the fact that the rules are not set in stone
    and the behavior can change. More importantly, it needs to change quickly to keep
    the software relevant for the business.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing business rules means tracking what the business needs to do, and
    this is more often than not based on facts in the head of the business domain
    experts. The important part of modeling the domain is extracting this knowledge,
    and verifying its validity with the business as a whole. This is the area where
    a solid domain model strives to make a difference.
  prefs: []
  type: TYPE_NORMAL
- en: When we are able to talk about the domain with the person who understands the
    domain best, we can verify quickly, and if we share a common language with this
    person, he or she can quickly explain to us new rules going forward. Often, complex
    data structures and algorithms are not the central part of building, such as an
    application, these pieces can be optimized by an external providing system, the
    understanding and flexible modeling of the domain is the power of a domain model.
  prefs: []
  type: TYPE_NORMAL
- en: The domains suitable for domain-driven design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book, we focused on building a business application, which in
    essence makes sure we don't over or under book our dungeon, and more specifically
    to manage the transfer of prisoners that need to be moved due to the constraints
    of the dungeon. We, as developers, had to rely heavily on the domain experts guiding
    us through the development, as we don't have the necessary knowledge of the business
    domain, yet. In this kind of scenario, the establishment of a language comes in
    very handy as it allows us to talk in a precise manner about what the problems
    are and how we can deal with new rules, from then on.
  prefs: []
  type: TYPE_NORMAL
- en: Previously, we have seen that not all domains lend themselves nicely to such
    a strategy, and even domains that do may contain parts that are best handled by
    secondary systems. Especially when starting out with a new project, we cannot
    be sure if it makes sense to invest in a heavy domain layer or not.
  prefs: []
  type: TYPE_NORMAL
- en: Banking applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A domain that is well specified, has a fixed ruleset, and is largely dealing
    with number should be a prime candidate for being served by well-developed software,
    so why is there not much accounting software out there, and why are the banks
    investing so heavily in their development teams?
  prefs: []
  type: TYPE_NORMAL
- en: A lot of people explore accounting problems from a domain-driven perspective,
    and the problems arise around similar areas. The first is the set of rules, even
    though the rules seem well defined from the outside, they contain a lot of edge
    cases that need to be covered, and covered correctly, as, by its nature, large
    amounts of money are moving through the system. These rules are largely known
    by a set of experts whose job it is to adjust them every time a change in market
    makes it necessary. This brings us to the second problem, a lot of very subtle
    changes need to be expressed and kept consistent across the system.
  prefs: []
  type: TYPE_NORMAL
- en: So, even though on the surface it seems that a relational database covers a
    lot of the cases in a banking application, the required agility for change and
    the intrinsic need for a lot of communication with banking experts makes banking
    a good candidate for applications following domain-driven design, if they indeed
    want to start a new development.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Banking is one of those domains better left to the experts. If there is no need
    to build your own accounting system, it's better to buy one of the shelf as the
    domain complexity and probability for error is very high.
  prefs: []
  type: TYPE_NORMAL
- en: Travel applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughout the book, we have been following a domain related to another prime
    candidate for domain-driven design, travel, and related booking management. Comparing
    a dungeon to a hotel may seem a little weird, but from a software point of view,
    the management is similar. We are trying to manage over- and underbooking while
    at the same time optimizing revenue.
  prefs: []
  type: TYPE_NORMAL
- en: Booking hotels is one of those domains that seem simple and well-defined on
    the surface, but are prone to many adjustments and complex rules when digging
    deeper. It will, for example, be quite easy to completely avoid overbooking when
    looking at database entries appropriately, but then again, this goes against the
    goal of maximizing revenue for our hotel. There is a certain amount of overbooking
    required for compensating the eventual dropping-out of guests.
  prefs: []
  type: TYPE_NORMAL
- en: This is not the only complex part of managing bookings, an important part of
    the business is adjusting to the season and the current market situation. Booking
    a hotel while a tradeshow is in town can be significantly more expensive than
    on a regular day, especially if not booked for the entire duration of the tradeshow
    since this would mean a room might stay empty even though it could have been booked
    easily when it was available for the entire timespan. On the other hand, partner
    discounts can make booking during these shows cheaper again for certain people,
    and we want to make sure that a certain amount of rooms are available for these
    people when booking other guests. All bookings also have multiple timelines that
    need to be managed, such as discount windows, refund windows, and more.
  prefs: []
  type: TYPE_NORMAL
- en: What makes travel even more interesting for domain-driven design, in recent
    years, is that the representation evolves a lot as well. While previously the
    systems were optimized to be worked by phone or by a small amount of booking agents,
    they started to be exposed to the general public via the web. This exposure led
    to a significant increase in requests and also increased the support needed. Even
    more recently, the systems are no longer operated directly, but needed to be accessible
    via APIs to be integrated into search engines.
  prefs: []
  type: TYPE_NORMAL
- en: All this makes travel complex, and way more than a store and load action from
    the database; especially, since the integration of many systems in combination
    with general public access puts a huge burden on the developed system's ability
    to grow and scale, not only in their performance, but more importantly in their
    complexity.
  prefs: []
  type: TYPE_NORMAL
- en: The domain prerequisites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The domains we have been looking at all involve different forms of complexity
    in the business areas that are served well using a domain-driven design approach.
    In the previous sections, we have seen a couple of domains suited well to this
    approach. What do they have in common?
  prefs: []
  type: TYPE_NORMAL
- en: As seen before, it is all about the different forms of complexity we need to
    approach. A domain that is moving fast in its business rule set needs more attention
    toward its modeling because rules need to be adjusted as they evolve. Even more
    importantly, evolving rules mean that the developers don't have a complete understanding
    of the rules, so the business experts need to be involved heavily. This means
    that the language we are building in domain-driven design pays off quickly. Therefore,
    one important part of domain-driven design is that it is about developer access
    and the ability to understand the domain. We want to be able to quickly get business
    experts integrated in the process to avoid misunderstanding. The business experts,
    in the end, are the ones who drive the domain. We, as developers, provide the
    software that allows the business to be more successful at what it does. As a
    part of our domain-driven design approach, we identified what really matters to
    the business now and how it can be made more efficient and less error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: Approaching the problem from the other side now, and still considering access,
    means access to the system from other systems needs to be simple. At the moment,
    this is true for a lot of domains with new devices being popular all the time
    and business in general driving towards a higher level of integration in a business-to-business
    environment. How does domain-driven design fit in there? The key again is access.
    We want to be able to provide multiple interfaces that are accessible from the
    outside, with the same underlying logic. In domain-driven design, we are all about
    building a strong service layer, and this layer can then be exposed to different
    systems via different interfaces without the need to duplicate logic, which will
    inherently risk a divergence of the parts and logic.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the name of this book suggests, it is already heavily influenced by the
    ideas Eric Evans presented in his book *Domain-Driven Design: Tackling Complexity
    in the Heart of Software*, *Addison-Wesley*, and I would recommend this as a follow-up.
    He goes in to much more detail about the general approach by providing different
    examples and from the perspective of a classic Java backend approach.'
  prefs: []
  type: TYPE_NORMAL
- en: Another book that should not be missing in any follow-up about software design
    is, of course, *Patterns of Enterprise Application Architecture*, *Martin Fowler*,
    *Addison-Wesley*, which follows most of the patterns used every day in object-oriented
    development and goes into more detail about the patterns in general. The book
    leans more heavily on the Java side, but as we have seen throughout this book,
    using JavaScript in an object-oriented way is very possible and will be recommended
    in a lot of the modeling scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With applications written in JavaScript becoming more and more complex, the
    need for stronger application design has increased. Browser applications are growing,
    and the business reliance on them grows as well. Due to this, what used to be
    a domain of backend development starts to become important in frontend development.
    For a long time now, people have been evolving the way backend applications can
    be modeled for flexibility, so they can grow with the business, and now browser
    applications need to do the same. There is a lot to learn from the approaches
    that have been developed over the years, and even though some are not directly
    transferable to JavaScript, or might not even be needed, the general ideas port
    over very well. I hope I was able to present some of these ideas throughout the
    book.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, with the rise and adoption of Node.js as a platform for application
    development, JavaScript has moved into the backend as well, and the same challenges
    that needed solving for Java or Ruby on the Rails backend systems, now need to
    be solved for JavaScript/Node.js. It is important to stay true to the nature of
    JavaScript, as with Node.js, the goal often is to make systems simpler and easier
    to manage in smaller chunks. This in turn means that a Node.js backend takes a
    lighter modeling approach than a classic enterprise Java system would have. This
    is empowering to the developers, as the overarching large-scale architecture discussions
    move toward a more practical approach being built bottom-up. This should not mean
    that architecture is not important, but with the split of complexity between frontend
    and backend systems, the complexity can be managed better with a lighter approach.
  prefs: []
  type: TYPE_NORMAL
