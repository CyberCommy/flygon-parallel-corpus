- en: Advanced TypeScript Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to look at aspects of TypeScript that go beyond
    the basics of the language. When used appropriately, these features provide a
    clean, intuitive way to work in TypeScript and will help you to craft professional-level
    code. Some of the things we cover here may not be new to you, but I am including
    them so that there is a common baseline of knowledge as we work through later
    chapters, as well as an understanding of why we will be using these features.
    We will also cover why we need these techniques; it is not merely enough to know
    how to apply something, we also need to know in what circumstances we should use
    them and what we need to consider when we do so. The focus of this chapter is
    not to create a dry, exhaustive list of each feature—instead, we are going to
    introduce the information we need to work through the rest of this book. These
    are practical techniques that we will apply again and again in our daily development.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: As this is a book on web development, we are also going to be creating a lot
    of UIs, so we are going to look at how we can create attractive interfaces using
    the popular Bootstrap framework.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Using different types with union types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining types with intersection types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplifying type declarations with type aliases
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deconstructing objects with REST properties
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coping with a variable number of parameters using REST
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Aspect-Oriented Programming** (**AOP**) using decorators'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composing types using mixins
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the same code with different types and using generics
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping values using maps
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating asynchronous code with promises and async/await
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating UIs with Bootstrap
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to complete this chapter, you are going to need Node.js installed.
    You can download and install Node.js from [https://nodejs.org/en/](https://nodejs.org/en/).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also need the TypeScript compiler installed. There are two ways to
    do this through Node.js using the **Node Package Manager** (**NPM**). If you want
    the same version of TypeScript used in all of your applications and are happy
    that they will all run on the same version whenever you update it, use the following
    command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you want the version of TypeScript to be local to a particular project,
    type the following in the project folder:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For a code editor, you can use any suitable editor or even a basic text editor.
    Throughout this book, I will be using Visual Studio Code, a free cross-platform
    **integrated development environment** (**IDE**), available at [https://code.visualstudio.com/](https://code.visualstudio.com/).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: All code is available on GitHub at [https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter01](https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter01).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Building future-proof TypeScript with tsconfig
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As TypeScript has grown in popularity, it has benefited from a rapidly evolving
    open source architecture. The design goals behind the original implementation
    means that it has proven to be a popular choice for developers, from those who
    were new to JavaScript-based development to seasoned professionals. This popularity
    means that the language has quickly gained new features, some straightforward
    and others geared toward developers who are working on the cutting edge of the
    JavaScript ecosystem. This chapter aims to address the features that TypeScript
    has introduced to match either current or upcoming ECMAScript implementations
    that you might not have encountered previously.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: As we progress through this chapter, I will occasionally call out features that
    require a newer ECMAScript standard. In some cases, TypeScript will already have
    provided a poly-filled implementation of a feature that works with earlier versions
    of ECMAScript. In other cases, the version we compile against will have a feature
    that could not be back-filled beyond a certain point so it will be worth using
    a more up-to-date setting.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们在本章的进展，我会不时地指出需要较新ECMAScript标准的功能。在某些情况下，TypeScript已经提供了一个与较早版本的ECMAScript兼容的功能的poly-filled实现。在其他情况下，我们编译的版本将具有一个功能，该功能无法在某一点之后进行回填，因此值得使用更更新的设置。
- en: 'While it''s possible to compile TypeScript completely from the command line
    using nothing but parameters, I prefer to use `tsconfig.json`. You can either
    create this file manually or have TypeScript create it for you using the following
    command from the command line:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以完全使用命令行编译TypeScript，但我更喜欢使用`tsconfig.json`。您可以手动创建此文件，也可以使用以下命令从命令行让TypeScript为您创建它：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you want to copy my settings, these are the ones I have set up by default.
    When we need to update references, I will point out the entries that need to be
    added:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想复制我的设置，这些是我默认设置的设置。当我们需要更新引用时，我会指出需要添加的条目：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Introduction to advanced TypeScript features
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍高级TypeScript功能
- en: With each release, TypeScript takes big strides forward, adding features and
    capabilities that build on the basics of the language that were introduced back
    in version 1\. Since then, JavaScript has moved on and TypeScript has added features
    to target emerging standards, providing implementations for older implementations
    of JavaScript or by calling native implementations when targeting updated ECMA
    standards. In this first chapter, we are going to look at some of these features,
    which we will be using throughout this book.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 随着每个版本的发布，TypeScript不断迈出重要的步伐，增加了功能和能力，这些功能和能力是建立在语言基础之上的，这些语言基础是在1版本中引入的。从那时起，JavaScript已经发展，TypeScript已经添加了一些功能，以便针对新兴标准，提供对旧版JavaScript的实现，或者在针对更新的ECMA标准时调用本地实现。在本章中，我们将看一些这些功能，这些功能将贯穿本书的整个内容。
- en: Using different types with union types
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用联合类型与不同类型
- en: 'The first feature that we are going to look at is one of my favorites, that
    is, the ability to use union types. These types are used when a function expects
    a single parameter to be one type or another. Suppose, for instance, that we have
    a validation routine that needs to check whether a value is in a particular range
    and this validation could receive the value either from a textbox as a `string`
    value, or as a `number` value from a calculation. As each of the techniques for
    solving this issue have a lot in common, we''ll start off with a simple class
    that allows us to specify the minimum and maximum values that form our range and
    a function to actually perform the validation, as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要看的第一个功能是我最喜欢的功能之一，即使用联合类型的能力。当函数期望单个参数是一种类型或另一种类型时，就会使用这些类型。例如，假设我们有一个验证例程，需要检查值是否在特定范围内，这个验证可以从文本框中接收`string`值，也可以从计算中接收`number`值。由于解决这个问题的每种技术都有很多共同之处，我们将从一个简单的类开始，这个类允许我们指定形成我们范围的最小值和最大值，并且有一个实际执行验证的函数，如下所示：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you haven''t seen a `constructor` that looks like that before, that''s the
    equivalent of writing the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以前没有见过那样的`constructor`，那就相当于编写以下内容：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you need to check your parameters or manipulate them in some way, you should
    use this expanded format of parameters. If you are simply assigning the values
    to private fields, then the first format is a very elegant way to do this and
    saves cluttering up your code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要检查参数或以某种方式操纵它们，您应该使用参数的扩展格式。如果您只是将值分配给私有字段，那么第一种格式是一种非常优雅的方式，可以节省代码的混乱。
- en: 'There are a few ways that we could solve the problem of ensuring we only perform
    our validation using `string` or `number`. The first way we could solve this problem
    would be by providing two separate methods that accept the relevant type, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以解决确保我们只使用`string`或`number`进行验证的问题。我们可以通过提供两个接受相关类型的单独方法来解决这个问题，如下所示：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'While this technique would work, it''s not very elegant and it certainly doesn''t
    take advantage of the power of TypeScript. The second technique that we could
    use is to allow us to pass in the value without constraining it, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种技术可以工作，但它并不是非常优雅，而且它肯定没有充分利用TypeScript的强大功能。我们可以使用的第二种技术是允许我们传入值而不加以限制，如下所示：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That's definitely an improvement over our original implementation because we
    have settled on one signature for our function, which means that calling the code
    is a lot more consistent. Unfortunately, we can still pass an invalid type into
    the method, so if we passed `boolean` in, for instance, this code would compile
    successfully but it would fail at runtime.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对是对我们原始实现的改进，因为我们已经确定了函数的一个签名，这意味着调用代码更加一致。不幸的是，我们仍然可以将无效类型传递给方法，因此，如果我们传递`boolean`，这段代码将成功编译，但在运行时会失败。
- en: 'If we want to constrain our validation so that it only accepts strings or numbers,
    then we can use a union type. It doesn''t differ much from the last implementation
    but it does give us the compile time type safety that we''re after, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要限制我们的验证只接受字符串或数字，那么我们可以使用联合类型。它与上一个实现并没有太大的不同，但它确实给了我们编译时类型安全性，这正是我们想要的，如下所示：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The signature that identifies the type constraints as being a union is `type
    | type` in the function name. This tells the compiler (and us) what the valid
    types are for this method. As we have constrained the input to be `number` or `string`,
    once we have ruled out that the type is not `number`, we don't need to check `typeof`
    to see whether it's a `string` so we have simplified the code even further.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 标识类型约束为联合的签名是函数名称中的`type | type`。这告诉编译器（和我们）这种方法的有效类型是什么。因为我们已经限制了输入为`number`或`string`，所以一旦我们排除了类型不是`number`，我们就不需要检查`typeof`来查看它是否是`string`，所以我们甚至进一步简化了代码。
- en: We can chain as many types together as we need in a union statement. There's
    no practical limit but we have to make sure that each type in the union list needs
    a corresponding `typeof` check if we are going to handle it properly. The order
    of the types does not matter either, so `number | string` is treated the same
    as `string | number`. Something to remember though is if the function has lots
    of types combined together, then it is probably doing too much and the code should
    be looked at to see whether it can be broken up into smaller pieces.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在联合语句中链接尽可能多的类型。实际上没有实际限制，但我们必须确保联合列表中的每种类型都需要相应的`typeof`检查，如果我们要正确处理它。类型的顺序也不重要，所以`number
    | string`与`string | number`是相同的。但要记住的是，如果函数将许多类型组合在一起，那么它可能做得太多了，应该查看代码，看看是否可以将其分解成更小的部分。
- en: We can go further than this with union types. In TypeScript, we have two special
    types, `null` and `undefined`. These types can be assigned to anything unless
    we compile our code with the `–strictNullChecks` option or `strictNullChecks =
    true` if we're setting this as a flag in our `tsconfig.json` file. I like to set
    this value so that my code only handles null cases where it should, which is a
    great way to guard against side effects creeping in just because a function receives
    a null value. If we want to allow `null` (or `undefined`), we simply need to add
    these as a union type.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步使用联合类型。在TypeScript中，我们有两种特殊类型，`null`和`undefined`。除非我们使用`-strictNullChecks`选项编译我们的代码，或者如果我们在`tsconfig.json`文件中将其设置为`strictNullChecks
    = true`，否则这些类型可以分配给任何东西。我喜欢设置这个值，这样我的代码只处理应该处理的空值情况，这是防止副作用潜入的好方法，只是因为一个函数接收了一个空值。如果我们想允许`null`（或`undefined`），我们只需要将它们添加为联合类型。
- en: Combining types with intersection types
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用交集类型组合类型
- en: 'Sometimes, it''s important for us to have the ability to handle a case where
    we can bring multiple types together and treat them as one type. Intersection
    types are the types that have all properties available from each type that is
    being combined. We can see what an intersection looks like with the following
    simple example. First of all, we are going to create classes for a `Grid` along
    with a `Margin` to apply to that `Grid`, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，对我们来说很重要的是，我们有能力处理一种情况，即我们可以将多种类型合并在一起，并将它们视为一种类型。交集类型是正在合并的每种类型中都可用的所有属性的类型。我们可以通过以下简单的示例看到交集的样子。首先，我们将为`Grid`和`Margin`创建类，如下所示：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'What we are going to create is an intersection that will end up with `Width`
    and `Height` from the `Grid` property, along with `Left` and `Top` from `Margin`.
    To do this, we are going to create a function that takes in `Grid` and `Margin`
    and returns a type that contains all of these properties, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要创建的是一个交集，最终会得到`Grid`属性的`Width`和`Height`，以及`Margin`的`Left`和`Top`。为此，我们将创建一个函数，该函数接受`Grid`和`Margin`，并返回一个包含所有这些属性的类型，如下所示：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note, we are going to come back to this function later in this chapter when
    we look at object spread to see how we can remove a lot of the boilerplate copying
    of properties.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们在本章后面查看对象扩展时，我们将回到这个函数，看看如何消除大量属性的样板复制。
- en: The *magic* that makes this work is the way we define `consolidatedGrid`. We
    use `&` to join together the types we want to use to create our intersection.
    As we want to bring `Grid` and `Margin` together, we are using `<Grid & Margin>`
    to tell the compiler what our type will look like. We can see that we don't have
    to explicitly name this type; the compiler is smart enough to take care of this
    for us.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使这项工作的*魔法*是我们如何定义`consolidatedGrid`。我们使用`&`来连接我们想要使用的类型，以创建我们的交集。因为我们想要将`Grid`和`Margin`合并在一起，所以我们使用`<Grid
    & Margin>`来告诉编译器我们的类型将是什么样子。我们可以看到，我们不必明确命名这种类型；编译器足够聪明，可以为我们处理这个问题。
- en: 'What happens if we have the same properties present in both types? Does TypeScript
    prevent us from mixing these types together? As long as the property is of the
    same type, then TypeScript is perfectly happy for us to use the same property
    name. To see this in action, we are going to expand our `Margin` class to also
    include `Width` and `Height` properties, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在两种类型中都有相同的属性，会发生什么？TypeScript是否会阻止我们混合这些类型？只要属性是相同类型，TypeScript就可以完全允许我们使用相同的属性名称。为了看到这一点，我们将扩展我们的`Margin`类，以包括`Width`和`Height`属性，如下所示：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'How we handle these extra properties really depends on what we want to do with
    them. In our example, we are going to add `Width` and `Height` of `Margin` to
    `Width` and `Height` of `Grid`. This leaves our function looking like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何处理这些额外的属性取决于我们想要做什么。在我们的示例中，我们将`Margin`的`Width`和`Height`添加到`Grid`的`Width`和`Height`中。这样，我们的函数看起来像这样：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If, however, we wanted to try and reuse the same property name but the types
    of those properties were different, we can end up with a problem if those types
    have restrictions on them. To see the effect this has, we are going to expand
    our `Grid` and `Margin` classes to include `Weight`. `Weight` in our `Grid` class
    is a number and `Weight` in our `Margin` class is a string, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们想要尝试并重用相同的属性名称，但这些属性的类型不同，如果这些类型有限制，我们可能会遇到问题。为了看到这种影响，我们将扩展我们的`Grid`和`Margin`类以包括`Weight`。我们的`Grid`类中的`Weight`是一个数字，而我们的`Margin`类中的`Weight`是一个字符串，如下所示：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We are going to try and add the `Weight` types together in our `ConsolidatedGrid`
    function:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试在我们的`ConsolidatedGrid`函数中将`Weight`类型相加：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'At this point, TypeScript complains about this line with the following error:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，TypeScript会对这行代码进行以下错误提示：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: While there are ways to solve this issue, such as using a union type for `Weight`
    in `Grid` and parsing the input, it's generally not worth going to that trouble.
    If the type is different, this is generally a good indication that the behavior
    of the property is different, so we really should look to name it something different.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有解决这个问题的方法，比如在`Grid`中使用联合类型来解析输入的`Weight`，但通常不值得那么麻烦。如果类型不同，这通常是属性行为不同的一个很好的指示，所以我们真的应该考虑给它取一个不同的名字。
- en: While we are working with classes in our examples here, it is worth pointing
    out that intersections are not just constrained to classes. Intersections apply
    to interfaces, generics, and primitive types as well.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在这里的示例中使用类，但值得指出的是，交集不仅限于类。交集也适用于接口、泛型和原始类型。
- en: 'There are certain other rules that we need to consider when dealing with intersections.
    If we have the same property name but only one side of that property is optional,
    then the finalized property will be mandatory. We are going to introduce a padding
    property to our `Grid` and `Margin` classes and make `Padding` optional in `Margin`,
    as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理交集时，还有一些其他规则需要考虑。如果我们有相同的属性名称，但只有一个属性是可选的，那么最终的属性将是必需的。我们将在`Grid`和`Margin`类中引入一个`padding`属性，并在`Margin`中将`Padding`设为可选，如下所示：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Because we have provided a mandatory `Padding` variable, we cannot change our
    intersection, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们提供了一个强制的`Padding`变量，我们不能改变我们的交集，如下所示：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As there is no guarantee that the margin padding will be assigned, the compiler
    is going to do its best to stop us. To solve this, we are going to change our
    code to apply the `margin` padding if it is set and fall back to the `grid` padding
    if it is not. To do this, we are going to make a simple fix:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于不能保证边距填充会被分配，编译器会尽力阻止我们。为了解决这个问题，我们将改变我们的代码，如果设置了`margin`填充，则应用`margin`填充，如果没有，则回退到`grid`填充。为了做到这一点，我们将做一个简单的修复：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This strange-looking syntax is called the ternary operator. This is a shorthand
    way of writing the following—if `margin.Padding` has a value, let `consolidatedGrid.Padding`
    equal that value; otherwise, let it equal `grid.Padding`. This could have been
    written as an if/else statement but, as this is a common paradigm in languages
    such as TypeScript and JavaScript, it is worth becoming familiar with.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这种看起来奇怪的语法被称为三元运算符。这是一种简写的方式，相当于写成以下形式——如果`margin.Padding`有值，则让`consolidatedGrid.Padding`等于该值；否则，让它等于`grid.Padding`。这本可以写成if/else语句，但是，由于这是TypeScript和JavaScript等语言中的常见范例，值得熟悉。
- en: Simplifying type declarations with type aliases
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类型别名简化类型声明
- en: Something that goes hand in hand with intersection types and union types are
    type aliases. Rather than cluttering our code with references to `string | number
    | null`, TypeScript gives us the ability to create a handy alias that is expanded
    out by the compiler into the relevant code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与交集类型和联合类型相辅相成的是类型别名。TypeScript允许我们创建一个方便的别名，而不是在代码中引用`string | number | null`，这个别名会被编译器展开成相关的代码。
- en: 'Suppose that we want to create a type alias that represents the union type
    of `string | number`, then we can create an alias that looks as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想创建一个代表`string | number`联合类型的类型别名，那么我们可以创建一个如下所示的别名：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we revisit our range validation sample, we can change the signature of our
    function to use this alias, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新审视我们的范围验证示例，我们可以更改函数的签名以使用这个别名，如下所示：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The important thing to notice in this code is that we don't really create any
    new types here. The type alias is just a syntactic trick that we can use to make
    our code more readable and, more importantly, help us to create code that is more
    consistent when we are working in larger teams.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中需要注意的重要事情是，我们并没有真正创建任何新类型。类型别名只是一个语法技巧，我们可以用它来使我们的代码更易读，更重要的是，帮助我们创建更一致的代码，尤其是在大型团队中工作时。
- en: 'We can combine type aliases with types to create more complex type aliases
    as well. If we wanted to add `null` support to the previous type alias, we could
    add this type:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将类型别名与类型结合起来创建更复杂的类型别名。如果我们想要为之前的类型别名添加`null`支持，我们可以添加这个类型：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As the compiler still sees the underlying type and uses that, we can use the
    following syntax to call our `IsInRange` method:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于编译器仍然看到了底层类型并使用它，我们可以使用以下语法来调用我们的`IsInRange`方法：
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Obviously, this doesn't give us very consistent-looking code, so we can change
    `string | number` to `StringOrNumber`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这样做不会给我们带来非常一致的代码，所以我们可以将`string | number`改为`StringOrNumber`。
- en: Assigning properties using object spread
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用对象展开分配属性
- en: In the `ConsolidatedGrid` example from the *Intersection types* section, we
    assigned each property to our intersection individually. Depending on the effect
    that we are trying to achieve, there is another way that we could have created
    our `<Grid & Margin>` intersection type with less code. Using a spread operator,
    we could perform a shallow copy of the properties from one or more of our input
    types automatically.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在*交集类型*部分的`ConsolidatedGrid`示例中，我们分别将每个属性分配给了我们的交集。根据我们试图实现的效果，我们还可以用另一种方式用更少的代码创建我们的`<Grid
    & Margin>`交集类型。使用展开运算符，我们可以自动从一个或多个输入类型中复制属性的浅层副本。
- en: 'First, let''s see how we can rewrite our earlier example so that it automatically
    populates the margin information:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何重写之前的例子，以便自动填充边距信息：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When we are instantiating our `consolidatedGrid` function, this code copies
    in the properties from `margin` and fills them in. The triple dots (`...`) tell
    the compiler to treat this as a spread operation. As we have already populated
    `Width` and `Height`, we use `+=` to simply add in the elements from the grid.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实例化我们的`consolidatedGrid`函数时，这段代码会复制`margin`的属性并填充它们。三个点(`...`)告诉编译器将其视为展开操作。由于我们已经填充了`Width`和`Height`，我们使用`+=`来简单地添加网格中的元素。
- en: 'What happens if we wanted to apply both the values from `grid` and `margin`
    instead? To do this, we can change our instantiation to look like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要同时应用`grid`和`margin`的值呢？为了做到这一点，我们可以将我们的实例化更改为如下所示：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This fills in the `Grid` values with the values from `grid` and then fills
    in the `Margin` values from `margin`. This tells us two things. The first is that
    the spread operation maps the appropriate property to the appropriate property.
    The second thing this tells us is that the order that it does this in is important.
    As `margin` and `grid` both have the same properties, the values set by `grid`
    are overwritten by the values set by `margin`. In order to set the properties
    so that we see the values from `grid` in `Width` and `Height`, we have to reverse
    the order of this line. In reality, of course, we can see the effect as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将`Grid`的值填充到`grid`的值中，然后将`Margin`的值填充到`margin`的值中。这告诉我们两件事。第一，扩展操作将适当的属性映射到适当的属性。第二，这告诉我们它执行的顺序很重要。由于`margin`和`grid`都具有相同的属性，`grid`设置的值将被`margin`设置的值覆盖。为了设置属性，以便我们在`Width`和`Height`中看到`grid`的值，我们必须颠倒这行的顺序。当然，实际上，我们可以看到效果如下：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'At this stage, we should really take a look at the JavaScript that TypeScript
    produces out of this. This is what the code looks like when we compile it using
    ES5:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们应该真正看一下TypeScript从中产生的JavaScript。当我们使用ES5编译它时，代码看起来像这样：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If, however, we compile the code using the version ES2015 or later, the `__assign`
    function is removed and our `ConsolidatedGrid` JavaScript looks as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们使用ES2015或更高版本编译代码，`__assign`函数将被移除，我们的`ConsolidatedGrid` JavaScript看起来如下：
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: What we are seeing here is that TypeScript works hard to ensure that it can
    produce code that works regardless of which version of ECMAScript we are targeting.
    We didn't have to worry whether the feature was available or not; we left it to
    TypeScript to fill in the blanks for us.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到的是，TypeScript努力确保它可以生成无论我们针对的ECMAScript版本是哪个都能工作的代码。我们不必担心该功能是否可用；我们把这个问题留给TypeScript来填补空白。
- en: Deconstructing objects with REST properties
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用REST属性解构对象
- en: Where we used spread operators to build up an object, we can also deconstruct
    objects with something called a REST property. Deconstructing simply means that
    we are going to take a complex *thing* and break it down into simpler ones. In
    other words, destructuring happens when we assign the elements inside an array
    or an object's properties to individual variables. While we have always been able
    to break complex objects and arrays down into simpler types, TypeScript provides
    a clean and elegant way to break these types down using REST parameters, which
    can deconstruct both objects and arrays.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建对象时，我们使用扩展运算符，我们也可以使用REST属性解构对象。解构简单地意味着我们要把一个复杂的*东西*分解成更简单的东西。换句话说，解构发生在我们将数组或对象的属性中的元素分配给单独的变量时。虽然我们一直能够将复杂的对象和数组分解为更简单的类型，但TypeScript提供了一种干净而优雅的方式，使用REST参数来分解这些类型，可以解构对象和数组。
- en: 'In order to understand what REST properties are, we first need to understand
    how to deconstruct an object or an array. We are going to start off by deconstructing
    the following object literal, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解REST属性是什么，我们首先需要了解如何解构对象或数组。我们将从解构以下对象文字开始，如下所示：
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'One way that we could deconstruct this is by using the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式解构这个对象：
- en: '[PRE29]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'While this works, it''s not very elegant and there''s a lot of repetition.
    Fortunately, TypeScript adopts the JavaScript syntax for a simple deconstruction
    like this, which provides a much neater syntax:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样可以工作，但不够优雅，而且有很多重复。幸运的是，TypeScript采用了JavaScript的语法，用于像这样简单的解构，提供了一个更整洁的语法：
- en: '[PRE30]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Functionally, this results in the same individual items as the original implementation.
    The name of the individual properties must match the names of the properties in
    the object we are deconstructing—that''s how the language knows which variable
    matches with which property on the object. If we need to change the name of the
    property for some reason, we use the following syntax:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从功能上讲，这导致与原始实现相同的单独项目。单个属性的名称必须与我们解构的对象中的属性的名称匹配——这就是语言知道哪个变量与对象上的哪个属性匹配的方式。如果我们因某种原因需要更改属性的名称，我们使用以下语法：
- en: '[PRE31]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The idea behind a REST operator on an object is that it applies when you take
    a variable number of items, so we are going to deconstruct this object into the
    manufacturer and the other fields are going to be bundled into a REST variable,
    as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对象上的REST运算符的想法是，当你获取可变数量的项目时，它适用于对象，因此我们将这个对象解构为制造商，其他字段将被捆绑到REST变量中，如下所示：
- en: '[PRE32]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The REST operator must appear at the end of the assignment list; the TypeScript
    compiler complains if we add any properties after it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: REST运算符必须出现在赋值列表的末尾；如果我们在它之后添加任何属性，TypeScript编译器会抱怨。
- en: 'After this statement, `details` now contains the type and strings values. Where
    things get interesting is when we look at the JavaScript that has been produced.
    The form of destructuring in the previous example is the same in JavaScript. There
    is no equivalent to the REST property in JavaScript (certainly in versions up
    to ES2018), so TypeScript produces code for us that gives us a consistent way
    to deconstruct more complex types:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个语句之后，`details`现在包含了类型和字符串值。有趣的地方在于我们看一下生成的JavaScript。在前面的例子中，解构的形式在JavaScript中是相同的。在JavaScript中没有REST属性的等价物（至少在ES2018之前的版本中没有），因此TypeScript为我们生成了代码，让我们以一种一致的方式解构更复杂的类型：
- en: '[PRE33]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Array destructuring works in a similar fashion to object destructuring. The
    syntax is virtually identical to the object version; the differences being that
    it uses `[ ]` to destructure in place of `{ }`, which the object version uses,
    and that the order of the variables is based on the position of the item in the
    array.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 数组解构与对象解构类似。语法与对象版本几乎相同；不同之处在于它使用`[]`来解构，而对象版本使用`{}`，以及变量的顺序是基于数组中项目的位置。
- en: 'The original method of destructuring an array relied on the variable being
    associated with an item at a certain index in the array:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 解构数组的原始方法依赖于将变量与数组中特定索引处的项目关联起来：
- en: '[PRE34]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Using array destructuring, we can change this syntax to be much more concise,
    as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组解构，我们可以将此语法更改为更简洁的形式，如下所示：
- en: '[PRE35]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Knowing that the TypeScript team are good at providing us with a consistent
    and logical experience, it should come as no surprise that we can also apply REST
    properties to arrays, using similar syntax:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 知道TypeScript团队擅长为我们提供一致和逻辑的体验，应该不会让人感到意外，我们也可以使用类似的语法将REST属性应用于数组：
- en: '[PRE36]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Yet again, there is no direct JavaScript equivalent, but the compiled TypeScript
    shows that JavaScript does provide the underlying fundamentals and the TypeScript
    designers have been able to elegantly roll this in using `array.slice:`
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，没有直接的JavaScript等价物，但编译后的TypeScript显示JavaScript确实提供了基本原理，TypeScript设计者能够优雅地使用`array.slice`进行整合。
- en: '[PRE37]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Coping with a variable number of parameters using REST
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用REST处理可变数量的参数
- en: The final thing we need to look at with regard to REST is the idea of functions
    having REST parameters. These aren't the same as REST properties but the syntax
    is so similar that we should find it easy to pick up. The problem that REST parameters
    solves is to cope with a variable number of parameters being passed into a function.
    The way to identify a REST parameter in a function is that it is preceded by the
    ellipsis and that it is typed as an array.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 关于REST我们需要看的最后一件事是函数具有REST参数的概念。这些与REST属性不同，但语法非常相似，我们应该很容易掌握。REST参数解决的问题是处理传递给函数的可变数量的参数。在函数中识别REST参数的方法是它前面有省略号，并且它被定义为数组。
- en: 'In this example, we are going to log out a header followed by a variable number
    of `instruments`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将记录一个标题，然后是可变数量的`instruments`：
- en: '[PRE38]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As the REST parameter is an array, this gives us access to array functions,
    which means that we can perform actions such as `forEach` from it directly. Importantly,
    REST parameters are different from the arguments object inside a JavaScript function
    because they start at the values that have not been named in the parameters list,
    whereas the arguments object contains a list of all of the arguments.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于REST参数是一个数组，这使我们可以直接从中执行`forEach`等操作。重要的是，REST参数与JavaScript函数内的arguments对象不同，因为它们从参数列表中未命名的值开始，而arguments对象包含所有参数的列表。
- en: 'As REST parameters were not available in ES5, TypeScript does the work necessary
    to provide JavaScript that simulates the REST parameter. First, we will see what
    this looks like when compiled as ES5, as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于ES5中没有REST参数，TypeScript会提供必要的工作来提供模拟REST参数的JavaScript。首先，我们将看到编译为ES5时的情况，如下所示：
- en: '[PRE39]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'When we look at the JavaScript produced from an ES2015 compilation (you will
    need to change the entry for target to ES2015 in the  `tsconfig.json` file), we
    see that it looks exactly the same as our TypeScript code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看从ES2015编译生成的JavaScript时（您需要在`tsconfig.json`文件中将目标更改为ES2015），我们看到它看起来与我们的TypeScript代码完全相同：
- en: '[PRE40]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: At this point, I cannot stress enough how important it is to take a look at
    the JavaScript that is being produced. TypeScript is very good at hiding complexity
    from us, but we really should be familiar with what is being produced. I find
    it a great way to understand what is going on *under the covers*, where possible,
    to compile using different versions of the ECMAScript standard and see what code
    is being produced.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我无法再强调查看生成的JavaScript有多么重要。TypeScript非常擅长隐藏复杂性，但我们确实应该熟悉生成的内容。我发现这是了解*底层*发生了什么的好方法，尽可能使用不同版本的ECMAScript标准进行编译，并查看生成的代码。
- en: AOP using decorators
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用装饰器的AOP
- en: One of my favorite features in TypeScript is the ability to use decorators.
    Decorators were introduced as an experimental feature and are pieces of code that
    we can use to modify the behavior of individual classes without having to change
    the internal implementation of the class. With this concept, we can adapt the
    behavior of an existing class without having to subclass it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript中我最喜欢的功能之一是使用装饰器。装饰器作为一项实验性功能被引入，它们是我们可以使用的代码片段，用于修改单个类的行为，而无需更改类的内部实现。通过这个概念，我们可以调整现有类的行为，而无需对其进行子类化。
- en: If you have come to TypeScript from a language such as Java or C#, you might
    notice that decorators look a lot like a technique known as AOP. What AOP techniques
    provide us with is the ability to extract repetitive code by cutting across a
    piece of code and separating this out into a different location. This means that
    we do not have to litter our implementations with code that will largely be boilerplate
    code, but which absolutely must be present in the running application.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从Java或C#等语言转到TypeScript，您可能会注意到装饰器看起来很像一种称为AOP的技术。AOP技术提供给我们的是通过跨越代码并将其分离到不同位置来提取重复代码的能力。这意味着我们不必在实现中散布大量基本代码，但这些代码在运行应用程序中必须存在。
- en: 'The easiest way to explain what a decorator is to start off with an example.
    Suppose we have a class where only users in certain roles can access certain methods,
    as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 解释装饰器的最简单方法是从一个例子开始。假设我们有一个类，只有特定角色的用户才能访问某些方法，如下所示：
- en: '[PRE41]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, we are going to create a user who has the `admin` and `user` roles, meaning
    that there are no problems in calling both methods in this class:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个具有`admin`和`user`角色的用户，这意味着在这个类中调用两种方法都没有问题：
- en: '[PRE42]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This gives us our expected output, as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们我们期望的输出，如下所示：
- en: '[PRE43]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If we were to create a user who only had the `user` role, we would expect that
    they should not be able to run the admin-only code. As our code has no role checking,
    the `AdminOnly` method will be run regardless of what roles the user has assigned.
    One way to fix this code would be to add code to check the entitlement and then
    add this inside each method.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建一个只有`user`角色的用户，我们期望他们不应该能够运行只有管理员才能运行的代码。由于我们的代码没有角色检查，无论用户分配了什么角色，`AdminOnly`方法都将被运行。修复这段代码的一种方法是添加代码来检查权限，然后将其添加到每个方法中。
- en: 'First, we are going to create a simple function to check whether or not the
    current user belongs to a particular role:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个简单的函数来检查当前用户是否属于特定角色：
- en: '[PRE44]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Revisiting our existing implementation, we are going to change our functions
    to call this check and determine whether or not `user` is allowed to run that
    method:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 重新审视我们现有的实现，我们将改变我们的函数来调用这个检查，并确定`user`是否被允许运行该方法：
- en: '[PRE45]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When we look at this code, we can see that there is a lot of repeated code
    in here. Worse still, while we have repeated code, there is a bug in this implementation.
    In the `AdminOnly` code, there is no return statement inside the `IsInRole` block
    so the code will still run the `AdminOnly` code, but it will tell us that the
    user is not in the `admin` role and will then output the message regardless. This
    highlights one of the problems with repeated code: it''s very easy to introduce
    subtle (or not-so-subtle) bugs without realizing it. Finally, we are violating
    one of the basic principles of good **object-oriented** (**OO**) development practice.
    Our classes and methods are doing things that they should not be doing; the code
    should be doing one thing and one thing only, so checking roles does not belong
    there. In [Chapter 2](3593e33f-7490-47b6-b129-ab5e08aef1b0.xhtml), *Creating a
    Markdown Editor with TypeScript*, we will cover this in more depth when we delve
    deeper into the OO development mindset.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看这段代码时，我们可以看到这里有很多重复的代码。更糟糕的是，虽然我们有重复的代码，但在这个实现中有一个bug。在`AdminOnly`代码中，在`IsInRole`块内没有返回语句，所以代码仍然会运行`AdminOnly`代码，但它会告诉我们用户不在`admin`角色中，然后无论如何输出消息。这突显了重复代码的一个问题：很容易引入微妙（或不那么微妙）的bug而不自知。最后，我们违反了良好的**面向对象**（**OO**）开发实践的基本原则之一。我们的类和方法正在做它们不应该做的事情；代码应该只做一件事，所以检查角色不属于那里。在[第2章](3593e33f-7490-47b6-b129-ab5e08aef1b0.xhtml)，*使用TypeScript创建Markdown编辑器*，当我们更深入地探讨面向对象开发思维方式时，我们将更深入地讨论这个问题。
- en: Let's see how we can use a method decorator to remove the boilerplate code and
    address the single responsibility issue.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用方法装饰器来消除样板代码并解决单一职责问题。
- en: 'Before we write our code, we need to ensure that TypeScript knows that we are
    going to use decorators, which are an experimental ES5 feature. We can do this
    by running the following command from the command line:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码之前，我们需要确保TypeScript知道我们将使用装饰器，这是一个实验性的ES5功能。我们可以通过在命令行中运行以下命令来做到这一点：
- en: '[PRE46]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Or, we can set this up in our `tsconfig` file:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以在我们的`tsconfig`文件中设置这一点：
- en: '[PRE47]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'With the decorator build features enabled, we can now write our first decorator
    to ensure that a user belongs to the `admin` role:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 启用了装饰器构建功能后，我们现在可以编写我们的第一个装饰器，以确保用户属于`admin`角色：
- en: '[PRE48]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Whenever we see a function definition that looks similar to this, we know that
    we are looking at a method decorator. TypeScript expects exactly these parameters
    in this order:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们看到一个函数定义看起来类似于这样的，我们知道我们正在看一个方法装饰器。TypeScript期望按照这个顺序精确地使用这些参数：
- en: '[PRE49]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The first parameter is used to refer to the element that we are applying it
    to. The second parameter is the name of the element, and the last parameter is
    the descriptor of the method we are applying our decorator to; this allows us
    to alter the behavior of the method. We must have a function with this signature
    to use as our decorator:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数用于引用我们正在应用的元素。第二个参数是元素的名称，最后一个参数是我们要应用装饰器的方法的描述符；这允许我们改变方法的行为。我们必须有一个具有这个签名的函数作为我们的装饰器。
- en: '[PRE50]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The internals of the decorator method are not as scary as they look. What we
    are doing is copying the original method from the descriptor and then replacing
    that method with our own custom implementation. This wrapped implementation is
    returned and will be the code that is executed when we encounter it:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器方法的内部并不像它们看起来那么可怕。我们所做的是从描述符中复制原始方法，然后用我们自己的自定义实现替换该方法。这个包装的实现被返回，并且在我们遇到它时将被执行的代码：
- en: '[PRE51]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In our wrapped implementation, we are performing the same role check. If the
    check passes, we apply the original method. By using a technique like this, we
    have added something that will avoid calling our methods if it does not need to
    in a consistent manner.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的包装实现中，我们正在执行相同的角色检查。如果检查通过，我们应用原始方法。通过使用这样的技术，我们已经添加了一些东西，可以以一致的方式避免调用我们的方法，如果不需要的话。
- en: 'In order to apply this, we use `@` in front of our decorator factory function
    name just before the method in our class. When we add our decorator, we must avoid
    putting a semicolon between it and the method, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应用这个，我们在我们的装饰器工厂函数名字前面使用`@`，就在我们的类的方法之前。当我们添加我们的装饰器时，我们必须避免在它和方法之间加上分号，如下所示：
- en: '[PRE52]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: While this code works for the `AdminOnly` code, it is not particularly flexible.
    As we add more roles, we will end up having to add more and more virtually identical
    functions. If only we had a way to create a general-purpose function that we could
    use to return a decorator that would accept a parameter that sets the role we
    wanted to allow. Fortunately, there is a way that we can do this using something
    called a decorator factory.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码对于`AdminOnly`代码来说是有效的，但它并不特别灵活。随着我们添加更多的角色，我们将不得不添加越来越多几乎相同的函数。如果我们能有一种方法来创建一个通用函数，我们可以用它来返回一个接受设置我们想要允许的角色的参数的装饰器。幸运的是，我们可以使用一种叫做装饰器工厂的东西来做到这一点。
- en: 'Put simply, a TypeScript decorator factory is a function that can receive parameters and
    uses the parameters to return the actual decorator. It only needs a couple of
    minor tweaks to our code and we have a working factory where we can specify the
    role we want to guard:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，TypeScript装饰器工厂是一个可以接收参数并使用这些参数返回实际装饰器的函数。我们的代码只需要进行一些微小的调整，就可以得到一个可以指定我们想要保护的角色的工作工厂：
- en: '[PRE53]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The only real differences here are that we have a function returning our decorator,
    which no longer has a name, and the factory function parameter is being used inside
    our decorator. We can now change our class to use this factory instead:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一的真正区别是我们有一个返回装饰器的函数，这个函数不再有名字，工厂函数参数被用在我们的装饰器内部。现在我们可以改变我们的类来使用这个工厂：
- en: '[PRE54]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: With this change, when we call our methods, only an admin will be able to access
    the `AdminOnly` method, while anyone who is a user will be able to call `AnyoneCanRun`.
    An important side note is that, our decorator only applies inside a class. We
    cannot use this on a standalone function.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种改变，当我们调用我们的方法时，只有管理员才能访问`AdminOnly`方法，而任何用户都可以调用`AnyoneCanRun`。一个重要的副作用是，我们的装饰器只适用于类内部。我们不能在独立的函数上使用它。
- en: The reason we call this technique a decorator is because it follows something
    called the **decorator pattern**. This pattern recognizes a technique that is
    used to add behavior to individual objects without affecting other objects from
    the same class and without having to create a subclass. A pattern is simply a
    formalized solution to problems that occur commonly in software engineering, so
    the names act as a useful shorthand for describing what is going on functionally.
    It will probably not come as much of a surprise to know that there is also a factory
    pattern. As we go through this book, we will encounter other examples of patterns,
    so we will be comfortable using them when we reach the end.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以称这种技术为装饰器，是因为它遵循了一种叫做**装饰器模式**的东西。这种模式认识到一种用于向单个对象添加行为而不影响同一类的其他对象并且不必创建子类的技术。模式只是对软件工程中常见问题的正式化解决方案，因此这些名称作为描述功能上发生的事情的有用缩写。也许不会讦知道还有一种工厂模式。当我们阅读本书时，我们将遇到其他模式的例子，因此当我们到达末尾时，我们将能够自如地使用它们。
- en: 'We can apply decorators to other items in a class as well. For instance, if
    we wanted to prevent an unauthorized user from even instantiating our class, we
    could define a class decorator. A class decorator is added to the class definition
    and expects to receive the constructor as a function. This is what our constructor
    decorator looks like when created from a factory:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将装饰器应用到类中的其他项目上。例如，如果我们想要防止未经授权的用户甚至实例化我们的类，我们可以定义一个类装饰器。类装饰器被添加到类定义中，并期望接收构造函数作为函数。这是我们从工厂创建的构造函数装饰器的样子：
- en: '[PRE55]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'When we apply this, we follow the same format of using the `@` prefix, so,
    when the code attempts to create a new instance of this class for a non-admin
    user, the application will throw an error, preventing this class from being created:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们应用这个时，我们遵循相同的格式，使用`@`前缀，所以当代码尝试为非管理员用户创建这个类的新实例时，应用程序会抛出错误，阻止这个类被创建：
- en: '[PRE56]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We can see that we have not declared any of our decorators inside a class. We
    should always create them as a top-level function because their usage is not suited
    for decorating a class, so we will not see syntax such as `@MyClass.Role("admin");`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们没有在类内声明任何装饰器。我们应该总是将它们创建为顶级函数，因为它们的用法不适合装饰一个类，所以我们不会看到诸如`@MyClass.Role("admin");`这样的语法。
- en: 'Beyond constructor and method decorations, we can decorate properties, accessors,
    and more. We aren''t going to go into these here, but they will be cropping up
    later on in this book. We will also be looking at how we can chain decorators
    together so we have a syntax that looks as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 除了构造函数和方法的装饰，我们还可以装饰属性、访问器等等。我们不会在这里详细介绍，但它们将在本书的后面出现。我们还将看看如何将装饰器链接在一起，以便我们有以下的语法：
- en: '[PRE57]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Composing types using mixins
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用混合类型进行组合
- en: When we first encounter classic OO theory, we come across the idea that classes
    can be inherited. The idea here is that we can create even more specialized classes
    from general-purpose classes. One of the more popular examples of this is that
    we have a vehicle class that contains basic details about a vehicle. We inherit
    from the `vehicle` class to make a `car` class. We then inherit from the `car`
    class to make a `sports car` class. Each layer of inheritance here adds features
    that aren't present in the class we are inheriting from.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们首次接触经典的面向对象理论时，我们会遇到类可以被继承的概念。这里的想法是我们可以从通用类创建更加专业化的类。其中一个更受欢迎的例子是我们有一个包含有关车辆基本细节的车辆类。我们从`vehicle`类继承，创建一个`car`类。然后我们从`car`类继承，创建一个`sports
    car`类。这里每一层继承都添加了在我们继承的类中不存在的特性。
- en: In general, this is a simple concept for us to work with, but what happens when
    we want to bring two or more seemingly unrelated things together to make our code?
    Let's examine a simple example.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这对我们来说是一个简单的概念，但是当我们想要将两个或更多看似无关的事物结合起来编写我们的代码时会发生什么呢？让我们来看一个简单的例子。
- en: 'It is a common thing with database applications to store whether a record has
    been deleted without actually deleting the record, and the time that the last
    update occurred on the record. At first glance, it would seem that we would want
    to track this information in a person''s data entity. Rather than adding this
    information into every data entity, we might end up creating a base class that
    includes this information and then inheriting from it:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The first problem with this approach is that it mixes details about the status
    of a record with the actual record itself. As we continue further into OO designs
    over the next few chapters, we will keep reinforcing the idea that mixing items
    together like this is not a good idea because we are creating classes that have
    to do more than one thing, which can make them less robust. The other problem
    with this approach is that, if we wanted to add the date the record was updated,
    we are either going to have to add the updated date to `ActiveRecord`, which means
    that every class that extends `ActiveRecord` will also get the updated date, or
    we are going to have to create a new class that adds the updated date and add
    this into our hierarchy chain, which means that we could not have an updated field
    without a deleted field.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: While inheritance definitely does have its place, recent years have seen the
    idea of composing objects together to make new objects gain in prominence. The
    idea behind this approach is that we build discrete elements that do not rely
    on inheritance chains. If we revisit our person implementation, we will build
    the same features using a feature called a mixin instead.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is define a type that will act as a suitable
    constructor for our mixin. We could name this type anything, but the convention
    that has evolved around mixins in TypeScript is to use the following type:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This type definition gives us something that we can extend to create our specialized
    mixins. The strange-looking syntax effectively says that, given any particular
    type, a new instance will be created using any appropriate arguments.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our record status implementation:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `RecordStatus` function extends the `Constructor` type by returning a new
    class that extends the constructor implementation. In this, we add our `Deleted`
    flag.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'To *merge* or mix in these two types, we simply do the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This has created something we can use to create a `Person` object with `RecordStatus`
    properties. It has not actually instantiated any objects yet. To do that, we instantiate
    the information in the same way we would with any other type:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, we also want to add details about when the record was last updated. We
    create another mixin, as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'To add this to `ActivePerson`, we change the definition to include `Timestamp`.
    It does not matter which mixin we put first, whether it is `Timestamp` or `RecordStatus`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'As well as properties, we can also add constructors and methods to our mixins.
    We are going to change our `RecordStatus` function to log out when the record
    was deleted. To do this, we are going to convert our `Deleted` property into a
    getter method and add a new method to actually perform the deletion:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'A word of warning about using mixins like this. They are a great technique,
    and they provide the ability to neatly do some really useful things, but we cannot
    pass them as a parameter unless we relax the parameter restrictions to any. That
    means we cannot use code like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: If we look at mixins in the TypeScript documentation at [https://www.typescriptlang.org/docs/handbook/mixins.html](https://www.typescriptlang.org/docs/handbook/mixins.html),
    we see that the syntax looks very different. Rather than dealing with that approach,
    with all of the inherent limitations it has, we will stick with the method here,
    which I was first introduced to at [https://basarat.gitbooks.io/typescript/docs/types/mixins.html](https://basarat.gitbooks.io/typescript/docs/types/mixins.html).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Using the same code with different types and using generics
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we first start developing classes in TypeScript, it is very common for
    us to repeat the same code again and again, only changing the type that we are
    relying on. For instance, if we wanted to store a queue of integers, we might
    be tempted to write the following class:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Calling this code is as easy as this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Later on, we decide that we also need to create a queue of strings, so we add
    code to do this as well:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: It is easy to see that the more code we add like this, the more tedious our
    job becomes and the more error-prone. Suppose that we forgot to put the shift
    operation in one of these implementations. The shift operation allows us to remove
    the first element from the array and return it, which gives us the core behavior
    of a queue (a queue operates as **First In First Out** (or **FIFO**)). If we had
    forgotten the shift operation, we would have implemented a stack operation instead
    (**Last In First Out** (or **LIFO**)). This could lead to subtle and dangerous
    bugs in our code.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'With generics, TypeScript provides us with the ability to create something
    called a generic, which is a type that uses a placeholder to denote what the type
    is that is being used. It is the responsibility of the code calling that generic
    to determine what type they are accepting. We recognize generics because they
    appear after the class name inside `<>`, or after things such as method names.
    If we rewrite our queue to use a generic, we will see what this means:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Let''s break this down:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Here, we are creating a class called `Queue` that accepts any type. The `<T>`
    syntax tells TypeScript that, whenever it sees `T` inside this class, it refers
    to the type that is passed in:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Here is our first instance of the generic type appearing. Rather than the array
    being fixed to a particular type, the compiler will use the generic type to create
    the array:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Again, we have replaced the specific type in our code with the generic instead.
    Note that TypeScript is happy to use this with the `undefined` keyword in the
    `Pop` method.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'Changing the way we use our code, we can now just tell our `Queue` object what
    type we want to apply to it:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: What is particularly helpful is that TypeScript enforces the type that we assign
    wherever it is referenced, so if we attempted to add a string to our `queue` variable,
    TypeScript would fail to compile this.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: While TypeScript does its best to protect us, we have to remember that it converts
    into JavaScript. This means that it cannot protect our code from being abused,
    so, while TypeScript enforces the type we assign, if we were to write external
    JavaScript that also called our generic types, there is nothing there to prevent
    adding an unsupported value. The generic is enforced at compile time only so,
    if we have code that is going to be called from outside our control, we should
    take steps to guard against incompatible types in our code.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'We aren''t limited to just having one type in the generic list. Generics allow
    us to specify any number of types in the definition as long as they have unique
    names, as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Keen-eyed readers will note that we have already encountered generics. When
    we created a mixin, we were using generics in our `Constructor` type.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens if we want to call a particular method from our generic? As TypeScript
    expects to know what the underlying implementation of the type is, it is strict
    about what we can do. This means that the following code is not acceptable:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'As TypeScript cannot guess that we want to use the `IStream` interface here,
    it is going to complain if we try to compile this. Fortunately, we can use a generic
    constraint to tell TypeScript that we have a particular type that we want to use
    here:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The `<T extends IStream>` part tells TypeScript that we are going to use *any*
    class that is based on our `IStream` interface.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: While we can constrain generics to types, we are generally going to want to
    constrain our generics to interfaces. This gives us a lot of flexibility in the
    classes that we use in the constraint and does not impose limitations that we
    can only use classes that inherit from a particular base class.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this in action, we are going to create two classes that implement `IStream`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'These can now be used as type constraints in our generic `Data` implementation:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We have just told `webStream` and `diskStream` that they are going to have
    access to our classes. To use them, we would still have to pass an instance, as
    follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'While we declared our generic and its constraints at the class level, we don''t
    have to do that. We can declare finer-grained generics, down to the method level,
    if we need to. In this case though, it makes sense to make it a class-level generic
    if we want to refer to that generic type in multiple places in our code. If the
    only place we wanted to apply a particular generic was at one or two methods,
    we could change our class signature to this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Mapping values using maps
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A situation that often comes up is needing to store a number of items with
    an easily looked up key. For instance, suppose we had a music collection broken
    down into a number of genres:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Against each one of these genres, we are going to store the details of a number
    of artists or composers. One approach we could take would be to create a class
    that represents each genre. While we could do that, it would be a waste of our
    coding time. The way we are going to solve this problem is by using something
    called a **map**. A map is a generic class that takes in two types: the type of
    key to use for the map and the type of objects to store in it.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'The key is a unique value that is used to allow us to store values or to quickly
    look things up—this makes maps a good choice for rapidly looking values up. We
    can have any type as a key and the value can be absolutely anything. For our music
    collection, we are going to create a class that uses a map with the genre as the
    key and a string array to represent the composer or artists:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'In order to populate a map, we call the `set` method, as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Retrieving the values from the map is as simple as calling `Get` with the relevant
    key:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: We have to add the `undefined` keyword to the return value here because there
    is a possibility that the map entry does not exist. If we forgot to take the possibility
    of undefined into account, TypeScript helpfully warns us of this. Yet again, TypeScript
    works hard to provide that robust safety net for our code.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now populate our collection, as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'If we want to add a single artist, our code becomes slightly more complex. Using
    set, we either add a new entry into our map or we replace the previous entry with
    our new one. As this is the case, we really need to check to see whether we have
    already added that particular key. To do this, we call the `has` method. If we
    have not added the genre, we are going to call set with an empty array. Finally,
    we are going to get the array out of our map using get so that we can push our
    values in:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'One more thing we are going to do to our code is change the `Add` method. Right
    now, that implementation overwrites previous calls to `Add` for a particular genre,
    which means that calling `AddArtist` and then `Add` would end up overwriting the
    artist we added individually with the ones from the `Add` call:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'In order to fix the `Add` method, it is a simple change to iterate over our
    artists and call the `AddArtist` method, as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Now, when we finish populating the `HeavyMetal` genre, our artists consist of
    `Iron Maiden`, `Tygers of Pan Tang`, `Saxon`, and `Doro`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Creating asynchronous code with promises and async/await
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We often need to write code that behaves in an asynchronous fashion. By this,
    we mean that we need to start a task off and leave it running in the background
    while we do something else. An example of this could be when we have made a call
    out to a web service, which may take a while to return. For a long time, the standard
    way in JavaScript was to use a callback. A big problem with this approach is that
    the more callbacks we need, the more complex and potentially error-prone our code
    becomes. This is where promises come in.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: A promise tells us that something will happen asynchronously; after the asynchronous
    operation finishes, we have the option to continue processing and work with the
    result of the promise, or to catch any exceptions that have been thrown by the
    exception.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a sample that demonstrates this in action:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: When we write a promise, we optionally take in two parameters—a `resolve` function
    and a `reject` function that can be called to trigger the error handling. Promises
    supply two functions for us to cope with these values, so `then()` will be triggered
    by successfully completing the operation and a separate `catch` function that
    copes with the `reject` function.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to run this code to see its effect:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'When we run this code, we get the following output:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Between the `Processing continues until the web service returns` and `Finished
    web service` lines, there is a four-second delay that we would expect because
    the application is waiting for the promise to return before it writes out the
    text in the `then()` function. What this is demonstrating to us is that the code
    is behaving asynchronously here because it is not waiting for the web service
    call to come back when it executed the processing console log.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'We might be tempted to think that this code is a bit too verbose, and that
    scattering `Promise<void>` is not the most intuitive way for others to understand
    that our code is asynchronous. TypeScript provides a syntactic equivalent that
    makes it much more apparent where our code is asynchronous. With the use of the
    `async` and `await` keywords, we easily turn our previous sample into something
    much more elegant:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The `async` keyword tells us that our function is returning `Promise`. It also
    tells the compiler that we want to process the function differently. Where we
    find `await` inside an `async` function, the application will pause that function
    at that point until the operation that is being awaited returns. At that point,
    processing continues, mimicking the behavior we saw inside the `then()` function
    from `Promise`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to catch errors in `async`/`await`, we really should wrap the code
    inside the function in a try...catch block. Where the error was explicitly caught
    by the `catch()` function, `async`/`await` does not have an equivalent way of
    handling errors, so it is up to us to deal with problems:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Whichever approach you choose to take is going to be a personal choice. The
    use of `async`/`await` just means it wraps the `Promise` approach so the runtime
    behavior of the different techniques is exactly the same. What I do recommend
    though is, once you decide on an approach in an application, be consistent. Don't
    mix styles as that will make it much harder for anyone reviewing your application.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Creating UIs with Bootstrap
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the remaining chapters, we are going to be doing a lot of work in the browser.
    Creating an attractive UI can be a difficult thing to do, especially in an era
    when we may also be targeting mobile devices in different layout modes. In order
    to make things easier for ourselves, we are going to rely quite heavily on Bootstrap.
    Bootstrap was designed to be a mobile device first UI framework that smoothly
    scales up to PC browsers. In this section, we are going to lay out the base template
    that contains the standard Bootstrap elements, and then have a look at how to
    lay out a simple page using features such as the Bootstrap grid system.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: We are going to start with the starter template from Bootstrap ([https://getbootstrap.com/docs/4.1/getting-started/introduction/#starter-template](https://getbootstrap.com/docs/4.1/getting-started/introduction/#starter-template)).
    With this particular template, we avoid the need to download and install the various
    CSS stylesheets and JavaScript files; instead, we rely on well-known **Content
    Delivery Networks** (**CDNs**) to source these files for us.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Where possible, I would recommend using CDNs to source external JavaScript and
    CSS files. This provides many benefits including not needing to maintain these
    files ourselves and getting the benefit of browser caching when the browser has
    encountered this CDN file elsewhere.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'The starter template looks as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The starting point for laying out content is the container. This goes in the
    preceding content section. The following code shows the `div` section:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The `container` class gives us that familiar Twitter look where it has a fixed
    size for each screen size. If we need to fill the full window, we can change this
    to `container-fluid`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the container, Bootstrap attempts to lay items out in a grid pattern.
    Bootstrap operates a system where each row of the screen can be represented as
    up to 12 discrete columns. By default, these columns are evenly spread out across
    the page so we can make complicated layouts just by choosing the appropriate number
    of columns to occupy for each part of our UI. Fortunately for us, Bootstrap provides
    an extensive set of predefined styles that help us to make layouts for different
    types of devices, whether they are PCs, mobile phones, or tablets. These styles
    all follow the same naming convention of `.col-<<size-identifier>>-<<number-of-columns>>`:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Extra small devices** | **Small devices** | **Medium devices**
    | **Large devices** |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
- en: '| **Dimensions** | Phones < 768px | Tablets >= 768px | Desktops >= 992px |
    Desktops >= 1200px |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
- en: '| **Prefix** | .col-xs- | .col-sm- | .col-md- | .col-lg- |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
- en: 'The way that the number of columns works is that each row should ideally add
    up to 12 columns. So, if we wanted to have a row made of content covering three
    columns, then six columns, and finally another three columns, we would define
    our rows to look like this inside our container:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'That styling defines how this would appear on small devices. It is possible
    to override the styles for larger devices. For instance, if we wanted large devices
    to use columns of five, two, and five, we could apply this styling:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: This is the beauty of a responsive layout system. It allows us to generate content
    that is appropriate for our devices.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how to add some content to our page. We are going to
    add `jumbotron` to our first column, some text into our second column, and a button
    in our third column:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Again, we are using CSS styling to control what our display looks like. By giving
    a `div` section a styling of `jumbotron`, Bootstrap immediately applies that styling
    for us. We controlled exactly what our button looks like by choosing to make it
    the primary button (`btn-primary`) and so on.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '`jumbotron` normally stretches across the width of all of the columns. We put
    it inside a three-column `div` just so we can see that the width and styling is
    controlled by the grid layout system and that `jumbotron` does not have some special
    properties that force it to lay out across the page.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: When I want to rapidly prototype a layout, I always follow a two-stage process.
    The first step is to draw on a piece of paper what I want my UI to look like.
    I could do this using a wireframe tool but I like the ability to quickly draw
    things out. Once I have got a general idea of what I want my layout to look like,
    I use a tool such as Layoutit! ([https://www.layoutit.com/](https://www.layoutit.com/))
    to put the ideas on to the screen; this also gives me the option to export the
    layout so that I can further refine it by hand.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we had a look at features of TypeScript that help us to build
    future-proof TypeScript code. We looked at how to set the appropriate ES levels
    to simulate or use modern ECMAScript features. We looked at how to use union and
    intersection types as well as how to create type aliases. We then looked into
    object spread and REST properties before we covered AOP with decorators. We also
    covered how to create and use map types, as well as using generics and promises.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: As preparation for the UIs we will be producing in the rest of this book, we
    briefly looked at using Bootstrap to lay out UIs and covered the basics of the
    Bootstrap grid layout system.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to build a simple markdown editor using a
    simple Bootstrap web page hooked up to our TypeScript. We will see how techniques
    such as design patterns and single responsibility classes help us to create robust
    professional code.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have written an application that allows users to convert from Fahrenheit
    into Celsius and from Celsius into Fahrenheit. The calculations are performed
    in the following classes:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: We want to write a method that accepts a temperature and an instance of either
    of these types, which will then perform the relevant calculation. What technique
    would we use to write this method?
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'We have written the following class:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: We want to use this in another class where we will add a number of commands.
    `Name` of the command is going to be the key that we can use to look up `Command`
    later on in our code. What would we use to provide this key-value functionality
    and how would we add records to it?
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: How would we automatically log that we were adding entries to the command we
    added in *Question 2* without adding any code inside our `Add` methods?
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have created a Bootstrap web page where we want to display a row with six
    medium columns of equal size. How would we do this?
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
