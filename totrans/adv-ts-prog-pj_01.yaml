- en: Advanced TypeScript Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to look at aspects of TypeScript that go beyond
    the basics of the language. When used appropriately, these features provide a
    clean, intuitive way to work in TypeScript and will help you to craft professional-level
    code. Some of the things we cover here may not be new to you, but I am including
    them so that there is a common baseline of knowledge as we work through later
    chapters, as well as an understanding of why we will be using these features.
    We will also cover why we need these techniques; it is not merely enough to know
    how to apply something, we also need to know in what circumstances we should use
    them and what we need to consider when we do so. The focus of this chapter is
    not to create a dry, exhaustive list of each feature—instead, we are going to
    introduce the information we need to work through the rest of this book. These
    are practical techniques that we will apply again and again in our daily development.
  prefs: []
  type: TYPE_NORMAL
- en: As this is a book on web development, we are also going to be creating a lot
    of UIs, so we are going to look at how we can create attractive interfaces using
    the popular Bootstrap framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using different types with union types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining types with intersection types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplifying type declarations with type aliases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deconstructing objects with REST properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coping with a variable number of parameters using REST
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Aspect-Oriented Programming** (**AOP**) using decorators'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composing types using mixins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the same code with different types and using generics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping values using maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating asynchronous code with promises and async/await
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating UIs with Bootstrap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to complete this chapter, you are going to need Node.js installed.
    You can download and install Node.js from [https://nodejs.org/en/](https://nodejs.org/en/).
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also need the TypeScript compiler installed. There are two ways to
    do this through Node.js using the **Node Package Manager** (**NPM**). If you want
    the same version of TypeScript used in all of your applications and are happy
    that they will all run on the same version whenever you update it, use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want the version of TypeScript to be local to a particular project,
    type the following in the project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For a code editor, you can use any suitable editor or even a basic text editor.
    Throughout this book, I will be using Visual Studio Code, a free cross-platform
    **integrated development environment** (**IDE**), available at [https://code.visualstudio.com/](https://code.visualstudio.com/).
  prefs: []
  type: TYPE_NORMAL
- en: All code is available on GitHub at [https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter01](https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter01).
  prefs: []
  type: TYPE_NORMAL
- en: Building future-proof TypeScript with tsconfig
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As TypeScript has grown in popularity, it has benefited from a rapidly evolving
    open source architecture. The design goals behind the original implementation
    means that it has proven to be a popular choice for developers, from those who
    were new to JavaScript-based development to seasoned professionals. This popularity
    means that the language has quickly gained new features, some straightforward
    and others geared toward developers who are working on the cutting edge of the
    JavaScript ecosystem. This chapter aims to address the features that TypeScript
    has introduced to match either current or upcoming ECMAScript implementations
    that you might not have encountered previously.
  prefs: []
  type: TYPE_NORMAL
- en: As we progress through this chapter, I will occasionally call out features that
    require a newer ECMAScript standard. In some cases, TypeScript will already have
    provided a poly-filled implementation of a feature that works with earlier versions
    of ECMAScript. In other cases, the version we compile against will have a feature
    that could not be back-filled beyond a certain point so it will be worth using
    a more up-to-date setting.
  prefs: []
  type: TYPE_NORMAL
- en: 'While it''s possible to compile TypeScript completely from the command line
    using nothing but parameters, I prefer to use `tsconfig.json`. You can either
    create this file manually or have TypeScript create it for you using the following
    command from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to copy my settings, these are the ones I have set up by default.
    When we need to update references, I will point out the entries that need to be
    added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Introduction to advanced TypeScript features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With each release, TypeScript takes big strides forward, adding features and
    capabilities that build on the basics of the language that were introduced back
    in version 1\. Since then, JavaScript has moved on and TypeScript has added features
    to target emerging standards, providing implementations for older implementations
    of JavaScript or by calling native implementations when targeting updated ECMA
    standards. In this first chapter, we are going to look at some of these features,
    which we will be using throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: Using different types with union types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first feature that we are going to look at is one of my favorites, that
    is, the ability to use union types. These types are used when a function expects
    a single parameter to be one type or another. Suppose, for instance, that we have
    a validation routine that needs to check whether a value is in a particular range
    and this validation could receive the value either from a textbox as a `string`
    value, or as a `number` value from a calculation. As each of the techniques for
    solving this issue have a lot in common, we''ll start off with a simple class
    that allows us to specify the minimum and maximum values that form our range and
    a function to actually perform the validation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you haven''t seen a `constructor` that looks like that before, that''s the
    equivalent of writing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you need to check your parameters or manipulate them in some way, you should
    use this expanded format of parameters. If you are simply assigning the values
    to private fields, then the first format is a very elegant way to do this and
    saves cluttering up your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few ways that we could solve the problem of ensuring we only perform
    our validation using `string` or `number`. The first way we could solve this problem
    would be by providing two separate methods that accept the relevant type, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'While this technique would work, it''s not very elegant and it certainly doesn''t
    take advantage of the power of TypeScript. The second technique that we could
    use is to allow us to pass in the value without constraining it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: That's definitely an improvement over our original implementation because we
    have settled on one signature for our function, which means that calling the code
    is a lot more consistent. Unfortunately, we can still pass an invalid type into
    the method, so if we passed `boolean` in, for instance, this code would compile
    successfully but it would fail at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to constrain our validation so that it only accepts strings or numbers,
    then we can use a union type. It doesn''t differ much from the last implementation
    but it does give us the compile time type safety that we''re after, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The signature that identifies the type constraints as being a union is `type
    | type` in the function name. This tells the compiler (and us) what the valid
    types are for this method. As we have constrained the input to be `number` or `string`,
    once we have ruled out that the type is not `number`, we don't need to check `typeof`
    to see whether it's a `string` so we have simplified the code even further.
  prefs: []
  type: TYPE_NORMAL
- en: We can chain as many types together as we need in a union statement. There's
    no practical limit but we have to make sure that each type in the union list needs
    a corresponding `typeof` check if we are going to handle it properly. The order
    of the types does not matter either, so `number | string` is treated the same
    as `string | number`. Something to remember though is if the function has lots
    of types combined together, then it is probably doing too much and the code should
    be looked at to see whether it can be broken up into smaller pieces.
  prefs: []
  type: TYPE_NORMAL
- en: We can go further than this with union types. In TypeScript, we have two special
    types, `null` and `undefined`. These types can be assigned to anything unless
    we compile our code with the `–strictNullChecks` option or `strictNullChecks =
    true` if we're setting this as a flag in our `tsconfig.json` file. I like to set
    this value so that my code only handles null cases where it should, which is a
    great way to guard against side effects creeping in just because a function receives
    a null value. If we want to allow `null` (or `undefined`), we simply need to add
    these as a union type.
  prefs: []
  type: TYPE_NORMAL
- en: Combining types with intersection types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, it''s important for us to have the ability to handle a case where
    we can bring multiple types together and treat them as one type. Intersection
    types are the types that have all properties available from each type that is
    being combined. We can see what an intersection looks like with the following
    simple example. First of all, we are going to create classes for a `Grid` along
    with a `Margin` to apply to that `Grid`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'What we are going to create is an intersection that will end up with `Width`
    and `Height` from the `Grid` property, along with `Left` and `Top` from `Margin`.
    To do this, we are going to create a function that takes in `Grid` and `Margin`
    and returns a type that contains all of these properties, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note, we are going to come back to this function later in this chapter when
    we look at object spread to see how we can remove a lot of the boilerplate copying
    of properties.
  prefs: []
  type: TYPE_NORMAL
- en: The *magic* that makes this work is the way we define `consolidatedGrid`. We
    use `&` to join together the types we want to use to create our intersection.
    As we want to bring `Grid` and `Margin` together, we are using `<Grid & Margin>`
    to tell the compiler what our type will look like. We can see that we don't have
    to explicitly name this type; the compiler is smart enough to take care of this
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens if we have the same properties present in both types? Does TypeScript
    prevent us from mixing these types together? As long as the property is of the
    same type, then TypeScript is perfectly happy for us to use the same property
    name. To see this in action, we are going to expand our `Margin` class to also
    include `Width` and `Height` properties, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'How we handle these extra properties really depends on what we want to do with
    them. In our example, we are going to add `Width` and `Height` of `Margin` to
    `Width` and `Height` of `Grid`. This leaves our function looking like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If, however, we wanted to try and reuse the same property name but the types
    of those properties were different, we can end up with a problem if those types
    have restrictions on them. To see the effect this has, we are going to expand
    our `Grid` and `Margin` classes to include `Weight`. `Weight` in our `Grid` class
    is a number and `Weight` in our `Margin` class is a string, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to try and add the `Weight` types together in our `ConsolidatedGrid`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, TypeScript complains about this line with the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: While there are ways to solve this issue, such as using a union type for `Weight`
    in `Grid` and parsing the input, it's generally not worth going to that trouble.
    If the type is different, this is generally a good indication that the behavior
    of the property is different, so we really should look to name it something different.
  prefs: []
  type: TYPE_NORMAL
- en: While we are working with classes in our examples here, it is worth pointing
    out that intersections are not just constrained to classes. Intersections apply
    to interfaces, generics, and primitive types as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are certain other rules that we need to consider when dealing with intersections.
    If we have the same property name but only one side of that property is optional,
    then the finalized property will be mandatory. We are going to introduce a padding
    property to our `Grid` and `Margin` classes and make `Padding` optional in `Margin`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we have provided a mandatory `Padding` variable, we cannot change our
    intersection, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As there is no guarantee that the margin padding will be assigned, the compiler
    is going to do its best to stop us. To solve this, we are going to change our
    code to apply the `margin` padding if it is set and fall back to the `grid` padding
    if it is not. To do this, we are going to make a simple fix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This strange-looking syntax is called the ternary operator. This is a shorthand
    way of writing the following—if `margin.Padding` has a value, let `consolidatedGrid.Padding`
    equal that value; otherwise, let it equal `grid.Padding`. This could have been
    written as an if/else statement but, as this is a common paradigm in languages
    such as TypeScript and JavaScript, it is worth becoming familiar with.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying type declarations with type aliases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Something that goes hand in hand with intersection types and union types are
    type aliases. Rather than cluttering our code with references to `string | number
    | null`, TypeScript gives us the ability to create a handy alias that is expanded
    out by the compiler into the relevant code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we want to create a type alias that represents the union type
    of `string | number`, then we can create an alias that looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If we revisit our range validation sample, we can change the signature of our
    function to use this alias, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The important thing to notice in this code is that we don't really create any
    new types here. The type alias is just a syntactic trick that we can use to make
    our code more readable and, more importantly, help us to create code that is more
    consistent when we are working in larger teams.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can combine type aliases with types to create more complex type aliases
    as well. If we wanted to add `null` support to the previous type alias, we could
    add this type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As the compiler still sees the underlying type and uses that, we can use the
    following syntax to call our `IsInRange` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, this doesn't give us very consistent-looking code, so we can change
    `string | number` to `StringOrNumber`.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning properties using object spread
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `ConsolidatedGrid` example from the *Intersection types* section, we
    assigned each property to our intersection individually. Depending on the effect
    that we are trying to achieve, there is another way that we could have created
    our `<Grid & Margin>` intersection type with less code. Using a spread operator,
    we could perform a shallow copy of the properties from one or more of our input
    types automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s see how we can rewrite our earlier example so that it automatically
    populates the margin information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: When we are instantiating our `consolidatedGrid` function, this code copies
    in the properties from `margin` and fills them in. The triple dots (`...`) tell
    the compiler to treat this as a spread operation. As we have already populated
    `Width` and `Height`, we use `+=` to simply add in the elements from the grid.
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens if we wanted to apply both the values from `grid` and `margin`
    instead? To do this, we can change our instantiation to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This fills in the `Grid` values with the values from `grid` and then fills
    in the `Margin` values from `margin`. This tells us two things. The first is that
    the spread operation maps the appropriate property to the appropriate property.
    The second thing this tells us is that the order that it does this in is important.
    As `margin` and `grid` both have the same properties, the values set by `grid`
    are overwritten by the values set by `margin`. In order to set the properties
    so that we see the values from `grid` in `Width` and `Height`, we have to reverse
    the order of this line. In reality, of course, we can see the effect as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'At this stage, we should really take a look at the JavaScript that TypeScript
    produces out of this. This is what the code looks like when we compile it using
    ES5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If, however, we compile the code using the version ES2015 or later, the `__assign`
    function is removed and our `ConsolidatedGrid` JavaScript looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: What we are seeing here is that TypeScript works hard to ensure that it can
    produce code that works regardless of which version of ECMAScript we are targeting.
    We didn't have to worry whether the feature was available or not; we left it to
    TypeScript to fill in the blanks for us.
  prefs: []
  type: TYPE_NORMAL
- en: Deconstructing objects with REST properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Where we used spread operators to build up an object, we can also deconstruct
    objects with something called a REST property. Deconstructing simply means that
    we are going to take a complex *thing* and break it down into simpler ones. In
    other words, destructuring happens when we assign the elements inside an array
    or an object's properties to individual variables. While we have always been able
    to break complex objects and arrays down into simpler types, TypeScript provides
    a clean and elegant way to break these types down using REST parameters, which
    can deconstruct both objects and arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to understand what REST properties are, we first need to understand
    how to deconstruct an object or an array. We are going to start off by deconstructing
    the following object literal, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'One way that we could deconstruct this is by using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'While this works, it''s not very elegant and there''s a lot of repetition.
    Fortunately, TypeScript adopts the JavaScript syntax for a simple deconstruction
    like this, which provides a much neater syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Functionally, this results in the same individual items as the original implementation.
    The name of the individual properties must match the names of the properties in
    the object we are deconstructing—that''s how the language knows which variable
    matches with which property on the object. If we need to change the name of the
    property for some reason, we use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The idea behind a REST operator on an object is that it applies when you take
    a variable number of items, so we are going to deconstruct this object into the
    manufacturer and the other fields are going to be bundled into a REST variable,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The REST operator must appear at the end of the assignment list; the TypeScript
    compiler complains if we add any properties after it.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this statement, `details` now contains the type and strings values. Where
    things get interesting is when we look at the JavaScript that has been produced.
    The form of destructuring in the previous example is the same in JavaScript. There
    is no equivalent to the REST property in JavaScript (certainly in versions up
    to ES2018), so TypeScript produces code for us that gives us a consistent way
    to deconstruct more complex types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Array destructuring works in a similar fashion to object destructuring. The
    syntax is virtually identical to the object version; the differences being that
    it uses `[ ]` to destructure in place of `{ }`, which the object version uses,
    and that the order of the variables is based on the position of the item in the
    array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The original method of destructuring an array relied on the variable being
    associated with an item at a certain index in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Using array destructuring, we can change this syntax to be much more concise,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Knowing that the TypeScript team are good at providing us with a consistent
    and logical experience, it should come as no surprise that we can also apply REST
    properties to arrays, using similar syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Yet again, there is no direct JavaScript equivalent, but the compiled TypeScript
    shows that JavaScript does provide the underlying fundamentals and the TypeScript
    designers have been able to elegantly roll this in using `array.slice:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Coping with a variable number of parameters using REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final thing we need to look at with regard to REST is the idea of functions
    having REST parameters. These aren't the same as REST properties but the syntax
    is so similar that we should find it easy to pick up. The problem that REST parameters
    solves is to cope with a variable number of parameters being passed into a function.
    The way to identify a REST parameter in a function is that it is preceded by the
    ellipsis and that it is typed as an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we are going to log out a header followed by a variable number
    of `instruments`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As the REST parameter is an array, this gives us access to array functions,
    which means that we can perform actions such as `forEach` from it directly. Importantly,
    REST parameters are different from the arguments object inside a JavaScript function
    because they start at the values that have not been named in the parameters list,
    whereas the arguments object contains a list of all of the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'As REST parameters were not available in ES5, TypeScript does the work necessary
    to provide JavaScript that simulates the REST parameter. First, we will see what
    this looks like when compiled as ES5, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'When we look at the JavaScript produced from an ES2015 compilation (you will
    need to change the entry for target to ES2015 in the  `tsconfig.json` file), we
    see that it looks exactly the same as our TypeScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: At this point, I cannot stress enough how important it is to take a look at
    the JavaScript that is being produced. TypeScript is very good at hiding complexity
    from us, but we really should be familiar with what is being produced. I find
    it a great way to understand what is going on *under the covers*, where possible,
    to compile using different versions of the ECMAScript standard and see what code
    is being produced.
  prefs: []
  type: TYPE_NORMAL
- en: AOP using decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of my favorite features in TypeScript is the ability to use decorators.
    Decorators were introduced as an experimental feature and are pieces of code that
    we can use to modify the behavior of individual classes without having to change
    the internal implementation of the class. With this concept, we can adapt the
    behavior of an existing class without having to subclass it.
  prefs: []
  type: TYPE_NORMAL
- en: If you have come to TypeScript from a language such as Java or C#, you might
    notice that decorators look a lot like a technique known as AOP. What AOP techniques
    provide us with is the ability to extract repetitive code by cutting across a
    piece of code and separating this out into a different location. This means that
    we do not have to litter our implementations with code that will largely be boilerplate
    code, but which absolutely must be present in the running application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to explain what a decorator is to start off with an example.
    Suppose we have a class where only users in certain roles can access certain methods,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are going to create a user who has the `admin` and `user` roles, meaning
    that there are no problems in calling both methods in this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us our expected output, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: If we were to create a user who only had the `user` role, we would expect that
    they should not be able to run the admin-only code. As our code has no role checking,
    the `AdminOnly` method will be run regardless of what roles the user has assigned.
    One way to fix this code would be to add code to check the entitlement and then
    add this inside each method.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are going to create a simple function to check whether or not the
    current user belongs to a particular role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Revisiting our existing implementation, we are going to change our functions
    to call this check and determine whether or not `user` is allowed to run that
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'When we look at this code, we can see that there is a lot of repeated code
    in here. Worse still, while we have repeated code, there is a bug in this implementation.
    In the `AdminOnly` code, there is no return statement inside the `IsInRole` block
    so the code will still run the `AdminOnly` code, but it will tell us that the
    user is not in the `admin` role and will then output the message regardless. This
    highlights one of the problems with repeated code: it''s very easy to introduce
    subtle (or not-so-subtle) bugs without realizing it. Finally, we are violating
    one of the basic principles of good **object-oriented** (**OO**) development practice.
    Our classes and methods are doing things that they should not be doing; the code
    should be doing one thing and one thing only, so checking roles does not belong
    there. In [Chapter 2](3593e33f-7490-47b6-b129-ab5e08aef1b0.xhtml), *Creating a
    Markdown Editor with TypeScript*, we will cover this in more depth when we delve
    deeper into the OO development mindset.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how we can use a method decorator to remove the boilerplate code and
    address the single responsibility issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we write our code, we need to ensure that TypeScript knows that we are
    going to use decorators, which are an experimental ES5 feature. We can do this
    by running the following command from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we can set this up in our `tsconfig` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'With the decorator build features enabled, we can now write our first decorator
    to ensure that a user belongs to the `admin` role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever we see a function definition that looks similar to this, we know that
    we are looking at a method decorator. TypeScript expects exactly these parameters
    in this order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter is used to refer to the element that we are applying it
    to. The second parameter is the name of the element, and the last parameter is
    the descriptor of the method we are applying our decorator to; this allows us
    to alter the behavior of the method. We must have a function with this signature
    to use as our decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The internals of the decorator method are not as scary as they look. What we
    are doing is copying the original method from the descriptor and then replacing
    that method with our own custom implementation. This wrapped implementation is
    returned and will be the code that is executed when we encounter it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In our wrapped implementation, we are performing the same role check. If the
    check passes, we apply the original method. By using a technique like this, we
    have added something that will avoid calling our methods if it does not need to
    in a consistent manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to apply this, we use `@` in front of our decorator factory function
    name just before the method in our class. When we add our decorator, we must avoid
    putting a semicolon between it and the method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: While this code works for the `AdminOnly` code, it is not particularly flexible.
    As we add more roles, we will end up having to add more and more virtually identical
    functions. If only we had a way to create a general-purpose function that we could
    use to return a decorator that would accept a parameter that sets the role we
    wanted to allow. Fortunately, there is a way that we can do this using something
    called a decorator factory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Put simply, a TypeScript decorator factory is a function that can receive parameters and
    uses the parameters to return the actual decorator. It only needs a couple of
    minor tweaks to our code and we have a working factory where we can specify the
    role we want to guard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The only real differences here are that we have a function returning our decorator,
    which no longer has a name, and the factory function parameter is being used inside
    our decorator. We can now change our class to use this factory instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: With this change, when we call our methods, only an admin will be able to access
    the `AdminOnly` method, while anyone who is a user will be able to call `AnyoneCanRun`.
    An important side note is that, our decorator only applies inside a class. We
    cannot use this on a standalone function.
  prefs: []
  type: TYPE_NORMAL
- en: The reason we call this technique a decorator is because it follows something
    called the **decorator pattern**. This pattern recognizes a technique that is
    used to add behavior to individual objects without affecting other objects from
    the same class and without having to create a subclass. A pattern is simply a
    formalized solution to problems that occur commonly in software engineering, so
    the names act as a useful shorthand for describing what is going on functionally.
    It will probably not come as much of a surprise to know that there is also a factory
    pattern. As we go through this book, we will encounter other examples of patterns,
    so we will be comfortable using them when we reach the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can apply decorators to other items in a class as well. For instance, if
    we wanted to prevent an unauthorized user from even instantiating our class, we
    could define a class decorator. A class decorator is added to the class definition
    and expects to receive the constructor as a function. This is what our constructor
    decorator looks like when created from a factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'When we apply this, we follow the same format of using the `@` prefix, so,
    when the code attempts to create a new instance of this class for a non-admin
    user, the application will throw an error, preventing this class from being created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We can see that we have not declared any of our decorators inside a class. We
    should always create them as a top-level function because their usage is not suited
    for decorating a class, so we will not see syntax such as `@MyClass.Role("admin");`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Beyond constructor and method decorations, we can decorate properties, accessors,
    and more. We aren''t going to go into these here, but they will be cropping up
    later on in this book. We will also be looking at how we can chain decorators
    together so we have a syntax that looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Composing types using mixins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we first encounter classic OO theory, we come across the idea that classes
    can be inherited. The idea here is that we can create even more specialized classes
    from general-purpose classes. One of the more popular examples of this is that
    we have a vehicle class that contains basic details about a vehicle. We inherit
    from the `vehicle` class to make a `car` class. We then inherit from the `car`
    class to make a `sports car` class. Each layer of inheritance here adds features
    that aren't present in the class we are inheriting from.
  prefs: []
  type: TYPE_NORMAL
- en: In general, this is a simple concept for us to work with, but what happens when
    we want to bring two or more seemingly unrelated things together to make our code?
    Let's examine a simple example.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is a common thing with database applications to store whether a record has
    been deleted without actually deleting the record, and the time that the last
    update occurred on the record. At first glance, it would seem that we would want
    to track this information in a person''s data entity. Rather than adding this
    information into every data entity, we might end up creating a base class that
    includes this information and then inheriting from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The first problem with this approach is that it mixes details about the status
    of a record with the actual record itself. As we continue further into OO designs
    over the next few chapters, we will keep reinforcing the idea that mixing items
    together like this is not a good idea because we are creating classes that have
    to do more than one thing, which can make them less robust. The other problem
    with this approach is that, if we wanted to add the date the record was updated,
    we are either going to have to add the updated date to `ActiveRecord`, which means
    that every class that extends `ActiveRecord` will also get the updated date, or
    we are going to have to create a new class that adds the updated date and add
    this into our hierarchy chain, which means that we could not have an updated field
    without a deleted field.
  prefs: []
  type: TYPE_NORMAL
- en: While inheritance definitely does have its place, recent years have seen the
    idea of composing objects together to make new objects gain in prominence. The
    idea behind this approach is that we build discrete elements that do not rely
    on inheritance chains. If we revisit our person implementation, we will build
    the same features using a feature called a mixin instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is define a type that will act as a suitable
    constructor for our mixin. We could name this type anything, but the convention
    that has evolved around mixins in TypeScript is to use the following type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This type definition gives us something that we can extend to create our specialized
    mixins. The strange-looking syntax effectively says that, given any particular
    type, a new instance will be created using any appropriate arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our record status implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The `RecordStatus` function extends the `Constructor` type by returning a new
    class that extends the constructor implementation. In this, we add our `Deleted`
    flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'To *merge* or mix in these two types, we simply do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'This has created something we can use to create a `Person` object with `RecordStatus`
    properties. It has not actually instantiated any objects yet. To do that, we instantiate
    the information in the same way we would with any other type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we also want to add details about when the record was last updated. We
    create another mixin, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'To add this to `ActivePerson`, we change the definition to include `Timestamp`.
    It does not matter which mixin we put first, whether it is `Timestamp` or `RecordStatus`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'As well as properties, we can also add constructors and methods to our mixins.
    We are going to change our `RecordStatus` function to log out when the record
    was deleted. To do this, we are going to convert our `Deleted` property into a
    getter method and add a new method to actually perform the deletion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'A word of warning about using mixins like this. They are a great technique,
    and they provide the ability to neatly do some really useful things, but we cannot
    pass them as a parameter unless we relax the parameter restrictions to any. That
    means we cannot use code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: If we look at mixins in the TypeScript documentation at [https://www.typescriptlang.org/docs/handbook/mixins.html](https://www.typescriptlang.org/docs/handbook/mixins.html),
    we see that the syntax looks very different. Rather than dealing with that approach,
    with all of the inherent limitations it has, we will stick with the method here,
    which I was first introduced to at [https://basarat.gitbooks.io/typescript/docs/types/mixins.html](https://basarat.gitbooks.io/typescript/docs/types/mixins.html).
  prefs: []
  type: TYPE_NORMAL
- en: Using the same code with different types and using generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we first start developing classes in TypeScript, it is very common for
    us to repeat the same code again and again, only changing the type that we are
    relying on. For instance, if we wanted to store a queue of integers, we might
    be tempted to write the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling this code is as easy as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Later on, we decide that we also need to create a queue of strings, so we add
    code to do this as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: It is easy to see that the more code we add like this, the more tedious our
    job becomes and the more error-prone. Suppose that we forgot to put the shift
    operation in one of these implementations. The shift operation allows us to remove
    the first element from the array and return it, which gives us the core behavior
    of a queue (a queue operates as **First In First Out** (or **FIFO**)). If we had
    forgotten the shift operation, we would have implemented a stack operation instead
    (**Last In First Out** (or **LIFO**)). This could lead to subtle and dangerous
    bugs in our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'With generics, TypeScript provides us with the ability to create something
    called a generic, which is a type that uses a placeholder to denote what the type
    is that is being used. It is the responsibility of the code calling that generic
    to determine what type they are accepting. We recognize generics because they
    appear after the class name inside `<>`, or after things such as method names.
    If we rewrite our queue to use a generic, we will see what this means:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break this down:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are creating a class called `Queue` that accepts any type. The `<T>`
    syntax tells TypeScript that, whenever it sees `T` inside this class, it refers
    to the type that is passed in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is our first instance of the generic type appearing. Rather than the array
    being fixed to a particular type, the compiler will use the generic type to create
    the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Again, we have replaced the specific type in our code with the generic instead.
    Note that TypeScript is happy to use this with the `undefined` keyword in the
    `Pop` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changing the way we use our code, we can now just tell our `Queue` object what
    type we want to apply to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: What is particularly helpful is that TypeScript enforces the type that we assign
    wherever it is referenced, so if we attempted to add a string to our `queue` variable,
    TypeScript would fail to compile this.
  prefs: []
  type: TYPE_NORMAL
- en: While TypeScript does its best to protect us, we have to remember that it converts
    into JavaScript. This means that it cannot protect our code from being abused,
    so, while TypeScript enforces the type we assign, if we were to write external
    JavaScript that also called our generic types, there is nothing there to prevent
    adding an unsupported value. The generic is enforced at compile time only so,
    if we have code that is going to be called from outside our control, we should
    take steps to guard against incompatible types in our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We aren''t limited to just having one type in the generic list. Generics allow
    us to specify any number of types in the definition as long as they have unique
    names, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Keen-eyed readers will note that we have already encountered generics. When
    we created a mixin, we were using generics in our `Constructor` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens if we want to call a particular method from our generic? As TypeScript
    expects to know what the underlying implementation of the type is, it is strict
    about what we can do. This means that the following code is not acceptable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'As TypeScript cannot guess that we want to use the `IStream` interface here,
    it is going to complain if we try to compile this. Fortunately, we can use a generic
    constraint to tell TypeScript that we have a particular type that we want to use
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The `<T extends IStream>` part tells TypeScript that we are going to use *any*
    class that is based on our `IStream` interface.
  prefs: []
  type: TYPE_NORMAL
- en: While we can constrain generics to types, we are generally going to want to
    constrain our generics to interfaces. This gives us a lot of flexibility in the
    classes that we use in the constraint and does not impose limitations that we
    can only use classes that inherit from a particular base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this in action, we are going to create two classes that implement `IStream`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'These can now be used as type constraints in our generic `Data` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'We have just told `webStream` and `diskStream` that they are going to have
    access to our classes. To use them, we would still have to pass an instance, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'While we declared our generic and its constraints at the class level, we don''t
    have to do that. We can declare finer-grained generics, down to the method level,
    if we need to. In this case though, it makes sense to make it a class-level generic
    if we want to refer to that generic type in multiple places in our code. If the
    only place we wanted to apply a particular generic was at one or two methods,
    we could change our class signature to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Mapping values using maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A situation that often comes up is needing to store a number of items with
    an easily looked up key. For instance, suppose we had a music collection broken
    down into a number of genres:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Against each one of these genres, we are going to store the details of a number
    of artists or composers. One approach we could take would be to create a class
    that represents each genre. While we could do that, it would be a waste of our
    coding time. The way we are going to solve this problem is by using something
    called a **map**. A map is a generic class that takes in two types: the type of
    key to use for the map and the type of objects to store in it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The key is a unique value that is used to allow us to store values or to quickly
    look things up—this makes maps a good choice for rapidly looking values up. We
    can have any type as a key and the value can be absolutely anything. For our music
    collection, we are going to create a class that uses a map with the genre as the
    key and a string array to represent the composer or artists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to populate a map, we call the `set` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Retrieving the values from the map is as simple as calling `Get` with the relevant
    key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: We have to add the `undefined` keyword to the return value here because there
    is a possibility that the map entry does not exist. If we forgot to take the possibility
    of undefined into account, TypeScript helpfully warns us of this. Yet again, TypeScript
    works hard to provide that robust safety net for our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now populate our collection, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to add a single artist, our code becomes slightly more complex. Using
    set, we either add a new entry into our map or we replace the previous entry with
    our new one. As this is the case, we really need to check to see whether we have
    already added that particular key. To do this, we call the `has` method. If we
    have not added the genre, we are going to call set with an empty array. Finally,
    we are going to get the array out of our map using get so that we can push our
    values in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'One more thing we are going to do to our code is change the `Add` method. Right
    now, that implementation overwrites previous calls to `Add` for a particular genre,
    which means that calling `AddArtist` and then `Add` would end up overwriting the
    artist we added individually with the ones from the `Add` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to fix the `Add` method, it is a simple change to iterate over our
    artists and call the `AddArtist` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Now, when we finish populating the `HeavyMetal` genre, our artists consist of
    `Iron Maiden`, `Tygers of Pan Tang`, `Saxon`, and `Doro`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating asynchronous code with promises and async/await
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We often need to write code that behaves in an asynchronous fashion. By this,
    we mean that we need to start a task off and leave it running in the background
    while we do something else. An example of this could be when we have made a call
    out to a web service, which may take a while to return. For a long time, the standard
    way in JavaScript was to use a callback. A big problem with this approach is that
    the more callbacks we need, the more complex and potentially error-prone our code
    becomes. This is where promises come in.
  prefs: []
  type: TYPE_NORMAL
- en: A promise tells us that something will happen asynchronously; after the asynchronous
    operation finishes, we have the option to continue processing and work with the
    result of the promise, or to catch any exceptions that have been thrown by the
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a sample that demonstrates this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: When we write a promise, we optionally take in two parameters—a `resolve` function
    and a `reject` function that can be called to trigger the error handling. Promises
    supply two functions for us to cope with these values, so `then()` will be triggered
    by successfully completing the operation and a separate `catch` function that
    copes with the `reject` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to run this code to see its effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this code, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Between the `Processing continues until the web service returns` and `Finished
    web service` lines, there is a four-second delay that we would expect because
    the application is waiting for the promise to return before it writes out the
    text in the `then()` function. What this is demonstrating to us is that the code
    is behaving asynchronously here because it is not waiting for the web service
    call to come back when it executed the processing console log.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might be tempted to think that this code is a bit too verbose, and that
    scattering `Promise<void>` is not the most intuitive way for others to understand
    that our code is asynchronous. TypeScript provides a syntactic equivalent that
    makes it much more apparent where our code is asynchronous. With the use of the
    `async` and `await` keywords, we easily turn our previous sample into something
    much more elegant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: The `async` keyword tells us that our function is returning `Promise`. It also
    tells the compiler that we want to process the function differently. Where we
    find `await` inside an `async` function, the application will pause that function
    at that point until the operation that is being awaited returns. At that point,
    processing continues, mimicking the behavior we saw inside the `then()` function
    from `Promise`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to catch errors in `async`/`await`, we really should wrap the code
    inside the function in a try...catch block. Where the error was explicitly caught
    by the `catch()` function, `async`/`await` does not have an equivalent way of
    handling errors, so it is up to us to deal with problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Whichever approach you choose to take is going to be a personal choice. The
    use of `async`/`await` just means it wraps the `Promise` approach so the runtime
    behavior of the different techniques is exactly the same. What I do recommend
    though is, once you decide on an approach in an application, be consistent. Don't
    mix styles as that will make it much harder for anyone reviewing your application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating UIs with Bootstrap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the remaining chapters, we are going to be doing a lot of work in the browser.
    Creating an attractive UI can be a difficult thing to do, especially in an era
    when we may also be targeting mobile devices in different layout modes. In order
    to make things easier for ourselves, we are going to rely quite heavily on Bootstrap.
    Bootstrap was designed to be a mobile device first UI framework that smoothly
    scales up to PC browsers. In this section, we are going to lay out the base template
    that contains the standard Bootstrap elements, and then have a look at how to
    lay out a simple page using features such as the Bootstrap grid system.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to start with the starter template from Bootstrap ([https://getbootstrap.com/docs/4.1/getting-started/introduction/#starter-template](https://getbootstrap.com/docs/4.1/getting-started/introduction/#starter-template)).
    With this particular template, we avoid the need to download and install the various
    CSS stylesheets and JavaScript files; instead, we rely on well-known **Content
    Delivery Networks** (**CDNs**) to source these files for us.
  prefs: []
  type: TYPE_NORMAL
- en: Where possible, I would recommend using CDNs to source external JavaScript and
    CSS files. This provides many benefits including not needing to maintain these
    files ourselves and getting the benefit of browser caching when the browser has
    encountered this CDN file elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'The starter template looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The starting point for laying out content is the container. This goes in the
    preceding content section. The following code shows the `div` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: The `container` class gives us that familiar Twitter look where it has a fixed
    size for each screen size. If we need to fill the full window, we can change this
    to `container-fluid`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the container, Bootstrap attempts to lay items out in a grid pattern.
    Bootstrap operates a system where each row of the screen can be represented as
    up to 12 discrete columns. By default, these columns are evenly spread out across
    the page so we can make complicated layouts just by choosing the appropriate number
    of columns to occupy for each part of our UI. Fortunately for us, Bootstrap provides
    an extensive set of predefined styles that help us to make layouts for different
    types of devices, whether they are PCs, mobile phones, or tablets. These styles
    all follow the same naming convention of `.col-<<size-identifier>>-<<number-of-columns>>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Extra small devices** | **Small devices** | **Medium devices**
    | **Large devices** |'
  prefs: []
  type: TYPE_TB
- en: '| **Dimensions** | Phones < 768px | Tablets >= 768px | Desktops >= 992px |
    Desktops >= 1200px |'
  prefs: []
  type: TYPE_TB
- en: '| **Prefix** | .col-xs- | .col-sm- | .col-md- | .col-lg- |'
  prefs: []
  type: TYPE_TB
- en: 'The way that the number of columns works is that each row should ideally add
    up to 12 columns. So, if we wanted to have a row made of content covering three
    columns, then six columns, and finally another three columns, we would define
    our rows to look like this inside our container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'That styling defines how this would appear on small devices. It is possible
    to override the styles for larger devices. For instance, if we wanted large devices
    to use columns of five, two, and five, we could apply this styling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: This is the beauty of a responsive layout system. It allows us to generate content
    that is appropriate for our devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how to add some content to our page. We are going to
    add `jumbotron` to our first column, some text into our second column, and a button
    in our third column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Again, we are using CSS styling to control what our display looks like. By giving
    a `div` section a styling of `jumbotron`, Bootstrap immediately applies that styling
    for us. We controlled exactly what our button looks like by choosing to make it
    the primary button (`btn-primary`) and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '`jumbotron` normally stretches across the width of all of the columns. We put
    it inside a three-column `div` just so we can see that the width and styling is
    controlled by the grid layout system and that `jumbotron` does not have some special
    properties that force it to lay out across the page.'
  prefs: []
  type: TYPE_NORMAL
- en: When I want to rapidly prototype a layout, I always follow a two-stage process.
    The first step is to draw on a piece of paper what I want my UI to look like.
    I could do this using a wireframe tool but I like the ability to quickly draw
    things out. Once I have got a general idea of what I want my layout to look like,
    I use a tool such as Layoutit! ([https://www.layoutit.com/](https://www.layoutit.com/))
    to put the ideas on to the screen; this also gives me the option to export the
    layout so that I can further refine it by hand.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we had a look at features of TypeScript that help us to build
    future-proof TypeScript code. We looked at how to set the appropriate ES levels
    to simulate or use modern ECMAScript features. We looked at how to use union and
    intersection types as well as how to create type aliases. We then looked into
    object spread and REST properties before we covered AOP with decorators. We also
    covered how to create and use map types, as well as using generics and promises.
  prefs: []
  type: TYPE_NORMAL
- en: As preparation for the UIs we will be producing in the rest of this book, we
    briefly looked at using Bootstrap to lay out UIs and covered the basics of the
    Bootstrap grid layout system.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to build a simple markdown editor using a
    simple Bootstrap web page hooked up to our TypeScript. We will see how techniques
    such as design patterns and single responsibility classes help us to create robust
    professional code.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have written an application that allows users to convert from Fahrenheit
    into Celsius and from Celsius into Fahrenheit. The calculations are performed
    in the following classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: We want to write a method that accepts a temperature and an instance of either
    of these types, which will then perform the relevant calculation. What technique
    would we use to write this method?
  prefs: []
  type: TYPE_NORMAL
- en: 'We have written the following class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: We want to use this in another class where we will add a number of commands.
    `Name` of the command is going to be the key that we can use to look up `Command`
    later on in our code. What would we use to provide this key-value functionality
    and how would we add records to it?
  prefs: []
  type: TYPE_NORMAL
- en: How would we automatically log that we were adding entries to the command we
    added in *Question 2* without adding any code inside our `Add` methods?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have created a Bootstrap web page where we want to display a row with six
    medium columns of equal size. How would we do this?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
