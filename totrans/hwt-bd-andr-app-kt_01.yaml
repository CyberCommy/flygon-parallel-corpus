- en: 1\. Creating Your First App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is an introduction to Android, where you will set up your environment
    and focus on the fundamentals of Android development. By the end of this chapter,
    you will have gained the knowledge required to create an Android app from scratch
    and install it on a virtual or physical Android device. You will be able to analyze
    and understand the importance of the `AndroidManifest.xml` file, and use the Gradle
    build tool to configure your app and implement UI elements from Material Design.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android is the most widely used mobile phone operating system in the world,
    with over 70% of the global market share (see [https://gs.statcounter.com/os-market-share/mobile/worldwide](https://gs.statcounter.com/os-market-share/mobile/worldwide)).
    This presents great opportunities to contribute and make an impact by learning
    Android and building apps that have a global reach. For a developer who is new
    to Android, there are many issues you must contend with in order to get started
    learning and becoming productive. This book will address these issues. After learning
    the tooling and development environment, you will explore fundamental practices
    to build Android apps. We will cover a wide range of real-world development challenges
    faced by developers and explore various techniques to overcome them.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to create a basic Android project and add
    features to it. You will be introduced to the comprehensive development environment
    of Android Studio and learn about the core areas of the software to enable you
    to work productively. Android Studio provides all the tooling for application
    development, but not the knowledge. This first chapter will guide you through
    using the software effectively to build an app and configure the most common areas
    of an Android project.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started creating an Android project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Android Project with Android Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to be productive in terms of building Android apps, it is essential
    to become confident with how to use **Android Studio**. This is the official **Integrated
    Development Environment** (**IDE**) for Android development, built on JetBrains'
    **IntelliJ IDEA IDE** and developed by the Android Studio team at Google. You
    will be using it throughout this course to create apps and progressively add more
    advanced features.
  prefs: []
  type: TYPE_NORMAL
- en: The development of Android Studio has followed the development of the IntelliJ
    IDEA IDE. The fundamental features of an IDE are of course present, enabling you
    to optimize your code with suggestions, shortcuts, and standard refactoring. The
    programming language you will be using throughout this course to create Android
    apps is Kotlin. Since Google I/O 2017 (the annual Google developer conference),
    this has been Google's preferred language for Android app development. What really
    sets Android Studio apart from other Android development environments is that
    **Kotlin** was created by JetBrains, the company that created IntelliJ IDEA, the
    software Android Studio is built on. You can, therefore, benefit from established
    and evolving first-class support for Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin was created to address some of the shortcomings of Java in terms of verbosity,
    handling null types, and adding more functional programming techniques, amongst
    many other issues. As Kotlin has been the preferred language for Android development
    since 2017, taking over from Java, you will be using it in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Getting to grips and familiarizing yourself with Android Studio will enable
    you to feel confident working on and building Android apps. So, let's get started
    creating your first project.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The installation and setup of Android Studio are covered in the *Preface*. Please
    ensure you have completed those steps before you continue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.01: Creating an Android Studio Project for Your App'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the starting point for creating a project structure your app will be
    built upon. The template-driven approach will enable you to create a basic project
    in a short timeframe whilst setting up the building blocks you can use to develop
    your app. To complete this exercise, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The version of Android Studio you will be using is *v4.1.1* (or above).
  prefs: []
  type: TYPE_NORMAL
- en: Upon opening Android Studio, you will see a window asking whether you want to
    create a new project or open an existing one. Select `Create New Project`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The start up window will appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1: Android Studio version 4.1.1'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_01_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.1: Android Studio version 4.1.1'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you''ll enter a simple wizard-driven flow, which greatly simplifies the
    creation of your first Android project. The next screen you will see has a large
    number of options for the initial setup you''d like your app to have:![Figure
    1.2: Starting a project template for your app'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15216_01_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.2: Starting a project template for your app'
  prefs: []
  type: TYPE_NORMAL
- en: Welcome to your first introduction to the `Activity`. In Android, an `Activity`
    is a page or screen. The options you can choose from on the preceding screen all
    create this initial screen differently. The descriptions describe how the first
    screen of the app will look. These are templates to build your app with. Select
    `Empty Activity` from the template and click on next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The project configuration screen is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3: Project configuration'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_01_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.3: Project configuration'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding screen configures your app. Let''s go through all the options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Name`: Similar to the name of your Android project, this name will appear
    as the default name of your app when it''s installed on a phone and visible on
    Google Play. You can replace the `Name` field with your own or set it now to the
    app you are going to create.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Package name`: This uses the standard reverse domain name pattern for creating
    a name. It will be used as an address identifier for source code and assets in
    your app. It is best to make this name as clear and descriptive and as closely
    aligned with the purpose of your app as possible. Therefore, it''s probably best
    to change this to use one or more sub-domains (such as `com.sample.shop.myshop`).
    As shown in *Figure 1.3*, the `Name` of the app (in lowercase with spaces removed)
    is appended to the domain.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Save location`: This is the local folder on your machine where the app will
    be initially stored. This can be changed in the future, so you can probably keep
    the default or edit it to something different (such as `Users/MyUser/android/projects`).
    The default location will vary with the operating system you are using.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Language – Kotlin`: This is Google''s preferred language for Android app development.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Minimum SDK`: Depending on which version of Android Studio you download, the
    default might be the same as displayed in *Figure 1.3* or a different version.
    Keep this the same. Most of Android''s new features are made backward compatible,
    so your app will run fine on the vast majority of older devices. However, if you
    do want to target newer devices, you should consider raising the minimum API level.
    There is a link, `Help Me Choose`, to a dialog that explains the feature set that
    you have access to with a view to development on different versions of Android
    and the current percentage of devices worldwide running each Android version.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(Checkbox) use legacy android.support libraries`. Leave this unchecked. You
    will be using AndroidX libraries, which are the replacement for the support libraries
    that were designed to make features on newer versions of Android backward compatible
    with older versions, but it provides much more than this. It also contains newer
    Android components called Jetpack, which, as the name suggests, "boost" your Android
    development and provide a host of rich features you will want to use in your app,
    thereby simplifying common operations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have filled in all these details, select `Finish`. Your project will
    be built and you will then be presented with the following screen or similar:
    You can immediately see the activity that has been created (`MainActivity`) in
    one tab and the layout used for the screen in the other tab (`activity_main.xml`).
    The application structure folders are in the left panel.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4: Android Studio default project'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_01_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.4: Android Studio default project'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you have gone through the steps to create your first Android
    app using Android Studio. This has been a template-driven approach that has shown
    you the core options you need to configure for your app.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will set up a virtual device and see your app run for
    the first time.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up a Virtual Device and Running Your App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a part of installing Android Studio, you downloaded and installed the latest
    Android SDK components. These included a base emulator, which you will configure
    to create a virtual device to run Android apps on. The benefit is that you can
    make changes and quickly see them on your desktop whilst developing your app.
    Although virtual devices do not have all the features of a real device, the feedback
    cycle is often quicker than going through the steps of connecting a real device.
  prefs: []
  type: TYPE_NORMAL
- en: Also, although you should ensure your app runs as expected on different devices,
    you can standardize it by targeting a specific device by downloading an emulator
    skin even if you don't have the real device if this is a requirement of your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The screen you will have seen (or something similar) when installing Android
    Studio is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5: SDK components'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_01_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.5: SDK components'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the SDK components that are installed and how the virtual
    device fits in:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Android Emulator**: This is the base emulator, which we will configure to
    create virtual devices of different Android makes and models.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Android SDK Build-Tools**: Android Studio uses the build tools to build your
    app. This process involves compiling, linking, and packaging your app to prepare
    it for installation on a device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Jelly Bean` was selected above in the Create Project wizard for configuring
    the minimum API level of your project. From Android 10, the versioning will no
    longer have a code name that is different from the version name. (The versions
    of the Build-Tools and Platform will change as new versions are released)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Android SDK Platform-Tools**: These are tools you can use, ordinarily, from
    the command line, to interact with and debug your app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Android SDK Tools**: In contrast to the platform tools, these are tools that
    you use predominantly from within Android Studio in order to accomplish certain
    tasks, such as the virtual device for running apps and the SDK manager to download
    and install platforms and other components of the SDK.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intel x86 Emulator Accelerator (HAXM installer)**: If your OS provides it,
    this is a feature at the hardware level of your computer you will be prompted
    to enable, which allows your emulator to run more quickly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SDK Patch Applier v4**: As newer versions of Android Studio become available,
    this enables patches to be applied to update the version you are running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this knowledge, let's start with the next exercise of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.02: Setting Up a Virtual Device and Running Your App on It'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We set up an Android Studio project to create our app in *Exercise 1.01*, *Creating
    an Android Studio Project for Your App*, and we are now going to run it on a virtual
    device. You can also run your app on a real device, but in this exercise, you
    will use a virtual device. This process is a continuous cycle whilst working on
    your app. Once you have implemented a feature, you can verify its look and behavior
    as you require. For this exercise, you will create a single virtual device, but
    you should ensure you run your app on multiple devices to verify that its look
    and behavior are consistent. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the top toolbar in Android Studio, you will see two drop-down boxes next
    to each other pre-selected with `app` and `No devices`:![Figure 1.6: Android Studio
    toolbar'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15216_01_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.6: Android Studio toolbar'
  prefs: []
  type: TYPE_NORMAL
- en: The `app` is the configuration of our app that we are going to run. As we haven't
    set up a virtual device yet, it says `No devices`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to create a virtual device, click on the `AVD Manager` (`Tools` menu:![Figure
    1.7: AVD Manager in the Tools menu'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15216_01_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.7: AVD Manager in the Tools menu'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the button or toolbar option to open the `Your Virtual Devices` window:![Figure
    1.8: The Your Virtual Devices window'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15216_01_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.8: The Your Virtual Devices window'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the `Create Virtual Device...` button as shown in *Figure 1.8*:![Figure
    1.9: Device definition creation'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15216_01_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.9: Device definition creation'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to choose the `Pixel 3` device. The real (non-virtual device)
    Pixel range of devices are developed by Google and have access to the most up-to-date
    versions of the Android platform. Once selected, click the `Next` button:![Figure
    1.10: System Image'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15216_01_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.10: System Image'
  prefs: []
  type: TYPE_NORMAL
- en: The `R` name displayed here is the initial code/release name for Android 11\.
    Select the latest system image available. The `Target` column might also show
    `(Google Play)` or `(Google APIs)` in the name. Google APIs mean that the system
    image comes pre-installed with Google Play Services. This is a rich feature set
    of Google APIs and Google apps that your app can use and interact with. On first
    running the app, you will see apps such as Maps and Chrome instead of a plain
    emulator image. A Google Play system image means that, in addition to the Google
    APIs, the Google Play app will also be installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should develop your app with the latest version of the Android platform
    to benefit from the latest features. On first creating a virtual device, you will
    have to download the system image. If a `Download` link is displayed next to `Release
    Name`, click on it and wait for the download to complete. Select the `Next` button
    to see the virtual device you have set up:![Figure 1.11: Virtual device configuration'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15216_01_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.11: Virtual device configuration'
  prefs: []
  type: TYPE_NORMAL
- en: You will then see a final configuration screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click `Finish` and your virtual device will be created. You will then see your
    device highlighted:![Figure 1.12: Virtual devices listed'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15216_01_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.12: Virtual devices listed'
  prefs: []
  type: TYPE_NORMAL
- en: 'Press the right arrow button under the `Actions` column to run up the virtual device:![Figure
    1.13: Virtual device launched'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15216_01_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.13: Virtual device launched'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you've created the virtual device and it's running, you can go back
    into Android Studio to run your app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The virtual device you have set up and started will be selected. Press the
    green triangle/play button to launch your app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.14: App launch configuration'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_01_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.14: App launch configuration'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.15: App running on a virtual device'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_01_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.15: App running on a virtual device'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you have gone through the steps to create a virtual device
    and run the app you created on it. The Android Virtual Device Manager, which you
    have used to do this, enables you to create the device (or range of devices) you
    would like to target your app for. Running your app on the virtual device allows
    a quick feedback cycle to verify how a new feature development behaves and that
    it displays the way you expect it to.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will explore the `AndroidManifest.xml` file of your project, which
    contains the information and configuration of your app.
  prefs: []
  type: TYPE_NORMAL
- en: The Android Manifest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The app you have just created, although simple, encompasses the core building
    blocks that you will use in all of the projects you create. The app is driven
    from the `AndroidManifest.xml` file, a manifest file that details the contents
    of your app. It has all the components, such as activities, content providers,
    services, receivers, and the list of permissions that the app requires to implement
    its features. For example, the camera permission is required to capture a photo
    in an app. You can find it in the Project view under `MyApplication` | `app` |
    `src` | `main`. Alternatively, if you are looking at the Android view, it is located
    at `app` | `manifests` | `AndroidManifest.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A typical manifest file in general terms is a top-level file that describes
    the enclosed files or other data and associated metadata that forms a group or
    unit. The Android Manifest takes this concept and applies it to your Android app
    as an XML file. The distinguishing feature of the app specified is the package
    defined at the manifest XML root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Every Android app has an application class that allows you to configure the
    app. By default, in version 4.1.1 of Android Studio, the following XML attributes
    and values are created in the application element:'
  prefs: []
  type: TYPE_NORMAL
- en: '`android:allowBackup="true"`: This backs up a user''s data from apps that target
    and run on Android 6.0 (API level 23) or later upon reinstall or switching devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:icon="@mipmap/ic_launcher"`: The resources Android uses are referenced
    in XML preceded by the `@` symbol and mipmap refers to the folder where launcher
    icons are stored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:label="@string/app_name"`: This is the name you specified when you
    created the app. It''s also currently displayed in the toolbar of the app and
    will be shown as the name of the app on the user''s device in the launcher. It
    is referenced by the `@` symbol followed by a string reference to the name you
    specified when you created the app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:roundIcon="@mipmap/ic_launcher_round"`: Depending on the device the
    user has, the launcher icons may be square or round. `roundIcon` is used when
    the user''s device displays round icons in the launcher.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:supportsRtl="true``"`: This specifies whether the app and its layout
    files support right-to-left language layouts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:theme="@style/Theme.MyApplication"`: This specifies the theme of your
    app in terms of text styles, colors, and other styles within your app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After the `<application>` element opens, you define the components your app
    consists of. As we have just created our app, it only contains the first screen
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The next child XML node specified is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Android uses intents as a mechanism for interacting with apps and system components.
    Intents get sent and the intent filter registers your app's capability to react
    to these intents. `<android.intent.action.MAIN>` is the main entry point into
    your app, which, as it appears in the enclosing XML of `.MainActivity`, specifies
    that this screen will be started when the app is launched. `android.intent.category.LAUNCHER`
    states that your app will appear in the launcher of your user's device.
  prefs: []
  type: TYPE_NORMAL
- en: As you have created your app from a template, it has a basic manifest that will
    launch the app and display an initial screen at startup through an `Activity`
    component. Depending on which other features you want to add to your app, you
    may need to add permissions in the Android Manifest file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Permissions are grouped into three different categories: normal, signature,
    and dangerous.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Normal** permissions include accessing the network state, Wi-Fi, the internet,
    and Bluetooth. These are usually permitted without asking the user''s consent
    at runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Signature** permissions are those shared by the same group of apps that have
    to be signed with the same certificate. This means these apps can share data freely,
    but other apps can''t get access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dangerous** permissions are centered around the user and their privacy, for
    example, sending SMS, access to accounts and location, and reading and writing
    to the filesystem and contacts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These permissions have to be listed in the manifest, and, in the case of dangerous
    permissions from Android Marshmallow API 23 (Android 6 Marshmallow) onward, you
    must also ask the user to grant the permissions at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, we will configure the Android Manifest file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.03: Configuring the Android Manifest Internet Permission'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The key permission that most apps require is access to the internet. This is
    not added by default. In this exercise, we will fix that and, in the process,
    load a `WebView`, which enables the app to show web pages. This use case is a
    very common one in Android app development as most commercial apps will display
    a privacy policy, terms and conditions, etc. As these documents are likely to
    be common to all platforms, the usual way to display them is to load a web page.
    Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Android Studio project as you did in *Exercise 1.01*, *Creating
    an Android Studio Project for Your App*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch tabs to the `MainActivity` class. From the main project window, it's
    located in `MyApplication` | `app` | `src` | `main` | `java` | `com` | `example`
    | `myapplication`. This follows the package structure you defined when creating
    the app. Alternatively, if you are looking at the Android view within the project
    window, it is located at `app` | `java` | `com` | `example` | `myapplication`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can change what the `Project` window displays by opening up the `Tool` window
    by selecting `View | Tool Windows | Project` - this will select `Project` view.
    The drop-down options on the top of the `Project` window allow you to change the
    way you view your project, with the most commonly used displays being `Project`
    and `Android`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.16 Tool Windows drop-down'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_01_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You'll examine the contents of this file in more detail in the next section
    of this chapter, but for now, you just need to be aware that the `setContentView(R.layout.Activity_main)`
    statement sets the layout of the UI you saw when you first ran the app in the
    virtual device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following code to change this to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: So, you are replacing the layout file with a `WebView`. The `val` keyword is
    a read-only property reference, which can't be changed once it has been set. JavaScript
    needs to be enabled in the WebView to execute JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'We are not setting the type, but Kotlin has type inference, so it will infer
    the type if possible. So, specifying the type explicitly with `val webView: WebView
    = WebView(this)` is not necessary. Depending on which programming languages you
    have used in the past, the order of defining the parameter name and type may or
    may not be familiar. Kotlin follows Pascal notation, that is, name followed by
    type.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, run the app up and the text will appear as shown in the screenshot here:![Figure
    1.17 No internet permission error message
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15216_01_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.17 No internet permission error message
  prefs: []
  type: TYPE_NORMAL
- en: 'This error occurs because there is no `INTERNET` permission added in your `AndroidManifest.xml`
    file. (If you get the error `net::ERR_CLEARTEXT_NOT_PERMITTED`, this is because
    the URL you are loading into the `WebView` is not HTTPS and non-HTTPS traffic
    is disabled from API level 28, Android 9.0 Pie and above.) Let''s fix that by
    adding the internet permission to the manifest. Open up the Android Manifest and
    add the following to above the `<application>` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Your manifest file should now look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Uninstall the app from the virtual device before running up the app again. You
    need to do this as app permissions can sometimes get cached. Do this by long pressing
    on the app icon and selecting the `App Info` option that appears and then pressing
    the Bin icon with `Uninstall` text below it. Alternatively, long press the app
    icon and then drag it to the Bin icon with `Uninstall` text beside it in the top-right
    corner of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the app again and see the web page appear in the `WebView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.18 App displaying the WebView'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_01_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.18 App displaying the WebView
  prefs: []
  type: TYPE_NORMAL
- en: In this example, you learned how to add a permission to the manifest. The Android
    Manifest can be thought of as a table of contents of your app. It lists all the
    components and permissions your app uses. As you have seen from starting the app
    from the launcher, it also provides the entry points into your app.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will explore the Android build system, which uses the
    Gradle build tool to get your app up and running.
  prefs: []
  type: TYPE_NORMAL
- en: Using Gradle to Build, Configure, and Manage App Dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the course of creating this project, you have principally used the Android
    platform SDK. The necessary Android libraries were downloaded when you installed
    Android Studio. These are not the only libraries, however, that are used to create
    your app. In order to configure and build your Android project or app, a build
    tool called Gradle is used. Gradle is a multi-purpose build tool that Android
    Studio uses to build your app. By default, in Android Studio, it uses Groovy,
    a dynamically typed JVM language, to configure the build process and allows easy
    dependency management so you can add libraries to your project and specify the
    versions. Android Studio can also be configured to use Kotlin to configure builds,
    but, as the default language is Groovy, you will be using this. The files that
    this build and configuration information is stored in are named `build.gradle`.
    When you first create your app, there are two `build.gradle` files, one at the
    root/top level of the project and one specific to your app in the app `module`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Project-Level build.gradle file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s now have a look at the project-level `build.gradle` file. This is where
    you add configuration options common to all sub-projects/modules, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `buildscript` block has build and configuration information to actually
    create your project, whilst the `allprojects` block specifies the configuration
    for all of the app''s modules. Groovy works on a plugin system, so you can write
    your own plugin that does a task or series of tasks and plug it into your build
    pipeline. The two plugins specified here are the Android tools plugin, which hooks
    into the `gradle` build toolkit and provides Android-specific settings and configuration
    to build your Android app, and the Kotlin `gradle` plugin, which takes care of
    compiling Kotlin code within the project. The dependencies themselves follow the
    Maven `groupId`, `artifactId`, and `versionId` separated by "`:`" colons. So as
    an example, the Android tools plugin dependency above is shown as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''com.android.tools.build:gradle:4.4.1''`'
  prefs: []
  type: TYPE_NORMAL
- en: The `groupId` is `com.android.tools.build`, the `artifactId` is `gradle`, and
    the `versionId` is `4.4.1`. In this way, the build system locates and downloads
    these dependencies by using the repositories referenced in the `repositories`
    block.
  prefs: []
  type: TYPE_NORMAL
- en: The specific versions of libraries can be specified directly (as is done with
    the Android `tools` plugin) in the dependency or added as variables. The `ext.`
    prefix on the variable means it is a Groovy extension property and can be used
    in the app `build.gradle` file as well.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The dependency versions specified in the previous code section and in the following
    sections of this and other chapters are subject to change, and are updated over
    time so are likely to be higher when you create these projects.
  prefs: []
  type: TYPE_NORMAL
- en: App-Level build.gradle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `build.gradle` app is specific to your project configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The plugins for Android and Kotlin detailed in the preceding explanation are
    applied to your project here by id in the `plugins` lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `android` block provided by the `com.android.application` plugin is where
    you configure your Android-specific configuration settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`compileSdkVersion`: This is used to define the API level the app has been
    compiled with and the app can use the features of this API and lower.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`buildToolsVersion`: The version of the build tools to build your app. (By
    default the `buildToolsVersion` line will be added to your project, but in order
    to always use the latest version of the build tools you can remove it).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`defaultConfig`: This is the base configuration of your app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`applicationId`: This is set to the package of your app and is the app identifier
    that is used on Google Play to uniquely identify your app. It can be changed to
    be different from the package name if required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minSdkVersion`: The minimum API level your app supports. This will filter
    out your app from being displayed in Google Play for devices that are lower than this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`targetSdkVersion`: The API level you are targeting. This is the API level
    your built app is intended to work with and has been tested with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`versionCode`: Specifies the version code of your app. Every time an update
    needs to be made to the app, the version code needs to be increased by 1 or more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`versionName`: A user-friendly version name that usually follows semantic versioning
    of X.Y.Z, where X is the major version, Y is the minor version, and Z is the patch
    version, for example, 1.0.3.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`testInstrumentationRunner`: The test runner to use for your UI tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`buildTypes`: Under `buildTypes`, a release is added that configures your app
    to create a `release` build. The `minifyEnabled` value, if set to `true`, will
    shrink your app size by removing any unused code, as well as obfuscate your app.
    This obfuscation step changes the name of the source code references to values
    such as `a.b.c()`. This makes your code less prone to reverse engineering and
    further reduces the size of the built app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compileOptions`: Language level of the java source code (`sourceCompatibility`)
    and byte code (`targetCompatibility`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kotlinOptions`: The `jvm` library the `kotlin gradle` plugin should use'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `dependencies` block specifies the libraries your app uses on top of the
    Android platform SDK, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `implementation` notation for adding these libraries means that their internal
    dependencies will not be exposed to your app, making compilation faster.
  prefs: []
  type: TYPE_NORMAL
- en: You will see here that the `androidx` components are added as dependencies,
    rather than in the Android platform source. This is so that they can be updated
    independently from Android versions. `androidx` is the repackaged support library
    and Jetpack components. In order to add or verify that your `gradle.properties`
    file has `androidx` enabled, you need to inspect the `gradle.properties` file
    at the root of your project and look for the `android.useAndroidX` and `android.enableJetifier`
    properties and ensure that they are set to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can open up the `gradle.properties` file now, and you will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you created the project with an Android Studio template, it set these flags
    to `true`, as well as adding the relevant `androidx` dependencies the app uses
    into the `dependencies` block of the app's `build.gradle` file. In addition to
    the preceding commented explanation, the `android.useAndroidX=true` flag states
    that the project is using the `androidx` libraries rather than the older support
    libraries and `android.enableJetifier=true` will also convert any older versions
    of the support libraries used in third-party libraries into the AndroidX format.
    `kotlin.code.style=official` will set the code style to the official kotlin one
    rather than the default Android Studio one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final Gradle file to examine is `settings.gradle`. This file shows which
    modules your app uses. On first creating a project with Android Studio, there
    will only be one module, `app`, but when you add more features, you can add new
    modules that are dedicated to containing the source of this feature rather than
    packaging it in the main `app` module. These are called feature modules, and you
    can supplement them with other types of modules such as shared modules, which
    are used by all other modules like a networking module. The `settings.gradle`
    file will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 1.04: Exploring how Material Design is used to theme an app'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will learn about Google''s new design language, **Material
    Design**, and use it to load a **Material Design** themed app. **Material Design**
    is a design language created by Google that adds enriched UI elements based on
    real-world effects such as lighting, depth, shadows, and animations. Perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Android Studio project as you did in *Exercise 1.01*, *Creating
    an Android Studio Project for Your App*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Firstly, look at the `dependencies` block and find the material design dependency
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, open the `themes.xml` file located at `app` | `src` | `main` | `res`
    | `values` | `themes.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the parent of `Theme.MyApplication` is `Theme.MaterialComponents.DayNight.DarkActionBar`
  prefs: []
  type: TYPE_NORMAL
- en: The Material Design dependency added in the `dependencies` block is being used
    here to apply the theme of the app.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the app now, you will see the default Material themed app as shown
    in *Figure 1.15*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this exercise, you've learned how `TextView` on the screen, it is not clear
    what benefits material design provides, but this will change when you start using
    Material UI design widgets more. Now that you've learned how the project is built
    and configured, in the next section, you'll explore the project structure in detail,
    learn how it has been created, and gain familiarity with the core areas of the
    development environment.
  prefs: []
  type: TYPE_NORMAL
- en: Android Application Structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have covered how the Gradle build tool works, we'll explore the
    rest of the project. The simplest way to do this is to examine the folder structure
    of the app. There is a tool window at the top left of Android Studio called `Project`,
    which allows you to browse the contents of your app. By default, it is `open`/`selected`
    when your Android project is first created. When you select it, you will see a
    view similar to the screenshot in *Figure 1.19*. (If you can't see any window
    bars on the left-hand side of the screen, then go to the top toolbar and select
    `View` | Appearance | `Tool` `Window Bars` and make sure it is ticked). There
    are many different options for how to browse your project, but `Android` will
    be pre-selected. This view neatly groups the `app` folder structure together,
    so let's take a look at it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an overview of these files with more detail about the most important
    ones. On opening it, you will see that it consists of the following folder structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.19: Overview of the files and folder structure in the app'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_01_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.19: Overview of the files and folder structure in the app'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Kotlin file (`MainActivity`), which you''ve specified as running when the
    app starts, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `import` statements include the libraries and the source of what this activity
    uses. The class header `class MainActivity : AppCompatActivity()` creates a class
    that extends `AppCompatActivity`. In Kotlin, the `:` colon character is used for
    both deriving from a class (also known as inheritance) and implementing an interface.'
  prefs: []
  type: TYPE_NORMAL
- en: '`MainActivity` derives from `androidx.appcompat.app.AppCompatActivity`, which
    is the backward-compatible activity designed to make your app work on older devices.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Android activities have many callback functions that you can override at different
    points of the activity''s life. This is known as the `onCreate` function as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `override` keyword in Kotlin specifies that you are providing a specific
    implementation for a function that is defined in the parent class. The `fun` keyword
    (as you may have guessed) stands for *function*. The `savedInstanceState: Bundle?`
    parameter is Android''s mechanism for restoring previously saved state. For this
    simple activity, you haven''t stored any state, so this value will be `null`.
    The question mark, `?`, that follows the type declares that this type can be `null`.
    The `super.onCreate(savedInstanceState)` line calls through to the overridden
    method of the base class, and finally, `setContentView(R.layout.Activity_main)`
    loads the layout we want to display in the activity; otherwise, it would be displayed
    as a blank screen as no layout has been defined.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at some other files (*Figure 1.19*) present in the folder
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ExampleInstrumentedTest`: This is an example UI test. You can check and verify
    the flow and structure of your app by running tests on the UI when the app is
    running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExampleUnitTest`: This is an example unit test. An essential part of creating
    an Android app is writing unit tests in order to verify that the source code works
    as expected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ic_launcher_background.xml`/`ic_launcher_foreground.xml`: These two files
    together make up the launcher icon of your app in vector format, which will be
    used by the launcher icon file, `ic_launcher.xml`, in Android API 26 (Oreo) and
    above.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`activity_main.xml`: This is the layout file that was created by Android Studio
    when we created the project. It is used by `MainActivity` to draw the initial
    screen content, which appears when the app runs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to support internationalization of your app and right-to-left (`rtl`)
    layouts, you should remove these attributes if they are present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace them with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this way, start and end are determined by the app language, whereas left
    and right mean start and end only in left-to-right languages.
  prefs: []
  type: TYPE_NORMAL
- en: Most screen displays in Android are created using XML layouts. The document
    starts with an XML header followed by a top-level `ViewGroup` (which here is `ConstraintLayout`)
    and then one or more nested `Views` and `ViewGroups`.
  prefs: []
  type: TYPE_NORMAL
- en: The `ConstraintLayout` `ViewGroup` allows very precise positioning of views
    on a screen constraining views with parent and sibling views, guidelines, and
    barriers.
  prefs: []
  type: TYPE_NORMAL
- en: '`TextView`, which is currently the only child view of `ConstraintLayout`, displays
    text on the screen through the `android:text` attribute. The positioning of the
    view horizontally is done by constraining the view to both the start and end of
    the parent, which, as both constraints are applied, centers the view horizontally.
    (start and end in left-to-right languages (`ltr`) are left and right, but right-to-left
    in `non ltr` languages). The view is positioned vertically in the center by constraining
    the view to both the top and the bottom of its parent. The result of applying
    all four constraints centers `TextView` both horizontally and vertically within
    `ConstraintLayout`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three XML namespaces in the `ConstraintLayout` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '`xmlns:android` refers to the Android-specific namespace and it is used for
    all attributes and values within the main Android SDK.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `xmlns:app` namespace is for anything not in the Android SDK. So, in this
    case, `ConstraintLayout` is not part of the main Android SDK but is added as a
    library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xmnls:tools` refers to a namespace used for adding metadata to the XML, which
    is used to indicate here where the layout is used (`tools:context=".MainActivity"`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The two most important attributes of an Android XML layout file are `android:layout_width`
    and `android:layout_height`.
  prefs: []
  type: TYPE_NORMAL
- en: These can be set to absolute values, usually of density-independent pixels (known
    as `dip` or `dp`) that scale pixel sizes to be roughly equivalent on different
    density devices. More commonly, however, these attributes have the values of `wrap_content`
    or `match_parent` set for them. `wrap_content` will be as big as required to enclose
    its contents only. `match_parent` will be sized according to its parent.
  prefs: []
  type: TYPE_NORMAL
- en: There are other `ViewGroups` you can use to create layouts. `LinearLayout` lays
    out views vertically or horizontally, `FrameLayout` is usually used to display
    a single child view, and `RelativeLayout` is a simpler version of `ConstraintLayout`,
    which lays out views positioned relative to the parent and sibling views.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ic_launcher.png` files are `.png` launcher icons that have an icon for
    every different density of devices. As the minimum version of Android we are using
    is API 16: Android 4.1 (Jelly Bean), these `.png` images are included as support
    for the launcher vector format was not introduced until Android API 26 (Oreo).'
  prefs: []
  type: TYPE_NORMAL
- en: The `ic_launcher.xml` file uses the vector files (`ic_launcher_background.xml`/`ic_launcher_foreground.xml`)
    to scale to different density devices in Android API 26 (Oreo) and above.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In order to target different density devices on the Android platform, besides
    each one of the `ic_launcher.png` icons, you will see in brackets the density
    it targets. As devices vary widely in their pixel densities, Google created density
    buckets so that the correct image would be selected to be displayed depending
    on how many dots per inch the device has.
  prefs: []
  type: TYPE_NORMAL
- en: 'The different density qualifiers and their details are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`nodpi`: Density-independent resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ldpi`: Low-density screens of 120 dpi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mdpi`: Medium-density screens of 160 dpi (the baseline)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hdpi`: High-density screens of 240 dpi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xhdpi`: Extra-high-density screens of 320 dpi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xxhdpi`: Extra-extra-high-density screens of 480 dpi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xxxhdpi`: Extra-extra-extra-high-density screens of 640 dpi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tvdpi`: Resources for televisions (approx 213 dpi)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The baseline density bucket was created at `160` dots per inch for medium-density
    devices and is called `160` dots/pixels, and the largest display bucket is `xxxhdpi`,
    which has `640` dots per inch. Android determines the appropriate image to display
    based on the individual device. So, the Pixel 3 emulator has a density of approximately
    `443dpi`, so it uses resources from the extra-extra-high-density bucket (xxhdpi),
    which is the closest match. Android has a preference for scaling down resources
    to best match density buckets, so a device with `400dpi`, which is halfway between
    the `xhdpi` and `xxhdpi` buckets, is likely to display the `480dpi` asset from
    the `xxhdpi` bucket.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create alternative bitmap drawables for different densities, you should
    follow the `3:4:6:8:12:16` scaling ratio between the six primary densities. For
    example, if you have a bitmap drawable that''s `48x48` pixels for medium-density
    screens, all the different sizes should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '`36x36` (`0.75x`) for low density (`ldpi`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`48x48` (`1.0x` baseline) for medium density (`mdpi`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`72x72` (`1.5x`) for high density (`hdpi`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`96x96` (`2.0x`) for extra-high density (`xhdpi`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`144x144` (`3.0x`) for extra-extra-high density (`xxhdpi`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`192x192` (`4.0x`) for extra-extra-extra-high density (`xxxhdpi`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a comparison of these physical launcher icons per density bucket, refer
    to the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.20: Comparison of principal density bucket launcher image sizes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_01_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.20: Comparison of principal density bucket launcher image sizes'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Launcher icons are made slightly larger than normal images within your app as
    they will be used by the device's launcher. As some launchers can scale up the
    image, this is to ensure there is no pixelation and blurring of the image.
  prefs: []
  type: TYPE_NORMAL
- en: Now you are going to look at some of the resources the app uses. These are referenced
    in XML files and keep the display and formatting of your app consistent.
  prefs: []
  type: TYPE_NORMAL
- en: In the `colors.xml` file, you define the colors you would like to use in your
    app in hexadecimal format.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The format is based on the RGB color space, so the first two characters are
    for red, the next two for green, and the last two for blue, where `#00` means
    none of the color is added to make up the composite color, and `#FF` means all
    of the color is added.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would like some transparency in the color, then precede it with two
    hexadecimal characters, from `#00` for completely transparent to `#FF` for completely
    opaque. So, to create blue and 50% transparent blue characters, here''s the format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `strings.xml` file displays all the text displayed in the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You can use hardcoded strings in your app, but this leads to duplication and
    also means you cannot customize the text if you want to make the app multilingual.
    By adding strings as resources, you can also update the string in one place if
    it is used in different places in the app.
  prefs: []
  type: TYPE_NORMAL
- en: Common styles you would like to use throughout your app are added to the `themes.xml`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: It is possible to apply style information directly to views by setting `android:textStyle="bold"`
    as an attribute on `TextView`. However, you would have to repeat this in multiple
    places for every `TextView` you wanted to display in bold. When you start to have
    multiple style attributes added to individual views, it adds a lot of duplication
    and can lead to errors when you want to make a change to all similar views and
    miss changing a style attribute on one view. If you define a style, you only have
    to change the style and it will update all the views that have that style applied
    to them. A top-level theme was applied to the application tag in the `AndroidManifest.xml`
    file when you created the project and is referred to as a theme that styles all
    views contained within the app. The colors you have defined in the `colors.xml`
    file are used here. In effect, if you change one of the colors defined in the
    `colors.xml` file, it will now propagate to style the app as well.
  prefs: []
  type: TYPE_NORMAL
- en: You've now explored the core areas of the app. You have added `TextView` views
    to display labels, headings, and blocks of text. In the next exercise, you will
    be introduced to UI elements that will allow the user to interact with your app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.05: Adding Interactive UI Elements to Display a Bespoke Greeting
    to the User'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The goal of this exercise is to add the capability of users to add and edit
    text and then submit this information to display a bespoke greeting with the entered
    data. You will need to add editable text views to achieve this. The `EditText`
    View is typically how this is done and can be added in an XML layout file like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This uses an android style `TextAppearance.AppCompat.Title` to display a title
    as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.21: EditText with hint'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_01_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.21: EditText with hint'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although this is perfectly fine to enable the user to add/edit text, the material
    `TextInputEditText` and it''s wrapper View `TextInputLayout` view gives some polish
    to the `EditText` display. Let''s use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.22: Material TextInputLayout/TextInputEditText with hint'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_01_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.22: Material TextInputLayout/TextInputEditText with hint'
  prefs: []
  type: TYPE_NORMAL
- en: '`TextInputLayout` allows us to create a label for the `TextInputEditText` view
    and does a nice animation when the `TextInputEditText` view is focused (moving
    to the top of the field) while still displaying the label. The label is specified
    with `android:hint.`'
  prefs: []
  type: TYPE_NORMAL
- en: 'You are going to change the `Hello World` text in your app so a user can enter
    their first and last name and further display a greeting on pressing a button.
    Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the labels and text you are going to use in your app by adding these
    entries to `app` | `src` | `main` | `res` | `values` | `strings.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Next, we are going to update our styles to use in the layout by adding the following
    styles to `app` | `src` | `main` | `res` | `themes.xml` after the Base application
    theme)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The parents of some of the styles refer to material styles, so these styles
    will be applied directly to the views as well as the styles that are specified.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have added the styles we want to apply to views in the layout and
    the text, we can update the layout in `activity_main.xml` in `app` | `src` | `main`
    | `res` | `layout` folder. The code below is truncated for space, but you can
    view the full source code using the link below.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: You have added IDs for all the views so they can be constrained against their
    siblings and also provided a way in the activity to get the values of the `TextInputEditText`
    views. The `style="@style.."` notation applies the style from the `themes.xml`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the app and see the look and feel. If you select one of the `TextInputEditText`
    views, you''ll see the label animated and move to the top of the view:![Figure
    1.23: TextInputEditText fields with label states with no focus and with focus'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15216_01_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.23: TextInputEditText fields with label states with no focus and with
    focus'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have to add the interaction with the view in our activity. The layout
    by itself doesn't do anything other than allow the user to enter text into the
    `EditText` fields. Clicking the button at this stage will not do anything. You
    will accomplish this by capturing the entered text by using the IDs of the form
    fields when the button is pressed and then using the text to populate a `TextView` message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `MainActivity` and complete the next steps to process the entered text
    and use this data to display a greeting and handle any form input errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `onCreate` function, set a click listener on the button so we can respond
    to the button click and retrieve the form data by updating `MainActivity` to what
    is displayed below:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, check that the trimmed names are not empty and format the name using
    Kotlin''s string templates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, show a message if the form fields have not been filled in correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `Toast` specified is a small text dialog that appears above the main layout
    for a short time to display a message to the user before disappearing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run up the app and enter text into the fields and verify that a greeting message
    is shown when both text fields are filled in, and a pop-up message appears with
    why the greeting hasn''t been set if both fields are not filled in. You should
    see the following display for each one of these cases:![Figure 1.24: App with
    name filled in correctly and with error'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15216_01_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.24: App with name filled in correctly and with error'
  prefs: []
  type: TYPE_NORMAL
- en: 'The full exercise code can be viewed here: [http://packt.live/39JyOzB](http://packt.live/39JyOzB)'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding exercise has introduced you to adding interactivity to your app
    with `EditText` fields that a user can fill in, adding a click listener to respond
    to button events and perform some validation.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Views in layout files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The established way to access Views in layout files is to use `findViewById`
    with the name of the View''s id. So the `enter_button` `Button` is retrieved by
    the syntax `findViewById<Button>(R.id.enter_button)` after the layout has been
    set in `setContentView(R.layout.activity_main)` in the Activity. You will use
    this technique in this course. Google has also introduced ViewBinding to replace
    `findViewById` which creates a binding class to access Views and has the advantage
    of null and type safety. You can read about this here: [https://developer.android.com/topic/libraries/view-binding](https://developer.android.com/topic/libraries/view-binding)'
  prefs: []
  type: TYPE_NORMAL
- en: Further Input Validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Validating user input is a key concept in processing user data and you must
    have seen it in action many times when you've not entered a required field in
    a form. This is what the previous exercise was validating when it checked that
    the user had entered values into both the first name and last name field.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other validation options that are available directly within XML view
    elements. Let''s say, for instance, you wanted to validate an IP address entered
    into a field. You know that an IP address can be four numbers separated by periods/dots
    where the maximum length of a number is 3\. So, the maximum number of characters
    that can be entered into the field is 15, and only numbers and periods can be
    entered. There are two XML attributes that can help us with the validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`android:digits="0123456789."`: Restricts the characters that can be entered
    into the field by listing all the permitted individual characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:maxLength="15"`: Restricts the user from entering more than the maximum
    number of characters an IP address will consist of.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, this is how you could display this in a form field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This validation restricts the characters that can be input and the maximum length.
    Additional validation would be required on the sequence of characters and whether
    they are periods/dots or numbers, as per the IP address format, but it is the
    first step to assist the user in entering the correct characters.
  prefs: []
  type: TYPE_NORMAL
- en: With the knowledge gained from the chapter, let's start with the following activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 1.01: Producing an App to Create RGB Colors'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, we will look into a scenario that uses validation. Suppose
    you have been tasked with creating an app that shows how the RGB channels of Red,
    Green, and Blue are added to the RGB color space to create a color. Each of the
    RGB channels should be added as two hexadecimal characters, where each character
    can be a value of 0-9 or A-F. The values will then be combined to produce a 6-character
    hexadecimal string that is displayed as a color within the app.
  prefs: []
  type: TYPE_NORMAL
- en: The aim of this activity is to produce a form with editable fields in which
    the user can add two hexadecimal values for each color. After filling in all three
    fields, the user should click a button that takes the three values and concatenates
    them to create a valid hexadecimal color string. This should then be converted
    to a color and displayed in the UI of the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you to complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project called `Colors`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a title to the layout constrained to the top of the layout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a brief description to the user on how to complete the form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add three material `TextInputLayout` fields wrapping three `TextInputEditText`
    fields that appear under `Title`. These should be constrained so that each view
    is on top of the other (rather than to the side). Name the `TextInputEditText`
    fields `Red Channel`, `Green Channel`, and `Blue Channel`, respectively, and add
    a restriction to each field to only be able to enter two characters and add hexadecimal
    characters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a button that takes the inputs from the three-color fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a view that will display the produced color in the layout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, display the RGB color created from the three channels in the layout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final output should look like this (the color will vary depending on the
    inputs):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.25: Output when the color is displayed'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_01_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.25: Output when the color is displayed'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at: [http://packt.live/3sKj1cp](http://packt.live/3sKj1cp)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The sources for all the exercises and the activity in this chapter are located
    here: [http://packt.live/2LLY9kb](http://packt.live/2LLY9kb)'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When loading all completed projects from the Github repository for this course
    into Android Studio for the first time, do *not* open the project using `File`
    | `Open` from the Top menu. Always use `File` | `New` | `Import Project`. This
    is needed to build the app correctly. When opening projects after the initial
    import, you can use `File` | `Open or File` | `Open Recent`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has covered a lot about the foundations of Android development.
    You started off with how to create Android projects using Android Studio and then
    created and ran apps on a virtual device. The chapter then progressed by exploring
    the `AndroidManifest` file, which details the contents of your app and the permission
    model, followed by an introduction to Gradle and the process of adding dependencies
    and building your app. This was then followed by going into the details of an
    Android application and the files and folder structure. Layouts and views were
    introduced, and exercises iterated on to illustrate how to construct UIs with
    an introduction to Google's Material Design. The next chapter will build on this
    knowledge by learning about the activity lifecycle, activity tasks, and launch
    modes, persisting and sharing data between screens, and how to create robust user
    journeys through your apps.
  prefs: []
  type: TYPE_NORMAL
