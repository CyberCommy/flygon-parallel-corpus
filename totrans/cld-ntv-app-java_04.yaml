- en: Writing Your First Cloud-Native Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter looks at the essential elements of building your first cloud-native
    application. We will do the minimal number of steps required to get a microservice
    running in our development environment.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: If you are an experienced Java developer using IDEs such as Eclipse, you will
    find yourself on familiar turf. Though most of it will be similar to building
    traditional applications, there are a few nuances, which we will discuss in this
    chapter and summarize at the end.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'The setup steps to get development going will vary based on the type of developer:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: For hobbyist, self-employed, or working-from-home developers with open access
    to the internet, cloud development is relatively simple.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: for enterprise developers who work on projects for customers or business teams
    in a closed environment and has to access the internet through a proxy, you have
    your enterprise development guidelines to follow. You will be constrained in what
    you can download, run, and configure. Having said that, the benefit of being this
    type of developer is that you are not alone. You have the support of your team
    and colleagues who can help with informal help, or formal documentation in wikis.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will have a cloud-native microservice running
    in your machine. To get there, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: The developer's toolbox and ecosystem
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internet connectivity
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The development life cycle
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Framework selection
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a cloud-native microservice
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling a few cloud native behaviors
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing key aspects of cloud development
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up your developer toolbox
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For any profession, the tools are very important, and that applies to coding
    as well. Before writing a line of code, we need to get the right equipment to
    start.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Getting an IDE
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An** integrated development environment** (**IDE**) is more than a code editor;
    it includes the tools for autocompletion, syntax, formatting, and other miscellaneous
    features, such as search and replace. IDEs have advanced features such as refactoring,
    building, testing, and running the programs with the help of runtime containers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'The popular IDEs are Eclipse, IntelliJ IDEA, and NetBeans. Of the three, Eclipse
    is the most popular and open source IDE available for Java. It has a big community
    and is frequently updated. It has a workspace and an extensible plugin system.
    The development potential of applications in a whole range of languages is endless.
    Some other development IDEs based on Eclipse include the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to do only Spring development, then the derivative of Eclipse
    called **Spring Tool Suite** (**STS**) is a good option.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are also cloud IDEs such as Eclipse Che, touted as the next-generation
    Eclipse. It does not need any installation. You develop in a browser that connects
    to a Che server, which builds a workspace remotely (containing libraries, runtime,
    and dependencies) in a Docker container. As a result, you can develop from any
    machine and anyone can contribute to your project, with just a URL. If you think
    that is cool and have a need for a location- and machine-independent development,
    give it a spin.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the purposes of this book, let's stick to the basic and hugely popular Eclipse.
    The current edition, at the time of writing this book, is Neon. A large community
    and configurable plugin support makes it the IDE of choice for cloud-based Java
    development.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Download the latest version from: [https://www.eclipse.org/](https://www.eclipse.org/).
    Assuming you have JDK 8 or later installed, Eclipse should start up fine.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure a workspace that will store your project files and settings:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d05a49d3-1c19-438f-afdd-9759f8202244.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
- en: 'When you hit OK, the Eclipse IDE should open up. Eclipse Neon will automatically
    get you two important plugins we need for development:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '**Git client**: This will allow us to connect to a Git source control repository.
    This book assumes you use Git due to its popularity and features, but there are
    many older options in use in enterprises, such as Subversion and Perforce. In
    case you use the alternatives, download the respective plugin to your IDE by following
    the developer setup instructions given by your project team or in your team wiki.
    If these instructions do not exist, ask to build one for new team members to use.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maven support**: Maven and Gradle are both great project management and configuration
    tools. They help with tasks such as getting dependencies, compiling, building,
    and so on. We chose Maven because of its maturity with the enterprises.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are coming across these two for the first time, please get familiar with
    both by reading up on their respective websites.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Setting up internet connectivity
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are working in an enterprise and have to access internet through a proxy,
    this can be a pain based on what your enterprise policies limits you to do.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'For our development purposes, we need internet connectivity for the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Downloading dependency libraries such as Log4j and Spring that are configured
    as part of the Maven repository. This is a one-time activity, as the libraries
    become part of the local Maven repository once downloaded. If your organization
    has a repository, you need to configure that.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eclipse plugins from the marketplace as we evolve our sample application.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your program calls a service or APIs that are in the public cloud.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For writing our first service, only the first point is important. Please get
    your proxy details and configure them in the Maven settings from the main menu, Windows
    | Preferences, as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9570efd-e76c-4132-9c6e-bbc5d2386b57.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
- en: 'Make changes to the `settings.xml` file in User Settings and add a proxy section:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Save the file and restart Eclipse. We will know whether it worked when we create
    a project.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the development life cycle
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Professional software writing goes through various stages. In the following
    sections, we will talk about all the various stages we will follow while developing
    the application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Requirements/user stories
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important to know the problem statement being solved before starting any
    coding or design. Agile development methodology recommends breaking the overall
    project into modules and services, and then implementing a few features at a time
    as user stories. The idea is to get a **minimally viable product** (**MVP**) and
    then keep adding features.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: The problem we have taken to solve is an area of e-commerce. Due to online shopping,
    most of us are familiar with e-commerce as consumers. It is time to look under
    the hood.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'The starting point is a `product` service that does the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Returns details of a product given a product ID
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gets a list of product IDs for a given product category
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architecture
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have separate chapters dedicated to this later in the book. In brief, once
    the requirements are known, architecture is about taking key decisions and creating
    a blueprint of how the requirements will be realized, and the design is about
    contracts and mechanisms to implement them. For cloud-native development, we have
    taken a call to implement microservices architecture.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: The microservices architecture paradigm recommends smaller deployment units
    that contain a unit of functionality. Hence, our `product` service will run its
    own process and have its own runtime. This makes it easier to bundle the entire
    runtime, and take it from development to test environments and then to production
    with a consistent behavior. Each `product` service will register itself in a service
    registry to be discoverable to other services. We will examine the technology
    choices later.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Design
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Design takes a deeper dive into the interface and implementation decisions of
    the service. The `product` service will have a simple interface that takes a product
    ID and returns a Java object. If the product is not found in the repository, you
    can decide to return an exception or an empty product. The access is logged and
    metrics on how many times the service was accessed and how long it took are recorded.
    These are the design decisions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 设计深入探讨了服务的接口和实现决策。`product`服务将具有一个简单的接口，接受产品ID并返回一个Java对象。如果在存储库中找不到产品，可以决定返回异常或空产品。访问被记录下来，记录了服务被访问的次数和所花费的时间。这些都是设计决策。
- en: We will discuss architecture and design principles specific to cloud development
    in detail in later chapters.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中详细讨论特定于云开发的架构和设计原则。
- en: Testing and development
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和开发
- en: In any modern enterprise software development, testing is not an afterthought
    or an activity post development. It is done with or prior to the development through
    concepts such as **test-driven development** (**TDD**) and **behavior-driven development**
    (**BDD**). The test cases are written first, which fail initially. Then, enough
    code is written to pass the test case. This concept is extremely important for
    regression testing in future iterations of the product and blends nicely with
    the **continuous integration** (**CI**) and **continuous delivery** (**CD**) concepts
    discussed later.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何现代企业软件开发中，测试都不是事后或开发后的活动。它是通过诸如**测试驱动开发**（**TDD**）和**行为驱动开发**（**BDD**）等概念与开发同时进行或在开发之前进行的。首先编写测试用例，最初失败。然后编写足够的代码来通过测试用例。这个概念对于产品未来迭代中的回归测试非常重要，并与后面讨论的**持续集成**（**CI**）和**持续交付**（**CD**）概念完美融合。
- en: Building and deployment
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和部署
- en: Building and deployment are the steps to create the deployment unit from the
    source code and put it in the target runtime environment. The developer executes
    most of the steps in the IDE. However, with CI principles, an integration server
    does the compilation, automated test case execution, building the deployment unit,
    and deploying it in a target runtime.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和部署是从源代码创建部署单元并将其放入目标运行时环境的步骤。开发人员在IDE中执行大部分步骤。然而，根据CI原则，集成服务器进行编译、自动化测试用例执行、构建部署单元，并将其部署到目标运行时环境。
- en: In a cloud environment, the deployable unit is deployed on a virtual environment
    such as a **virtual machine** (**VM**) or in a container. As part of the deployment,
    it is important to include the necessary runtimes and dependencies as part of
    the build process itself. This is different from the traditional process of putting
    a `.war` or `.ear` in an application server running in each environment. Including
    all dependencies in the deployable unit makes it complete and consistent as it
    moves across the various environments. This reduces the chances of errors where
    the dependencies on server does not match with those on the local machine of the
    developer.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在云环境中，可部署单元部署在虚拟环境中，如**虚拟机**（**VM**）或容器中。作为部署的一部分，将必要的运行时和依赖项包含在构建过程中非常重要。这与将`.war`或`.ear`放入每个环境中运行的应用服务器的传统过程不同。将所有依赖项包含在可部署单元中使其在不同环境中完整和一致。这减少了出现错误的机会，即服务器上的依赖项与开发人员本地机器上的依赖项不匹配。
- en: Selecting a framework
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择框架
- en: 'Having looked at the basics, let''s write our `product` service. After IDE
    setup, the next step is to select a framework to write the service. The microservice
    architecture puts forward a few interesting design considerations that will help
    us select the frameworks:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了基础知识之后，让我们编写我们的`product`服务。在IDE设置之后，下一步是选择一个框架来编写服务。微服务架构提出了一些有趣的设计考虑，这将帮助我们选择框架：
- en: '**Lightweight runtime**: The service should be small in size and fast to deploy'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轻量级运行时**：服务应该体积小，部署快速'
- en: '**High resiliency**: It should have support for patterns such as circuit breaker
    and timeout'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高弹性**：应该支持诸如断路器和超时等模式'
- en: '**Measurable and monitorable**: It should capture metrics and expose hooks
    for monitoring agents to tap into'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可测量和可监控**：应该捕获指标并公开钩子供监控代理使用'
- en: '**Efficient**: It should avoid blocking resources and enable high scalability
    and elasticity in the presence of increased load'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高效**：应该避免阻塞资源，在负载增加的情况下实现高可伸缩性和弹性'
- en: 'A good comparison can be found at: [https://cdelmas.github.io/2015/11/01/A-comparison-of-Microservices-Frameworks.html](https://cdelmas.github.io/2015/11/01/A-comparison-of-Microservices-Frameworks.html).
    Three frameworks are gaining popularity in the Java space that meet the preceding
    requirements: Dropwizard, Vert.x, and Spring Boot.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在以下网址找到一个很好的比较：[https://cdelmas.github.io/2015/11/01/A-comparison-of-Microservices-Frameworks.html](https://cdelmas.github.io/2015/11/01/A-comparison-of-Microservices-Frameworks.html)。在Java领域，有三个框架正在变得流行，符合前述要求：Dropwizard，Vert.x和Spring
    Boot。
- en: Dropwizard
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dropwizard
- en: Dropwizard was one of the first frameworks to popularize the fat JAR concept
    by putting container runtime with all dependencies and libraries inside the deployment
    unit, instead of putting the deployment unit inside the container. It mashes up
    libraries such as Jetty for HTTP, Jackson for JSON, Jersey for REST, and Metrics
    to create a perfect blend for building RESTful web services. It was one of the
    early frameworks to be used in microservice development.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Dropwizard是最早推广fat JAR概念的框架之一，通过将容器运行时与所有依赖项和库一起放入部署单元，而不是将部署单元放入容器。它整合了Jetty用于HTTP，Jackson用于JSON，Jersey用于REST和Metrics等库，创建了一个完美的组合来构建RESTful
    web服务。它是早期用于微服务开发的框架之一。
- en: Its choices, such as JDBI, Freemarker, and Moustache, might sound restrictive
    for some organizations that want flexibility in their choice of implementation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 它的选择，如JDBI，Freemarker和Moustache，可能对一些希望在实现选择上灵活的组织来说有所限制。
- en: Vert.x
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vert.x
- en: Vert.x is an excellent framework to build reactive applications that do not
    block resources (threads) and hence are very scalable and elastic, and hence resilient.
    It is a relatively new kid on the block (with major upgrades in version 3.0).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: However, its Reactive programming model is not very popular in the industry
    yet and hence it is just gaining adoption, especially for use cases that require
    very high resiliency and scalability.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Boot is rapidly becoming the most popular of the Java frameworks for
    building cloud-native microservices. Here are a few good reasons:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: It has a foundation on Spring and Spring MVC, which is already popular in enterprises
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like Dropwizard, it assembles the most reasonable defaults and takes an opinionated
    approach to assembling the required dependencies for the services, reducing the
    XML required for configuration
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It integrates Spring Cloud out of the box, which provides useful libraries such
    as Hystrix and Ribbon, for distributed service development that is required for
    cloud deployment
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a lower learning curve; you can get started in minutes (as we shall see
    next)
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has the concept of 40+ starter Maven **Project Object Models (POMs)** that
    give good flexibility for choosing and developing applications
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot is suitable for a wide spectrum of the workloads that are suitable
    for cloud-native deployments and hence is a good first choice for most use cases.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Let's get into writing a service in Spring Boot now.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Writing a product service
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the sake of simplicity, our `product` service has two functions:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '`List<int> getProducts(int categoryId)`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Product getProduct(int prodId)`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The intent of the two methods is quite clear. The first returns a list of product
    IDs given a category ID, and the second returns product details (as an object)
    given a product ID.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Service registration and discovery
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why is service registration and discovery important? So far, we have been calling
    the service through its URL, which includes the IP address—for example, `http://localhost:8080/prod`—thus
    we expect the service to run at that address. Even though we might substitute
    the test and the production URLs, the step of calling the service at a particular
    IP address and port is still static.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: However, in a cloud environment, things are quite dynamic. If the service goes
    down at a given IP, it can come up in a different IP address as it comes up on
    some container. Although we can mitigate that with virtual IPs and reverse proxies,
    it would be better to look up a service dynamically at the time of the service
    call and then call the service at the IP address. The lookup addresses can be
    cached in the client, so that the dynamic lookup need not be performed for each
    service call.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: A registry (referred to as a service registry) helps in this case. When the
    service boots up, it registers itself in a registry. There is also a heartbeat
    between registry and service to ensure that the registry keeps only live services
    in its registry. If the heartbeat stops, the registry deregisters that instance
    of the service.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'For this quick starter, we are going to use Spring Cloud Netflix, which nicely
    integrates with Spring Boot. We need three components now:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '**Product service**: We have already written this'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service registry**: We are going to use Eureka, which is part of Spring Cloud'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service client**: Instead of calling our service directly through a browser,
    we will write a simple client to our service'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Maven project
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open your IDE (Eclipse Neon or other) and then create a new Maven project as
    follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on Package Explorer and select New and Project..., as shown in
    the following screenshot:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/681949d8-038d-4675-9be2-8e5a65d86c5a.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
- en: 'Select Maven Project:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9fe14540-94a8-4cd4-b7fe-156e2d293869.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: In the next window of the wizard, choose Create a simple project.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next dialog will ask for many parameters. Of these, the Group Id (what
    your project name is) and the Artifact Id (application or service name) are important.
    Select reasonable names, as shown in the following screenshot:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1c3962d4-41d2-4a1f-9fda-56f35f23a737.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
- en: 'Select Finish. You should see the following structure:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f7096253-de5c-4104-ac43-57ab9881fb77.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: If the JRE System Library [JavaSE-1.6] does not exist, or you have a later version,
    go to the project properties and edit it to select the version that your Eclipse
    is configured with. You do this by changing the Properties by right-clicking JRE
    System Library [JavaSE-1.6]. Here's a screenshot after adjusting the JRE System Library
    to 1.8.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43dfa29c-079f-4a17-b400-375158b121f4.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
- en: 'Now, you have a clean slate. Open the Maven file `pom.xml` and add a dependency
    to the `spring-boot-starter-web`. This will tell Spring Boot to configure this
    project to get libraries for web development:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When you save this POM file, your IDE will build the workspace and download
    the dependent libraries, assuming your internet connection works (directly or
    through a proxy as configured before), and you are all set to develop the service.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Spring Boot application class
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This class contains the main method where the execution starts. This main method
    will bootstrap the Spring Boot application, look at the configurations, and start
    the respective bundled containers such as Tomcat if executing web services:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note the annotation called `@SpringBootApplication`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@SpringBootApplication` annotation is equivalent to using `@Configuration`,
    `@EnableAutoConfiguration`, and `@ComponentScan`, which do the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '`@Configuration`: This is a core Spring annotation. It tells Spring that this
    class is a source of the `Bean` definitions.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@EnableAutoConfiguration`: This annotation tells Spring Boot to guess how
    you will want to configure Spring, based on the JAR dependencies that you have
    added. We have added the starter web and hence the application will be considered
    to be a Spring MVC web application.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ComponentScan`: This annotation tells Spring to scan for any components,
    for example, the `RestController` that we are going to write. Note the scan happens
    in current and child packages. Hence, the class having this component scan should
    be at the top of the package hierarchy.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing service and domain objects
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The annotations in Spring Boot make it easy to extract parameters and path variables
    and execute the service. For now, let's mock the response instead of getting the
    data from the database.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a simple Java entity called the `Product` class. For now, it is a simple **Plain
    Old Java Object** (**POJO**) class with three fields:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the getter and setter methods and a constructor that accepts the product
    ID:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Also, add an empty constructor that will be used by the service client, as
    we will see later:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, write the `ProductService` class as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e48d02a3-1d11-4c87-b0f6-933b6155d8a2.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: Running the service
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many ways to run the service.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on the project and select Run As | Maven build and configure the
    Run Configurations to execute the `spring-boot:run` target as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/517a372f-2512-46ef-8db3-44f2e63bac93.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: 'On clicking Run, if the internet connection and configuration are fine, you
    will see the following console output:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note the stages of the Maven execution:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: First, the Maven task compiles all the Java files. We have three simple Java
    classes as of now.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step runs it as an application, where a Tomcat instance starts.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note the mapping of the URLs `/product/` and `/productIds` to the `Bean` methods.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tomcat listens on port `8080` for service requests.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also run the service by just right-clicking the class that has the main
    method (`ProductSpringApp`) in Package Explorer and then selecting Run As | Java
    Application.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Testing the service on the browser
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open a browser and hit the following URL: `http://localhost:8080/product/1`.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'You should get back the following response:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, try the other service (URL—`http://localhost:8080/productIds`). What response
    do you get? An error, as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Can you guess why? It is because the service definition that you wrote had
    a method expecting a request parameter:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So, the URL is expecting an `id` and as you did not supply it, it gives an error.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Give the parameter and try  `http://localhost:8080/productIds?id=5` again.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'You will now get back a correct response:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Creating a deployable
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are not going to run our service on Eclipse. We would like to deploy it
    on a server. There are two options for doing this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Create a WAR and deploy it in Tomcat or any other web container. This is the
    traditional method.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a JAR with the runtime (Tomcat) included so that you just need Java to
    execute the service.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In cloud application development, the second option, also called fat JAR or
    uber JAR, is becoming popular for the following reasons:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: The deployable is self-contained with all the dependencies it needs. This reduces
    the chances of environment mismatch as the deployable unit is deployed to Dev,
    Test, UAT, and Production. If it works in development, there is a good chance
    it will work across all the other environments.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The host, server, or container where the service is deployed need not have a
    preinstalled application server or servlet engine. Just a basic JRE is good enough.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at the steps to create a JAR file and run it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the following dependencies of the POM file:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, run it by right-clicking the project in the explorer and choosing Run As
    | Maven Install.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: You will see `product-0.0.1-SNAPSHOT.jar` in the target directory of the project
    folder structure.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the `product` folder so that you see the target directory in the
    command line and then run the JAR through a Java command, as shown in the following
    screenshot:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43947a81-a87d-47cb-832f-a0a4ecb0893c.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
- en: You will see Tomcat listening to the port at the end of the startup. Test it
    through the browser again. Milestone achieved.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Enabling cloud-native behaviors
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have just developed a basic service with two APIs that respond to requests.
    Let''s add a few capabilities that will enable to it to be a good cloud citizen.
    We will discuss the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Externalizing configuration
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instrumentation—health and metrics
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service registration and discovery
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Externalizing configuration
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configuration can be any property that is likely to differ between environments
    or production deployments. Typical examples are queue and topic names, ports,
    URLs, connection and pool properties, and so on.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: A deployable should not have configuration in it. A configuration should be
    injected from outside. This makes the deployable unit immutable as it goes through
    the various stages of the life cycle, such as Dev, QA, and UAT.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume we have to run our `product` service in different environments,
    where the URL differentiates the environment. Therefore, the small change we make
    in the request mapping is as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can inject this variable in various ways. Once injected, the value is not
    expected to change for the life of the deployment. The simplest is to pass it
    in the command-line argument. Bring up the Run Configurations dialog and in the
    Arguments, add the command-line parameter `-env=dev/` as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0613d40-8b94-4e8b-8f03-81ba4ddbd6cc.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: 'Now, Run the configuration. During startup, you will find the value substituted
    in the log statement as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The configuration can also be provided through configuration files, database,
    operating system environment properties, and so on.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Spring applications popularly use `application.properties` to store a few properties
    such as port numbers. Recently, YAML, which is a superset of JSON, is becoming
    more popular due to the hierarchical definition of the properties.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `application.yml` file in the `/product/src/main/resources` folder
    of the application and put in the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的`/product/src/main/resources`文件夹中创建一个`application.yml`文件，并输入以下内容：
- en: '[PRE14]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This tells the `product` service to run at port `8081` instead of the default
    `8080`. This concept is further extended to profiles. So, it is possible to load
    different profiles by loading the configuration specific to the profile.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉`product`服务在端口`8081`上运行，而不是默认的`8080`。这个概念进一步扩展到配置文件。因此，可以通过加载特定于配置文件的配置来加载不同的配置文件。
- en: Spring Cloud Config as a project handles this well. It uses a `bootstrap.yml`
    file to get the application started up with a name and details of the source to
    further load the configuration. Hence, `bootstrap.yml` contains the application
    name and config server details, and then loads the respective profile configuration.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Config作为一个项目很好地处理了这个问题。它使用`bootstrap.yml`文件来启动应用程序，并加载配置的名称和详细信息。因此，`bootstrap.yml`包含应用程序名称和配置服务器详细信息，然后加载相应的配置文件。
- en: 'Create a `bootstrap.yml` file in the `resources` folder of the application
    and put in the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的`resources`文件夹中创建一个`bootstrap.yml`文件，并输入以下内容：
- en: '[PRE15]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We will come back to these files when we discuss service registration later.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论服务注册时，我们将回到这些文件。
- en: Metering your services
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计量您的服务
- en: Instrumentation is important for cloud applications. Your service should expose
    health check and metrics so that it can be monitored better. Spring Boot allows
    for easier instrumentation through the `actuator` module.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 仪器化对于云应用程序非常重要。您的服务应该公开健康检查和指标，以便更好地进行监控。Spring Boot通过`actuator`模块更容易进行仪器化。
- en: 'Include the following in your POM:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在POM中包含以下内容：
- en: '[PRE16]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Run the service. During startup, you will see a number of mappings being created.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 运行服务。在启动过程中，您将看到创建了许多映射。
- en: 'You can access these URLs (such as `http://localhost:8080/env`) directly and
    see the information displayed:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接访问这些URL（例如`http://localhost:8080/env`）并查看显示的信息：
- en: '[PRE17]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The metrics are especially interesting (`http://localhost:8080/metrics`):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 指标尤其有趣（`http://localhost:8080/metrics`）：
- en: '[PRE18]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The information includes the counters and gauges which store the number of times
    the service was accessed and the response times.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 信息包括计数器和量规，用于存储服务被访问的次数和响应时间。
- en: Running a service registry
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行服务注册表
- en: Consul and Eureka are two popular dynamic service registries. There are subtle
    conceptual differences between them with respect to the method of heartbeats and
    agent-based operations, but the fundamental concept of registry is similar. The
    selection of the registry will be driven by the needs and the decisions of the
    enterprise. For our example, let's continue with Spring Boot and the Spring Cloud
    ecosystem and use Eureka for this example. Spring Cloud includes Spring Cloud
    Netflix, which has support for the Eureka registry.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Consul和Eureka是两个流行的动态服务注册表。它们在心跳方法和基于代理的操作方面存在微妙的概念差异，但注册表的基本概念是相似的。注册表的选择将受企业的需求和决策的驱动。对于我们的示例，让我们继续使用Spring
    Boot和Spring Cloud生态系统，并为此示例使用Eureka。Spring Cloud包括Spring Cloud Netflix，它支持Eureka注册表。
- en: 'Perform the following steps to get a service registry running:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以运行服务注册表：
- en: Create a new Maven project with `artifactId` as `eureka-server`.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Maven项目，`artifactId`为`eureka-server`。
- en: 'Edit the POM file and add the following:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑POM文件并添加以下内容：
- en: Parent as `spring-boot-starter-parent`
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父级为`spring-boot-starter-parent`
- en: The dependency to `eureka-server` as ``spring-cloud-starter-eureka-server``
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖于`eureka-server`为`spring-cloud-starter-eureka-server`
- en: 'The `dependencyManagement` to `spring-cloud-netflix`:'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dependencyManagement`为`spring-cloud-netflix`：'
- en: '![](img/432ff7ef-5eb6-4cc5-9810-9280b967d0e7.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/432ff7ef-5eb6-4cc5-9810-9280b967d0e7.png)'
- en: 'Create an application class similar to the one we created for the `product`
    project. Note the annotations. The annotation `@EnableEurekaServer` starts Eureka
    as a service:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类似于我们为`product`项目创建的应用程序类。注意注解。注解`@EnableEurekaServer`将Eureka作为服务启动：
- en: '![](img/f1c9c5e9-be4a-4332-8242-c5a24e496291.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f1c9c5e9-be4a-4332-8242-c5a24e496291.png)'
- en: 'Create an `application.yml` file in the `/product/src/main/resources` folder
    of the application and put in the following:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序的`/product/src/main/resources`文件夹中创建一个`application.yml`文件，并输入以下内容：
- en: '[PRE19]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create a `bootstrap.yml` file in the `resources` folder of the application
    and put in the following:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序的`resources`文件夹中创建一个`bootstrap.yml`文件，并输入以下内容：
- en: '[PRE20]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Build the `eureka-server` Maven project (as we did for `product`) and then run
    it.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建`eureka-server` Maven项目（就像我们为`product`做的那样），然后运行它。
- en: 'Apart from a few connectivity errors (more on this later), you should see a
    Tomcat started message as follows:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了一些连接错误（稍后会详细介绍），您应该看到以下Tomcat启动消息：
- en: '![](img/aa53f30d-18e5-46f3-b83d-342370af2aec.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa53f30d-18e5-46f3-b83d-342370af2aec.png)'
- en: 'Once the startup is completed, access the Eureka server at `localhost:8761`
    and check whether you get the following page:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 启动完成后，访问`localhost:8761`上的Eureka服务器，并检查是否出现以下页面：
- en: '![](img/be32fc66-1a70-47a3-bad5-8d633506d118.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be32fc66-1a70-47a3-bad5-8d633506d118.png)'
- en: Look at the circled section in the preceding screenshot. The instance currently
    registered with Eureka is `EUREKA` itself. We can correct this later. Now, let's
    focus on registering our `product` service with this Eureka service registry.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 查看前面截图中的圈定部分。当前注册到Eureka的实例是`EUREKA`本身。我们可以稍后更正这一点。现在，让我们专注于将我们的`product`服务注册到这个Eureka服务注册表。
- en: Registering a product service
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册产品服务
- en: 'The `product` service boots up and listens on port `8081` for `product` service
    requests. We will now add the necessary instructions so that the service instance
    registers itself with the Eureka registry. Thanks to Spring Boot, we only have
    to do a few configurations and annotations:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`product`服务启动并监听端口`8081`以接收`product`服务请求。现在，我们将添加必要的指示，以便服务实例将自身注册到Eureka注册表中。由于Spring
    Boot，我们只需要进行一些配置和注解：'
- en: 'Add the `dependencyManagement` section with dependency on `spring-cloud-netflix`
    and the dependency in the existing dependencies section to `spring-cloud-starter-eureka`
    to the `product` service POM as follows:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`product`服务POM中添加`dependencyManagement`部分，依赖于`spring-cloud-netflix`和现有依赖项部分中的`spring-cloud-starter-eureka`如下所示：
- en: '![](img/582a3747-c882-43dd-a428-9c5e34411f9b.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/582a3747-c882-43dd-a428-9c5e34411f9b.png)'
- en: 'The `product` service keeps renewing its lease every specific interval. Reduce
    it to 5 seconds, by defining an entry explicitly in the `application.yml` as follows:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`product`服务会在特定间隔内不断更新其租约。通过在`application.yml`中明确定义一个条目，将其减少到5秒：'
- en: '[PRE21]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Include the annotation `@EnableDiscoveryClient` in the startup application
    class of the `product` project, in other words, `ProductSpringApp`. The `@EnableDiscoveryClient`
    annotation activates the Netflix Eureka `DiscoveryClient` implementation as that
    is the one we have defined in the POM file. There are other implementations for
    other service registries, such as HashiCorp Consul or Apache Zookeeper:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`product`项目的启动应用程序类中包含`@EnableDiscoveryClient`注解，换句话说，`ProductSpringApp`。`@EnableDiscoveryClient`注解激活Netflix
    Eureka `DiscoveryClient`实现，因为这是我们在POM文件中定义的。还有其他实现适用于其他服务注册表，如HashiCorp Consul或Apache
    Zookeeper：
- en: '![](img/397e1c42-3d6c-424c-9012-305e71f783ae.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/397e1c42-3d6c-424c-9012-305e71f783ae.png)'
- en: 'Now, start the `product` service as before:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，像以前一样启动`product`服务：
- en: '![](img/8e4e43cc-a802-441d-b9ba-0f169af84c0c.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e4e43cc-a802-441d-b9ba-0f169af84c0c.png)'
- en: At the end of the initialization of the `product` service, you will see log
    statements that register the service with the Eureka server.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在`product`服务初始化结束时，您将看到注册服务到Eureka服务器的日志声明。
- en: 'To check whether the `product` service has registered, refresh the Eureka server
    page that you just accessed:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查`product`服务是否已注册，请刷新您刚访问的Eureka服务器页面：
- en: '![](img/2c653d48-c5d6-4702-83bf-e03c58e5131b.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2c653d48-c5d6-4702-83bf-e03c58e5131b.png)'
- en: Also keep a tab on the Eureka log. You will find the lease renewal log statements
    of the `product` service.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 还要留意Eureka日志。您会发现`product`服务的租约续订日志声明。
- en: Creating a product client
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建产品客户端
- en: We have created a dynamic product registry and even registered our service.
    Now, let's use this lookup to access the `product` service.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个动态产品注册表，甚至注册了我们的服务。现在，让我们使用这个查找来访问`product`服务。
- en: We will use the Netflix Ribbon project, which provides a load balancer as well
    as having address lookup from the service registry. Spring Cloud makes it easier
    to configure and use this.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Netflix Ribbon项目，该项目提供了负载均衡器以及从服务注册表中查找地址的功能。Spring Cloud使配置和使用这一切变得更加容易。
- en: 'For now, let''s run the client within the same project as the service itself.
    The client will make an HTTP call to the service after looking up the product
    definition in Eureka. All this will be done by the Ribbon library, and we will
    just be using it as an endpoint:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在与服务本身相同的项目中运行客户端。客户端将在Eureka中查找产品定义后，向服务发出HTTP调用。所有这些都将由Ribbon库完成，我们只需将其用作端点：
- en: 'Add a dependency to the Maven POM of the `product` project as follows:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`product`项目的Maven POM中添加依赖如下：
- en: '![](img/a120da92-e357-4c87-a464-4497467711cd.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a120da92-e357-4c87-a464-4497467711cd.png)'
- en: 'Create a `ProductClient` class, which simply listens on `/client` and then
    forwards the request after doing a lookup to the actual `product` service:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`ProductClient`类，它简单地监听`/client`，然后在进行查找后将请求转发到实际的`product`服务：
- en: '![](img/a9340beb-00a1-47e4-b71f-2fd7ebcb4681.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a9340beb-00a1-47e4-b71f-2fd7ebcb4681.png)'
- en: The URL construction `http://PRODUCT/` will be translated at runtime by Ribbon
    after doing a lookup. We are nowhere giving an IP address of the service.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: URL构造`http://PRODUCT/`将在运行时由Ribbon进行翻译。我们没有提供服务的IP地址。
- en: 'The `restTemplate` is injected here through auto-wiring. However, it needs
    to be initialized in the latest Spring versions. Hence, declare it as follows
    in the main application class, which also acts as a configuration class:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`restTemplate`通过自动装配在这里注入。但是，在最新的Spring版本中需要初始化它。因此，在主应用程序类中声明如下，这也充当配置类：'
- en: '![](img/da08bf22-4652-47b9-bdc4-29a5a359104e.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da08bf22-4652-47b9-bdc4-29a5a359104e.png)'
- en: The `@LoadBalanced` annotation tells Spring to use the Ribbon load balancer
    (as Ribbon is in the classpath due to Maven).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`@LoadBalanced`注解告诉Spring使用Ribbon负载均衡器（因为Ribbon在类路径中由Maven提供）。'
- en: Seeing the lookup in action
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看查找的实际操作
- en: 'Now, we are all set to run the product client. To recap, at this stage, we
    have a Eureka server project and a `product` project with the following structure:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好运行产品客户端了。简而言之，在这个阶段，我们有一个Eureka服务器项目和一个具有以下结构的`product`项目：
- en: '![](img/e6bb7836-fac8-4b95-a37b-c562d0d4fd4c.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e6bb7836-fac8-4b95-a37b-c562d0d4fd4c.png)'
- en: 'Let''s take a few minutes to review what we did:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花几分钟时间来回顾一下我们做了什么：
- en: We created a Maven project and defined the starters and dependencies.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个Maven项目并定义了启动器和依赖项。
- en: We created the YML files for bootstrapping and application properties.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为引导和应用程序属性创建了YML文件。
- en: We created the `ProductSpringApp` class containing the main method that is the
    starting point of the applications.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了包含主方法的`ProductSpringApp`类，这是应用程序的起点。
- en: 'For the `product` project, we had the following classes:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`product`项目，我们有以下类：
- en: '`Product`: The domain or entity which we will enhance later'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Product`：我们稍后将增强的领域或实体'
- en: '`ProductService`: The microservice responsible for implementing the services
    and APIs'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProductService`：负责实现服务和API的微服务'
- en: '`ProductClient`: The client to test out the service lookup'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProductClient`：用于测试服务查找的客户端'
- en: 'Now, let''s see it in action:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看它的实际操作：
- en: 'Run the `EurekaApplication` class (or run a Maven build on the `eureka-server`
    project). Observe the last few lines in the logs:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`EurekaApplication`类（或在`eureka-server`项目上运行Maven构建）。观察日志中的最后几行：
- en: '![](img/9624f0d6-6e69-49df-9d35-0988accb12c2.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9624f0d6-6e69-49df-9d35-0988accb12c2.png)'
- en: 'Run the `ProductSpringApp` class (or run a Maven build on the `product` project).
    Note the last few lines in the the log:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`ProductSpringApp`类（或在`product`项目上运行Maven构建）。注意日志中的最后几行：
- en: '![](img/57e4b508-31d3-4563-985e-2fa5b451d62e.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
- en: Access the `product` service directly at: `http://localhost:8081/dev/product/4`.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following response:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, access the client URL, `http://localhost:8081/client/4` , which does a
    lookup of the `product` service from the service registry and directs it to the
    respective `product` service.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following response:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You may see an internal server error (`No instances available for PRODUCT`).
    This can happen while the heartbeat completes and the addresses are re-picked
    by the Ribbon load balancer. Wait a few seconds for the registry to update and then try
    again.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'A lot has happened under the hood in getting this response:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP request to get `/client/4` was handled by the `getProduct` method in
    the `ProductClient` class.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It did a lookup of the service from the Eureka registry. This is where we find
    log statements as follows:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: After it did the lookup, it forwarded the request to the actual `ProductService`
    through the Ribbon load balancer library.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This was just a simple mechanism of a client invoking services through a dynamic
    lookup. In later chapters, we will add functionality to make it resilient and
    functional in terms of getting data from the database.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's review the key concepts of the cloud applications that we have discussed
    so far. We made our application **lightweight** by making it run on a servlet
    engine and start in less than 15 seconds. Our application is **self-contained**,
    as the fat JAR has all libraries to run our service. We just need a JVM to run
    this JAR file. It has **externalized configuration** (to some extent) by injecting
    environment from the command line and properties from `application.yml` and `bootstrap.yml`.
    We take a deeper look at the next stages of externalization in [Chapter 7](23d9bfc6-4a12-4ead-9389-7d11ac4cb2ac.xhtml),
    *Cloud-Native Application Runtime*. The Spring actuator helped capturing all metrics
    and made their URL available for consumption, thus enabling **instrumentation**.
    The **location abstraction** was implemented by Eureka.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapters, we will enhance this service by adding to it a data tier
    and resiliency, and adding cache behavior and other enhancements that we skipped
    in this chapter.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
