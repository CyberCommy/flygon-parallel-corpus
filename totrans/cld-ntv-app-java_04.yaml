- en: Writing Your First Cloud-Native Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter looks at the essential elements of building your first cloud-native
    application. We will do the minimal number of steps required to get a microservice
    running in our development environment.
  prefs: []
  type: TYPE_NORMAL
- en: If you are an experienced Java developer using IDEs such as Eclipse, you will
    find yourself on familiar turf. Though most of it will be similar to building
    traditional applications, there are a few nuances, which we will discuss in this
    chapter and summarize at the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'The setup steps to get development going will vary based on the type of developer:'
  prefs: []
  type: TYPE_NORMAL
- en: For hobbyist, self-employed, or working-from-home developers with open access
    to the internet, cloud development is relatively simple.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: for enterprise developers who work on projects for customers or business teams
    in a closed environment and has to access the internet through a proxy, you have
    your enterprise development guidelines to follow. You will be constrained in what
    you can download, run, and configure. Having said that, the benefit of being this
    type of developer is that you are not alone. You have the support of your team
    and colleagues who can help with informal help, or formal documentation in wikis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will have a cloud-native microservice running
    in your machine. To get there, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The developer's toolbox and ecosystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internet connectivity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The development life cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Framework selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a cloud-native microservice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling a few cloud native behaviors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing key aspects of cloud development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up your developer toolbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For any profession, the tools are very important, and that applies to coding
    as well. Before writing a line of code, we need to get the right equipment to
    start.
  prefs: []
  type: TYPE_NORMAL
- en: Getting an IDE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An** integrated development environment** (**IDE**) is more than a code editor;
    it includes the tools for autocompletion, syntax, formatting, and other miscellaneous
    features, such as search and replace. IDEs have advanced features such as refactoring,
    building, testing, and running the programs with the help of runtime containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The popular IDEs are Eclipse, IntelliJ IDEA, and NetBeans. Of the three, Eclipse
    is the most popular and open source IDE available for Java. It has a big community
    and is frequently updated. It has a workspace and an extensible plugin system.
    The development potential of applications in a whole range of languages is endless.
    Some other development IDEs based on Eclipse include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to do only Spring development, then the derivative of Eclipse
    called **Spring Tool Suite** (**STS**) is a good option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are also cloud IDEs such as Eclipse Che, touted as the next-generation
    Eclipse. It does not need any installation. You develop in a browser that connects
    to a Che server, which builds a workspace remotely (containing libraries, runtime,
    and dependencies) in a Docker container. As a result, you can develop from any
    machine and anyone can contribute to your project, with just a URL. If you think
    that is cool and have a need for a location- and machine-independent development,
    give it a spin.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the purposes of this book, let's stick to the basic and hugely popular Eclipse.
    The current edition, at the time of writing this book, is Neon. A large community
    and configurable plugin support makes it the IDE of choice for cloud-based Java
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Download the latest version from: [https://www.eclipse.org/](https://www.eclipse.org/).
    Assuming you have JDK 8 or later installed, Eclipse should start up fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure a workspace that will store your project files and settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d05a49d3-1c19-438f-afdd-9759f8202244.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When you hit OK, the Eclipse IDE should open up. Eclipse Neon will automatically
    get you two important plugins we need for development:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Git client**: This will allow us to connect to a Git source control repository.
    This book assumes you use Git due to its popularity and features, but there are
    many older options in use in enterprises, such as Subversion and Perforce. In
    case you use the alternatives, download the respective plugin to your IDE by following
    the developer setup instructions given by your project team or in your team wiki.
    If these instructions do not exist, ask to build one for new team members to use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maven support**: Maven and Gradle are both great project management and configuration
    tools. They help with tasks such as getting dependencies, compiling, building,
    and so on. We chose Maven because of its maturity with the enterprises.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are coming across these two for the first time, please get familiar with
    both by reading up on their respective websites.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up internet connectivity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are working in an enterprise and have to access internet through a proxy,
    this can be a pain based on what your enterprise policies limits you to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our development purposes, we need internet connectivity for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Downloading dependency libraries such as Log4j and Spring that are configured
    as part of the Maven repository. This is a one-time activity, as the libraries
    become part of the local Maven repository once downloaded. If your organization
    has a repository, you need to configure that.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eclipse plugins from the marketplace as we evolve our sample application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your program calls a service or APIs that are in the public cloud.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For writing our first service, only the first point is important. Please get
    your proxy details and configure them in the Maven settings from the main menu, Windows
    | Preferences, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9570efd-e76c-4132-9c6e-bbc5d2386b57.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Make changes to the `settings.xml` file in User Settings and add a proxy section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Save the file and restart Eclipse. We will know whether it worked when we create
    a project.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the development life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Professional software writing goes through various stages. In the following
    sections, we will talk about all the various stages we will follow while developing
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements/user stories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important to know the problem statement being solved before starting any
    coding or design. Agile development methodology recommends breaking the overall
    project into modules and services, and then implementing a few features at a time
    as user stories. The idea is to get a **minimally viable product** (**MVP**) and
    then keep adding features.
  prefs: []
  type: TYPE_NORMAL
- en: The problem we have taken to solve is an area of e-commerce. Due to online shopping,
    most of us are familiar with e-commerce as consumers. It is time to look under
    the hood.
  prefs: []
  type: TYPE_NORMAL
- en: 'The starting point is a `product` service that does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Returns details of a product given a product ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gets a list of product IDs for a given product category
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have separate chapters dedicated to this later in the book. In brief, once
    the requirements are known, architecture is about taking key decisions and creating
    a blueprint of how the requirements will be realized, and the design is about
    contracts and mechanisms to implement them. For cloud-native development, we have
    taken a call to implement microservices architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The microservices architecture paradigm recommends smaller deployment units
    that contain a unit of functionality. Hence, our `product` service will run its
    own process and have its own runtime. This makes it easier to bundle the entire
    runtime, and take it from development to test environments and then to production
    with a consistent behavior. Each `product` service will register itself in a service
    registry to be discoverable to other services. We will examine the technology
    choices later.
  prefs: []
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Design takes a deeper dive into the interface and implementation decisions of
    the service. The `product` service will have a simple interface that takes a product
    ID and returns a Java object. If the product is not found in the repository, you
    can decide to return an exception or an empty product. The access is logged and
    metrics on how many times the service was accessed and how long it took are recorded.
    These are the design decisions.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss architecture and design principles specific to cloud development
    in detail in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Testing and development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In any modern enterprise software development, testing is not an afterthought
    or an activity post development. It is done with or prior to the development through
    concepts such as **test-driven development** (**TDD**) and **behavior-driven development**
    (**BDD**). The test cases are written first, which fail initially. Then, enough
    code is written to pass the test case. This concept is extremely important for
    regression testing in future iterations of the product and blends nicely with
    the **continuous integration** (**CI**) and **continuous delivery** (**CD**) concepts
    discussed later.
  prefs: []
  type: TYPE_NORMAL
- en: Building and deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building and deployment are the steps to create the deployment unit from the
    source code and put it in the target runtime environment. The developer executes
    most of the steps in the IDE. However, with CI principles, an integration server
    does the compilation, automated test case execution, building the deployment unit,
    and deploying it in a target runtime.
  prefs: []
  type: TYPE_NORMAL
- en: In a cloud environment, the deployable unit is deployed on a virtual environment
    such as a **virtual machine** (**VM**) or in a container. As part of the deployment,
    it is important to include the necessary runtimes and dependencies as part of
    the build process itself. This is different from the traditional process of putting
    a `.war` or `.ear` in an application server running in each environment. Including
    all dependencies in the deployable unit makes it complete and consistent as it
    moves across the various environments. This reduces the chances of errors where
    the dependencies on server does not match with those on the local machine of the
    developer.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having looked at the basics, let''s write our `product` service. After IDE
    setup, the next step is to select a framework to write the service. The microservice
    architecture puts forward a few interesting design considerations that will help
    us select the frameworks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lightweight runtime**: The service should be small in size and fast to deploy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High resiliency**: It should have support for patterns such as circuit breaker
    and timeout'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Measurable and monitorable**: It should capture metrics and expose hooks
    for monitoring agents to tap into'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efficient**: It should avoid blocking resources and enable high scalability
    and elasticity in the presence of increased load'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A good comparison can be found at: [https://cdelmas.github.io/2015/11/01/A-comparison-of-Microservices-Frameworks.html](https://cdelmas.github.io/2015/11/01/A-comparison-of-Microservices-Frameworks.html).
    Three frameworks are gaining popularity in the Java space that meet the preceding
    requirements: Dropwizard, Vert.x, and Spring Boot.'
  prefs: []
  type: TYPE_NORMAL
- en: Dropwizard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dropwizard was one of the first frameworks to popularize the fat JAR concept
    by putting container runtime with all dependencies and libraries inside the deployment
    unit, instead of putting the deployment unit inside the container. It mashes up
    libraries such as Jetty for HTTP, Jackson for JSON, Jersey for REST, and Metrics
    to create a perfect blend for building RESTful web services. It was one of the
    early frameworks to be used in microservice development.
  prefs: []
  type: TYPE_NORMAL
- en: Its choices, such as JDBI, Freemarker, and Moustache, might sound restrictive
    for some organizations that want flexibility in their choice of implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Vert.x
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vert.x is an excellent framework to build reactive applications that do not
    block resources (threads) and hence are very scalable and elastic, and hence resilient.
    It is a relatively new kid on the block (with major upgrades in version 3.0).
  prefs: []
  type: TYPE_NORMAL
- en: However, its Reactive programming model is not very popular in the industry
    yet and hence it is just gaining adoption, especially for use cases that require
    very high resiliency and scalability.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Boot is rapidly becoming the most popular of the Java frameworks for
    building cloud-native microservices. Here are a few good reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: It has a foundation on Spring and Spring MVC, which is already popular in enterprises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like Dropwizard, it assembles the most reasonable defaults and takes an opinionated
    approach to assembling the required dependencies for the services, reducing the
    XML required for configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It integrates Spring Cloud out of the box, which provides useful libraries such
    as Hystrix and Ribbon, for distributed service development that is required for
    cloud deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a lower learning curve; you can get started in minutes (as we shall see
    next)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has the concept of 40+ starter Maven **Project Object Models (POMs)** that
    give good flexibility for choosing and developing applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot is suitable for a wide spectrum of the workloads that are suitable
    for cloud-native deployments and hence is a good first choice for most use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get into writing a service in Spring Boot now.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a product service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the sake of simplicity, our `product` service has two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`List<int> getProducts(int categoryId)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Product getProduct(int prodId)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The intent of the two methods is quite clear. The first returns a list of product
    IDs given a category ID, and the second returns product details (as an object)
    given a product ID.
  prefs: []
  type: TYPE_NORMAL
- en: Service registration and discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why is service registration and discovery important? So far, we have been calling
    the service through its URL, which includes the IP address—for example, `http://localhost:8080/prod`—thus
    we expect the service to run at that address. Even though we might substitute
    the test and the production URLs, the step of calling the service at a particular
    IP address and port is still static.
  prefs: []
  type: TYPE_NORMAL
- en: However, in a cloud environment, things are quite dynamic. If the service goes
    down at a given IP, it can come up in a different IP address as it comes up on
    some container. Although we can mitigate that with virtual IPs and reverse proxies,
    it would be better to look up a service dynamically at the time of the service
    call and then call the service at the IP address. The lookup addresses can be
    cached in the client, so that the dynamic lookup need not be performed for each
    service call.
  prefs: []
  type: TYPE_NORMAL
- en: A registry (referred to as a service registry) helps in this case. When the
    service boots up, it registers itself in a registry. There is also a heartbeat
    between registry and service to ensure that the registry keeps only live services
    in its registry. If the heartbeat stops, the registry deregisters that instance
    of the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this quick starter, we are going to use Spring Cloud Netflix, which nicely
    integrates with Spring Boot. We need three components now:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Product service**: We have already written this'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service registry**: We are going to use Eureka, which is part of Spring Cloud'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service client**: Instead of calling our service directly through a browser,
    we will write a simple client to our service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Maven project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open your IDE (Eclipse Neon or other) and then create a new Maven project as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on Package Explorer and select New and Project..., as shown in
    the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/681949d8-038d-4675-9be2-8e5a65d86c5a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select Maven Project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9fe14540-94a8-4cd4-b7fe-156e2d293869.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next window of the wizard, choose Create a simple project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next dialog will ask for many parameters. Of these, the Group Id (what
    your project name is) and the Artifact Id (application or service name) are important.
    Select reasonable names, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1c3962d4-41d2-4a1f-9fda-56f35f23a737.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select Finish. You should see the following structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f7096253-de5c-4104-ac43-57ab9881fb77.png)'
  prefs: []
  type: TYPE_IMG
- en: If the JRE System Library [JavaSE-1.6] does not exist, or you have a later version,
    go to the project properties and edit it to select the version that your Eclipse
    is configured with. You do this by changing the Properties by right-clicking JRE
    System Library [JavaSE-1.6]. Here's a screenshot after adjusting the JRE System Library
    to 1.8.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43dfa29c-079f-4a17-b400-375158b121f4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, you have a clean slate. Open the Maven file `pom.xml` and add a dependency
    to the `spring-boot-starter-web`. This will tell Spring Boot to configure this
    project to get libraries for web development:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When you save this POM file, your IDE will build the workspace and download
    the dependent libraries, assuming your internet connection works (directly or
    through a proxy as configured before), and you are all set to develop the service.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Spring Boot application class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This class contains the main method where the execution starts. This main method
    will bootstrap the Spring Boot application, look at the configurations, and start
    the respective bundled containers such as Tomcat if executing web services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note the annotation called `@SpringBootApplication`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@SpringBootApplication` annotation is equivalent to using `@Configuration`,
    `@EnableAutoConfiguration`, and `@ComponentScan`, which do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Configuration`: This is a core Spring annotation. It tells Spring that this
    class is a source of the `Bean` definitions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@EnableAutoConfiguration`: This annotation tells Spring Boot to guess how
    you will want to configure Spring, based on the JAR dependencies that you have
    added. We have added the starter web and hence the application will be considered
    to be a Spring MVC web application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ComponentScan`: This annotation tells Spring to scan for any components,
    for example, the `RestController` that we are going to write. Note the scan happens
    in current and child packages. Hence, the class having this component scan should
    be at the top of the package hierarchy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing service and domain objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The annotations in Spring Boot make it easy to extract parameters and path variables
    and execute the service. For now, let's mock the response instead of getting the
    data from the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a simple Java entity called the `Product` class. For now, it is a simple **Plain
    Old Java Object** (**POJO**) class with three fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the getter and setter methods and a constructor that accepts the product
    ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, add an empty constructor that will be used by the service client, as
    we will see later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, write the `ProductService` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e48d02a3-1d11-4c87-b0f6-933b6155d8a2.png)'
  prefs: []
  type: TYPE_IMG
- en: Running the service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many ways to run the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on the project and select Run As | Maven build and configure the
    Run Configurations to execute the `spring-boot:run` target as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/517a372f-2512-46ef-8db3-44f2e63bac93.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On clicking Run, if the internet connection and configuration are fine, you
    will see the following console output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the stages of the Maven execution:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the Maven task compiles all the Java files. We have three simple Java
    classes as of now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step runs it as an application, where a Tomcat instance starts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note the mapping of the URLs `/product/` and `/productIds` to the `Bean` methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tomcat listens on port `8080` for service requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also run the service by just right-clicking the class that has the main
    method (`ProductSpringApp`) in Package Explorer and then selecting Run As | Java
    Application.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the service on the browser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open a browser and hit the following URL: `http://localhost:8080/product/1`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should get back the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, try the other service (URL—`http://localhost:8080/productIds`). What response
    do you get? An error, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Can you guess why? It is because the service definition that you wrote had
    a method expecting a request parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: So, the URL is expecting an `id` and as you did not supply it, it gives an error.
  prefs: []
  type: TYPE_NORMAL
- en: Give the parameter and try  `http://localhost:8080/productIds?id=5` again.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will now get back a correct response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Creating a deployable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are not going to run our service on Eclipse. We would like to deploy it
    on a server. There are two options for doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a WAR and deploy it in Tomcat or any other web container. This is the
    traditional method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a JAR with the runtime (Tomcat) included so that you just need Java to
    execute the service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In cloud application development, the second option, also called fat JAR or
    uber JAR, is becoming popular for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The deployable is self-contained with all the dependencies it needs. This reduces
    the chances of environment mismatch as the deployable unit is deployed to Dev,
    Test, UAT, and Production. If it works in development, there is a good chance
    it will work across all the other environments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The host, server, or container where the service is deployed need not have a
    preinstalled application server or servlet engine. Just a basic JRE is good enough.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at the steps to create a JAR file and run it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the following dependencies of the POM file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, run it by right-clicking the project in the explorer and choosing Run As
    | Maven Install.
  prefs: []
  type: TYPE_NORMAL
- en: You will see `product-0.0.1-SNAPSHOT.jar` in the target directory of the project
    folder structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the `product` folder so that you see the target directory in the
    command line and then run the JAR through a Java command, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43947a81-a87d-47cb-832f-a0a4ecb0893c.png)'
  prefs: []
  type: TYPE_IMG
- en: You will see Tomcat listening to the port at the end of the startup. Test it
    through the browser again. Milestone achieved.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling cloud-native behaviors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have just developed a basic service with two APIs that respond to requests.
    Let''s add a few capabilities that will enable to it to be a good cloud citizen.
    We will discuss the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Externalizing configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instrumentation—health and metrics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service registration and discovery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Externalizing configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configuration can be any property that is likely to differ between environments
    or production deployments. Typical examples are queue and topic names, ports,
    URLs, connection and pool properties, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: A deployable should not have configuration in it. A configuration should be
    injected from outside. This makes the deployable unit immutable as it goes through
    the various stages of the life cycle, such as Dev, QA, and UAT.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume we have to run our `product` service in different environments,
    where the URL differentiates the environment. Therefore, the small change we make
    in the request mapping is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can inject this variable in various ways. Once injected, the value is not
    expected to change for the life of the deployment. The simplest is to pass it
    in the command-line argument. Bring up the Run Configurations dialog and in the
    Arguments, add the command-line parameter `-env=dev/` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0613d40-8b94-4e8b-8f03-81ba4ddbd6cc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, Run the configuration. During startup, you will find the value substituted
    in the log statement as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The configuration can also be provided through configuration files, database,
    operating system environment properties, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Spring applications popularly use `application.properties` to store a few properties
    such as port numbers. Recently, YAML, which is a superset of JSON, is becoming
    more popular due to the hierarchical definition of the properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `application.yml` file in the `/product/src/main/resources` folder
    of the application and put in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This tells the `product` service to run at port `8081` instead of the default
    `8080`. This concept is further extended to profiles. So, it is possible to load
    different profiles by loading the configuration specific to the profile.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud Config as a project handles this well. It uses a `bootstrap.yml`
    file to get the application started up with a name and details of the source to
    further load the configuration. Hence, `bootstrap.yml` contains the application
    name and config server details, and then loads the respective profile configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `bootstrap.yml` file in the `resources` folder of the application
    and put in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We will come back to these files when we discuss service registration later.
  prefs: []
  type: TYPE_NORMAL
- en: Metering your services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instrumentation is important for cloud applications. Your service should expose
    health check and metrics so that it can be monitored better. Spring Boot allows
    for easier instrumentation through the `actuator` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the following in your POM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Run the service. During startup, you will see a number of mappings being created.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access these URLs (such as `http://localhost:8080/env`) directly and
    see the information displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The metrics are especially interesting (`http://localhost:8080/metrics`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The information includes the counters and gauges which store the number of times
    the service was accessed and the response times.
  prefs: []
  type: TYPE_NORMAL
- en: Running a service registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consul and Eureka are two popular dynamic service registries. There are subtle
    conceptual differences between them with respect to the method of heartbeats and
    agent-based operations, but the fundamental concept of registry is similar. The
    selection of the registry will be driven by the needs and the decisions of the
    enterprise. For our example, let's continue with Spring Boot and the Spring Cloud
    ecosystem and use Eureka for this example. Spring Cloud includes Spring Cloud
    Netflix, which has support for the Eureka registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to get a service registry running:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Maven project with `artifactId` as `eureka-server`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the POM file and add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parent as `spring-boot-starter-parent`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dependency to `eureka-server` as ``spring-cloud-starter-eureka-server``
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `dependencyManagement` to `spring-cloud-netflix`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/432ff7ef-5eb6-4cc5-9810-9280b967d0e7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create an application class similar to the one we created for the `product`
    project. Note the annotations. The annotation `@EnableEurekaServer` starts Eureka
    as a service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f1c9c5e9-be4a-4332-8242-c5a24e496291.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create an `application.yml` file in the `/product/src/main/resources` folder
    of the application and put in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `bootstrap.yml` file in the `resources` folder of the application
    and put in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Build the `eureka-server` Maven project (as we did for `product`) and then run
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Apart from a few connectivity errors (more on this later), you should see a
    Tomcat started message as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/aa53f30d-18e5-46f3-b83d-342370af2aec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the startup is completed, access the Eureka server at `localhost:8761`
    and check whether you get the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be32fc66-1a70-47a3-bad5-8d633506d118.png)'
  prefs: []
  type: TYPE_IMG
- en: Look at the circled section in the preceding screenshot. The instance currently
    registered with Eureka is `EUREKA` itself. We can correct this later. Now, let's
    focus on registering our `product` service with this Eureka service registry.
  prefs: []
  type: TYPE_NORMAL
- en: Registering a product service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `product` service boots up and listens on port `8081` for `product` service
    requests. We will now add the necessary instructions so that the service instance
    registers itself with the Eureka registry. Thanks to Spring Boot, we only have
    to do a few configurations and annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `dependencyManagement` section with dependency on `spring-cloud-netflix`
    and the dependency in the existing dependencies section to `spring-cloud-starter-eureka`
    to the `product` service POM as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/582a3747-c882-43dd-a428-9c5e34411f9b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `product` service keeps renewing its lease every specific interval. Reduce
    it to 5 seconds, by defining an entry explicitly in the `application.yml` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Include the annotation `@EnableDiscoveryClient` in the startup application
    class of the `product` project, in other words, `ProductSpringApp`. The `@EnableDiscoveryClient`
    annotation activates the Netflix Eureka `DiscoveryClient` implementation as that
    is the one we have defined in the POM file. There are other implementations for
    other service registries, such as HashiCorp Consul or Apache Zookeeper:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/397e1c42-3d6c-424c-9012-305e71f783ae.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, start the `product` service as before:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8e4e43cc-a802-441d-b9ba-0f169af84c0c.png)'
  prefs: []
  type: TYPE_IMG
- en: At the end of the initialization of the `product` service, you will see log
    statements that register the service with the Eureka server.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check whether the `product` service has registered, refresh the Eureka server
    page that you just accessed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c653d48-c5d6-4702-83bf-e03c58e5131b.png)'
  prefs: []
  type: TYPE_IMG
- en: Also keep a tab on the Eureka log. You will find the lease renewal log statements
    of the `product` service.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a product client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have created a dynamic product registry and even registered our service.
    Now, let's use this lookup to access the `product` service.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the Netflix Ribbon project, which provides a load balancer as well
    as having address lookup from the service registry. Spring Cloud makes it easier
    to configure and use this.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, let''s run the client within the same project as the service itself.
    The client will make an HTTP call to the service after looking up the product
    definition in Eureka. All this will be done by the Ribbon library, and we will
    just be using it as an endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a dependency to the Maven POM of the `product` project as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a120da92-e357-4c87-a464-4497467711cd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a `ProductClient` class, which simply listens on `/client` and then
    forwards the request after doing a lookup to the actual `product` service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a9340beb-00a1-47e4-b71f-2fd7ebcb4681.png)'
  prefs: []
  type: TYPE_IMG
- en: The URL construction `http://PRODUCT/` will be translated at runtime by Ribbon
    after doing a lookup. We are nowhere giving an IP address of the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `restTemplate` is injected here through auto-wiring. However, it needs
    to be initialized in the latest Spring versions. Hence, declare it as follows
    in the main application class, which also acts as a configuration class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/da08bf22-4652-47b9-bdc4-29a5a359104e.png)'
  prefs: []
  type: TYPE_IMG
- en: The `@LoadBalanced` annotation tells Spring to use the Ribbon load balancer
    (as Ribbon is in the classpath due to Maven).
  prefs: []
  type: TYPE_NORMAL
- en: Seeing the lookup in action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we are all set to run the product client. To recap, at this stage, we
    have a Eureka server project and a `product` project with the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6bb7836-fac8-4b95-a37b-c562d0d4fd4c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a few minutes to review what we did:'
  prefs: []
  type: TYPE_NORMAL
- en: We created a Maven project and defined the starters and dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We created the YML files for bootstrapping and application properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We created the `ProductSpringApp` class containing the main method that is the
    starting point of the applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the `product` project, we had the following classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Product`: The domain or entity which we will enhance later'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProductService`: The microservice responsible for implementing the services
    and APIs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProductClient`: The client to test out the service lookup'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `EurekaApplication` class (or run a Maven build on the `eureka-server`
    project). Observe the last few lines in the logs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9624f0d6-6e69-49df-9d35-0988accb12c2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the `ProductSpringApp` class (or run a Maven build on the `product` project).
    Note the last few lines in the the log:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/57e4b508-31d3-4563-985e-2fa5b451d62e.png)'
  prefs: []
  type: TYPE_IMG
- en: Access the `product` service directly at: `http://localhost:8081/dev/product/4`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, access the client URL, `http://localhost:8081/client/4` , which does a
    lookup of the `product` service from the service registry and directs it to the
    respective `product` service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You may see an internal server error (`No instances available for PRODUCT`).
    This can happen while the heartbeat completes and the addresses are re-picked
    by the Ribbon load balancer. Wait a few seconds for the registry to update and then try
    again.
  prefs: []
  type: TYPE_NORMAL
- en: 'A lot has happened under the hood in getting this response:'
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP request to get `/client/4` was handled by the `getProduct` method in
    the `ProductClient` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It did a lookup of the service from the Eureka registry. This is where we find
    log statements as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: After it did the lookup, it forwarded the request to the actual `ProductService`
    through the Ribbon load balancer library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This was just a simple mechanism of a client invoking services through a dynamic
    lookup. In later chapters, we will add functionality to make it resilient and
    functional in terms of getting data from the database.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's review the key concepts of the cloud applications that we have discussed
    so far. We made our application **lightweight** by making it run on a servlet
    engine and start in less than 15 seconds. Our application is **self-contained**,
    as the fat JAR has all libraries to run our service. We just need a JVM to run
    this JAR file. It has **externalized configuration** (to some extent) by injecting
    environment from the command line and properties from `application.yml` and `bootstrap.yml`.
    We take a deeper look at the next stages of externalization in [Chapter 7](23d9bfc6-4a12-4ead-9389-7d11ac4cb2ac.xhtml),
    *Cloud-Native Application Runtime*. The Spring actuator helped capturing all metrics
    and made their URL available for consumption, thus enabling **instrumentation**.
    The **location abstraction** was implemented by Eureka.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapters, we will enhance this service by adding to it a data tier
    and resiliency, and adding cache behavior and other enhancements that we skipped
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
