- en: Stability Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stability is one of the cornerstones of software engineering. No matter what,
    you must expect the worst from your environment and your users and be prepared
    for it. Your Angular applications should be able to operate in a degraded mode
    when your backend is burning and smoothly recover when it comes back online.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about stability patterns and anti-patterns,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Timeouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circuit breaker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Factory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memento
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The prototype and reusable pool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timeouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we experimented with API services with the intent
    of consuming APIs of any type of content that were created by our hypothetical
    backend. If I had to share a one-liner about what I learned during my online adventures,
    it would be *don't trust anybody...especially not yourself*. What I mean by that
    is that you can never trust an API to work as expected, even if it is your own
    API. You should always expect everything that can go wrong to, well, go wrong.
    One of the less harmful things that can happen when trying to communicate with
    your backend is that it won't respond. While this one-way communication is harmless
    for your Angular applications, it is most frustrating for your users. In this
    recipe, we will learn how to implement timeouts in our external call and how to
    react to unresponsive APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, there is a very simple way to prevent our user from getting frustrated
    about unresponsive APIs: timeouts. A timeout is a simple defense mechanism that
    allows your application to wait a fixed amount of time and not a millisecond more.
    Let''s create a new project to test it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a new project and a service called `API`. At first glance,
    there is not much to look at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need to add the `HttpClient` component in`app.module.ts` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we want to inject the `HttpClient` component into our API service client
    in order to have access to its methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We will add a new method in our `APIService` that simply makes an `http.get`
    to the GitHub repository that contains the code for this book( [https://github.com/MathieuNls/Angular-Design-Patterns-and-Best-Practices](https://github.com/MathieuNls/Angular-Design-Patterns-and-Best-Practices)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This is followed by an injection of `ApiService` and a call to the new `getURL`
    method in the `AppComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we were to execute this, we would have a gracious HTTP response, and
    the HTML of the web page would be printed out in the console. The problem, however,
    is that we have no countermeasure in place in the case that [github.com](http://www.github.com)
    is down and does not respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this version of the `getURL` function, we must first declare a timeout variable
    that will contain a NodeJS timeout. Then, instead of performing a regular `HTTP.get`,
    we will subscribe to the response. Finally, after the subscription to the result,
    we assign the timeout variable with the `setTimeout` function. We use this function
    to unsubscribe from the response after 1,000 ms. Consequently, we only wait one
    second for the `http` reply. If the reply does not arrive within that time, we
    automatically unsubscribe and allow our application to continue. Of course, our
    users will have to be warned in some way that the operation was unsuccessful.
  prefs: []
  type: TYPE_NORMAL
- en: Circuit breaker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The timeout pattern we implemented in the previous section is efficient at protecting
    the patience of our users and, ultimately, our Angular application. However, in
    the case that the API is not responding because something went wrong on the server
    side, let's say 80% of your server is down and the remaining 20% is trying to
    manage the load, your clients will most likely repeatedly retry the action that
    timed out. Consequently, this puts even more stress on our dying backend infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: A circuit is an automatic device for stopping the flow of the current in an
    electric circuit as a safety measure. Circuit breakers are used to detect failures
    and encapsulate the logic of preventing a failure from reoccurring constantly
    (during maintenance, temporary external system failure, or unexpected system difficulties).
  prefs: []
  type: TYPE_NORMAL
- en: 'Concretely, within the framework of an Angular app, a circuit breaker will
    prevent the client from performing API requests when there are too many failures.
    After a given amount of time, the circuit will allow some of the queries to go
    through and consume the API. If these queries return without any problems, then
    the circuit will close itself and allow all the requests to go through:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c2200dc4-5325-466a-837a-2c4a731d5d4e.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, we can see how the circuit breaker operates. All requests
    go through the circuit breaker, and if the supplier answers the requests in time,
    the circuit stays closed. When problems start to occur, the circuit breaker notices,
    and if enough requests timeout, then the circuit opens and prevents requests from
    going through.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, after a given amount of time, the circuit breaker tries to resend
    requests to the supplier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ba406e26-efc0-4531-ab10-e3aafad6bade.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From an implementation point of view, we will need the `ApiStatus` and `Call`
    classes, which are responsible for keeping track of the call we make to diverse
    APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `APIStatus` contains the statistics for the on root api. We take into account
    that we might use several APIs in our application. Each API has to be linked to
    its own circuit breaker. First, we have the `lastFail` variable, which contains
    the date at which the last call to this API failed. Then, we have a `calls` array
    that contains all the calls made to a given API. In addition to the constructor
    that defines the URL property, we have the `failPercentage` function. This function
    is responsible for computing the percentage of calls that failed within the `timeWindows`
    time. To do this, we iterate over all the calls in a reverse chronological order
    until we reach `Date.now()` – `timeWindow` or the end of the `calls` array. Within
    the `while` loop, we increment two number variables called `success and fail`
    with regard to the status of the current call. At the end, we return the percentage
    of failed calls. This percentage will be used to determine the status of the circuit
    breaker.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Call` class is rather simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It only contains two properties: time and status. We are now ready to implement
    an API client for our *Angular* app that implements a circuit breaker. First,
    we have to create the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have to add the property for `ApiwithBreakerService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: These properties will allow us to implement the circuit breaker pattern. First,
    we have a map of `string`, an `ApiStatus` that is used to store the API status
    of many APIs. Then, we have `failPercentage`, which defines how many calls can
    fail, as a percentage, before we open the circuit. The `timeWindow` variable defines
    the amount of time that is used to compute`failPercentage`. Here, we have a maximum
    of 20% of calls that can fail within a 24-hour window before we open this circuit
    and prevent other calls from being made. Finally, we have `timeToRetry`, which
    states how long we have to wait before trying to reclose the circuit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the modified `getURL` function from the timeout section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We kept the same core functionalities from the previous section with the timeout,
    but we embedded it in an `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `if` statement checks if the circuit is closed or if we are ready to retry
    on an open circuit.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also added calls to the `addCall` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `addCall` function adds a new call to an `ApiStatus` that's stored inside
    the `apis` map. It also updates the `lastFail` properties of the `ApiStatus` instance
    if the call was unsuccessful.
  prefs: []
  type: TYPE_NORMAL
- en: 'What remains are the `readyToRetry` and `isClosed` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `readyToRetry` function, we simply check that the latest fail is older
    than the time it is now minus`timeToRetry`. In the `isClosed` function, we check
    if the percentage of failed calls during the time window is greater than the maximum
    allowed. Here is the complete implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have two helper functions that do not directly participate in the
    implementation of the circuit patterns, only extracting the root URL of a call
    in order to compute a shared status by root APIs. Thanks to these helper functions,
    we can have [http://someapi.com/users](http://someapi.com/users) and [http://someapi.com/sales](http://someapi.com/sales)
    share the same status while [http://anotherapi.com/someCall](http://anotherapi.com/someCall)
    has its own separated `ApiStatus`.
  prefs: []
  type: TYPE_NORMAL
- en: The timeout and the circuit breaker patterns work in parallel in order to reduce
    self-denial. Self-denial is the art of dooming your backend servers yourself.
    This tends to happen when you have an application behaving improperly and making
    thousands of calls per second to your backend architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s assume that we have a `User` class with two private variables: `lastName:string`
    and `firstName:string`. In addition, this simple class proposes that the `hello`
    method prints `"Hi I am", this.firstName, this.lastName`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, consider that we receive users through a JSON API. It will more than likely
    look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'With the following snippet, we can create a `User`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Up until now, the TypeScript compiler hasn''t complained, and it executes smoothly.
    It works because the parse method returns `any` (for example, the TypeScript equivalent
    of the Java object). Sure enough, we can convert the `any into User`. However,
    `userFromJSONAPI.hello();` will yield the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Why? Well, the left-hand side of assignation is defined as `User`, sure, but
    it'll be erased when we transpile it to JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'The type-safe TypeScript way to do it would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Interestingly enough, the `typeof` function won't help you either. In both cases,
    it'll display `Object` instead of `User`, as the very concept of `User` doesn't
    exist in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: While the direct type-safe approach works, it isn't very expansible nor reusable.
    Indeed, the `map` callback method would have to be duplicated everywhere you receive
    a JSON `user`. The most convenient way to do that is through the `Factory` pattern.
    A `Factory` is used for objects without exposing the instantiation logic to the
    client.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to have a `factory` to create a user, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a static method named `buildUser` that receives a JSON object
    and takes all the required value inside the JSON object to invoke, with the right
    attributes, a hypothetical `User` constructor. The method is static, like all
    the methods of such a factory. Indeed, we don't need to save any states or instance-bound
    variables in a factory; we only encapsulate away the gruesome creation of users.
    Note that your factory will likely be shared for the rest of your POTOs.
  prefs: []
  type: TYPE_NORMAL
- en: Memento
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The memento pattern is a really  useful pattern in the context of Angular. In
    Angular-powered applications, we use and overuse two ways binding between domain
    models such as `User` or `Movie`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider two components, one named `Dashboard` and the other one named
    `EditMovie`. On the `Dashboard` component, you have a list of movies displayed
    in the context of our IMDb-like application. The view of such a dashboard could
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This simple view owns a `ngFor` directive that iterates over the list of movies
    contained in a model. Then, for each movie, it displays two `p` elements containing
    the title and the release year, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the `EditMovie` components access one of the movies on the `model.movies`
    array and allow the user to edit it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to the two ways binding used here, the modifications performed on the
    movie title and year will directly impact the dashboard. As you can see, we have
    a `cancel` button here. While the user might expect that the modification is synchronized
    in `real time`*,* he also expects that the cancel button/link cancels the modifications
    that have been done on the movie.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is where the Memento pattern comes into play. This pattern allows performing
    undo operations on objects. It can be implemented in many ways, but the simplest
    one is to go with cloning. Using cloning, we can store one version of our object,
    at a given moment, and, if need be, get back to it. Let''s enhance our `Movie`
    object from the `prototype` pattern as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this new version, we added the `restore(movie:Movie)` method, which takes
    a `Movie` as an argument and affects the local attributes to the values of the
    received movie.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in practice, the constructor of our `EditMovie` component could look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: What's interesting is that you are not limited to one memento over time, as
    you can have as many as you want.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw patterns that aim to improve the stability of our Angular
    applications. It is worth noting that most of the aim, in fact, is for protecting
    our backend infrastructures from overheating. Indeed, the timeout and the circuit
    breaker, when combined, allow us to give our backends a break while they come
    back online. In addition, the memento and the reusable pool aim to keep the client-side
    information we could have re-requested from the backend if we were not to store
    them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover performance patterns and best practices to
    improve the speed at which our application operates.
  prefs: []
  type: TYPE_NORMAL
