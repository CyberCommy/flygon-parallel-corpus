- en: 4\. Kubernetes Deep Dive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up a local Kubernetes cluster on your computer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access a Kubernetes cluster using the dashboard and the Terminal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify the fundamental Kubernetes resources, the building blocks of Kubernetes
    applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install complex applications on a Kubernetes cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will explain the basics of the Kubernetes architecture,
    the methods of accessing the Kubernetes API, and fundamental Kubernetes resources.
    In addition to that, we will deploy a real-life application into Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Kubernetes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, we studied serverless frameworks, created serverless
    applications using these frameworks, and deployed these applications to the major
    cloud providers.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have seen in the previous chapters, Kubernetes and serverless architectures
    started to gain traction at the same time in the industry. Kubernetes got a high
    level of adoption and became the de facto container management system with its
    design principles based on scalability, high availability, and portability. For
    serverless applications, Kubernetes provides two essential benefits: **removal
    of vendor lock-in** and **reuse of services**.'
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes creates an infrastructure layer of abstraction to remove vendor lock-in.
    Vendor lock-in is a situation where transition from one service provider to another
    is very difficult or even infeasible. In the previous chapter, we studied how
    serverless frameworks make it easy to develop cloud-agnostic serverless applications.
    Let's assume you are running your serverless framework on an **AWS EC2** instance
    and want to move to **Google Cloud**. Although your serverless framework creates
    a layer between the cloud provider and serverless applications, you are still
    deeply attached to the cloud provider for the infrastructure. Kubernetes breaks
    this connection by creating an abstraction between the infrastructure and the
    cloud provider. In other words, serverless frameworks running on Kubernetes are
    unaware of the underlying infrastructure. If your serverless framework runs on
    Kubernetes in AWS, it is expected to run on **Google Cloud Platform** (**GCP**)
    or Azure.
  prefs: []
  type: TYPE_NORMAL
- en: As the defacto container management system, Kubernetes manages most microservices
    applications in the cloud and in on-premise systems. Let's assume you have already
    converted your big monolith application to cloud-native microservices and you're
    running them on Kubernetes. And now you've started developing serverless applications
    or turning some of your microservices to serverless *nanoservices*. At this stage,
    your serverless applications will need to access the data and other services.
    If you can run your serverless applications in your Kubernetes clusters, you will
    have the chance to reuse the services and be close to your data. Besides, it will
    be easier to manage and operate both microservices and serverless applications.
  prefs: []
  type: TYPE_NORMAL
- en: As a solution to vendor lock-in, and for potential reuse of data and services,
    it is crucial to learn how to run serverless architectures on Kubernetes. In this
    chapter, a Kubernetes recap is presented to introduce the origin and design of
    Kubernetes. Following that, we will install a local Kubernetes cluster, and you
    will be able to access the cluster by using a dashboard or a client tool such
    as `kubectl`. In addition to that, we will discuss the building blocks of Kubernetes
    applications, and finally, we'll deploy a real-life application to the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes Design and Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes, which is also known as **k8s**, is a platform for managing containers.
    It is a complex system focused on the complete life cycle of containers, including
    configuration, installation, health checking, troubleshooting, and scaling. With
    Kubernetes, it is possible to run microservices in a scalable, flexible, and reliable
    way. Let's assume you are a DevOps engineer at a fin-tech company, focusing on
    online banking for your customers.
  prefs: []
  type: TYPE_NORMAL
- en: You can configure and install the complete backend and frontend of an online
    bank application to Kubernetes in a secure and cloud-native way. With the Kubernetes
    controllers, you can manually or automatically scale your services up and down
    to match customer demand. Also, you can check the logs, perform health checks
    on each service, and even SSH into the containers of your applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will focus on how Kubernetes is designed and how its components
    work in harmony.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kubernetes clusters consist of one or more servers, and each server is assigned
    with a set of logical roles. There are two essential roles assigned to the servers
    of a cluster: **master** and **node**. If the server is in the **master** role,
    **control plane** components of the Kubernetes run on these nodes. Control plane
    components are the primary set of services used to run the Kubernetes API, including
    REST operations, authentication, authorization, scheduling, and cloud operations.
    With the recent version of Kubernetes, four services are running as the control
    plane:'
  prefs: []
  type: TYPE_NORMAL
- en: '**etcd**: `etcd` is an open source key/value store, and it is the database
    of all Kubernetes resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kube-apiserver**: API server is the component that runs the Kubernetes REST
    API. It is the most critical component for interacting with other parts of the
    plane and client tools.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kube-scheduler**: A scheduler assigns workloads to nodes based on the workload
    requirements and node status.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kube-controller-manager**: `kube-controller-manager` is the control plane
    component used to manage core controllers of Kubernetes resources. *Controllers*
    are the primary life cycle managers of the Kubernetes resources. For each Kubernetes
    resource, there is one or more controller that works in the **observe**, **decide**,
    and **act** loop diagrammed in *Figure 4.1*. Controllers check the current status
    of the resources in the observe stage and then analyze and decide on the required
    actions to reach the desired state. In the act stage, they execute the actions
    and continue to observe the resources.![ Figure 4.1: Controller loop in Kubernetes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '](image/C12607_04_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.1: Controller loop in Kubernetes'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Servers with the **node** role are responsible for running the workload in
    Kubernetes. Therefore, there are two essential Kubernetes components required
    in every node:'
  prefs: []
  type: TYPE_NORMAL
- en: '**kubelet**: `kubelet` is the management gateway of the control plane in the
    nodes. `kubelet` communicates with the API server and implements actions needed
    on the nodes. For instance, when a new workload is assigned to a node, `kubelet`
    creates the container by interacting with the container runtime, such as Docker.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kube-proxy**: Containers run on the server nodes, but they interact with
    each other as they are running in a unified networking setup. `kube-proxy` makes
    it possible for containers to communicate, although they are running on different
    nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The control plane and the roles, such as master and node, are logical groupings
    of components. However, it is recommended to have a highly available control plane
    with multiple master role servers. Besides, servers with node roles are connected
    to the control plane to create a scalable and cloud-native environment. The relationship
    and interaction of the control plane and the master and node servers are presented
    in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2: The control plane and the master and node servers in a Kubernetes
    cluster'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_04_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.2: The control plane and the master and node servers in a Kubernetes
    cluster'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the following exercise, a Kubernetes cluster will be created locally, and
    Kubernetes components will be checked. Kubernetes clusters are sets of servers
    with master or worker nodes. On these nodes, both control plane components and
    user applications are running in a scalable and highly available way. With the
    help of local Kubernetes cluster tools, it is possible to create single-node clusters
    for development and testing. `minikube` is the officially supported and maintained
    local Kubernetes solution, and it will be used in the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You will use `minikube` in the following exercise as the official local Kubernetes
    solution, and it runs the Kubernetes components on hypervisors. Hence you must
    install a hypervisor such as **Virtualbox**, **Parallels**, **VMWareFusion**,
    **Hyperkit**, or **VMWare**. Refer to this link for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://kubernetes.io/docs/tasks/tools/install-minikube/#install-a-hypervisor](https://kubernetes.io/docs/tasks/tools/install-minikube/#install-a-hypervisor)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10: Starting a Local Kubernetes Cluster'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this exercise, we will install `minikube` and use it to start a one-node
    Kubernetes cluster. When the cluster is up and running, it will be possible to
    check the master and node components.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the exercise, we need to ensure the following steps are executed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `minikube` to the local system by running these commands in your Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: These commands download the binary file of `minikube`, make it executable, and
    move it into the `bin` folder for Terminal access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the `minikube` cluster by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This command downloads the images and creates a single-node virtual machine.
    Following that, it configures the machine and waits until the Kubernetes control
    plane is up and running, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3: Starting a new cluster in minikube'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_04_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.3: Starting a new cluster in minikube'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Check the status of Kubernetes cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`minikube status`'
  prefs: []
  type: TYPE_NORMAL
- en: 'As the output in the following figure indicates, the host system, `kubelet`,
    and `apiserver` are running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4: Kubernetes cluster status'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_04_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.4: Kubernetes cluster status'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Connect to the virtual machine of `minikube` by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the output shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5: minikube virtual machine'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_04_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.5: minikube virtual machine'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Check for the four control-plane components with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This command lists the processes and captures the mentioned command names.
    There are total of four lines corresponding to each control plane component and
    its process IDs, as depicted in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6: Control plane components'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_04_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.6: Control plane components'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Check for the node components with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This command lists two components running in the node role, with their process
    IDs, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7: Node components'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_04_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.7: Node components'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Exit the terminal started in *Step 4* with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the output shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8: Exiting the minikube virtual machine'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_04_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.8: Exiting the minikube virtual machine'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this exercise, we installed a single-node Kubernetes cluster using `minikube`.
    In the next section, we will discuss using the official client tool of Kubernetes
    to connect to and operate the cluster from the previous exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kubernetes Client Tool: kubectl'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Kubernetes control plane runs a REST API server for accessing Kubernetes
    resources and undertaking operational activities. Kubernetes comes with an open
    source official command-line tool named `kubectl` in order to consume the REST
    API. It is installed on the local system and configured to connect remote clusters
    securely and reliably. `kubectl` is the primary tool for the complete life cycle
    of applications running in Kubernetes. For instance, say you deploy a **WordPress**
    blog in your cluster. First, you start creating your database passwords as secrets
    using `kubectl`. Following that, you deploy your blog application and check its
    status. In addition to that, you may trace the logs of your applications or even
    SSH into the containers for further analysis. Therefore, it is a powerful CLI
    tool that can handle both basic **create, read, update, and delete (CRUD)** actions
    and troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to application management, `kubectl` is also a powerful tool for
    cluster operations. It is possible to check the Kubernetes API status or the status
    of the servers in the cluster using `kubectl`. Let's assume you need to restart
    a server in your cluster and you need to move the workload to other nodes. Using
    `kubectl` commands, you can mark the node as *unschedulable* and let the Kubernetes
    scheduler move the workload to other nodes. When you complete the maintenance,
    you can mark the node back as **Ready** and let a Kubernetes scheduler assign
    workloads.
  prefs: []
  type: TYPE_NORMAL
- en: '`kubectl` is a vital command-line tool for daily Kubernetes operations. Therefore,
    learning the basics and getting hands-on experience with `kubectl` is crucial.
    In the following exercise, you will install and configure `kubectl` to connect
    to a local Kubernetes cluster.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11: Accessing Kubernetes Clusters Using the Client Tool: kubectl'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this exercise, we aim to access the Kubernetes API using `kubectl` and explore
    its capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the exercise, we need to ensure the following steps are executed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the `kubectl` executable by running these commands in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: These commands download the binary of `kubectl`, make it executable, and move
    it into the `bin` folder for Terminal access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure `kubectl` to connect to the `minikube` cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This command configures `kubectl` to use the `minikube` context, which is the
    set of credentials used to connect to the `kubectl` cluster, as shown in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9: kubectl context setting'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_04_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.9: kubectl context setting'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Check the available nodes with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This command lists all the nodes connected to the cluster. As a single-node
    cluster, there is only one node, named `minikube`, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10: kubectl get nodes'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_04_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.10: kubectl get nodes'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Get more information about the `minikube` node with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`kubectl describe node minikube`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This command lists all the information about the node, starting with its metadata,
    such as `Roles`, `Labels`, and `Annotations`. The role of this node is specified
    as `master` in the **Roles** section, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11: Node metadata'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_04_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.11: Node metadata'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Following the metadata, `Conditions` lists the health status of the node. It
    is possible to check available memory, disk, and process IDs in tabular form,
    as shown in the following figure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12: Node conditions'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_04_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.12: Node conditions'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Then, available and allocatable capacity and system information are listed,
    as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.13: Node capacity information'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_04_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.13: Node capacity information'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Finally, the running workload on the node and allocated resources are listed,
    as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.14: Node workload information'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_04_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.14: Node workload information'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Get the supported API resources with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the output shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.15: Output of kubectl api-resources'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_04_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.15: Output of kubectl api-resources'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This command lists all the resources supported by the Kubernetes cluster. The
    length of the list indicates the power and comprehensiveness of Kubernetes in
    the senseof application management. In this exercise, the official Kubernetes
    client tool was installed, configured, and explored. In the following section,
    the core building block resources from the resource list will be presented.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes Resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes comes with a rich set of **resources** to define and manage cloud-native
    applications as containers. In the Kubernetes API, every container, secret, configuration,
    or custom definition is defined as a **resource**. The control plane manages these
    resources while the node components try to achieve the *desired state* of the
    applications. The *desired state* could be running 10 instances of the application
    or mounting disk volumes to database applications. The control plane and node
    components work in harmony to make all resources in the cluster reach their *desired
    state*.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will study the fundamental Kubernetes resources used to
    run serverless applications.
  prefs: []
  type: TYPE_NORMAL
- en: Pod
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `pod` is the building block resource for computation in Kubernetes. A pod
    consists of containers scheduled to run into the same node as a single application.
    Containers in the same pod share the same resources, such as network and memory
    resources. In addition, the containers in the pod share life cycle events such
    as scaling up or down. A pod can be defined with an `ubuntu` image and the `echo`
    command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When the `echo` pod is created in Kubernetes API, the scheduler will assign
    it to an available node. Then the `kubelet` in the corresponding node will create
    a container and attach networking to it. Finally, the container will start to
    run the `echo` and `sleep` commands. Pods are the essential Kubernetes resource
    for creating applications, and Kubernetes uses them as building blocks for more
    complex resources. In the following resources, the pod will be encapsulated to
    create more complex cloud-native applications.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Deployments are the most commonly used Kubernetes resource to manage highly
    available applications. Deployments enhance pods by making it possible to scale
    up, scale down, or roll out new versions. The deployment definition looks similar
    to a pod with two important additions: **labels** and **replicas**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The deployment named `webserver` defines five `replicas` of the application
    running with the label `app:server`. In the `template` section, the application
    is defined with the exact same label and one `nginx` container. The deployment
    controller in the control plane ensures that five instances of this application
    are running inside the cluster. Let's assume you have three nodes, A, B, and C,
    with one, two, and two instances of webserver application running, respectively.
    If node C goes offline, the deployment controller will ensure that the two lost
    instances will be recreated in nodes A and B. Kubernetes ensures that scalable
    and highly available applications are running reliably as deployments. In the
    following section, Kubernetes resources for stateful applications such as databases
    will be presented.
  prefs: []
  type: TYPE_NORMAL
- en: StatefulSet
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kubernetes supports running both stateless ephemeral applications and stateful
    applications. In other words, it is possible to run database applications or disk-oriented
    applications in a scalable way inside your clusters. The `StatefulSet` definition
    is similar to deployment with volume-related additions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `mysql` `StatefulSet` state creates a MySQL database with 1 GB volume data.
    The volume is created by Kubernetes and attached to the container at `/var/lib/mysql`.
    With the `StatefulSet` controllers, it is possible to create applications that
    need disk access in a scalable and reliable way. In the following section, we'll
    discuss how to connect applications in a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Kubernetes, multiple applications run in the same cluster and connect to
    each other. Since each application has multiple pods running on different nodes,
    it is not straightforward to connect applications. In Kubernetes, `Service` is
    the resource used to define a set of pods, and you access them by using the name
    of the `Service`. Service resources are defined using the labels of the pods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `my-database` service, the pods with the label `app: mysql` are grouped.
    When the `3306` port of `my-database` address is called, Kubernetes networking
    will connect to the `3306` port of a pod with the label `app:mysql`. Service resources
    create an abstraction layer between applications and enable decoupling. Let''s
    assume you have a three-instance backend and a three-instance frontend in your
    application. Frontend pods can easily connect to backend instances using the `Service`
    resource without knowing where the backend instances are running. It creates abstraction
    and decoupling between the applications running in the cluster. In the following
    section, resources focusing on tasks and scheduled tasks will be presented.'
  prefs: []
  type: TYPE_NORMAL
- en: Job and CronJob
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Kubernetes resources such as `deployments` and `StatefulSets` focus on running
    applications and keeping them up and running. However, Kubernetes also provides
    `Job` and `CronJob` resources to run applications to completion. For instance,
    if your application needs to do one-time tasks, you can create a `Job` resource
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When the `echo` Job is created, Kubernetes will create a pod, schedule it, and
    run it. When the container terminates after the `echo` command, Kubernetes will
    not try to restart it or keep it running.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to one-time tasks, it is possible to run scheduled jobs using the
    `CronJob` resource, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: With the `hourly-echo` CronJob, an additional `schedule` parameter is provided.
    With the schedule of `"0 * * * *"`, Kubernetes will create a new Job instance
    of this CronJob and run it every hour. Jobs and CronJobs are Kubernetes-native
    ways of handling manual and automated tasks required for your applications. In
    the following exercise, Kubernetes resources will be explored using `kubectl`
    and a local Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12: Installing a Stateful MySQL Database and Connecting inside Kubernetes'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this exercise, we will install a MySQL database as `StatefulSet`, check its
    status, and connect to the database using a job for creating tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the exercise, we need to ensure the following steps are executed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `mysql.yaml` on your local computer with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`mysql.yaml` is available on GitHub at [https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/blob/master/Lesson04/Exercise12/mysql.yaml](https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/blob/master/Lesson04/Exercise12/mysql.yaml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Deploy the `StatefulSet` MySQL database with the following command in your
    Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This command submits the `mysql.yaml` file, which includes a `StatefulSet`
    called `mysql` and a 1 GB volume claim. The output will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.16: StatefulSet creation'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_04_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.16: StatefulSet creation'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Check the pods with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`kubectl get pods`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This command lists the running pods, and we expect to see the one instance
    of `mysql`, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.17: Pod listing'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_04_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.17: Pod listing'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If the pod status is `Pending`, wait a couple of minutes until it becomes `Running`
    before continuing to the next step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the persistent volumes with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This command lists the persistent volumes, and we expect to see the one-volume
    instance created for the `StatefulSet`, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.18: Persistent volume listing'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_04_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.18: Persistent volume listing'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Create the `service.yaml` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`service.yaml` is available on GitHub at [https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/blob/master/Lesson04/Exercise12/service.yaml](https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/blob/master/Lesson04/Exercise12/service.yaml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Deploy the `my-database` service with the following command in your Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`kubectl apply -f service.yaml`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This command submits the `Service` named `my-database` to group pods with the
    label `app:mysql`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.19: Service creation'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_04_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.19: Service creation'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Create the `create-table.yaml` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`create-table.yaml` is available on GitHub at [https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/blob/master/Lesson04/Exercise12/create-table.yaml](https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/blob/master/Lesson04/Exercise12/create-table.yaml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Deploy the job with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This command submits the Job named `create-table` and within a couple of minutes,
    the pod will be created to run the `CREATE TABLE` command, as shown in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.20: Job creation'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_04_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.20: Job creation'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Check for the pods with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`kubectl get pods`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This command lists the running pods, and we expect to see the one instance
    of `create-table`, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.21: Pod listing'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_04_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.21: Pod listing'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If the pod status is **Pending** or **Running**, wait a couple of minutes until
    it becomes **Completed** before continuing to the next step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to check the tables in the MySQL database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This command runs a temporary instance of the `mysql:5.7` image and runs the
    `mysql` command, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.22: Table listing'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_04_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.22: Table listing'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the MySQL database, a table with the name `messages` is available, as shown
    in the preceding output. It shows that `MySQL` `StatefulSet` is up and running
    the database successfully. In addition, the `create-table` Job has created a pod,
    connected to the database using the service, and created the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clean the resources by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the output shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.23: Cleanup'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_04_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.23: Cleanup'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the following activity, the database will be filled with the information
    retrieved by automated tasks in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You will need a Docker Hub account to push the images into the registry in the
    following activity. Docker Hub is a free service, and you can sign up to it at
    [https://hub.docker.com/signup](https://hub.docker.com/signup).
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 4: Collect Gold Prices in a MySQL Database in Kubernetes'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The aim of this activity to create a real-life serverless application that
    runs in a Kubernetes cluster using Kubernetes-native resources. The serverless
    function will get gold prices from the live market and will push the data to the
    database. The function will run with predefined intervals to keep a history and
    make statistical analyses. Gold prices can be retrieved from the *CurrencyLayer*
    API, which provides a free API for exchange rates. Once completed, you will have
    a CronJob running every minute:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In order to complete the following activity, you need to have a CurrencyLayer
    API access key. It is a free currency and exchange rate service, and you can sign
    up to it on the official website.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.24: Kubernetes Job for gold price'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_04_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.24: Kubernetes Job for gold price'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Finally, with each run of the Kubernetes Job, you will have a real-time gold
    price in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.25: Price data in the database'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/C12607_04_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.25: Price data in the database'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Execute the following steps to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an application to retrieve the gold price from *CurrencyLayer* and insert
    it into the MySQL database. It is possible to implement this function in Go with
    the following structure in a `main.go` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main` function, first you need to connect to the database, and then
    retrieve the price from *CurrencyLayer*. Then you need to create a SQL statement
    and execute on the database connection. The complete code for main.go can be found
    here: [https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/blob/master/Lesson04/Activity4/main.go](https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/blob/master/Lesson04/Activity4/main.go).'
  prefs: []
  type: TYPE_NORMAL
- en: Build the application as a Docker container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push the Docker container to the Docker registry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy the MySQL database into the Kubernetes cluster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy a Kubernetes service to expose the MySQL database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy a `CronJob` to run every minute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for a couple of minutes and check the instances of `CronJob`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect to the database and check for the entries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clean the database and automated tasks from Kubernetes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution of the activity can be found on page 403.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we first described the origins and characteristics of Kubernetes.
    Following that, we studied the Kubernetes design and components with the details
    of master and node components. Then, we installed a local single-node Kubernetes
    cluster and checked the Kubernetes components. Following the cluster setup, we
    studied the official Kubernetes client tool, `kubectl`, which is used to connect
    to a cluster. We also saw how `kubectl` is used to manage clusters and the life
    cycle of applications. Finally, we discussed the fundamental Kubernetes resources
    for serverless applications, including pods, deployments, and `StatefulSets`.
    In addition to that, we also studied how to connect applications in a cluster
    using services. Kubernetes resources for one-time and automated tasks were presented
    using `Jobs` and `CronJobs`. At the end of this chapter, we developed a real-time
    data collection function using Kubernetes-native resources.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be studying the features of Kubernetes clusters
    and using a popular cloud platform to deploy them.
  prefs: []
  type: TYPE_NORMAL
