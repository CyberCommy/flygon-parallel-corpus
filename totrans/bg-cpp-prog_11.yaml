- en: Chapter 11. Sound Effects, File I/O, and Finishing the Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。音效，文件I/O和完成游戏
- en: We are nearly there. This short chapter will demonstrate how we can easily manipulate
    files stored on the hard drive using the C++ standard library, and we will also
    add sound effects. Of course, we know how to add sound effects, but we will discuss
    exactly where in the code the calls to `play` will go. We will also tie up a few
    loose-ends to make the game complete.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们快要完成了。这一小节将演示如何使用C++标准库轻松操作存储在硬盘上的文件，我们还将添加音效。当然，我们知道如何添加音效，但我们将讨论在代码中`play`的调用应该放在哪里。我们还将解决一些问题，使游戏更完整。
- en: 'In this chapter we will learn the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: Saving and loading the high score
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存和加载最高分
- en: Adding sound effects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加音效
- en: Allow the player to level up
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许玩家升级
- en: Create never-ending multiple waves
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建无尽的多波
- en: Saving and loading the high-score
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存和加载最高分
- en: File I/O, or input/output, is a fairly technical subject. Fortunately for us,
    as it is such a common requirement in programming, there is a library that handles
    all the complexity for us. As with concatenating strings for our HUD, it is the
    **Standard Library** that provides the necessary functionality through `fstream`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 文件I/O，即输入/输出，是一个相当技术性的主题。幸运的是，由于它在编程中是一个如此常见的需求，有一个库可以处理所有复杂性。与我们为HUD连接字符串一样，**标准库**通过`fstream`提供了必要的功能。
- en: 'First, we include `fstream` in the same way we included `sstream`:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们以与包含`sstream`相同的方式包含`fstream`：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, add a new folder in the `ZombieArena/ZombieArena` folder called `gamedata`.
    Next, right-click in this folder and create a new file called `scores.txt`. It
    is in this file that we will save the player's high-score. You could open the
    file and add a score to it. If you do, make sure it is quite a low score so we
    can easily test whether beating that score results in the new score being added.
    Be sure to close the file once you are done with it or the game will not be able
    to access it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`ZombieArena/ZombieArena`文件夹中添加一个名为`gamedata`的新文件夹。接下来，在此文件夹中右键单击并创建一个名为`scores.txt`的新文件。在这个文件中，我们将保存玩家的最高分。您可以打开文件并向其中添加分数。如果您这样做，请确保它是一个相当低的分数，这样我们就可以很容易地测试是否击败该分数会导致新分数被添加。确保在完成后关闭文件，否则游戏将无法访问它。
- en: In the next code, we create an `ifstream` object called `InputFile` and send
    the folder and file we just created as a parameter to its constructor.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一段代码中，我们创建一个名为`InputFile`的`ifstream`对象，并将刚刚创建的文件夹和文件作为参数发送到它的构造函数。
- en: 'The `if(InputFile.is_open())` code checks that the file exists and is ready
    to read from. We then put the contents of the file into `hiScore` and close the
    file. Add the highlighted code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`if(InputFile.is_open())`代码检查文件是否存在并准备好从中读取。然后我们将文件的内容放入`hiScore`中，并关闭文件。添加突出显示的代码：'
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now we handle saving a potentially new high-score. Within the block that handles
    the player''s health being less than or equal to zero, we create an `ofstream`
    object called `outputFile`, write the value of `hiScore` to the text file, and
    then close the file:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们处理保存可能的新高分。在处理玩家生命值小于或等于零的代码块中，我们创建一个名为`outputFile`的`ofstream`对象，将`hiScore`的值写入文本文件，然后关闭文件：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can play the game and your high-score will be saved. Quit the game and notice
    that your high-score is still there if you play it again.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以玩游戏，您的最高分将被保存。退出游戏并注意，如果您再次玩游戏，您的最高分仍然存在。
- en: Let's make some noise.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们制造一些噪音。
- en: Preparing sound effects
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备音效
- en: In this section, we will create all the `SoundBuffer` and `Sound` objects that
    we need to add a range of sound effects to the game.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建所有我们需要为游戏添加一系列音效的`SoundBuffer`和`Sound`对象。
- en: 'Start by adding the required SFML includes:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先添加所需的SFML包括：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now go ahead and add the seven `SoundBuffer` and `Sound` objects which load
    and prepare the seven sound files that we prepared in [Chapter 6](ch06.html "Chapter 6. 
    Object-Oriented Programming, Classes, and SFML Views"): *Object-Oriented Programming,
    Classes, and SFML Views*:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在继续添加七个`SoundBuffer`和`Sound`对象，它们加载和准备了我们在[第6章](ch06.html "第6章。面向对象编程，类和SFML视图")中准备的七个音频文件：*面向对象编程，类和SFML视图*：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now the seven sound effects are ready to play. We just need to work out where
    in our code each of the calls to the `play` function will go.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在七种音效已经准备好播放。我们只需要弄清楚在我们的代码中每个`play`函数的调用将放在哪里。
- en: Leveling up
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 升级
- en: The next code we will add enables the player to level-up between waves. Because
    of the work we have already done that makes, this is straightforward to achieve.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们要添加的代码使玩家可以在波之间升级。由于我们已经做过的工作，这是很容易实现的。
- en: 'Add the highlighted code in the `LEVELING_UP` state where we handle player
    input:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LEVELING_UP`状态中添加突出显示的代码，我们处理玩家输入：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The player can now level-up each time a wave of zombies is cleared. We can't,
    however, increase the number of zombies or the size of the level yet.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家现在可以在清除一波僵尸时升级。但是，我们目前还不能增加僵尸的数量或级别的大小。
- en: In the next part of the `LEVELING_UP` state, right after the code we have just
    added, amend the code that runs when the state changes from `LEVELING_UP` to `PLAYING`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LEVELING_UP`状态的下一部分，在我们刚刚添加的代码之后，修改当状态从`LEVELING_UP`变为`PLAYING`时运行的代码。
- en: Here is the code in full. I have highlighted the lines that are either new or
    have been slightly amended.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是完整的代码。我已经突出显示了要么是新的要么已经稍作修改的行。
- en: 'Add or amend the highlighted code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 添加或修改突出显示的代码：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The previous code starts by incrementing the `wave` variable. Then the code
    is amended to make the number of zombies and size of the arena relative to the
    new value of `wave`. Finally, we add the call to `powerup.play()` to play the
    leveling up sound effect.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码首先递增`wave`变量。然后修改代码，使僵尸的数量和竞技场的大小与`wave`的新值相关。最后，我们添加了`powerup.play()`的调用，以播放升级音效。
- en: Restarting the game
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新开始游戏
- en: 'We already determine the size of the arena and the number of zombies by the
    value of the `wave` variable. We must also reset the ammo, gun, `wave`, and `score`
    to zero at the start of each new game. Find the following code in the event handling
    section of the game loop and add the highlighted code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now we can play the game, the player can get ever more powerful and the zombies
    will get ever more numerous within an arena of increasing size - until he dies
    then it all starts again.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Playing the rest of the sounds
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we will add the rest of the calls to the `play` function. We deal with each
    of them individually as locating exactly where they go is key to playing them
    at the right moment.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Adding sound effects while the player is reloading
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add the highlighted code in three places to play the appropriate `reload` or
    `reloadFailed` sound when the player presses the ***R*** key to attempt to reload
    their gun:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Make a shooting sound
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add the highlighted call to `shoot.play()` near the end of the code that handles
    the player clicking the left mouse button:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Play a sound when the player is hit
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this next code, we wrap the call to `hit.play` in a test to see whether the
    `player.hit` function returns `true`. Remember that the `player.hit` function
    tests to see whether a hit has been recorded in the previous 100 milliseconds.
    This will have the effect of playing a fast, repeating, thudding sound, but not
    so fast that the sound blurs into one noise.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the call to `hit.play`, as highlighted here:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Play a sound when getting a pickup
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the player picks up a health pickup, we will play the regular pickup sound,
    but when the player gets an ammo pickup we play the reload sound effect.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the two calls to play sounds as highlighted here, within the appropriate
    collision detection code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Make a splat sound when a zombie is shot
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a call to `splat.play` at the end of the section of code that detects a
    bullet colliding with a zombie:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can now play the completed game and watch the number of zombies and the
    arena increase with each wave. Choose your level-ups carefully:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '![Make a splat sound when a zombie is shot](img/image_11_001.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
- en: Congratulations!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: FAQ
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some questions that might be on your mind:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Q) Despite using classes, I am finding that the code is getting really long
    and unmanageable, again.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: A) One of the biggest issues is the structure of our code. As we learn more
    C++, we will also learn ways to make the code more manageable and generally less
    lengthy.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Q) The sound effects seem a bit flat and unrealistic. How can they be improved?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: A) One way to significantly improve the feeling the player gets from sound is
    to make the sound directional, as well as change the volume based on the distance
    from the sound source to the player character. We will use SFML's advanced sound
    features in the next project.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are finished with the Zombie Arena game. It has been quite a journey. We
    have learned a whole bunch of C++ fundamentals such as references, pointers, OOP,
    and classes. In addition, we have used SFML for managing cameras, vertex arrays,
    and collision detection as well. We learned how to use sprite sheets to reduce
    the number of calls to `window.draw` and speed up the frame rate. Using C++ pointers,
    the STL, and a little bit of OOP, we built a singleton class to manage our textures
    and in the next project we will extend this idea to manage all of our game's assets.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Coming up in the closing project of the book we will discover particle effects,
    directional sound, and split-screen multiplayer gaming. In C++, we will encounter
    inheritance, polymorphism, and a few more new concepts as well.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
