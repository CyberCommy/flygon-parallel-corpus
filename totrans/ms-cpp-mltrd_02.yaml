- en: Multithreading Implementation on the Processor and OS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理器和操作系统上的多线程实现
- en: The foundation of any multithreaded application is formed by the implementation
    of the required features by the hardware of the processor, as well as by the way
    these features are translated into an API for use by applications by the operating
    system. An understanding of this foundation is crucial for developing an intuitive
    understanding of how to best implement a multithreaded application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 任何多线程应用程序的基础是由处理器硬件实现所需功能以及这些功能如何被操作系统转换为应用程序使用的API所形成的。了解这个基础对于开发对多线程应用程序的最佳实现方式至关重要。
- en: This chapter looks at how hardware and operating systems have evolved over the
    years to arrive at the current implementations and APIs as they are in use today.
    It shows how the example code of the previous chapter ultimately translates into
    commands to the processor and related hardware.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨多年来硬件和操作系统是如何演变到当前的实现和API的，展示了前一章的示例代码最终如何转换为对处理器和相关硬件的命令。
- en: 'Topics covered in this chapter include the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题包括以下内容：
- en: The evolution of processor hardware in order to support multithreading concepts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了支持多线程概念而发展的处理器硬件的演变
- en: How operating systems changed to use these hardware features
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统如何改变以使用这些硬件特性
- en: Concepts behind memory safety and memory models in various architectures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种架构中内存安全和内存模型背后的概念
- en: Differences between various process and threading models by OSes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统之间各种进程和线程模型的差异
- en: Defining processes and threads
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义进程和线程
- en: Essentially, to the **operating system** (**OS**), a process consists of one
    or more threads, each thread processing its own state and variables. One would
    regard this as a hierarchical configuration, with the OS as the foundation, providing
    support for the running of (user) processes. Each of these processes then consists
    of one or more threads. Communication between processes is handled by **inter-process
    communication** (**IPC**), which is provided by the operating system.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，对于**操作系统**（**OS**）来说，一个进程由一个或多个线程组成，每个线程处理自己的状态和变量。可以将其视为分层配置，操作系统作为基础，为（用户）进程的运行提供支持。然后，每个进程由一个或多个线程组成。进程之间的通信由操作系统提供的**进程间通信**（**IPC**）来处理。
- en: 'In a graphical view, this looks like the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在图形视图中，这看起来像下面这样：
- en: '![](img/00007.gif)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00007.gif)'
- en: Each process within the OS has its own state, with each thread in a process
    having its own state as well as the relative to the other threads within that
    same process. While IPC allows processes to communicate with each other, threads
    can communicate with other threads within the process in a variety of ways, which
    we'll explore in more depth in upcoming chapters. This generally involves some
    kind of shared memory between threads.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统中的每个进程都有自己的状态，进程中的每个线程也有自己的状态，相对于该进程中的其他线程。虽然IPC允许进程之间进行通信，但线程可以以各种方式与进程内的其他线程进行通信，我们将在接下来的章节中更深入地探讨这些方式。这通常涉及线程之间的某种共享内存。
- en: 'An application is loaded from binary data in a specific executable format such
    as, for example, **Executable and Linkable Format** (**ELF**) which is generally
    used on Linux and many other operating systems. With ELF binaries, the following
    number of sections should always be present:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序是从特定的可执行格式的二进制数据中加载的，例如，**可执行和可链接格式**（**ELF**），通常用于Linux和许多其他操作系统。对于ELF二进制文件，应该始终存在以下数量的部分：
- en: '`.bss`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.bss`'
- en: '`.data`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.data`'
- en: '`.rodata`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.rodata`'
- en: '`.text`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.text`'
- en: The `.bss` section is, essentially, allocated with uninitialized memory including
    empty arrays which thus do not take up any space in the binary, as it makes no
    sense to store rows of pure zeroes in the executable. Similarly, there is the
    `.data` section with initialized data. This contains global tables, variables,
    and the like. Finally, the `.rodata` section is like `.data`, but it is, as the
    name suggests, read-only. It contains things such as hardcoded strings.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`.bss`部分基本上是分配未初始化的内存，包括空数组，因此在可执行文件中不占用任何空间，因为在可执行文件中存储纯零行是没有意义的。类似地，还有`.data`部分包含初始化数据。其中包括全局表、变量等。最后，`.rodata`部分类似于`.data`，但正如其名称所示，是只读的。其中包含硬编码的字符串等内容。'
- en: 'In the `.text` section, we find the actual application instructions (code)
    which will be executed by the processor. The whole of this will get loaded by
    the operating system, thus creating a process. The layout of such a process looks
    like the following diagram:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在`.text`部分，我们找到实际的应用程序指令（代码），这些指令将由处理器执行。整个内容将被操作系统加载，从而创建一个进程。这样的进程布局如下图所示：
- en: '![](img/00008.gif)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00008.gif)'
- en: This is what a process looks like when launched from an ELF-format binary, though
    the final format in memory is roughly the same in basically any OS, including
    for a Windows process launched from a PE-format binary. Each of the sections in
    the binary are loaded into their respective sections, with the BSS section allocated
    to the specified size. The `.text` section is loaded along with the other sections,
    and its initial instruction is executed once this is done, which starts the process.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从ELF格式二进制文件启动时进程的样子，尽管在内存中的最终格式在基本上任何操作系统中都大致相同，包括从PE格式二进制文件启动的Windows进程。二进制文件中的每个部分都加载到它们各自的部分中，BSS部分分配给指定的大小。`.text`部分与其他部分一起加载，并且一旦完成，将执行其初始指令，从而启动进程。
- en: In system languages such as C++, one can see how variables and other program
    state information within such a process are stored both on the stack (variables
    exist within the scope) and heap (using the new operator). The stack is a section
    of memory (one allocated per thread), the size of which depends on the operating
    system and its configuration. One can generally also set the stack size programmatically
    when creating a new thread.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在诸如C++之类的系统语言中，可以看到在这样的进程中变量和其他程序状态信息是如何存储在堆栈（变量存在于作用域内）和堆（使用new运算符）中的。堆栈是内存的一部分（每个线程分配一个），其大小取决于操作系统及其配置。在创建新线程时，通常也可以通过编程方式设置堆栈大小。
- en: In an operating system, a process consists of a block of memory addresses, the
    size of which is constant and limited by the size of its memory pointers. For
    a 32-bit OS, this would limit this block to 4 GB. Within this virtual memory space,
    the OS allocates a basic stack and heap, both of which can grow until all memory
    addresses have been exhausted, and further attempts by the process to allocate
    more memory will be denied.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作系统中，一个进程由一块内存地址组成，其大小由其内存指针的大小限制。对于32位操作系统，这将限制该块为4GB。在这个虚拟内存空间中，操作系统分配了一个基本的堆栈和堆，两者都可以增长，直到所有内存地址都被耗尽，进程进一步尝试分配更多内存将被拒绝。
- en: The stack is a concept both for the operating system and for the hardware. In
    essence, it's a collection (stack) of so-called stack frames, each of which is
    composed of variables, instructions, and other data relevant to the execution
    frame of a task.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈对操作系统和硬件都是一个概念。本质上，它是一组所谓的堆栈帧的集合，每个堆栈帧由与任务的执行框架相关的变量、指令和其他数据组成。
- en: In hardware terms, the stack is part of the task (x86) or process state (ARM),
    which is how the processor defines an execution instance (program or thread).
    This hardware-defined entity contains the entire state of a singular thread of
    execution. See the following sections for further details on this.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从硬件角度来看，堆栈是任务（x86）或进程状态（ARM）的一部分，这是处理器定义执行实例（程序或线程）的方式。这个硬件定义的实体包含了一个线程的整个状态。有关此内容的更多详细信息，请参见以下各节。
- en: Tasks in x86 (32-bit and 64-bit)
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: x86（32位和64位）中的任务
- en: 'A task is defined as follows in the Intel IA-32 System Programming guide, Volume
    3A:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在Intel IA-32系统编程指南第3A卷中，任务定义如下：
- en: '*"A task is a unit of work that a processor can dispatch, execute, and suspend.
    It can be used to execute a program, a task or process, an operating-system service
    utility, an interrupt or exception handler, or a kernel or executive utility."*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: “任务是处理器可以分派、执行和挂起的工作单元。它可以用于执行程序、任务或进程、操作系统服务实用程序、中断或异常处理程序，或内核或执行实用程序。”
- en: '*"The IA-32 architecture provides a mechanism for saving the state of a task,
    for dispatching tasks for execution, and for switching from one task to another.
    When operating in protected mode, all processor execution takes place from within
    a task. Even simple systems must define at least one task. More complex systems
    can use the processor''s task management facilities to support multitasking applications."*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: “IA-32架构提供了一种保存任务状态、分派任务执行和从一个任务切换到另一个任务的机制。在保护模式下，所有处理器执行都是在任务内部进行的。即使是简单的系统也必须定义至少一个任务。更复杂的系统可以使用处理器的任务管理设施来支持多任务应用程序。”
- en: This excerpt from the IA-32 (Intel x86) manual summarizes how the hardware supports
    and implements support for operating systems, processes, and the switching between
    these processes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: IA-32（Intel x86）手册中的这段摘录总结了硬件如何支持和实现对操作系统、进程以及这些进程之间的切换的支持。
- en: It's important to realize here that, to the processor, there's no such thing
    as a process or thread. All it knows of are threads of execution, defined as a
    series of instructions. These instructions are loaded into memory somewhere, and
    the current position in these instructions is kept track of along with the variable
    data (variables) being created, as the application is executed within the data
    section of the process.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要意识到，对于处理器来说，没有进程或线程这样的东西。它所知道的只是执行线程，定义为一系列指令。这些指令被加载到内存的某个地方，并且当前位置和变量数据（变量）的创建情况都在进程的数据部分中被跟踪，当应用程序在数据部分中执行时。
- en: Each task also runs within a hardware-defined protection ring, with the OS's
    tasks generally running on ring 0, and user tasks on ring 3\. Rings 1 and 2 are
    rarely used except for specific use cases with modern OSes on the x86 architecture.
    These rings are privilege-levels enforced by the hardware and allow for example
    for the strict separation of kernel and user-level tasks.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 每个任务也在硬件定义的保护环中运行，操作系统的任务通常在环0上运行，用户任务在环3上运行。环1和2很少被使用，除非在x86架构的现代操作系统中有特定的用例。这些环是硬件强制执行的特权级别，例如严格分离内核和用户级任务。
- en: 'The task structure for both 32-bit and 64-bit tasks are quite similar in concept.
    The official name for it is the **Task State Structure** (**TSS**). It has the
    following layout for 32-bit x86 CPUs:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 32位和64位任务的任务结构在概念上非常相似。它的官方名称是**任务状态结构**（**TSS**）。对于32位x86 CPU，它的布局如下：
- en: '![](img/00009.gif)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00009.gif)'
- en: 'Following are the firlds:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是字段：
- en: '**SS0**: The first stack segment selector field'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SS0**：第一个堆栈段选择器字段'
- en: '**ESP0**: The first SP field'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ESP0**：第一个SP字段'
- en: 'For 64-bit x86_64 CPUs, the TSS layout looks somewhat different, since hardware-based
    task switching is not supported in this mode:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于64位x86_64 CPU，TSS布局看起来有些不同，因为在这种模式下不支持基于硬件的任务切换：
- en: '![](img/00010.gif)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00010.gif)'
- en: 'Here, we have similar relevant fields, just with different names:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有类似的相关字段，只是名称不同：
- en: '**RSPn**: SP for privilege levels 0 through 2'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RSPn**：特权级别0到2的SP'
- en: '**ISTn**: Interrupt stack table pointers'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ISTn**：中断堆栈表指针'
- en: Even though on x86 in 32-bit mode, the CPU supports hardware-based switching
    between tasks, most operating systems will use just a single TSS structure per
    CPU regardless of the mode, and do the actual switching between tasks in software.
    This is partially due to efficiency reasons (swapping out only pointers which
    change), partially due to features which are only possible this way, such as measuring
    CPU time used by a process/thread, and to adjust the priority of a thread or process.
    Doing it in software also simplifies the portability of code between 64-bit and
    32-bit systems, since the former do not support hardware-based task switching.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: During a software-based task switch (usually via an interrupt), the ESP/RSP,
    and so on are stored in memory and replaced with the values for the next scheduled
    task. This means that once execution resumes, the TSS structure will now have
    the **Stack Pointer** (**SP**), segment pointer(s), register contents, and all
    other details of the new task.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: The source of the interrupt can be based in hardware or software. A hardware
    interrupt is usually used by devices to signal to the CPU that they require attention
    by the OS. The act of calling a hardware interrupt is called an Interrupt Request,
    or IRQ.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: A software interrupt can be due to an exceptional condition in the CPU itself,
    or as a feature of the CPU's instruction set. The action of switching tasks by
    the OS's kernel is also performed by triggering a software interrupt.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Process state in ARM
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In ARM architectures, applications usually run in the unprivileged **Exception
    Level 0** (**EL0**) level, which is comparable to ring 3 on x86 architectures,
    and the OS kernel in EL1\. The ARMv7 (AArch32, 32-bit) architecture has the SP
    in the general purpose register 13\. For ARMv8 (AArch64, 64-bit), a dedicated
    SP register is implemented for each exception level: `SP_EL0`, `SP_EL1`, and so
    on.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: For task state, the ARM architecture uses **Program State Register** (**PSR**)
    instances for the **Current Program State Register** (**CPSR**) or the **Saved
    Program State Register** (**SPSR**) program state's registers. The PSR is part
    of the **Process State** (**PSTATE**), which is an abstraction of the process
    state information.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'While the ARM architecture is significantly different from the x86 architecture,
    when using software-based task switching, the basic principle does not change:
    save the current task''s SP, register state, and put the next task''s detail in
    there instead before resuming processing.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: The stack
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we saw in the preceding sections, the stack together with the CPU registers
    define a task. As mentioned earlier, this stack consists of stack frames, each
    of which defines the (local) variables, parameters, data, and instructions for
    that particular instance of task execution. Of note is that although the stack
    and stack frames are primarily a software concept, it is an essential feature
    of any modern OS, with hardware support in many CPU instruction sets. Graphically,
    it can be be visualized like the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00011.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: The SP (ESP on x86) points to the top of the stack, with another pointer (**Extended
    Base Pointer** (**EBP**) for x86). Each frame contains a reference to the preceding
    frame (caller return address), as set by the OS.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: When using a debugger with one's C++ application, this is basically what one
    sees when requesting the backtrack--the individual frames of the stack showing
    the initial stack frame leading up until the current frame. Here, one can examine
    each individual frame's details.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Defining multithreading
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the past decades, a lot of different terms related to the way tasks are
    processed by a computer have been coined and come into common use. Many of these
    are also used interchangeably, correctly or not. An example of this is multithreading
    in comparison with multiprocessing.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the latter means running one task per processor in a system with multiple
    physical processors, while the former means running multiple tasks on a singular
    processor simultaneously, thus giving the illusion that they are all being executed
    simultaneously:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00012.gif)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
- en: Another interesting distinction between multiprocessing and multitasking is
    that the latter uses time-slices in order to run multiple threads on a single
    processor core. This is different from multithreading in the sense that in a multitasking
    system, no tasks will ever run in a concurrent fashion on the same CPU core, though
    tasks can still be interrupted.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: The concept of a process and a shared memory space between the threads contained
    within the said process is at the very core of multithreaded systems from a software
    perspective. Though the hardware is often not aware of this--seeing just a single
    task to the OS. However, such a multithreaded process contains two or many more
    threads. Each of these threads then perform its own series of tasks.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: In other implementations, such as Intel's **Hyper-Threading** (**HT**) on x86
    processors, this multithreading is implemented in the hardware itself, where it's
    commonly referred to as SMT (see the section *Simultaneous multithreading (SMT)*
    for details). When HT is enabled, each physical CPU core is presented to the OS
    as being two cores. The hardware itself will then attempt to execute the tasks
    assigned to these so-called virtual cores concurrently, scheduling operations
    which can use different elements of a processing core at the same time. In practice,
    this can give a noticeable boost in performance without the operating system or
    application requiring any type of optimization.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: The OS can of course still do its own scheduling to further optimize the execution
    of task, since the hardware is not aware of many details about the instructions
    it is executing.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'Having HT enabled looks like this in the visual format:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00013.jpeg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
- en: In this preceding graphic, we see the instructions of four different tasks in
    memory (RAM). Out of these, two tasks (threads) are being executed simultaneously,
    with the CPU's scheduler (in the frontend) attempting to schedule the instructions
    so that as many instructions as possible can be executed in parallel. Where this
    is not possible, so-called pipeline bubbles (in white) appear where the execution
    hardware is idle.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Together with internal CPU optimizations, this leads to a very high throughput
    of instructions, also called **Instructions Per Second** (**IPC**). Instead of
    the GHz rating of a CPU, this IPC number is generally far more significant for
    determining the sheer performance of a CPU.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Flynn's taxonomy
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Different types of computer architecture are classified using a system which
    was first proposed by Michael J. Flynn, back in 1966\. This classification system
    knows four categories, defining the capabilities of the processing hardware in
    terms of the number of input and output streams:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '**Single Instruction, Single Data** (**SISD**): A single instruction is fetched
    to operate on a single data stream. This is the traditional model for CPUs.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Single Instruction, Multiple Data** (**SIMD**): With this model, a single
    instruction operates on multiple data streams in parallel. This is what vector
    processors such as **graphics processing units** (**GPUs**) use.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiple Instruction, Single Data** (**MISD**): This model is most commonly
    used for redundant systems, whereby the same operation is performed on the same
    data by different processing units, validating the results at the end to detect
    hardware failure. This is commonly used by avionics systems and similar.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiple Instruction, Multiple Data** (**MIMD**): For this model, a multiprocessing
    system lends itself very well. Multiple threads across multiple processors process
    multiple streams of data. These threads are not identical, as is the case with
    SIMD.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An important thing to note with these categories is that they are all defined
    in terms of multiprocessing, meaning that they refer to the intrinsic capabilities
    of the hardware. Using software techniques, virtually any method can be approximated
    on even a regular SISD-style architecture. This is, however, part of multithreading.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric versus asymmetric multiprocessing
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the past decades, many systems were created which contained multiple processing
    units. These can be broadly divided into **Symmetric Multiprocessing** (**SMP**)
    and **Asymmetric Multiprocessing** (**AMP**) systems.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: AMP's main defining feature is that a second processor is attached as a peripheral
    to the primary CPU. This means that it cannot run control software, but only user
    applications. This approach has also been used to connect CPUs using a different
    architecture to allow one to, for example, run x86 applications on an Amiga, 68k-based
    system.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'With an SMP system, each of the CPUs are peers having access to the same hardware
    resources, and set up in a cooperative fashion. Initially, SMP systems involved
    multiple physical CPUs, but later, multiple processor cores got integrated on
    a single CPU die:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00014.gif)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: With the proliferation of multi-core CPUs, SMP is the most common type of processing
    outside of embedded development, where uniprocessing (single core, single processor)
    is still very common.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Technically, the sound, network, and graphic processors in a system can be considered
    to be asymmetric processors related to the CPU. With an increase in **General
    Purpose GPU** (**GPGPU**) processing, AMP is becoming more relevant.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Loosely and tightly coupled multiprocessing
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A multiprocessing system does not necessarily have to be implemented within
    a single system, but can also consist of multiple systems which are connected
    in a network. Such a cluster is then called a loosely coupled multiprocessing
    system. We cover distributing computing in [Chapter 9](part0187.html#5IAP60-1ab5991b318547348fc444437bdacb24),
    *Multithreading with Distributed Computing*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: This is in contrast with a tightly coupled multiprocessing system, whereby the
    system is integrated on a single **printed circuit board** (**PCB**), using the
    same low-level, high-speed bus or similar.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Combining multiprocessing with multithreading
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Virtually any modern system combines multiprocessing with multithreading, courtesy
    of multi-core CPUs, which combine two or more processing cores on a single processor
    die. What this means for an operating system is that it has to schedule tasks
    both across multiple processing cores while also scheduling them on specific cores
    in order to extract maximum performance.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: This is the area of task schedulers, which we will look at in a moment. Suffice
    it to say that this is a topic worthy of its own book.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Multithreading types
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like multiprocessing, there is not a single implementation, but two main ones.
    The main distinction between these is the maximum number of threads the processor
    can execute concurrently during a single cycle. The main goal of a multithreading
    implementation is to get as close to 100% utilization of the processor hardware
    as reasonably possible. Multithreading utilizes both thread-level and process-level
    parallelism to accomplish this goal.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: The are two types of multithreading, which we will cover in the following sections.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Temporal multithreading
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Also known as super-threading, the main subtypes for **temporal multithreading**
    (**TMT**) are coarse-grained and fine-grained (or interleaved). The former switches
    rapidly between different tasks, saving the context of each before switching to
    another task's context. The latter type switches tasks with each cycle, resulting
    in a CPU pipeline containing instructions from various tasks from which the term
    *interleaved* is derived.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: The fine-grained type is implemented in barrel processors. They have an advantage
    over x86 and other architectures that they can guarantee specific timing (useful
    for hard real-time embedded systems) in addition to being less complex to implement
    due to assumptions that one can make.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 细粒度类型在桶处理器中实现。它们比x86和其他架构具有优势，因为它们可以保证特定的时间（对于硬实时嵌入式系统很有用），并且由于可以做出的假设较少，实现起来更不复杂。
- en: Simultaneous multithreading (SMT)
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同时多线程（SMT）
- en: SMT is implemented on superscalar CPUs (implementing instruction-level parallelism),
    which include the x86 and ARM architectures. The defining characteristic of SMT
    is also indicated by its name, specifically, its ability to execute multiple threads
    in parallel, per core.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: SMT实现在超标量CPU上（实现指令级并行性），其中包括x86和ARM架构。SMT的定义特征也由其名称指示，特别是其能够在每个核心中并行执行多个线程。
- en: Generally, two threads per core is common, but some designs support up to eight
    concurrent threads per core. The main advantage of this is being able to share
    resources among threads, with an obvious disadvantage of conflicting needs by
    multiple threads, which has to be managed. Another advantage is that it makes
    the resulting CPU more energy efficient due to a lack of hardware resource duplication.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，每个核心有两个线程是常见的，但某些设计支持每个核心最多八个并发线程。这样做的主要优势是能够在线程之间共享资源，明显的缺点是多个线程的冲突需得到管理。另一个优势是由于缺乏硬件资源重复，使得结果CPU更节能。
- en: Intel's HT technology is essentially Intel's SMT implementation, providing a
    basic two thread SMT engine starting with some Pentium 4 CPUs in 2002.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔的超线程技术本质上是英特尔的SMT实现，从2002年的一些奔腾4 CPU开始提供基本的双线程SMT引擎。
- en: Schedulers
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调度程序
- en: A number of task-scheduling algorithms exist, each focusing on a different goal.
    Some may seek to maximize throughput, others minimize latency, while others may
    seek to maximize response time. Which scheduler is the optimal choice solely depends
    on the application the system is being used for.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多任务调度算法，每个算法都专注于不同的目标。有些可能寻求最大化吞吐量，其他人则最小化延迟，而其他人可能寻求最大化响应时间。哪种调度程序是最佳选择完全取决于系统所用于的应用程序。
- en: For desktop systems, the scheduler is generally kept as general-purpose as possible,
    usually prioritizing foreground applications over background applications in order
    to give the user the best possible desktop experience.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于桌面系统，调度程序通常尽可能保持通用，通常优先考虑前台应用程序，以便为用户提供最佳的桌面体验。
- en: For embedded systems, especially in real-time, industrial applications would
    instead seek to guarantee timing. This allows processes to be executed at exactly
    the right time, which is crucial in, for example, driving machinery, robotics,
    or chemical processes where a delay of even a few milliseconds could be costly
    or even fatal.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于嵌入式系统，特别是在实时、工业应用中，通常会寻求保证定时。这允许进程在恰当的时间执行，这在例如驱动机械、机器人或化工过程中至关重要，即使延迟几毫秒也可能成本高昂甚至致命。
- en: The scheduler type is also dependent on the multitasking state of the OS--a
    cooperative multitasking system would not be able to provide many guarantees about
    when it can switch out a running process for another one, as this depends on when
    the active process yields.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 调度程序类型还取决于操作系统的多任务状态--合作式多任务系统无法提供关于何时可以切换运行中进程的许多保证，因为这取决于活动进程何时让出。
- en: With a preemptive scheduler, processes are switched without them being aware
    of it, allowing the scheduler more control over when processes run at which time
    points.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用抢占式调度程序，进程在不知情的情况下进行切换，允许调度程序更多地控制进程在哪些时间点运行。
- en: Windows NT-based OSes (Windows NT, 2000, XP, and so on) use what is called a
    multilevel feedback queue, featuring 32 priority levels. This type of priority
    scheduler allows one to prioritize tasks over other tasks, allowing one to fine-tune
    the resulting experience.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Windows NT的操作系统（Windows NT，2000，XP等）使用所谓的多级反馈队列，具有32个优先级级别。这种类型的优先级调度程序允许对任务进行优先级排序，从而可以微调产生的体验。
- en: Linux originally (kernel 2.4) also used a multilevel feedback queue-based priority
    scheduler like Windows NT with an O(n) scheduler. With version 2.6, this was replaced
    with an O(1) scheduler, allowing processes to be scheduled within a constant amount
    of time. Starting with Linux kernel 2.6.23, the default scheduler is the **Completely
    Fair Scheduler** (**CFS**), which ensures that all tasks get a comparable share
    of CPU time.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Linux最初（内核2.4）也使用了基于多级反馈队列的优先级调度程序，类似于具有O(n)调度程序的Windows NT。在2.6版本中，这被替换为O(1)调度程序，允许进程在恒定的时间内被调度。从Linux内核2.6.23开始，默认调度程序是**完全公平调度程序**（**CFS**），它确保所有任务获得可比较的CPU时间份额。
- en: 'The type of scheduling algorithm used for a number of commonly used or well-known
    OSes is listed in this table:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些常用或知名操作系统使用的调度算法类型：
- en: '| **Operating System** | **Preemption** | **Algorithm** |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| **操作系统** | **抢占** | **算法** |'
- en: '| Amiga OS | Yes | Prioritized round-robin scheduling |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| Amiga OS | 是 | 优先级轮转调度 |'
- en: '| FreeBSD | Yes | Multilevel feedback queue |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| FreeBSD | 是 | 多级反馈队列 |'
- en: '| Linux kernel before 2.6.0 | Yes | Multilevel feedback queue |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| Linux内核2.6.0之前 | 是 | 多级反馈队列 |'
- en: '| Linux kernel 2.6.0-2.6.23 | Yes | O(1) scheduler |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| Linux内核2.6.0-2.6.23 | 是 | O(1)调度程序 |'
- en: '| Linux kernel after 2.6.23 | Yes | Completely Fair Scheduler |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| Linux内核2.6.23之后 | 是 | 完全公平调度程序 |'
- en: '| classic Mac OS pre-9 | None | Cooperative scheduler |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 经典Mac OS 9之前 | 无 | 合作式调度程序 |'
- en: '| Mac OS 9 | Some | Preemptive scheduler for MP tasks, and cooperative for
    processes and threads |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| Mac OS 9 | 一些 | 用于MP任务的抢占式调度程序，以及用于进程和线程的合作式调度程序 |'
- en: '| OS X/macOS | Yes | Multilevel feedback queue |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| OS X/macOS | 是 | 多级反馈队列 |'
- en: '| NetBSD | Yes | Multilevel feedback queue |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| NetBSD | 是 | 多级反馈队列 |'
- en: '| Solaris | Yes | Multilevel feedback queue |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| Solaris | 是 | 多级反馈队列 |'
- en: '| Windows 3.1x | None | Cooperative scheduler |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| Windows 3.1x | 无 | 合作式调度程序 |'
- en: '| Windows 95, 98, Me | Half | Preemptive scheduler for 32-bit processes, and
    cooperative for 16-bit processes |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
- en: '| Windows NT (including 2000, XP, Vista, 7, and Server) | Yes | Multilevel
    feedback queue |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
- en: '(Source: [https://en.wikipedia.org/wiki/Scheduling_(computing)](https://en.wikipedia.org/wiki/Scheduling_(computing)))'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: The preemptive column indicates whether the scheduler is preemptive or not,
    with the next column providing further details. As one can see, preemptive schedulers
    are very common, and used by all modern desktop operating systems.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Tracing the demo application
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the demonstration code of [Chapter 1](part0020.html#J2B80-1ab5991b318547348fc444437bdacb24),
    *Revisiting Multithreading*, we looked at a simple `c++11` application which used
    four threads to perform some processing. In this section, we will look at the
    same application, but from a hardware and OS perspective.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'When we look at the start of the code in the `main` function, we see that we
    create a data structure containing a single (integer) value:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After the OS creates a new task and associated stack structure, an instance
    of a vector data structure (customized for integer types) is allocated on the
    stack. The size of this was specified in the binary file's global data section
    (BSS for ELF).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: When the application's execution is started using its entry function (`main()`
    by default), the data structure is modified to contain the new integer value.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create four threads, providing each with some initial data:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For the OS, this means creating new data structures, and allocating a stack
    for each new thread. For the hardware, this initially does not change anything
    if no hardware-based task switching is used.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the OS's scheduler and the CPU can combine to execute this set
    of tasks (threads) as efficiently and quickly as possible, employing features
    of the hardware including SMP, SMT, and so on.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, the main thread waits until the other threads stop executing:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These are blocking calls, which mark the main thread as being blocked until
    these four threads (tasks) finish executing. At this point, the OS's scheduler
    will resume execution of the main thread.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'In each newly created thread, we first output a string on the standard output,
    making sure that we lock the mutex to ensure synchronous access:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A mutex, in essence, is a singular value being stored on the stack of heap,
    which then is accessed using an atomic operation. This means that some form of
    hardware support is required. Using this, a task can check whether it is allowed
    to proceed yet, or has to wait and try again.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: In this last particular piece of code, this mutex lock allows us to output on
    the standard C++ output stream without other threads interfering.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, we copy the initial value in the vector to a local variable, again
    ensuring that it''s done synchronously:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The same thing happens here, except now the mutex lock allows us to read the
    first value in the vector without risking another thread accessing or even changing
    it while we use it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'This is followed by the generating of a random number as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This uses the `randGen()` method, which is as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This method is interesting due to its use of a thread-local variable. Thread-local
    storage is a section of a thread's memory which is specific to it, and used for
    global variables, which, nevertheless, have to remain limited to that specific
    thread.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: This is very useful for a static variable like the one used here. That the `generator`
    instance is static is because we do not want to reinitialize it every single time
    we use this method, yet we do not want to share this instance across all threads.
    By using a thread-local, static instance, we can accomplish both goals. A static
    instance is created and used, but separately for each thread.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: The `Thread` function then ends with the same series of mutexes being locked,
    and the new value being copied to the array.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here we see the same synchronous access to the standard output stream, followed
    by synchronous access to the values data structure.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到对标准输出流的同步访问，然后是对值数据结构的同步访问。
- en: Mutual exclusion implementations
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互斥实现
- en: Mutual exclusion is the principle which underlies thread-safe access of data
    within a multithreaded application. One can implement this both in hardware and
    software. The **mutual exclusion** (**mutex**) is the most elementary form of
    this functionality in most implementations.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥是多线程应用程序中数据的线程安全访问的原则。可以在硬件和软件中实现这一点。**互斥**（**mutex**）是大多数实现中这种功能的最基本形式。
- en: Hardware
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬件
- en: The simplest hardware-based implementation on a uniprocessor (single processor
    core), non-SMT system is to disable interrupts, and thus, prevent the task from
    being changed. More commonly, a so-called busy-wait principle is employed. This
    is the basic principle behind a mutex--due to how the processor fetches data,
    only one task can obtain and read/write an atomic value in the shared memory,
    meaning, a variable sized the same (or smaller) as the CPU's registers. This is
    further detailed in Chapter 8, *Atomic Operations - Working with the Hardware*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在单处理器（单处理器核心），非SMT系统上最简单的基于硬件的实现是禁用中断，从而防止任务被更改。更常见的是采用所谓的忙等待原则。这是互斥的基本原则--由于处理器获取数据的方式，只有一个任务可以获取和读/写共享内存中的原子值，即与CPU寄存器相同（或更小）大小的变量。这在第8章“原子操作-与硬件一起工作”中有进一步详细说明。
- en: 'When our code tries to lock a mutex, what this does is read the value of such
    an atomic section of memory, and try to set it to its locked value. Since this
    is a single operation, only one task can change the value at any given time. Other
    tasks will have to wait until they can gain access in this busy-wait cycle, as
    shown in this diagram:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的代码尝试锁定互斥锁时，这实际上是读取这样一个原子内存区域的值，并尝试将其设置为其锁定值。由于这是一个单操作，只有一个任务可以在任何给定时间更改该值。其他任务将不得不等待，直到它们可以在这个忙等待周期中获得访问，如图所示：
- en: '![](img/00015.jpeg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00015.jpeg)'
- en: Software
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件
- en: Software-defined mutual exclusion implementations are all based on busy-waiting.
    An example is **Dekker's** algorithm, which defines a system in which two processes
    can synchronize, employing busy-wait to wait for the other process to leave the
    critical section.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 基于忙等待的软件定义的互斥实现。一个例子是**Dekker**算法，它定义了一个系统，其中两个进程可以同步，利用忙等待等待另一个进程离开临界区。
- en: 'The pseudocode for this algorithm is as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法的伪代码如下：
- en: '[PRE8]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '(Referenced from: [https://en.wikipedia.org/wiki/Dekker''s_algorithm](https://en.wikipedia.org/wiki/Dekker''s_algorithm))'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: （引用自：[https://en.wikipedia.org/wiki/Dekker's_algorithm](https://en.wikipedia.org/wiki/Dekker's_algorithm)）
- en: In this preceding algorithm, processes indicate the intent to enter a critical
    section, checking whether it's their turn (using the process ID), then setting
    their intent to enter the section to false after they have entered it. Only once
    a process has set its intent to enter to true again will it enter the critical
    section again. If it wishes to enter, but `turn` does not match its process ID,
    it'll busy-wait until the condition becomes true.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述算法中，进程表明他们打算进入临界区，检查是否轮到他们（使用进程ID），然后在进入后将其意图设置为false。只有当进程再次将其意图设置为true时，它才会再次进入临界区。如果它希望进入，但`turn`与其进程ID不匹配，它将忙等待直到条件变为真。
- en: A major disadvantage of software-based mutual exclusion algorithms is that they
    only work if **out-of-order** (**OoO**) execution of code is disabled. OoO means
    that the hardware actively reorders incoming instructions in order to optimize
    their execution, thus changing their order. Since these algorithms require that
    various steps are executed in order, they no longer work on OoO processors.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 软件基础的互斥算法的一个主要缺点是，它们只在禁用代码的**乱序**（**OoO**）执行时才能工作。 OoO意味着硬件积极重新排序传入的指令，以优化它们的执行，从而改变它们的顺序。由于这些算法要求各个步骤按顺序执行，它们在OoO处理器上不再起作用。
- en: Summary
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we saw how processes and threads are implemented both in operating
    systems and in hardware. We also looked at various configurations of processor
    hardware and elements of operating systems involved in scheduling to see how they
    provide various types of task processing.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了进程和线程在操作系统和硬件中的实现方式。我们还研究了处理器硬件的各种配置以及涉及调度的操作系统元素，以了解它们如何提供各种类型的任务处理。
- en: Finally, we took the multithreaded program example of the previous chapter,
    and ran through it again, this time considering what happens in the OS and processor
    while it is being executed.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们再次运行了上一章的多线程程序示例，并考虑了在执行过程中操作系统和处理器发生了什么。
- en: In the next chapter, we will take a look at the various multithreading APIs
    being offered via OS and library-based implementations, along with examples comparing
    these APIs.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看看通过操作系统和基于库的实现提供的各种多线程API，以及比较这些API的示例。
