- en: Chapter 4. Building Robust Applications with HTML5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the advent of ActionScript 3, Flash developers have become accustomed
    to developing in an **object-oriented programming** (**OOP**) paradigm. When transitioning
    to JavaScript, many developers with an experience of OOP would initially be put
    off by the syntax JavaScript uses to accomplish the same functionality. However,
    a misunderstanding of the syntax may lead to a misunderstanding of the functionality.
    Therefore, in this chapter we will cover the use of JavaScript OOP, Events, and
    Event Listeners as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript class structure, usage, and syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class constructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools and frameworks to aid in development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom events and listeners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing object-oriented JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In 2006, when Adobe released Flash Player 9 with the inclusion of ActionScript
    3 support, the Flash development community saw a major paradigm shift in the way
    they developed their Flash applications. Prior to the use of ActionScript 3, developers
    were tasked with writing their applications in ActionScript 2, which is primarily
    used as a scripting programming language. ActionScript 3 was designed as a true
    object-oriented programming language with strict typing, which allows for code
    to be written in a reusable, more controlled manner.
  prefs: []
  type: TYPE_NORMAL
- en: With the use of ActionScript 3 and the new ActionScript Virtual Machine compiler
    released for Flash Player 9, the code within Flash applications was not only written
    in an OOP structure but could also run up to 10 times faster than the previous
    legacy Flash applications. Over time, Flash developers have become accustomed
    to writing proper OOP structured code, which has allowed them to easily transition
    their programming skill set to other languages such as Java, C++, or C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of the OOP paradigm in JavaScript is a bit tricky to understand at
    first, so let''s create an example class structure in ActionScript 3 and port
    it directly to JavaScript to see the visual syntax differences. In this example,
    we will create a sample "Player" class that will emulate the basic functionality
    of a character in a game. Rather than setting up each Player in our game with
    a separate code, based on functionality, we will use the `Player` class to create
    as many players as we need in our game and alter their properties via constructors,
    getters, setters, and public variables. To get a better idea of this concept,
    consider the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Although simplified for example purposes, this class example should look pretty
    familiar to any developer with the experience of coding in ActionScript 3\. With
    this class within our Flash project, we can import it and instantiate it at any
    time within our application. Declared within the object are properties and methods
    that can be called by the parent object to manipulate the data for the specific
    `Player` object, and this is typical of any class. When you are ready to add a
    new Player into your application, we can instantiate a new object with the following
    ActionScript 3 code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: By appending the required values into the constructor, we give our Player a
    unique name as well as an initial value as to how many lives this Player will
    have. We now have our new Player, which we can manipulate in our imaginary game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s take a look at the same class that is rewritten in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: At first glance one can see that there is no class declaration, which one would
    be familiar with, as in many other programming languages. Instead, when creating
    "classes" in JavaScript, one uses a function to simulate the usage of a traditional
    class structure. Package declarations are removed from the equation as well as
    the inclusion of JavaScript is appended to the HTML document rendering the web
    page. By all means, pending it was logical; one could separate all one's JavaScript
    classes into separate files for ease of development. However, when publishing
    large amounts of JavaScript to a public-hosted environment, to conserve the amount
    of requests to the web server for data, JavaScript should be consolidated as much
    as possible. We will dig further into the preparation of your HTML5 projects for
    production environments in [Chapter 10](ch10.html "Chapter 10. Preparing for Release"),
    *Preparing for Release*.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One thing must be noted at this point of time. With the lack of strict typing
    and many other specific class structure rules, the same JavaScript functionality
    can be written in numerous ways. During the course of this chapter, I have written
    the examples to be as user-friendly as possible in order to allow us to examine
    the syntax better.
  prefs: []
  type: TYPE_NORMAL
- en: Class syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the initial JavaScript class example, we examined the differences between
    ActionScript 3's class structure as compared to JavaScript when creating object-oriented
    code. The example used one of the more traditional methods of creating a class
    in JavaScript by using a function in place of the typical class declaration.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Many of the example JavaScript functions we have used in code examples so far
    have shown some of the different ways in which we can define a new function. As
    I just mentioned, depending on what the developers are comfortable with, they
    may choose to write their functions in JavaScript in one of the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of the three `console.log` outputs in the previous example would yield
    the proper Boolean return of *true*. It is also worth noting that the order of
    the function definitions and function usage is not required to be as demonstrated
    in the preceding sample of code. The following example would yield the exact same
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When attempting to call a function that has not been defined, a `ReferenceError`
    error will be dispatched and displayed in the JavaScript console.
  prefs: []
  type: TYPE_NORMAL
- en: '![Functions](img/3325OT_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Although our application would continue running despite this runtime error,
    it would generally mean that there is an issue with our code. Rather than having
    the default `ReferenceError` error sent to the JavaScript console, we could use
    a simple condition to handle this issue within our code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Variable scope
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Understanding properly how variables scope in JavaScript is a critical step
    in understanding the core aspects of the language. Scope refers to the accessibility
    that the variables have to other parts of the code when they are created somewhere
    within your code. Variables can be instantiated and referenced depending on the
    syntax used to declare them. JavaScript utilizes what many refer to as *function
    scope*, whereby all variables and functions scope in the same manner. At the top
    of the scope chain are the global variables and functions. As with all programming
    paradigms, global means everything, and a global variable or function is accessible
    anywhere else within your code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This code demonstrates the use of a global variable. Since the variable name
    is declared above the scope of the function that uses it, there would be no errors
    when running this code. However, variables can also be locally declared from within
    a function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As the Player's name (which in this case is John) is created within the `getName`
    function, it is not globally accessible to any of the code outside of that function.
    As simple as the concept of global and local variables is, when you begin to consider
    the lack of strict typing and the use of exact variable names for global and local
    variables, your head may begin to spin. Not to worry, this is another one of the
    typical learning curve issues developers have with JavaScript. But as mentioned
    before, mastering variable scope in JavaScript is one of the essential skills
    every good HTML5 developer must have.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate some of the issues presented, and to allow you to fully view
    scoping in action, let''s review the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The previous example, although an illogical way to output the characters A to
    F, demonstrates many of the ways in which variables and functions can be manipulated
    to access data from specific areas in your application's scope chain.
  prefs: []
  type: TYPE_NORMAL
- en: Public and private variables and functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next step for understanding variables and functions within JavaScript is
    by learning how to create and utilize public and private members. Unlike in ActionScript
    3, variables are not typed as private or public, thus making the syntax a little
    harder to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Local or private variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Private (or local) variables are declared by utilizing the `var` keyword when
    creating variables within an object. The resulting variable will only be accessible
    within that specific object and would require a getter and setter method to allow
    for external manipulation. This manner of variable declaration is similar to using
    the `private` keyword when creating variables in ActionScript 3\. A general rule
    of thumb in OOP development is to use private variables whenever possible as it
    will lead to far less issues with variable corruption or other misusage.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Public variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Public variables or properties are declared by using the `this.myVariableName`
    syntax. Similar to the `public` keyword when creating variables in ActionScript
    3, public variables in JavaScript are accessible not only to the code within the
    object's scope chain but also from outside of the object it was created in as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Private functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Private functions, which are only accessible within the object scope, can be
    written in a couple of different ways.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Both examples demonstrated previously yield a private function. Any attempt
    to call the function from outside of the object scope would result in a runtime
    error.
  prefs: []
  type: TYPE_NORMAL
- en: Public functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Public or privileged functions, like public variables, are accessible from outside
    of the object they were created in, and are created using the `this.myFunctionName
    = function() {...}` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Prototype
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the more confusing aspects of a JavaScript object's syntax is the use
    of the prototype object. As we have seen in the examples and explanations up to
    this point, everything in JavaScript is an object, and within every JavaScript
    object is a prototype property.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you were using Flash back in the days of ActionScript 1 or ActionScript 2,
    you may be familiar with the concept of the prototype object ([http://help.adobe.com/en_US/as2/reference/flashlite/WS5b3ccc516d4fbf351e63e3d118ccf9c47f-7ec2.html](http://help.adobe.com/en_US/as2/reference/flashlite/WS5b3ccc516d4fbf351e63e3d118ccf9c47f-7ec2.html)).
    This object was utilized in both programming languages, but dropped on the release
    of ActionScript 3.
  prefs: []
  type: TYPE_NORMAL
- en: To see this concept in action, let's start simple and work our way forward into
    more complex usages of the prototype object. We will start by looking at the prototype
    object for a new empty object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this code in a web browser would result in a JavaScript log that would
    resemble something very close to the following code, if not the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This output can give us a lot more sense of what the prototype object is really
    about. As you already know from previous ActionScript 3 development, object variable
    types come with many built-in methods to manipulate the content within it. Looking
    at the output of the prototype of our `Player` object, you may notice that many
    of these familiar methods and properties are listed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this prototype object to append new properties to an object at any
    time. Consider the following example where we create a simplified `Player` object
    and append the move functionality to it via the prototype object rather than directly
    within the object itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The same concept could be used for overriding the default object behavior. By
    modifying the move properties via the prototype object, any further calls to the
    move method would result in a newly appended behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Keep in mind that these changes are targeted to the object itself and not the
    instance. Therefore, these changes will affect each and every Player instance
    demonstrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: So why is this important? While depending on how your application is built,
    by utilizing the prototype object, you can easily append shared code to objects
    directly, without the need for coding the same thing more than once. Less code
    means less memory, and it will always make your life easier when it comes to maintaining
    your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Instance types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you begin to float around all of this new JavaScript code and syntax in
    these examples and in your own, adding checks and conditions for instance types
    will prove to be an important addition. The lack of strict typing will require
    you to write and maintain clean and optimized code to get your applications working
    properly. Consider some of the following code snippets for acquiring information
    on the instance type of our `Player` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of these calls to the `console.log` method are performing different ways
    to look up the instance of the `Player` object. When we run this code in a web
    browser and open up the developer console, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Instance types](img/3325OT_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The initial `object` output is a result of the `typeof()` function call made
    on the `Player` object. The second output is the code block returned when calling
    the constructor of the `Player` object. Finally, the conditional console call
    (`console.log(player instanceof Object)`) results in the Boolean return in the
    console letting us know that the `instanceof` condition is true.
  prefs: []
  type: TYPE_NORMAL
- en: Object literals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Literals are simply a shorter method to define arrays and objects within JavaScript.
    We are already creating new objects in JavaScript with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We can further extend the preceding syntax by creating the internals of the
    object directly within the variable declaration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This `Object` syntax, however, creates major issues with its lack of reusability
    as its instance already will have existed when it is created. Since there is no
    need to instantiate the object, we can continue our code by referencing its properties.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Constructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we have seen in some of the previous examples, in comparison to ActionScript
    3, the object constructor syntax is a bit different than one would typically be
    used to. Since classes are just functions, we can just place the code typically
    found within the constructor directly within the class.
  prefs: []
  type: TYPE_NORMAL
- en: You can easily look up the reference to the function that initially created
    an object, by calling the `constructor` property on it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When attempting to look up the constructor of a built-in object type such as
    an array, string, or date, the output will conceal the inner code and display
    a warning of the use of native code as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This would generate the following in the browser''s JavaScript console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By using the `call()` method on a pre-existing object, we can update the reference
    to `this` from the object itself to somewhere else in the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This example demonstrates a simple inheritance of the `Player` object within
    the new `John` object. This allows us to access the internal values within `Player`
    and use them externally within the `John` class. In this example case, we make
    John 35 years older than the default `Player`. We can also use the prototype object
    to declare object inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'When the new `jill` object is created, it inherits all of the base properties
    and functions from `Player` as the prototype reference has declared object inheritance.
    The resulting output for this example on page load would display the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Listing object properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At any point you can look up the available properties within an object by using
    the `Object.getOwnPropertyNames()` method. Keeping private and public syntax in
    mind, let''s review the following example to view the output when looking up an
    object''s properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, with public and private variables in mind, only variables created with
    the keyword `this` are visible outside of the object scope. Executing the preceding
    code example would provide the following array of properties'' names as the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Making OOP in JavaScript easier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To many developers, the culmination of all of these workarounds and syntax changes
    that come with developing object-oriented JavaScript may seem just like a laundry
    list of "hacks". Regardless of your point of view on the matter, there are many
    options available to aid in building large-scale JavaScript-based applications
    with a more traditional development flow. In [Chapter 6](ch06.html "Chapter 6. HTML5
    Frameworks and Libraries"), *HTML5 Frameworks and Libraries*, we will dig into
    many of the popular JavaScript libraries and frameworks available, and how they
    can be used to not only speed up your development time but also provide a more
    solid end result on all modern browsers and devices.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with most languages, events are what really brings an application to life.
    Without the use of events, programs would usually just run from start to finish
    without the need for human interaction. JavaScript events are built around the
    asynchronous event model. Rather than checking continually to see if a condition
    is met, events can use call-back structures, like in ActionScript, to execute
    code once an event has been fired. A great example of this, which you may have
    already seen in many other examples thus far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We use this Event Listener on the `window` object to allow our code to determine
    when the `window` object will finish loading, so that we can call our initial
    method to begin JavaScript manipulation of our document.
  prefs: []
  type: TYPE_NORMAL
- en: Keyboard and mouse events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mouse events are another one of the core elements almost all JavaScript projects
    contain. Although we will be using these events within the examples all throughout
    this book, it''s worth reviewing a consolidated list of not only the mouse, but
    keyboard and touch events as well, so that you can have a better understanding
    of what is easily available to you for input event listening. The different keyboard
    and mouse events are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**mousedown:** A mouse button has been pressed down'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**mouseup:** A mouse button has been released'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**click:** A mouse button has been clicked'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dblclick:** A mouse button has been double-clicked'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**contextmenu:** Some action to trigger a context menu has occurred'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**scrolling:** The context has been moved on the scroll axis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**keydown:** A keyboard key has been pressed into the down state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**keypress:** A keyboard key has been pressed and released'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**keyup:** A keyboard key has been released'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Touch events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Touch event support is growing closer to a set standard; however, you will
    notice support and feature set differences depending on what device and browser
    you are testing on. It''s worth noting that just like Flash applications running
    on a touch interface, you can use the mouse events with no issues, and still support
    the use of an actual mouse. However, as a mouse can only click on one point at
    a time, if your application will need multitouch support, you will have to begin
    utilizing the touch event structure. In the next two chapters, we will look further
    into the use of HTML on touch devices and how the development differs. The touch
    events supported are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**touchstart:** A user has started to touch an element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**touchmove:** A user has moved the touch position since touchstart'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**touchend:** A user has removed his/her finger from the element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having the ability to create custom events and dispatch them to waiting Event
    Listeners allows you to further extend your application''s OOP syntax and structure.
    Typically, as a Flash developer using ActionScript 3, you would utilize the `flash
    events` class to create custom events so as to create the flow of communication
    from class to class. In its simplest form, it would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As with most of the functionality in ActionScript 3, to optimize the application''s
    file size and execution speed, packages must be directly imported into the project
    when utilizing extended internal functionality. Therefore, when creating and dispatching
    events in ActionScript 3, we should always import the `Event` and `EventDispatcher`
    classes, after which we can instantiate a new event with our custom event type
    that is supplied as a string. When the event is dispatched, there will need to
    be an Event Listener to execute further code to complete the event sequence within
    your application. I am sure you are well aware that the typical Event Listener
    in ActionScript 3 is described in the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Using the same ActionScript 3 syntax like all Event Listener setups, the custom
    event type, which is again in the form of a string, is supplied to the identifier.
    The second parameter supplied is always the function to be called once this listener
    has fired. The final three parameters control bubbling and weak referencing for
    event control and memory cleanup.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the customized events' setup and structure in JavaScript are extremely
    similar with some obvious differences. Consider this working example in comparison
    to what we just reviewed and what you already know about events in ActionScript
    3.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Apart from the lack of imported classes, this event example should look pretty
    familiar in the eyes of any Flash developer. As with majority of the examples
    in this book, we wait for the window to load with an Event Listener that we have
    often seen up to this point. Within the `init` function, we start by creating
    our Event Listener. In this case, we append the listener to the document; however,
    this could be appended to any object within your code. Note that not only is the
    method to create a new Event Listener exactly the same (`addEventListener`), but
    the syntax of the initial two parameters is the same as well. The final Boolean
    value supplied controls event bubbling, which we will refer back to in a while.
    The remaining code within the `init` function contains our event instantiation
    as well as the dispatching of that event. Again, thanks to the glory that is,
    ECMAScript, the syntax and structure of the custom event is nearly identical.
  prefs: []
  type: TYPE_NORMAL
- en: While creating our event type in JavaScript with the `createEvent()` method,
    the availability of event modules depends on the DOM Level support that the viewing
    browser has. At the time of writing this book, majority of the browsers are moving
    towards full support of the DOM Level 3 Events, which include UIEvent, DOMFocus,
    DOMActivate, Event, MouseEvent, MutationEvent, TextEvent, KeyboardEvent, and HTMLEvent.
    You can always check out the complete list of currently available or future specified
    DOM Level 3 Events by heading over to [http://www.w3.org/TR/DOM-Level-3-Events/](http://www.w3.org/TR/DOM-Level-3-Events/).
  prefs: []
  type: TYPE_NORMAL
- en: The third parameter of the `addEventListener` method specifies whether the registered
    Event Handler captures the specified event or not. If the Event Handler captures
    an event, then each time the event occurs on the element or its descendants, the
    Event Handler will be called.
  prefs: []
  type: TYPE_NORMAL
- en: Event bubbling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an event is dispatched, it will follow the object's parent tree to the
    absolute parent object until it is either handled or stopped. This behavior is
    known as event bubbling and is found in ActionScript 3 as well as JavaScript event
    structure. In Flash projects, an event will bubble all the way to the main object
    or in most cases, the Stage. In JavaScript, the event will bubble to the document
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we will examine dealing with the `mousedown` event
    on the document and object by controlling the propagation of the event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This JavaScript snippet applies a `mousedown` Event Listener to both an element
    within the document as well as the document itself. If the user was to click on
    the element within the page, both Event Listeners would be called, resulting in
    two different handlers handling the same mouse click. Although this may be handy
    in some applications, the natural way to deal with this issue and only allow a
    single handler to be called is by stopping the flow of the event bubbling with
    the `stopPropagation()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with event propagation in JavaScript is identical to what you are used
    to in ActionScript 3\. At any point in the event flow, you can easily stop the
    traversal of the event by calling either the `stopPropagation()` or `stopImmediatePropagation()`
    method. If you are familiar with these methods from ActionScript 3 development,
    you will already know that they are almost identical by nature. The only difference
    is that the `stopImmediatePropagation()` call stops the event flow from reaching
    any further Event Listeners in the current node.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the end of the day, all of these code examples only define each of the individual
    pieces of JavaScript's functionality. Continuing with our `Player` class concept
    that we have been using throughout this chapter, we then put some finishing touches
    to our example "Player in a game" class structure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Though still a simple example of what all this could look like in a single
    package, this example encompasses many of the features we have looked at within
    this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Putting it all together](img/3325OT_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although this chapter covers the main concepts surrounding the syntax and structure
    of objects in JavaScript development, in reality we could write a whole book on
    the topic. That being said, we will continue to cover these and more aspects of
    the more advanced side of JavaScript development throughout this book. As mentioned
    in the introduction of this chapter, many of the differences and paradigm changes
    presented with advanced JavaScript development may seem a bit daunting to some
    Flash developers. However, once you get your head wrapped around most of these
    core concepts, the rest of the puzzle pieces begin to fit together with ease.
    In the next chapter, we will be looking into some of the tools available for porting
    pre-existing Flash content to HTML5.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Looking for even more advanced JavaScript syntax and structure tips and techniques?
    You can check these books from Packt Publishing, *Object-Oriented JavaScript*
    by *Stoyan Stefanov*, *Learning jQuery, Third Edition* by *Jonathan Chaffer* and
    *Karl Swedberg*, and *jQuery for Designers: Beginner''s Guide* by *Natalie MacLees*.'
  prefs: []
  type: TYPE_NORMAL
