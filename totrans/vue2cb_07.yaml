- en: Unit Testing and End-to-End Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试和端到端测试
- en: 'In this chapter, the following recipes will be covered:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下内容：
- en: Using Jasmine for testing Vue
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jasmine进行Vue测试
- en: Adding some Karma to your workflow
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Karma添加到工作流程中
- en: Testing your application state and methods
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试应用程序的状态和方法
- en: Testing the DOM
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试DOM
- en: Testing DOM asynchronous updates
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试DOM异步更新
- en: End-to-end testing with nightwatch
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用nightwatch进行端到端测试
- en: Simulating a double-click in nightwatch
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在nightwatch中模拟双击
- en: Different styles of unit testing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同风格的单元测试
- en: Stubbing external API calls with Sinon.JS
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Sinon.JS对外部API调用进行存根
- en: Measuring the coverage of your code
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量代码的覆盖率
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Testing is what really differentiates professional software from amateur software.
    From industry experience and studies, it has been discovered that much of the
    cost of software lies in correcting bugs while the software is in production.
    Testing software reduces bugs in production and makes correcting those bugs much
    less expensive.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是真正区分专业软件和业余软件的关键。根据行业经验和研究，发现软件成本的很大一部分在于在软件投入生产时纠正错误。测试软件可以减少生产中的错误，并使纠正这些错误的成本大大降低。
- en: In this chapter, you will learn how to set up your test harness and how to write
    unit tests and integration tests that will help speed up your app development
    and help it grow in complexity without leaving bugs behind.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何设置测试工具和编写单元测试和集成测试，以加快应用程序开发速度，并使其在复杂性增加时不留下错误。
- en: You will gain familiarity with the most popular testing framework and slang;
    after completing the recipes, you will be able to confidently ship software that
    works just as expected.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这些示例后，您将熟悉最流行的测试框架和术语；您将能够自信地发布按预期工作的软件。
- en: Using Jasmine for testing Vue
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jasmine进行Vue测试
- en: Jasmine is a library for testing, it's very easy to use and it's capable of
    displaying the results of the tests directly in the browser. In this recipe, you
    will build a simple Vue application and you will test it with Jasmine.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine是一个用于测试的库，非常易于使用，并且能够直接在浏览器中显示测试结果。在这个示例中，您将构建一个简单的Vue应用程序，并使用Jasmine进行测试。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: I hope you don't start learning Vue with this recipe because I'm going to assume,
    as I will with the rest of the chapter, that you already know the basics of building
    simple applications in Vue.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您不是从这个示例开始学习Vue，因为我将假设，就像本章的其他部分一样，您已经了解了在Vue中构建简单应用程序的基础知识。
- en: 'You should also be able to find four files on the Internet. I will write the
    link as I found them at writing time but, of course, they may change:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应该能够在互联网上找到四个文件。我将在写作时提供链接，但是当然，它们可能会发生变化：
- en: '[https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.5.2/jasmine.css](https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.5.2/jasmine.css)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.5.2/jasmine.css](https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.5.2/jasmine.css)'
- en: '[https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.5.2/jasmine.js](https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.5.2/jasmine.js)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.5.2/jasmine.js
- en: '[https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.5.2/jasmine-html.js](https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.5.2/jasmine-html.js)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.5.2/jasmine-html.js](https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.5.2/jasmine-html.js)
    的中文翻译如下：'
- en: '[https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.5.2/boot.js](https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.5.2/boot.js)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.5.2/boot.js
- en: You can conveniently copy-paste all the links from the [https://cdnjs.com/libraries/jasmine](https://cdnjs.com/libraries/jasmine)
     page.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以方便地从[https://cdnjs.com/libraries/jasmine](https://cdnjs.com/libraries/jasmine)页面复制粘贴所有链接。
- en: The files are dependent on each other, so the order in which you add them matters!
    In particular, `boot.js` is dependent on `jasmine-html.js` , which is dependent
    on `jasmine.js` .
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件彼此依赖，因此添加它们的顺序很重要！特别是，`boot.js` 依赖于 `jasmine-html.js`，而 `jasmine-html.js`
    又依赖于 `jasmine.js`。
- en: How to do it...
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Jasmine is a library composed of various modules. To make it work, you need
    to install a few dependencies related to Jasmine. I will assume that you are using
    JSFiddle to follow along. If you are using npm or other methods instead, you should
    be able to derive what you need to change as the code will be simple in principle.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine是一个由各种模块组成的库。为了使其工作，您需要安装一些与Jasmine相关的依赖项。我假设您正在使用JSFiddle进行操作。如果您使用的是npm或其他方法，您应该能够根据原则简单地推导出需要更改的内容。
- en: To install Jasmine in your app, you will need four different dependencies, of
    which one is just for CSS styling.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的应用程序中安装Jasmine，您将需要四个不同的依赖项，其中一个仅用于CSS样式。
- en: 'The four files are (*in order of dependence* ):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个文件的顺序（按依赖关系排序）是：
- en: '`jasmine.css`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jasmine.css`'
- en: '`jasmine.js`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jasmine.js` 是一个用于 JavaScript 测试的开源框架。它提供了一套简洁的语法和功能，用于编写和执行单元测试和集成测试。`jasmine.js`
    可以帮助开发人员轻松地编写可靠的测试用例，以确保代码的质量和稳定性。无论是在前端还是后端开发中，`jasmine.js` 都是一个非常有用的工具。'
- en: '`jasmine-html.js` (which depends on the preceding js)'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jasmine-html.js`（依赖于前面的js文件）'
- en: '`boot.js` (which depends on the preceding js)'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boot.js`（依赖于前面的js文件）'
- en: You should be able to find all these files on CDNJS or other CDNs. Install them
    in the order shown, or they won't work properly.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够在CDNJS或其他CDN上找到所有这些文件。按照显示的顺序安装它们，否则它们将无法正常工作。
- en: 'When you have all the files in place, write the following HTML code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当你把所有文件放好后，写下以下HTML代码：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the following script as the JavaScript part:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
- en: You can launch the application now and, as expected, the `Hello World`  message
    should appear on the screen.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: We would like to be 100% sure that our application always displays this message
    when we make modifications to it and add new features.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'Jasmine will help us in this regard. Just after the Vue instance, we write
    the following JavaScript:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
- en: In order for this to work in JSFiddle, Load Type needs to be set to No wrap
    - in <body> . If you keep the default Load Type onLoad , it will load Jasmine
    before Vue has a chance to start.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Now try and launch the application. You will see a detailed report by Jasmine
    at the end of the page that tells you weather there is something wrong with your
    app.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything goes as expected, you should see a happy green bar, like the
    following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00131.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You wrote your very first unit test for a Vue application. If you write unit
    tests already, everything should be quite clear since we have not used any feature
    unique to Vue to write the test.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: In any case, let's spend a little time analyzing the code we have written; after
    that, I'll provide some considerations about when you should write similar tests
    when writing a real application.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: The test we wrote displays `my app should say Hello World` when you read it
    as a sentence on the web page.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a fairly generic message; however, let''s look at the code closely:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
- en: Read it as an English phrase--we expect the `<p>` element inside the document
    to contain the text `Hello World` .
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: The `document.querySelector('p')` code selects the first `p` element inside
    the page, to be precise. `innerText` looks inside the HTML element and returns
    the readable text that's inside. We then verify that this text contains `Hello
    World` .
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: In a real application, you wouldn't write the tests just under your web pages.
    Tests are of great importance to a developer to check whether everything is working
    correctly without manually verifying every single feature after every code change.
    On the other hand, you don't want your users to see the results of your tests.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: In general, you will have a dedicated page, accessible only by developers, that
    runs all the tests for you.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a widespread practice in software called **TDD** or **Test-Driven Development**
    . It encourages you to think about the features of your software as tests. This,
    in turn, enables you to ensure that the features in your software work because
    the tests themselves work.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: In this bit, we will add a feature to our recipe using TDD. We want the page
    to have a header that says `Welcome` .
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will write a (failing) test for the feature inside the `describe`
     function after the hello world test:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
- en: 'When we launch the test, we should see it fail:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00132.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
- en: Now, don't pay too much attention to the stack trace. The important thing you
    should note is that we have the name of the test that is failing (the other test
    is still working.)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: It's important to write the test and see that it fails before implementing the
    feature itself. To understand why, try to imagine that we write the test before
    implementing the feature, then we launch it, and then it succeeds. It would mean
    that the test is not really working because we never implemented the feature in
    the first place.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: If you think this is just strange and impossible, think again. In practice,
    it often happens that a test that seems perfectly okay is not testing anything
    in reality and will always succeed, even if the feature is broken.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we are ready to actually implement the feature. We edit the
    HTML layout, like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
- en: 'When we launch the page, the result should be similar to this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00133.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: Adding some Karma to your workflow
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Karma is a JavaScript test runner. This means that it will run your tests for
    you. Software often grows quickly and Karma gives you a way to run all your unit
    tests at once. It also gives you the power to add tools that monitor for test
    coverage and code quality.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Karma is used traditionally in Vue projects and is present in the official Vue
    templates as a tool. Learning Karma is a great addition for your JavaScript toolbelt
    even if you are not working with Vue.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I would consider having completed the *Using Jasmine for testing Vue*  recipe
    a prerequisite. Since Karma is a test runner, you should first be able to write
    a test.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: We will use npm in this recipe, so you should first read the basics on how to
    use it in the *Choosing a development environment*  recipe.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we will need the command line and npm, so be sure to have it
    installed before moving ahead.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'In a new folder, create a file named `package.json` and write the following
    inside it:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
- en: Just having this file in your folder creates a new npm project. We will edit
    this file later.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'In your command line, go to the directory where your project is and type the
    following command inside it to install the necessary dependencies:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
- en: This will install Vue along with Karma, Jasmine, and a couple of plugins of
    Karma as dependencies of our project.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: If you take a look at the `package.json` now, you will see that it has changed
    accordingly.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'The next command will create a file named `karma.conf.js` that will contain
    the configuration for Karma:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
- en: This will ask you some questions, just leave the default for all the questions
    except when it asks you the location of your source and test files. For that question,
    just write `*.js` . After this, you should be able to see the `karma.conf.js`
     file in your directory. Open it and take a quick look at all the settings you
    just set by answering the questions.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Karma doesn''t know about Vue natively, you''ll need to perform a small
    modification to add Vue as a dependency to Karma. There are a couple of ways to
    do this; the quickest is probably to add a line to the list of the files you want
    to load. In the `karma.conf.js`  file, add the following line in the `files` array:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
- en: Note that when you answered the question, you could have also added the line
    directly.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to write the application we want to test.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'In your folder, create a file named `myApp.js` ; inside it, write the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
- en: The object we are assigning to `myApp` is just a simple Vue instance.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will create a test for it. Specifically, we will check weather the
    `Hello World`  text is contained somewhere in the component.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `test.js` and write the following inside it:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
- en: The `beforeEach` block will run before each test (now we have only one), resetting
    the state of our Vue app before checking additional features.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now in a position to run our test. Write the following command in your
    terminal:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
- en: 'You should see Chrome starting and if you go back to your command line, you
    should receive a message similar to this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00134.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: This means that your tests worked successfully.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After your recipe is complete, you should note the general structure of your
    application. You have the application itself in `myApp.js` , and then you have
    your tests in `test.js` . You have some configuration files, such as `karma.conf.js`
    and `package.json` , and you have your libraries inside the `node_modules`  directory.
    All these files work together to make your application testable.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: In a real application, you will probably have more files for the source code
    and for the test, while the configuration files usually grow much slower.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: In this whole setup, you may be wondering how you launch the application itself.
    After all, there is no HTML and the only thing we launched are tests; we've never
    seen this `Hello World`  program.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, you are right; there is no program to launch here. As a matter of
    fact, we had to write a fixture for the HTML layout inside the `beforeEach` of
    the tests:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are injecting the HTML, which consists only of a `<div>`
    element (the rest of the layout is inside `myApp.js` ) in the page.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: We then create a new Vue instance, passing the option object contained in the
    `myApp` variable that was defined in `myApp.js` ; we then use the `$mount('#app')`
    Vue API that effectively materializes the application in the `<div>` element we
    just injected.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Calling Karma from inside the `node_modules` directory every time can be annoying.
    There are two ways to make this more pleasant: we can install Karma globally or we
    can add Karma to our npm scripts; we''ll do both.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s add Karma to our npm scripts. Go inside the `package.json` file
    and add the following block:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can type `npm run test` and Karma will automatically launch. The next
    thing we can do is install Karma globally with the following line:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
- en: 'Now we can write commands such as `karma init` and `karma start` , and they
    will be recognized. We can also edit our `package.json` , like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
- en: Testing your application state and methods
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will write a unit test to touch and check the state of our
    Vue instance directly. The advantage of testing the state of our components instead
    of looking for something in our web page is that we don't have to wait for the
    DOM to be updated and that, even if something changes in the HTML layout, the
    state changes much more slowly, reducing the amount of maintenance required for
    our tests.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before trying this recipe, you should complete *Adding some Karma to your workflow*
     as we will describe how to write the test but we won't mention much about the
    setup of the testing environment.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's suppose that we have an application that greets you with `Hello World!`
    , but it also has a button to translate the greeting to Italian, as `Ciao Mondo!`
    .
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, you need to create a new npm project in a new folder. There, you
    can install the dependencies required for this recipe with the following command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
- en: 'To set up Karma like in the previous recipe, run the following command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
- en: 'Leave the default answers, except for the question `What is the location of
    your source and test files ?` ; for that, you should answer with the following
    two lines:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '`node_modules/vue/dist/vue.js`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*.js`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a file called `test.js` and write a `beforeEach` that will bring the
    application back to it''s starting state inside it so that it can be tested independently
    of other tests:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
- en: Note how you are declaring the `vm` variable at the beginning to reference our
    Vue instance.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Just after the `beforeEach`  (but inside the `describe` ), add the following
    (empty for now) test:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
- en: 'In the first part of the test, you will bring the component to the desired
    state (after `toItalian` is called):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
- en: 'Now, we want to check whether the greeting has changed:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
- en: 'Now, to prove to yourself that the state is reset before each test, add the
    following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
- en: If the state is really reset, it should contain the English greeting, and if
    you launch the tests (with the `./node_modules/karma/bin/karma start`  command),
    you'll find that (if there are no errors) indeed it does.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we have the reference to the Vue instance itself, we can access methods
    and status variables directly in our tests.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: I would like you to spend some time appreciating the name of the tests. The
    first is titled `should greet in Italian after toItalian is called` . It doesn't
    make any reference to the page or the graphics, and it doesn't make any assumption
    on preconditions. Note that the button is never clicked on and, as a matter of
    fact, the button is not mentioned in the test title.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Had we titled the test `should display 'Ciao Mondo' when Translate button is
    clicked on` , we would have lied because we never check whether the greeting is
    actually displayed and we never click on the button in our test.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Naming the test the right way is very important in real applications because
    when you have thousands of tests and one breaks, the first thing you read about
    it is the title or what the test should check. If the title is misleading, you
    are in for a lot of time spent chasing after a red herring.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Testing the DOM
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn a technique to quickly test weather the DOM or
    the web page itself is what it is supposed to be, even when the Vue component
    is not present in the page.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, you should have a test setup already up and working; complete
    the *Using* * Jasmine for testing Vue*  recipe if you don't know what that means.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: I will assume that you have Jasmine installed and you can perform tests.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, all you need is a web page (JSFiddle is okay) and these four dependencies
    installed:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '`jasmine.css`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jasmine.js`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jasmine-html.js`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boot.js`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are using JSFiddle or adding them manually, remember to add them in the
    specified order.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Find the link to these files in the *Using Jasmine for testing Vue*  recipe.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's suppose that you are writing a component that displays the `Hello World!`
    greeting; you want to test that the greeting is actually displayed, but the web
    page you are testing is already complex enough and you want to test your component
    in isolation.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Turns out you don't have to actually display the component to prove that it
    works. You can display and test your component outside the document.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following setup for your greeting in your test file or test part
    of your page:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
- en: 'To materialize our Vue instance as an off-document element, we just need to
    add the `$mount()`  API call:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
- en: 'Since we have the reference to `vm` , we can now test our component to access
    the element rendered off-document:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
- en: The `vm.$el`  element represents our component, but it's not reachable from
    the normal DOM.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On initialization, the `Vue` instance checks whether there is an `el` option.
    In our recipes, we usually include an `el` option, but this time we have a template
    instead:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
- en: When the `Vue` instance has the `el` option, it automatically mounts to that
    element (if found); in our case, the Vue instances waits for the `$mount` call
    instead. We don't provide any arguments to the function and so the component gets
    rendered off-document.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the only way to retrieve it in the DOM is through the `$el` property.
    The `$el` property is always present once the component is mounted, irrespective
    of whether the component was mounted manually or automatically.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: From there, we can access it as we would access any normal component and test
    whether everything is as we expect.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Testing DOM asynchronous updates
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Vue, when the status of your component changes, the DOM is changed accordingly;
    that's why we call the status reactive. The only gotcha here is that the update
    is not synchronous; it happens that we have to wait additional time for the changes
    to actually propagate.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, I will assume that you have already completed the *Using* * Jasmine
    for testing Vue*  recipe, and you know how to write a basic test.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The test we will write is an illustration of how Vue's update mechanism works.
    From there, you will then be able to write asynchronous tests on your own.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `beforeEach` function of our test suite, write the following Vue instance:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
- en: This will create a component with a text box and a span element that will contain
    the `Hello from ...`  phrase and whatever is written in the text box.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: What we will do to test this component is write `Herman`  in the text box (programmatically,
    not manually), and then wait for the DOM to update. When the DOM has updated,
    we check whether the `Hello from Herman`  phrase appears.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with an empty test just after the `beforeEach` function:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
- en: The preceding test passes already. Note that we are taking the done argument
    and then we are calling it as a function. The test will not pass until `done()`
    is called.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'Assign the `<span>` element to a variable for convenience and then insert the
    text `Herman`  in to the text box:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
- en: 'While we have to wait for the DOM to update when we modify the state, the opposite
    is not true; when we have modified the DOM, we can already check whether the `name`
    variable has changed:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
- en: Launch the test while you edit it to check whether it works.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will install a listener for the next update cycle of the `Vue` component,
    called a tick:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
- en: 'Everything inside the `$nextTick` block is run only after the DOM is updated.
    We will check that the content of the `<span>` element has changed:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
- en: Note how we also verify that the DOM is unchanged before the tick.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The official documentation states the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: <q>Vue performs DOM updates **asynchronously** . Whenever a data change is observed,
    it will open a queue and buffer all the data changes that happen in the same event
    loop.</q>
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, many tests require the `$nextTick` helper. There is, however,
    an ongoing effort to create better tools to deal with testing and synchronicity
    so, while this recipe illustrates the problem, it might not be the most up-to-date
    method to deal with the test.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: End-to-end testing with nightwatch
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes unit tests just don't cut it. We may need to integrate two features
    developed independently and, while each works and is unit tested, there is no
    easy way to test them along with a unit test. Also, it defeats the purpose of
    unit tests--testing atomic units of the software. Integration testing and e2e
    (end-to-end) testing can be performed in these cases. Nightwatch is software that
    basically mimics a user clicking and typing around in a website. This is probably
    what we want as an ultimate verification that the whole system works.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before beginning your journey in this somewhat advanced recipe, you should already
    be familiar with the command line and npm. Check the *Choosing a development environment*
     recipe if you are not familiar with them.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new folder for this recipe and create a new file inside it, named `index.html`
    .
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'This file will contain our Vue application and it is what we will test. Write
    the following in this file:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this is just the usual boilerplate for a small Vue application.
    Inside the `<div>` , put a header and a button; when we click on the button, the
    text `Hello Nightwatch!` will be displayed:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
- en: 'Inside the script tag, write the following JavaScript to make it work:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
- en: Our application is complete; now we move into the test part of the recipe.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch these commands to install what would be your dependencies:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
- en: This will install the Selenium server, which is necessary to automate browser
    actions, and it is what really makes nightwatch work. The `http-server` command
    will be useful to serve our working website without having to memorize a long
    file path. Finally, it will install nightwatch itself which, for the most part,
    is a wrapper and JavaScript API for Selenium.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'When npm finishes installing all these tools, create a new file, named `nightwatch.json`
    , that will contain the nightwatch configuration and write this inside it:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
- en: The first setting says that you will write all your tests inside a folder called
    tests (which we will create); the second setting just sets Chrome as our default
    browser to run tests into.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Now, create, `test` directory and a `test.js` file inside it. In the file, we
    will test the app. We will verify that when the app launches, the `<p>` tag is
    not visible and that when we click on the button it should appear.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'An empty test will look like this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
- en: Here, the client is the browser (Chrome in this case).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'We will serve our application at the `http://localhost:8080`  address, so first
    we want the browser to go to this address. For this we would write the following
    code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
- en: 'Next, we wait for the page to load; we do this indirectly by waiting for the
    `<div>` with `id="app"` to appear:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
- en: The second argument is the number of milliseconds we are willing to wait before
    considering the test failed.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want to ensure that the header is also displayed correctly and there
    is no `<p>` element visible:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
- en: 'We then click on the button and assert that the `<p>` element is visible and
    contains the word `Nightwatch` :'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
- en: The `end()` function will mark the test as having succeeded, as there are no
    more things to check for.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'To actually launch this test, you will need to launch the following command:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
- en: 'This will install Selenium, then open three different command lines. In the
    first, launch the Selenium server with the following command:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
- en: 'In the second command line, go to the root of your recipe folder, where `index.html`
    is, and launch `http-server` :'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
- en: 'This will tell you after it''s launched that your website is served at `http://localhost:8080`
    . This is just like the address we wrote in our test. You can navigate to it right
    now to see the application running:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00135.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
- en: 'Lastly, in the third command line, again go inside your recipe folder and type
    the following command:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
- en: 'If everything goes well, you will see the browser flashing before your eyes
    and displaying the application for a fraction of a second (depending on the speed
    of your computer), and in the console, you should see something like this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00136.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If this recipe looked like a lot of effort, don't despair, Vue templates already
    have this setup all sorted out inside them. You know how all this machinery works
    but when, in the later recipes, we use Webpack, you will only need one command
    to run e2e tests because everything is already set up.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Note how the title of the end-to-end test is rather generic, and it refers to
    a particular action flow rather than detailing the context and what is expected.
    This is common for e2e tests as you are usually better off building user stories
    and then branching them and naming each branch after a particular scenario. So,
    just to give an example, if we were expecting a response from the server and it
    didn't come back, we could test a scenario in which we give an error and call
    the test *Server error scenario* .
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Simulating a double-click in nightwatch
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is candy for all those who have struggled to simulate a double-click
    in nightwatch. Being one of them in the first place, I'm sympathetic. As it turns
    out, there is a `doubleClick` function in nightwatch but, at least in the opinion
    of the author, it doesn't work as expected.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is for developers who are starting out in nightwatch and struggle
    with this particular problem. You want to learn how to simulate a double-click
    for testing and you don't know nightwatch? Go back one recipe.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: I will assume that your setup with nightwatch is working and you can launch
    tests. I will also assume that you have all the commands installed from the preceding recipe.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s assume that you have the following Vue application in an `index.html`
    file:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
- en: 'Just after the `<div>` element, add this script:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
- en: You can serve your app with `http-server` . Go to `http://localhost:8080` with
    your browser, and you can try double-clicking on the button to make the text appear.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we want to test that, we look at nightwatch's API and discover that
    it has a function call named `doubleClick()` .
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then write a test similar to the one in the preceding recipe:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
- en: 'Except that this won''t work as expected. The right way to do it is the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
- en: Double-click only works if you first *move* to the element you want to double-click
    on; only then you can call `doubleClick` without any argument.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The arguments for the `moveToElement` function are the following:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '`selector` : We used `tag name` as a selector'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tag` /`selector` : We looked for the `button`  tag; had we used another selector
    here, we would have put a different format'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xoffset` : This is where the virtual mouse will be positioned in x coordinates;
    for us, 0 was okay as, even on the edge of a button, clicking is valid'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yoffset` : This is similar to the preceding argument, but on the y-axis'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a range of commands that, after having been brought to the right position,
    can release events. We used `doubleClick` , but there are others as well.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Different styles of unit testing
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've discovered and used Jasmine in the previous recipes. In this recipe, we
    will explore and compare different styles of unit testing. This is particularly
    relevant because Vue templates come with Mocha and Chai preinstalled. Chai enables
    you to write your tests in three different styles.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe doesn't require any particular previous knowledge, but I highly
    suggest that you complete the *Using* * Jasmine for testing Vue* recipe.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe to work, you will need two dependencies: Mocha and Chai. You
    will find them in no time with Google; just remember that Mocha comes in two different
    files: `mocha.js` and `mocha.css` . You will have to add them both if you want
    it to display nicely.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: If you are using JSFiddle, continue as usual; otherwise, just make sure to have
    Vue as well in the dependencies.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'Our HTML layout will look like this:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
- en: The mocha bit is where all the results will be presented.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'In the JavaScript part, write the simplest `Vue` application and assign it
    to a variable:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
- en: We will write a test to see whether the `Hello world`  text really gets displayed.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'Just after the `Vue` application is finished, write the following:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
- en: The preceding code is preparing `mocha` and `chai` (by installing the `describe`
    , `it` and `should`  functions) and then asserting that the inner text of our
    component should contain `Hello World` . Pretty readable, don't you think?
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'You can launch your application and you will see this:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00137.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
- en: 'There are two other ways `chai` lets us write the very same test. The first
    one is as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
- en: 'To use the second one, you have to add `const  expect = chai . expect`  before
    it:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add the `const assert = chai.assert` line before:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
- en: It's idiomatic for the assert style to add a message as an additional argument
    to make a test more verbose when something goes wrong.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chai is a simple library that implements some functions and throws exceptions
    when some conditions are not satisfied. Mocha, on the other hand, runs certain
    bits of code, collects the exceptions, and tries to display them to the user in
    a nice way.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: While it's largely a matter of taste as to what style to use, there are some
    subtle differences between the three styles.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '`Should`  has the added value of being more eloquent and readable. Unfortunately,
    it extends `Object` , adding the `should` function to everything. You shouldn''t
    mind if you don''t know how to react to the last phrase, but the correct way to
    behave is run and scream in pain; never extend `Object` .'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Assert`  means writing a detailed description of every assertion, and this
    is usually good if you write multiple assertions for each test. Personally, I
    consider it a good practice to write at most one assertion per test and concentrate
    on the title for description.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Expect`  does not extend `Object` and is very readable with a good balance,
    and normally I prefer to use it over the other alternatives.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stubbing external API calls with Sinon.JS
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Normally, when you do end-to-end testing and integration testing, you will have
    the backend server running and ready to respond to you. I think there are many
    situations in which this is not desirable. As a frontend developer, you take every
    opportunity to blame the backend guys.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No particular skills are required to complete this recipe, but you should install
    Jasmine as a dependency; this is explained in detail in the *Using* * Jasmine
    for testing Vue*  recipe.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First of all, let's install some dependencies. For this recipe, we will use
    Jasmine to run the whole thing; you can find detailed instructions in the *Using Jasmine
    for testing Vue*  recipe (the four files you'll need are `jasmine.css` , `jasmine.js`
    , `jasmine-html.js` , and `boot.js` , in this order)
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Also, install Sinon.JS and Axios before continuing; you just need to add the
    `js` files relative to them.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 'We will build an application that retrieves a post at the click of a button.
    In the HTML part, write the following:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
- en: 'Instead, the JavaScript part will look like the following:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
- en: 'If you launch your application now, you should be able to see it working:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00138.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
- en: Now we want to test the application, but we don't want to connect to the real
    server. This will take additional time and it will not be reliable; instead, we
    will take a sample correct response from the server and use that instead.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Sinon.JS has the concept of a sandbox. It means that whenever a test starts,
    some dependencies, such as Axios are overwritten. After each test, we can discard
    the sandbox and everything returns to normal.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'An empty test with Sinon.JS looks like the following (add it after the `Vue`
    instance):'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
- en: 'We want to stub the call to the `get` function for axios:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
- en: 'We are overwriting axios here. We are saying that now the `get` method should
    return the `resolved` promise:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
- en: Since we are returning a promise (and we need to return a promise because the
    `retrieve` method is calling `then` on it), we need to wait until it resolves.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 'We can launch the page and see whether it works:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00139.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
- en: If you are using JSFiddle, remember to set Load Type to No wrap - in `<body>`
     or Vue won't get a chance to start.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our case, we used the sandbox to stub a method of one of our dependencies.
    This way, the `get` method of axios never gets fired and we receive an object
    that is similar to what the backend will give us.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Stubbing the API responses will get you isolated from the backend and its quirks.
    If something goes wrong, you won't mind and, moreover, you can run your test without
    relying on the backend running correctly.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: There are many libraries and techniques to stub API calls in general, not only
    related to HTTP. Hopefully, this recipe has given you a head start.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Measuring the coverage of your code
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code coverage is one of the most used and understandable metrics to evaluate
    the quality of a piece of software. If a test exercises a particular portion of
    code, the code is said to be covered. This suggests that that particular portion
    of code is working correctly and has less chance of containing bugs.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before measuring your code coverage, ensure that you complete the  *Adding some
    Karma to your workflow*  recipe as we will be using Karma to help us.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new directory and place a file named `package.json`  in it. Inside
    it, write the following:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
- en: 'This creates an npm project. In the same directory, run the following command
    to install our dependencies:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
- en: The `package.json` file changes accordingly.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: The `karma-coverage` plugin uses the underlying software, Istanbul, to measure
    and display the coverage of our tests.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the next step a little easier, we will install Karma globally (if you
    have not already done it). Run the following command:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
- en: 'When Karma is installed, run the following command in your directory; it will
    create a Karma configuration file:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
- en: 'Answer the default value for all questions except when it asks you the files
    to load; in that case, write the following two lines:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '`node_modules/vue/dist/vue.js`'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*.js`'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leave a blank line after that to confirm.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: This will load Vue and all the files that end with the `js` extension in the
    root of the directory.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Open the file that Karma created; it should be called `karma.conf.js` and it
    should be in your directory along with the other files.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 'There should be a part like the following:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
- en: 'Inside the preprocessors object, insert coverage, as follows:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
- en: This means that we want to preprocess the `myApp.js` file with the coverage
    preprocessor. The `myApp.js` file will contain our application to test.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: 'Just after that, in the `reporters` array, add coverage:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
- en: This will make the coverage reporter print a web page with the coverage measurements.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for the setup to work properly, you need to set another property,
    called `plugins` , between `frameworks`  and `files` :'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
- en: Next, we will write a simple Vue application that we want to test.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `myApp.js` ; we will create a number guessing game.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following inside the file:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
- en: 'The user will input a number and the output will display a hint or a text to
    celebrate victory if the number is right. Add the following status to the `myApp`
    object:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
- en: 'At the top of the file, you can add a `getRandomInt` function, as illustrated:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
- en: 'We also need a computed property to display the hints:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
- en: Our application is complete. Let's test weather it works as expected.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `test.js` at the root of the directory and write the following
    test:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
- en: 'To run the tests, use the following command:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
- en: If the preceding command fails to ask for the `karma-coverage`  plugin to be
    installed when it's already installed, you can either install the plugin globally
    or use the locally installed Karma to run the tests from `./node-modules/karma/bin/karma
    start` .
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: If your browser opens, go back to the console and, when the test finishes, hit
    *Ctrl* + *C* to stop Karma.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything went well, you should have a new folder named coverage with a
    directory named Chrome inside it. You should also find a file named `index.html`
    inside it. Open it, and you will see a page like this:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00140.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
- en: Right from the start, we can see that yellow indicates that something is wrong.
    We tested 100% of the functions but only 50% of the if branches.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 'If you navigate through and open the details of the `myApp.js` file, you will
    see that we are not testing two branches of the `if` statement:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00141.jpg)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
- en: We can have errors inside those branches and we may not even know it!
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: 'Try adding these two tests inside the test file:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
- en: 'Now if you run the test and open the report, it looks much greener:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00142.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We never even opened the application, but we are already pretty sure that it
    works correctly, thanks to our tests.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we have a report that shows us that we covered 100% of the code.
    Although we have only tested the guessing game for three numbers, we covered all
    the possible branches.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: We will never be sure that our software is free of bugs, but these kinds of
    tool help us developers a great deal in adding features to our software without
    having nightmares that we might have broken something.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
