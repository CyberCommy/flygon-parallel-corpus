- en: Unit Testing and End-to-End Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, the following recipes will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Jasmine for testing Vue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding some Karma to your workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing your application state and methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the DOM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing DOM asynchronous updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: End-to-end testing with nightwatch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating a double-click in nightwatch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different styles of unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stubbing external API calls with Sinon.JS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measuring the coverage of your code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is what really differentiates professional software from amateur software.
    From industry experience and studies, it has been discovered that much of the
    cost of software lies in correcting bugs while the software is in production.
    Testing software reduces bugs in production and makes correcting those bugs much
    less expensive.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to set up your test harness and how to write
    unit tests and integration tests that will help speed up your app development
    and help it grow in complexity without leaving bugs behind.
  prefs: []
  type: TYPE_NORMAL
- en: You will gain familiarity with the most popular testing framework and slang;
    after completing the recipes, you will be able to confidently ship software that
    works just as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Using Jasmine for testing Vue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jasmine is a library for testing, it's very easy to use and it's capable of
    displaying the results of the tests directly in the browser. In this recipe, you
    will build a simple Vue application and you will test it with Jasmine.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope you don't start learning Vue with this recipe because I'm going to assume,
    as I will with the rest of the chapter, that you already know the basics of building
    simple applications in Vue.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should also be able to find four files on the Internet. I will write the
    link as I found them at writing time but, of course, they may change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.5.2/jasmine.css](https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.5.2/jasmine.css)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.5.2/jasmine.js](https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.5.2/jasmine.js)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.5.2/jasmine-html.js](https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.5.2/jasmine-html.js)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.5.2/boot.js](https://cdnjs.cloudflare.com/ajax/libs/jasmine/2.5.2/boot.js)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can conveniently copy-paste all the links from the [https://cdnjs.com/libraries/jasmine](https://cdnjs.com/libraries/jasmine)
     page.
  prefs: []
  type: TYPE_NORMAL
- en: The files are dependent on each other, so the order in which you add them matters!
    In particular, `boot.js` is dependent on `jasmine-html.js` , which is dependent
    on `jasmine.js` .
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jasmine is a library composed of various modules. To make it work, you need
    to install a few dependencies related to Jasmine. I will assume that you are using
    JSFiddle to follow along. If you are using npm or other methods instead, you should
    be able to derive what you need to change as the code will be simple in principle.
  prefs: []
  type: TYPE_NORMAL
- en: To install Jasmine in your app, you will need four different dependencies, of
    which one is just for CSS styling.
  prefs: []
  type: TYPE_NORMAL
- en: 'The four files are (*in order of dependence* ):'
  prefs: []
  type: TYPE_NORMAL
- en: '`jasmine.css`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jasmine.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jasmine-html.js` (which depends on the preceding js)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boot.js` (which depends on the preceding js)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should be able to find all these files on CDNJS or other CDNs. Install them
    in the order shown, or they won't work properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you have all the files in place, write the following HTML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the following script as the JavaScript part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can launch the application now and, as expected, the `Hello World`  message
    should appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: We would like to be 100% sure that our application always displays this message
    when we make modifications to it and add new features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Jasmine will help us in this regard. Just after the Vue instance, we write
    the following JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In order for this to work in JSFiddle, Load Type needs to be set to No wrap
    - in <body> . If you keep the default Load Type onLoad , it will load Jasmine
    before Vue has a chance to start.
  prefs: []
  type: TYPE_NORMAL
- en: Now try and launch the application. You will see a detailed report by Jasmine
    at the end of the page that tells you weather there is something wrong with your
    app.
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything goes as expected, you should see a happy green bar, like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00131.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You wrote your very first unit test for a Vue application. If you write unit
    tests already, everything should be quite clear since we have not used any feature
    unique to Vue to write the test.
  prefs: []
  type: TYPE_NORMAL
- en: In any case, let's spend a little time analyzing the code we have written; after
    that, I'll provide some considerations about when you should write similar tests
    when writing a real application.
  prefs: []
  type: TYPE_NORMAL
- en: The test we wrote displays `my app should say Hello World` when you read it
    as a sentence on the web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a fairly generic message; however, let''s look at the code closely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Read it as an English phrase--we expect the `<p>` element inside the document
    to contain the text `Hello World` .
  prefs: []
  type: TYPE_NORMAL
- en: The `document.querySelector('p')` code selects the first `p` element inside
    the page, to be precise. `innerText` looks inside the HTML element and returns
    the readable text that's inside. We then verify that this text contains `Hello
    World` .
  prefs: []
  type: TYPE_NORMAL
- en: In a real application, you wouldn't write the tests just under your web pages.
    Tests are of great importance to a developer to check whether everything is working
    correctly without manually verifying every single feature after every code change.
    On the other hand, you don't want your users to see the results of your tests.
  prefs: []
  type: TYPE_NORMAL
- en: In general, you will have a dedicated page, accessible only by developers, that
    runs all the tests for you.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a widespread practice in software called **TDD** or **Test-Driven Development**
    . It encourages you to think about the features of your software as tests. This,
    in turn, enables you to ensure that the features in your software work because
    the tests themselves work.
  prefs: []
  type: TYPE_NORMAL
- en: In this bit, we will add a feature to our recipe using TDD. We want the page
    to have a header that says `Welcome` .
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will write a (failing) test for the feature inside the `describe`
     function after the hello world test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When we launch the test, we should see it fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00132.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, don't pay too much attention to the stack trace. The important thing you
    should note is that we have the name of the test that is failing (the other test
    is still working.)
  prefs: []
  type: TYPE_NORMAL
- en: It's important to write the test and see that it fails before implementing the
    feature itself. To understand why, try to imagine that we write the test before
    implementing the feature, then we launch it, and then it succeeds. It would mean
    that the test is not really working because we never implemented the feature in
    the first place.
  prefs: []
  type: TYPE_NORMAL
- en: If you think this is just strange and impossible, think again. In practice,
    it often happens that a test that seems perfectly okay is not testing anything
    in reality and will always succeed, even if the feature is broken.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we are ready to actually implement the feature. We edit the
    HTML layout, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When we launch the page, the result should be similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00133.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding some Karma to your workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Karma is a JavaScript test runner. This means that it will run your tests for
    you. Software often grows quickly and Karma gives you a way to run all your unit
    tests at once. It also gives you the power to add tools that monitor for test
    coverage and code quality.
  prefs: []
  type: TYPE_NORMAL
- en: Karma is used traditionally in Vue projects and is present in the official Vue
    templates as a tool. Learning Karma is a great addition for your JavaScript toolbelt
    even if you are not working with Vue.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I would consider having completed the *Using Jasmine for testing Vue*  recipe
    a prerequisite. Since Karma is a test runner, you should first be able to write
    a test.
  prefs: []
  type: TYPE_NORMAL
- en: We will use npm in this recipe, so you should first read the basics on how to
    use it in the *Choosing a development environment*  recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we will need the command line and npm, so be sure to have it
    installed before moving ahead.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a new folder, create a file named `package.json` and write the following
    inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Just having this file in your folder creates a new npm project. We will edit
    this file later.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your command line, go to the directory where your project is and type the
    following command inside it to install the necessary dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This will install Vue along with Karma, Jasmine, and a couple of plugins of
    Karma as dependencies of our project.
  prefs: []
  type: TYPE_NORMAL
- en: If you take a look at the `package.json` now, you will see that it has changed
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next command will create a file named `karma.conf.js` that will contain
    the configuration for Karma:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will ask you some questions, just leave the default for all the questions
    except when it asks you the location of your source and test files. For that question,
    just write `*.js` . After this, you should be able to see the `karma.conf.js`
     file in your directory. Open it and take a quick look at all the settings you
    just set by answering the questions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Karma doesn''t know about Vue natively, you''ll need to perform a small
    modification to add Vue as a dependency to Karma. There are a couple of ways to
    do this; the quickest is probably to add a line to the list of the files you want
    to load. In the `karma.conf.js`  file, add the following line in the `files` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that when you answered the question, you could have also added the line
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to write the application we want to test.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your folder, create a file named `myApp.js` ; inside it, write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The object we are assigning to `myApp` is just a simple Vue instance.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will create a test for it. Specifically, we will check weather the
    `Hello World`  text is contained somewhere in the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `test.js` and write the following inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `beforeEach` block will run before each test (now we have only one), resetting
    the state of our Vue app before checking additional features.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now in a position to run our test. Write the following command in your
    terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see Chrome starting and if you go back to your command line, you
    should receive a message similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00134.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This means that your tests worked successfully.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After your recipe is complete, you should note the general structure of your
    application. You have the application itself in `myApp.js` , and then you have
    your tests in `test.js` . You have some configuration files, such as `karma.conf.js`
    and `package.json` , and you have your libraries inside the `node_modules`  directory.
    All these files work together to make your application testable.
  prefs: []
  type: TYPE_NORMAL
- en: In a real application, you will probably have more files for the source code
    and for the test, while the configuration files usually grow much slower.
  prefs: []
  type: TYPE_NORMAL
- en: In this whole setup, you may be wondering how you launch the application itself.
    After all, there is no HTML and the only thing we launched are tests; we've never
    seen this `Hello World`  program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, you are right; there is no program to launch here. As a matter of
    fact, we had to write a fixture for the HTML layout inside the `beforeEach` of
    the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are injecting the HTML, which consists only of a `<div>`
    element (the rest of the layout is inside `myApp.js` ) in the page.
  prefs: []
  type: TYPE_NORMAL
- en: We then create a new Vue instance, passing the option object contained in the
    `myApp` variable that was defined in `myApp.js` ; we then use the `$mount('#app')`
    Vue API that effectively materializes the application in the `<div>` element we
    just injected.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Calling Karma from inside the `node_modules` directory every time can be annoying.
    There are two ways to make this more pleasant: we can install Karma globally or we
    can add Karma to our npm scripts; we''ll do both.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s add Karma to our npm scripts. Go inside the `package.json` file
    and add the following block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can type `npm run test` and Karma will automatically launch. The next
    thing we can do is install Karma globally with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can write commands such as `karma init` and `karma start` , and they
    will be recognized. We can also edit our `package.json` , like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Testing your application state and methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will write a unit test to touch and check the state of our
    Vue instance directly. The advantage of testing the state of our components instead
    of looking for something in our web page is that we don't have to wait for the
    DOM to be updated and that, even if something changes in the HTML layout, the
    state changes much more slowly, reducing the amount of maintenance required for
    our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before trying this recipe, you should complete *Adding some Karma to your workflow*
     as we will describe how to write the test but we won't mention much about the
    setup of the testing environment.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's suppose that we have an application that greets you with `Hello World!`
    , but it also has a button to translate the greeting to Italian, as `Ciao Mondo!`
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, you need to create a new npm project in a new folder. There, you
    can install the dependencies required for this recipe with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To set up Karma like in the previous recipe, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Leave the default answers, except for the question `What is the location of
    your source and test files ?` ; for that, you should answer with the following
    two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '`node_modules/vue/dist/vue.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a file called `test.js` and write a `beforeEach` that will bring the
    application back to it''s starting state inside it so that it can be tested independently
    of other tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note how you are declaring the `vm` variable at the beginning to reference our
    Vue instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just after the `beforeEach`  (but inside the `describe` ), add the following
    (empty for now) test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first part of the test, you will bring the component to the desired
    state (after `toItalian` is called):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we want to check whether the greeting has changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to prove to yourself that the state is reset before each test, add the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If the state is really reset, it should contain the English greeting, and if
    you launch the tests (with the `./node_modules/karma/bin/karma start`  command),
    you'll find that (if there are no errors) indeed it does.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we have the reference to the Vue instance itself, we can access methods
    and status variables directly in our tests.
  prefs: []
  type: TYPE_NORMAL
- en: I would like you to spend some time appreciating the name of the tests. The
    first is titled `should greet in Italian after toItalian is called` . It doesn't
    make any reference to the page or the graphics, and it doesn't make any assumption
    on preconditions. Note that the button is never clicked on and, as a matter of
    fact, the button is not mentioned in the test title.
  prefs: []
  type: TYPE_NORMAL
- en: Had we titled the test `should display 'Ciao Mondo' when Translate button is
    clicked on` , we would have lied because we never check whether the greeting is
    actually displayed and we never click on the button in our test.
  prefs: []
  type: TYPE_NORMAL
- en: Naming the test the right way is very important in real applications because
    when you have thousands of tests and one breaks, the first thing you read about
    it is the title or what the test should check. If the title is misleading, you
    are in for a lot of time spent chasing after a red herring.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the DOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn a technique to quickly test weather the DOM or
    the web page itself is what it is supposed to be, even when the Vue component
    is not present in the page.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, you should have a test setup already up and working; complete
    the *Using* * Jasmine for testing Vue*  recipe if you don't know what that means.
  prefs: []
  type: TYPE_NORMAL
- en: I will assume that you have Jasmine installed and you can perform tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, all you need is a web page (JSFiddle is okay) and these four dependencies
    installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`jasmine.css`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jasmine.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jasmine-html.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boot.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are using JSFiddle or adding them manually, remember to add them in the
    specified order.
  prefs: []
  type: TYPE_NORMAL
- en: Find the link to these files in the *Using Jasmine for testing Vue*  recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's suppose that you are writing a component that displays the `Hello World!`
    greeting; you want to test that the greeting is actually displayed, but the web
    page you are testing is already complex enough and you want to test your component
    in isolation.
  prefs: []
  type: TYPE_NORMAL
- en: Turns out you don't have to actually display the component to prove that it
    works. You can display and test your component outside the document.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following setup for your greeting in your test file or test part
    of your page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To materialize our Vue instance as an off-document element, we just need to
    add the `$mount()`  API call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we have the reference to `vm` , we can now test our component to access
    the element rendered off-document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `vm.$el`  element represents our component, but it's not reachable from
    the normal DOM.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On initialization, the `Vue` instance checks whether there is an `el` option.
    In our recipes, we usually include an `el` option, but this time we have a template
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: When the `Vue` instance has the `el` option, it automatically mounts to that
    element (if found); in our case, the Vue instances waits for the `$mount` call
    instead. We don't provide any arguments to the function and so the component gets
    rendered off-document.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the only way to retrieve it in the DOM is through the `$el` property.
    The `$el` property is always present once the component is mounted, irrespective
    of whether the component was mounted manually or automatically.
  prefs: []
  type: TYPE_NORMAL
- en: From there, we can access it as we would access any normal component and test
    whether everything is as we expect.
  prefs: []
  type: TYPE_NORMAL
- en: Testing DOM asynchronous updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Vue, when the status of your component changes, the DOM is changed accordingly;
    that's why we call the status reactive. The only gotcha here is that the update
    is not synchronous; it happens that we have to wait additional time for the changes
    to actually propagate.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, I will assume that you have already completed the *Using* * Jasmine
    for testing Vue*  recipe, and you know how to write a basic test.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The test we will write is an illustration of how Vue's update mechanism works.
    From there, you will then be able to write asynchronous tests on your own.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `beforeEach` function of our test suite, write the following Vue instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This will create a component with a text box and a span element that will contain
    the `Hello from ...`  phrase and whatever is written in the text box.
  prefs: []
  type: TYPE_NORMAL
- en: What we will do to test this component is write `Herman`  in the text box (programmatically,
    not manually), and then wait for the DOM to update. When the DOM has updated,
    we check whether the `Hello from Herman`  phrase appears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with an empty test just after the `beforeEach` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The preceding test passes already. Note that we are taking the done argument
    and then we are calling it as a function. The test will not pass until `done()`
    is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assign the `<span>` element to a variable for convenience and then insert the
    text `Herman`  in to the text box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'While we have to wait for the DOM to update when we modify the state, the opposite
    is not true; when we have modified the DOM, we can already check whether the `name`
    variable has changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Launch the test while you edit it to check whether it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will install a listener for the next update cycle of the `Vue` component,
    called a tick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything inside the `$nextTick` block is run only after the DOM is updated.
    We will check that the content of the `<span>` element has changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note how we also verify that the DOM is unchanged before the tick.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The official documentation states the following:'
  prefs: []
  type: TYPE_NORMAL
- en: <q>Vue performs DOM updates **asynchronously** . Whenever a data change is observed,
    it will open a queue and buffer all the data changes that happen in the same event
    loop.</q>
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, many tests require the `$nextTick` helper. There is, however,
    an ongoing effort to create better tools to deal with testing and synchronicity
    so, while this recipe illustrates the problem, it might not be the most up-to-date
    method to deal with the test.
  prefs: []
  type: TYPE_NORMAL
- en: End-to-end testing with nightwatch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes unit tests just don't cut it. We may need to integrate two features
    developed independently and, while each works and is unit tested, there is no
    easy way to test them along with a unit test. Also, it defeats the purpose of
    unit tests--testing atomic units of the software. Integration testing and e2e
    (end-to-end) testing can be performed in these cases. Nightwatch is software that
    basically mimics a user clicking and typing around in a website. This is probably
    what we want as an ultimate verification that the whole system works.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before beginning your journey in this somewhat advanced recipe, you should already
    be familiar with the command line and npm. Check the *Choosing a development environment*
     recipe if you are not familiar with them.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new folder for this recipe and create a new file inside it, named `index.html`
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'This file will contain our Vue application and it is what we will test. Write
    the following in this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this is just the usual boilerplate for a small Vue application.
    Inside the `<div>` , put a header and a button; when we click on the button, the
    text `Hello Nightwatch!` will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the script tag, write the following JavaScript to make it work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Our application is complete; now we move into the test part of the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch these commands to install what would be your dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This will install the Selenium server, which is necessary to automate browser
    actions, and it is what really makes nightwatch work. The `http-server` command
    will be useful to serve our working website without having to memorize a long
    file path. Finally, it will install nightwatch itself which, for the most part,
    is a wrapper and JavaScript API for Selenium.
  prefs: []
  type: TYPE_NORMAL
- en: 'When npm finishes installing all these tools, create a new file, named `nightwatch.json`
    , that will contain the nightwatch configuration and write this inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The first setting says that you will write all your tests inside a folder called
    tests (which we will create); the second setting just sets Chrome as our default
    browser to run tests into.
  prefs: []
  type: TYPE_NORMAL
- en: Now, create, `test` directory and a `test.js` file inside it. In the file, we
    will test the app. We will verify that when the app launches, the `<p>` tag is
    not visible and that when we click on the button it should appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'An empty test will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here, the client is the browser (Chrome in this case).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will serve our application at the `http://localhost:8080`  address, so first
    we want the browser to go to this address. For this we would write the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we wait for the page to load; we do this indirectly by waiting for the
    `<div>` with `id="app"` to appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The second argument is the number of milliseconds we are willing to wait before
    considering the test failed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want to ensure that the header is also displayed correctly and there
    is no `<p>` element visible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We then click on the button and assert that the `<p>` element is visible and
    contains the word `Nightwatch` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `end()` function will mark the test as having succeeded, as there are no
    more things to check for.
  prefs: []
  type: TYPE_NORMAL
- en: 'To actually launch this test, you will need to launch the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This will install Selenium, then open three different command lines. In the
    first, launch the Selenium server with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second command line, go to the root of your recipe folder, where `index.html`
    is, and launch `http-server` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This will tell you after it''s launched that your website is served at `http://localhost:8080`
    . This is just like the address we wrote in our test. You can navigate to it right
    now to see the application running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00135.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Lastly, in the third command line, again go inside your recipe folder and type
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything goes well, you will see the browser flashing before your eyes
    and displaying the application for a fraction of a second (depending on the speed
    of your computer), and in the console, you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00136.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If this recipe looked like a lot of effort, don't despair, Vue templates already
    have this setup all sorted out inside them. You know how all this machinery works
    but when, in the later recipes, we use Webpack, you will only need one command
    to run e2e tests because everything is already set up.
  prefs: []
  type: TYPE_NORMAL
- en: Note how the title of the end-to-end test is rather generic, and it refers to
    a particular action flow rather than detailing the context and what is expected.
    This is common for e2e tests as you are usually better off building user stories
    and then branching them and naming each branch after a particular scenario. So,
    just to give an example, if we were expecting a response from the server and it
    didn't come back, we could test a scenario in which we give an error and call
    the test *Server error scenario* .
  prefs: []
  type: TYPE_NORMAL
- en: Simulating a double-click in nightwatch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is candy for all those who have struggled to simulate a double-click
    in nightwatch. Being one of them in the first place, I'm sympathetic. As it turns
    out, there is a `doubleClick` function in nightwatch but, at least in the opinion
    of the author, it doesn't work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is for developers who are starting out in nightwatch and struggle
    with this particular problem. You want to learn how to simulate a double-click
    for testing and you don't know nightwatch? Go back one recipe.
  prefs: []
  type: TYPE_NORMAL
- en: I will assume that your setup with nightwatch is working and you can launch
    tests. I will also assume that you have all the commands installed from the preceding recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s assume that you have the following Vue application in an `index.html`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Just after the `<div>` element, add this script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: You can serve your app with `http-server` . Go to `http://localhost:8080` with
    your browser, and you can try double-clicking on the button to make the text appear.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we want to test that, we look at nightwatch's API and discover that
    it has a function call named `doubleClick()` .
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then write a test similar to the one in the preceding recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Except that this won''t work as expected. The right way to do it is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Double-click only works if you first *move* to the element you want to double-click
    on; only then you can call `doubleClick` without any argument.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The arguments for the `moveToElement` function are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`selector` : We used `tag name` as a selector'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tag` /`selector` : We looked for the `button`  tag; had we used another selector
    here, we would have put a different format'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xoffset` : This is where the virtual mouse will be positioned in x coordinates;
    for us, 0 was okay as, even on the edge of a button, clicking is valid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yoffset` : This is similar to the preceding argument, but on the y-axis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a range of commands that, after having been brought to the right position,
    can release events. We used `doubleClick` , but there are others as well.
  prefs: []
  type: TYPE_NORMAL
- en: Different styles of unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've discovered and used Jasmine in the previous recipes. In this recipe, we
    will explore and compare different styles of unit testing. This is particularly
    relevant because Vue templates come with Mocha and Chai preinstalled. Chai enables
    you to write your tests in three different styles.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe doesn't require any particular previous knowledge, but I highly
    suggest that you complete the *Using* * Jasmine for testing Vue* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe to work, you will need two dependencies: Mocha and Chai. You
    will find them in no time with Google; just remember that Mocha comes in two different
    files: `mocha.js` and `mocha.css` . You will have to add them both if you want
    it to display nicely.'
  prefs: []
  type: TYPE_NORMAL
- en: If you are using JSFiddle, continue as usual; otherwise, just make sure to have
    Vue as well in the dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our HTML layout will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The mocha bit is where all the results will be presented.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the JavaScript part, write the simplest `Vue` application and assign it
    to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We will write a test to see whether the `Hello world`  text really gets displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just after the `Vue` application is finished, write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is preparing `mocha` and `chai` (by installing the `describe`
    , `it` and `should`  functions) and then asserting that the inner text of our
    component should contain `Hello World` . Pretty readable, don't you think?
  prefs: []
  type: TYPE_NORMAL
- en: 'You can launch your application and you will see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00137.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are two other ways `chai` lets us write the very same test. The first
    one is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the second one, you have to add `const  expect = chai . expect`  before
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add the `const assert = chai.assert` line before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: It's idiomatic for the assert style to add a message as an additional argument
    to make a test more verbose when something goes wrong.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chai is a simple library that implements some functions and throws exceptions
    when some conditions are not satisfied. Mocha, on the other hand, runs certain
    bits of code, collects the exceptions, and tries to display them to the user in
    a nice way.
  prefs: []
  type: TYPE_NORMAL
- en: While it's largely a matter of taste as to what style to use, there are some
    subtle differences between the three styles.
  prefs: []
  type: TYPE_NORMAL
- en: '`Should`  has the added value of being more eloquent and readable. Unfortunately,
    it extends `Object` , adding the `should` function to everything. You shouldn''t
    mind if you don''t know how to react to the last phrase, but the correct way to
    behave is run and scream in pain; never extend `Object` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Assert`  means writing a detailed description of every assertion, and this
    is usually good if you write multiple assertions for each test. Personally, I
    consider it a good practice to write at most one assertion per test and concentrate
    on the title for description.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Expect`  does not extend `Object` and is very readable with a good balance,
    and normally I prefer to use it over the other alternatives.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stubbing external API calls with Sinon.JS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Normally, when you do end-to-end testing and integration testing, you will have
    the backend server running and ready to respond to you. I think there are many
    situations in which this is not desirable. As a frontend developer, you take every
    opportunity to blame the backend guys.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No particular skills are required to complete this recipe, but you should install
    Jasmine as a dependency; this is explained in detail in the *Using* * Jasmine
    for testing Vue*  recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First of all, let's install some dependencies. For this recipe, we will use
    Jasmine to run the whole thing; you can find detailed instructions in the *Using Jasmine
    for testing Vue*  recipe (the four files you'll need are `jasmine.css` , `jasmine.js`
    , `jasmine-html.js` , and `boot.js` , in this order)
  prefs: []
  type: TYPE_NORMAL
- en: Also, install Sinon.JS and Axios before continuing; you just need to add the
    `js` files relative to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will build an application that retrieves a post at the click of a button.
    In the HTML part, write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, the JavaScript part will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'If you launch your application now, you should be able to see it working:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00138.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now we want to test the application, but we don't want to connect to the real
    server. This will take additional time and it will not be reliable; instead, we
    will take a sample correct response from the server and use that instead.
  prefs: []
  type: TYPE_NORMAL
- en: Sinon.JS has the concept of a sandbox. It means that whenever a test starts,
    some dependencies, such as Axios are overwritten. After each test, we can discard
    the sandbox and everything returns to normal.
  prefs: []
  type: TYPE_NORMAL
- en: 'An empty test with Sinon.JS looks like the following (add it after the `Vue`
    instance):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to stub the call to the `get` function for axios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We are overwriting axios here. We are saying that now the `get` method should
    return the `resolved` promise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Since we are returning a promise (and we need to return a promise because the
    `retrieve` method is calling `then` on it), we need to wait until it resolves.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can launch the page and see whether it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00139.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you are using JSFiddle, remember to set Load Type to No wrap - in `<body>`
     or Vue won't get a chance to start.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our case, we used the sandbox to stub a method of one of our dependencies.
    This way, the `get` method of axios never gets fired and we receive an object
    that is similar to what the backend will give us.
  prefs: []
  type: TYPE_NORMAL
- en: Stubbing the API responses will get you isolated from the backend and its quirks.
    If something goes wrong, you won't mind and, moreover, you can run your test without
    relying on the backend running correctly.
  prefs: []
  type: TYPE_NORMAL
- en: There are many libraries and techniques to stub API calls in general, not only
    related to HTTP. Hopefully, this recipe has given you a head start.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring the coverage of your code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code coverage is one of the most used and understandable metrics to evaluate
    the quality of a piece of software. If a test exercises a particular portion of
    code, the code is said to be covered. This suggests that that particular portion
    of code is working correctly and has less chance of containing bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before measuring your code coverage, ensure that you complete the  *Adding some
    Karma to your workflow*  recipe as we will be using Karma to help us.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new directory and place a file named `package.json`  in it. Inside
    it, write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates an npm project. In the same directory, run the following command
    to install our dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The `package.json` file changes accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: The `karma-coverage` plugin uses the underlying software, Istanbul, to measure
    and display the coverage of our tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the next step a little easier, we will install Karma globally (if you
    have not already done it). Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'When Karma is installed, run the following command in your directory; it will
    create a Karma configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Answer the default value for all questions except when it asks you the files
    to load; in that case, write the following two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '`node_modules/vue/dist/vue.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leave a blank line after that to confirm.
  prefs: []
  type: TYPE_NORMAL
- en: This will load Vue and all the files that end with the `js` extension in the
    root of the directory.
  prefs: []
  type: TYPE_NORMAL
- en: Open the file that Karma created; it should be called `karma.conf.js` and it
    should be in your directory along with the other files.
  prefs: []
  type: TYPE_NORMAL
- en: 'There should be a part like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the preprocessors object, insert coverage, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This means that we want to preprocess the `myApp.js` file with the coverage
    preprocessor. The `myApp.js` file will contain our application to test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just after that, in the `reporters` array, add coverage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This will make the coverage reporter print a web page with the coverage measurements.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for the setup to work properly, you need to set another property,
    called `plugins` , between `frameworks`  and `files` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will write a simple Vue application that we want to test.
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `myApp.js` ; we will create a number guessing game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following inside the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The user will input a number and the output will display a hint or a text to
    celebrate victory if the number is right. Add the following status to the `myApp`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'At the top of the file, you can add a `getRandomInt` function, as illustrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need a computed property to display the hints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Our application is complete. Let's test weather it works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `test.js` at the root of the directory and write the following
    test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the tests, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: If the preceding command fails to ask for the `karma-coverage`  plugin to be
    installed when it's already installed, you can either install the plugin globally
    or use the locally installed Karma to run the tests from `./node-modules/karma/bin/karma
    start` .
  prefs: []
  type: TYPE_NORMAL
- en: If your browser opens, go back to the console and, when the test finishes, hit
    *Ctrl* + *C* to stop Karma.
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything went well, you should have a new folder named coverage with a
    directory named Chrome inside it. You should also find a file named `index.html`
    inside it. Open it, and you will see a page like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00140.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Right from the start, we can see that yellow indicates that something is wrong.
    We tested 100% of the functions but only 50% of the if branches.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you navigate through and open the details of the `myApp.js` file, you will
    see that we are not testing two branches of the `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00141.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can have errors inside those branches and we may not even know it!
  prefs: []
  type: TYPE_NORMAL
- en: 'Try adding these two tests inside the test file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if you run the test and open the report, it looks much greener:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00142.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We never even opened the application, but we are already pretty sure that it
    works correctly, thanks to our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we have a report that shows us that we covered 100% of the code.
    Although we have only tested the guessing game for three numbers, we covered all
    the possible branches.
  prefs: []
  type: TYPE_NORMAL
- en: We will never be sure that our software is free of bugs, but these kinds of
    tool help us developers a great deal in adding features to our software without
    having nightmares that we might have broken something.
  prefs: []
  type: TYPE_NORMAL
