- en: List Comprehension and Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Necessity is the Mother of Invention* is a popular English proverb which means
    that any pioneer ideas that have been invented so far or will be invented are
    because of their need. For instance, the giant video hosting platform YouTube
    became popular not only because of its business model but also because of the
    time it was introduced. Many creative artists such as video editors, singers,
    dancers, and gamers wanted the platform to be recognized globally without any
    initial investments, and audiences wanted a platform where they could learn and
    be entertained free of charge. Thus, the need is the driving force for any new
    invention. However, this doesn''t mean that every revolutionary idea that was
    created at the right time succeeded. Some of them have failed miserably because
    they didn''t address the limitations that were posed by the technology. Our quixotic
    imagination is fettered by these technologies, and, although we have been progressing,
    we are not there yet.'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, in order to make any revolutionary ideas successful, we have to know our
    limitations. Our primary limitations are memory space and processing power. Taking
    care of these limitations, this chapter will teach us to write an elegant program
    that will save memory storage and running time to some extent. We will learn about
    the comprehension and generation that are provided by Python. They will make the
    program run faster while maintaining its readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of code complexities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For loop versus list comprehension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decorators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refining the snake game with LC and property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need the following requirements to complete this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Python version 3.5 or newer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python IDLE (Python's built-in IDE)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A text editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A web browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The files for this chapter can be found in this book's GitHub repository: [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter07](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter07)
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2pzX8Au](http://bit.ly/2pzX8Au)'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of code complexities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been learning about the basics of Python, such as functions,
    data structures, and object-oriented programming. Now, we are able to create our
    own logic and even program some games too. As we continue to add features for
    these games, we are expected to have millions of lines of code. Those huge **lines
    of code** (**LOC**) will be hard to understand, interpret, and process. For example,
    in some cases, we may have to make a trade-off between code maintainability and
    optimization. Let's suppose you maintain the code for a shopping website and one
    day you got millions of hits on your website, which is beyond the processing speed
    of your server. Now, you have to accommodate a situation in which you must either
    serve the page without a delay and give the customers no proper recommendations
    about products or serve the page with little delay and give proper recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, we may want to achieve some amount of code optimization.
    If any program takes seconds to execute, then after optimization, we may want
    to run it within a millisecond. Now, we may think this time is negligible, which
    it is on the first run. However, when we have to run the same program a thousand
    times, we may cut off some seconds and this could be potentially useful for any
    real-time applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on the ways we can modify our code to improve
    its quality and efficiency. Any original program can be said to have been optimized
    if we managed to make its code shorter, reduce memory consumption and increase
    its execution speed and the interaction of fewer input/output instructions. The
    basic canonization followed by optimization is that the outcome of the optimization
    must have the same output and consequences as that of the non-optimized one.
  prefs: []
  type: TYPE_NORMAL
- en: However, these requirements may be insignificant whenever the achieved optimized
    program has favorable results over the non-optimized one in terms of time and
    space complexities. For example, in the rocket-launch activities, we may want
    the real-time data of the surrounding area while trading for the accuracy of the
    data. Thus, optimization is important in such cases even though it might affect
    the system's output in one way or another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we learn about optimization, we will look at the necessity for it. In
    order to check the room for optimization, we have to analyze the code first, and
    the prime way to analyze it is by using complexity analysis. Algorithm complexity
    analysis is a tool that will explain the behavior of the program as the size of
    the program increases. The size increases when input to the program increases.
    Thus, we have to check the program against the mathematical `f(n)` function, where
    *n* represents the input to the programs. Now, you may be wondering whether running
    this algorithm may cause a difference in time units, depending on the different
    computers that are used by companies such as NASA or Apple Inc. as they will have
    higher processing power than our simple computer. Therefore, it might be an injustice
    to judge the algorithm that is running on our PC. If you''re ever faced with such
    ambiguity, just pat on yourself on the back as you are thinking like a programmer.
    To test whether the algorithm is independent of processing speed, disk power,
    and powerful software, scientists have developed something called symptotic analysis.
    This analysis will check the algorithm against the size of the input and without
    recording the time it took to execute it. We call this **time complexity**, and
    it allows us to check how the algorithm runs with respect to the size of the input
    data. To observe the time complexity of the algorithm, the best and well-known
    notation we should use is Big-Oh notation. This notation will help us analyze
    the worst-case scenario of the algorithm and help us optimize it. Let''s analyze
    the following complexities using some simple examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`O(1)`: This notation is used to define the algorithms that are independent
    of input size. Increasing or decreasing any sets of data from the input might
    not affect the execution speed of the algorithm:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding program is going to print the first element of the array, no matter
    what data is in it. Thus, it has a time complexity of `O(1)`. This is considered
    a best-case scenario and is hard to achieve in a real-life scenario.
  prefs: []
  type: TYPE_NORMAL
- en: '`O(n)`: This notation describes the algorithm that will have a linear increase
    in running time as the size of the input data, `(n)`, increases. For example,
    in the following program, the worst-case scenario may lead us to iterate over
    the whole list. Thus, performance depends on the size of the input:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`O(n²)`: This notation specifies the performance of algorithms, which is proportional
    to the square size of the input data. It is highly common in nested loops.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a few more notations, such as `O(2^N)` and `O(log N)`, but we don't
    need to go any further as we have already learned enough so that we can differentiate
    between good and bad code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have gained enough information about optimization and the way we
    can analyze algorithms, it''s time to look at some examples to clarify the differences
    between non-optimized and optimized code. Before diving into the algorithmic analysis
    of the following code, we will learn how to analyze the complexities of the programs.
    Since this book is not going to teach advanced algorithmic concepts, we will take
    a look at the basic ideas to evaluate performance and optimization. This will
    provide you with a tool that will help you write programs that are shorter, readable,
    and don''t waste memory resources. Thus, this practice will make us able to make
    proper decisions while differentiating between the algorithms in terms of their
    efficient use of resources, which means time and memory, depending on the scenario.
    Let''s get started by taking a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we used two nested `for` loops to get the desired output.
    In the case of the first for loop, it takes all the elements of the range one
    by one and for each iteration, we make a second for loop. For the second loop,
    we will have a range of the same elements with the same number of counts. For
    example, for element 2, we will have [2,2] for the second j loop, thus printing
    the same number multiple times. If you followed the preceding chapters properly,
    this code shouldn''t be hard to understand. Now, let''s observe the fun part.
    We know that the first i^([-])loop is going to iterate into the whole range of
    datasets, which will lead to the time complexity of `O(n)`. The same goes for
    the j-loop. Thus, the total time complexity will be `O(n) * O(n)`, which will
    result in `O(n²)`. This represents an expensive algorithm. We have to try and
    convert the programs with nested loops into single loops, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding program contains a single for loop, and so it will loop the entire
    datasets once, which will result in only `O(n)` and not `O(n²)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may be wondering why these things are so important and why we covered them
    in this chapter. The answer is simple. Although in some applications written by
    Python, that is, Android applications or websites, saving some milliseconds would
    be unnecessary. But, in a large application that''s handling gigantic amounts
    of data, this time measurement can be increased. For example, let''s think about
    an application calling a function to predict whether the news is fake or not.
    Let''s say the non-optimized code would take a few seconds to make a prediction
    and that optimization would take some milliseconds. Here, the quantity would seem
    small but imagine we are calling the same function 1 million times. Now, calculate
    the time that would be saved as a whole: 277.5 hours.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s cumbersome, isn''t it? Python provides two constructs to facilitate
    faster and efficient processing of these huge data collections: comprehension
    and generators. There are three types of comprehensions, that is, list, dict,
    and set. First, we will delve into learning about list comprehension. Then, we
    will explore the other two (dict and set) by relating to them.'
  prefs: []
  type: TYPE_NORMAL
- en: For loop versus list comprehension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we''ve been coding our program with loops since [Chapter 3](49a63c5e-e333-46c8-b8de-a54ca40d949c.xhtml), *Flow
    Control – Building a Decision Maker For Your Game*, we are quite familiar with
    looping patterns, especially for loops. They are going to iterate through some
    items and, at each iteration, the iterating variable is going to perform some
    manipulation. The power of for loops can be alleviated by combining it with the
    appropriate data structure, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Python has another easier way of doing the same thing, and is known as list
    comprehension. The output of list comprehension will always be a list, which will
    be the result of the evaluation of the expression in the context of the for loop.
    This is followed by if conditionals. The code that emulates the for loop with
    expressions and conditionals by using list comprehension will be single-line code.
    Thus, code that's written using list comprehension is shorter and easily maintainable.
    To understand how list comprehension works, we have to be familiar with its pattern.
    We'll learn about the list comprehension pattern in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: List comprehension pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will use list comprehension to modify the preceding code
    that was written by a for loop. The result of list comprehension is a list. The
    pattern inside the square bracket is an expression followed by a loop, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the left-hand side object, that is, `new_list` represents
    the output list that stores the result of list comprehension. On the right-hand
    side expression, the statement enclosed by square brackets will result in list
    comprehension. First, we pass the expression to be performed, then the loop and
    conditionals (if any). The following illustration represents the pattern for list
    comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/e20c0782-2c51-466c-b885-f82aec9c0a0a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a look at a simple example to explain the preceding pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The first statement inside the square brackets represents an expression. There
    can only be a single expression while we use list comprehension, unlike the body
    of a `for` loop. After the expression, we apply spaces and provide iteration.
    We can add nested loops too. After adding the iterations, we have to specify the
    conditionals, if there are any. List comprehension is widely used to concatenate
    the elements of two lists and create a new one, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code was able to create a complex list of lists. The comprehensions
    are not only limited to lists; there''s also dict and set comprehensions. As for
    the list, we used square brackets to perform comprehension. For set and dict comprehension,
    we need to use curly braces `{}`. Note, however, that the patterns will be similar
    for all of these comprehensions. Let''s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code represents the usage of dict comprehension. The pattern
    is similar to list comprehension except we use curly braces to perform comprehension.
    The result of dict comprehension will be a dictionary. Similarly, in the case
    of set comprehension, the result of comprehension will be set. This is shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Before wrapping up this section, we have to cover two powerful built-in functions
    of Python that manipulate the data of collections faster than ever. If you ever
    got a chance to learn about big data, you should have heard these two words: zip
    and map. Python has provided these two functions in order to work with a high
    amount of data with minimal load and faster computation. Let''s look at a simple
    example to understand the concepts of zip and map. Let''s say we have two lists
    containing limited integers. Now, you have to write a program to create a new
    list that will store the smallest number from each of them. A comparison will
    be made between the elements that have the same indexes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The most simple and conventional approach is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s learn about the other way we can perform the preceding computation.
    This is done with a single line of code which is made by using the `zip` and `map`
    functions. The `zip` function is a simple Python built-in function that takes
    two objects of equal length and merges them together. If you pass two lists of
    equal length to the `zip` function, it will merge it into a single one so that
    computation can be performed within a single object. This is shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We know that the comparison between the numbers should be made since they have
    the same indexes. Thus, we can combine the original array of numbers with the `zip`
    function so that we can store tuples of numbers in the single list, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Map function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The prime task of programming is to perform a computation. The operation that's
    done on elements can be done independent of one another; that is, we can perform
    a comparison on lists a and b separately, like we did in the preceding code, or
    simply merge them so that comparison can be done faster. The `zip` method is able
    to merge two objects that are the same length into a new iterable. Now, the major
    task is to create a comparison operation and use it on each element of the iterable,
    which is done by using the `map` function. The `map` function takes some function
    and applies it to each of the elements of the iterable.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to Python''s official documentation, map can be described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Map applies a function to every item of iterable and returns a list of the
    results. If additional iterable arguments are passed, the function must take that
    many arguments and is applied to the items from all the iterables in parallel.
    If one iterable is shorter than another, it is assumed to be extended with None
    items. If the function is None, the identity function is assumed; if there are
    multiple arguments,* `map()` *returns a list consisting of tuples containing the
    corresponding items from all the iterables (a kind of transpose operation). The
    iterable arguments may be a sequence or any iterable object; the result is always
    a list.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument that''s passed when we call map function is a function that''s
    followed by iterables. Normally, we use an anonymous or lambda function, such
    as `some_function`, which takes some positional arguments and returns them as
    a tuple. This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a simple example to illustrate the use of the `map` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code was not fruitful as the `map` function doesn''t return any
    iterables or objects. Instead, it prints the string representing the map object.
    To achieve a desirable result, we have to wrap the `map` method with a list constructor,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will use the concepts of the `map` and `zip` functions to find the
    list of minimum elements from the two lists. The following code is pretty simple;
    we started by defining two arrays. After that, we used the `map` function, which
    will take the `lambda` function containing the comparison operation and `zip`
    method and merge the two arrays into the list of tuples. Each pair of tuples made
    by the `zip` method are passed to `lambda` functions for comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'With the power of `map` and `zip`, we can do anything, similar to list comprehension.
    With the preceding program complete with list comprehension, the `map` function,
    and a for loop, we can see the following runtime performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Thus, these three features of Python primarily enable the manipulation of collections
    faster than anything. But in terms of code maintainability and readability, list
    comprehension tops the list as it provides us with a way to customize the inner
    workings of programs effectively. Now, it's time to learn about another feature
    of Python, known as decorators. These allow us to modify the functionality of
    an existing object without modifying its current structure.
  prefs: []
  type: TYPE_NORMAL
- en: Decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A decorator is a design pattern that adds new functionality to an existing
    object without deferring its original structure. We must be comfortable with the
    fact that everything in Python is an object – even functions. The different names
    that are used for defining these objects are just their identifiers. Let''s run
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the preceding code, the `fun1` and `fun2` functions print the same
    output of `"Good Morning"` as both refer to the same objects (functions). Thus,
    functions are just objects with attributes. Let''s get back to decorators. In
    a basic sense, a decorator is a construct where a part of the program tries to
    change the behavior of another part of the program at compile time. In the case
    of functions, the decorator takes a function, adds unique functionality to it,
    and eventually returns it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try to run the preceding code from the Python shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, `decorate_it()` is a decorator that takes a non-decorated
    function as an argument. The `decorate = decorate_it(non_Decorated)` statement
    is an assignment, where the `Non_Decorated` function was passed to the decorator
    and it returned the function called decorate. Thus, we can conclude that decorators
    are callables that return a callable. In the preceding example, we can see that
    the `decorate_it()` decorator added some functionality to the `non_Decorated`
    or ordinary function. When decorators started getting famous, the introduced design
    pattern was based on decorating the function first and returning to the name of
    the second callable, just like we did in this example. However, programmers found
    this job to be redundant. Thus, they developed another syntax that simplified
    the preceding construct: using the`@` symbol.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To decorate an ordinary function, we use the `@` symbol, along with the decorator''s
    name, and place it at the top of the non-decorated function, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is auxiliary to the following code, which we wrote earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at another example. We want to make a decorator that acts like
    an exception handler that throws error messages whenever unusual activity is encountered
    by the programs. The preceding decorator was simple since it wasn''t concerned
    about the argument that was passed to the inner function. Now, we are going to
    make a program that will multiply any two numbers but also handle the error if
    any other data is passed, such as a string or complex numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will try to make a decorator that will check whether we got an exception,
    like in the preceding code, and handle it automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you run the previous code, you will be asked for entries in the
    Python Shell. You have to enter two entities for `a` and `b`, and then the code
    does the rest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the preceding code one more time. This time, we will input the values
    of `a` and `b` as strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `inner` function of the decorator has the same number of
    arguments as those that were passed in by the non-decorated function. Thus, generalization
    can be done with `inner(*args, **kwargs)`, where `args` is the tuple of positional
    arguments and `kwargs` represents the dictionary of keyword arguments. Now, we
    can make decorators that will work with any number of arguments, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Thus, at compile time, decorators modify the operations of the original function,
    methods, or even classes without altering the code of the objects being decorated.
    This ultimately leads to the use of **don't repeat yourself** (**DRY**) technique.
    In the next section, we are going to learn about the `@property` decorator – a
    built-in decorator of Python for implementing the `property()` function. As you
    may recall from the previous chapter, this construct of `@property` has already
    been used and it was defined as a Pythonic way of implementing getters and setters.
    Now, we will learn about it in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Python property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To understand the usage of the property in the first place, we have to recall
    one of the principles of the object-oriented paradigm: data encapsulation. This
    bundles the data with the methods as a single capsule. The methods that are going
    to get and set the attributes of the classes are getters and setters. This principle
    of OOP infers that the attributes of the class must be made private so that accident
    modification or theft is prevented. Let''s look at a simple example to begin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we made a class called `Speed` that stores the speed
    of the vehicle in kilometers. It has `members` as a method that converts kilometers
    into miles. Now, we can make the objects of the `Speed` class and manipulate the
    members of this class as we like. We will use the Python Shell for this, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever assignment is done to the attributes of the class, the Python interpreter
    maintains the dictionary where the attributes and their values are maintained
    as key and value. In the case of the `Speed` class, we can retrieve any attributes
    of the object, that is, `speed`, with `__dict__ attributes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Thus, whenever we execute the `car.speed` operation, the Python interpreter
    makes a search in the preceding dictionary and fetches the value as `car.__dict__['speed']`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s assume that the preceding code became popular worldwide in the
    field of traffic control. One day, traffic police argued that there should be
    constraints in terms of the speed of a vehicle so that law can be enforced. Now,
    we have to modify the code in such a way that, if any driver drives too fast,
    the program provides them with a warning message. We can do this using getters
    and setters. Inside the `setter` method, we can explicitly check the maximum speed
    of the vehicle using conditionals. This can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, two major modifications were done and we are familiar
    with them. They are the `getter: get_speed` method and `setter: set_speed` method.
    Another change that was made in the code is the signature of the attribute. The
    speed attribute begins with a single underscore, which makes it private (data
    encapsulation). Try the following code in the Python Shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The update to the original program was successfully reflected with new ranges
    of restriction. The driver is not allowed to drive their vehicle at a speed of
    more than 50km/hr.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s run the preceding code and observe the overhead that might be caused
    by the new updates. We can simply compare the code that was written with the getter
    and the setter with the code that was written without them. A major headache will
    arise when you try to accommodate the original code with the new changes as you
    have to modify your code from calling the attributes of the `car.speed` object
    to calling the attributes of `car.get_speed()`. The constructor must be changed
    to `car.set_speed` (speed). We might find it easier to make changes in this program,
    but imagine if the program had 10,000+ lines of code. It would be a hard time
    for any programmer to update and synchronize it with the new code. Now, here comes
    the property decorator in action. The following code solves this problem for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we are familiar with decorators, the preceding construct should be familiar
    to us. Now, let''s run our code in the Python Shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Using the property construct, we modified our original class and provided some
    constraints too. But this time, we removed the changes we made, such as `get_speed`
    and `set_speed`, that were added by the getter and the setter. Thus, the traffic
    control system can use this new code without making any changes to the original
    code, which leads to backward compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have another way of implementing the preceding code, which is by using
    the `property()` function. The following code is equivalent to the preceding code
    being written with the `@` property construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The last line of the preceding code makes an object of the speed property. Remember
    that the property must be made out of those attributes, which are likely to be
    changed. We added some code that creates the object of property and inside parenthesis,
    we passed the getter and setter method. Now, any program that uses the value of
    speed will invoke the `get_speed` method automatically and any program that assigns
    the value of speed will invoke the `set_speed` method without having to look up `dictionary(obj.__dict__)`,
    which is managed by class.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's use our knowledge of list comprehension and property that we learned
    about in this chapter to modify our snake game.
  prefs: []
  type: TYPE_NORMAL
- en: Refining the snake game with LC and property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section will be kept as concise as possible because there is nothing new
    to cover. Now that we have learned about list comprehension and property in detail,
    we should be able to cover this topic quickly, as we discussed in the summary
    of the previous chapter. Just as a recap: list comprehension is a technique that
    is used to create a new list of elements from other iterables. A list comprehension
    statement consists of square brackets containing transformation that must be made
    for each element, along with a for loop. This is followed by some conditions.
    On the other hand, the `@property` or `property()` constructs are the Pythonic
    way of implementing getters and setters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go over some of the refinements we can make to our snake game:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we can make a function that will check the collision of the snake with
    the boundary or with itself. For example, if the coordinate (x,y) for the head
    of the snake is the same as the coordinate for its body, we have a collision.
    This logic can be made with list comprehension: `[body.coor == self.head.coor
    for body in self.body_list[:-1]]`. The following expression is going to store
    a Boolean that''s either True or False in the result list. The `body.coor == self.head.coor` comparison
    is going to be made for every position representing the body of the snake. The
    following lines of code represent a function that returns either True or False
    based on the check for collision:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Secondly, we can decorate the preceding method with the `@property` construct.
    Since we''ve covered it in detail, this should not create any confusion for us.
    If there is, let me enlighten you. The main use of `@property` is to support backward
    compatibility. We can modify the specifications of classes and implement the constraints
    without actually modifying the code of the previous versions that are distributed
    to the clients. Similarly, we can decorate a score function with `@property` since
    we need to update its time value. Thus, in order to continually access the score
    method as an attribute, we can add the property we decorated previously, like
    so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The preceding implementation of property and list comprehension is both an easy
    and efficient way of making code more readable and maintainable. We are going
    to find these types of constructs more often while programming with Python at
    an enterprise level.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has uncovered the advanced concepts of comprehension and generation,
    followed by some examples and its applications in the real-world. We saw the usage
    of comprehension and some of the built-in functions of Python such as map and
    zip, which over-shadowed the performance of for loops. Although these concepts
    of comprehension and mapping may seem overrated, we usually find it helpful if
    we have gigantic lines of code where performance matters rather than code readability.
    We also explored decorators in this chapter, which added some extra functionality
    to the existing code without affecting its original substance. Then, we learned
    about the concepts of the property decorator, which is a Pythonic way of implementing
    getters and setters while maintaining backward code compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: From the next chapter onward, our main goal will likely be lean toward game
    programming. We have successfully learned about the essentials of Python in order
    to become proficient game programmers. Now, we will learn about the graphical
    user interface and ways of making it using modules provided by Python, such as
    turtle and pygame. But before we hop over to the next chapter, make sure you are
    playing with the code we've written so far properly. It is a very important thing
    for any programmer to be able to read the code by breaking it line by line. If
    you already have enough confidence in your skills, proceed to the next chapter,
    where we will look at the turtle module, which is a basic way of drawing shapes
    into the game screen.
  prefs: []
  type: TYPE_NORMAL
