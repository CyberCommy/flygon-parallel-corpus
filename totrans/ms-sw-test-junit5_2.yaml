- en: What’s New In JUnit 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Those who can imagine anything, can create the impossible.
  prefs: []
  type: TYPE_NORMAL
- en: '*- Alan Turing*'
  prefs: []
  type: TYPE_NORMAL
- en: 'JUnit is the most important testing framework for the JVM and one of the most
    influential in software engineering in general. JUnit 5 is the next generation
    of JUnit, and its first **General Availability** (**GA**) version (5.0.0) was
    released on September 10, 2017. As we will discover, JUnit 5 supposes a small
    revolution with respect to JUnit 4, providing a completely new architecture, programming,
    and extension model. This chapter covers the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Road to JUnit 5**: In the first section, we will discover the motivation
    to create a new major version of JUnit (that is, the limitations of JUnit 4),
    the design principles guiding the development of JUnit 5, and finally the details
    of the JUnit 5 open source community.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JUnit 5 architecture**: JUnit 5 is a modular framework composed of three
    major components, named Platform, Jupiter, and Vintage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Running tests in JUnit 5**: We will discover how to run JUnit 5 tests using
    popular build tools, such as Maven or Gradle, and also with IDEs such as IntelliJ
    or Eclipse.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The extension model of JUnit 5**: The extension model allows for third-party
    libraries and frameworks to extend the JUnit 5 programming model with their own
    additions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Road to JUnit 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software testing has changed a lot since the first release of JUnit 4 in 2006\.
    Since then, not only have Java and the JVM has evolved, but also our testing needs
    matured. We are not writing just unit tests anymore. Instead, in addition to verifying
    a single piece of code, software engineers and testers demand other kinds of tests,
    such as integration and end-to-end tests.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, our expectations about testing frameworks have grown. Nowadays,
    we demand advanced capabilities for these frameworks, such as extensibility or
    modularity, to name a few. In this section, we discover the main limitations of
    JUnit 4, the vision of JUnit 5, and the community supporting its development.
  prefs: []
  type: TYPE_NORMAL
- en: JUnit 5 motivation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to several studies, JUnit 4 is the most used library for Java projects.
    For instance, *The Top 100 Java libraries on GitHub* is a well-known report published
    by OverOps ([@overopshq](https://twitter.com/overopshq)), a software analytics
    company focused on large-scale Java and Scala code bases.
  prefs: []
  type: TYPE_NORMAL
- en: 'In its edition of 2017, this report analyzed the import statements of unique
    Java libraries that are used by the top 1,000 Java projects on GitHub (by stars).
    In the light of the results, JUnit 4 is the undisputed king of Java Libraries:
    the imports of the packages `org.junit` and `org.junit.runner` appear in the first
    and second position, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Top 20 Java libraries on GitHub
  prefs: []
  type: TYPE_NORMAL
- en: Despite this fact, JUnit 4 is a framework created more than a decade ago, and
    there are important several limitations that impose a complete redesign of the
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: Modularity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First of all, JUnit 4 is not modular. As depicted in the following picture,
    the architecture of JUnit 4 is completely monolithic. All the capabilities of
    JUnit 4 are provided by the `junit.jar` dependency. As a result, different test
    mechanisms, such as test discovery and execution, are tightly coupled in JUnit
    4.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00019.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The JUnit 4 Architecture
  prefs: []
  type: TYPE_NORMAL
- en: 'Johannes Link, one of the JUnit 5 core team members, summarizes this problem
    in an interview for Jax magazine on August 13, 2015 (during the inception of JUnit
    5):'
  prefs: []
  type: TYPE_NORMAL
- en: The success of JUnit as a platform prevents the development of JUnit as a test
    tool. The basic problem we want to solve is executing test cases by separating
    a sufficiently powerful and stable API.
  prefs: []
  type: TYPE_NORMAL
- en: JUnit 4 runners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The JUnit 4''s runner API also has an important deterrent. As described in
    [chapter 1](part0021.html#K0RQ0-ef8404ed083f459d860f84cc8198f8bb), *Retrospective
    on software quality and Java testing*, in JUnit 4 a runner is a Java class used
    to manage a test''s life cycle. The runner API in JUnit 4 is quite powerful, nevertheless,
    it has an important drawback: runners are not composable, that is, we can only
    use a single runner at a time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a parameterized test cannot be combined with the Spring test support,
    due to the fact that both tests would use their own runner implementation. Thinking
    in Java (see the snippets given follow), each test case uses its own unique `@RunWith`
    annotation. The first one uses the `Parameterized` runner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'While this second example is using the `SpringJUnit4ClassRunner` runner,  it
    would not be combined with the previous one due to a limitation on JUnit 4 (runners
    are not composable):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: JUnit 4 rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Due to the strict limitation of uniqueness of a JUnit 4 runner within the same
    test class, version 4.7 of JUnit introduced the concept of method-level rules,
    which are annotated fields in a test class with `@Rule`. These rules allow for
    addition or redefinition of test behavior by executing some code before and after
    the execution of the test. JUnit 4.9 also incorporates the concept of class-level
    rules, which are rules that are executed before and after all tests within the
    class. These rules are identified by annotating static fields with `@ClassRule`,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: While rules are simpler and mostly compostable, they have other drawbacks. The
    main inconvenience when using JUnit 4 rules for complex tests is that we are not
    able to use a single rule entity for method-level and class-level. At the end
    of the day, this imposes limitations to customize the life cycle management (the
    before/after behavior).
  prefs: []
  type: TYPE_NORMAL
- en: JUnit 5 inception
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Even though JUnit 4 was the default testing framework for millions of Java
    developers worldwide, none of the active JUnit maintainers were paid by their
    employer to do that work. For that reason, and in order to overcome the drawbacks
    of JUnit 4, in July 2015 Johannes Link and Marc Philipp started the JUnit Lambda
    crowdfunding campaign ([http://junit.org/junit4/junit-lambda-campaign.html](http://junit.org/junit4/junit-lambda-campaign.html))
    on Indiegogo (an international crowdfunding website):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: JUnit Lambda Crowdfunding Campaign
  prefs: []
  type: TYPE_NORMAL
- en: 'JUnit Lambda was the name given to the project, which was the seed of the current
    JUnit 5 framework. The inclusion of the word lambda in the project name enforces
    the idea of using Java 8 from the very beginning of the project. Quoting the JUnit
    Lambda project site:'
  prefs: []
  type: TYPE_NORMAL
- en: The goal is to create an up-to-date foundation for developer-side testing on
    the JVM. This includes focusing on Java 8 and above, as well as enabling many
    different styles of testing.
  prefs: []
  type: TYPE_NORMAL
- en: The JUnit Lambda Crowdfunding Campaign ran from July to October 2015\. It was
    a success, raising 53,937 euros from 474 individuals and companies worldwide.
    From this point, the JUnit 5 kick-off team was created, joining people from Eclipse,
    Gradle, IntelliJ, or Spring.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JUnit Lambda project became JUnit 5, and the design principles guiding
    the development process were the follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modularization: As introduced before, JUnit 4 was not modular, and this causes
    some problems. From its inception, JUnit 5 architecture is much completely modular,
    allowing developers to use the specific parts of the framework they require.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Powerful extension model with focus on composability: Extensibility is a must
    for modern testing frameworks. Therefore, JUnit 5 should provide seamless integration
    with third-party frameworks, such as Spring or Mockito, to name a few.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'API segregation: Decouple test discovery and execution from test definition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Compatibility with older releases: Supporting the execution of legacy Java
    3 and Java 4 in the new JUnit 5 platform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Modern programming model for writing tests (Java 8): Nowadays, more and more
    developers write code with Java 8 new features, such as lambda expressions. JUnit
    4 was built on Java 5, but JUnit 5 has been created from scratch using Java 8.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JUnit 5 community
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source code of JUnit 5 is hosted on GitHub ([https://github.com/junit-team/junit5](https://github.com/junit-team/junit5)).
    All modules of the JUnit 5 framework have been released under the terms of the
    open source license EPL v1.0\. There is one exception to this rule, since the
    module called `junit-platform-surefire-provider` (described later) has been released
    using Apache License v2.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'The roadmap of the JUnit development ([https://github.com/junit-team/junit5/wiki/Roadmap](https://github.com/junit-team/junit5/wiki/Roadmap))
    and the definition and status of the different releases and milestones ([https://github.com/junit-team/junit5/milestones/](https://github.com/junit-team/junit5/milestones/))
    are public on GitHub. The following table summarizes this roadmap:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Phase | Date | Release |'
  prefs: []
  type: TYPE_TB
- en: '| 0\. Crowdfunding | From July 2015 to October 2015 | - |'
  prefs: []
  type: TYPE_TB
- en: '| 1\. Kick off | From October 20 to 22, 2015 | - |'
  prefs: []
  type: TYPE_TB
- en: '| 2\. First prototype | From October 23, 2015 to the end of November 2015 |
    - |'
  prefs: []
  type: TYPE_TB
- en: '| 3\. Alpha version | February 1, 2016 | 5.0 Alpha |'
  prefs: []
  type: TYPE_TB
- en: '| 4. First milestone | July 9, 2016 | 5.0 M1: Stable, documented IDE-facing
    APIs (Launcher API and Engine SPI), dynamic tests |'
  prefs: []
  type: TYPE_TB
- en: '| 5. Additional milestones | July 23, 2016 (5.0 M2)November 30, 2016 (5.0 M3)April
    1, 2017 (5.0 M4)July 5, 2017 (5.0 M5)July 16, 2017 (5.0 M6) | 5.0 M2: Bugfix and
    minor improvement release5.0 M3: JUnit 4 interoperability, additional discovery
    selectors5.0 M4: Test templates, repeated tests, and parameterized tests5.0 M5:
    Dynamic containers and minor API changes5.0 M6: Java 9 compatibility, scenario
    tests, additional extension APIs for JUnit Jupiter |'
  prefs: []
  type: TYPE_TB
- en: '| 6. **Release candidate** (**RC**) | July 30, 2017July 30, 2017August 23, 2017
    | 5.0 RC1: Final bug fixes and documentation improvements5.0 RC2: Fix Gradle consumption
    of *junit-jupiter-engine*5.0 RC3: Configuration parameters and bug fixes |'
  prefs: []
  type: TYPE_TB
- en: '| 7. **General availability** (**GA**) | September 10, 2017 | 5.0 GA: First
    stable release |'
  prefs: []
  type: TYPE_TB
- en: 'The JUnit 5 contributors are more than just developers. Contributors are also
    testers, maintainers, and communicators. At the time of writing, the top JUnit
    5 contributors on GitHub are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sam Brannen ([@sam_brannen](https://twitter.com/sam_brannen)): Core Spring
    Framework and JUnit 5 committer. Enterprise Java Consultant at Swiftmind. Spring
    & JUnit trainer. Conference speaker.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Marc Philipp ([@marcphilipp](https://twitter.com/marcphilipp)): Senior Software
    Engineer on LogMeIn, active contributor to open source projects such as JUnit
    or Usus. Conference speaker.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Johannes Link ([@johanneslink](https://twitter.com/johanneslink)): Programmer
    and software therapist. JUnit 5 supporter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Matthias Merdes: Lead Developer at Heidelberg Mobil GmbH, Germany.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Top JUnit 5 contributors on GitHub
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list provides a collection of online JUnit 5 resources:'
  prefs: []
  type: TYPE_NORMAL
- en: Official website ([http://junit.org/junit5/](https://twitter.com/hashtag/JUnit5)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Source code ([https://github.com/junit-team/junit5/](https://github.com/junit-team/junit5/)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JUnit 5 developer guide ([http://junit.org/junit5/docs/current/user-guide/](http://junit.org/junit5/docs/current/user-guide/)).
    Reference documentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Twitter of the JUnit team ([https://twitter.com/junitteam](https://twitter.com/junitteam)).
    Usually, the tweets about JUnit 5 are tagged with `#JUnit5` ([https://twitter.com/hashtag/JUnit5](https://twitter.com/hashtag/JUnit5)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Issues ([https://github.com/junit-team/junit5/issues](https://github.com/junit-team/junit5/issues)).
    Problems or suggestions for additional functionality on GitHub.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions on Stack Overflow ([https://stackoverflow.com/questions/tagged/junit5](https://stackoverflow.com/questions/tagged/junit5)).
    Stack Overflow is a popular question-and-answer website for computer programming.
    The tag `junit5` should be used to ask questions about JUnit 5.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JUnit 5 JavaDoc ([http://junit.org/junit5/docs/current/api/](http://junit.org/junit5/docs/current/api/)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JUnit 5 Gitter ([https://gitter.im/junit-team/junit5](https://gitter.im/junit-team/junit5)),
    an instant messaging and chat room system used to discuss directly with the JUnit
    5 team members and other practitioners.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open Test Alliance for the JVM ([https://github.com/ota4j-team/opentest4j](https://github.com/ota4j-team/opentest4j)). It
    is an initiative started by the JUnit 5 team, and its objective is to provide
    a minimal common foundation for testing libraries (JUnit, TestNG, Spock, and so
    on) and third-party assertion libraries (Hamcrest, AssertJ, and so on) on the
    JVM. The idea is to use a common set of exceptions that IDEs and build tools can
    support in a consistent manner across all testing scenarios (so far there is no
    standard for testing on the JVM, and the only common building block is the Java
    exception `java.lang.AssertionError`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JUnit 5 architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JUnit 5 framework has been designed to be consumed by different programmatic
    clients. The first group of clients are Java tests. These tests can be based on
    JUnit 4 (tests which use the test legacy programming model), JUnit 5 (tests which
    use the brand new programming model), and even other kinds of Java tests (third
    party). The second group of clients are build tools (such as Maven or Gradle)
    and IDEs (such as IntelliJ or Eclipse).
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to achieve the integration of all these pieces in a loosely coupled
    manner, JUnit 5 was designed to be modular. As depicted in the following picture,
    the JUnit 5 framework is composed of three major components, called Platform,
    Jupiter*,* and Vintage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'JUnit 5 Architecture: high-level component'
  prefs: []
  type: TYPE_NORMAL
- en: 'The high-level components of the JUnit 5 architecture are enumerated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first high-level component is called *Jupiter*. It provides the brand-new
    programming and extension model of the JUnit 5 framework.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the core of JUnit 5, we find the JUnit *Platform*. This component is aimed
    to become the foundation for any testing framework executed in the JVM. In other
    words, it provides mechanisms to run Jupiter tests, legacy JUnit 4, and also third-party
    tests (for example, Spock, FitNesse, and so on).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last high-level component of the JUnit 5 architecture is called *Vintage*.
    This component allows running legacy JUnit tests on the JUnit Platform out of
    the box.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a closer look at the details of each component to find out their
    internal modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'JUnit 5 Architecture: modules'
  prefs: []
  type: TYPE_NORMAL
- en: 'As can be seen in the picture preceding, there are three types of module:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Test APIs**: These are the modules facing users (that is, software engineer
    and testers). These modules provide the programming model for a particular Test
    Engine (for example, `junit-jupiter-api` for JUnit 5 tests and `junit` for JUnit
    4 tests).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test Engines**: These modules allow to execute a kind of test (Jupiter tests,
    legacy JUnit 4, or other Java tests) within the JUnit Platform. They are created
    by extending the general *Platform Engine* (`junit-platform-engine`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test Launcher**:These modules provide the ability of test discovery inside
    the JUnit platform for external build tools and IDEs. This API is consumed by
    tools such as Maven, Gradle, IntelliJ, and so on, using the `junit-platform-launcher`
    module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a result of this modular architecture, the JUnit framework exposes a set
    of interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: An **API** (**Application Programming Interface**) to write tests, the *Jupiter
    API*. The detailed description of this API is what it is known as the Jupiter
    programming model and it is described in detail in chapters 3, *JUnit 5 Standard
    Tests* and [chapter 4](part0100.html#2VBO80-ef8404ed083f459d860f84cc8198f8bb),
    *Simplifying Testing With Advanced JUnit Features* of this book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **SPI** (**Service Provider Interface**) to discover and execute tests, the
    *Engine SPI*. This SPI is typically extended by test engines, which in the end
    provide the programming models to write tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An API for test discovery and execution, the *Launcher API*. This API is typically
    consumed by programmatic clients, that are IDEs and build tools.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API and SPI are both a sets of assets (typically classes and interfaces) used
    by software engineers for a given purpose. The difference is that API is *called*
    while SPI is *extended*.
  prefs: []
  type: TYPE_NORMAL
- en: Test Engine SPI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Test Engine SPI allows for creating test executors on top of the JVM. In
    the JUnit 5 framework, there are two Test Engine implementations out of the box:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `junit-vintage-engine`: This allows running JUnit 3 and 4 tests in the
    JUnit platform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `junit-jupiter-engine`: This allows running JUnit 5 tests in the JUnit
    platform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Moreover, third-party test libraries (for example, Spock, TestNG, and so on)
    can plug into the JUnit Platform by providing a custom Test Engine. To do that, these
    frameworks should create its own Test Engine by extending the JUnit 5 interface `org.junit.platform.engine.TestEngine`.
    In order to extend this interface, three mandatory methods must be overridden:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getId`: The unique identifier for the test engine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`discover`: The logic to find and filter the test(s).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`execute`: The logic to run the previously found test(s).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example provides the skeleton for a custom Test Engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: A list of existing Test Engines (for example, Specsy, Spek, and others) is maintained
    by the community in the wiki located in the GitHub site of the JUnit 5 team: [https://github.com/junit-team/junit5/wiki/Third-party-Extensions](https://github.com/junit-team/junit5/wiki/Third-party-Extensions).
  prefs: []
  type: TYPE_NORMAL
- en: Test Launcher API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the goals of JUnit 5 is to make the interface between JUnit and its programmatic
    clients (build tools and IDEs) more powerful and stable. To that aim, the Test
    Launcher API has been implemented. This API is used by IDEs and build tools for
    discovering, filtering, and executing tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking closer at the details of this API, we find the class `LauncherDiscoveryRequest`,
    which exposes a fluent API to select the location of tests (for example classes,
    methods, or packages). This group of tests can be filtered, for example, using
    a match pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, the resulting test suite can be executed using the class `TestExecutionListener`.
    This class can be also used to get feedback and receive events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Running tests in JUnit 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the time of writing, Jupiter tests can be executed in several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using a build tool**: Maven (implemented in the module `junit-plaform-surefire-provider`)
    or Gradle (implemented in the module `junit-platform-gradle-plugin`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using the Console Launcher**: A command-line Java application that allows
    to launch the JUnit Platform from the console.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using an IDE**: IntelliJ (since version 2016.2) and Eclipse (since version
    4.7, Oxygen).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we are going to discover, and due to the modular architecture of JUnit 5,
    we need to include three dependencies in our projects: one for the Test API (to
    implement tests), an other for the Test Engine (to run tests), and the last one
    of the Test Launcher (to discover tests).'
  prefs: []
  type: TYPE_NORMAL
- en: Jupiter tests with Maven
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to run Jupiter tests within a Maven project, we need to configure
    the `pom.xml` file properly. First of all, we need to include the `junit-jupiter-api`
    module as a dependency. This is needed to write our test, and typically with test
    scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In general, it is recommended to use the latest version of the dependencies.
    In order to check what it that version, we can check it on Maven Central ([http://search.maven.org/](http://search.maven.org/))
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the `maven-surefire-plugin` has to be declared. Internally, this plugin
    needs two dependencies: the Test Launcher (`junit-platform-surefire-provider`)
    and the Test Engine (`junit-jupiter-engine`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: All the source code of this book is publicly available on the GitHub repository
    at [https://github.com/bonigarcia/mastering-junit5](https://github.com/bonigarcia/mastering-junit5).
  prefs: []
  type: TYPE_NORMAL
- en: 'Last but not least, we need to create a Jupiter test case. So far, we have
    not learned how to implement Jupiter tests (this part is covered in [chapter 3](part0077.html#29DRA0-ef8404ed083f459d860f84cc8198f8bb),
    JUnit 5 Standard Tests). Nevertheless, the test we execute here is the simplest
    test to demonstrate the execution of the JUnit 5 framework. A Jupiter test, in
    its minimal expression, is just a Java class in which one (or more) of its methods
    are annotated with `@Test` (package `org.junit.jupiter.api`). The following snippet
    provides an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: JUnit requires Java 8 (or higher) at runtime. However, we can still test code
    that has been compiled with previous versions of Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the following picture, this test can be executed using the command
    `mvn test`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00024.gif)'
  prefs: []
  type: TYPE_IMG
- en: Running Jupiter tests with Maven
  prefs: []
  type: TYPE_NORMAL
- en: Jupiter tests with Gradle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we are going to study the same example, but this time executed with Gradle.
    Therefore, we need to configure the `build.gradle` file. In this file, we need
    to define:'
  prefs: []
  type: TYPE_NORMAL
- en: The dependency for the Jupiter API (`junit-jupiter-api`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dependency for the Test Engine (`junit-jupiter-engine`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The plugin for the Test Launcher (`junit-platform-gradle-plugin`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The complete source of `build.gradle` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the command `gradle test` to run our Jupiter test from the command line
    with Gradle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00025.gif)'
  prefs: []
  type: TYPE_IMG
- en: Running Jupiter tests with Gradle
  prefs: []
  type: TYPE_NORMAL
- en: Legacy tests with Maven
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is the image we want to run the  legacy test (JUnit 4 in this
    case) inside the JUnit Plaform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To that aim, in Maven, we first need to include the old JUnit 4 dependency
    in our `pom.xml`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to include `maven-surefire-plugin`, using the following dependencies
    for the plugin: the Test Engine (`junit-vintage-engine`) and the Test Launcher
    (`junit-platform-surefire-provider`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The execution from the command line will also be using the command `mvn test`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00026.gif)'
  prefs: []
  type: TYPE_IMG
- en: Running Legacy tests with Maven
  prefs: []
  type: TYPE_NORMAL
- en: Legacy tests wih Gradle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we want to execute the same test presented in the example before (`io.github.bonigarcia.LegacyJUnit4Test`),
    but this time using Gradle, we need to include the following in our `build.gradle`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: The dependency for JUnit 4.12.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dependency for the Test Engine (`junit-vintage-engine`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The plugin for the Test Launcher (`junit-platform-gradle-plugin`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thus, the complete source of `build.gradle` would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The execution from the command line would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00027.gif)'
  prefs: []
  type: TYPE_IMG
- en: Running Legacy tests with Gradle
  prefs: []
  type: TYPE_NORMAL
- en: The ConsoleLauncher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ConsoleLauncher` is a command-line Java application that allows launching
    the JUnit Platform from the console. For example, it can be used to run Vintage
    and Jupiter tests from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'An executable JAR with all dependencies included is published in the central
    Maven repository under the `junit-platform-console-standalone` artifact. The standalone
    Console Launcher can be executed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The example GitHub repository [*junit5-console-launcher*](https://github.com/bonigarcia/mastering-junit5/tree/master/junit5-console-launcher) contains
    a simple example for the use of the Console Launcher. As depicted in the following
    picture, a run configuration entry has been created in Eclipse, running the main
    class, `org.junit.platform.console.ConsoleLauncher`. Then, the test class name
    is passed as an argument using the option `--select-class` and the qualified class
    name (in this example, `io.github.bonigarcia.EmptyTest`). After that, we can run
    the application, obtaining the test result in the integrated console of Eclipse:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Example of ConsoleLauncher in Eclipse
  prefs: []
  type: TYPE_NORMAL
- en: Jupiter tests in JUnit 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JUnit 5 has been designed to be forward and backward compatible. On the one
    hand, the Vintage component supports running legacy code on JUnit 3 and 4\. On
    the other hand, JUnit 5 provides a JUnit 4 runner that allows to run JUnit 5 in
    IDEs and build systems that support JUnit 4, but does not yet support the new
    JUnit Platform 5 directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see one example. Imagine we want to run a Jupiter test in an IDE does
    not support JUnit 5, for example, an old version of Eclipse. In this case, we
    need to annotate our Jupiter test with `@RunWith(JUnitPlatform.class)`. The `JUnitPlatform`
    runner is a JUnit 4-based runner, which enables to run any test whose programming
    model is supported on the JUnit Platform in a JUnit 4 environment. Therefore,
    our test would result as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If this test is contained in a Maven project, our `pom.xml` should contain
    the following dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, for a Gradle project, our `build.gradle` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: IntelliJ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'IntelliJ 2016.2+ has been the first IDE which supports the execution of Jupiter
    tests natively. As shown in the following screenshot, any Jupiter test can be
    executed using the integrated functions of the IDE:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Running a Jupiter test in IntelliJ 2016.2+
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Eclipse 4.7 (*Oxygen*) has beta support for JUnit 5\. Thanks to this, Eclipse
    provides the ability of running Jupiter tests directly in Eclipse, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Running a Jupiter test in Eclipse 4.7+
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, Eclipse 4.7 (*Oxygen*) provides a wizard to create Jupiter tests
    in a simple way, as shown in the following pictures:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Eclipse wizard to create Jupiter tests
  prefs: []
  type: TYPE_NORMAL
- en: The extension model of JUnit 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As introduced before, Jupiter is the name given to the new programming model
    of JUnit 5, described in detail in [chapter 3](part0077.html#29DRA0-ef8404ed083f459d860f84cc8198f8bb), *JUnit
    5 standard tests* and [chapter 4](part0100.html#2VBO80-ef8404ed083f459d860f84cc8198f8bb),
    *Simplifying testing with advanced JUnit features*, together with the extension
    model. The extension model allows to extend the Jupiter programming model with
    custom additions. Thanks to this, third-party frameworks (such as Spring or Mockito,
    to name a few) can achieve interoperability with JUnit 5 in a seamless way. The
    extensions provided by these frameworks will be studied in [chapter 5](part0122.html#3KB4K0-ef8404ed083f459d860f84cc8198f8bb), *Integration
    of JUnit 5 with external frameworks*. In the current section, we analyze the general
    performance of the extension model and also the extensions provided out of the
    box in JUnit 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast to former extension points in JUnit 4 (that is, test runners and
    rules), the JUnit 5 extension model consists of a single, coherent concept: the
    **Extension API**. This API allows to extend the core functionality of JUnit 5
    by any third party (tool vendor, developers, and so on). The first thing we need
    to understand about extensions in Jupiter is that each new extension implements
    an interface called `Extension`. This interface is a *marker* interface, that
    is, a Java interface with no field or methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to make ease the creation of Jupiter extensions, JUnit 5 provides
    a set of extensions points which allows to execute custom code in different parts
    of the test life cycle. The following table contains a summary of the extension
    points in Jupiter, and its details are presented in the next sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Extension point** | **Implemented by extensions which want to…** |'
  prefs: []
  type: TYPE_TB
- en: '| `TestInstancePostProcessor` | Provide additional behavior just after the
    test instantiation |'
  prefs: []
  type: TYPE_TB
- en: '| `BeforeAllCallback` | Provide additional behavior before all tests are invoked
    in a test container |'
  prefs: []
  type: TYPE_TB
- en: '| `BeforeEachCallback` | Provide additional behavior to tests before each test
    is invoked |'
  prefs: []
  type: TYPE_TB
- en: '| `BeforeTestExecutionCallback` | Provide additional behavior to tests immediately
    before each test is executed |'
  prefs: []
  type: TYPE_TB
- en: '| `TestExecutionExceptionHandler` | Handle exceptions thrown during test execution
    |'
  prefs: []
  type: TYPE_TB
- en: '| `AfterAllCallback` | Provide additional behavior to test containers after
    all tests have been invoked |'
  prefs: []
  type: TYPE_TB
- en: '| `AfterEachCallback` | Provide additional behavior to tests after each test
    has been invoked |'
  prefs: []
  type: TYPE_TB
- en: '| `AfterTestExecutionCallback` | Provide additional behavior to tests immediately
    after each test has been executed |'
  prefs: []
  type: TYPE_TB
- en: '| `ExecutionCondition` | Conditionate the test execution at runtime |'
  prefs: []
  type: TYPE_TB
- en: '| `ParameterResolver` | Resolve parameters at runtime |'
  prefs: []
  type: TYPE_TB
- en: 'Once we created an extension, in order to use it, we need to use the annotation
    `ExtendWith`. This annotation can be used to register one or more extensions.
    It can be declared on interfaces, classes, methods, fields, and even in other
    annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Test lifecycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a set of extension points aimed at controlling the life cycle of
    tests. First of all, the `TestInstancePostProcessor` can be used to execute some
    logic after the test instantiation. After that, there are different extensions
    which control the pre-test stage:'
  prefs: []
  type: TYPE_NORMAL
- en: The `BeforeAllCallback` defines the logic executed before all tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `BeforeEachCallback` defines the logic executed before a test method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `BeforeTestExecutionCallback` defines the logic executed immediately before
    a test method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Similarly, there are extensions to control the post-test phases:'
  prefs: []
  type: TYPE_NORMAL
- en: The `AfterAllCallback` defines the logic executed after all tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `AfterEachCallback` defines the logic executed after a test method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `AfterTestExecutionCallback` defines the logic executed immediately after
    a test method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In between the `Before*` and `After*` callbacks, there is an extension that
    provides a way for collecting exceptions: the `TestExecutionExceptionHandler`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All these callbacks, and their order in the test life cycl are depicted in
    the following picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Lifecycle of extension callbacks
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example. We created an extension called `IgnoreIOExceptionExtension`,
    which implements `TestExecutionExceptionHandler`. In this example, the extension
    checks whether or not the exception is `IOException`. If so, the exception is
    discarded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following test class, which contains two tests (`@Test`). The
    first one is annotated with `@ExtendWith` and our custom extension (`IgnoreIOExceptionExtension`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When executing this test class, the first test is succeeded due to the fact
    that the `IOException` has been internally handled by our extension. On the other
    hand, the second will fail since that exception is not handled.
  prefs: []
  type: TYPE_NORMAL
- en: 'The execution of this test class in the console can be seen in the next screenshot.
    Note that we select the test to be executed using the Maven command `mvn test
    -Dtest=ExceptionTest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00033.gif)'
  prefs: []
  type: TYPE_IMG
- en: Output of ignore exception example
  prefs: []
  type: TYPE_NORMAL
- en: Conditional extension points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to create extensions that activate or deactivate tests depending on
    a given condition, JUnit 5 provides one conditional extension point callled `ExecutionCondition`.
    The following snippet shows the declaration of this extension point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The extension can be used to deactivate either all tests in a container (likely
    a class) or individual tests (likely a test method). Examples of this extension
    are provided in the section C*onditional Test Execution* of [chapter 3](part0077.html#29DRA0-ef8404ed083f459d860f84cc8198f8bb), *JUnit
    5 Standard Tests*.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ParameterResolver` extension provides dependency injection at method level.
    In this example, we can see how an argument is injected in the test method with
    a custom implementation of `ParameterResolver` called `MyParameterResolver`. Following
    the code, we can see that this resolver will simply inject hard-coded String parameters
    with the value `my parameter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, this parameter resolver can be used in a test, declaring it as usual
    using the annotation `@ExtendWith`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if we execute this test (for example using Maven and the command line),
    we can see how the injected parameter is logged in the standard output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00034.gif)'
  prefs: []
  type: TYPE_IMG
- en: Output of dependency injection extension example
  prefs: []
  type: TYPE_NORMAL
- en: Third-party extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: A list of existing JUnit 5 extensions (for example, Spring, Selenium, Docker,
    and others) is maintained by the community in the wiki located in the GitHub site
    of the JUnit 5 team: [https://github.com/junit-team/junit5/wiki/Third-party-Extensions](https://github.com/junit-team/junit5/wiki/Third-party-Extensions).
    Some of them are also detailed in [chapter 5](part0122.html#3KB4K0-ef8404ed083f459d860f84cc8198f8bb),
    *Integration of JUnit 5 with external frameworks*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter provides an overview of the JUnit 5 testing framework. Due to the
    limitations of JUnit 4 (monolithic architecture, impossibility of compose test
    runners, and limitations of test rules), a new major version of the framework
    was needed. In order to carry out the implementations, the JUnit Lambda project
    started a crowdfunding campaign in 2015\. As a result, the JUnit 5 development
    team was born, and the GA release of the framework was released on September 10,
    2017.
  prefs: []
  type: TYPE_NORMAL
- en: 'JUnit 5 was designed to be modern (that is, using Java 8 and Java 9 compliant
    from the very beginning) and modular. The three major components within JUnit
    5 are: Jupiter (new programming an extension model), Platform (foundation for
    any testing framework executed in the JVM), and Vintage (integration with legacy
    JUnit 3 and 4 tests). At the time of this writing, JUnit 5 tests can be executed
    using build tools (Maven or Gradle) and also with IDEs (IntelliJ 2016.2+ or Eclipse
    4.7+).'
  prefs: []
  type: TYPE_NORMAL
- en: The extension model of JUnit 5 allows to extend the core functionality of JUnit
    5 by any third party. In order to create JUnit 5 extensions, we need to implement
    one or several JUnit extension points (such as `BeforeAllCallback`, `ParameterResolver`,
    or `ExecutionCondition`, among others), and then register the extension in our
    tests using the annotation `@ExtendWith`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next [chapter 3](part0077.html#29DRA0-ef8404ed083f459d860f84cc8198f8bb),
    *JUnit 5 Standard Tests*, we are going to learn the basics of the Jupiter programming
    model. In other words, we are going to learn how to create standard JUnit 5 tests.
  prefs: []
  type: TYPE_NORMAL
