- en: Vue Communicates with the Internet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, the following recipes will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Sending basic AJAX request with Axios
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating user data before sending it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a form and sending data to your server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recovering from an error during a request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a REST client (and server!)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing infinite scrolling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing a request before sending it out
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing XSS attacks to your app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web applications rarely work all by themselves. What makes them interesting
    is actually the fact that they enable us to communicate with the world in innovative
    ways that didn't exist just a few years ago.
  prefs: []
  type: TYPE_NORMAL
- en: Vue, by itself, doesn't contain any mechanism or library to make AJAX requests
    or open web sockets. In this chapter, we will, therefore, explore how Vue interacts
    with built-in mechanisms and external libraries to connect to external services.
  prefs: []
  type: TYPE_NORMAL
- en: You will start by making basic AJAX requests with the help of an external library.
    Then, you'll explore some common patterns with sending and getting data in forms.
    Finally, there are some recipes with real-world applications and how to build
    a RESTful client.
  prefs: []
  type: TYPE_NORMAL
- en: Sending basic AJAX requests with Axios
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Axios** is the recommended library for Vue for making HTTP requests. It''s
    a very simple library, but it has some built-in features that help you in carrying
    out common operations. It implements a REST pattern for making requests with HTTP
    verbs and can also deal with concurrency (spawning multiple requests at the same
    time) in a function call. You can find more information at [https://github.com/mzabriskie/axios](https://github.com/mzabriskie/axios).'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, you don't need any particular knowledge of Vue. We will use
    Axios, which itself uses **JavaScript promises**. If you have never heard of promises,
    you can have a primer at [https://developers.google.com/web/fundamentals/getting-started/primers/promises](https://developers.google.com/web/fundamentals/getting-started/primers/promises).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will build a simple application that gives you a wise piece of advice every
    time you visit the web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you will need is to install Axios in your application. If you
    are using npm, you can just issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you are working on a single page, you can import the following file from
    CDN, at [https://unpkg.com/axios/dist/axios.js](https://unpkg.com/axios/dist/axios.js).
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the advise slip service we will use will not work with JSFiddle
    because while the service runs on HTTP, JSFiddle is on HTTPS and your browser
    will most likely complain. You can run this recipe on a local HTML file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our HTML looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Our Vue instance is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Open your app to have a refreshingly wise slip of advice:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fe5c736a-4340-4b65-be40-c53492e3e2fc.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When our application starts up, the created hook is engaged and will run the
    code with Axios. The first line performs a GET request to the API endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return a promise. We can use the `then` method on any promise to
    act on the result if the promise resolves successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The response object will contain some data about the result of our request.
    A possible response object is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We navigate to the property we want to interact with; in our case, we want `response.data.slip.advice`,
    which is the string. We copied the string in the variable advice in the instance
    state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part is when something wrong happens to our request or to our code
    inside the first branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We will explore error handling more in depth in the *Recovering from an error
    during a request* recipe. For now, let's trigger an error by hand, just to see
    what happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'The cheapest way to trigger an error is to run the app on JSFiddle. Since the
    browser detects JSFiddle on a secure connection and our API is on HTTP (which
    is not secure), modern browsers will complain and will block the connection. You
    should see the following text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is just one of the many possible errors you can experiment with. Consider
    that you edit the GET endpoint to some non-existent page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, you will get a 404 error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Interestingly, you will end up in the error branch even if the request goes
    well but there is an error in the first branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the `then` branch to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As everybody knows, JavaScript cannot read "hello" property  of an undefined
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It's just as I told you.
  prefs: []
  type: TYPE_NORMAL
- en: Validating user data before sending it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generally, users hate forms. While we can't do much to change that, we can make
    it less frustrating for them by providing relevant instructions on how to fill
    them in. In this recipe, we will create a form, and we will leverage HTML standards
    to provide the user with a nice guidance on how to complete it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe does not need previous knowledge to be completed. While we will
    build a form (the *Sending basic AJAX requests with Axios* recipe), we will fake
    the AJAX call and concentrate on the validation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will build a very simple form: one field for the username and one for the
    user e-mail, plus one button to submit the information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type in this HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The Vue instance is trivial, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Run this app and try to submit the form with an empty field or wrong e-mail.
    You should see help from the browser itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/89b2c210-31e6-4a6e-b06e-fb5fab39ee29.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, if you try to enter an invalid e-mail address, you will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9ae50ef5-524f-432f-82e4-1735525a8179.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are using a native HTML5 validation API, which internally uses pattern matching
    to check whether what we are typing is conformant to certain rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the attribute required in the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that when we submit the form, the field is actually populated while
    having `type="email"` in the other input element ensures that the content resembles
    an e-mail format.
  prefs: []
  type: TYPE_NORMAL
- en: This API is very rich and you can read more at [https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms/Data_form_validation](https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms/Data_form_validation).
  prefs: []
  type: TYPE_NORMAL
- en: 'Many a time, the problem is that to leverage this API, we need to trigger the
    native validation mechanism. This means that we are not allowed to prevent the
    default behavior of the Submit button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This will not trigger the native validation and the form will always be submitted.
    On the other hand, if we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The form will get validated but, since we are not preventing the default behavior
    of the submit button, the form will be sent to another page, which will destroy
    the one-page application experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'The trick is to intercept the submit at form level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This way, we can have form native validation and all the modern browsing experience
    we really like.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a form and sending data to your server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTML forms are a standard way to interact with your user. You can gather their
    data to register within the site, make them log in, or even carry out more advanced
    interactions. In this recipe, you will build your first form with Vue.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is very easy, but it assumes that you already know about AJAX and
    you want to apply your knowledge on Vue.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s pretend that we have a blog, and we want to write a new post. For that,
    we need a form. Here is how you lay out the HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We have a box for the title, one for the body of our new post, and a button
    to send our post.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our Vue instance, those three things along with a user ID will be part of
    the state of the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we just need to add a method to send the data to our server when
    we click on the Submit button. Since we don't have a server, we will use a very
    useful service by **Typicode.** It's basically a fake REST server. We will send
    a request and the server will respond in a realistic manner, even if nothing will
    really happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s our method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the actual response of the server, we will add the response variable
    to our status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'After the form in our HTML, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'When you launch your page, you should be able to interact with your server.
    When you write a post, the server will echo the post and answer with the post
    ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5b07cbb9-8885-48fa-b2f3-e2722be8aa0b.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the magic happens in the `submit` method. In the first line, we are
    creating an `XMLHttpRequest` object, which is a native JavaScript mechanism to
    make AJAX requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We then use the `open` and `setRequestHeader` methods to configure a new connection;
    we want to send a POST request, and we will send some JSON along with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Since we are interacting with a RESTful interface, the POST method means that
    we expect our request to modify data on the server (in particular, create a new
    post), and that issuing the same request more than one time will get different
    results every time (namely we will create a new, different post ID each time).
  prefs: []
  type: TYPE_NORMAL
- en: This is different from the more common GET request that will not modify data
    on the server (except logs maybe) and this will always yield the same results
    (provided that data on the server does not change between requests).
  prefs: []
  type: TYPE_NORMAL
- en: For more details about REST, take a look at the *Creating a REST client (and
    server!)* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines are all about the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This will install a handler whenever we get some kind of change in our object.
    If the `readyState` is changed to `DONE` it means, that we have our response from
    the server. Next, we check the status code, which should be `201` to signal that
    a new resource (our new post) has been created. If that is the case, we set the
    variable we put in the mustaches to get a quick feedback. Otherwise, we put the
    error message we received in the same variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we need to do, after setting up the event handlers, is to actually
    send the request along with the data of our new post:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another way to approach the same problem is to use Axios for sending the AJAX
    request. If you need to brush up on what Axios is, take a look at the *Sending
    basic AJAX requests with Axios* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the `submit` method will become as follows (remember to add Axios
    as a dependency):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This code is perfectly equivalent, but it's much more expressive and concise
    than using native browser objects.
  prefs: []
  type: TYPE_NORMAL
- en: Recovering from an error during a request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Requests to an external service take ages from the perspective of a computer.
    In human terms, it would be like sending a satellite to Jupiter and waiting for
    it to come back to Earth. You can't be 100% sure that the travel will ever be
    complete and how much time will the travel actually take. Networks are notoriously
    flaky and it's better to come prepared in case our request does not complete successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is a little complex, but, does not use advanced concepts. You are
    expected, nonetheless, to be familiar with using Vue.
  prefs: []
  type: TYPE_NORMAL
- en: We will be using Axios for this recipe. You can complete the *Sending basic
    AJAX requests with Axios* recipe if you are unsure of what it exactly entails.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will build a website for ordering pizzas on Mt. Everest. The area has a
    notoriously poor Internet connection, so we may want to retry a couple of times
    before giving up on our pizza.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what our HTML looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We have a button to place orders that will be disabled while an order is in
    progress--a list of orders in progress (that will contain only one order for the
    moment) and a list of pizzas already ordered.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add a spinner to make the waiting a bit more pleasant. Add this CSS
    to make the little pizza spin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Our Vue instance will keep track of a few things; write this code to start
    building the instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: I would like to use JavaScript sets for the requests and responses; unfortunately,
    sets are not reactive in Vue; the closest thing we can use is an object, which
    is empty for now, that is, we are initializing requests and responses to an empty
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `impatientAxios` variable will be filled upon creation. Normally, Axios
    waits as long as the browser will wait for a response. Since we are impatient,
    we will create an Axios that will drop the connection after 3 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to build is the order method. Since we don''t have a
    web server to make actual requests to, we will use the `http://httpstat.us/200`
    endpoint that simply answers 200 OK to all our requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To run this program as intended, open it in Chrome and open the Developer Tools
    with *Cmd* + *Opt* + *I*  (*F12* on Windows):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a50f7cc7-aa6e-41f7-aaed-00600cf52c1f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Switch the tab to Network and open the dropdown where you see No Throttling:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](assets/3839d7cb-8319-4cd7-9198-0ffe81506b27.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on it to display the drop-down menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a76b0d43-9f47-45e6-a471-83e2750189b0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add a new custom throttling called `Everest` with `1kb/s` for download and
    upload and a latency of `1,000` milliseconds, as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4a15fc97-768d-4c46-851b-ed6661401e52.png)'
  prefs: []
  type: TYPE_IMG
- en: You can then select that type of throttling and try to order some pizzas. If
    you are lucky, you should eventually be able to order some, thanks to the persistency
    of Axios.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not getting success or if all your pizzas are ordered correctly,
    try to adjust the parameters; much of this process is actually random and highly
    dependent on the machine.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many ways to deal with flaky connections and there are many libraries
    out there that integrate with Axios and have more advanced retry and reattempt
    strategies. Here, we have seen only one basic strategy, but libraries such as **Patience
    JS** have more advanced ones and they are not difficult to use.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a REST client (and server!)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn about REST and how to build a REST client. To
    build a REST client, we will need a server that exposes a REST interface; we will
    build that also. Wait a minute! A whole REST server is a side note in a recipe
    in a book about Vue? Just follow along and you won't be disappointed.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is fairly advanced in the sense that you will need to be comfortable
    with the architecture of client and server and at least have heard or read about
    REST interfaces. You will also need to be familiar with the command line and have
    npm installed. You can read all about it in the *Choosing a development environment* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Axios will also need to be installed; read more about this in the first recipe
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I remember when some years ago, building a REST server could take days or weeks.
    You can use `Feather.js`, and it will be quick and (hopefully painless). Open
    a command line and install it through npm with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, create a directory where you will run the server, go inside it,
    and launch Feathers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Answer all the questions with default values. When the process finishes, type
    in the following command to create a new resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: One of the questions is the name of the resource; call it `messages`, but other
    than that, use the default for all the other questions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exit from the feathers-cli with the  `exit` command and start your new server
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: After some seconds, your REST server should be started and should be listening
    on port `3030`. Can you honestly say it was difficult?
  prefs: []
  type: TYPE_NORMAL
- en: The preceding sequence of commands works with Feathers version 2.0.0
  prefs: []
  type: TYPE_NORMAL
- en: It's totally possible that you may be using another version but it should still
    be easy to get the same result with a later version; check the online install
    guide at [https://feathersjs.com/](https://feathersjs.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Next, you'll build a Vue app that communicates with the server seamlessly. Now,
    since the server is running in your local environment through HTTP, you will not
    be able to use JSFiddle because it works on HTTPS and considers HTTP insecure.
    You can either use other methods described earlier or use services on HTTP, such
    as [codepen.io](http://codepen.io) or others.
  prefs: []
  type: TYPE_NORMAL
- en: You will code an app that manages sticky messages. We want to be able to view,
    add, edit, and delete them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type the following in this HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Our Vue instance state will consist of a list of recorded messages, plus a temporary
    message to be added to the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing that we want to do is ask the server for a list of messages.
    Write the created hook for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'For creating a new message, write a method that binds to the click of the add
    button and send what''s written in the input box to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, write a method for deleting a message and for editing a message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Launch your application and you will be able to manage your board of sticky
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/99b328f2-4364-4d96-8c9d-26d0accb2dc6.png)'
  prefs: []
  type: TYPE_IMG
- en: To prove to yourself that you are really communicating with the server, you
    can refresh the page or close and reopen the browser and your notes will still
    be there.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**REST** means **REpresentational State Transfer**, as in you will transfer
    a representation of the state of some resource. In practice, we are using a set
    of **verbs** to transfer the representation of the state of our messages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the HTTP protocol, we have at our disposal the following verbs:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Verb** | **Properties** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Idempotent, safe | Used to retrieve the representation of a resource
    |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` |  | Used to upload a new resource |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | Idempotent | Used to upload an existing resource (to modify it) |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | Idempotent | Used to delete a resource |'
  prefs: []
  type: TYPE_TB
- en: Idempotent means that if we use the same verb twice, nothing will happen to
    the resource, and safe means that nothing will happen at all.
  prefs: []
  type: TYPE_NORMAL
- en: In our application, we use the GET verb only at the beginning during creation.
    When we see the list changing as a result of the other actions, it is only because
    we are mirroring the actions on the server on the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: The POST verb is used to add a new message to the list. Note how it's not idempotent,
    as even with the same text in the sticky message, we nonetheless create a new
    message that differs in ID when pressing the add button.
  prefs: []
  type: TYPE_NORMAL
- en: Pressing the edit button triggers a PUT and the Delete button, well, you can
    imagine that it uses the DELETE verb.
  prefs: []
  type: TYPE_NORMAL
- en: Axios makes this very clear by naming the methods of its API with the verbs
    themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing infinite scrolling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Infinite scrolling is a fine example of what you can do with Vue and AJAX. It
    is also quite popular and can improve interaction for some kind of content. You
    will build a random word generator that works with infinite scrolling.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use Axios. Take a look at the *Sending basic AJAX requests with Axios*
    recipe to know how to install it and its basic functionality. Other than that,
    you don't need to know much to follow along.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make our app work, we will ask random words from the [http://www.setgetgo.com/randomword/get.php](http://www.setgetgo.com/randomword/get.php) endpoint.
    Every time you point the browser at this address, you will get a random word.
  prefs: []
  type: TYPE_NORMAL
- en: 'The whole page will consist solely of an infinite list of words. Write the
    following HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The list of words needs to grow as we scroll down. So we need two things: understanding
    when the user reaches the bottom of the page, and getting new words.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To know when the user has reached the bottom of the page, we add a method in
    our Vue instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This will return `true` if either the page is scrolled until the bottom of the
    page itself is smaller than the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to add a mechanism to bind the result of this function to a state
    variable bottom and update it every time the user scrolls the page. We can do
    that in the created hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The state will be composed of the `bottom` variable and the list of random
    words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need a method to add words to the array. Add the following method to
    the existing method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The method will recursively call itself until the page has enough words to fill
    the whole browser view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this method needs to be called every time we reach the bottom, we will
    watch for the bottom variable and fire the method if it''s `true.` Add the following
    option to the Vue instance just after the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to call the `addWord` method in the created hook to kick-start
    the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: If you launch the page now, you will have an infinite stream of random words,
    which is useful when you need to create a new password!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we used an option called `watch`, which uses the following
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This is the counterpart of computed properties when we are not interested in
    a result after some reactive variable changes. As a matter of fact, we used it
    to just fire another method. Had we been interested in the result of some calculations,
    we would have used a computed property.
  prefs: []
  type: TYPE_NORMAL
- en: Processing a request before sending it out
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe teaches you how to use interceptors to edit your request before
    it goes out to the Internet. This can be useful in some cases, such as when you
    need to supply an authorization token along with all the requests to your server
    or when you need a single point to edit how your API calls are performed.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe uses Axios (the *Sending basic AJAX requests with Axios* recipe);
    apart from that, it will be useful to have completed the *How to validate user
    data before sending it* recipe since we will build a small form for demonstration.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, you will build a filter for curse words for a hypothetical
    comment system. Suppose there''s an article on our website that can potentially
    start a flame war:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'After that article, we place a comment box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We also added a line after the form to debug the response that we will get from
    the server.
  prefs: []
  type: TYPE_NORMAL
- en: In our Vue instance, we write all the support code to send the comment to our
    server, which, in this case, will be [http://jsonplaceholder.typicode.com/comments](http://www.setgetgo.com/randomword/get.php),
    a fake REST interface that will behave like a real server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the submit method that is triggered by the press of the Submit button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The state of the Vue instance will only be two variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, we want to mount it to the `<div>` app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as the instance is mounted, we want to install the word filter in Axios;
    for this, we tap into the `mounted` hook of Vue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We can launch our application now and try to write our salty comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fbf91399-45a4-41e4-88dc-20fe51bfabed.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `mounted` hook, we are installing a so-called `interceptor.` In particular,
    it is a request interceptor, which means it will take our request and manipulate
    it before sending it out to the Internet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The `config` object contains a lot of things we can edit. It contains the headers
    and URL parameters. It also contains Axios configuration variables. You can check
    out the Axios documentation for an up-to-date list.
  prefs: []
  type: TYPE_NORMAL
- en: We are taking what's inside the data part that got sent along with the POST
    request and sniffing if the `punk` word is found. If that is the case, it will
    get substituted with asterisks. The returned object will be the new config for
    the current request.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing XSS attacks to your app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing applications without thinking about security will inevitably lead to
    vulnerabilities, especially if it has to run on a web server. **Cross site scripting**
    (**XSS**) is among the most popular security issues nowadays; even if you are
    not a security expert, you should be aware of how it works and how to prevent
    it in a Vue application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe does not need any previous knowledge except for Axios. You can find
    more on Axios and how to install it in the *Sending basic AJAX requests with Axios* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing you should do is to discover how your backend is giving you
    the CSRF token (more on this in the next paragraph). We will suppose that the
    server will place a cookie in your browser with the name, XSRF-TOKEN.
  prefs: []
  type: TYPE_NORMAL
- en: You can simulate your server, setting a cookie with the `document.cookie = 'XSRF-TOKEN=abc123'` command
    issued in the browser console (in the developer tools).
  prefs: []
  type: TYPE_NORMAL
- en: Axios automatically reads such a cookie and transmits it in the next request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider that we call an Axios `get` request in our code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Axios will pick up that cookie and add a new header to the request called X-XSRF-TOKEN.
    You can see such headers in the Network tab of the Developer Tools in Chrome by
    clicking on the name of the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ccef71e0-e9d4-4a34-af67-ad1bd4625699.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To prevent XSS attacks, you must ensure that no user input can appear as code
    in your app. This means you must be very careful about using the `v-html` attribute
    (the *Output raw HTML* recipe).
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, you can't control what happens outside your page. If one of your
    users receives a fake e-mail that contains a link that corresponds to an action
    in your application, clicking on the link in the e-mail will trigger the action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make a concrete example; you developed a bank app, *VueBank*, and a
    user of your app receives the following fake e-mail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the mail is not even about our application and the `here` hyperlink
    is hidden in the HTML of the mail itself. In reality, it points to the `http://vuebank.com?give_all_my_money_to_account=754839534` address.
  prefs: []
  type: TYPE_NORMAL
- en: If we are logged in to VueBank, the link may work right away. It does not look
    good for our finances.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent these kinds of attacks, we should have our backend generate a **CSRF** (**Cross
    Site Request Forgery**) token for us. We will take the token and send it along
    the request to prove that the request originated from the user. The preceding
    link will become
  prefs: []
  type: TYPE_NORMAL
- en: '`http://vuebank.com?give_all_my_money_to_account=754839534&csrf=s83Rnj`.'
  prefs: []
  type: TYPE_NORMAL
- en: Since the token is generated randomly every time, the link in the mail cannot
    be forged correctly because the attacker does not know the token that the server
    gave to the web page.
  prefs: []
  type: TYPE_NORMAL
- en: In Vue, we use Axios to send the token. Usually, we won't send it as part of
    the link, but in a header of the request; in fact, Axios does this for us and
    puts in the token in the next request automatically.
  prefs: []
  type: TYPE_NORMAL
- en: You can change the name of the cookie that Axios will pick up by setting the
    `axios.defaults.xsrfCookieName` variable, and you can edit the name of the header
    that will return the token acting on the `axios.defaults.xsrfHeaderName` variable.
  prefs: []
  type: TYPE_NORMAL
