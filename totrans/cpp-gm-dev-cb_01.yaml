- en: Chapter 1. Game Development Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, the following recipes will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing an IDE on Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing the right source control tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using call stacks for memory storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using recursions cautiously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using pointers to store memory addresses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Casting between various datatypes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing memory more effectively using dynamic allocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using bitwise operations for advanced checks and optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover the basic concepts that you need to know to kick-start
    your career in game development.
  prefs: []
  type: TYPE_NORMAL
- en: The first step before a person starts coding is to install an **integrated development
    environment** (**IDE**). Nowadays, there are a few online IDEs that are available,
    but we are going to use an offline standalone IDE, **Visual Studio**. The next
    most important thing that many programmers do not start using at an early stage
    is **revision control software**.
  prefs: []
  type: TYPE_NORMAL
- en: Revision control software helps to back up the code in one central location;
    it has a historical overview of the changes that are made, which you can access
    and revert to if needed, and it also helps to resolve conflicts between files
    that have been worked on by different programmers at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: The most useful feature of C++, in my opinion, is **memory handling**. It gives
    the developers a lot of control over how memory must be assigned depending on
    the current usage and needs of the program. As a result of this, we can allocate
    memory when there is a need and deallocate it accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: If we do not de-allocate memory, we might run out of memory very soon, especially
    if we are using recursion. Sometimes there is a need to convert from one datatype
    to another to prevent loss of data, to pass the correct datatype in a function,
    and so on. C++ provides us a few ways by which we can do those castings.
  prefs: []
  type: TYPE_NORMAL
- en: The recipes in this chapter will primarily focus on these topics and deal with
    practical ways to implement them.
  prefs: []
  type: TYPE_NORMAL
- en: Installing an IDE on Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will find out how easy it is to install Visual Studio on
    your Windows machine.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To go through this recipe, you will need a machine running Windows. No other
    prerequisites are required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Visual Studio is a powerful IDE in which most professional software is written.
    It has loads of features and plugins to help us write better code:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://www.visualstudio.com](https://www.visualstudio.com).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Download Visual Studio Community**.![How to do it…](img/4929_01_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download Visual Studio Community
  prefs: []
  type: TYPE_NORMAL
- en: This should download an `.exe` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After it downloads, double-click on the setup file to start the installation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure you have all the updates necessary on your Windows machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also download any version of Visual Studio or Visual C++ Express.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the application asks for starting environment settings, select **C++** from
    the available options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A few things to note are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: You need a Microsoft account to install it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are other free IDEs for C++, such as **NetBeans**, **Eclipse**, and **Code::Blocks**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While Visual Studio works only for Windows, Code::Blocks and other such IDEs
    are cross-platform and can work on Mac and Linux as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the remainder of this chapter, all code examples and snippets will be provided
    using Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An IDE is a programming environment. An IDE consists of various functionalities
    that can vary from one IDE to another. However, the most basic functionalities
    that are present in all IDEs are a code editor, a compiler, a debugger, a linker,
    and a GUI builder.
  prefs: []
  type: TYPE_NORMAL
- en: 'A code editor, or a source code editor as they are otherwise known, is useful
    for editing code written by programmers. They provide features such as auto-correct,
    syntax highlighting, bracket completion and indentation, and so on. An example
    snapshot of the Visual Studio code editor is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/4929_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A **compiler** is a computer program that converts your C++ code to object code.
    This is necessary in order to create an executable. If you have a file called
    `main.cpp`, it will generate an object code called `main.o`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A **linker** is a computer program that converts the object code generated
    by the compiler to an executable or a library file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/4929_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Compiler and linker
  prefs: []
  type: TYPE_NORMAL
- en: A **debugger** is a computer program that helps to test and debug computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: A **GUI builder** helps the designer and programmer to create GUI content or
    widgets easily. It uses a drag and drop **WYSIWYG** tool editor.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the right source control tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will see how easy it is to take a backup of our code using
    the right version control. The advantages of having a backup to a central server
    is that you will never lose work, can download the code on any machine, and can
    also go back to any of your changes from the past. Imagine it is like a checkpoint
    that we have in games, and you can go back to that checkpoint if you face problems.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To go through this recipe, you will need a machine running Windows. No other
    prerequisites are required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Choosing a correct version tool is very important as it will save a lot of time
    organizing data. There are a few versioning tools that are available, so it is
    very important that we should be informed about all of them so that we can use
    the correct one based on our needs.
  prefs: []
  type: TYPE_NORMAL
- en: First analyze the choices that are available to you. The choices primarily include
    **Concurrent Versions System** (**CVS**), **Apache** **Subversion** (**SVN**),
    **Mercurial**, and **GIT**.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CVS has been around for a long time, so there is tons of documentation and help
    available. However, a lack of atomic operations often leads to source corruption
    and it is not well cut out for long-term branching operations.
  prefs: []
  type: TYPE_NORMAL
- en: SVN was made as an improvement to CVS and it does fix many of its issues relating
    to atomic operations and source corruption. It is free and open source. It has
    lots of plugins for different IDEs. However, one of the major drawbacks of this
    tool is that it is comparatively very slow in its operations.
  prefs: []
  type: TYPE_NORMAL
- en: GIT was made primarily for Linux but it improves operation speed a lot. It works
    on UNIX systems as well. It has cheap branch operations but it is not totally
    optimized for a single developer and its Windows support is limited compared to
    Linux. However, GIT is extremely popular and many prefer GIT to SVN or CVS.
  prefs: []
  type: TYPE_NORMAL
- en: Mercurial came into existence shortly after GIT. It has node-based operations
    but does not allow the merging of two parent branches.
  prefs: []
  type: TYPE_NORMAL
- en: So to sum up, use SVN if you want a central repository that others can push
    and pull. Although it has its limitations, it's easy to learn. Use Mercurial or
    GIT if you want a distributed model. In this case, there is a repository on every
    computer, and generally, one of them is regarded as the *official* one. Mercurial
    is often preferred if it is a relatively small team, and it's easier to learn
    than GIT.
  prefs: []
  type: TYPE_NORMAL
- en: We will look into these in more detail in a separate chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Detailed steps to download the code bundle are mentioned in the Preface of this
    book. Please have a look.
  prefs: []
  type: TYPE_NORMAL
- en: The code bundle for the book is also hosted on GitHub at [https://github.com/PacktPublishing/C++Game-Development-Cookbook](https://github.com/PacktPublishing/C++Game-Development-Cookbook).
    We also have other code bundles from our rich catalog of books and videos available
    at [https://github.com/PacktPublishing/](https://github.com/PacktPublishing/).
    Check them out!
  prefs: []
  type: TYPE_NORMAL
- en: Using call stacks for memory storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main reason why C++ is still the preferred language for most game developers
    is that you handle memory yourself and control the allocation and de-allocation
    of memory to a great extent. For that reason, we need to understand the different
    memory spaces that are provided to us. When data is "pushed" onto the stack, the
    stack grows. As data is "popped" off the stack, the stack shrinks. It is not possible
    to pop a particular piece of data off the stack without first popping off all
    data placed on top of it. Think of this as a series of compartments aligned top
    to bottom. The top of the stack is whatever compartment the stack pointer happens
    to point to (this is a register).
  prefs: []
  type: TYPE_NORMAL
- en: Each compartment has a sequential address. One of those addresses is kept in
    the stack pointer. Everything below that magic address, known as the top of the
    stack, is considered to be on the stack. Everything above the top of the stack
    is considered to be off the stack. When data is pushed onto the stack, it is placed
    into a compartment above the stack pointer, and then the stack pointer is moved
    to the new data. When data is popped off the stack, the address of the stack pointer
    is changed by moving it down the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to have a working copy of Visual Studio installed on your Windows machine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C++ is probably one of the best programming languages out there and one of
    the main reasons for that is that it is also a low level language, because we
    can manipulate memory. To understand memory handling, it is very important to
    understand how memory stacks work:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Win32 Console Application**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a source file called `main.cpp` or anything that you want to name the source
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you call the function `CountTotalBullets`, the code branches to the called
    function. The parameters are passed in and the body of the function is executed.
    When the function completes, a value is returned and the control returns to the
    calling function.
  prefs: []
  type: TYPE_NORMAL
- en: But how does it really work from a compiler's point of view? When you begin
    your program, the compiler creates a stack. The **stack** is a special area of
    memory allocated for your program in order to hold the data for each function
    in your program. A stack is a **Last In First Out** (**LIFO**) data structure.
    Imagine a deck of cards; the last card put on the pile will be the first card
    taken out.
  prefs: []
  type: TYPE_NORMAL
- en: 'When your program calls `CountTotalBullets`, a stack frame is established.
    A **stack frame** is an area of the stack set aside to manage that function. This
    is very complex and different on different platforms, but these are the essential
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The return address of `CountTotalBullets` is put on the stack. When the function
    returns, it will resume executing at this address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Room is made on the stack for the return type you have declared.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All arguments to the function are placed on the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The program branches to your function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Local variables are pushed onto the stack as they are defined.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using recursions cautiously
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recursions are a form of programming design in which the function calls itself
    multiple times to solve a problem by breaking down a large solutions set into
    multiple small solution sets. The code size definitely shortens. However, if not
    used properly, recursions can fill up the call stack really fast and you can run
    out of memory.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started with this recipe, you should have some prior knowledge of call
    stacks and how memory is assigned during a function call. You need a Windows machine
    with a working copy of Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, you will see how easy it is to use recursions. Recursions are
    very smart to code but also can lead to some serious problems:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Win32 Console Application**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a source file called `main.cpp` or anything that you want to name the source
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see from the preceding code, both the functions find the factorial
    of a number. However, when using recursion, the stack size will grow immensely
    with each function call; the stack pointer has to be updated every call and data
    pushed onto the stack. With recursion, as the function calls itself, every time
    a function is called from within itself the stack size will keep on rising until
    it runs out of memory and creates a deadlock or crashes.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine finding the factorial of 1000\. The function will be called within itself
    a very large number of times. This is a recipe for certain disaster and we should
    avoid such coding practices to a great extent.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use a larger datatype than int if you are finding the factorial of a
    number greater than 15, as the resulting factorial will be too large to be stored
    in int.
  prefs: []
  type: TYPE_NORMAL
- en: Using pointers to store memory addresses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous two recipes, we have seen how not having sufficient memory can
    be a problem to us. However, until now, we have had no control over how much memory
    is assigned and what is assigned to each memory address. Using pointers, we can
    address this issue. In my opinion, pointers are the single most important topic
    in C++. If your concept of C++ has to be clear, and if you are to become a good
    developer in C++, you must be good with pointers. Pointers can seem very daunting
    at first, but once you get the hang of it, pointers are pretty easy to use.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need a Windows machine with a working copy of Visual
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will see how easy it is to work with pointers. Once you
    are comfortable using pointers, we can manipulate memory and store references
    in memory quite easily:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Win32 Console Application**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a source file called `main.cpp` or anything that you want to name the source
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the most powerful tools of a C++ programmer is to manipulate computer
    memory directly. A **pointer** is a variable that holds a memory address. Each
    variable and object used in a C++ program is stored in a specific place in memory.
    Each memory location has a unique address. Memory addresses will vary depending
    on the operating system used. The amount of bytes taken up depends on the variable
    type: *float = 4 bytes*, *short = 2 bytes*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/4929_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Pointers and memory storage
  prefs: []
  type: TYPE_NORMAL
- en: Each location in the memory is 1 byte. The pointer `pfLocalCurrentHealth` holds
    the address of the memory location that has stored `fCurrentHealth`. Hence, when
    we display the contents of the pointer, we get the same address as that of the
    address containing the `fCurrentHealth` variable. We use the `&` operator to get
    the address of the `pfLocalCurrentHealth` variable. When we reference the pointer
    using the `*` operator, we get the value stored at the address. Since the stored
    address is same as the address storing `fCurrentHealth`, we get the value `10`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us consider the following declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`const float* pfNumber1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float* const pfNumber2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const float* const pfNumber3`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of these declarations are valid. But what do they mean? The first declaration
    states that `pfNumber1` is a pointer to a constant float. The second declaration
    states that `pfNumber2` is a constant pointer to a float. The third declaration
    states that `pfNumber3` is a constant pointer to a constant integer. The key differences
    between references and these three types of const pointers are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`const` pointers can be NULL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A reference does not have its own address, whereas a pointer does
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The address of a reference is the actual object's address
  prefs: []
  type: TYPE_NORMAL
- en: A pointer has its own address and it holds as its value the address of the value
    it points to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information on pointers and references, go to the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in/57492#57492](http://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in/57492#57492)'
  prefs: []
  type: TYPE_NORMAL
- en: Casting between different datatypes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Casting is a conversion process of changing some data into a different type
    of data. We can convert between built-in types or our own datatypes. Some of the
    conversions are done automatically by the compiler, and the programmer does not
    have to intervene. Such conversions are called **implicit conversions**. Other
    conversions, which have to be directly specified by the programmer, are called
    explicit conversion. Sometimes we may get warnings about *loss of data*. We should
    pay heed to these warnings and think about how this might adversely affect our
    code. Casting is commonly used when the interface expects a particular type, but
    we want to feed it data of a different type. With C, we can cast anything to everything.
    However, C++ provides us with finer controls.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need a Windows machine with a working copy of Visual
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will see how we can easily cast or convert between various
    datatypes. Usually, a programmer uses C-style casting even in C++, but this is
    not recommended. C++ provides us with its own style of casting for different situations
    which we should use:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Win32 Console Application**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a source file called `main.cpp` or anything that you want to name the source
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are four types of casting operators in C++, depending on what we are
    casting: `static_cast`, `const_cast`, `reinterpret_cast`, and `dynamic_cast`.
    Now, we are going to look at `static_cast`. We will look at the remaining three
    casting technique after we discuss dynamic memory and classes. Converting from
    a smaller datatype to a larger type is called promotion and is guaranteed to have
    no data loss. However, conversion from a larger datatype to a smaller one is called
    demotion and may lead to data loss. Compilers will generally give you a warning
    when this happens, and you should pay heed to this.'
  prefs: []
  type: TYPE_NORMAL
- en: Let us look at the previous example. We have initialized an integer with the
    value `5`. Next, we have initialized a floating point variable and stored the
    result of `5` divided by `2`, which is `2.5`. However, when we display the variable
    `fNumber`, we see that the displayed value is `2`. The reason is the C++ compiler
    implicitly casts the result of `5/2` and stores it as an integer. So it is evaluating
    something similar to int (`5/2`) which is int (`2.5`), evaluating to `2`. So to
    achieve our desired result, we have two options. The first method is a C-style
    explicit cast, which is not recommended at all because it does not have a type
    safe check. The format for the C-style cast is (`resultant_data_type`) (`expression`),
    which in this case is something like float (`5/2`). We are explicitly telling
    the compiler to store the result of the expression as a floating point number.
    The second method, and a more C++ style way of doing the cast, is by using the
    `static_cast` operation. This has suitable constructors to dictate that the conversion
    is type safe. The format for a `static_cast` operation is `static_cast<resultant_data_type>
    (expression)`. The compiler checks if the casting conversion is safe and then
    executes the type casting operation.
  prefs: []
  type: TYPE_NORMAL
- en: Managing memory more effectively using dynamic allocation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Programmers generally deal with five areas of memory: **global namespace**,
    **registers**, **code space**, **stack**, and the **free store**. When an array
    is initialized, the number of elements has to be defined. This leads to lots of
    memory problems. Most of the time, not all elements that we allocated are used,
    and sometimes we need more elements. To help overcome this problem, C++ facilitates
    memory allocation while an `.exe` file is running by using the free store.'
  prefs: []
  type: TYPE_NORMAL
- en: The free store is a large area of memory that can be used to store data, and
    is sometimes referred to as *the heap*. We can request some space on the free
    store, and it will give us an address that we can use to store data. We need to
    keep that address in a pointer. The free store is not cleaned up until your program
    ends. It is the programmer's responsibility to free any free store memory used
    by their program.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of the free store is that there is no need to preallocate all
    variables. We can decide at runtime when more memory is needed. The memory is
    reserved and remains available until it is explicitly freed. If memory is reserved
    while in a function, it is still available when control returns from that function.
    This is a much better way of coding than global variables. Only functions that
    have access to the pointer can access the data stored in memory, and it provides
    a tightly controlled interface to that data.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need a Windows machine with a working copy of Visual
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will see how easy it is to use dynamic allocation. In games,
    most of the memory is allocated dynamically at runtime as we are never sure how
    much memory we should assign. Assigning an arbitrary amount of memory may result
    in less memory or memory wastage:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a source file called `main.cpp` or anything that you want to name the source
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can allocate memory to the free store using the `new` keyword; `new` is
    followed by the type of the variable you want to allocate. This allows the compiler
    to know how much memory will need to be allocated. In our example, we have used
    string. The `new` keyword returns a memory address. This memory address is assigned
    to a pointer, `sNameOfGuns`. We must assign the address to a pointer, otherwise
    the address will be lost. The format for using the `new` operator is `datatype
    * pointer = new datatype`. So in our example, we have used `sNameOfGuns = new
    string[iNumberofGuns]`. If the new allocation fails, it will return a null pointer.
    We should always check whether the pointer allocation has been successful; otherwise
    we will try to access a part of the memory that has not been allocated and we
    may get an error from the compiler, as shown in the following screenshot, and
    your application will crash:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/4929_01_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you are finished with the memory, you must call delete on the pointer.
    Delete returns the memory to the free store. Remember that the pointer is a local
    variable. Where the function that the pointer is declared in goes out of scope,
    the memory on the free store is not automatically deallocated. The main difference
    between static and dynamic memory is that the creation/deletion of static memory
    is handled automatically, whereas dynamic memory must be created and destroyed
    by the programmer.
  prefs: []
  type: TYPE_NORMAL
- en: The `delete[]` operator signals to the compiler that it needs to free an array.
    If you leave the brackets off, only the first element in the array will be deleted.
    This will create a memory leak. Memory leaks are really bad as it means there
    are memory spaces that have not been deallocated. Remember, memory is a finite
    space, so eventually you are going to run into trouble.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we use `delete[]`, how does the compiler know that it has to free *n*
    number of strings from the memory? The runtime system stores the number of items
    somewhere it can be retrieved only if you know the pointer `sNameOfGuns`. There
    are two popular techniques that do this. Both of these are used by commercial
    compilers, both have tradeoffs, and neither are perfect:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Technique 1:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Over-allocate the array and put the number of items just to the left of the
    first element. This is the faster of the two techniques, but is more sensitive
    to the problem of the programmer saying `delete sNameOfGuns`, instead of `delete[]
    sNameOfGuns`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Technique 2:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use an associative array with the pointer as a key and the number of items as
    the value. This is the slower of the two techniques, but is less sensitive to
    the problem of the programmer saying `delete sNameOfGuns`, instead of `delete[]
    sNameOfGuns`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can also use a tool called **VLD** to check for memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Download VLD from [https://vld.codeplex.com/](https://vld.codeplex.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'After the setup has downloaded, install VLD on your system. This may or may
    not set up the VC++ directories correctly. If it doesn''t, do it manually by right-clicking
    on the project page and adding the directory of VLD to the field called **Include
    Directories**, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more…](img/4929_01_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After setting up the directories, add the header file `<vld.h>` in your source
    file. After you execute your application and exit it, your output window will
    now show whether there are any memory leaks in your application.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the error messages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When using the debug build, you may notice the following values in memory during
    debugging:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0xCCCCCCCC`: This refers to values being allocated on the stack, but not yet
    initialized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0xCDCDCDCD`: This means memory has been allocated in the heap, but it is not
    yet initialized (clean memory).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0xDDDDDDDD`: This means memory has been released from the heap (dead memory).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0xFEEEFEEE`: This refers to values being deallocated from the free store.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0xFDFDFDFD`: "No man''s land" fences, which are placed at the boundary of
    heap memory in debug mode. These should never be overwritten, and if they are,
    it probably means the program is trying to access memory at an index outside of
    an array''s max size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using bitwise operations for advanced checks and optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most cases, a programmer will not need to worry too much about bits unless
    there is a need to write some compression algorithms, and when we are making a
    game, we never know when a situation such as that arises. In order to encode and
    decode files compressed in this manner, you need to actually extract data at the
    bit level. Finally, you can use bit operations to speed up your program or perform
    neat tricks. However, this is not always recommended.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need a Windows machine with a working copy of Visual
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will see how easy it is to use bitwise operations to perform
    operations by manipulating memory. Bitwise operations are also a great way to
    optimize code by directly interacting with memory:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a source file called `main.cpp` or anything that you want to name the source
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The left shift operator is the equivalent of moving all the bits of a number
    a specified number of places to the left. In our example, the numbers we are sending
    to the function `Multi_By_Power_2` is `4` and `3`. The binary representation of
    `4` is `100`, so if we shift the most significant bit, which is `1`, three places
    to the left, we get `10000`, which is the binary of `16`. Hence, left shift is
    equivalent to integer division by `2^shift_arg`, that is, `4*2^3`, which is again
    `16`. Similarly, the right shift operation is equivalent to integer division by
    `2^shift_arg`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let us consider we want to pack data so that the data is compressed. Consider
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We are storing the total bullets in a gun; the type of gun, but it can only
    be a rifle or pistol; and the total bullets per round it can fire. Currently we
    are using three integer values to store the data. However, we can compress all
    the preceding data into one single integer and hence compress the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If we assume the following notations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'TotalAmmon: `A`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Type: `T`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rounds: `R`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The final representation in the data would be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
