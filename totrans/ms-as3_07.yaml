- en: Language Support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For an IDE to be considered truly essential, it has to do more than just offer
    the basics. In particular, it has to be accessible to developers from all kinds
    of backgrounds, using all kinds of languages and philosophies. For example, many
    developers prefer to take an object-oriented approach, whereas others prefer a
    more function-based philosophy, and many potential projects will lend themselves
    more easily to one or the other of these paradigms.
  prefs: []
  type: TYPE_NORMAL
- en: Android Studio 3 provides complete language support for both C++ and Kotlin,
    giving the developer the chance to focus on speed or programmability depending
    on the needs of the project in hand.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to providing this language support, Android Studio also facilitates
    the development of apps for a wide variety of form factors. The reader will already
    be familiar with Android Wear and Android Auto, and recently the IDE has included
    support for Android Things.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will take a look at these language support systems and the
    exciting new form factors that comprise the **Internet of Things** (**IoT**).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Including Kotlin language support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating Kotlin with Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying Kotlin extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up native components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Including C/C++ code within a project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an Android Things project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kotlin support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the dawn of the mobile app, software development has undergone more than
    one revolution, and the Android framework has been no stranger to these changes.
    Many developers prefer Java as it is relatively easy to work with, but there will
    always be times when we want the raw speed of C++, and Java predates mobile devices
    by decades. Wouldn't it be nice if there ware a high-level language, such as Java,
    that had been designed with mobile development largely in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, a JetBrains team in Russia created Kotlin, which works alongside
    Java and even runs on the Java Virtual Machine, to create a language that better
    suits the needs of Android developers. It is also 100 percent interoperable with
    Java, so you can use Java and Kotlin files in the same project, and everything
    will still compile. You can also continue to use all existing Java frameworks
    and libraries with Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin has been available for some time to developers as a plugin, but since
    the inception of Android Studio 3.0, Kotlin is now fully integrated into the IDE
    and is officially supported as a development language by Google. Both working
    samples written in Kotlin and wizard templates are included in the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8482cd4-7b27-4aa5-a322-1fc29ad13536.png)'
  prefs: []
  type: TYPE_IMG
- en: Including Kotlin support in the project setup wizard
  prefs: []
  type: TYPE_NORMAL
- en: Learning a new programming language is rarely a great deal of fun, and Kotlin
    is no exception. What takes the hardwork out of using it is that we do not have
    to make the leap from one language to another in a single jump, we can gradually
    introduce Kotlin as and when we choose.
  prefs: []
  type: TYPE_NORMAL
- en: Many of us will have worked with Java for a very long time and will see no real
    reason for changing. After all, Java works perfectly well, and years of experience
    can lead to some very speedy work practices. On top of this, the internet is awash
    with high-quality, open source, code repositories, making research and learning
    new skills very appealing to the Java coder.
  prefs: []
  type: TYPE_NORMAL
- en: It will never be strictly necessary to learn and use Kotlin in Android development,
    but it is certainly worth taking a look at why so many developers think it represents
    the future of Android app development.
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Along with Google's own endorsements, there are a number of good reasons for
    developers to consider Kotlin. One of the reasons might be the end to null pointer
    exceptions, which the compiler acheives by not allowing a null value to be assigned
    to any object reference. Other exciting features of the language include favoring
    composition over inheritance, smart casting, and the ability to create data classes.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to see how much of an advantage such innovations provide is to
    take a look at these.
  prefs: []
  type: TYPE_NORMAL
- en: As the screenshot in the preceding section demonstrates, Kotlin can be included
    into a project directly from the template wizard, but we can also include Kotlin
    classes from an already open project in precisely the same way that we add any
    other class or file, from the module's New menu.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f3358cf0-c019-4b3e-a705-6962e2ca9d66.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding a new Kotlin file/class
  prefs: []
  type: TYPE_NORMAL
- en: 'Including a Kotlin class in this manner will prompt the IDE to automatically
    configure Kotlin with Gradle. It does this by modifying the top-level `build.gradle` file
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Using Kotlin in an Android application will incur almost no extra overheads;
    moreover, once it is compiled, Kotlin code will run no more slowly than its Java
    equivalent, nor will it occupy any more memory.
  prefs: []
  type: TYPE_NORMAL
- en: Including a new Kotlin class or file like this is very useful, but what about
    creating a Kotlin activity or fragment from a template? As Java developers, we
    are used to simple configuration dialogs to set these up. Fortunately, Kotlin
    activities are no different, and the Configure Activity dialog allows us to select
    our source language appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23a4e7b9-8cd7-4e9e-95db-f2d621c88856.png)'
  prefs: []
  type: TYPE_IMG
- en: Selecting the source language
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, it is well worth taking a look at the resultant code to see just
    how much more concise and readable it is compared to the tradition Java activity/fragment
    templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This code can be made even more concise by removing calls to `findViewById()`
    using the Kotlin extension, as explained in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although mixing-and-matching languages this way can be very useful to adapt
    and update existing apps, Kotlin really comes into its own when applied across
    an entire project. Perhaps its most appealing feature is its conciseness, and
    this can be easily seen by starting two projects from scratch and comparing their
    code. The following is the `onCreate()` listing from the Navigation Drawer template
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is its Kotlin equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The increased simplicity of this syntax is something all developers will welcome,
    and this is by no means the only advantage to using Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Extending Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As one would expect with any powerful programming paradigm, it can be extended
    with a plugin to increase its usefulness even further.
  prefs: []
  type: TYPE_NORMAL
- en: Every Android developer will have lost count of the number of times they have
    typed `findViewById()`. They will also be aware of how error-prone such static
    typing can be.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Kotlin extension is included, by default, when Kotlin support is enabled
    during project setup, as can be seen in the module-level `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Using an extension also requires that it be imported into the appropriate class,
    usually an activity or fragment. It is more than likely that the reader will have
    set up automatic imports through system settings. All that is needed then is to
    create a view using XML in the usual fashion, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, all that is needed to set values on that widget is something along the
    lines of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Regardless of whether you have imports set to be included automatically, it
    is useful to know the format these imports take. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to import a reference to a specific view rather than the
    entire layout file with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import kotlinx.android.synthetic.main.some_layout.text_view`'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, `some_layout.xml` would be the file containing our `text_view`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you are in the healthy habit of using `<include>` to reference content XML
    from your activity XML, then you will need two imports, along these lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: It is not only the text we can set here; any function we like can be called
    in the same way without ever having to reference a view by searching for its ID.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the use of a semicolon as a statement delineation is entirely optional
    in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, by now, the reader will be convinced of the advantages of coding
    in Kotlin, but before we move on, one Kotlin feature is hidden away at the bottom
    of the main `Code` menu. This is Convert Java File to Kotlin File. This does exactly
    what it says and can even find and solve most conversion issues, making it a great
    time-saver and a fun way to learn the differences between the two languages.
  prefs: []
  type: TYPE_NORMAL
- en: Automatically convert Java into Kotlin with *Ctrl* + *Alt* + *Shift* + *K*.
  prefs: []
  type: TYPE_NORMAL
- en: Although Kotlin may be one of the newest additions to Android Studio, it is
    not our only choice for an alternative language, and the speed and low-level memory
    access that C++ provides have made it many developers' first choice. In the following
    section we will see how this powerful language can be easily supported by the
    IDE.
  prefs: []
  type: TYPE_NORMAL
- en: C/C++ support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen so far, there are pros and cons to all programming languages.
    C and C++ probably take a little more discipline to master, but this is often
    more than made up for by the low-level control the language provides us with.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to Android Studio, a slightly different subset of development
    tools is required. This includes the **Native Development Kit** (**NDK**) and
    the **Java Native Interface** (**JNI**), along with other ways of debugging and
    building. As with most processes in Android Studio, setting up these tools is
    quite straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: The NDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in the preceding section, native programming requires a slightly
    different set of tools from those we have been using up until now. As one might
    expect, everything we need can be found in the SDK Manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is most likely that you will need to install the components highlighted
    in the following screenshot; you will need at least NDK, CMake, and LLDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d0c0b7cd-f80b-4186-b30d-5d5cc1f16719.png)'
  prefs: []
  type: TYPE_IMG
- en: Native development components
  prefs: []
  type: TYPE_NORMAL
- en: 'CMake: This a multiplatform test and build tool works alongside Gradle. For
    comprehensive documentation, visit [cmake.org](https://cmake.org/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'LLDB: This is a powerful, open source debugging tool designed specifically
    to work with multithreaded applications. Its detailed usage is beyond the scope
    of this book, but interested users can visit [lldb.llvm.org](http://lldb.llvm.org/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the correct software installed, native coding is incorporated into Android
    Studio projects very smoothly, alongside our Java/Kotlin classes and files. As
    with Kotlin support, all that is needed is to check the appropriate box during
    setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this option is selected, you will be given the opportunity to configure
    C++ support, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f4bb14b-8e7f-4a61-baca-37ade8605f52.png)'
  prefs: []
  type: TYPE_IMG
- en: The C++ support customization dialog
  prefs: []
  type: TYPE_NORMAL
- en: 'Selecting Toolchain Default as Standard is your best option if you are working
    with CMake, and both Exceptions Support and Runtime Type Information Support are
    probably worth checking on most occasions. Their inclusion can be most clearly
    seen by examining the module-level `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As is often the case, one of the best ways to get a good look under the hood
    without having to get our hands too dirty is with the ready-made Android samples.
    There are not a huge number of these, but they are all good, and there is a growing
    community project on GitHub at [github.com/googlesamples/android-ndk](https://github.com/googlesamples/android-ndk).
  prefs: []
  type: TYPE_NORMAL
- en: What all these samples show is which code structures are added and where; like
    the project structures we've encountered before, the actual file structure is
    not reflected by the project file explorer, which organizes files according to
    their type, not location.
  prefs: []
  type: TYPE_NORMAL
- en: The obvious additions are the `main/cpp` directory, containing source code,
    and the external build files used by CMake.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e2f1e49-266e-490d-89e0-fc3c9abe4844.png)'
  prefs: []
  type: TYPE_IMG
- en: Native code structures
  prefs: []
  type: TYPE_NORMAL
- en: C++ is not everyone's cup of tea, and going into greater detail is beyond the
    scope of this book. From an Android Studio point of view, those who want to take
    further advantage of the NDK will find that the way that CMake seamlessly integrates
    with Gradle makes testing and building apps calling on native libraries a fantastic
    time-saver.
  prefs: []
  type: TYPE_NORMAL
- en: One of the beauties of the Android OS, for users, manufacturers, and developers
    alike, is the enormous variety of devices it can, and does, run on. At first,
    this phenomenon appeared on our wrist watches, television sets, and in our cars.
    More recently, the development of the IoT has led to the need for sophisticated
    operating systems in any number of electronic devices. This has led Google to
    develop Android Things.
  prefs: []
  type: TYPE_NORMAL
- en: Android Things
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The IoT has already made an impact on the consumer with the introduction of
    smart household appliances, such as kettles and washing machines. In addition
    to this, many municipal authorities uses the technology to manage things such
    as traffic and utility usage.
  prefs: []
  type: TYPE_NORMAL
- en: In reality, absolutely any device could constitute a Thing. A device does not
    even need to have a screen or any buttons, provided it has an IP address and can
    communicate with other devices. One can even get a toothbrush with an IP address,
    although the advantages of that sadly escape me.
  prefs: []
  type: TYPE_NORMAL
- en: From a developer's perspective, the IoT is incredibly exciting, and the inclusion
    of APIs in the SDK opens up almost unlimited new worlds. Naturally, these APIs
    have been sewn neatly into Android Studio, making Android Thing development as
    simple and as much fun as any other branch of Android app creation.
  prefs: []
  type: TYPE_NORMAL
- en: Development kits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Perhaps the most significant differences between Android Things and other forms
    of Android development is the hardware. It is tempting to think that an expertise
    in embedded circuitry is needed, and although a little knowledge in this area
    is useful, it is by no means necessary, as Google works with **System on a Chip**
    (**SoC**) manufacturers, such as Intel, NXP, and Raspberry Pi, to produce developer
    kits that allow us to quickly produce and test prototypes.
  prefs: []
  type: TYPE_NORMAL
- en: As always, Android Studio has been designed to assist us in as many ways as
    possible, and of course, there are a support library, system images, and a growing
    collection of working samples to help us on our way. Unfortunately, there is no
    way to simply emulate Android Things, and although some functions can be emulated
    on some mobile AVDs, some form of physical development kit is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is perfectly possible to create one''s own development board with a little
    expertise and a soldering iron, but the low prices of boards, such as the Intel
    Edison and the Raspberry Pi, along with free system images from Android make this
    a time-consuming process. If what you have is an idea and you want to quickly
    test and develop it into a finished project, the way to go is with an approved
    development kit, such as the Raspberry Pi 3, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a3d74ca-94d7-4c9c-a60d-2cfec1d7f6b1.png)'
  prefs: []
  type: TYPE_IMG
- en: Raspberry Pi 3
  prefs: []
  type: TYPE_NORMAL
- en: Information about which single-board computers are available for Things can
    be found at [developer.android.com/things/hardware/developer-kits.html](http://developer.android.com/things/hardware/developer-kits.html). There
    are also peripheral kits available for each of the boards, and these can be found
    on the same page.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have chosen a kit, system images can be found at [developer.android.com/things/preview/download.html ](http://developer.android.com/things/preview/download.html)and
    also on your Things developer console at [partner.android.com/things/console/](http://partner.android.com/things/console/).
  prefs: []
  type: TYPE_NORMAL
- en: Once you have your kit and peripherals, you are ready to develop your first
    Things application, the basics of which are outlined in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Things project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The APIs used by Android Things are not included in the standard SDK, and so
    a support library is required. At the very least, you will need the following
    dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Along with this entry in your manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Most Things projects will need more than this, depending on which peripherals
    are used and whether the project will be tested using Firebase. Taking a look
    at the provided samples is a good way to see what dependencies are needed; the
    following snippet is taken from the Things Doorbell sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The next major difference in setting up an Android Things project can be seen
    in the manifest file, and adding the highlighted `<intent-filter>` in the following
    code will enable the project to run successfully when testing and debugging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: These are really the only differences when it comes to setting up an Android
    Things project. The other differences will be based more around which peripherals
    and sensors are being used. As is so often the case, one of the best ways to explore
    Things further is through the provided samples. Not many samples are available,
    but the number is growing, and they have all been written to assist our learning.
  prefs: []
  type: TYPE_NORMAL
- en: Developing for Android Things can appear daunting for many developers, but the
    way that Android Studio facilitates this through its system images, support libraries,
    and code samples means that any developer with a great idea can cheaply and quickly
    develop, test, and produce such products.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we explored some of the more exotic ways in which Android
    Studio can assist the developer. Google's immense influence in the digital world
    has provided alternative technologies such as the Kotlin language and encouraged
    manufacturers to develop technologies that appeal to Android developers in a way
    that makes cutting-edge technology available to anyone with skills and ideas.
  prefs: []
  type: TYPE_NORMAL
- en: Android Studio is not alone in offering the opportunity to code in different
    languages or for different form factors, but Android Studio does make it simpler
    and easier for developers to learn new skills.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will take a look at one of the final development stages;
    testing. This will give us a great chance to explore one of Android Studio''s
    most innovative and useful tools: the device monitor and profiler.'
  prefs: []
  type: TYPE_NORMAL
