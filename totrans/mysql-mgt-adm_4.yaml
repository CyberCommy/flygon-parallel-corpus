- en: Chapter 4. Data Modeling with Navicat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As of version 10 of Navicat, a data modeler feature has been added to the application,
    which allows the user to create and edit database objects, such as tables, fields,
    and relationships in a visual editor.
  prefs: []
  type: TYPE_NORMAL
- en: PremiumSoft (the makers of Navicat) also released this feature as a separate
    application software product with the name **Navicat Data Modeler**, and it is
    available for Windows, Mac OS X, and Linux. For those who exclusively require
    a visual tool for data modeling and do not require the other administration and
    data management tools, which were covered in the previous chapters, Navicat Data
    Modeler could be a pertinent choice.
  prefs: []
  type: TYPE_NORMAL
- en: While Oracle's MySQL Workbench (a GUI administration and database modeling tool
    for MySQL) could be considered a free alternative, Navicat Data Modeler provides
    means for easier manipulation of model objects and also presents some advanced
    features, such as history tracking and database synchronization; thanks to this,
    you can asynchronously work with data diagrams for later synchronization with
    actual database structure(s). For a better understanding of the functionalities
    of Navicat modeling tools, we will begin the chapter by following a tutorial to
    design our first data model, in order to aid you in learning each feature step
    by step.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn how to master Navicat''s visual data modeling
    tool, which makes it easy to:'
  prefs: []
  type: TYPE_NORMAL
- en: Design data models in a GUI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create, edit, and manipulate table structures from within the visual editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forward-engineer a data model into a `.sql` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reverse-engineer an existing database into visual representations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Navicat's model designer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we begin designing our first data model, it is a good idea to get acquainted
    with the tools that Navicat Data Modeler provides, which we have at our disposal.
  prefs: []
  type: TYPE_NORMAL
- en: The last button on the main toolbar in Navicat's main window is the **Model**
    button. Clicking on this button will take you to the model view. An alternative
    way is to select **Model** from the **View** menu (on the Mac, you can press the
    *+* key and the *8* key simultaneously as a shortcut). Then you can create a new
    blank model by right-clicking anywhere in the object pane of the main window and
    selecting **New model**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On the Mac, press the *+* key and the *N* key simultaneously as a shortcut or
    click on the *+* button at the bottom-left side frame in the main window. On a
    Windows PC, simply click on the **New Model** button on the secondary toolbar,
    located under the main toolbar in the main window.
  prefs: []
  type: TYPE_NORMAL
- en: 'The screenshot of Navicat''s toolbar on Mac and Windows is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with Navicat''s model designer](img/7461EN_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This action also brings up a new window called **model designer** , where you
    can edit the data model. The left side pane of the **model designer** window contains
    the diagram of a tree palette that aids you to toggle its counterpart; a model
    tree palette is obtained by clicking on the tiny icons just above it. The diagram
    tree palette lists the model objects, such as tables, relationships, notes, and
    images (pictures) of the active diagram in alphabetical order. The model tree
    palette lists only the table objects of all the diagrams in the model. Now these
    metaphors can be extremely confusing, so I will describe briefly what each metaphor
    means and also explain their hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Each model can contain one or more diagram that could also be called **entity-relationship
    diagrams** (**ER diagrams**) among database administrators. A database design
    can be split across the multiple diagrams within a model. There is also the concept
    of **layers**, but unlike graphics and image processing applications, layers in
    Navicat's Data Modeler are not containers or placeholders. Just like other objects,
    they are drawn on the canvas, but with a slight difference so that they are opaque
    and can be overlaid on other objects. Layers can be useful to organize certain
    objects by grouping the related ones and separating them according to different
    concerns. For example, when designing an ERP database, you may want to gather
    tables related with accounting and finance in one layer, and those related with
    sales and marketing in another.
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with Navicat''s model designer](img/7461EN_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Aligned to the right-hand side of it is a vertical toolbar also called the model
    diagram palette, from which you can select the type of database object you want
    to place in the diagram. The available objects in this context are tables, notes
    (labels), pictures (images), layers, and relationships. The right side of the
    window contains the **Properties** palette (on the lower left-hand side in Windows),
    and it is used to display and edit the properties of the active diagram and the
    objects it contains. Here you can manage every setting, pertaining to the selected
    item in the canvas, with options to rename the diagram, adjust the number of pages
    (significant when printing), adjust the font and color of the labels of the objects,
    and the notation of the diagram. There are five notations available—**Default**,
    **Simple**, **IDEF1X**, **UML**, and **Crow's Foot**, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Below the **Properties** palette is **History Palette** (in the Mac version)
    that lists every action you performed step by step, allowing you to take these
    actions back by as many steps as you wish. There''s also a preview pane on the
    opposite side, almost placed symmetrically, that you can use for a map-like navigation.
    In the Windows version, these two palettes are placed at each other''s exact opposite
    location. Refer to the following screenshot of Navicat in the Mac version:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with Navicat''s model designer](img/7461EN_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating our first model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section features a tutorial in which we will create the model of a fairly
    **Simple To Do** application for the database. Our new database will consist of
    three tables—**tasks**, **categories**, and **users**. Using the model designer,
    we will design these tables and also define the field types, primary keys, and
    relationships. All of these three tables will be interrelated to each other using
    foreign keys. We will then annotate the model and finally generate the actual
    database, forward-engineering the model we will have created. To start working
    on the model, switch to the **model view** window(if you haven't already done
    so) by clicking on the large **Model** icon on the main toolbar of Navicat's main
    window; or select **Model** from the **View** menu, and then to create a new model,
    right-click on the empty area in the object pane and select **New Model** from
    the pop-up menu. In the Windows version of Navicat, you can also simply click
    on the **New Model** button from the smaller secondary toolbar,right under the
    main toolbar of Navicat's main window. In the Mac version, there is no secondary
    toolbar. Instead, on the lower frame, which is thick enough to fit a small button,
    there is a **+** sign. This **+** sign intuitively indicates the function of adding
    an object in the chosen context. In this case, a model is accompanied by two more
    buttons; one is with a **-** sign that means delete, the other with a pencil icon
    that means edit. (The Windows version has equivalent buttons explicitly labeled
    as **Design Model** and **Delete Model** respectively.) After you perform this
    step, a new model designer window named **Untitled–Model** will pop up, presenting
    you with a blank diagram named **Diagram 1**. Now, let's get ready to start editing
    the model by creating our first table in the diagram. Click on the **Table** button
    (a tiny button with a table-shaped icon) from the vertical model diagram toolbar,
    and then click on an empty area of the canvas. You could also right-click on the
    canvas and select **New** | **Table** from the pop-up menu. A new, square-like
    box with rounded corners will be drawn in the canvas right where you last clicked,
    with a blue title bar labeled as **Table 1** also highlighted, indicating that
    it's ready to be renamed for your convenience. In order to rename it, type `category`
    and press the *Enter* key. Next, right-click inside the box and select **Add Field**
    from the pop-up menu. (An alternative shortcut is to press the down arrow or the
    *Tab* key from your keyboard when editing a table or a field name.) You will notice
    a text cursor blinking inside the box representing the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type `id` and press *Enter*. While Navicat is creating the field, it also senses
    what this field is meant for by the name you entered, and it automatically defines
    the field as a primary key of the **INTEGER** type. Now go on and repeat the previous
    step, this time typing `name` as the field name, and press *Enter*. Eureka! Navicat
    perceived this one correctly as well, and it created the field as a varchar type
    of 255 characters in length. The 255-character length is perhaps outrageous, but
    we''ll see how to cut it down to size in a little bit. The ID and name fields
    are sufficient for the category table, so we are now moving onto the second table.
    Refer to the following screenshot to see how the tables, **category** and **task**,
    are created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating our first model](img/7461EN_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Create another table and name it `task`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a field named `id` for this one as well (see how Navicat makes it another
    primary key of the **INTEGER** type).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the second field as `title` and press *Enter*. (Navicat will create this
    one of type **VARCHAR(255)**.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the same way, add the following fields—`description`, `due_date`, `category_id`,
    and `user_id`. (Navicat will determine what type they should be created of.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create one last table and name it `user`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the following fields for it—`id`, `login_name`, `password`, `email`,
    and `role.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we need to fine-tune some of these fields. For example, we will trim the
    length of those varchar fields from a 255-character length to some more reasonable
    length. To do this, right-click on **task** and select **Design Table** from the
    pop-up menu. This will make a table designer interface very identical to the tables
    you saw in [Chapter 2](ch02.html "Chapter 2. Working with Databases"), *Working
    with Databases*. In Mac, the table will look similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating our first model](img/7461EN_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On this screen, you can add or remove fields, or rename them, change their data
    types, change the data length, assign or remove primary keys, define default values
    for fields, add indexes, and even add constraints such as foreign keys or uniqueness
    definitions.
  prefs: []
  type: TYPE_NORMAL
- en: You can even reorder the fields by gesturing the mouse to drag-and-drop the
    fields in this interface.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we will just reduce the length of the title to `50` and the
    description to `200`.
  prefs: []
  type: TYPE_NORMAL
- en: You can refer to [Chapter 2](ch02.html "Chapter 2. Working with Databases"),
    *Working with Databases*, for more details on the table designer interface and
    the functionalities it provides, for editing and tweaking table structures.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the relationships
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have our three related tables, it is time to define the relationships
    between them. This model is intended for a **Simple To Do** database, where our
    main data would be stored in the **task** table. Every task to be entered here
    will have a title, description, entry date, due date, category, and user. Here
    we are storing the categories and users on separate tables, so we need to refer
    to the related category and user from the **task** table, using the ID columns.
    There is a many-to-one relationship between the **category** table and the **task**
    table. In our case, a task can have one category associated with it, but a category
    can have many tasks under it. As such, a task can be assigned to one user, but
    a user can have many tasks.
  prefs: []
  type: TYPE_NORMAL
- en: To establish a join between two tables, first select the relationship tool from
    the vertical palette, then move your pointer to the **task** table and click-and-drag
    the **category_id** field, dragging it onto the **id** field of the **category**
    table. This should establish the join between the two tables, and a line joining
    them on the canvas should appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'But that''s not all. What we have done so far is to establish a basic one-to-one
    relationship with no further information on the cardinality between the two objects,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining the relationships](img/7461EN_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, to right-click on the adjoining line and then select **Cardinality on category**
    | **One or Many** from the pop-up menu. Now that a one-to-many relationship between
    the two tables is established, a foreign-key from **category** to **task** is
    automatically created; also, the category end of the joining line will have a
    fork-like joint in the diagram. One shortcoming of the diagram editor (directly
    editing on the canvas) is that when relationships are visually defined by point-and-click
    and drag-and-drop gestures, the joints of the lines may not be placed at the beginning
    or the end of referencing and the referenced fields. So, you will need to manually
    adjust them by clicking and dragging the joints to the correct location on the
    diagram object (of course, if you want more precision in the visual representation
    of these relationships).
  prefs: []
  type: TYPE_NORMAL
- en: We could have also used the **Design Relation...** command from the pop-up menu
    that is the equivalent of double-clicking on the joining line, which would bring
    us back to the table designer that has the **Foreign Keys** tab active. This is
    where you can fine-tune the foreign key definition of the adjoining table-field
    pairs; furthermore, it gives you the flexibility to reference more than one field
    in the join.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you have seen, it is best to use on-canvas editing and the table designer
    in conjunction with one another, rather than as alternatives, to make the best
    of two worlds, and for maximum flexibility in data modeling. Refer to the following
    screenshot to see how **Foreign Keys** are created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining the relationships](img/7461EN_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As many DBAs and software project managers would suggest (if not required),
    it is a good idea to conform to certain naming conventions when creating database
    objects, especially constraints such as **Foreign Keys**. I prefer to name **Foreign
    Keys** as starting with the prefix `fk_` concatenated by the table name, and then
    with `_4_` proceeded by the referenced table name, followed by the name of its
    primary key field. For example, in the case of the task-category relation, I used
    `fk_task_4_category_id` as the foreign key name, which means that this constraint
    is a foreign key defined for the **task** table that references the **id** field
    of the **category** table from the **category_id** field of the **task** table
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: While Navicat provides a lot of ergonomie for database object management, especially
    for constraint and index management, many other tools do not. In case of a need
    for modification, it can become cumbersome for someone who is not using a sophisticated
    GUI tool to manage a database, to locate a foreign key or some other constraint
    in the database unless a certain naming standard is respected from beginning to
    end, and by everyone involved.
  prefs: []
  type: TYPE_NORMAL
- en: When you're finished editing, click on the **OK** button on the lower right-hand
    side of the screen to save your changes, or click on **Cancel** to discard them.
  prefs: []
  type: TYPE_NORMAL
- en: Adding some pizzazz to the model with notes and images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine a case where you are designing a database model as part of a project
    proposal and you want your model to look pretty and appealing. Well, it could
    take more than a well-designed ER diagram to make your model seductive. The additional
    objects on the vertical model diagram palette, what I call annotation tools, can
    help you achieve just that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the tiny button with a yellow icon resembling a post-it note, on the
    vertical model diagram palette, to activate the note tool, and then click on an
    empty area of the canvas to drop in a sticky note. You can double-click on it
    to edit its text, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding some pizzazz to the model with notes and images](img/7461EN_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The note we have just added looks indeed like a post-it sticky, and it looks
    pretty good to me, in my humble opinion. But if you wish to change the appearance
    of the note (such as the color and text style), you can go to the properties pane
    and experiment with the different settings. The properties editor lets you tweak
    the note color, (rectangle) size, location, and even the font size and style.
  prefs: []
  type: TYPE_NORMAL
- en: If you prefer not to have a piece of sticky note on your model, but rather something
    more contemporary, you can choose to make the paper-like graphic completely disappear
    and leave only the text. To do this, simply click on the note with the arrow tool
    so it remains highlighted (or selected), and then in the properties pane select
    **Label** from the drop-down list named **Note style**. In Windows, right-click
    on the note and then go to **Style** | **Note**.
  prefs: []
  type: TYPE_NORMAL
- en: Right below the notes icon, there is the image tool with a tiny picture icon.
    You can add any picture or image to the diagram by first activating this tool
    by clicking on it, and by secondly clicking anywhere on the canvas. This will
    prompt you with your operating system's standard **Open** file dialog box, to
    select an image file or photo from your disk. Upon doing so, the image you have
    selected will be placed where you had clicked on the canvas. You could, for example,
    place your company logo in a corner to make the look and feel a little more corporate.
  prefs: []
  type: TYPE_NORMAL
- en: Working with layers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, the layers in Navicat's Model Designer are only for colorizing
    certain areas of the canvas for some kind of annotation, and can be used for marking
    a certain area of the canvas to gather some tables of a certain type of business
    logic. For example, you would want to separate the tables related with HR and
    put them within the boundaries of a certain layer, and put the tables related
    with manufacturing and logistics in another layer, for example, in a different
    area distinguished by a different layer, preferably in a different color, in the
    same diagram.
  prefs: []
  type: TYPE_NORMAL
- en: To create a layer, simply click on the icon above the relationship tool (and
    below the image tool) on the vertical palette, then click-and-drag a rectangular
    area ofyour choice on the canvas that you want your layer to be placed across.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please remember that layers are neither containers nor placeholders, and they
    serve no other purpose than being a visual aid.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting unwanted objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you create a table in the model designer, it begins to exist both in the
    diagram and the model. Deleting a table from the diagram thereafter does not necessarily
    mean it will be deleted from the model, but the good news is that you are asked
    from what context you want to delete a table, provided that you right-click on
    the table and select **Delete** | **from Diagram** or **Delete** | **from Diagram
    and Model**.
  prefs: []
  type: TYPE_NORMAL
- en: What's the difference? Well, the decision affects the objects that will be created
    when you generate a database from a model design. At the end of this section,
    you will learn how to forward-engineer a database by generating SQL from the model
    design.
  prefs: []
  type: TYPE_NORMAL
- en: Objects other than tables and relationships have no impact on the database structure,
    so deleting them from a diagram also removes them from the model.
  prefs: []
  type: TYPE_NORMAL
- en: Working with multiple diagrams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed in the beginning of the chapter, a model can contain multiple diagrams.
    Working with more than one diagram within a model can become necessary if you're
    working with very large databases, whose model would be too large to be managed,
    leaving you no choice but to divide them into subgroups and place them in separate
    diagrams.
  prefs: []
  type: TYPE_NORMAL
- en: We will not go into detail about working with more than one diagram within the
    same model. However, I want to mention a few points here. Also, the user interface
    of Navicat for Windows differs in some aspects from that of the Mac version, so
    I'll try to briefly explain the differences between the two user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: On both the Windows and Mac platforms, you can create a new diagram simply by
    clicking on the **New Diagram** button on the toolbar of the Model Designer window.
    When you do this on Windows, the new diagram comes up under a new tab right above
    the canvas area. You can switch between the diagrams simply by clicking on their
    tabs.
  prefs: []
  type: TYPE_NORMAL
- en: In the Mac version, instead of a tab bar on the top left side of the canvas,
    there's a drop-down menu labeled with the name of the active diagram. Also in
    the Mac version, at the bottom left side of every window, there is a small, black
    icon in the shape of toothed gear wheels. When clicked, it pops up a menu for
    you to add objects to, relevant to the context you're currently in. To switch
    between diagrams on the Mac, just click on its name and then select the name of
    the diagram from the drop-down menu that opens, which you want to toggle.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting the model diagram to SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have completed the design of a simple, yet functional, database model design.
    Now, it's time to put it to some use.
  prefs: []
  type: TYPE_NORMAL
- en: I mentioned earlier, the possibility of generating a database from a model.
    To achieve this with a model we designed from scratch, we first need to export
    our design to a `.sql` file.
  prefs: []
  type: TYPE_NORMAL
- en: On the Mac, there's a button labeled **Export SQL** on the toolbar of the Model
    Designer window. When you press it, the canvas is masked with an export settings
    form, where you must indicate which tables to export and optionally specify some
    advanced settings, such as excluding DROP statements, primary keys, indexes, and
    foreign keys from the generated SQL. You can leave these untouched if you don't
    want to omit anything.
  prefs: []
  type: TYPE_NORMAL
- en: In the Windows version, however, there's no export button on the toolbar; rather,
    you must select **Tools** | **Export SQL...** from the menu bar.
  prefs: []
  type: TYPE_NORMAL
- en: I suggest you uncheck the option of DROP statements, which could cause SQL errors,
    as this is the first time we'll be creating the **Simple To Do** database.
  prefs: []
  type: TYPE_NORMAL
- en: You can name the file to be exported something like `simple-todo.sql` and proceed
    with the exporting process.
  prefs: []
  type: TYPE_NORMAL
- en: Importing and exporting data was discussed in detail in [Chapter 3](ch03.html
    "Chapter 3. Data Management with Navicat"), *Data Management with Navicat*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code of the exported file should resemble the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Finally, by applying what you have learned in [Chapter 2](ch02.html "Chapter 2. Working
    with Databases"), *Working with Databases* and [Chapter 3](ch03.html "Chapter 3. Data
    Management with Navicat"), *Data Management with Navicat*, you can create a new
    database called **simple_todo** or just **todo**, and **Execute SQL file...**
    to generate the database from our exported model.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also paste the following code in a query window and execute the query
    to achieve the same result, provided that you have created the blank database.
  prefs: []
  type: TYPE_NORMAL
- en: Reverse-engineering a database into a model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we learnt how to design data models from scratch.
    Now that you're acquainted with the data modeling tools and diagram structures,
    we can move onto generating a model from an existing database.
  prefs: []
  type: TYPE_NORMAL
- en: For this part I have chosen the Sakila example database, which I introduced
    in [Chapter 3](ch03.html "Chapter 3. Data Management with Navicat"), *Data Management
    with Navicat*. If you already followed the tutorials in the previous chapter,
    you must have a working copy of the **sakila** database available to be reverse-engineered
    into a data model. If not, now is a good time to take a look into it and at least
    follow the steps to get the **sakila** database imported into your MySQL server.
  prefs: []
  type: TYPE_NORMAL
- en: Go to Navicat's main window and locate the **sakila** database in the **connections**
    pane; right-click on its name and select **Reverse Database to Model...** from
    the pop-up menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'A new model design window should instantly show up featuring all the tables
    and relationships of the Sakila database in a visual diagram, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reverse-engineering a database into a model](img/7461EN_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You could experiment with applying what you have learned in this chapter, for
    example, by adding notes and layers, and fine-tuning joining lines.
  prefs: []
  type: TYPE_NORMAL
- en: If you end up modifying the model with added tables, fields, and relationships,
    you can synchronize these changes back to the **sakila** database without having
    to regenerate the entire database from a SQL file.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, simply hit the **Synchronize** button on the toolbar (on the Mac)
    or select **Tools** | **Synchronize to Database...** from the menu bar (on Windows).
  prefs: []
  type: TYPE_NORMAL
- en: Details on the data synchronization process and its settings were covered in
    detail in [Chapter 3](ch03.html "Chapter 3. Data Management with Navicat"), *Data
    Management with Navicat*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started the chapter by getting you acquainted with the visual data modeler
    of Navicat, the metaphors it introduces, and how to design tables, fields, constraints,
    and relationships between these objects. These are both visual and form-based
    tools, which resemble other tools of Navicat covered in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Using these tools, you learned how to design a database model from scratch and
    then actually generated that database from the model.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we reverse-engineered a larger, existing database and automatically
    generated its visual model with a one-click wizard, and you have learned how you
    can synchronize your changes back to the database as you progress on the model.
  prefs: []
  type: TYPE_NORMAL
