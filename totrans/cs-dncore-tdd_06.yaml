- en: Mocking Dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 5](ef706a31-a272-418d-9706-ed84089d89a4.xhtml), *Data-Driven Unit
    Tests*, we discussed data-driven unit testing using the xUnit framework, which
    allows us to create tests that run on data from different sources, such as flat
    files, databases, or inline data. Now, we will explain the concepts of mocking
    dependencies and explore how to use the Moq framework to isolate your class that
    is being tested from its dependencies, using mock objects created with Moq.
  prefs: []
  type: TYPE_NORMAL
- en: There are usually objects dependencies in the code base of software projects,
    whether for a simple or a complex project. This is because the various objects
    need to interact and share information across boundaries. However, to effectively
    unit test the objects and isolate their behaviors, each object must be tested
    in isolation, irrespective of the dependencies it has on other objects.
  prefs: []
  type: TYPE_NORMAL
- en: In order to achieve this, the dependent objects in a class are replaced with
    mocks to allow the object being tested to be effective when tested in isolation,
    without having to go through the pain of constructing the dependent objects, which
    sometimes might not be fully implemented or may be impractical to construct at
    the time the object being tested is written.
  prefs: []
  type: TYPE_NORMAL
- en: '**Mock objects** are used to simulate or mimic real objects for the purpose
    of code testing. Mock objects are used to replace real objects; they are created
    from real interfaces or classes and used to verify interactions. Mock objects
    are essential instances of classes referenced in another class to be tested and
    are used to simulate the behavior of these classes. Since the components of a
    software system need to interact and collaborate, mock objects are used to replace
    the collaborators. A mock object, when used, verifies that the usage is correct
    and is as expected. Mocks can be created using a mocking framework or library
    or, alternatively, by generating code for them through handwritten mock objects.'
  prefs: []
  type: TYPE_NORMAL
- en: The Moq framework will be explored in detail in this chapter and will be used
    to create mock objects. Moq is a fully functional mocking framework that can be
    set up easily. It can be used to create mock objects for use in unit tests. Moq
    has several basic and advanced features expected of a mocking framework to create
    useful mocks and essentially write good unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of mocking objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The shortcomings of mocking frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hand-rolling mocks versus using the mocking framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking objects using Moq framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The benefits of mocking objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a well-architected software system, there are usually objects that interact
    and coordinate to accomplish set objectives based on the business or automation
    requirements. Quite often, these objects are complex and rely on other external
    components or systems, such as databases, SOAP, or REST services for data and
    internal state updates.
  prefs: []
  type: TYPE_NORMAL
- en: Most developers are beginning to adopt TDD because of the many benefits that
    practicing it can offer and due to the awareness that it is the responsibility
    of programmers to write quality code that is bug free and well tested. However,
    some developers object to mocking objects due to several assumptions. For example,
    adding mock objects to unit tests increases the total time required to write unit
    tests. This assumption is false because using mock objects offers several benefits,
    as explained in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Fast running tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main characteristics of a unit test are that it should run very quickly
    and should give consistent results even when executed multiple times with the
    same set of data. However, to effectively run a unit test and maintain this attribute
    of having unit tests that are efficients and run quickly, it is important to have
    mock objects set up where there are dependencies in the code being tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the following code snippet, the `LoanRepository` class has
    a dependency on Entity Framework''s `DbContext` class which creates a connection
    to a database server for database operations. To write a unit test for the `GetCarLoans`
    method in the `LoanRepository` class will necessitate that the `DbContext` object
    be constructed. The `DbContext` object can be mocked to avoid the expensive operation
    of opening and closing database connections each time a unit test is run for that
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In a software system, based on the requirements, there will be the need to access
    external systems, such as large files, databases, or web connections. Interacting
    directly with these external systems in a unit test increases the runtime of the
    test. Therefore, it is desirable to mock these external systems to allow the tests
    to run quickly. The benefits of unit testing can be lost when you have long running
    tests that apparently waste productive time. A developer in such a situation can
    stop running the tests or totally stop unit testing on the assertion that unit
    testing is time wasting.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies isolation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using dependencies mocking, you technically create alternatives to the dependencies
    in your code that you can experiment with. When you have a mock implementation
    of dependencies in place, you can make changes and test the effect of the changes
    in isolation since the tests will be running against mock objects and not the
    real objects.
  prefs: []
  type: TYPE_NORMAL
- en: When you have the dependencies isolated, you can focus on the test being run,
    thereby limiting the scope of your test to the code that really matters for the
    test. In essence, with the reduced scope, you can easily refactor the code being
    tested as well as the test itself, giving you a clear picture of areas where the
    code can be improved.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to test the `LoanRepository` class in the following snippet in isolation,
    the `DbContext` object that the class depends on can be mocked out. This will
    limit the scope of the unit tests to only the `LoanRepository` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Also, keeping the scope of the test small through isolation of dependencies
    makes the test easy to understand and facilitates easy maintenance. Increasing
    the scope of the test by not mocking dependencies eventually makes test maintenance
    difficult and reduces the high level detailed coverage of the test. Since the
    dependencies will have to be tested, this can result in less detail being tested
    due to increased scope.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring legacy code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Legacy source code is the code that was written by you or someone else usually
    without tests or using an old framework, architecture, or technology. Such a code
    base can be difficult to rewrite or maintain. It can sometimes be tangled code
    that cannot be easily read and understood and as such is very difficult to change.
  prefs: []
  type: TYPE_NORMAL
- en: When faced with the daunting task of maintaining a legacy code base, especially
    a code base written without adequate or proper testing, writing unit tests for
    such code can be difficult, and a waste of time, and can result in a lot of hard
    work. However, using a mocking framework can greatly simplify the refactoring
    process, as the new code being written can be isolated from the existing code
    and tested using mock objects.
  prefs: []
  type: TYPE_NORMAL
- en: Wider test coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With mocks, you are sure of a wide test coverage, as you can easily use mock
    objects to simulate possible exceptions, execution scenarios, and conditions that
    otherwise would be difficult without mocks. For example, if you have a method
    that purges or drops a database table, it is safer to test this method using mock
    objects than run it on a live database each time the unit test is run.
  prefs: []
  type: TYPE_NORMAL
- en: The shortcomings of mocking frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While mocking frameworks are very useful during TDD in that they simplify unit
    testing through the use of mock objects, they, however, have some limitations
    and downsides that can impact the design of the code or through excessive usage
    lead to the creation of tangled tests containing irrelevant mock objects.
  prefs: []
  type: TYPE_NORMAL
- en: Interface explosion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The architecture of the majority of the mocking frameworks necessitates that
    interfaces should be created in order to mock objects. In essence, you cannot
    mock a class directly; it has to be through the interface implemented by the class.
    In an attempt to mock dependencies during unit testing, an interface is created
    for each object or dependency to be mocked, even if the interface is not required
    to use the dependency in production code. This results in the creation of too
    many interfaces, a condition known as **interface explosion**.
  prefs: []
  type: TYPE_NORMAL
- en: Extra complexity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most mocking frameworks use reflection or create proxies to invoke the methods
    and create the mocks required in unit tests. This process is slow and adds overhead
    to the unit testing process. This is noticeable especially when it is desired
    to mock interactions between all classes and dependencies using mocks, which can
    lead to a situation where a mock returns other mocks.
  prefs: []
  type: TYPE_NORMAL
- en: Mock explosion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the availability of several mocking frameworks, it is easier to get familiar
    with mocking concepts and create mocks for unit testing. However, a developer
    can start to over-mock, a situation where every object seems like a mock candidate.
    Also, having too many mocks can lead to writing fragile tests, making your tests
    prone to breaking when the interface changes. When you have too many mocks, this
    ends up slowing down the test suites and consequently increases development time.
  prefs: []
  type: TYPE_NORMAL
- en: Hand-rolling mocks versus using a mocking framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using a mocking framework can facilitate a smooth unit testing experience, especially
    when unit testing a portion of code with dependencies in which mock objects are
    created and substituted for the dependencies. While it is easier using mocking
    frameworks, you might sometimes prefer to hand-roll mock objects for your unit
    tests and not add extra complexity or additional libraries to your project or
    code base.
  prefs: []
  type: TYPE_NORMAL
- en: Hand-rolled mocks are classes that are created for the purpose of testing and
    used to replace production objects. These created classes will have equivalent
    methods as the production classes with the same definitions and return values
    to effectively simulate the production classes and to use as substitute for dependencies
    in unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking concept
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step in creating mocks should be dependency identification. The goal
    of unit testing should be to have clean code and tests that run as quickly as
    possible with good coverage. You should identify dependencies that can slow down
    your tests. These are candidates for mocking, for example, a web service or database
    call.
  prefs: []
  type: TYPE_NORMAL
- en: The approach for creating mock objects can vary based on the type of dependencies
    being mocked. However, the concepts of mocking can follow the basic concepts that
    mock objects should return specific predefined values when the methods are invoked.
    There should be an appropriate validation mechanism in place to ensure the methods
    of the mock were called and the mock object can throw an exception if configured
    based on the test requirements.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand the types of mock objects to effectively hand-roll
    mock objects. There are two types of mock objects that can be created—dynamic
    and static mock objects. **Dynamic objects** can be created through reflection
    or proxy classes. This is similar to how mocking frameworks work. **Static mock
    objects** can be created by having classes that implement an interface and sometimes
    the actual concrete class that is the dependency to be mocked. You are essentially
    creating static mock objects when you hand-roll mocks objects.
  prefs: []
  type: TYPE_NORMAL
- en: '**Reflection** can be used to create mock objects. Reflection in C# is a useful
    construct that allows you to create an object that is an instance of a type, as
    well as getting or binding a type to an existing object and invoking the available
    fields and method in the type. Additionally, you can use reflection to create
    objects that describe modules and assemblies.'
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of hand-rolling mocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hand-rolling your mocks can sometimes be an effective approach to use, when
    you intend to have full control of your test setup and specify the behavior of
    the test setup. Also, when the test is relatively simple, using a mocking framework
    is not an option; it is better to roll the mock and keep everything simple.
  prefs: []
  type: TYPE_NORMAL
- en: When using mocking frameworks, making changes to the real object being mocked
    will necessitate changes to the mock objects wherever they are used. This is because
    changes made to the dependency will break the tests. If, for example, the method
    name on the dependent object changes, you have to change this in the dynamic mocks.
    Thus, changes have to be made in several parts of the code base. With hand-rolled
    mocks, you only have to make the changes at one point only since you are in control
    of what method is presented to the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Mocks and stubs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Mocks** and **stubs** are both similar because they are used to replace class
    dependencies or collaborators and most mocking frameworks provide the features
    to create both. Stubs can be hand-rolled in the same manner you hand-roll mocks.'
  prefs: []
  type: TYPE_NORMAL
- en: So what really differentiates mocks from stubs? Mocks are used to test collaboration.
    This includes verifying the expectations of the actual collaborator. Mocks are
    programmed to have the expectation containing the details of method invocations
    to be received, while stubs are used to simulate collaborators. Let's explain
    this further with an illustration.
  prefs: []
  type: TYPE_NORMAL
- en: A stub can be used to represent the result from a database. In place of a database
    call to return a set of data, a C# list can be created with the data that can
    be used in executing a test. If the stub above the dependency interaction of the
    test is not validated, the test will only be concerned with the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `LoanService` class in the following snippet has a `GetBadCarLoans` method
    that accepts a list of `Loan` objects to be retrieved from a database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The test for the `GetBadCarLoans` method, `Test_GetBadCarLoans_ShouldReturnLoans`,
    in the following snippet uses a stub, which is a list of `Loan` objects that is
    passed as a parameter to the `GetBadCarLoans` method, instead of making a database
    call to get the list of `Loan` objects to be used for the `Test` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `LoanService` class in the following snippet has a `LoanRepository` DI that
    connects to the database to fetch records. The class has a constructor, where
    the `ILoanRepository` object is injected. The `LoanService` class has a `GetBadCarLoans`
    method that calls the `GetCarLoan` method on the dependency, which in turn makes
    a call to get a list of `Loan` objects from the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike when using a stub, a mock will verify that a method in a dependency
    is called. This implies that the mock object will have a setup of the method to
    be called in the dependency. In the `LoanServiceTest` class in the following snippet,
    a mock object is created from `ILoanRepository`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor of the `LoanServiceTest` class, the data to be returned by
    the mock object is first created, followed by the method set up in the line `loanRepository.Setup(x
    => x.GetCarLoans()).Returns(loans);`. The mock object is then passed to the `LoanService`
    constructor, `loanService= new loanService(loanRepository.Object);`.
  prefs: []
  type: TYPE_NORMAL
- en: Hand-rolled mock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can hand-roll a mock object to test the `LoanService` class. The mock object
    to be created will implement the `ILoanRepository` interface and will be used
    for the purpose of unit testing only since it is not needed in the production
    code. The mock object will return a list of `Loan` objects, which will simulate
    the actual call to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `LoanRepositoryMock` class created can now be used in the `LoanService`
    class to mock `ILoanRepository` in place of using a mock object created from a
    mock framework. In the constructor of the `LoanServiceTest` class, the `LoanRepositoryMock`
    class will be instantiated and injected into the `LoanService` class, which is
    used in the `Test` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Because `LoanRepositoryMock` is used as a concrete class for the `ILoanRepository`
    interface, a dependency of the `LoanService` class, whenever the `GetCarLoans`
    method is called on the `ILoanRepository` interface, the `GetCarLoans` method
    of `LoanRepositoryMock` will be called to return the data required for the test
    to run.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking objects using Moq framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Selecting a mock framework to use for mocking objects is important for a smooth
    unit testing experience. However, there are no written rules to be followed for
    this. You can consider some factors and features of the mocking framework when
    selecting a mocking framework for use in your tests.
  prefs: []
  type: TYPE_NORMAL
- en: Performance and available features should be the first factors to be considered
    when selecting a mocking framework. You should examine the way the mocking framework
    creates mocks; frameworks that use inheritance, virtual, and static methods cannot
    be mocked. Other features to look out for can be methods, properties, events,
    and even if the framework supports LINQ.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, nothing beats simplicity and the ease of use of a library. You
    should go for a framework that is easy to use, with good documentation of the
    available features. In the subsequent sections of this chapter, the other concepts
    of mocking will be explained using the Moq framework, an easy-to-use strongly
    typed library.
  prefs: []
  type: TYPE_NORMAL
- en: When using Moq, the mock object is an actual dummy class that is created for
    you using reflection, which contains the implementation of methods contained in
    an interface that is being mocked. In the Moq setup, you will specify the interface
    you want to mock and the methods that the test class requires to effectively run
    the tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Moq, you need to install the library through the NuGet package manager
    or through the NuGet console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To explain mocking with Moq, let''s create an `ILoanRepository` interface with
    two methods, `GetCarLoan`, which retrieves car loans from the database as a list,
    and a `GetLoanTypes` method that returns a list of `LoanType` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `LoanRepository` class uses the Entity Framework as the ORM for data access
    and retrieval and implements `ILoanRepository`. The two methods, `GetLoanTypes`
    and `GetCarLoans`, have been implemented by the `LoanRepository` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Let's create a mock object for `ILoanRepository` to test the two methods without
    having to depend on any concrete class implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a mock object is easy with Moq:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding line of code, a mock object has been created which implements
    the `ILoanRepository` interface. The object can be used as a regular implementation
    of `ILoanRepository` and injected into any class that has `ILoanRepository` as
    the dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking methods, properties, and callback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before the methods of the mock objects can be used in the test, they need to
    be set up. This setup is preferably done in the constructor of the test class
    after the mock object is created and before the object is injected into the class
    that requires the dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the data to be returned by the method to be set up will have to be created;
    this is the dummy data to be used in the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'At the point of setting up the method, the return data will be passed to it
    as well as any method parameter, if applicable. In the following line of code,
    the `GetCarLoans` method is set up with the list of the `Loan` objects passed
    as the return data. This means that whenever the `GetCarLoans` method is invoked
    in the unit test using the mock object, the list created earlier will be returned
    as the method return value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can have a lazy evaluation of the method return value. This is a syntax
    sugar available with the use of LINQ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Moq has an `It` object, which can be used to specify a matching condition for
    a parameter in the method being set up. `It` refers to the argument being matched.
    Assuming the `GetCarLoans` method has a string parameter, `loanType,` the syntax
    of the method setup can be changed to include the parameter with the return value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to set up a method that returns a different return value each
    time it is invoked. For example, the setup of the `GetCarLoans` method can be
    done to return different sizes of the list each time the method is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, a random number is generated between `1` and `3`,
    to set. This will ensure that the size of the list to be returned by the `GetCarLoans`
    method varies with each invocation. The first time the `GetCarLoans` method is
    called, the `Returns` method is called, while the code in the `Callback` is executed
    with subsequent calls to the `GetCarLoans` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'A feature of Moq is the provision of testing for exceptions. You can set up
    the method to test for exceptions. In the following method setup, the `GetCarLoans`
    method throws `InvalidOperationException` when called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have a dependency that has properties to be set which are used in the
    method calls, you can set dummy values for such properties using the Moq `SetupProperty`
    method. Let''s add two properties to the `ILoanRepository` interface, `LoanType`
    and `Rate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'With the Moq `SetupProperty` method, you can specify that the property should
    have a behavior, which in essence implies that whenever the property is requested,
    the value set in the `SetupProperty` method will be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The lines of code in the preceding snippet set the `LoanType` property to an
    enum value, `CarLoan`, and `Rate` to `12.5`. Whenever the properties are requested
    in a test, the set values will be returned to the calling points.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the properties using the `SetupProperty` method automatically sets the
    property as a stub and will allow the values of the properties to be tracked and
    provide a default value for the property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, while setting up the property, you can use the `SetupSet` method, which
    accepts a lambda expression to specify a type for a call to a property setter
    and allows you to pass the value into the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to `SetupSet` is `SetupGet`, which is used to specify a setup on the
    type for a call to a property getter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Recursive mocking allows you to mock complex object types, especially nested
    complex types. For example, you might want to mock the `Age` property in the `Person`
    complex type of the `Loan` type. The Moq framework can traverse this graph to
    mock the property in an elegant way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You can stub all the properties available on a mock, using the `SetupAllProperties`
    method. This method will specify that all properties on the mock have a property
    behavior set. By generating the default value for each property in the mock, the
    default property is generated using the `Mock.DefaultProperty` property of the
    Moq framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Matching parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using Moq to create mock objects, you can match arguments to ensure that
    the expected parameters are passed during a test. Using this feature, you can
    ascertain the validity of the arguments passed into a method while the method
    is called while being tested. This is applicable only to methods that have arguments
    and the matching will be done during the method setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Moq''s `It` keyword, you can specify different expressions and validations
    for the method parameter during setup. Let''s add a `GetCarLoanDefaulters` method
    definition to the `ILoanRepository` interface. The implementation in the `LoanRepository`
    class accepts an integer parameter, which is the service year for a loan and returns
    a list of car loan defaulters. The `GetCarLoanDefaulters` method code is shown
    in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s set up the `GetCarLoanDefaulters` method in the `LoanServiceTest`
    constructor to accept a different value for the `year` parameter using Moq''s `It`
    keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: A list of `Person` objects has been created, which will be passed to the `Returns`
    method of the mock setup. The `GetCarLoanDefaulters` method will now accept the
    value in the range specified, since the `It.IsInRange` method has been used with
    both the upper and lower range value supplied.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `It` class has other useful methods for specifying the matching conditions
    for a method during setup instead of having to specify a particular value:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IsRegex` is used for specifying a regular expression to match a string argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Is` is used to specify a value that matches a given predicate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IsAny<>` is used to match any value of the type specified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ref<>` is used to match any value specified in a `ref` parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can create a custom matcher and use it in method setup. For example, let''s
    create a custom matcher, `IsOutOfRange`, for the `GetCarLoanDefaulters` method
    to ensure a value greater than `12` is not supplied as an argument. Creating a
    custom matcher is done by using `Match.Create`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The created `IsOutOfRange` matcher can now be used in a method setup of a mock
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Moq has a feature that allows you to raise an event on the mock object. To
    raise an event, you use the `Raise` method. The method has two parameters. The
    first is a Lambda expression with the event subscribed for the event to be raised
    on the mock. The second argument provides a parameter that will be included in
    the event. To raise a `LoanDefaulterNotification` event on the `loanRepository`
    mock object with an empty argument, you can use the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Real use cases are used when you want to have a mock object raise an event
    in response to an action or raise an event in response to a method invocation.
    When setting up a method on a mock to allow events to be raised, the `Returns`
    method on the mock is replaced with the `Raises` method, which indicates that
    when the method is called in the test, an event should be raised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Callbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the `Callback` method of Moq, you can specify the callback to be invoked
    before and after a method is called. There are some test scenarios that might
    not be easily tested using the simple mock expectations. In such complex scenarios,
    you can use a callback to execute specific actions when the mock objects are called.
    The `Callback` method accepts an action parameter, which will be executed based
    on whether the callback is set up before or after the method invocation. The action
    can be an expression to be evaluated or another method to be called.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you can have a callback set up to change the data after a specific
    method has been called. This feature allows you to create tests that offer more
    flexibility while simplifying test complexities. Let's add a callback to the `loanRepository`
    mock object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The callback can be a method that will be invoked or a property that you need
    to set with values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding snippet has two callbacks set up for the method setup. The `CarLoanDefaultersCallback`
    method is called before the actual `GetCarLoanDefaulters` method is invoked and
    `CarLoanDefaultersCallbackAfter` will be called after the `GetCarLoanDefaulters`
    method has been called on the mock object. `CarLoanDefaultersCallback` adds a
    new `Person` object to the `List` and `CarLoanDefaultersCallback` removes the
    first element in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Mock customization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When using the Moq framework, you can further customize mock object, to enhance
    the effective unit testing experience. The `MockBehavior` enum can be passed into
    Moq''s `Mock` object constructor to specify the behavior of the mock. The enum
    members are `Default`, `Strict`, and `Loose`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'When a `Loose` member is selected, the mock will not throw any exceptions.
    The default values will always be returned. This means null will be returned for
    reference types, and zero or empty arrays and enumerables will be returned for
    value types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Selecting a `Strict` member will make the mock throw exceptions for every call
    on the mock that does not have a proper setup. Lastly, the `Default` member is
    the default behavior of the mock, which technically equals the `Loose` enum member.
  prefs: []
  type: TYPE_NORMAL
- en: CallBase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`CallBase`, when initialized during a mock construction, is used to specify
    whether the base class virtual implementation will be invoked for mocked dependencies
    if no setup is matched. The default value is `false`. This is useful when mocking
    HTML/web controls of the `System.Web` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Mock repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Instead of having mock objects creation code scattered across your tests, you
    can avoid repetitive code by using `MockRepository`, available in Moq for creating
    and verifying mocks in a single location, thereby ensuring that you can do mock
    configuration by setting `CallBase`, `DefaultValue`, and `MockBehavior` and verifying
    the the mocks in one place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, a mock repository is created with `MockBehaviour.Strict`,
    and two mock objects are created, each with the `loanRepository` mock, overriding
    the default `MockBehaviour` specified in the repository. The last statement is
    an invocation of the `Verify` method to verify all expectations on all the mock
    objects created in the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing multiple interfaces in a mock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Additionally, you can implement multiple interfaces in a single mock. For example,
    we can create a mock that implements `ILoanRepository` and later implements the
    `IDisposable` interface using the `As<>` method, which is used to add an interface
    implementation to a mock and to specify a setup for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Verification method and property invocations with Moq
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mock behaviors are specified during the setup. This is the expected behavior
    of an object and the collaborator. While unit testing, mocking is not complete
    until all the mocked dependencie's invocations have been verified. It can be helpful
    to be aware of the number of times methods were executed or properties accessed.
  prefs: []
  type: TYPE_NORMAL
- en: The Moq framework has useful verification methods that can be used to verify
    mocked methods and properties. Also, the `Times` structure contains useful members
    showing the number of calls that can be allowed on a method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Verify` method can be used to verify that a method invocation, together
    with the supplied parameters performed on a mock, match what was earlier configured
    during the mock setup and used with the default `MockBehaviour`, which is `Loose`.
    To explain verification concepts in Moq, let''s create a `LoanService` class that
    depends on `ILoanRepository` for data and add a method, `GetOlderCarLoanDefaulters`,
    to it to return a list of loan defaulters older than `20` years of age. `ILoanRepository`
    is injected to `LoanService` through the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'To test the `LoanService` class, we will create a `LoanServiceTest` test class
    that uses dependency mocking to isolate `LoanService` for unit testing. `LoanServiceTest`
    will contain a constructor for setting up a mock for `ILoanRepository`, required
    by the `LoanService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '`The LoanServiceTest` constructor contains a mock set up for the `GetCarLoanDefaulters`
    method of the `ILoanRepository` interface, with the arguments expectation and
    the return value. Let''s create a test method, `Test_GetOlderCarLoanDefaulters_ShouldReturnList`,
    to test `GetCarLoanDefaulters`. After the assert statements, there is the `Verify`
    method to check if `GetCarLoanDefaulters` was called once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Verify` method takes two arguments: the method to be verified and the
    `Time` structure. `Time.Once` was used, which specifies that the mocked method
    should only be called once.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Times.AtLeast(int callCount)`, when used, is to specify that a mocked method
    should be called in the minimum number of times specified in the value of the
    `callCount` parameter. This can be used to verify that a method was called in
    the number of times specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding test snippet, `Times.AtLeast(2)` was passed to the `Verify`
    method. The test, when run, will fail with `Moq.MoqException` because the `GetCarLoanDefaulters`
    method was only called once in the code being tested:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5fc37630-7401-4e5b-91eb-3b83646e10be.png)'
  prefs: []
  type: TYPE_IMG
- en: '`Times.AtLeastOnce` can be used to specify that a mocked method should be called
    a minimum of one time, which means the method can be called many times in the
    code being tested. We can modify the `Verify` method in `Test_GetOlderCarLoanDefaulters_ShouldReturnList`
    to take a second parameter as `Time.AtLeastOnce` to validate after the test is
    run that the `GetCarLoanDefaulters` was called at least once in the code being
    tested:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '`Times.AtMost(int callCount)` can be used to specify the maximum number of
    times that a mocked method should be called in the code being tested. The `callCount`
    parameter is used to pass the value for the maximum invocation time for a method.
    This can be used to limit the calls allowed to a mocked method. A Moq exception
    is thrown if the method is called more than the `callCount` value specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '`Times.AtMostOnce` is similar to `Time.Once` or `Time.AtLeastOnce`, but with
    the difference being that the mocked method can only be called at most one time.
    A Moq exception is thrown if the method is called more than once, but if the method
    is not called when the code is run, no exception will be thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '`Times.Between(callCountFrom,callCountTo, Range)` can be used in the `Verify`
    method to specify that the mocked method should be called between `callCountFrom`
    and `callCountTo` and the `Range` enum used to specify whether to include or exclude
    the range specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '`Times.Exactly(callCount)` is very useful when you want to specify that a mocked
    method should be called at the `callCount` specified. If the mocked method is
    called fewer times than the `callCount` specified or more times, a Moq exception
    will be generated with a detailed description of the expectation and what failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check the code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6b75b04-d6c5-4546-9ac3-c279e4a9d943.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Also important is `Times.Never`. When used, it can verify that a mocked method
    is never used. You can use this when you don''t want a mocked method to be invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'A mocked property verification is done in a similar manner to mocked methods
    using the `VerifySet` and `VerifyGet` methods. The `VerifySet` method is used
    to verify that a property was set on the mock. Also, the `VerifyGet` method is
    used to validate that a property was read on a mock, regardless of the value contained
    in the property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify that a property has been set on a mock, irrespective of whatever
    value was set, you can use the `VerifySet` method with this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'At times, you might want to validate that a particular value was assigned to
    a property on the mock. You can do this by assigning the value to verify to the
    property in the `VerifySet` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The `VerifyNoOtherCalls()` method introduced in Moq 4.8 can be used to ascertain
    that no calls were made other than the ones already verified. The `VerifyAll()`
    method is used to verify all expectations, irrespective of if they have been flagged
    as verifiable.
  prefs: []
  type: TYPE_NORMAL
- en: LINQ to mocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Language-Integrated Query** (**LINQ**) is a language construct introduced
    in .NET 4.0, which provides query capabilities in the .NET Framework. LINQ has
    query expressions that are written in a declarative query syntax. There are different
    implementations of LINQ-LINQ to XML, used for querying XML documents, LINQ to
    entities, which is used for ADO.NET Entity Framework operations, LINQ to objects
    used for querying .NET collections, files, strings, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we have created mock objects using Lambda expressions
    syntax. Another exciting feature available in the Moq framework is **LINQ to mocks**,
    which allows you to set up mocks using LINQ like syntax.
  prefs: []
  type: TYPE_NORMAL
- en: LINQ to Mocks is great for simple mocks, and for stubbing out dependencies when
    you really do not care about the verification. Using the `Of<>` method, you can
    create a mock object of the specified type.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use LINQ to Mocks to have multiple setups done on a single mock and
    recursive mocks, using LINQ like syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding mock initialization, the `Rate` and `LoanType` properties were
    set up as stubs, with the default values for the properties, when accessed during
    the tests invocation.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Moq features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, the default values provided by Moq might not be suitable for some
    test scenarios and you need to create a custom default value generation approach
    to complement what Moq currently provides, which are `DefaultValue.Empty` and
    `DefaultValue.Mock`. This can be done through extending `DefaultValueProvider`
    or `LookupOrFallbackDefaultValueProvider`, which are available in Moq 4.8 and
    higher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The `TestDefaultValueProvider` class created the sub-classes `LookupOrFallbackDefaultValueProvider`
    and implemented default values for both `string` and `List`. For any type of `string`,
    `string.empty` is returned and an empty list is created with a `List` of any type.
    `TestDefaultValueProvider` can now be used in mock creation, in the `Mock` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The `objectName` variable in the preceding snippet will contain a string of
    zero characters since the implementation in `TestDefaultValueProvider` indicates
    that the `string` type should be assigned an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking internal types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depending on your project requirements, you might need to create mock objects
    for internal types. Internal types or members in C# are accessible only within
    files in the same assembly. Mocking internal types can be done by adding custom
    attributes to the `AssemblyInfo.cs` file of the concerned projects.
  prefs: []
  type: TYPE_NORMAL
- en: If the assembly containing the internal types does not already have the `AssemblyInfo.cs`
    file, you can add it. Also, when the assembly is not strongly-named, you can add
    the `InternalsVisibleTo` attribute, which has the public key excluded. You have
    to specify the name of the project to share visibility with, which in this case
    should be the test project.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you change the `LoanService` access modifier to internal, you will get the
    error, `LoanService`. It is inaccessible due to its protection level. To be able
    to test `LoanService`, without changing the access modifier, we then add the `AssemblyInfo.cs`
    file to the project, and add the required attribute with the test project name
    specified in order to share the assembly that contains `LoanService` with the
    test project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d577ffd0-5843-454d-ae40-c150b5f0c98b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The attribute added to the `AssemblyInfo.cs` file is shown in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Moq framework, when used together with the xUnit.net framework, can deliver
    a smooth unit testing experience and make the overall TDD process worthwhile.
    Moq provides powerful features that, when used effectively, can simplify the creation
    of dependencies mocking for unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Mock objects created with Moq can allow you to substitute the concrete dependencies
    in your unit tests for the created mocks created by you in order to isolate different
    units in your code for testing and subsequent refactoring, which can facilitate
    crafting elegant production-ready code. Also, you can use mock objects to experiment
    and test features available in dependencies that otherwise might not be easily
    done by using the live dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we have explored the basics of mocking, and extensively used
    mocks in unit tests. Also, we configured mocks to set up methods and properties
    and return exceptions. Some other features provided by the Moq library were explained
    and mocks verification was covered.
  prefs: []
  type: TYPE_NORMAL
- en: Project hosting and continuous integration will be covered in the next chapter.
    This will include test and enterprise approaches to automate the running of tests
    to ensure that quality feedback can be provided on the code coverage.
  prefs: []
  type: TYPE_NORMAL
