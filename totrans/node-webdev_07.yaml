- en: Your First Express Application
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've got our feet wet building an Express application for Node.js,
    let's start developing an application that performs a useful function. The application
    we'll build will keep a list of notes and will eventually have users who can send
    messages to each other. Over the course of this book, we will use it to explore
    some aspects of real Express web applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll start with the basic structure of an application, the
    initial UI, and the data model. We'll also lay the groundwork for adding persistent
    data storage and all the other features that we will cover in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered in this chapter include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Promises and async functions in Express router functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript class definitions and data hiding in JavaScript classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The architecture of an Express application using the MVC paradigm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an Express application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the CRUD paradigm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Express application theming and Handlebars templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To get started, we will talk about integrating Express router callbacks with
    async functions.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Promises and async functions in Express router functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get into developing our application, we need to take a deeper look
    at using the `Promise` class and async functions with Express because Express
    was invented before these features existed, and so it does not directly integrate
    with them. While we should be using async functions wherever possible, we have
    to be aware of how to properly use them in certain circumstances, such as in an
    Express application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules in Express for handling asynchronous execution are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Synchronous errors are caught by Express and cause the application to go to
    the error handler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous errors must be reported by calling `next(err)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A successfully executing middleware function tells Express to invoke the next
    middleware by calling `next()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A router function that returns a result to the HTTP request does not call `next()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we'll discuss three ways to use Promises and async functions
    in a way that is compatible with these rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both Promises and async functions are used for deferred and asynchronous computation
    and can make intensely nested callback functions a thing of the past:'
  prefs: []
  type: TYPE_NORMAL
- en: A `Promise` class represents an operation that hasn't completed yet but is expected
    to be completed in the future. We've used Promises already, so we know that the `.then`
    or `.catch` functions are invoked asynchronously when the promised result (or
    error) is available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside an async function, the `await` keyword is available to automatically
    wait for a Promise to resolve. It returns the result of a Promise, or else throws
    errors, in the natural location at the next line of code, while also accommodating
    asynchronous execution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The magic of async functions is that we can write asynchronous code that looks
    like synchronous code. It's still asynchronous code—meaning it works correctly
    with the Node.js event loop—but instead of results and errors landing inside callback
    functions, errors are thrown naturally as exceptions and results naturally land
    on the next line of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because this is a new feature in JavaScript, there are several traditional
    asynchronous coding practices with which we must correctly integrate. You may
    come across some other libraries for managing asynchronous code, including the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `async` library is a collection of functions for various asynchronous patterns.
    It was originally completely implemented around the callback function paradigm,
    but the current version can handle async functions and is available as an ES6
    package. Refer to [https://www.npmjs.com/package/async](https://www.npmjs.com/package/async)
    for more information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before Promises were standardized, at least two implementations were available:
    Bluebird ([http://bluebirdjs.com/](http://bluebirdjs.com/)) and Q ([https://www.npmjs.com/package/q](https://www.npmjs.com/package/q)).
    Nowadays, we focus on using the standard, built-in `Promise` object, but both
    of these packages offer additional features. What''s more likely is that we will
    come across older code that uses these libraries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These and other tools were developed to make it easier to write asynchronous
    code and to solve the **pyramid of doom** problem. This is named after the shape
    that the code takes after a few layers of nesting. Any multistage process written
    as callbacks can quickly escalate to code that is nested many levels deep. Consider
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: 'A function like this creates the `Promise` object, giving it a callback function,
    within which is your asynchronous operation. The `resolve` and `reject` functions
    are passed into that function and are called when the Promise is resolved as either
    a success or failure state. A typical use of `new Promise` is a structure like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: The `Promise` object is fluid enough that the function passed in a `.then` handler
    can return something, such as another Promise, and you can chain the `.then` calls
    together. The value returned in a `.then` handler (if any) becomes a new `Promise`
    object, and in this way, you can construct a chain of `.then` and `.catch` calls
    to manage a sequence of asynchronous operations.
  prefs: []
  type: TYPE_NORMAL
- en: With the `Promise` object, a sequence of asynchronous operations is called a
    **Promise chain**, consisting of chained `.then` handlers, as we will see in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Promises and error handling in Express router functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is important that all errors are correctly handled and reported to Express.
    With synchronous code, Express will correctly catch a thrown exception and send
    it to the error handler. Take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: This is an example of the error indicator landing in an inconvenient place in
    the callback function. The exception is thrown in a completely different stack
    frame than the one invoked by Express. Even if we arranged to return a Promise,
    as is the case with an async function, Express doesn't handle the Promise. In
    this example, the error is lost; the caller would never receive a response and
    nobody would know why.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to reliably catch any errors and respond to the caller with
    results or errors. To understand this better, let''s rewrite the pyramid of doom
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: The goal here is to avoid blocking the event loop with a long operation. Deferring
    the processing of results or errors using callback functions is an excellent solution
    and is the founding idiom of Node.js. The implementation of callback functions
    led to this pyramid-shaped problem. Promises help flatten the code so that it
    is no longer in a pyramid shape. They also capture errors, ensuring delivery to
    a useful location. In both cases, errors and results are buried inside an anonymous
    function and are not delivered to the next line of code.
  prefs: []
  type: TYPE_NORMAL
- en: Generators and the iteration protocol are an intermediary architectural step
    that, when combined with Promises, lead to the async function. We won't use either
    of these in this book, but they are worth learning about.
  prefs: []
  type: TYPE_NORMAL
- en: For the documentation for the iteration protocol, refer to [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols).
  prefs: []
  type: TYPE_NORMAL
- en: For the documentation for the generator functions, refer to [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator).
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve already used async functions and learned about how they let us write
    clean-looking asynchronous code. For example, the `db.query` example as an async
    function looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: Other than `try/catch`, this example is very clean compared to its earlier forms,
    both as a callback pyramid and as a Promise chain. All the boilerplate code is
    erased, and the intent of the programmer shines through clearly. Nothing is lost
    inside a callback function. Instead, everything lands on the next line of code
    where it is convenient.
  prefs: []
  type: TYPE_NORMAL
- en: The `await` keyword looks for a Promise. Therefore, `doSomething` and the other
    functions are expected to return a Promise, and `await` manages its resolution.
    Each of these functions could be an async function, and thereby automatically
    returns a Promise, or it could explicitly create a Promise to manage an asynchronous
    function call. A generator function is also involved, but we don't need to know
    how that works. We just need to know that `await` manages the asynchronous execution
    and the resolution of the Promise.
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, each statement with an `await` keyword executes asynchronously.
    That's a side effect of `await`—managing asynchronous execution to ensure the
    asynchronous result or error is delivered correctly. However, Express cannot catch
    an asynchronous error and requires us to notify it of asynchronous results using
    `next()`.
  prefs: []
  type: TYPE_NORMAL
- en: The `try/catch` structure is needed for integration with Express. For the reasons
    just given, we must explicitly catch asynchronously delivered errors and notify
    Express with `next(err)`.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed three methods for notifying Express about asynchronously
    delivered errors. The next thing to discuss is some architectural choices to structure
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: Architecting an Express application in the MVC paradigm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Express doesn't enforce an opinion on how you should structure the **Model,**** View,
    and Controller** (**MVC**) modules of your application, or whether you should
    follow any kind of MVC paradigm at all. The MVC pattern is widely used and involves
    three main architectural pieces. The **controller** accepts inputs or requests
    from the user, converting that into commands sent to the model. The **model**
    contains the data, logic, and rules by which the application operates. The **view**
    is used to present results to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we learned in the previous chapter, the blank application created by the
    Express generator provides two aspects of the MVC model:'
  prefs: []
  type: TYPE_NORMAL
- en: The `views` directory contains template files, controlling the display portion,
    corresponding to the view.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `routes` directory contains code implementing the URLs recognized by the
    application and coordinates the data manipulation required to generate the response
    to each URL. This corresponds to the controller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the router functions also call the function to generate the result using
    a template, we cannot strictly say that the router functions are the controller
    and that the `views` templates are the view. However, it's close enough to the
    MVC model for it to be a useful analogy.
  prefs: []
  type: TYPE_NORMAL
- en: This leaves us with a question of where to put the model code. Since the same
    data manipulation can be used by multiple router functions, clearly the router
    functions should use a standalone module (or modules) containing the model code.
    This will also ensure a clean separation of concerns—for example, to ease the
    unit testing of each.
  prefs: []
  type: TYPE_NORMAL
- en: The approach we'll use is to create a `models` directory as a sibling of the
    `views` and `routes` directories. The `models` directory will hold modules to
    handle data storage and other code that we might call **business logic**. The
    API of the modules in the `models` directory will provide functions to create,
    read, update, or delete data items—a **C****reate,** **R****ead,** **Update, and D****elete**/**Destroy **(**CRUD**)
    model—and other functions necessary for the view code to do its thing.
  prefs: []
  type: TYPE_NORMAL
- en: The CRUD model includes the four basic operations of persistent data storage.
    The `Notes` application is structured as a CRUD application to demonstrate the
    implementation each of these operations.
  prefs: []
  type: TYPE_NORMAL
- en: We'll use functions named `create`, `read`, `update`, and `destroy` to implement
    each of the basic operations.
  prefs: []
  type: TYPE_NORMAL
- en: We're using the `destroy` verb, rather than `delete`, because `delete` is a
    reserved word in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: With that architectural decision in mind, let's proceed with creating the `Notes`
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Notes application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we''re starting a new application, we can use the Express generator to
    give us a starting point. It is not absolutely necessary to use this tool since
    we can definitely write the code ourselves. The advantage, however, is that it
    gives us a fully fleshed out starting point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: The supplied script uses `bin/www`, but shortly, we'll restructure the generated
    code to put everything into a single ES6 script named `app.mjs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, install `cross-env`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: We'll finish this up later, but what we've done is restructured the code we
    were given. We can import the Express package, and then export the `router` object.
    Adding router functions is, of course, the done in the same way, whether it is
    a CommonJS or an ES6 module. We made the router callback an async function because
    it will be using async code.
  prefs: []
  type: TYPE_NORMAL
- en: We'll need to follow the same pattern for any other router modules we create.
  prefs: []
  type: TYPE_NORMAL
- en: Having converted this to an ES6 module, the next step is to merge code from `bin/www` and `app.js` into
    an ES6 module named `app.mjs`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Notes application wiring – app.mjs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the `express-generator` tool gives us a slightly messy application structure
    that does not use ES6 modules, let's reformulate the code it gave us appropriately.
    The first, `app.mjs`, contains the *wiring* of the application, meaning it configures
    the objects and functions from which the application is built while not containing
    any functions of its own. The other code, `appsupport.mjs`, contains the callback
    functions that appeared in the generated `app.js` and `bin/www` modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `app.mjs`, start with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: In the `dirname-fixed.mjs` example in [Chapter 3](516a5cd0-bdae-4e8c-bb0a-d508f85d483a.xhtml), *Exploring
    Node.js Modules*, we imported specific functions from the `path` and `url` core
    modules. We have used that code and then exported the value for `__dirname` as
    `approotdir`. Other parts of the `Notes` application simply need the pathname
    of the root directory of the application in order to calculate the required pathnames.
  prefs: []
  type: TYPE_NORMAL
- en: Return your attention to `app.mjs` and you'll see that the router modules are
    imported as `indexRouter` and `notesRouter`. For the moment, `notesRouter` is
    commented out, but we'll get to that in a later section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s initialize the `express` application object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: This section of code wraps the Express application in an HTTP server and gets
    it listening to HTTP requests. The `server` object is also exported in case other
    code wants to access it.
  prefs: []
  type: TYPE_NORMAL
- en: Compare `app.mjs` with the generated `app.js` and `bin/www` code and you will
    see that we've covered everything in those two modules except for the inline functions.
    These inline functions could be written at the end of `app.mjs`, but we've elected
    instead to create a second module to hold them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `appsupport.mjs` to hold the inline functions, starting with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code handles errors from the HTTP server object. Some of these
    errors will simply cause the server to exit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: These were previously inline functions implementing error handling for the Express
    application.
  prefs: []
  type: TYPE_NORMAL
- en: The result of these changes is that `app.mjs` is now clean of distracting code,
    and it instead focuses on connecting together the different parts that make up
    the application. Since Express is not opinionated, it does not care that we restructured
    the code like this. We can structure the code in any way that makes sense to us
    and that correctly calls the Express API.
  prefs: []
  type: TYPE_NORMAL
- en: Since this application is about storing data, let's next talk about the data
    storage modules.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Notes data storage model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember that we decided earlier to put data model and data storage code into
    a directory named `models` to go along with the `views` and `routes` directories.
    Together, these three directories will separately store the three sides of the
    MVC paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is to centralize the implementation details of storing data. The data
    storage modules will present an API for storing and manipulating application data,
    and over the course of this book, we'll make several implementations of this API.
    To switch between one storage engine to another, we will just require a configuration
    change. The rest of the application will use the same API methods, regardless
    of the storage engine being used.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, let''s define a pair of classes to describe the data model. Create
    a file named `models/Notes.mjs` with the following code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a `Symbol` instance is done with `Symbol('symbol-name')`. The resulting
    `Symbol` instance is a unique identifier, and even if you call `Symbol('symbol-name')`
    again, the uniqueness is preserved. Each `Symbol` instance is unique from all
    other `Symbol` instances, even ones that are formed from the same string. In this
    example, the `b` and `b1` variables were both formed by calling `Symbol('b')`,
    but they are not equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can use a `Symbol` instance to attach fields to an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: With the `Note` class defined, we can create a `Note` instance, and then dump
    it and see the resulting fields. The keys to these fields are indeed `Symbol`
    instances. These `Symbol` instances are hidden inside the module. The fields themselves
    are visible to code outside the module. As we can see here, an attempt to subvert
    the instance with `note[Symbol('key')] = 'new key'` does not overwrite the field
    but instead adds a second field.
  prefs: []
  type: TYPE_NORMAL
- en: With our data types defined, let's start implementing the application, beginning
    with a simple in-memory datastore.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an in-memory Notes datastore
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Eventually, we will create a `Notes` data storage module that persists the notes
    to long-term storage. But to get us started, let's implement an in-memory datastore
    so that we can get on with implementing the application. Because we designed an
    abstract base class, we can easily create new implementations of that class for
    various storage services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `notes-memory.mjs` in the `models` directory with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: This creates an instance of the class and exports it as `NotesStore`. This will
    work so long as we have a single `NotesStore` instance, but in [Chapter 7](ae8529e5-3a08-45cc-89e9-82895eb45641.xhtml), *Data
    Storage and Retrieval*, we will change this around to support dynamically selecting
    a `NotesStore` instance.
  prefs: []
  type: TYPE_NORMAL
- en: We're now ready to start implementing the web pages and associated code for
    the application, starting with the home page.
  prefs: []
  type: TYPE_NORMAL
- en: The Notes home page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're going to modify the starter application to support creating, editing,
    updating, viewing, and deleting notes. Let's start by changing the home page to
    show a list of notes, and have a top navigation bar linking to an ADD Note page
    so that we can always add a new note.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s no change required in `app.mjs` because the home page is generated
    in routes controlled in this router module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: We showed the outline for this earlier, and having defined the `Notes` data
    storage model, we can fill in this function.
  prefs: []
  type: TYPE_NORMAL
- en: This uses the `AbstractNotesStore` API that we designed earlier. The `keylist`
    method returns a list of the key values for notes currently stored by the application.
    Then, it uses the `read` method to retrieve each note and pass that list to a
    template that renders the home page. This template will render a list of the notes.
  prefs: []
  type: TYPE_NORMAL
- en: 'What''s the best way to retrieve all the notes? We could have written a simple `for` loop,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: This is the file generated by `express-generator`, with the addition of a `header`
    partial for the page header.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that in the Fibonacci application, we used a *partial* to store the
    HTML snippet for the navigation. Partials are just that—HTML template snippets
    that can be reused in one or more templates. In this case, the `header` partial
    will appear on every page and serve as a common navigation bar across the application.
    Create `partials/header.hbs`, containing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: This simply steps through the array of note data and formats a simple listing.
    Each item links to the `/notes/view` URL with a `key` parameter. We have yet to
    write code to handle that URL, but will obviously display the note. Another thing
    to note is that no HTML for the list is generated if `notelist` is empty.
  prefs: []
  type: TYPE_NORMAL
- en: There is, of course, a whole lot more that could be put into this. For example,
    it's easy to add jQuery support to every page just by adding the appropriate `script`
    tags here.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now written enough to run the application, so let''s view the home
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: We'll end up with this in `app.mjs`. We import both routers and then add them
    to the application configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `routes/notes.mjs` to hold `notesRouter`, starting with
    the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: This template supports both creating new notes and updating existing notes.
    We'll reuse this template to support both scenarios via the `docreate` flag.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `note` and `notekey` objects passed to the template are empty
    in this case. The template detects this condition and ensures that the input areas
    are empty. Additionally, a flag, `docreate`, is passed in so that the form records
    whether it is being used to create or update a note. At this point, we're adding
    a new note, so no `note` objects exist. The template code is written defensively
    to not throw errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating HTML forms like this, you have to be careful with using whitespace
    in the elements holding the values. Consider a scenario where the `<textarea>`
    element was instead formatted like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: Because this URL will also be used for both creating and updating notes, we
    check the `docreate` flag to call the appropriate model operation.
  prefs: []
  type: TYPE_NORMAL
- en: Both `notes.create` and `notes.update` are async functions, meaning we must
    use `await`.
  prefs: []
  type: TYPE_NORMAL
- en: This is an HTTP `POST` handler. Because of the `bodyParser` middleware, the
    form data is added to the `req.body` object. The fields attached to `req.body`
    correspond directly to elements in the HTML form.
  prefs: []
  type: TYPE_NORMAL
- en: In this, and most of the other router functions, we use the `try/catch` construct
    that we discussed earlier to ensure errors are caught and forwarded correctly
    to Express. The difference between this and the preceding `/notes/add` router
    function is whether the router uses an async callback function. In this case,
    it is an async function, whereas for `/notes/add`, it is not async. Express knows
    how to handle errors in non-async callbacks, but it does not know how to handle
    errors in async callback functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can run the application again and use the Add a Note form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c949b296-32e0-4690-be97-a94016e40b5e.png)'
  prefs: []
  type: TYPE_IMG
- en: However, upon clicking on the Submit button, we get an error message. This is
    because there isn't anything (yet) to implement the `/notes/view` URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can modify the URL in the `Location` box to revisit `http://localhost:3000`, and
    you''ll see something similar to the following screenshot on the home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94936122-5cf1-4959-999d-0fc10d3766b3.png)'
  prefs: []
  type: TYPE_IMG
- en: The note is actually there; we just need to implement `/notes/view`. Let's get
    on with that.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing notes – read
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we've looked at how to create notes, we need to move on to reading
    them. This means implementing controller logic and view templates for the `/notes/view`
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `router` function to `routes/notes.mjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: This is straightforward; we are taking data out of the `note` object and displaying
    it using HTML. At the bottom are two links—one to `/notes/destroy` to delete the
    note and the other to `/notes/edit` to edit it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Neither of these corresponding codes exists at the moment, but that won''t
    stop us from going ahead and executing the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f551683-feb4-41c4-86a4-c5fcdabafde8.png)'
  prefs: []
  type: TYPE_IMG
- en: As expected, with this code, the application correctly redirects to `/notes/view`,
    and we can see our handiwork. Also, as expected, clicking on either the Delete
    or Edit links will give us an error because the code hasn't yet been implemented.
  prefs: []
  type: TYPE_NORMAL
- en: We'll next create the code to handle the Edit link and later, one to handle
    the Delete link.
  prefs: []
  type: TYPE_NORMAL
- en: Editing an existing note – update
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we've looked at the `create` and `read` operations, let's look at how
    to update or edit a note.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following router function to `routes/notes.mjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: Destroying a note is a significant step, if only because there's no trash can
    to retrieve it from if the user makes a mistake. Therefore, we need to ask the
    user whether they're sure that they want to delete the note. In this case, we
    retrieve the note and then render the following page, displaying a question to
    ensure they definitely want to delete the note.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `notedestroy.hbs` template to the `views` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: 'This calls the `notes.destroy` function in the model. If it succeeds, the browser
    is redirected to the home page. If not, an error message is shown to the user.
    Rerunning the application, we can now view it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bafe62b3-9c7a-4c38-a32a-e0ca175fad05.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that everything is working in the application, you can click on any button
    or link and keep all the notes you want.
  prefs: []
  type: TYPE_NORMAL
- en: We've implemented a bare-bones application for managing notes. Let's now see
    how to change the look, since in the next chapter, we'll implement a mobile-first
    UI.
  prefs: []
  type: TYPE_NORMAL
- en: Theming your Express application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Express team has done a decent job of making sure Express applications look
    okay out of the gate. Our `Notes` application won't win any design awards, but
    at least it isn't ugly. There's a lot of ways to improve it, now that the basic
    application is running. Let's take a quick look at theming an Express application.
    In Chapter 6, *Implementing the Mobile-First Paradigm*, we'll take a deeper dive
    into this, focusing on that all-important goal of addressing the mobile market.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re running the `Notes` application using the recommended method, `npm
    start`, a nice log of activity is being printed in your console window. One of
    these is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: 'This file was autogenerated for us by the Express generator at the outset and
    was dropped in the `public` directory. The `public` directory is managed by the
    Express static file server, using the following line in `app.mjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: 'Something that leaps out is that the application content has a lot of whitespace
    at the top and left-hand sides of the screen. The reason for this is that the `body` tags
    have the `padding: 50px` style. Changing it is a quick business.'
  prefs: []
  type: TYPE_NORMAL
- en: Since there is no caching in the Express static file server, we can simply edit
    the CSS file and reload the page, and the CSS will be reloaded as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make a couple of tweaks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: The `server1` script runs on `PORT 3001`, while the `server2` script runs on
    `PORT 3002`. Isn't it nice to have all of this documented in one place?
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in one command window, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives us two instances of the `Notes` application. Use two browser windows
    to visit `http://localhost:3001` and `http://localhost:3002`. Enter a couple of
    notes, and you might see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c6d2829-f1c9-4df4-9131-d8163de6210a.png)'
  prefs: []
  type: TYPE_IMG
- en: After editing and adding some notes, your two browser windows could look as
    in the preceding screenshot. The two instances do not share the same data pool;
    each is instead running in its own process and memory space. You add a note to
    one and it does not show on the other screen.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, because the model code does not persist data anywhere, the notes
    are not saved. You might have written the greatest Node.js programming book of
    all time, but as soon as the application server restarts, it's gone.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, you run multiple instances of an application to scale performance.
    That's the old *throw more servers at it* trick. For this to work, the data, of
    course, must be shared, and each instance must access the same data source. Typically,
    this involves a database, and when it comes to user identity information, it might
    even entail armed guards.
  prefs: []
  type: TYPE_NORMAL
- en: All that means databases, more data models, unit testing, security implementation,
    a deployment strategy, and much more. Hold on—we'll get to all of that soon!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've come a long way in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We started by looking at the pyramid of doom and how Promise objects and async
    functions can help us tame asynchronous code. Because we're writing an Express
    application, we looked at how to use async functions in Express. We'll be using
    these techniques throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: We quickly moved on to writing the foundation of a real application with Express.
    At the moment, our application keeps its data in memory, but it has the basic
    functionality of what will become a note-taking application that supports real-time
    collaborative commenting on notes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll dip our toes into the water of responsive, mobile-friendly
    web design. Due to the growing popularity of mobile computing devices, it's become
    necessary to address mobile devices first before desktop computer users. In order
    to reach those millions of users a day, the `Notes` application users need a good
    user experience when using their smartphones.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapters, we'll keep growing the capabilities of the `Notes`
    application, starting with database storage models. But first, we have an important
    task in the next chapter—implementing a mobile-first UI using Bootstrap.
  prefs: []
  type: TYPE_NORMAL
