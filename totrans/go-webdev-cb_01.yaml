- en: Creating Your First Server in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple HTTP server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing basic authentication on a simple HTTP server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing HTTP server responses with GZIP compression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a simple TCP server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading data from a TCP connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing data to a TCP connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing HTTP request routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing HTTP request routing using Gorilla Mux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging HTTP requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go was created to solve the problems that came with the new architecture of
    multi-core processors, creating high-performance networks that serve millions
    of requests and compute-intensive jobs. The idea behind Go was to increase productivity
    by enabling rapid prototyping, decreasing compile and build time, and enabling
    better dependency management.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike most other programming languages, Go provides the `net/http` package,
    which is sufficient when creating HTTP clients and servers. This chapter will
    cover the creation of HTTP and TCP servers in Go.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with some simple recipes to create an HTTP and TCP server and
    will gradually move to recipes that are more complex, where we implement basic
    authentication, optimize server responses, define multiple routes, and log HTTP
    requests. We will also cover concepts and keywords such as Go Handlers, Goroutines,
    and Gorilla – a web toolkit for Go.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple HTTP server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a programmer, if you have to create a simple HTTP server then you can easily
    write it using Go's `net/http` package, which we will be covering in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we are going to create a simple HTTP server that will render
    Hello World! when we browse `http://localhost:8080` or execute `curl` `http://localhost:8080`
    from the command line. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `http-server.go` and copy the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we run the program, an HTTP server will start locally listening on port
    `8080`. Opening `http://localhost:8080` in a browser will display Hello World!
    from the server, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2cff40e1-a56f-4dbf-bbbd-a61b57ab4600.png)'
  prefs: []
  type: TYPE_IMG
- en: Hello World!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s understand what each line in the program means:'
  prefs: []
  type: TYPE_NORMAL
- en: '`package main`: This defines the package name of the program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`import ( "fmt" "log" "net/http" )`: This is a preprocessor command that tells
    the Go compiler to include all files from `fmt`, `log`, and the `net/http` package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const ( CONN_HOST = "localhost" CONN_PORT = "8080" )`: We declare constants
    in the Go program using the `const` keyword. Here we declared two constants—one
    is `CONN_HOST` with localhost as a value and another one is `CONN_PORT` with `8080`
    as a value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func helloWorld(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, "Hello
    World!") }`: This is a Go function that takes `ResponseWriter` and `Request` as
    an input and writes `Hello World!` on an HTTP response stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we declared the `main()` method from where the program execution begins,
    as this method does a lot of things. Let’s understand it line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http.HandleFunc("/", helloWorld)`: Here, we are registering the `helloWorld`
    function with the `/` URL pattern using `HandleFunc` of the `net/http` package,
    which means `helloWorld` gets executed, passing `(http.ResponseWriter`, `*http.Request)`
    as a parameter to it whenever we access the HTTP URL with pattern `/`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`err := http.ListenAndServe(CONN_HOST+":"+CONN_PORT, nil)`: Here, we are calling
    `http.ListenAndServe` to serve HTTP requests that handle each incoming connection
    in a separate Goroutine. `ListenAndServe` accepts two parameters—server address
    and handler. Here, we are passing the server address as `localhost:8080` and handler
    as `nil`, which means we are asking the server to use `DefaultServeMux` as a handler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if err != nil { log.Fatal("error starting http server : ", err) return}`:
    Here, we check whether there is a problem starting the server. If there is, then
    log the error and exit with a status code of `1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing basic authentication on a simple HTTP server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have created the HTTP server then you probably want to restrict resources
    from being accessed by a specific user, such as the administrator of an application.
    If so, then you can implement basic authentication on an HTTP server, which we
    will be covering in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already created an HTTP server in our previous recipe, we will just
    extend it to incorporate basic authentication.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we are going to update the HTTP server we created in the previous
    recipe by adding a `BasicAuth` function and modifying the `HandleFunc` to call
    it. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `http-server-basic-authentication.go` and copy the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: Once the server starts, accessing `http://localhost:8080` in a browser will
    prompt you to enter a username and password. Providing it as `admin`, `admin`
    respectively will render Hello World! on the screen, and for every other combination
    of username and password it will render You are Unauthorized to access the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the server from the command line we have to provide the `--user`
    flag as part of the `curl` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also access the server using a `base64` encoded token of `username:password`,
    which we can get from any website, such as `https://www.base64encode.org/`, and
    pass it as an authorization header in the `curl` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s understand the change we introduced as part of this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: The `import` function adds an additional package, `crypto/subtle`, which we
    will use to compare the username and password from the user's entered credentials.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `const` function we defined two additional constants, `ADMIN_USER`
    and `ADMIN_PASSWORD`, which we will use while authenticating the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we declared a `BasicAuth()` method, which accepts two input parameters—a
    handler, which executes after the user is successfully authenticated, and realm,
    which returns `HandlerFunc`, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding handler, we first get the username and password provided in
    the request's authorization header using `r.BasicAuth()` then compare it to the
    constants declared in the program. If credentials match, then it returns the handler,
    otherwise it sets `WWW-Authenticate` along with a status code of `401` and writes
    `You are Unauthorized to access the application` on an HTTP response stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we introduced a change in the `main()` method to call `BasicAuth`
    from `HandleFunc`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We just pass a `BasicAuth` handler instead of `nil` or `DefaultServeMux` for
    handling all incoming requests with the URL pattern as `/`.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing HTTP server responses with GZIP compression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GZIP compression means sending the response to the client from the server in
    a `.gzip` format rather than sending a plain response and it’s always a good practice
    to send compressed responses if a client/browser supports it.
  prefs: []
  type: TYPE_NORMAL
- en: 'By sending a compressed response we save network bandwidth and download time
    eventually rendering the page faster. What happens in GZIP compression is the
    browser sends a request header telling the server it accepts compressed content
    (`.gzip` and `.deflate`) and if the server has the capability to send the response
    in compressed form then sends it. If the server supports compression then it sets
    `Content-Encoding: gzip` as a response header, otherwise it sends a plain response
    back to the client, which clearly means asking for a compressed response is only
    a request by the browser and not a demand. We will be using Gorilla’s handlers
    package to implement it in this recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we are going to create an HTTP server with a single handler,
    which will write Hello World! on an HTTP response stream and use a Gorilla `CompressHandler`
    to send all the responses back to the client in the `.gzip` format. Perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Gorilla handlers, first we need to install the package using the `go
    get` command or copy it manually to `$GOPATH/src` or `$GOPATH`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `http-server-mux.go` and copy the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Opening `http://localhost:8080` in a browser will display Hello World! from
    the server with the Content-Encoding response header value gzip, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7dc5f016-1d66-4503-bdeb-752523842b72.png)'
  prefs: []
  type: TYPE_IMG
- en: Hello World!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s understand what each line in the program means:'
  prefs: []
  type: TYPE_NORMAL
- en: '`package main`: This defines the package name of the program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`import ( "io" "net/http" "github.com/gorilla/handlers" )`: This is a preprocessor
    command that tells the Go compiler to include all files from `io`, `net/http`,
    and the `github.com/gorilla/handlers` package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const ( CONN_HOST = "localhost" CONN_PORT = "8080" )`: We declare constants
    in a Go program using the const keyword. Here, we declared two constants—one is
    `CONN_HOST` with a value of localhost and another is `CONN_PORT` with a value
    of 8080.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func helloWorld(w http.ResponseWriter, r *http.Request) { io.WriteString(w,
    "Hello World!")}`: This is a Go function that takes `ResponseWriter` and `Request`
    as input parameters and writes `Hello World!` on the HTTP response stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we declared the `main()` method from where the program execution begins.
    As this method does a lot of things, let’s understand it line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mux := http.NewServeMux()`: This allocates and returns a new HTTP request
    multiplexer (`ServeMux`), which matches the URL of each incoming request against
    a list of registered patterns and calls the handler for the pattern that most
    closely matches the URL. One of the benefits of using it is that the program has
    complete control over the handlers used with the server, although any handlers
    registered with the `DefaultServeMux` are ignored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http.HandleFunc("/", helloWorld)`: Here, we are registering the `helloWorld`
    function with the `/` URL pattern using `HandleFunc` of the `net/http` package,
    which means `helloWorld` gets executed, passing `(http.ResponseWriter`, `*http.Request)`
    as a parameter to it whenever we access the HTTP URL with the `/` pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`err := http.ListenAndServe(CONN_HOST+":"+CONN_PORT, handlers.CompressHandler(mux))`:
    Here, we are calling `http.ListenAndServe` to serve HTTP requests that handle
    each incoming connection in a separate Goroutine for us. `ListenAndServe` accepts
    two parameters—server address and handler. Here, we are passing the server address
    as `localhost:8080` and handler as `CompressHandler`, which wraps our server with
    a `.gzip` handler to compress all responses in a `.gzip` format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if err != nil { log.Fatal("error starting http server: ", err) return}`: Here,
    we check whether there is any problem in starting the server. If there is, then
    log the error and exit with a status code of 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a simple TCP server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever you have to build high performance oriented systems then writing a
    TCP server is always the best choice over an HTTP server, as TCP sockets are less
    hefty than HTTP. Go supports and provides a convenient way of writing TCP servers
    using a `net` package, which we will be covering in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we are going to create a simple TCP server that will accept
    a connection on `localhost:8080`. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `tcp-server.go` and copy the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we run the program, the TCP server will start locally listening on port
    `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s understand what each line in the program means:'
  prefs: []
  type: TYPE_NORMAL
- en: '`package main`: This defines the package name of the program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`import ( "log" "net")`: This is a preprocessor command that tells the Go compiler
    to include all files from the `log` and `net` package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const ( CONN_HOST = "localhost" CONN_PORT = "8080" CONN_TYPE = "tcp" )`: We
    declare constants in a Go program using the const keyword. Here, we declare three
    constants—one is `CONN_HOST` with a value of `localhost`, another one is `CONN_PORT`
    with a value as `8080`, and lastly `CONN_TYPE` with a value as `tcp`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we declared the `main()` method from where the program execution begins.
    As this method does a lot of things, let’s understand it line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '`listener, err := net.Listen(CONN_TYPE, CONN_HOST+":"+CONN_PORT)`: This creates
    a TCP server running on localhost at port `8080`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if err != nil { log.Fatal("Error starting tcp server: ", err) }`: Here, we
    check if there is any problem in starting the TCP server. If there is, then log
    the error and exit with a status code of 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`defer listener.Close()`: This defer statement closes a TCP socket listener
    when the application closes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we accept the incoming request to the TCP server in a constant loop,
    and if there are any errors in accepting the request, then we log it and exit;
    otherwise, we simply print the connection object on the server console, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Reading data from a TCP connection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common scenarios in any application is the client interacting
    with the server. TCP is one of the most widely used protocols for this interaction.
    Go provides a convenient way to read incoming connection data through `bufio`
    implementing buffered `Input/Output`, which we will be covering in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already created a TCP server in our previous recipe, we will update
    it to read data from incoming connections.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we are going to update the `main()` method to call a `handleRequest`
    method passing the connection object to read and print data on the server console.
    Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `tcp-server-read-data.go` and copy the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we run the program, the TCP server will start locally listening on port
    `8080`. Executing an `echo` command from the command line as follows will send
    a message to the TCP server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This apparently logs it to a server console, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e852ce37-88a6-4c6a-97c9-e00988ec7752.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s understand the change we introduced in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we called `handleRequest` from the `main()` method using the `go` keyword,
    which means we are invoking a function in a Goroutine, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we defined the `handleRequest` function, which reads an incoming connection
    into the buffer until the first occurrence of `\n` and prints the message on the
    console. If there are any errors in reading the message then it prints the error
    message along with the error object and finally closes the connection, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Writing data to a TCP connection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another common, as well as important, scenario in any web application is to
    send the data back to the client or responding to the client. Go provides a convenient
    way to write a message on a connection as bytes, which we will be covering in
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already created a TCP server that reads incoming connection data
    in the previous recipe, we will just update it to write the message back to the
    client.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we are going to update the `handleRequest` method in the program
    to write data back to the client. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `tcp-server-write-data.go` and copy the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we run the program, the TCP server will start locally listening on port
    `8080`. Execute an `echo` command from the command line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us the following response from the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at the changes we introduced in this recipe to write data to the
    client. Everything in `handleRequest` is exactly the same as in the previous recipe
    except we introduced a new line that writes data as a byte array to the connection,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Implementing HTTP request routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the time, you have to define more than one URL route in a web application,
    which involves mapping the URL path to the handlers or resources. In this recipe,
    we will learn how we can implement it in Go.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will define three routes, such as `/`, `/login`, and `/logout`
    along with their handlers. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `http-server-basic-routing.go` and copy the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we run the program, the HTTP server will start locally listening on port
    `8080` and accessing `http://localhost:8080/`, `http://localhost:8080/login`,
    and `http://localhost:8080/logout` from a browser or command line will render
    the message defined in the corresponding handler definition. For example, execute
    `http://localhost:8080/` from the command line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us the following response from the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/37497746-7f2d-4fe2-89ce-b9fcba58982c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We could also execute `http://localhost:8080/login` from the command line as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us the following response from the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3278b2fb-4f05-4654-9b24-3df2751d2d03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s understand the program we have written:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We started with defining three handlers or web resources, such as the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `helloWorld` handler writes `Hello World!` on an HTTP response stream.
    In a similar way, login and logout handlers write `Login Page!` and `Logout Page!`
    on an HTTP response stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we registered three URL paths—`/`, `/login`, and `/logout` with `DefaultServeMux`
    using `http.HandleFunc()` . If an incoming request URL pattern matches one of
    the registered paths, then the corresponding handler is called passing `(http.ResponseWriter`,
    `*http.Request)` as a parameter to it, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Implementing HTTP request routing using Gorilla Mux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go’s `net/http` package offers a lot of functionalities for URL routing of the
    HTTP requests. One thing it doesn’t do very well is dynamic URL routing. Fortunately,
    we can achieve this with the `gorilla/mux` package, which we will be covering
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will use `gorilla/mux` to define a few routes, like we did
    in our previous recipe, along with their handlers or resources. As we have already
    seen in one of our previous recipes, to use external packages, first we have to
    install the package using the `go get` command or we have to copy it manually
    to `$GOPATH/src` or `$GOPATH`. We will do the same in the recipe as well. Perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `github.com/gorilla/mux` using the `go get` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `http-server-gorilla-mux-routing.go` and copy the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we run the program, the HTTP server will start locally listening on port
    `8080`, and accessing `http://localhost:8080/`, `http://localhost:8080/post`,
    and `http://localhost:8080/hello/foo` from a browser or command line will produce
    the message defined in the corresponding handler definition. For example, execute
    `http://localhost:8080/` from the command line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us the following response from the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5dbedcdd-3be8-4718-af12-a6d8afb02094.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We could also execute `http://localhost:8080/hello/foo` from the command line,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us the following response from the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/783a091d-58e2-406d-b4ac-18bb23bc2aed.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s understand the code changes we made in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we defined `GetRequestHandler` and `PostRequestHandler`, which simply
    write a message on an HTTP response stream, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we defined `PathVariableHandler`, which extracts request path variables,
    gets the value, and writes it to an HTTP response stream, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we registered all these handlers with the `gorilla/mux` router and instantiated
    it, calling the `NewRouter()` handler of the mux router, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Logging HTTP requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logging HTTP requests is always useful when troubleshooting a web application,
    so it’s a good idea to log a request/response with a proper message and logging
    level. Go provides the `log` package, which can help us to implement logging in
    an application. However, in this recipe we will be using Gorilla logging handlers
    to implement it because the library offers more features such as logging in Apache
    Combined Log Format and Apache Common Log Format, which are not yet supported
    by the Go `log` package.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already created an HTTP server and defined routes using Gorilla Mux
    in our previous recipe, we will update it to incorporate Gorilla logging handlers.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s implement logging using Gorilla handlers. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `github.com/gorilla/handler` and `github.com/gorilla/mux` packages
    using the `go get` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `http-server-request-logging.go` and copy the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program, using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute a `GET` request from the command line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log the request details in the server log in the Apache Common Log
    Format, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d0cddd33-c7b7-4425-b8b9-54c3b29abae8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We could also execute `http://localhost:8080/hello/foo` from the command line,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log the request details in the `server.log` in the Apache Combined
    Log Format, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3221304b-510c-4324-98ba-8cda9f8ac737.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s understand what we have done in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we imported two additional packages, one is `os`, which we use to
    open a file. The other one is `github.com/gorilla/handlers`, which we use to import
    logging handlers for logging HTTP requests, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Next, we modified the `main()` method. Using `router.Handle("/", handlers.LoggingHandler(os.Stdout,`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http.HandlerFunc(GetRequestHandler))).Methods("GET")`, we wrapped `GetRequestHandler`
    with a Gorilla logging handler, and passed a standard output stream as a writer
    to it, which means we are simply asking to log every request with the URL path
    `/` on the console in Apache Common Log Format.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create a new file named `server.log` in write-only mode, or we open
    it, if it already exists. If there is any error, then log it and exit with a status
    code of 1, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Using `router.Handle("/post", handlers.LoggingHandler(logFile, PostRequestHandler)).Methods("POST")`,
    we wrapped `GetRequestHandler` with a Gorilla logging handler and passed the file
    as a writer to it, which means we are simply asking to log every request with
    the URL path `/post` in a file named `/hello/{name}` in Apache Common Log Format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using `router.Handle("/hello/{name}", handlers.CombinedLoggingHandler(logFile,
    PathVariableHandler)).Methods("GET")`, we wrapped `GetRequestHandler` with a Gorilla
    logging handler and passed the file as a writer to it, which means we are simply
    asking to log every request with the URL path `/hello/{name}` in a file named
    `server.log` in Apache Combined Log Format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
