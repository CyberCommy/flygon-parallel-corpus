- en: Prominent OOP Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term **object-oriented** (**OO**) has been around since the 70s, when it
    was coined by computer scientist, Alan Kay. The term stood for a programming paradigm
    based on the concept of objects. At that time, Simula was the first language to
    exhibit OO features, such as objects, classes, inheritance, subtyping, and so
    on. Standardized as Simula 67 in 1977, it became an inspiration for later languages.
    One such inspired language is Smalltalk, created as a product of research led
    by Alan Kay at Xerox. Compared to Simula, Smalltalk greatly improved the overall
    OO concept. Over time, Smalltalk became one of the most influential OO programming
    language.
  prefs: []
  type: TYPE_NORMAL
- en: While there is much more to be said about these early days, the takeaway is
    that OOP was born out of specific need. Where Simula used static objects for modeling
    real-world entities, Smalltalk used dynamic objects that could be created, changed,
    or deleted as the foundation for computation.
  prefs: []
  type: TYPE_NORMAL
- en: The MVC pattern, one of the most common object-oriented software design patterns, was
    introduced in Smalltalk.
  prefs: []
  type: TYPE_NORMAL
- en: The ease of mapping physical entities into objects described by classes certainly
    influenced the overall popularity of the OO paradigm among developers. However,
    objects are not just about mapped out instances of various properties, they are
    also about messages and responsibilities. While we may embrace OOP based on the
    first premise, we certainly start to appreciate the latter one, as the key to
    making big and scalable systems lies in the ease of object communication.
  prefs: []
  type: TYPE_NORMAL
- en: 'The PHP language embodies several paradigms, most notably: imperative, functional,
    object oriented, procedural, and reflective. Whereas, the OOP support in PHP hasn''t
    fully kicked off until the PHP 5 release. The latest versions of PHP 7 brought
    forth some minor yet noteworthy improvements to what is now considered a stable
    and mature PHP OOP model.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore some prominent features of object-oriented
    PHP:'
  prefs: []
  type: TYPE_NORMAL
- en: Object inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects and references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object iteration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object comparison
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reflection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The OOP paradigm places objects at the heart of application design, where objects
    can be looked at as units that contain various properties and methods. Interaction
    between these properties and methods defines the internal state of an object.
    Every object is built from a blueprint called a class. There is no such thing
    as an object without the class, at least not in a class-based OOP.
  prefs: []
  type: TYPE_NORMAL
- en: We differentiate class-based OOP (PHP, Java, C#, ...) and prototype-based OOP
    (ECMAScript / JavaScript, Lua, ...). In class-based OOP, objects are created from
    classes; in prototype-based OOP, objects are created from other objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process of building or creating new objects is called **instantiation**.
    In PHP, like many other languages, we use the `new` keyword to instantiate an object
    from a given class. Let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are defining two simple classes, `JsonOutput` and `SerializedOutput`.
    We say simple merely because they have a single property and two methods. These
    two classes are nearly identical--they only differ in a single line of code within
    the `render()` method. One class converts the given content into JSON, while the
    other converts it to a serialized string. Right after our class declarations,
    we define a dummy $users array that we then feed to the instances of the `JsonOutput`
    and `SerializedOutput` classes, that is, the `$json` and `$ser` objects.
  prefs: []
  type: TYPE_NORMAL
- en: While this is far from an ideal class design, it serves as a nice introduction
    into inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: allows classes and, therefore, objects to inherit properties and methods of
    another class. Terms such as *s*uperclass, base class, or parent class are used
    to flag the class used as a basis for inheritance. Terms such as subclass, derived
    class, or child class are used to flag the inheriting class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The PHP `extends` keyword is used to enable inheritance. Inheritance has its
    limits. We can only extend from a single class at a time as PHP does not support multiple inheritance.
    However, having a chain of inheritance is perfectly valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `C` class shown in the valid example will end up inheriting all the allowed
    properties and methods of classes `B` and `A`. When we say allowed, we refer to
    the property and method visibility, that is, access modifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the object context, the access modifiers behave as per the preceding example, which
    is pretty much as we would expect them to. The object would exhibit the same behavior,
    whether it was an instance of class `A` or class `B`. Let''s observe the behavior
    of access modifiers on the inner workings of the child class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the `public` and `protected` members (property or method) can
    be accessed from child classes, whereas private members cannot--they are only
    accessible from the class that defines them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `extends` keyword is also applicable to interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Being able to inherit the class and interface properties and methods makes for
    a powerful overall object inheritance mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowing these simple inheritance rules, let''s see how we can rewrite our `JsonOutput`
    and the `SerializedOutput` classes into a more convenient form using inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We started off by defining an `Output` class with the content nearly identical
    to the previous `JsonOutput` and `SerializedOutput` classes, merely changing its
    `render()` method to simply return content as-is. We then rewrote the `JsonOutput`
    and `SerializedOutput` classes in such a way that they both extend the `Output`
    class. In this setup, an `Output` class becomes a parent class, whereas `JsonOutput`
    and `SerializedOutput` become child classes. The child classes redefine the `render()`
    method, thus overriding the parent class implementation. The `$this` keyword has
    access to all of the public and protected modifiers, which makes it easy to access
    the `$content` property.
  prefs: []
  type: TYPE_NORMAL
- en: While inheritance might be a quick and powerful way to structure our code into
    convenient chains of parent/child relationships, one should avoid the danger of
    misusing or overusing it. This can be especially tricky with larger systems where
    we might end up spending more time tackling a large class hierarchy than actually
    maintaining the sub-system interfaces. Therefore, we should use it carefully.
  prefs: []
  type: TYPE_NORMAL
- en: Objects and references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two ways to pass arguments within the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**By reference**: This is where both the caller and callee use the same variable
    for argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**By value**: This is where both the caller and callee have their own copy
    of the variable for argument. If the callee decides to change the value of the
    passed argument, the caller would not notice it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'by value is the default PHP behavior, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at the internals of the `hello()` method, we can see it is resetting
    the `$msg` argument value to another string value wrapped in HTML tags. The default
    PHP passed by the value behavior prevents this change to propagate outside the
    scope of a method. Using the `&` operator just before the argument name in the
    function definition, we can force the passed by reference behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Being able to do something does not necessarily mean we should. The passing
    by reference behavior should be used with caution, only if there's a really good
    reason to do it. The preceding example clearly shows the side-effect of the internal
    `hello()` method to a simple scalar type value within the outside scope. Object
    instance methods, or even plain functions, should not have these types of side-effect
    to the outside scope.
  prefs: []
  type: TYPE_NORMAL
- en: Several PHP functions, such as `sort()`, use the `&` operator to force the pass
    by reference behavior on a given array argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all being said, where do objects fit in? Objects in PHP lean towards the passed
    by reference behavior. When an object is passed as an argument, it is still being
    passed as a value, but the value being passed is not the object itself, it is
    the object identifier. Therefore, the act of passing the object as an argument
    feels more like it is being passed by reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Since objects are bigger structures than scalar values, passing by reference
    greatly minimizes the memory and CPU footprint.
  prefs: []
  type: TYPE_NORMAL
- en: Object iteration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The PHP arrays are the most frequent collection structure used in PHP. We can
    squeeze pretty much anything into an array, ranging from scalar values to objects.
    Iterating through elements of such a structure is trivially easy using the `foreach`
    statement. However, arrays are not the only iterable types, as objects themselves
    are iterable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following array-based example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s take a look at the following object-based example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Executed on the console, both of these examples would yield an identical output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: By default, iteration works only with public properties, excluding any private or
    protected properties from the list.
  prefs: []
  type: TYPE_NORMAL
- en: PHP provides an `Iterator` interface, making it possible to specify what values
    we want to make available for iterating.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example demonstrates a simple `Iterator` interface implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: With this implementation, we are now seemingly able to iterate over the User
    class private and protected properties. Although, this is not really the case.
    What's happening is that, through the constructor, the class is filling the `$info` parameter
    with the data of all other properties we wish to iterate. The interface mandated
    methods then ensure that our class plays nicely with the `foreach` construct.
  prefs: []
  type: TYPE_NORMAL
- en: Object iteration is a neat, though often overlooked, feature of PHP when it
    comes to everyday development.
  prefs: []
  type: TYPE_NORMAL
- en: Object comparison
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The PHP language provides several comparison operators that allow us to compare two
    different values, resulting in either `true` or `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`==`: equal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`===`: identical'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`!=`: not equal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<>`: not equal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`!==`: not identical'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<`: less than'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>`: greater than'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<=`: less than or equal to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>=`: greater than or equal to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While all of these operators are equally important, let's take a closer look
    at the behavior of the equal (`==`) and identical (`===`) operators in the context
    of objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a simple `User` class with two properties set to some default
    values. We then have two different instances of the same class, `$user` and `$employee`. Given
    that both objects have the same properties, with the same values, the equal (`==`)
    operator returns `true`. The identical (`===`) operator, on the other hand, returns
    false. Even though objects are of the same class, and have the same properties
    and values in those properties, an identical operator sees them as different.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The identical (`===`) operator considers two objects to be identical only if
    they refer to the same instance of the same class. The same operator behavior
    applies to the counterpart operators, that is, the not equal (`<>` or `!=`)  and
    not identical (`!==`) operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside from objects, the identical operator is applicable to any other type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the preceding example clearly reveals the importance of an identical
    operator. The  `2 == "2ABC"` expression evaluating to true is something that boggles the
    mind. We might even think of it as a bug in the PHP language itself. While relying
    on PHP automatic type conversion is mostly fine, there are times where unexpected
    bugs can squeeze in and disrupt our application logic. The use of the identical
    operator reaffirms the comparison, assuring that we consider not just the value
    but the type as well.
  prefs: []
  type: TYPE_NORMAL
- en: Traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We mentioned previously that PHP is a single inheritance language. We cannot
    use the `extends` keyword to extend multiple classes in PHP. This very feature
    is actually a rare commodity only a handful of programming languages support,
    such as C++. For better or worse, multiple inheritance allows some interesting
    tinkering with our code structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'The PHP Traits provide a mechanism by which we can achieve these structures,
    either in the context of code reuse or the grouping of functionality. The `trait` keyword
    is used to declare a Trait, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The body of a Trait can be pretty much anything we would put in a class. While
    they resemble classes, we cannot instantiate a Trait itself. We can only use the
    Trait from another class. To do so, we employ the `use` keyword within the class
    body, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To better understand how Traits can be helpful, let''s take a look at the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example demonstrates the use of trait in a code reuse context,
    where two different shipping classes, `Ups` and `Dhl`, use the same trait. The
    trait itself wraps a nice little `formatPrice()` helper method that formats the
    given price to two decimal fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like classes, traits have access to `$this`, 1 which means we could easily rewrite
    the previous `formatPrice()` method of the `Formatter` trait as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This, however, severely limits our trait use, as its `formatPrice()` method
    now expects a `$price` member, which some of the classes using the `Formatter`
    trait might not have.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at another example where we use traits in a grouping of
    functionality context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: What we did here was nothing more than cut and paste our class code into two
    different traits. We grouped all of the methods related to possible order actions
    into a single `SalesOrderActions` trait, and all methods related to order customer
    into the `SalesOrderCustomer` trait. This brings us back to the possible-does-not-necessarily-mean-preferable
    philosophy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using multiple traits can sometimes lead to conflicts, where the same method
    name can be found in more than one trait. We can use the `insteadof` and `as`
    keywords to mitigate these types of conflicts, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `as` keyword can also be used in conjunction with the `public`, `protected`,
    or `private` keywords in order to change the method visibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To make things even more interesting, traits can be further composed of other
    traits, even supporting the `abstract` and `static` members, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Aside from being non-instantiatable, traits share many features with classes.
    While they provide us with the tooling for some interesting code structuring, they
    also make it easy to violate the single responsibility principle. The overall
    impression of trait usage is often that of extending regular classes, which makes
    it hard to find the right use case. We can use them to describe characteristics
    that are common to many, but not essential. For example, jet engines are not essential
    on every airplane, but a lot of airplanes have them, whereas others might have
    propellers.
  prefs: []
  type: TYPE_NORMAL
- en: Reflection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reflection is a highly important concept every developer should be wary about.
    It denotes the ability of a program to inspect itself during runtime, thus allowing
    easy reverse-engineering of classes, interfaces, functions, methods, and extensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get a quick taste of the PHP reflection capabilities right from the
    console. The PHP CLI supports several reflection-based commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--rf <*function name*>`: This shows information about a function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--rc <*class name*>`: This shows information about a class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--re <*extension name*>`: This shows information about an extension'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--rz <*extension name*>`: This shows information about the Zend extension'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--ri <*extension name*>`: This shows the configuration for an extension'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following output demonstrates the result of the `php --rf str_replace`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The output reflects on the `str_replace()` function, which is a standard PHP
    function. It clearly describes the total number of parameters, along with their
    name and required or optional assignment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The real power of reflection, the one developers get to utilize, comes from
    the reflection API. Let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We started off  by defining a `User` class with three properties, each of a
    different visibility. We then instantiated an object of the `User` class and tried
    changing the value of all three properties. Normally, members that are defined
    as `protected` or `private` cannot be accessed outside of an object. Trying to
    access them either in read or write mode would throw a Cannot access... error.
    This is what we would consider a normal behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the PHP reflection API, we can circumvent this normal behavior, making
    it possible to access private and protected members. The reflection API itself
    provides several classes for us to use:'
  prefs: []
  type: TYPE_NORMAL
- en: Reflection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ReflectionClass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ReflectionZendExtension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ReflectionExtension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ReflectionFunction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ReflectionFunctionAbstract
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ReflectionMethod
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ReflectionObject
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ReflectionParameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ReflectionProperty
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ReflectionType
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ReflectionGenerator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reflector (interface)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ReflectionException (exception)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of these classes expose a diverse set of functionality, allowing us to
    tinker with internals of other classes, interfaces, functions, methods, and extensions.
    Assuming our goal is to change the values of `protected` and `private` properties
    from the previous example, we could use `ReflectionClass` and `ReflectionProperty`,
    as per the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We started off by instantiating an object of a `User` class, as we did in the
    previous example. We then created an instance of `ReflectionClass`, passing its
    constructor the name of the `User` class. The newly created `$reflector` instance
    allows us to fetch a list of all `User` class properties through its `getProperties()`
    method. Looping through properties, one by one, we kick off the real magic of
    reflection API. Each property (`$prop`) is an instance of the `ReflectionProperty`
    class. Two of the `ReflectionProperty` methods, `setAccessible()` and `setValue()`,
    provide just the right functionality for us to reach our goal. Using these methods,
    we are able to set the value of otherwise inaccessible object properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another simple, yet interesting reflection example is that of doc comment extraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: With merely two lines of code, we were able to reflect upon a `Calc` class and
    extract the doc comment from its `sum()` method. While the practical use of the
    reflection API might not be obvious at first, it is capabilities such as these
    that empower us with building powerful and dynamic libraries and platforms.
  prefs: []
  type: TYPE_NORMAL
- en: The phpDocumentor tool uses the PHP reflection features to automatically generate
    documentation from the source code. The popular Magento v2.x eCommerce platform
    extensively uses the PHP reflection features to automatically instantiate objects
    that are type-hinted as `__construct()` arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we took a look into some of the most basic, yet lesser
    known features of PHP OOP that sometimes do not get enough attention in our day-to-day
    development. Nowadays, most of the mainstream work is focused around working with
    frameworks and platforms, which tend to abstract some of these concepts from us. Understanding
    the inner workings of objects is crucial to successfully developing and debugging
    a larger system. The reflection API provides a great deal of power when it comes
    to manipulating objects. Combined with the power of magic methods, which we mentioned
    in [Chapter 4](d96bd098-e569-4ac7-ba7e-47ad24e3bbfb.xhtml), *Magic Behind Magic
    Methods*, the PHP OOP model seems quite feature-rich.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, we will assume that we have a working application in place and
    focus on optimizing it for high performance.
  prefs: []
  type: TYPE_NORMAL
