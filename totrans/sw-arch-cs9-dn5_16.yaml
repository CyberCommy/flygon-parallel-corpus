- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blazor WebAssembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to implement a presentation layer with Blazor
    WebAssembly. Blazor WebAssembly applications are C# applications that can run
    in any browser that supports the WebAssembly technology. They can be accessed
    by navigating to a specific URL and are downloaded in the browser as standard
    static content, made of HTML pages and downloadable files.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor applications use many technologies we already analyzed in *Chapter 15*,
    *Presenting ASP.NET Core MVC*, such as dependency injection and Razor. Therefore,
    we strongly recommend studying *Chapter 15*, *Presenting ASP.NET Core MVC*, before
    reading this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'More specifically, in this chapter, you will learn about the following subjects:'
  prefs: []
  type: TYPE_NORMAL
- en: Blazor WebAssembly architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blazor pages and components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blazor forms and validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blazor advanced features, such as globalization, authentication, and JavaScript
    interoperability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third-party tools for Blazor WebAssembly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use case: implementing a simple application in Blazor WebAssembly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While there is also server-side Blazor, which runs on the server like ASP.NET
    Core MVC, this chapter discusses just Blazor WebAssembly, which runs entirely
    in the user's browser, since the main purpose of the chapter is to furnish a relevant
    example of how to implement a presentation layer with client-side technology.
    Moreover, as a server-side technology, Blazor can't furnish a performance that
    is comparable with other server-side technologies like ASP.NET Core MVC, which
    we already analyzed in *Chapter 15*, *Presenting ASP.NET Core MVC*.
  prefs: []
  type: TYPE_NORMAL
- en: The first section gives a sketch of the general Blazor WebAssembly architecture,
    while the remaining sections describe specific features. When needed, concepts
    are clarified by analyzing and modifying the example code that Visual Studio generates
    automatically when one selects the Blazor WebAssembly project template. The last
    section shows how to use all the concepts learned in practice with the implementation
    of a simple application based on the WWTravelClub book use case.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires the free Visual Studio 2019 Community edition or better
    with all database tools installed. All concepts are clarified with a simple example
    application, based on the WWTravelClub book use case. The code for this chapter
    is available at [https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5](https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5).
  prefs: []
  type: TYPE_NORMAL
- en: Blazor WebAssembly architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blazor WebAssembly exploits the new WebAssembly browser feature to execute the
    .NET runtime in the browser. This way, it enables all developers to use the whole
    .NET code base and ecosystem in the implementation of applications capable of
    running in any WebAssembly compliant browser. WebAssembly was conceived as a high-performance
    alternative to JavaScript. It is an assembly capable of running in a browser and
    obeying the same limitations as JavaScript code. This means that WebAssembly code,
    like JavaScript code, runs in an isolated execution environment that has very
    limited access to all machine resources.
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly differs from similar options of the past, like Flash and Silverlight,
    since it is an official W3C standard. More specifically, it became an official
    standard on December 5, 2019, so it is expected to have a long life. As a matter
    of fact, all mainstream browsers already support it.
  prefs: []
  type: TYPE_NORMAL
- en: However, WebAssembly doesn't bring just performance with it! It also creates
    the opportunity to run whole code bases associated with modern and advanced object-oriented
    languages such as C++ (direct compilation), Java (bytecode), and C# (.NET) in
    browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft advises running .NET code in the browser with the Unity 3D graphic
    framework and Blazor.
  prefs: []
  type: TYPE_NORMAL
- en: Before WebAssembly, presentation layers running in a browser could be implemented
    only in JavaScript, with all the problems implied by the maintenance of big code
    bases the language brings with it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, with Blazor we can implement complex applications in the modern and advanced
    C#, with all the comforts offered to this language by the C# compiler and Visual
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, with Blazor, all .NET developers can use the full power of the .NET
    framework to implement presentation layers that run in the browser and that share
    libraries and classes with all other layers that run on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: The subsections that follow describe the overall Blazor architectures. The first
    subsection explores the general concept of a Single-Page Application, pointing
    out Blazor peculiarities.
  prefs: []
  type: TYPE_NORMAL
- en: What is a Single-Page Application?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **Single-Page Application** (**SPA**) is an HTML-based application, where
    the HTML is changed by code that runs in the browser itself instead of issuing
    a new request to the server and rendering a new HTML page from scratch. SPAs are
    able to simulate a multi-page experience by replacing complete page areas with
    new HTML.
  prefs: []
  type: TYPE_NORMAL
- en: SPA frameworks are frameworks explicitly designed for implementing SPAs. Before
    WebAssembly, all SPA frameworks were based on JavaScript. The most famous JavaScript-based
    SPA frameworks are Angular, React.js, and Vue.js.
  prefs: []
  type: TYPE_NORMAL
- en: All SPA frameworks furnish ways to transform data into HTML to show to the user
    and rely on a module called *router* to simulate page changes. Typically, data
    fills in the placeholders of HTML templates and selects which parts of a template
    to render (if-like constructs), and how many times to render it (for-like constructs).
  prefs: []
  type: TYPE_NORMAL
- en: The Blazor template language is Razor, which we already described in *Chapter
    15*, *Presenting ASP.NET Core MVC*.
  prefs: []
  type: TYPE_NORMAL
- en: In order to increase modularity, code is organized into components that are
    a kind of virtual HTML tag that, once rendered, generates actual HTML markup.
    Like HTML tags, components have their attributes, which are usually called parameters,
    and their custom events. It is up to the developer to ensure that each component
    uses its parameters to create proper HTML and to ensure that it generates adequate
    events. Components can be used inside other components in a hierarchical fashion.
  prefs: []
  type: TYPE_NORMAL
- en: The application router performs its job by selecting components, acting as pages,
    and placing them in predefined areas. Each page component has a web address path
    that is somehow associated with it. This path concatenated with the web application
    domain becomes a URL that univocally identifies the page. As in usual web applications,
    page URLs are used to communicate to the router which page to load, either with
    usual links or with routing methods/functions.
  prefs: []
  type: TYPE_NORMAL
- en: Some SPA frameworks also furnish a predefined dependency injection engine in
    order to ensure better separation between components from one side and general-purpose
    services plus business code that runs in the browser on the other side. Among
    the frameworks listed in this subsection, only Blazor and Angular have an out-of-the-box
    dependency injection engine.
  prefs: []
  type: TYPE_NORMAL
- en: SPA frameworks based on JavaScript usually compile all JavaScript code in a
    few JavaScript files and then perform so-called tree-shaking, that is, the removal
    of all unused code.
  prefs: []
  type: TYPE_NORMAL
- en: At the moment, instead, Blazor keeps all DLLs referenced by the main application
    separate, and performs tree-shaking on each of them separately.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection starts to describe the Blazor architecture. You are encouraged
    to create a Blazor WebAssembly project called `BlazorReview`, so you can inspect
    the code and the constructs explained throughout the chapter. Please select **Individual
    User Accounts** as authentication, and **ASP.NET Core hosted**. This way, Visual
    Studio will also create an ASP.NET Core project that communicates with the Blazor
    client application, with all the authentication and authorization logic.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_16_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.1: Creating the BlazorReview application'
  prefs: []
  type: TYPE_NORMAL
- en: If you start the application and try to log in or try to access a page that
    requires login, an error should appear saying database migrations have not been
    applied. It should be enough to click the link next to the message to apply the
    pending migrations. Otherwise, as explained in the *Entity Framework Core migrations*
    section of *Chapter 8*, *Interacting with Data in C# – Entity Framework Core*,
    go to the Visual Studio Package Manager Console and run the `Update-Database`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Loading and starting the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The URL of a Blazor WebAssembly application always includes an `index.html`
    static HTML page. In our `BlazorReview` project, `index.html` is in `BlazorReview.Client->wwwroot->index.html`.
    This page is the container where the Blazor application will create its HTML.
    It contains an HTML header with a `viewport meta` declaration, title, and the
    overall application's CSS. The Visual Studio default project template adds an
    application-specific CSS file and Bootstrap CSS, with a neutral style. You can
    replace the default Bootstrap CSS either with Bootstrap CSS with a customized
    style or with a completely different CSS framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'The body contains the code that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The initial `div` is where the application will place the code it generates.
    Any markup placed inside this `div` will appear just while the Blazor application
    is loading and starting, then it will be replaced by the application-generated
    HTML. The second `div` is normally invisible and appears only when Blazor intercepts
    an unhandled exception.
  prefs: []
  type: TYPE_NORMAL
- en: '`blazor.webassembly.js` contains the JavaScript part of the Blazor framework.
    Among other things, it takes care of downloading the .NET runtime, together with
    all application DLLs. More specifically, `blazor.webassembly.js` downloads the
    `blazor.boot.json` file that lists all application files with their hashes. Then,
    `blazor.webassembly.js` downloads all resources listed in this file and verifies
    their hashes. All resources downloaded by `blazor.webassembly.js` are created
    when the application is built or published.'
  prefs: []
  type: TYPE_NORMAL
- en: '`AuthenticationService.js` is added only when the project enables authentication
    and takes care of the `OpenID Connect` protocol used by Blazor to exploit other
    authentication credentials like cookies to get bearer tokens, which are the preferred
    authentication credentials for clients that interact with a server through Web
    APIs. Authentication is discussed in more detail in the *Authentication and authorization*
    subsection later on in this chapter, while bearer tokens are discussed in the
    *REST services authorization and authentication* section of *Chapter 14*, *Applying
    Service-Oriented Architectures with .NET Core*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Blazor application entry point is in the `BlazorReview.Client->Program.cs`
    file. It has the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`WebAssemblyHostBuilder` is a builder for creating a `WebAssemblyHost`, which
    is a WebAssembly-specific implementation of the generic host discussed in the
    *Using generic hosts* subsection of *Chapter 5*, *Applying a Microservice Architecture
    to Your Enterprise Application* (you are encouraged to review that subsection).
    The first builder configuration instruction declares the Blazor root component
    (`App`), which will contain the whole components tree, and in which HTML tag of
    the `Index.html` page to place it (`#app`). More specifically, `RootComponents.Add`
    adds a hosted service that takes care of handling the whole Blazor components
    tree. We can run several Blazor WebAssembly user interfaces in the same HTML page
    by calling `RootComponents.Add` several times, each time with a different HTML
    tag reference.'
  prefs: []
  type: TYPE_NORMAL
- en: '`builder.Services` contains all the usual methods and extension methods to
    add services to the Blazor application dependency engine: `AddScoped`, `AddTransient`,
    `AddSingleton`, and so on. Like in ASP.NET Core MVC applications (*Chapter 15*,
    *Presenting ASP.NET Core MVC*), services are the preferred places to implement
    business logic and to store shared state. While in ASP.NET Core MVC, services
    were usually passed to controllers, in Blazor WebAssembly, they are injected into
    components.'
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection explains how the root `App` component simulates page changes.
  prefs: []
  type: TYPE_NORMAL
- en: Routing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The root `App` class referenced by the host building code is defined in the
    `BlazorReview.Client->App.razor` file. `App` is a Blazor component, and like all
    Blazor components, it is defined in a file with a `.razor` extension and uses
    Razor syntax enriched with component notation, that is, with HTML-like tags that
    represent other Blazor components. It contains the whole logic for handling application
    pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: All tags in the preceding code represent either components or particular component
    parameters, called templates. Components will be discussed in detail throughout
    the chapter. For the moment, imagine them as a kind of custom HTML tag that we
    can define somehow with C# and Razor code. Templates, instead, are parameters
    that accept Razor markup as values. Templates are discussed in the *Templates
    and cascading parameters* subsection later on in this section.
  prefs: []
  type: TYPE_NORMAL
- en: The `CascadingAuthenticationState` component has the only function of passing
    authentication and authorization information to all components of the component
    tree that is inside of it. Visual Studio generates it only if one chooses to add
    authorization during project creation.
  prefs: []
  type: TYPE_NORMAL
- en: The `Router` component is the actual application router. It scans the assembly
    passed in the `AppAssembly` parameter looking for components containing routing
    information, that is, for components that can work as pages. Visual studio passes
    it the assembly that contains the `Program` class, that is, the main application.
    Pages contained in other assemblies can be added through the `AdditionalAssemblies`
    parameter, which accepts an `IEnumerable` of assemblies.
  prefs: []
  type: TYPE_NORMAL
- en: After that, the router intercepts all page changes performed either by code
    or through the usual `<a>` HTML tags that point to an address inside of the application
    base address. Navigation can be handled by code by requiring a `NavigationManager`
    instance from dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Router` component has two templates, one for the case where a page for
    the requested URI is found (`Found`), and the other for the case where it is not
    found (`NotFound`). When the application uses authorization, the `Found` template
    consists of the `AuthorizeRouteView` components, which further distinguish whether
    the user is authorized to access the selected page or not. When the application
    doesn''t use authorization, the `Found` template consists of the `RouteView` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`RouteView` takes the selected page and renders it inside the layout page specified
    by the `DefaultLayout` parameter. This specification acts just as a default since
    each page can override it by specifying a different layout page. Blazor layout
    pages work similarly to ASP.NET Core MVC layout pages described in the *Reusing
    view code* subsection of *Chapter 15*, *Presenting ASP.NET Core MVC*, the only
    difference being that the place to add the page markup is specified with `@Body`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the Visual Studio template, the default layout page is in the `BlazorReview.Client->Shared->MainLayout.razor`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the application uses authorization, `AuthorizeRouteView` works like `RouteView`,
    but it also allows the specification of a template for a case where the user is
    not authorized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If the user is not authenticated, the `RedirectToLogin` component uses a `NavigationManager`
    instance to move to the login logic page, otherwise, it informs the user they
    haven't got enough privileges to access the selected page.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor WebAssembly also allows assemblies lazy loading to reduce the initial
    application loading time, but we will not discuss it here for lack of space. The
    *Further reading* section contains references to the official Blazor documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor pages and components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn the basics of Blazor components, how to define
    a component, its structure, how to attach events to HTML tags, how to define their
    attributes, and how to use other components inside your components. We have organized
    all content into different subsections. The first subsection describes the basics
    of component structure.
  prefs: []
  type: TYPE_NORMAL
- en: Component structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Components are defined in files with a `.razor` extension. Once compiled, they
    become classes that inherit from `ComponentBase`. Like all other Visual Studio
    project elements, Blazor components are available through the **add new item**
    menu. Usually, components to be used as pages are defined in the `Pages` folder,
    or in its subfolders, while other components are organized in different folders.
    Default Blazor projects add all their non-page components inside the `Shared`
    folder, but you can organize them differently.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, pages are assigned a namespace that corresponds to the path of
    the folder they are in. Thus, for instance, in our example project, all pages
    that are in the `BlazorReview.Client->Pages` path are assigned to the `BlazorReview.Client.Pages`
    namespace. However, you can change this default namespace with an `@namespace`
    declaration placed in the declaration area that is at the top of the file. This
    area may also contain other important declarations. Following is an example that
    shows all declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two directives make sense only for components that must work as pages.
    More specifically, the `@layout` directive overrides the default layout page with
    another component, while the `@page` directive defines the path of the page (**route**)
    within the application base URL. Thus, for instance, if our application runs at
    `https://localhost:5001`, then the URL of the above page will be `https://localhost:5001/counter`.
    Page routes can also contain parameters like in this example: `/orderitem/{customer}/{order}`.
    Parameter names must match public properties defined as parameters by the components.
    The match is case-insensitive, and parameters will be explained later on in this
    subsection.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The string that instantiates each parameter is converted into the parameter
    type and if this conversion fails an exception is thrown. This behavior can be
    prevented by associating a type with each parameter, in which case, if the conversion
    to the specified type fails, the match with the page URL fails. Only elementary
    types are supported: `/orderitem/{customer:int}/{order:int}`. Parameters are obligatory,
    that is, if they are not found, the match fails and the router tries other pages.
    However, you can make a parameter optional by specifying two `@page` directives,
    one with the parameter, and the other without the parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: '`@namespace` overrides the default namespace of the component, while `@using`
    is equivalent to the usual C# `using`. `@using` declared in the special `{project
    folder}->_Imports.razor` folder is automatically applied to all components.'
  prefs: []
  type: TYPE_NORMAL
- en: '`@inherits` declares that the component is a subclass of another component,
    while `@implements` declares it implements an interface.'
  prefs: []
  type: TYPE_NORMAL
- en: '`@typeparam` is used if the component is a generic class, and declares the
    name of the generic parameter, while `@attribute` declares any attribute applied
    to the component class. Property-level attributes are applied directly to properties
    defined in the code area, so they don''t need special notation. The `[Authorize]`
    attribute, applied to a component class used as a page, prevents unauthorized
    users from accessing the page. It works exactly in the same way as when it is
    applied to a controller or to an action method in ASP.NET Core MVC.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `@inject` directive requires a type instance to the dependency
    injection engine and inserts it in the field declared after the type name; in
    the previous example, in the `navigation` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The middle part of the component file contains the HTML that will be rendered
    by the component with Razor markup, enriched with the possible invocation of children
    components.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bottom part of the file is enclosed by an `@code` construct and contains
    fields, properties, and methods of the class that implements the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Public properties decorated with the `[Parameter]` attribute work as component
    parameters; that is, when the component is instantiated into another component,
    they are used to pass values to the decorated properties, like values are passed
    to HTML elements in HTML markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Values can also be passed to component parameters by page route parameters
    that match the property name in a case invariant match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Component parameters can also accept complex types and functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If components are generic, they must be passed type values for each generic
    parameter declared with `typeparam`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: However, often, the compiler is able to infer generic types from the type of
    other parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the code enclosed in the `@code` directive can be also declared in
    a partial class with the same name and namespace as the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Usually, these partial classes are declared in the same folder of the component
    and with a filename equal to the component file name with a `.cs` postfix added.
    Thus, for instance, the partial class associated with the `counter.razor` component
    will be `counter.razor.cs`.
  prefs: []
  type: TYPE_NORMAL
- en: Each component may also have an associated CSS file, whose name must be the
    name of the component file plus the `.css` postfix. Thus, for instance, the CSS
    file associated with the `counter.razor` component will be `counter.razor.css`.
    The CSS contained in this file is applied only to the component and has no effect
    on the remainder of the page. This is called CSS isolation, and at the moment,
    it is implemented by adding a unique attribute to all component HTML roots. Then,
    all selectors of the component CSS file are scoped to this attribute, so that
    they can't affect other HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a component decorates an `IDictionary<string, object>` parameter with
    `[Parameter(CaptureUnmatchedValues = true)]`, then all unmatched parameters inserted
    into the tag, that is, all parameters without a matching component property, are
    added to the `IDictionary` as key-value pairs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This feature furnishes an easy way to forward parameters to HTML elements or
    ­other children components contained in the component markup. For instance, if
    we have a `Detail` component that displays a detail view of the object passed
    in its `Value` parameter, we can use this feature to forward all usual HTML attributes
    to the root HTML tag of the component, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This way, usual HTML attributes added to the component tag such as, for instance,
    class, are forwarded to the root `div` of the components and somehow used to style
    the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The next subsection explains how to pass markup generating functions to components.
  prefs: []
  type: TYPE_NORMAL
- en: Templates and cascading parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Blazor works by building a data structure called a **render tree**, which is
    updated as the UI changes. At each change, Blazor locates the part of the HTML
    that must be rendered and uses the information contained in the **render tree**
    to update it.
  prefs: []
  type: TYPE_NORMAL
- en: The `RenderFragment` delegate defines a function that is able to add further
    markup to a specific position of the **render tree**. There is also a `RenderFragment<T>`
    that accepts a further argument you can use to drive the markup generation. For
    instance, you can pass a `Customer` object to a `RenderFragment<T>` so that it
    can render all the data for that specific customer.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can define a `RenderFragment` or a `RenderFragment<T>` with C# code, but
    the simplest way is to define it in your components with Razor markup. The Razor
    compiler will take care of generating the proper C# code for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The information on the location to add the markup is passed in the `RenderTreeBuilder`
    argument it receives as an argument. You can use a `RenderFragment` in your component
    Razor markup by simply invoking it as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The position where you invoke the `RenderFragment` defines the location where
    it will add its markup, since the component compiler is able to generate the right
    `RenderTreeBuilder` argument to pass to it. `RenderFragment<T>` delegates are
    invoked as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Being functions, render fragments can be passed to component parameters like
    all other types. However, Blazor has a specific syntax to make it easier to simultaneously
    define and pass render fragments to components, the **template** syntax. First,
    you define the parameters in your component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, when you call the customer, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Each render fragment parameter is represented by a tag with the same name as
    the parameter. You can place the markup that defines the render fragment inside
    of it. For the `CustomerTemplate` that has a parameter, the `Context` keyword
    defines the parameter name inside the markup. In our example, the chosen parameter
    name is `customer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a component has just one render fragment parameter, if it is named `ChildContent`,
    the template markup can be enclosed directly between the open and end tag of the
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In order to familiarize ourselves with component templates, let's modify the
    `Pages->FetchData.razor` page so that, instead of using a `foreach`, it uses a
    `Repeater` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s right-click on the `Shared` folder, select **Add**, then **Razor Component**,
    and add a new **Repeater.razor** component. Then, replace the existing code with
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The component is defined with a generic parameter so that it can be used with
    any `IEnumerable`. Now let''s replace the markup in the `tbody` of the **FetchData.razor**
    component with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Since the `Repeater` component has just one template, and since we named it
    `ChildContent`, we can place our template markup directly within the component
    open and close tags. Run it and verify that the page works properly. You have
    learned how to use templates, and that markup placed inside a component defines
    a template.
  prefs: []
  type: TYPE_NORMAL
- en: 'An important predefined templated Blazor component is the `CascadingValue`
    component. It renders the content placed inside of it with no changes, but passes
    a type instance to all its descendant components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'All components placed inside of the `CascadingValue` tag and all their descendant
    components can now capture the instance of `MyOptionsInstance` passed in the `CascadingValueValue`
    parameter. It is enough that the component declares a public or private property
    with a type that is compatible with `MyOptionsInstance` and that decorates it
    with the `CascadingParameter` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Matching is performed by type compatibility. In case of ambiguity with other
    cascaded parameters with a compatible type, we can specify the `Name` optional
    parameter of the `CascadingValue` component and pass the same name to the `CascadingParameter`
    attribute: `[CascadingParameter("myUnique name")]`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `CascadingValue` tag also has an `IsFixed` parameter that should be set
    to `true` whenever possible for performance reasons. In fact, propagating cascading
    values is very useful for passing options and settings, but it has a very high
    computational cost.
  prefs: []
  type: TYPE_NORMAL
- en: When `IsFixed` is set to `true`, propagation is performed just once, the first
    time that each piece of involved content is rendered, and then no attempt is made
    to update the cascaded value during the content's lifetime. Thus, `IsFixed` can
    be used whenever the pointer of the cascaded object is not changed during the
    content's lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: An example of a cascading value is the `CascadingAuthenticationState` component
    we encountered in the *Routing* subsection, which cascades authentications and
    authorization information to all rendered components.
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Both HTML tags and Blazor components use attributes/parameters to get input.
    HTML tags provide output to the remainder of the page through events, and Blazor
    allows C# functions to be attached to HTML `on{event name}` attributes. The syntax
    is shown in the `Pages->Counter.razor` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The function can also be passed inline as a lambda. Moreover, it accepts the
    C# equivalent of the usual `event` argument. The *Further reading* section contains
    a link to the Blazor official documentation page that lists all supported events
    and their arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Blazor also allows events in components, so they can return output, too. Component
    events are parameters whose type is either `EventCallBack` or `EventCallBack<T>`.
    `EventCallBack` is the type of component event with no arguments while `EventCallBack<T>`
    is the type of component event with an argument of type `T`. In order to trigger
    an event, say `MyEvent`, the component calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: These calls execute the handlers bound to the events or do nothing if no handler
    has been bound.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once defined, component events can be used exactly in the same way as HTML
    element events, the only difference being that there is no need to prefix the
    event name with an `@`, since `@` in HTML events is needed to distinguish between
    the HTML attribute and the Blazor-added parameter with the same name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Actually, HTML element events are also `EventCallBack<T>`, that is why both
    event types behave in exactly the same way. `EventCallBack` and `EventCallBack<T>`
    are structs, not delegates, since they contain a delegate, together with a pointer
    to the entity that must be notified that the event has been triggered. Formally,
    this entity is represented by a `Microsoft.AspNetCore.Components.IHandleEvent`
    interface. Needless to say, all components implement this interface. The notification
    informs `IHandleEvent` that a state change took place. State changes play a fundamental
    role in the way Blazor updates the page HTML. We will analyze them in detail in
    the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: 'For HTML elements, Blazor also provides the possibility to stop the event''s
    default action and the event bubbling by adding the `:preventDefault` and `:stopPropagation`
    directives to the attribute that specifies the event, like in these examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Bindings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often a component parameter value must be kept synchronized with an external
    variable, property, or field. The typical application of this kind of synchronization
    is an object property being edited in an input component or HTML tag. Whenever
    the user changes the input value, the object property must be updated coherently,
    and vice versa. The object property value must be copied into the component as
    soon as the component is rendered so that the user can edit it.
  prefs: []
  type: TYPE_NORMAL
- en: Similar scenarios are handled by parameter-event pairs. More specifically, from
    one side, the property is copied in the input component parameter. From the other
    side, each time the input changes value, a component event that updates the property
    is triggered. This way, property and input values are kept synchronized.
  prefs: []
  type: TYPE_NORMAL
- en: This scenario is so common and useful that Blazor has a specific syntax for
    simultaneously defining the event and the copying of the property value into the
    parameter. This simplified syntax requires that the event has the same name as
    the parameter involved in the interaction but with a `Changed` postfix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose, for instance, that a component has a `Value` parameter. Then the corresponding
    event must be `ValueChanged`. Moreover, each time the user changes the component
    value, the component must invoke the `ValueChanged` event by calling `await ValueChanged.InvokeAsync(arg)`.
    With this in place, a property `MyObject.MyProperty` can be synchronized with
    the `Value` property with the syntax shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding syntax is called **binding**. Blazor takes care of automatically
    attaching an event handler that updated the `MyObject.MyProperty` property to
    the `ValueChanged` event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bindings of HTML elements work in a similar way, but since the developer can''t
    decide the names of parameters and events, a slightly different convention must
    be used. First of all, there is no need to specify the parameter name in the binding,
    since it is always the HTML input `value` attribute. Therefore, the binding is
    written simply as `@bind="object.MyProperty"`. By default, the object property
    is updated on the `change` event, but you can specify a different event by adding
    the `@bind-event: @bind-event="oninput"` attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, bindings of HTML inputs try to automatically convert the input string
    into the target type. If the conversion fails, the input reverts to its initial
    value. This behavior is quite primitive since, in the event of errors, no error
    message is provided to the user, and the culture settings are not taken into account
    properly (HTML5 inputs use invariant culture but text input must use the current
    culture). We advise binding inputs only to string target types. Blazor has specific
    components for handling dates and numbers that should be used whenever the target
    type is not a string. We will describe them in the *Blazor forms and validation*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to familiarize ourselves with events, let''s write a component that
    synchronizes the content of an input type text when the user clicks a confirmation
    button. Let''s right-click on the `Shared` folder and add a new **ConfirmedText.razor**
    component. Then replace its code with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `ConfirmedText` component exploits the button-click event to trigger the
    `ValueChanged` event. Moreover, the component itself uses `@bind` to synchronize
    its `Value` parameter with the HTML input. It is worth pointing out that the component
    uses `CaptureUnmatchedValues` to forward all HTML attributes applied to its tag
    to the HTML input. This way, users of the `ConfirmedText` component can style
    the input field by simply adding `class` and/or `style` attributes to the component
    tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s use this component in the `Pages->Index.razor` page by placing the
    following code at the end of `Index.razor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If you run the project and play with the input and its **Confirm** button, you
    will see that each time the **Confirm** button is clicked, not only are the input
    values copied in the `textValue` page property but also the content of the paragraph
    that is behind the component is coherently updated.
  prefs: []
  type: TYPE_NORMAL
- en: We explicitly synchronized `textValue` with the component with `@bind-Value`,
    but who takes care of keeping `textValue` synchronized with the content of the
    paragraph? The answer is in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: How Blazor updates HTML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we write the content of a variable, property, or field in Razor markup
    with something like `@model.property`, Blazor, not only renders the actual value
    of the variable, property, or field when the component is rendered but tries also
    to update the HTML each time that this value changes, with a process called **change
    detection**. Change detection is a feature of all main SPA frameworks, but the
    way Blazor implements it is very simple and elegant.
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea is that, once all HTML has been rendered, changes may occur only
    because of code executed inside of events. That is why `EventCallBack` and `EventCallBack<T>`
    contain a reference to an `IHandleEvent`. When a component binds a handler to
    an event, the Razor compiler creates an `EventCallBack`or`EventCallBack<T>` passing
    in its `struct` constructor the function bound to the event, and the component
    where the function was defined (`IHandleEvent`).
  prefs: []
  type: TYPE_NORMAL
- en: Once the code of the handler has been executed, the Blazor runtime is notified
    that the `IHandleEvent` might have changed. In fact, the handler code can only
    change the values of variables, properties, or fields of the component where the
    handler was defined. In turn, this triggers a change detection rooted in the component.
    Blazor verifies which variables, properties, or fields used in the component Razor
    markup changed and updates the associated HTML.
  prefs: []
  type: TYPE_NORMAL
- en: If a changed variable, property, or field is an input parameter of another component,
    then, the HTML generated by that component might also need updates. Accordingly,
    another change-detection process rooted in that component is recursively triggered.
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm sketched previously discovers all relevant changes only if the
    following conditions listed are met:'
  prefs: []
  type: TYPE_NORMAL
- en: No component references data structures belonging to other components in an
    event handler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All inputs to a component arrive through its parameters and not through method
    calls or other public members.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When there is a change that is not detected because of the failure of one of
    the preceding conditions, the developer must manually declare the possible change
    of the component. This can be done by calling the `StateHasChanged()` component
    method. Since this call might result in changes to the page HTML, its execution
    cannot take place asynchronously but must be queued in the HTML page UI thread.
    This is done by passing the function to be executed to the `InvokeAsync` component
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Summing up, the instruction to execute is `await InvokeAsync(StateHasChanged)`.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection concludes the description of components with an analysis
    of their lifecycle and of the associated lifecycle methods.
  prefs: []
  type: TYPE_NORMAL
- en: Component lifecycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each component lifecycle event has an associated method. Some methods have both
    synchronous and asynchronous versions, some have just an asynchronous version,
    and some others have just a synchronous version.
  prefs: []
  type: TYPE_NORMAL
- en: 'The component lifecycle starts with parameters passed to the component being
    copied in the associated component properties. You can customize this step by
    overriding the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Typically, customization consists of the modification of additional data structures,
    so the base method is called to also perform the default action of copying parameters
    in the associated properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, there is the component initialization that is associated with the
    two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: They are called once in the component lifetime, immediately after the component
    has been created and added to the render tree. Please place any initialization
    code there, and not in the component constructor because this will improve component
    testability, because, there, you have all parameters set, and because future Blazor
    versions might pool and reuse component instances.
  prefs: []
  type: TYPE_NORMAL
- en: If the initialization code subscribes to some events or performs actions that
    need a cleanup when the component is destroyed, implement `IDisposable`, and place
    all cleanup code in its `Dispose` method. In fact, whenever a component implements
    `IDisposable`, Blazor calls its `Dispose` method before destroying it.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the component has been initialized and each time a component parameter
    changes, the following two methods are called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: They are the right place to update data structures that depend on the values
    of the component parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, the component is rendered or re-rendered. You can prevent component
    re-rendering after an update by overriding the `ShouldRender` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Letting a component re-render only if you are sure its HTML code will change
    is an advanced optimization technique used in the implementation of component
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'The component rendering stage also involves the invocation of its children
    components. Therefore, component rendering is considered complete only after all
    its descendant components have completed their rendering, too. When rendering
    is complete, the following methods are called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Since when the preceding methods are called, all component HTML has been updated
    and all children components have executed all their lifetime methods, the preceding
    methods are the right places for performing the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Calling JavaScript functions that manipulate the generated HTML. JavaScript
    calls are described in the *JavaScript interoperability* subsection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing information attached to parameters or cascaded parameters by descendant
    components. In fact, Tabs-like components and other components might have the
    need to register some of their subparts in the root component, so the root component
    typically cascades a data structure where some children components can register.
    Code written in `AfterRender` and `AfterRenderAsync` can rely on the fact that
    all subparts have completed their registration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next section describes Blazor tools for collecting user input.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor forms and validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to all major SPA frameworks, Blazor also offers specific tools for processing
    user input while providing valid feedback to the user with error messages and
    immediate visual clues. The whole toolset is known as **Blazor Forms** and consists
    of a form component called `EditForm`, various input components, a data annotation
    validator, a validation error summary, and validation error labels.
  prefs: []
  type: TYPE_NORMAL
- en: '`EditForm` takes care of orchestrating the state of all input components, through
    an instance of the `EditContext` class that is cascaded inside of the form. The
    orchestration comes from the interaction of both input components and the data
    annotation validator with this `EditContext` instance. A validation summary and
    error message labels don''t take part in the orchestration but register to some
    `EditContext` events to be informed about errors.'
  prefs: []
  type: TYPE_NORMAL
- en: '`EditForm` must be passed the object whose properties must be rendered in its
    `Model` parameter. It is worth pointing out that input components bound to nested
    properties are not validated, so `EditForm` must be passed a flattened ViewModel.
    `EditForm` creates a new `EditContext` instance, passes the object received in
    its `Model` parameter in its constructor, and cascades it so it can interact with
    the form content.'
  prefs: []
  type: TYPE_NORMAL
- en: You can also directly pass an `EditContext` custom instance in the `EditContext`
    parameter of `EditForm` instead of passing the object in its `Model` parameter,
    in which case `EditForm` will use your custom copy instead of creating a new instance.
    Typically, you do this when you need to subscribe to the `EditContextOnValidationStateChanged`
    and `OnFieldChanged` events.
  prefs: []
  type: TYPE_NORMAL
- en: When `EditForm` is submitted with a **Submit** button and there are no errors,
    the form invokes its `OnValidSubmit` callback, where you can place the code that
    uses and processes the user input. If instead, there are validation errors, they
    are shown, and the form invokes its `OnInvalidSubmit` callback.
  prefs: []
  type: TYPE_NORMAL
- en: 'The state of each input is reflected in some CSS classes that are automatically
    added to them, namely: `valid`, `invalid`, and `modified`. You can use these classes
    to furnish adequate visual feedback to the user. The default Blazor Visual Studio
    template already furnishes some CSS for them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is a typical form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The label is a standard HTML label, while `InputNumber` is a Blazor-specific
    component for number properties. `ValidationMessage` is the error label that appears
    only in the event of a validation error. As a default, it is rendered with a `validation-message`
    CSS class. The property associated with the error message is passed in the `for`
    parameter with a parameterless lambda as shown in the example.
  prefs: []
  type: TYPE_NORMAL
- en: The `DataAnnotationsValidator` component adds a validation based on the usual
    .NET validation attributes, such as `RangeAttribute`, `RequiredAttribute`, and
    so on. You can also write your custom validation attributes by inheriting from
    the `ValidationAttribute` class.
  prefs: []
  type: TYPE_NORMAL
- en: You can provide custom error messages in the validation attributes. If they
    contain a `{0}` placeholder, this will be filled with the property display name
    declared in a `DisplayAttribute`, if one is found, otherwise with the property
    name.
  prefs: []
  type: TYPE_NORMAL
- en: Together with the `InputNumber` component, Blazor also supports an `InputText`
    component for `string` properties, an `InputTextArea` component for `string` properties
    to be edited in an HTML `textarea`, an `InputCheckbox` component for `bool` properties,
    and an `InputDate` component that renders `DateTime` and `DateTimeOffset` as dates.
    They all work in exactly the same way as the `InputNumber` component. No component
    is available for other HTML5 input types. In particular, no component is available
    for rendering time or date and time, or for rendering numbers with a `range` widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can implement rendering time or date and time by inheriting from the `InputBase<TValue>`
    class and overriding the `BuildRenderTree`, `FormatValueAsString`, and `TryParseValueFromString`
    methods. The sources of the `InputNumber` component show how to do it: [https://github.com/dotnet/aspnetcore/blob/15f341f8ee556fa0c2825cdddfe59a88b35a87e2/src/Components/Web/src/Forms/InputNumber.cs](https://github.com/dotnet/aspnetcore/blob/15f341f8ee556fa0c2825cdddfe59a88b35a87e2/src/Components/We).
    You can also use the third-party libraries described in the *Third-party tools
    for Blazor WebAssembly* section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Blazor also has a specific component for rendering a `select`, which works
    as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also render enumerations with a radio group thanks to the `InputRadioGroup`
    and `InputRadio` components, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Finally, Blazor also offers an `InputFile` component together with all the tools
    for processing and uploading the file. We will not cover this here, but the *Further
    reading* section contains links to the official documentation.
  prefs: []
  type: TYPE_NORMAL
- en: This subsection finishes the description of Blazor basics; the next section
    analyzes some advanced features.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor advanced features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section collects short descriptions of various Blazor advanced features
    organized in subsections. For lack of space, we can't give all the details of
    each feature, but the lacking details are covered by links in the *Further reading*
    section. We start with how to reference components and HTML elements defined in
    Razor markup.
  prefs: []
  type: TYPE_NORMAL
- en: References to components and HTML elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes we might need a reference to a component in order to call some of
    its methods. This is the case, for instance, for a component that implements a
    modal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As the preceding example shows, references are captured with the `@ref` directive.
    The same `@ref` directive can also be used to capture references to HTML elements.
    HTML references have an `ElementReference` type and are typically used to call
    JavaScript functions on HTML elements, as explained in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript interoperability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since Blazor doesn't expose all JavaScript features to C# code, and since it
    is convenient to take advantage of the huge JavaScript code base available, sometimes
    it is necessary to invoke JavaScript functions. Blazor allows this through the
    `IJSRuntime` interface that can be injected into a component via dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once one has an `IJSRuntime` instance, a JavaScript function that returns a
    value can be called as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions that do not return any argument can be invoked as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Arguments can be either basic types or objects that can be serialized in JSON,
    while the name of the JavaScript function is a string that can contain dots that
    represent access to properties, sub-properties, and method names, like, for instance,
    the `"myJavaScriptObject.myProperty.myMethod"` string.
  prefs: []
  type: TYPE_NORMAL
- en: Arguments can also be `ElementReference` instances captured with the `@ref`
    directive, in which case they are received as HTML elements on the JavaScript
    side.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript functions invoked must be defined either in the `Index.html`
    file or in JavaScript files referenced in `Index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are writing a component library with a Razor library project, JavaScript
    files can be embedded together with CSS files as resources in the DLL library.
    It is enough to add a `wwwroot` folder in the project root and to place the needed
    CSS and JavaScript files in that folder or in some subfolder of it. After that,
    these files can be referenced as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Accordingly, if the filename is `myJsFile.js`, the dll name is `MyCompany.MyLibrary`,
    and the file is placed in the `js` folder inside `wwwroot`, then its reference
    will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If your JavaScript files are organized as ES6 modules, you can avoid referencing
    them in `Index.html`, and can load the modules directly as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, instance methods of C# objects can be called from JavaScript code,
    taking the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Say the C# method is called `MyMethod`. Decorate the `MyMethod` method with
    the `[JSInvokable]` attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enclose the C# object in a `DotNetObjectReference` instance and pass it to
    JavaScript with a JavaScript call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'On the JavaScript side, say the C# object is in a variable called `dotnetObject`.
    Then it is enough to invoke:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The next section explains how to handle contents and number/date localization.
  prefs: []
  type: TYPE_NORMAL
- en: Globalization and localization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As soon as the Blazor application starts, both the application culture and the
    application UI culture are set to the browser culture. However, the developer
    can change both of them by assigning the chosen cultures to `CultureInfo.DefaultThreadCurrentCulture`
    and `CultureInfo.DefaultThreadCurrentUICulture`. Typically, the application lets
    the user choose one of its supported cultures, or it accepts the browser culture
    only if it is supported, otherwise, it falls back to a supported culture. In fact,
    it is possible to support just a reasonable number of cultures because all application
    strings must be translated in all supported cultures.
  prefs: []
  type: TYPE_NORMAL
- en: Once the `CurrentCulture` is set, dates and numbers are automatically formatted
    according to the conventions of the chosen culture. For the UI culture, the developer
    must manually provide resource files with the translations of all application
    strings in all supported cultures.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to use resource files. With the first option, you create
    a resource file, say, `myResource.resx`, and then add all language-specific files:
    `myResource.it.resx`, `myResource.pt.resx`, and so on. In this case, Visual Studio
    creates a static class named `myResource` whose static properties are the keys
    of each resource file. These properties will automatically contain the localized
    strings corresponding to the current UI culture. You can use these static properties
    wherever you like, and you can use pairs composed of a resource type and a resource
    name to set the `ErrorMessageResourceType` and the `ErrorMessageResourceName`
    properties of validation attributes or similar properties of other attributes.
    This way, the attributes will use an automatically localized string.'
  prefs: []
  type: TYPE_NORMAL
- en: With the second option, you add only language-specific resource files (`myResource.it.resx`,
    `myResource.pt.resx`, and so on). In this case, Visual Studio doesn't create any
    class associated with the resource file, and you can use resource files together
    with `IStringLocalizer` and `IStringLocalizer<T>` injected in components as you
    use them in ASP.NET Core MVC views (see the *ASP.NET Core globalization* section
    of *Chapter 15*, *Presenting ASP.NET Core MVC*).
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and authorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Routing* subsection, we sketched how the `CascadingAuthenticationState`
    and `AuthorizeRouteView` components prevent unauthorized users from accessing
    pages protected with an `[Authorize]` attribute. Let's go deeper into the details
    of how page authorization works.
  prefs: []
  type: TYPE_NORMAL
- en: In .NET applications, authentication and authorization information is usually
    contained in a `ClaimsPrincipal` instance. In server applications, this instance
    is built when the user logs in, taking the required information from a database.
    In Blazor WebAssembly, such information must be provided by some remote server
    that takes care of SPA authentication, too. Since there are several ways to provide
    authentication and authorization to a Blazor WebAssembly application, Blazor defines
    the `AuthenticationStateProvider` abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and authorization providers inherit from the `AuthenticationStateProvider`
    abstract class and override its `GetAuthenticationStateAsync` method, which returns
    a `Task<AuthenticationState>`, where the `AuthenticationState` contains the authentication
    and authorization information. Actually, `AuthenticationState` contains just a
    `User` property with a `ClaimsPrincipal`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve defined a concrete implementation of `AuthenticationStateProvider`,
    we must register it in the dependency engine container in the application `program.cs`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We will return to the predefined implementations of `AuthenticationStateProvider`
    offered by Blazor after having described how Blazor uses authentication and authorization
    information furnished by a registered `AuthenticationStateProvider`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CascadingAuthenticationState` component calls the `GetAuthenticationStateAsync`
    method of the registered `AuthenticationStateProvider` and cascades the returned
    `Task<AuthenticationState>`. You can intercept this cascading value with a `[CascadingParameter]`
    defined as follows in your components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: However, Blazor applications typically use `AuthorizeRouteView` and `AuthorizeView`
    components to control user access to content.
  prefs: []
  type: TYPE_NORMAL
- en: '`AuthorizeRouteView` prevents access to pages if the user doesn''t satisfy
    the prescriptions of the page `[Authorize]` attribute, otherwise, the content
    in the `NotAuthorized` template is rendered. `AuthorizeRouteView` also has an
    `Authorizing` template that is shown while user information is being retrieved.'
  prefs: []
  type: TYPE_NORMAL
- en: '`AuthorizeView` can be used within components to show the markup it encloses
    only to authorized users. It contains the same `Roles` and `Policy` parameters
    of the `[Authorize]` attribute that you can use to specify the constraints the
    user must satisfy to access the content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '`AuthorizeView` can also specify `NotAuthorized` and an `Authorizing` template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'If one adds authorization while creating a Blazor WebAssembly project, the
    following method call is added to the application dependency engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This method adds an `AuthenticationStateProvider` that extracts the user information
    from the usual ASP.NET Core authentication cookie. Since authentication cookies
    are encrypted, this operation must be performed by contacting an endpoint exposed
    by the server. The operation is performed with the help of the `AuthenticationService.js`
    JavaScript file we saw in the *Loading and starting the application* subsection
    of this chapter. The server endpoint returns user information in the form of a
    bearer token that can be used also to authenticate communications with the server's
    WEB API. Bearer tokens are described in detail in the *REST services authorization
    and authentication* and *ASP.NET Core service authorization* sections of *Chapter
    14*, *Applying Service-Oriented Architectures with .NET Core*. Blazor WebAssembly
    communication is described in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: 'If no valid authentication cookie is found, the provider creates an unauthenticated
    `ClaimsPrincipal`. This way, when the user tries to access a page that is protected
    by an `[Authorize]` attribute, the `AuthorizeRouteView` component invokes the
    `RedirectToLogin` component, which, in turn, navigates to the `Authentication.razor`
    page, passing it a login request in its `action` route parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The `RemoteAuthenticatorView` acts as an interface with the usual ASP.NET Core
    user login/registration system, and whenever it receives an "action" to perform
    redirects the user from the Blazor application to the proper ASP.NET Core server
    page (login, registration, logout, user profile).
  prefs: []
  type: TYPE_NORMAL
- en: All information needed to communicate with the server is based on name conventions,
    but they can be customized with the `options` argument of the `AddApiAuthorization`
    method. There, for instance, you can change the URL where the user can register,
    and also the address of the endpoint contacted by Blazor to collect information
    on the server settings. This endpoint is in the `BlazorReview.Server->Controller->OidcConfigurationController.cs`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Once the user logs in, they are redirected to the Blazor application page that
    caused the login request. The redirect URL is computed by the `BlazorReview.Client->Shared->RedirectToLogin.razor`
    component, which extracts it from the `NavigationManager` and passes it to the
    `RemoteAuthenticatorView` component. This time, the `AuthenticationStateProvider`
    is able to get the user information from the authentication cookie that has been
    created by the login operation.
  prefs: []
  type: TYPE_NORMAL
- en: More details on the authentication process are available in the official documentation
    reference in the *Further reading* section
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection describes a Blazor WebAssembly-specific implementation of
    the `HttpClient` class and related types.
  prefs: []
  type: TYPE_NORMAL
- en: Communication with the server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Blazor WebAssembly supports the same .NET `HttpClient` and `HttpClientFactory`
    classes described in the *.NET Core HTTP clients* section of *Chapter 14*, *Applying
    Service-Oriented Architectures with .NET Core*. However, due to the communication
    limitations of browsers, their implementations are different and rely on the browser
    **fetch API**.
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 14*, *Applying Service-Oriented Architectures with .NET Core*, we
    analyzed how to take advantage of `HttpClientFactory` to define typed clients.
    You can also define typed clients in Blazor with exactly the same syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, since Blazor needs to send the bearer token created during the authentication
    process in each request to the application server, it is common to define a named
    client as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '`AddHttpMessageHandler` adds a `DelegatingHandler`, that is, a subclass of
    the `DelegatingHandler` abstract class. Implementations of `DelegatingHandler`
    override its `SendAsync` method in order to process each request and each relative
    response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '`BaseAddressAuthorizationMessageHandler` is added to the dependency injection
    engine by the `AddApiAuthorization` call we saw in the previous section. It adds
    the bearer token produced by the authorization process to each request addressed
    to the application server domain. If either this bearer token is expired or is
    not found at all, it tries to get a new bearer token from the user authentication
    cookie. If this attempt also fails, an `AccessTokenNotAvailableException` is thrown.
    Typically, similar exceptions are captured and trigger a redirection to the login
    page (as the default, to `/authentication/{action}`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Since most requests are directed to the application server, and just a few
    calls might contact other servers with CORS, the `BlazorReview.ServerAPI` named
    `client` is also defined to be the default `HttpClient` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The default client can be obtained by requiring an `HttpClient` instance to
    the dependency injection engine. CORS requests to other servers can be handled
    by defining other named clients that use other bearer tokens. One can get a named
    client by first getting an `IHttpClientFactory` instance from dependency injection,
    and then calling its `CreateClient("<named client name>")` method. Blazor offers
    packages for getting bearer tokens and connecting with well-known services. They
    are described in the authorization documentation referenced in the *Further reading*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: The next section briefly discusses some of the most relevant third-party tools
    and libraries that complete Blazor's official features, and help increase productivity
    in Blazor projects.
  prefs: []
  type: TYPE_NORMAL
- en: Third-party tools for Blazor WebAssembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Notwithstanding Blazor is a young product, its third-party tool and product
    ecosystem is already quite rich. Among the open source, free products, it is worth
    mentioning the **Blazorise** project ([https://github.com/stsrki/Blazorise](https://github.com/stsrki/Blazorise)),
    which contains various free basic Blazor components (inputs, tabs, modals, and
    so on) that can be styled with various CSS frameworks, such as Bootstrap and Material.
    It also contains a simple editable grid and a simple tree view.
  prefs: []
  type: TYPE_NORMAL
- en: Also worth mentioning is **BlazorStrap** ([https://github.com/chanan/BlazorStrap](https://github.com/chanan/BlazorStrap)),
    which contains pure Blazor implementations of all Bootstrap 4 components and widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Among all the commercial products, it is worth mentioning **Blazor Controls
    Toolkit** ([http://blazor.mvc-controls.com/](http://blazor.mvc-controls.com/)),
    which is a complete toolset for implementing commercial applications. It contains
    all input types with their fallbacks in case they are not supported by the browser;
    all Bootstrap components; other basic components; and a complete, advanced drag-and-drop
    framework; advanced customizable and editable components, like detail views, detail
    lists, grids, a tree-repeater (a generalization of the tree-view). All components
    are based on a sophisticated metadata representation system that enables the user
    to design the markup in a declarative way using data annotations and inline Razor
    declarations.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, it contains additional sophisticated validation attributes, tools
    for undoing user input, tools for computing changes to send to the server, sophisticated
    client-side and server-side query tools based on the OData protocol, and tools
    to maintain and save the whole application state.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth also mentioning the **bUnit** open source project ([https://github.com/egil/bUnit](https://github.com/egil/bUnit)),
    which furnishes all tools for testing Blazor components.
  prefs: []
  type: TYPE_NORMAL
- en: The next section shows how to put into practice what you have learned by implementing
    a simple application.
  prefs: []
  type: TYPE_NORMAL
- en: Use case – implementing a simple application in Blazor WebAssembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will implement a package search application for the *WWTravelClub*
    book use case. The first subsection explains how to set up the solution exploiting
    the domain layer and data layer we already implemented in *Chapter 15*, *Presenting*
    *ASP.NET* *Core MVC*.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all, create a copy of the **PackagesManagement** solution folder we
    created in *Chapter 15*, *Presenting ASP.NET Core MVC*, and rename it **PackagesManagementBlazor**.
  prefs: []
  type: TYPE_NORMAL
- en: Open the solution, right-click on the Web project (the one named **PackagesManagement**)
    and remove it. Then, go to the solution folder and delete the whole Web project
    folder (the one named **PackagesManagement**).
  prefs: []
  type: TYPE_NORMAL
- en: Now right-click on the solution and select **Add New project**. Add a new Blazor
    WebAssembly project called **PackagesManagementBlazor**. Select **no authentication**
    and **ASP.NET Core hosted**. We don't need authentication since the search-by-location
    feature we are going to implement must also be available to unregistered users.
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that the **PackagesManagementBlazor.Server** project is the start project
    (its name should be in bold). If it is not, right-click on it and click on **Set
    as Start Project**.
  prefs: []
  type: TYPE_NORMAL
- en: The server project needs to reference both the data (**PackagesManagementDB**)
    and the domain (**PackagesManagementDomain**) projects, so please add them as
    references.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also copy the same connection string of the old web project into the
    `PackagesManagementBlazor.Serverappsettings.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This way, we can reuse the database we already created. We also need to add
    the same DDD tools we added to the old web project. Add a folder named `Tools`
    in the project root and copy the content of the `ch12->ApplicationLayer` folder
    of the GitHub repository associated with the book there.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to finish the solution setup, we just need to connect **PackagesManagementBlazor.Server**
    with the domain layer by adding the following code at the end of the `ConfigureServices`
    method in the `Startup.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'It is the same method we added to the old Web project. Finally, we can also
    add the `AddAllQueries` extension method, which discovers all queries in the Web
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We don't need other automatic discovery tools since this is a query-only application.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection explains how to design the server-side REST API.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the required ASP.NET Core REST APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the first step, let's define the ViewModels used in the communication between
    the server and the client applications. They must be defined in the **PackagesManagementBlazor.Shared**
    project that is referenced by both applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the `PackageInfosViewModel` ViewModel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add also the ViewModel that encloses all packages to return to the Blazor
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can also add our query that searches packages by location. Let''s add
    a `Queries` folder in the root of the **PackagesManagementBlazor.Server** project,
    and then add the interface that defines our query, `IPackagesListByLocationQuery`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s also add the query implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'We are finally ready to define our `PackagesController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The server-side code is finished! Let's move on to the definition of the Blazor
    service that communicates with the server.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the business logic in a service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s add a `ViewModels` and a `Services` folder to the **PackagesManagementBlazor.Client**
    project. Most of the ViewModels we need were already defined in the **PackagesManagementBlazor.Shared**
    project. We only need a ViewModel for the search form. Let''s add it to the `ViewModels`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s call our service `PackagesClient`, and let''s add it to the `Services`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The code is straightforward! The `Uri.EscapeDataString` method url-encodes the
    parameter so it can be safely appended to the URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s register the service in the dependency injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: It is worth pointing out that in a commercial application, we should have registered
    the service through an `IPackagesClient` interface, in order to be able to mock
    it in the tests (`.AddScoped<IPackagesClient, PackagesClient>()`).
  prefs: []
  type: TYPE_NORMAL
- en: Everything is in place; we just need to build the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the user interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the first step, let's delete application pages we don't need, namely, `Pages->Counter.razor`
    and `Pages->FetchData.razor`. Let's also remove their links from the side menu
    in `Shared->NavMenu.razor`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will put our code in the `Pages->Index.razor` page. Let''s replace the code
    of this page with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code adds the needed `@using`, injects our `PackagesClient` service
    in the page, and defines the search form. When the form is successfully submitted,
    it invokes the `Search` callback where we will place the code that retrieves all
    the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is time to add the logic to display all the results and to complete the
    `@code` block. The following code must be placed immediately after the search
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The omitted code in the `if` block is responsible for rendering a table with
    all the results. We will show it after having commented the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: Before retrieving the results with the `PackagesClient` service, we remove all
    previous results and set the `loading` field, so the Razor code selects the `else
    if` path that replaces the previous table with a loading message. Once we've set
    these variables, we are forced to call `StateHasChanged` to trigger change detection
    and to refresh the page. After all the results have been retrieved and the callback
    returns, there is no need to call `StateHasChanged` again because the termination
    of the callback itself triggers change detection and causes the required page
    refresh.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the code that renders the table with all the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Run the project and write the initial characters of Florence. Since in previous
    chapters, we inserted Florence as a location in the database, some results should
    appear!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned what a SPA is and learned how to build a SPA based
    on the Blazor WebAssembly framework. The first part of the chapter described Blazor
    WebAssembly architecture, and then the chapter explained how to exchange input/output
    with Blazor components, and the concept of binding.
  prefs: []
  type: TYPE_NORMAL
- en: After having explained Blazor's general principles, the chapter focused on how
    to get user input while furnishing the user with adequate feedback and visual
    clues in the event of errors. Then, the chapter furnished a short description
    of advanced features, such as JavaScript interoperability, globalization, authentication
    with authorization, and client-server communication.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a practical example taken from the book user case shows how to use
    Blazor in practice to implement a simple touristic package search application.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is WebAssembly?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an SPA?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the Blazor `router` component?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a Blazor page?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the `@namespace` directive?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an `EditContext`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the right place to initialize a component?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the right place to process the user input?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the `IJSRuntime` interface?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of `@ref`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Blazor official documentation is available at: [https://docs.microsoft.com/en-US/aspnet/core/blazor/webassembly-lazy-load-assemblies](https://docs.microsoft.com/en-US/aspnet/core/blazor/webassembly-lazy-load-assemblies).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Assemblies'' lazy loading is described at: [https://docs.microsoft.com/en-US/aspnet/core/blazor/webassembly-lazy-load-assemblies](https://docs.microsoft.com/en-US/aspnet/core/blazor/webassembly-lazy-load-assemblies).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All HTML events supported by Blazor together with their event arguments are
    listed at: [https://docs.microsoft.com/en-US/aspnet/core/blazor/components/event-handling?#event-argument-types](https://docs.microsoft.com/en-US/aspnet/core/blazor/components/event-handling?#event-argument-types).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Blazor supports the same validation attributes as ASP.NET MVC, with the exception
    of the `RemoteAttribute`: [https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation#built-in-attributes](https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation#built-in-attributes).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A description of the `InputFile` component, and how to use it, can be found
    here: [https://docs.microsoft.com/en-US/aspnet/core/blazor/file-uploads](https://docs.microsoft.com/en-US/aspnet/core/blazor/file-uploads).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More details on Blazor localization and globalization are available here: [https://docs.microsoft.com/en-US/aspnet/core/blazor/globalization-localization](https://docs.microsoft.com/en-US/aspnet/core/blazor/globalization-localization).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More details on Blazor authentication are available here, and on all its related
    URLs: [https://docs.microsoft.com/en-US/aspnet/core/blazor/security/webassembly/](https://docs.microsoft.com/en-US/aspnet/core/blazor/security/webassembly/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
