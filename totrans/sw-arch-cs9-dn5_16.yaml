- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blazor WebAssembly
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to implement a presentation layer with Blazor
    WebAssembly. Blazor WebAssembly applications are C# applications that can run
    in any browser that supports the WebAssembly technology. They can be accessed
    by navigating to a specific URL and are downloaded in the browser as standard
    static content, made of HTML pages and downloadable files.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Blazor applications use many technologies we already analyzed in *Chapter 15*,
    *Presenting ASP.NET Core MVC*, such as dependency injection and Razor. Therefore,
    we strongly recommend studying *Chapter 15*, *Presenting ASP.NET Core MVC*, before
    reading this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'More specifically, in this chapter, you will learn about the following subjects:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Blazor WebAssembly architecture
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blazor pages and components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blazor forms and validation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blazor advanced features, such as globalization, authentication, and JavaScript
    interoperability
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third-party tools for Blazor WebAssembly
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use case: implementing a simple application in Blazor WebAssembly'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While there is also server-side Blazor, which runs on the server like ASP.NET
    Core MVC, this chapter discusses just Blazor WebAssembly, which runs entirely
    in the user's browser, since the main purpose of the chapter is to furnish a relevant
    example of how to implement a presentation layer with client-side technology.
    Moreover, as a server-side technology, Blazor can't furnish a performance that
    is comparable with other server-side technologies like ASP.NET Core MVC, which
    we already analyzed in *Chapter 15*, *Presenting ASP.NET Core MVC*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: The first section gives a sketch of the general Blazor WebAssembly architecture,
    while the remaining sections describe specific features. When needed, concepts
    are clarified by analyzing and modifying the example code that Visual Studio generates
    automatically when one selects the Blazor WebAssembly project template. The last
    section shows how to use all the concepts learned in practice with the implementation
    of a simple application based on the WWTravelClub book use case.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires the free Visual Studio 2019 Community edition or better
    with all database tools installed. All concepts are clarified with a simple example
    application, based on the WWTravelClub book use case. The code for this chapter
    is available at [https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5](https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Blazor WebAssembly architecture
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blazor WebAssembly exploits the new WebAssembly browser feature to execute the
    .NET runtime in the browser. This way, it enables all developers to use the whole
    .NET code base and ecosystem in the implementation of applications capable of
    running in any WebAssembly compliant browser. WebAssembly was conceived as a high-performance
    alternative to JavaScript. It is an assembly capable of running in a browser and
    obeying the same limitations as JavaScript code. This means that WebAssembly code,
    like JavaScript code, runs in an isolated execution environment that has very
    limited access to all machine resources.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly differs from similar options of the past, like Flash and Silverlight,
    since it is an official W3C standard. More specifically, it became an official
    standard on December 5, 2019, so it is expected to have a long life. As a matter
    of fact, all mainstream browsers already support it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: However, WebAssembly doesn't bring just performance with it! It also creates
    the opportunity to run whole code bases associated with modern and advanced object-oriented
    languages such as C++ (direct compilation), Java (bytecode), and C# (.NET) in
    browsers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft advises running .NET code in the browser with the Unity 3D graphic
    framework and Blazor.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Before WebAssembly, presentation layers running in a browser could be implemented
    only in JavaScript, with all the problems implied by the maintenance of big code
    bases the language brings with it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Now, with Blazor we can implement complex applications in the modern and advanced
    C#, with all the comforts offered to this language by the C# compiler and Visual
    Studio.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, with Blazor, all .NET developers can use the full power of the .NET
    framework to implement presentation layers that run in the browser and that share
    libraries and classes with all other layers that run on the server side.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: The subsections that follow describe the overall Blazor architectures. The first
    subsection explores the general concept of a Single-Page Application, pointing
    out Blazor peculiarities.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: What is a Single-Page Application?
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **Single-Page Application** (**SPA**) is an HTML-based application, where
    the HTML is changed by code that runs in the browser itself instead of issuing
    a new request to the server and rendering a new HTML page from scratch. SPAs are
    able to simulate a multi-page experience by replacing complete page areas with
    new HTML.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: SPA frameworks are frameworks explicitly designed for implementing SPAs. Before
    WebAssembly, all SPA frameworks were based on JavaScript. The most famous JavaScript-based
    SPA frameworks are Angular, React.js, and Vue.js.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: All SPA frameworks furnish ways to transform data into HTML to show to the user
    and rely on a module called *router* to simulate page changes. Typically, data
    fills in the placeholders of HTML templates and selects which parts of a template
    to render (if-like constructs), and how many times to render it (for-like constructs).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: The Blazor template language is Razor, which we already described in *Chapter
    15*, *Presenting ASP.NET Core MVC*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: In order to increase modularity, code is organized into components that are
    a kind of virtual HTML tag that, once rendered, generates actual HTML markup.
    Like HTML tags, components have their attributes, which are usually called parameters,
    and their custom events. It is up to the developer to ensure that each component
    uses its parameters to create proper HTML and to ensure that it generates adequate
    events. Components can be used inside other components in a hierarchical fashion.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: The application router performs its job by selecting components, acting as pages,
    and placing them in predefined areas. Each page component has a web address path
    that is somehow associated with it. This path concatenated with the web application
    domain becomes a URL that univocally identifies the page. As in usual web applications,
    page URLs are used to communicate to the router which page to load, either with
    usual links or with routing methods/functions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Some SPA frameworks also furnish a predefined dependency injection engine in
    order to ensure better separation between components from one side and general-purpose
    services plus business code that runs in the browser on the other side. Among
    the frameworks listed in this subsection, only Blazor and Angular have an out-of-the-box
    dependency injection engine.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: SPA frameworks based on JavaScript usually compile all JavaScript code in a
    few JavaScript files and then perform so-called tree-shaking, that is, the removal
    of all unused code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: At the moment, instead, Blazor keeps all DLLs referenced by the main application
    separate, and performs tree-shaking on each of them separately.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection starts to describe the Blazor architecture. You are encouraged
    to create a Blazor WebAssembly project called `BlazorReview`, so you can inspect
    the code and the constructs explained throughout the chapter. Please select **Individual
    User Accounts** as authentication, and **ASP.NET Core hosted**. This way, Visual
    Studio will also create an ASP.NET Core project that communicates with the Blazor
    client application, with all the authentication and authorization logic.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_16_01.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.1: Creating the BlazorReview application'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: If you start the application and try to log in or try to access a page that
    requires login, an error should appear saying database migrations have not been
    applied. It should be enough to click the link next to the message to apply the
    pending migrations. Otherwise, as explained in the *Entity Framework Core migrations*
    section of *Chapter 8*, *Interacting with Data in C# – Entity Framework Core*,
    go to the Visual Studio Package Manager Console and run the `Update-Database`
    command.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启动应用程序并尝试登录或尝试访问需要登录的页面，则应该出现一个错误，指出数据库迁移尚未应用。只需单击消息旁边的链接即可应用待处理的迁移。否则，如*第8章*的*使用C#与数据交互-Entity
    Framework Core*部分中所解释的那样，转到Visual Studio包管理器控制台并运行`Update-Database`命令。
- en: Loading and starting the application
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载和启动应用程序
- en: The URL of a Blazor WebAssembly application always includes an `index.html`
    static HTML page. In our `BlazorReview` project, `index.html` is in `BlazorReview.Client->wwwroot->index.html`.
    This page is the container where the Blazor application will create its HTML.
    It contains an HTML header with a `viewport meta` declaration, title, and the
    overall application's CSS. The Visual Studio default project template adds an
    application-specific CSS file and Bootstrap CSS, with a neutral style. You can
    replace the default Bootstrap CSS either with Bootstrap CSS with a customized
    style or with a completely different CSS framework.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor WebAssembly应用程序的URL始终包括一个`index.html`静态HTML页面。在我们的`BlazorReview`项目中，`index.html`位于`BlazorReview.Client->wwwroot->index.html`。此页面是Blazor应用程序将创建其HTML的容器。它包含一个带有`viewport
    meta`声明、标题和整个应用程序CSS的HTML头。Visual Studio默认项目模板添加了一个特定于应用程序的CSS文件和Bootstrap CSS，具有中性样式。您可以使用具有自定义样式的默认Bootstrap
    CSS或完全不同的CSS框架来替换默认的Bootstrap CSS。
- en: 'The body contains the code that follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正文包含以下代码：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The initial `div` is where the application will place the code it generates.
    Any markup placed inside this `div` will appear just while the Blazor application
    is loading and starting, then it will be replaced by the application-generated
    HTML. The second `div` is normally invisible and appears only when Blazor intercepts
    an unhandled exception.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 初始的`div`是应用程序将放置其生成的代码的地方。放置在此`div`中的任何标记都将在Blazor应用程序加载和启动时出现，然后将被应用程序生成的HTML替换。第二个`div`通常是不可见的，只有在Blazor拦截到未处理的异常时才会出现。
- en: '`blazor.webassembly.js` contains the JavaScript part of the Blazor framework.
    Among other things, it takes care of downloading the .NET runtime, together with
    all application DLLs. More specifically, `blazor.webassembly.js` downloads the
    `blazor.boot.json` file that lists all application files with their hashes. Then,
    `blazor.webassembly.js` downloads all resources listed in this file and verifies
    their hashes. All resources downloaded by `blazor.webassembly.js` are created
    when the application is built or published.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`blazor.webassembly.js`包含Blazor框架的JavaScript部分。除其他外，它负责下载.NET运行时以及所有应用程序DLL。更具体地说，`blazor.webassembly.js`下载列出所有应用程序文件及其哈希值的`blazor.boot.json`文件。然后，`blazor.webassembly.js`下载此文件中列出的所有资源并验证它们的哈希值。`blazor.webassembly.js`下载的所有资源都是在构建或发布应用程序时创建的。'
- en: '`AuthenticationService.js` is added only when the project enables authentication
    and takes care of the `OpenID Connect` protocol used by Blazor to exploit other
    authentication credentials like cookies to get bearer tokens, which are the preferred
    authentication credentials for clients that interact with a server through Web
    APIs. Authentication is discussed in more detail in the *Authentication and authorization*
    subsection later on in this chapter, while bearer tokens are discussed in the
    *REST services authorization and authentication* section of *Chapter 14*, *Applying
    Service-Oriented Architectures with .NET Core*.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在项目启用身份验证时才会添加`AuthenticationService.js`，它负责Blazor利用其他身份验证凭据（如cookie）来获取承载令牌的`OpenID
    Connect`协议。承载令牌是客户端通过Web API与服务器交互的首选身份验证凭据。身份验证将在本章后面的*身份验证和授权*子章节中更详细地讨论，而承载令牌将在*第14章*的*应用Service-Oriented
    Architectures with .NET Core*部分中讨论。
- en: 'The Blazor application entry point is in the `BlazorReview.Client->Program.cs`
    file. It has the following structure:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor应用程序的入口点在`BlazorReview.Client->Program.cs`文件中。它具有以下结构：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`WebAssemblyHostBuilder` is a builder for creating a `WebAssemblyHost`, which
    is a WebAssembly-specific implementation of the generic host discussed in the
    *Using generic hosts* subsection of *Chapter 5*, *Applying a Microservice Architecture
    to Your Enterprise Application* (you are encouraged to review that subsection).
    The first builder configuration instruction declares the Blazor root component
    (`App`), which will contain the whole components tree, and in which HTML tag of
    the `Index.html` page to place it (`#app`). More specifically, `RootComponents.Add`
    adds a hosted service that takes care of handling the whole Blazor components
    tree. We can run several Blazor WebAssembly user interfaces in the same HTML page
    by calling `RootComponents.Add` several times, each time with a different HTML
    tag reference.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebAssemblyHostBuilder`是用于创建`WebAssemblyHost`的构建器，它是在*第5章*的*将微服务架构应用于企业应用程序*中讨论的通用主机的WebAssembly特定实现（鼓励您查看该子章节）。第一个构建器配置指令声明了Blazor根组件（`App`），它将包含整个组件树，并在`Index.html`页面的哪个HTML标记中放置它（`#app`）。更具体地说，`RootComponents.Add`添加了一个托管服务，负责处理整个Blazor组件树。我们可以通过多次调用`RootComponents.Add`在同一个HTML页面中运行多个Blazor
    WebAssembly用户界面，每次使用不同的HTML标记引用。'
- en: '`builder.Services` contains all the usual methods and extension methods to
    add services to the Blazor application dependency engine: `AddScoped`, `AddTransient`,
    `AddSingleton`, and so on. Like in ASP.NET Core MVC applications (*Chapter 15*,
    *Presenting ASP.NET Core MVC*), services are the preferred places to implement
    business logic and to store shared state. While in ASP.NET Core MVC, services
    were usually passed to controllers, in Blazor WebAssembly, they are injected into
    components.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection explains how the root `App` component simulates page changes.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Routing
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The root `App` class referenced by the host building code is defined in the
    `BlazorReview.Client->App.razor` file. `App` is a Blazor component, and like all
    Blazor components, it is defined in a file with a `.razor` extension and uses
    Razor syntax enriched with component notation, that is, with HTML-like tags that
    represent other Blazor components. It contains the whole logic for handling application
    pages:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: All tags in the preceding code represent either components or particular component
    parameters, called templates. Components will be discussed in detail throughout
    the chapter. For the moment, imagine them as a kind of custom HTML tag that we
    can define somehow with C# and Razor code. Templates, instead, are parameters
    that accept Razor markup as values. Templates are discussed in the *Templates
    and cascading parameters* subsection later on in this section.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: The `CascadingAuthenticationState` component has the only function of passing
    authentication and authorization information to all components of the component
    tree that is inside of it. Visual Studio generates it only if one chooses to add
    authorization during project creation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: The `Router` component is the actual application router. It scans the assembly
    passed in the `AppAssembly` parameter looking for components containing routing
    information, that is, for components that can work as pages. Visual studio passes
    it the assembly that contains the `Program` class, that is, the main application.
    Pages contained in other assemblies can be added through the `AdditionalAssemblies`
    parameter, which accepts an `IEnumerable` of assemblies.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: After that, the router intercepts all page changes performed either by code
    or through the usual `<a>` HTML tags that point to an address inside of the application
    base address. Navigation can be handled by code by requiring a `NavigationManager`
    instance from dependency injection.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Router` component has two templates, one for the case where a page for
    the requested URI is found (`Found`), and the other for the case where it is not
    found (`NotFound`). When the application uses authorization, the `Found` template
    consists of the `AuthorizeRouteView` components, which further distinguish whether
    the user is authorized to access the selected page or not. When the application
    doesn''t use authorization, the `Found` template consists of the `RouteView` component:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`RouteView` takes the selected page and renders it inside the layout page specified
    by the `DefaultLayout` parameter. This specification acts just as a default since
    each page can override it by specifying a different layout page. Blazor layout
    pages work similarly to ASP.NET Core MVC layout pages described in the *Reusing
    view code* subsection of *Chapter 15*, *Presenting ASP.NET Core MVC*, the only
    difference being that the place to add the page markup is specified with `@Body`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the Visual Studio template, the default layout page is in the `BlazorReview.Client->Shared->MainLayout.razor`
    file.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'If the application uses authorization, `AuthorizeRouteView` works like `RouteView`,
    but it also allows the specification of a template for a case where the user is
    not authorized:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If the user is not authenticated, the `RedirectToLogin` component uses a `NavigationManager`
    instance to move to the login logic page, otherwise, it informs the user they
    haven't got enough privileges to access the selected page.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Blazor WebAssembly also allows assemblies lazy loading to reduce the initial
    application loading time, but we will not discuss it here for lack of space. The
    *Further reading* section contains references to the official Blazor documentation.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Blazor pages and components
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn the basics of Blazor components, how to define
    a component, its structure, how to attach events to HTML tags, how to define their
    attributes, and how to use other components inside your components. We have organized
    all content into different subsections. The first subsection describes the basics
    of component structure.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Component structure
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Components are defined in files with a `.razor` extension. Once compiled, they
    become classes that inherit from `ComponentBase`. Like all other Visual Studio
    project elements, Blazor components are available through the **add new item**
    menu. Usually, components to be used as pages are defined in the `Pages` folder,
    or in its subfolders, while other components are organized in different folders.
    Default Blazor projects add all their non-page components inside the `Shared`
    folder, but you can organize them differently.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, pages are assigned a namespace that corresponds to the path of
    the folder they are in. Thus, for instance, in our example project, all pages
    that are in the `BlazorReview.Client->Pages` path are assigned to the `BlazorReview.Client.Pages`
    namespace. However, you can change this default namespace with an `@namespace`
    declaration placed in the declaration area that is at the top of the file. This
    area may also contain other important declarations. Following is an example that
    shows all declarations:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first two directives make sense only for components that must work as pages.
    More specifically, the `@layout` directive overrides the default layout page with
    another component, while the `@page` directive defines the path of the page (**route**)
    within the application base URL. Thus, for instance, if our application runs at
    `https://localhost:5001`, then the URL of the above page will be `https://localhost:5001/counter`.
    Page routes can also contain parameters like in this example: `/orderitem/{customer}/{order}`.
    Parameter names must match public properties defined as parameters by the components.
    The match is case-insensitive, and parameters will be explained later on in this
    subsection.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'The string that instantiates each parameter is converted into the parameter
    type and if this conversion fails an exception is thrown. This behavior can be
    prevented by associating a type with each parameter, in which case, if the conversion
    to the specified type fails, the match with the page URL fails. Only elementary
    types are supported: `/orderitem/{customer:int}/{order:int}`. Parameters are obligatory,
    that is, if they are not found, the match fails and the router tries other pages.
    However, you can make a parameter optional by specifying two `@page` directives,
    one with the parameter, and the other without the parameter.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '`@namespace` overrides the default namespace of the component, while `@using`
    is equivalent to the usual C# `using`. `@using` declared in the special `{project
    folder}->_Imports.razor` folder is automatically applied to all components.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '`@inherits` declares that the component is a subclass of another component,
    while `@implements` declares it implements an interface.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '`@typeparam` is used if the component is a generic class, and declares the
    name of the generic parameter, while `@attribute` declares any attribute applied
    to the component class. Property-level attributes are applied directly to properties
    defined in the code area, so they don''t need special notation. The `[Authorize]`
    attribute, applied to a component class used as a page, prevents unauthorized
    users from accessing the page. It works exactly in the same way as when it is
    applied to a controller or to an action method in ASP.NET Core MVC.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `@inject` directive requires a type instance to the dependency
    injection engine and inserts it in the field declared after the type name; in
    the previous example, in the `navigation` parameter.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: The middle part of the component file contains the HTML that will be rendered
    by the component with Razor markup, enriched with the possible invocation of children
    components.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'The bottom part of the file is enclosed by an `@code` construct and contains
    fields, properties, and methods of the class that implements the component:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Public properties decorated with the `[Parameter]` attribute work as component
    parameters; that is, when the component is instantiated into another component,
    they are used to pass values to the decorated properties, like values are passed
    to HTML elements in HTML markup:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Values can also be passed to component parameters by page route parameters
    that match the property name in a case invariant match:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Component parameters can also accept complex types and functions:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If components are generic, they must be passed type values for each generic
    parameter declared with `typeparam`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: However, often, the compiler is able to infer generic types from the type of
    other parameters.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the code enclosed in the `@code` directive can be also declared in
    a partial class with the same name and namespace as the component:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Usually, these partial classes are declared in the same folder of the component
    and with a filename equal to the component file name with a `.cs` postfix added.
    Thus, for instance, the partial class associated with the `counter.razor` component
    will be `counter.razor.cs`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Each component may also have an associated CSS file, whose name must be the
    name of the component file plus the `.css` postfix. Thus, for instance, the CSS
    file associated with the `counter.razor` component will be `counter.razor.css`.
    The CSS contained in this file is applied only to the component and has no effect
    on the remainder of the page. This is called CSS isolation, and at the moment,
    it is implemented by adding a unique attribute to all component HTML roots. Then,
    all selectors of the component CSS file are scoped to this attribute, so that
    they can't affect other HTML.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a component decorates an `IDictionary<string, object>` parameter with
    `[Parameter(CaptureUnmatchedValues = true)]`, then all unmatched parameters inserted
    into the tag, that is, all parameters without a matching component property, are
    added to the `IDictionary` as key-value pairs.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'This feature furnishes an easy way to forward parameters to HTML elements or
    ­other children components contained in the component markup. For instance, if
    we have a `Detail` component that displays a detail view of the object passed
    in its `Value` parameter, we can use this feature to forward all usual HTML attributes
    to the root HTML tag of the component, as shown in the following example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This way, usual HTML attributes added to the component tag such as, for instance,
    class, are forwarded to the root `div` of the components and somehow used to style
    the component:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The next subsection explains how to pass markup generating functions to components.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Templates and cascading parameters
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Blazor works by building a data structure called a **render tree**, which is
    updated as the UI changes. At each change, Blazor locates the part of the HTML
    that must be rendered and uses the information contained in the **render tree**
    to update it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: The `RenderFragment` delegate defines a function that is able to add further
    markup to a specific position of the **render tree**. There is also a `RenderFragment<T>`
    that accepts a further argument you can use to drive the markup generation. For
    instance, you can pass a `Customer` object to a `RenderFragment<T>` so that it
    can render all the data for that specific customer.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'You can define a `RenderFragment` or a `RenderFragment<T>` with C# code, but
    the simplest way is to define it in your components with Razor markup. The Razor
    compiler will take care of generating the proper C# code for you:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The information on the location to add the markup is passed in the `RenderTreeBuilder`
    argument it receives as an argument. You can use a `RenderFragment` in your component
    Razor markup by simply invoking it as shown in the following example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The position where you invoke the `RenderFragment` defines the location where
    it will add its markup, since the component compiler is able to generate the right
    `RenderTreeBuilder` argument to pass to it. `RenderFragment<T>` delegates are
    invoked as shown here:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Being functions, render fragments can be passed to component parameters like
    all other types. However, Blazor has a specific syntax to make it easier to simultaneously
    define and pass render fragments to components, the **template** syntax. First,
    you define the parameters in your component:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, when you call the customer, you can do the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Each render fragment parameter is represented by a tag with the same name as
    the parameter. You can place the markup that defines the render fragment inside
    of it. For the `CustomerTemplate` that has a parameter, the `Context` keyword
    defines the parameter name inside the markup. In our example, the chosen parameter
    name is `customer`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'When a component has just one render fragment parameter, if it is named `ChildContent`,
    the template markup can be enclosed directly between the open and end tag of the
    component:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In order to familiarize ourselves with component templates, let's modify the
    `Pages->FetchData.razor` page so that, instead of using a `foreach`, it uses a
    `Repeater` component.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s right-click on the `Shared` folder, select **Add**, then **Razor Component**,
    and add a new **Repeater.razor** component. Then, replace the existing code with
    this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The component is defined with a generic parameter so that it can be used with
    any `IEnumerable`. Now let''s replace the markup in the `tbody` of the **FetchData.razor**
    component with this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Since the `Repeater` component has just one template, and since we named it
    `ChildContent`, we can place our template markup directly within the component
    open and close tags. Run it and verify that the page works properly. You have
    learned how to use templates, and that markup placed inside a component defines
    a template.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'An important predefined templated Blazor component is the `CascadingValue`
    component. It renders the content placed inside of it with no changes, but passes
    a type instance to all its descendant components:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'All components placed inside of the `CascadingValue` tag and all their descendant
    components can now capture the instance of `MyOptionsInstance` passed in the `CascadingValueValue`
    parameter. It is enough that the component declares a public or private property
    with a type that is compatible with `MyOptionsInstance` and that decorates it
    with the `CascadingParameter` attribute:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Matching is performed by type compatibility. In case of ambiguity with other
    cascaded parameters with a compatible type, we can specify the `Name` optional
    parameter of the `CascadingValue` component and pass the same name to the `CascadingParameter`
    attribute: `[CascadingParameter("myUnique name")]`.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: The `CascadingValue` tag also has an `IsFixed` parameter that should be set
    to `true` whenever possible for performance reasons. In fact, propagating cascading
    values is very useful for passing options and settings, but it has a very high
    computational cost.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: When `IsFixed` is set to `true`, propagation is performed just once, the first
    time that each piece of involved content is rendered, and then no attempt is made
    to update the cascaded value during the content's lifetime. Thus, `IsFixed` can
    be used whenever the pointer of the cascaded object is not changed during the
    content's lifetime.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: An example of a cascading value is the `CascadingAuthenticationState` component
    we encountered in the *Routing* subsection, which cascades authentications and
    authorization information to all rendered components.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Events
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Both HTML tags and Blazor components use attributes/parameters to get input.
    HTML tags provide output to the remainder of the page through events, and Blazor
    allows C# functions to be attached to HTML `on{event name}` attributes. The syntax
    is shown in the `Pages->Counter.razor` component:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The function can also be passed inline as a lambda. Moreover, it accepts the
    C# equivalent of the usual `event` argument. The *Further reading* section contains
    a link to the Blazor official documentation page that lists all supported events
    and their arguments.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Blazor also allows events in components, so they can return output, too. Component
    events are parameters whose type is either `EventCallBack` or `EventCallBack<T>`.
    `EventCallBack` is the type of component event with no arguments while `EventCallBack<T>`
    is the type of component event with an argument of type `T`. In order to trigger
    an event, say `MyEvent`, the component calls:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: or
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: These calls execute the handlers bound to the events or do nothing if no handler
    has been bound.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Once defined, component events can be used exactly in the same way as HTML
    element events, the only difference being that there is no need to prefix the
    event name with an `@`, since `@` in HTML events is needed to distinguish between
    the HTML attribute and the Blazor-added parameter with the same name:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Actually, HTML element events are also `EventCallBack<T>`, that is why both
    event types behave in exactly the same way. `EventCallBack` and `EventCallBack<T>`
    are structs, not delegates, since they contain a delegate, together with a pointer
    to the entity that must be notified that the event has been triggered. Formally,
    this entity is represented by a `Microsoft.AspNetCore.Components.IHandleEvent`
    interface. Needless to say, all components implement this interface. The notification
    informs `IHandleEvent` that a state change took place. State changes play a fundamental
    role in the way Blazor updates the page HTML. We will analyze them in detail in
    the next subsection.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'For HTML elements, Blazor also provides the possibility to stop the event''s
    default action and the event bubbling by adding the `:preventDefault` and `:stopPropagation`
    directives to the attribute that specifies the event, like in these examples:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Bindings
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often a component parameter value must be kept synchronized with an external
    variable, property, or field. The typical application of this kind of synchronization
    is an object property being edited in an input component or HTML tag. Whenever
    the user changes the input value, the object property must be updated coherently,
    and vice versa. The object property value must be copied into the component as
    soon as the component is rendered so that the user can edit it.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Similar scenarios are handled by parameter-event pairs. More specifically, from
    one side, the property is copied in the input component parameter. From the other
    side, each time the input changes value, a component event that updates the property
    is triggered. This way, property and input values are kept synchronized.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: This scenario is so common and useful that Blazor has a specific syntax for
    simultaneously defining the event and the copying of the property value into the
    parameter. This simplified syntax requires that the event has the same name as
    the parameter involved in the interaction but with a `Changed` postfix.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose, for instance, that a component has a `Value` parameter. Then the corresponding
    event must be `ValueChanged`. Moreover, each time the user changes the component
    value, the component must invoke the `ValueChanged` event by calling `await ValueChanged.InvokeAsync(arg)`.
    With this in place, a property `MyObject.MyProperty` can be synchronized with
    the `Value` property with the syntax shown here:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding syntax is called **binding**. Blazor takes care of automatically
    attaching an event handler that updated the `MyObject.MyProperty` property to
    the `ValueChanged` event.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'Bindings of HTML elements work in a similar way, but since the developer can''t
    decide the names of parameters and events, a slightly different convention must
    be used. First of all, there is no need to specify the parameter name in the binding,
    since it is always the HTML input `value` attribute. Therefore, the binding is
    written simply as `@bind="object.MyProperty"`. By default, the object property
    is updated on the `change` event, but you can specify a different event by adding
    the `@bind-event: @bind-event="oninput"` attribute.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, bindings of HTML inputs try to automatically convert the input string
    into the target type. If the conversion fails, the input reverts to its initial
    value. This behavior is quite primitive since, in the event of errors, no error
    message is provided to the user, and the culture settings are not taken into account
    properly (HTML5 inputs use invariant culture but text input must use the current
    culture). We advise binding inputs only to string target types. Blazor has specific
    components for handling dates and numbers that should be used whenever the target
    type is not a string. We will describe them in the *Blazor forms and validation*
    section.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to familiarize ourselves with events, let''s write a component that
    synchronizes the content of an input type text when the user clicks a confirmation
    button. Let''s right-click on the `Shared` folder and add a new **ConfirmedText.razor**
    component. Then replace its code with this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `ConfirmedText` component exploits the button-click event to trigger the
    `ValueChanged` event. Moreover, the component itself uses `@bind` to synchronize
    its `Value` parameter with the HTML input. It is worth pointing out that the component
    uses `CaptureUnmatchedValues` to forward all HTML attributes applied to its tag
    to the HTML input. This way, users of the `ConfirmedText` component can style
    the input field by simply adding `class` and/or `style` attributes to the component
    tag.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s use this component in the `Pages->Index.razor` page by placing the
    following code at the end of `Index.razor`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If you run the project and play with the input and its **Confirm** button, you
    will see that each time the **Confirm** button is clicked, not only are the input
    values copied in the `textValue` page property but also the content of the paragraph
    that is behind the component is coherently updated.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: We explicitly synchronized `textValue` with the component with `@bind-Value`,
    but who takes care of keeping `textValue` synchronized with the content of the
    paragraph? The answer is in the next subsection.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: How Blazor updates HTML
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we write the content of a variable, property, or field in Razor markup
    with something like `@model.property`, Blazor, not only renders the actual value
    of the variable, property, or field when the component is rendered but tries also
    to update the HTML each time that this value changes, with a process called **change
    detection**. Change detection is a feature of all main SPA frameworks, but the
    way Blazor implements it is very simple and elegant.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea is that, once all HTML has been rendered, changes may occur only
    because of code executed inside of events. That is why `EventCallBack` and `EventCallBack<T>`
    contain a reference to an `IHandleEvent`. When a component binds a handler to
    an event, the Razor compiler creates an `EventCallBack`or`EventCallBack<T>` passing
    in its `struct` constructor the function bound to the event, and the component
    where the function was defined (`IHandleEvent`).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Once the code of the handler has been executed, the Blazor runtime is notified
    that the `IHandleEvent` might have changed. In fact, the handler code can only
    change the values of variables, properties, or fields of the component where the
    handler was defined. In turn, this triggers a change detection rooted in the component.
    Blazor verifies which variables, properties, or fields used in the component Razor
    markup changed and updates the associated HTML.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: If a changed variable, property, or field is an input parameter of another component,
    then, the HTML generated by that component might also need updates. Accordingly,
    another change-detection process rooted in that component is recursively triggered.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm sketched previously discovers all relevant changes only if the
    following conditions listed are met:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: No component references data structures belonging to other components in an
    event handler.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All inputs to a component arrive through its parameters and not through method
    calls or other public members.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When there is a change that is not detected because of the failure of one of
    the preceding conditions, the developer must manually declare the possible change
    of the component. This can be done by calling the `StateHasChanged()` component
    method. Since this call might result in changes to the page HTML, its execution
    cannot take place asynchronously but must be queued in the HTML page UI thread.
    This is done by passing the function to be executed to the `InvokeAsync` component
    method.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Summing up, the instruction to execute is `await InvokeAsync(StateHasChanged)`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection concludes the description of components with an analysis
    of their lifecycle and of the associated lifecycle methods.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Component lifecycle
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each component lifecycle event has an associated method. Some methods have both
    synchronous and asynchronous versions, some have just an asynchronous version,
    and some others have just a synchronous version.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'The component lifecycle starts with parameters passed to the component being
    copied in the associated component properties. You can customize this step by
    overriding the following method:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Typically, customization consists of the modification of additional data structures,
    so the base method is called to also perform the default action of copying parameters
    in the associated properties.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, there is the component initialization that is associated with the
    two methods:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: They are called once in the component lifetime, immediately after the component
    has been created and added to the render tree. Please place any initialization
    code there, and not in the component constructor because this will improve component
    testability, because, there, you have all parameters set, and because future Blazor
    versions might pool and reuse component instances.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: If the initialization code subscribes to some events or performs actions that
    need a cleanup when the component is destroyed, implement `IDisposable`, and place
    all cleanup code in its `Dispose` method. In fact, whenever a component implements
    `IDisposable`, Blazor calls its `Dispose` method before destroying it.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'After the component has been initialized and each time a component parameter
    changes, the following two methods are called:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: They are the right place to update data structures that depend on the values
    of the component parameters.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, the component is rendered or re-rendered. You can prevent component
    re-rendering after an update by overriding the `ShouldRender` method:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Letting a component re-render only if you are sure its HTML code will change
    is an advanced optimization technique used in the implementation of component
    libraries.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'The component rendering stage also involves the invocation of its children
    components. Therefore, component rendering is considered complete only after all
    its descendant components have completed their rendering, too. When rendering
    is complete, the following methods are called:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Since when the preceding methods are called, all component HTML has been updated
    and all children components have executed all their lifetime methods, the preceding
    methods are the right places for performing the following operations:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Calling JavaScript functions that manipulate the generated HTML. JavaScript
    calls are described in the *JavaScript interoperability* subsection.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing information attached to parameters or cascaded parameters by descendant
    components. In fact, Tabs-like components and other components might have the
    need to register some of their subparts in the root component, so the root component
    typically cascades a data structure where some children components can register.
    Code written in `AfterRender` and `AfterRenderAsync` can rely on the fact that
    all subparts have completed their registration.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next section describes Blazor tools for collecting user input.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Blazor forms and validation
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to all major SPA frameworks, Blazor also offers specific tools for processing
    user input while providing valid feedback to the user with error messages and
    immediate visual clues. The whole toolset is known as **Blazor Forms** and consists
    of a form component called `EditForm`, various input components, a data annotation
    validator, a validation error summary, and validation error labels.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '`EditForm` takes care of orchestrating the state of all input components, through
    an instance of the `EditContext` class that is cascaded inside of the form. The
    orchestration comes from the interaction of both input components and the data
    annotation validator with this `EditContext` instance. A validation summary and
    error message labels don''t take part in the orchestration but register to some
    `EditContext` events to be informed about errors.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '`EditForm` must be passed the object whose properties must be rendered in its
    `Model` parameter. It is worth pointing out that input components bound to nested
    properties are not validated, so `EditForm` must be passed a flattened ViewModel.
    `EditForm` creates a new `EditContext` instance, passes the object received in
    its `Model` parameter in its constructor, and cascades it so it can interact with
    the form content.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: You can also directly pass an `EditContext` custom instance in the `EditContext`
    parameter of `EditForm` instead of passing the object in its `Model` parameter,
    in which case `EditForm` will use your custom copy instead of creating a new instance.
    Typically, you do this when you need to subscribe to the `EditContextOnValidationStateChanged`
    and `OnFieldChanged` events.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: When `EditForm` is submitted with a **Submit** button and there are no errors,
    the form invokes its `OnValidSubmit` callback, where you can place the code that
    uses and processes the user input. If instead, there are validation errors, they
    are shown, and the form invokes its `OnInvalidSubmit` callback.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'The state of each input is reflected in some CSS classes that are automatically
    added to them, namely: `valid`, `invalid`, and `modified`. You can use these classes
    to furnish adequate visual feedback to the user. The default Blazor Visual Studio
    template already furnishes some CSS for them.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is a typical form:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The label is a standard HTML label, while `InputNumber` is a Blazor-specific
    component for number properties. `ValidationMessage` is the error label that appears
    only in the event of a validation error. As a default, it is rendered with a `validation-message`
    CSS class. The property associated with the error message is passed in the `for`
    parameter with a parameterless lambda as shown in the example.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: The `DataAnnotationsValidator` component adds a validation based on the usual
    .NET validation attributes, such as `RangeAttribute`, `RequiredAttribute`, and
    so on. You can also write your custom validation attributes by inheriting from
    the `ValidationAttribute` class.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: You can provide custom error messages in the validation attributes. If they
    contain a `{0}` placeholder, this will be filled with the property display name
    declared in a `DisplayAttribute`, if one is found, otherwise with the property
    name.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Together with the `InputNumber` component, Blazor also supports an `InputText`
    component for `string` properties, an `InputTextArea` component for `string` properties
    to be edited in an HTML `textarea`, an `InputCheckbox` component for `bool` properties,
    and an `InputDate` component that renders `DateTime` and `DateTimeOffset` as dates.
    They all work in exactly the same way as the `InputNumber` component. No component
    is available for other HTML5 input types. In particular, no component is available
    for rendering time or date and time, or for rendering numbers with a `range` widget.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'You can implement rendering time or date and time by inheriting from the `InputBase<TValue>`
    class and overriding the `BuildRenderTree`, `FormatValueAsString`, and `TryParseValueFromString`
    methods. The sources of the `InputNumber` component show how to do it: [https://github.com/dotnet/aspnetcore/blob/15f341f8ee556fa0c2825cdddfe59a88b35a87e2/src/Components/Web/src/Forms/InputNumber.cs](https://github.com/dotnet/aspnetcore/blob/15f341f8ee556fa0c2825cdddfe59a88b35a87e2/src/Components/We).
    You can also use the third-party libraries described in the *Third-party tools
    for Blazor WebAssembly* section.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'Blazor also has a specific component for rendering a `select`, which works
    as in the following example:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You can also render enumerations with a radio group thanks to the `InputRadioGroup`
    and `InputRadio` components, as shown in the following example:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Finally, Blazor also offers an `InputFile` component together with all the tools
    for processing and uploading the file. We will not cover this here, but the *Further
    reading* section contains links to the official documentation.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: This subsection finishes the description of Blazor basics; the next section
    analyzes some advanced features.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Blazor advanced features
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section collects short descriptions of various Blazor advanced features
    organized in subsections. For lack of space, we can't give all the details of
    each feature, but the lacking details are covered by links in the *Further reading*
    section. We start with how to reference components and HTML elements defined in
    Razor markup.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: References to components and HTML elements
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes we might need a reference to a component in order to call some of
    its methods. This is the case, for instance, for a component that implements a
    modal window:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As the preceding example shows, references are captured with the `@ref` directive.
    The same `@ref` directive can also be used to capture references to HTML elements.
    HTML references have an `ElementReference` type and are typically used to call
    JavaScript functions on HTML elements, as explained in the next subsection.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript interoperability
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since Blazor doesn't expose all JavaScript features to C# code, and since it
    is convenient to take advantage of the huge JavaScript code base available, sometimes
    it is necessary to invoke JavaScript functions. Blazor allows this through the
    `IJSRuntime` interface that can be injected into a component via dependency injection.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'Once one has an `IJSRuntime` instance, a JavaScript function that returns a
    value can be called as shown here:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Functions that do not return any argument can be invoked as shown here:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Arguments can be either basic types or objects that can be serialized in JSON,
    while the name of the JavaScript function is a string that can contain dots that
    represent access to properties, sub-properties, and method names, like, for instance,
    the `"myJavaScriptObject.myProperty.myMethod"` string.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Arguments can also be `ElementReference` instances captured with the `@ref`
    directive, in which case they are received as HTML elements on the JavaScript
    side.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript functions invoked must be defined either in the `Index.html`
    file or in JavaScript files referenced in `Index.html`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are writing a component library with a Razor library project, JavaScript
    files can be embedded together with CSS files as resources in the DLL library.
    It is enough to add a `wwwroot` folder in the project root and to place the needed
    CSS and JavaScript files in that folder or in some subfolder of it. After that,
    these files can be referenced as:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Accordingly, if the filename is `myJsFile.js`, the dll name is `MyCompany.MyLibrary`,
    and the file is placed in the `js` folder inside `wwwroot`, then its reference
    will be:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If your JavaScript files are organized as ES6 modules, you can avoid referencing
    them in `Index.html`, and can load the modules directly as shown here:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In addition, instance methods of C# objects can be called from JavaScript code,
    taking the following steps:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Say the C# method is called `MyMethod`. Decorate the `MyMethod` method with
    the `[JSInvokable]` attribute.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enclose the C# object in a `DotNetObjectReference` instance and pass it to
    JavaScript with a JavaScript call:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'On the JavaScript side, say the C# object is in a variable called `dotnetObject`.
    Then it is enough to invoke:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The next section explains how to handle contents and number/date localization.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Globalization and localization
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As soon as the Blazor application starts, both the application culture and the
    application UI culture are set to the browser culture. However, the developer
    can change both of them by assigning the chosen cultures to `CultureInfo.DefaultThreadCurrentCulture`
    and `CultureInfo.DefaultThreadCurrentUICulture`. Typically, the application lets
    the user choose one of its supported cultures, or it accepts the browser culture
    only if it is supported, otherwise, it falls back to a supported culture. In fact,
    it is possible to support just a reasonable number of cultures because all application
    strings must be translated in all supported cultures.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Once the `CurrentCulture` is set, dates and numbers are automatically formatted
    according to the conventions of the chosen culture. For the UI culture, the developer
    must manually provide resource files with the translations of all application
    strings in all supported cultures.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to use resource files. With the first option, you create
    a resource file, say, `myResource.resx`, and then add all language-specific files:
    `myResource.it.resx`, `myResource.pt.resx`, and so on. In this case, Visual Studio
    creates a static class named `myResource` whose static properties are the keys
    of each resource file. These properties will automatically contain the localized
    strings corresponding to the current UI culture. You can use these static properties
    wherever you like, and you can use pairs composed of a resource type and a resource
    name to set the `ErrorMessageResourceType` and the `ErrorMessageResourceName`
    properties of validation attributes or similar properties of other attributes.
    This way, the attributes will use an automatically localized string.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: With the second option, you add only language-specific resource files (`myResource.it.resx`,
    `myResource.pt.resx`, and so on). In this case, Visual Studio doesn't create any
    class associated with the resource file, and you can use resource files together
    with `IStringLocalizer` and `IStringLocalizer<T>` injected in components as you
    use them in ASP.NET Core MVC views (see the *ASP.NET Core globalization* section
    of *Chapter 15*, *Presenting ASP.NET Core MVC*).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and authorization
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Routing* subsection, we sketched how the `CascadingAuthenticationState`
    and `AuthorizeRouteView` components prevent unauthorized users from accessing
    pages protected with an `[Authorize]` attribute. Let's go deeper into the details
    of how page authorization works.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: In .NET applications, authentication and authorization information is usually
    contained in a `ClaimsPrincipal` instance. In server applications, this instance
    is built when the user logs in, taking the required information from a database.
    In Blazor WebAssembly, such information must be provided by some remote server
    that takes care of SPA authentication, too. Since there are several ways to provide
    authentication and authorization to a Blazor WebAssembly application, Blazor defines
    the `AuthenticationStateProvider` abstraction.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and authorization providers inherit from the `AuthenticationStateProvider`
    abstract class and override its `GetAuthenticationStateAsync` method, which returns
    a `Task<AuthenticationState>`, where the `AuthenticationState` contains the authentication
    and authorization information. Actually, `AuthenticationState` contains just a
    `User` property with a `ClaimsPrincipal`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve defined a concrete implementation of `AuthenticationStateProvider`,
    we must register it in the dependency engine container in the application `program.cs`
    file:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We will return to the predefined implementations of `AuthenticationStateProvider`
    offered by Blazor after having described how Blazor uses authentication and authorization
    information furnished by a registered `AuthenticationStateProvider`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CascadingAuthenticationState` component calls the `GetAuthenticationStateAsync`
    method of the registered `AuthenticationStateProvider` and cascades the returned
    `Task<AuthenticationState>`. You can intercept this cascading value with a `[CascadingParameter]`
    defined as follows in your components:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: However, Blazor applications typically use `AuthorizeRouteView` and `AuthorizeView`
    components to control user access to content.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '`AuthorizeRouteView` prevents access to pages if the user doesn''t satisfy
    the prescriptions of the page `[Authorize]` attribute, otherwise, the content
    in the `NotAuthorized` template is rendered. `AuthorizeRouteView` also has an
    `Authorizing` template that is shown while user information is being retrieved.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '`AuthorizeView` can be used within components to show the markup it encloses
    only to authorized users. It contains the same `Roles` and `Policy` parameters
    of the `[Authorize]` attribute that you can use to specify the constraints the
    user must satisfy to access the content:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`AuthorizeView` can also specify `NotAuthorized` and an `Authorizing` template:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If one adds authorization while creating a Blazor WebAssembly project, the
    following method call is added to the application dependency engine:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This method adds an `AuthenticationStateProvider` that extracts the user information
    from the usual ASP.NET Core authentication cookie. Since authentication cookies
    are encrypted, this operation must be performed by contacting an endpoint exposed
    by the server. The operation is performed with the help of the `AuthenticationService.js`
    JavaScript file we saw in the *Loading and starting the application* subsection
    of this chapter. The server endpoint returns user information in the form of a
    bearer token that can be used also to authenticate communications with the server's
    WEB API. Bearer tokens are described in detail in the *REST services authorization
    and authentication* and *ASP.NET Core service authorization* sections of *Chapter
    14*, *Applying Service-Oriented Architectures with .NET Core*. Blazor WebAssembly
    communication is described in the next subsection.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'If no valid authentication cookie is found, the provider creates an unauthenticated
    `ClaimsPrincipal`. This way, when the user tries to access a page that is protected
    by an `[Authorize]` attribute, the `AuthorizeRouteView` component invokes the
    `RedirectToLogin` component, which, in turn, navigates to the `Authentication.razor`
    page, passing it a login request in its `action` route parameter:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `RemoteAuthenticatorView` acts as an interface with the usual ASP.NET Core
    user login/registration system, and whenever it receives an "action" to perform
    redirects the user from the Blazor application to the proper ASP.NET Core server
    page (login, registration, logout, user profile).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: All information needed to communicate with the server is based on name conventions,
    but they can be customized with the `options` argument of the `AddApiAuthorization`
    method. There, for instance, you can change the URL where the user can register,
    and also the address of the endpoint contacted by Blazor to collect information
    on the server settings. This endpoint is in the `BlazorReview.Server->Controller->OidcConfigurationController.cs`
    file.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Once the user logs in, they are redirected to the Blazor application page that
    caused the login request. The redirect URL is computed by the `BlazorReview.Client->Shared->RedirectToLogin.razor`
    component, which extracts it from the `NavigationManager` and passes it to the
    `RemoteAuthenticatorView` component. This time, the `AuthenticationStateProvider`
    is able to get the user information from the authentication cookie that has been
    created by the login operation.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: More details on the authentication process are available in the official documentation
    reference in the *Further reading* section
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection describes a Blazor WebAssembly-specific implementation of
    the `HttpClient` class and related types.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Communication with the server
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Blazor WebAssembly supports the same .NET `HttpClient` and `HttpClientFactory`
    classes described in the *.NET Core HTTP clients* section of *Chapter 14*, *Applying
    Service-Oriented Architectures with .NET Core*. However, due to the communication
    limitations of browsers, their implementations are different and rely on the browser
    **fetch API**.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 14*, *Applying Service-Oriented Architectures with .NET Core*, we
    analyzed how to take advantage of `HttpClientFactory` to define typed clients.
    You can also define typed clients in Blazor with exactly the same syntax.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'However, since Blazor needs to send the bearer token created during the authentication
    process in each request to the application server, it is common to define a named
    client as shown here:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`AddHttpMessageHandler` adds a `DelegatingHandler`, that is, a subclass of
    the `DelegatingHandler` abstract class. Implementations of `DelegatingHandler`
    override its `SendAsync` method in order to process each request and each relative
    response:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`BaseAddressAuthorizationMessageHandler` is added to the dependency injection
    engine by the `AddApiAuthorization` call we saw in the previous section. It adds
    the bearer token produced by the authorization process to each request addressed
    to the application server domain. If either this bearer token is expired or is
    not found at all, it tries to get a new bearer token from the user authentication
    cookie. If this attempt also fails, an `AccessTokenNotAvailableException` is thrown.
    Typically, similar exceptions are captured and trigger a redirection to the login
    page (as the default, to `/authentication/{action}`):'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Since most requests are directed to the application server, and just a few
    calls might contact other servers with CORS, the `BlazorReview.ServerAPI` named
    `client` is also defined to be the default `HttpClient` instance:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The default client can be obtained by requiring an `HttpClient` instance to
    the dependency injection engine. CORS requests to other servers can be handled
    by defining other named clients that use other bearer tokens. One can get a named
    client by first getting an `IHttpClientFactory` instance from dependency injection,
    and then calling its `CreateClient("<named client name>")` method. Blazor offers
    packages for getting bearer tokens and connecting with well-known services. They
    are described in the authorization documentation referenced in the *Further reading*
    section.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: The next section briefly discusses some of the most relevant third-party tools
    and libraries that complete Blazor's official features, and help increase productivity
    in Blazor projects.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Third-party tools for Blazor WebAssembly
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Notwithstanding Blazor is a young product, its third-party tool and product
    ecosystem is already quite rich. Among the open source, free products, it is worth
    mentioning the **Blazorise** project ([https://github.com/stsrki/Blazorise](https://github.com/stsrki/Blazorise)),
    which contains various free basic Blazor components (inputs, tabs, modals, and
    so on) that can be styled with various CSS frameworks, such as Bootstrap and Material.
    It also contains a simple editable grid and a simple tree view.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Also worth mentioning is **BlazorStrap** ([https://github.com/chanan/BlazorStrap](https://github.com/chanan/BlazorStrap)),
    which contains pure Blazor implementations of all Bootstrap 4 components and widgets.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Among all the commercial products, it is worth mentioning **Blazor Controls
    Toolkit** ([http://blazor.mvc-controls.com/](http://blazor.mvc-controls.com/)),
    which is a complete toolset for implementing commercial applications. It contains
    all input types with their fallbacks in case they are not supported by the browser;
    all Bootstrap components; other basic components; and a complete, advanced drag-and-drop
    framework; advanced customizable and editable components, like detail views, detail
    lists, grids, a tree-repeater (a generalization of the tree-view). All components
    are based on a sophisticated metadata representation system that enables the user
    to design the markup in a declarative way using data annotations and inline Razor
    declarations.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, it contains additional sophisticated validation attributes, tools
    for undoing user input, tools for computing changes to send to the server, sophisticated
    client-side and server-side query tools based on the OData protocol, and tools
    to maintain and save the whole application state.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: It is worth also mentioning the **bUnit** open source project ([https://github.com/egil/bUnit](https://github.com/egil/bUnit)),
    which furnishes all tools for testing Blazor components.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: The next section shows how to put into practice what you have learned by implementing
    a simple application.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Use case – implementing a simple application in Blazor WebAssembly
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will implement a package search application for the *WWTravelClub*
    book use case. The first subsection explains how to set up the solution exploiting
    the domain layer and data layer we already implemented in *Chapter 15*, *Presenting*
    *ASP.NET* *Core MVC*.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the solution
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all, create a copy of the **PackagesManagement** solution folder we
    created in *Chapter 15*, *Presenting ASP.NET Core MVC*, and rename it **PackagesManagementBlazor**.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Open the solution, right-click on the Web project (the one named **PackagesManagement**)
    and remove it. Then, go to the solution folder and delete the whole Web project
    folder (the one named **PackagesManagement**).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Now right-click on the solution and select **Add New project**. Add a new Blazor
    WebAssembly project called **PackagesManagementBlazor**. Select **no authentication**
    and **ASP.NET Core hosted**. We don't need authentication since the search-by-location
    feature we are going to implement must also be available to unregistered users.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that the **PackagesManagementBlazor.Server** project is the start project
    (its name should be in bold). If it is not, right-click on it and click on **Set
    as Start Project**.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: The server project needs to reference both the data (**PackagesManagementDB**)
    and the domain (**PackagesManagementDomain**) projects, so please add them as
    references.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also copy the same connection string of the old web project into the
    `PackagesManagementBlazor.Serverappsettings.json` file:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This way, we can reuse the database we already created. We also need to add
    the same DDD tools we added to the old web project. Add a folder named `Tools`
    in the project root and copy the content of the `ch12->ApplicationLayer` folder
    of the GitHub repository associated with the book there.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to finish the solution setup, we just need to connect **PackagesManagementBlazor.Server**
    with the domain layer by adding the following code at the end of the `ConfigureServices`
    method in the `Startup.cs` file:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'It is the same method we added to the old Web project. Finally, we can also
    add the `AddAllQueries` extension method, which discovers all queries in the Web
    project:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We don't need other automatic discovery tools since this is a query-only application.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection explains how to design the server-side REST API.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the required ASP.NET Core REST APIs
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the first step, let's define the ViewModels used in the communication between
    the server and the client applications. They must be defined in the **PackagesManagementBlazor.Shared**
    project that is referenced by both applications.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the `PackageInfosViewModel` ViewModel:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Then, add also the ViewModel that encloses all packages to return to the Blazor
    application:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now we can also add our query that searches packages by location. Let''s add
    a `Queries` folder in the root of the **PackagesManagementBlazor.Server** project,
    and then add the interface that defines our query, `IPackagesListByLocationQuery`:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Finally, let''s also add the query implementation:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We are finally ready to define our `PackagesController`:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The server-side code is finished! Let's move on to the definition of the Blazor
    service that communicates with the server.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the business logic in a service
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s add a `ViewModels` and a `Services` folder to the **PackagesManagementBlazor.Client**
    project. Most of the ViewModels we need were already defined in the **PackagesManagementBlazor.Shared**
    project. We only need a ViewModel for the search form. Let''s add it to the `ViewModels`
    folder:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Let''s call our service `PackagesClient`, and let''s add it to the `Services`
    folder:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The code is straightforward! The `Uri.EscapeDataString` method url-encodes the
    parameter so it can be safely appended to the URL.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s register the service in the dependency injection:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: It is worth pointing out that in a commercial application, we should have registered
    the service through an `IPackagesClient` interface, in order to be able to mock
    it in the tests (`.AddScoped<IPackagesClient, PackagesClient>()`).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Everything is in place; we just need to build the UI.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the user interface
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the first step, let's delete application pages we don't need, namely, `Pages->Counter.razor`
    and `Pages->FetchData.razor`. Let's also remove their links from the side menu
    in `Shared->NavMenu.razor`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 'We will put our code in the `Pages->Index.razor` page. Let''s replace the code
    of this page with this:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The preceding code adds the needed `@using`, injects our `PackagesClient` service
    in the page, and defines the search form. When the form is successfully submitted,
    it invokes the `Search` callback where we will place the code that retrieves all
    the results.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'It is time to add the logic to display all the results and to complete the
    `@code` block. The following code must be placed immediately after the search
    form:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The omitted code in the `if` block is responsible for rendering a table with
    all the results. We will show it after having commented the preceding code.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Before retrieving the results with the `PackagesClient` service, we remove all
    previous results and set the `loading` field, so the Razor code selects the `else
    if` path that replaces the previous table with a loading message. Once we've set
    these variables, we are forced to call `StateHasChanged` to trigger change detection
    and to refresh the page. After all the results have been retrieved and the callback
    returns, there is no need to call `StateHasChanged` again because the termination
    of the callback itself triggers change detection and causes the required page
    refresh.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the code that renders the table with all the results:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Run the project and write the initial characters of Florence. Since in previous
    chapters, we inserted Florence as a location in the database, some results should
    appear!
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned what a SPA is and learned how to build a SPA based
    on the Blazor WebAssembly framework. The first part of the chapter described Blazor
    WebAssembly architecture, and then the chapter explained how to exchange input/output
    with Blazor components, and the concept of binding.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: After having explained Blazor's general principles, the chapter focused on how
    to get user input while furnishing the user with adequate feedback and visual
    clues in the event of errors. Then, the chapter furnished a short description
    of advanced features, such as JavaScript interoperability, globalization, authentication
    with authorization, and client-server communication.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a practical example taken from the book user case shows how to use
    Blazor in practice to implement a simple touristic package search application.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is WebAssembly?
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an SPA?
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the Blazor `router` component?
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a Blazor page?
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the `@namespace` directive?
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an `EditContext`?
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the right place to initialize a component?
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the right place to process the user input?
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the `IJSRuntime` interface?
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of `@ref`?
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Blazor official documentation is available at: [https://docs.microsoft.com/en-US/aspnet/core/blazor/webassembly-lazy-load-assemblies](https://docs.microsoft.com/en-US/aspnet/core/blazor/webassembly-lazy-load-assemblies).'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Assemblies'' lazy loading is described at: [https://docs.microsoft.com/en-US/aspnet/core/blazor/webassembly-lazy-load-assemblies](https://docs.microsoft.com/en-US/aspnet/core/blazor/webassembly-lazy-load-assemblies).'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All HTML events supported by Blazor together with their event arguments are
    listed at: [https://docs.microsoft.com/en-US/aspnet/core/blazor/components/event-handling?#event-argument-types](https://docs.microsoft.com/en-US/aspnet/core/blazor/components/event-handling?#event-argument-types).'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Blazor supports the same validation attributes as ASP.NET MVC, with the exception
    of the `RemoteAttribute`: [https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation#built-in-attributes](https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation#built-in-attributes).'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A description of the `InputFile` component, and how to use it, can be found
    here: [https://docs.microsoft.com/en-US/aspnet/core/blazor/file-uploads](https://docs.microsoft.com/en-US/aspnet/core/blazor/file-uploads).'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More details on Blazor localization and globalization are available here: [https://docs.microsoft.com/en-US/aspnet/core/blazor/globalization-localization](https://docs.microsoft.com/en-US/aspnet/core/blazor/globalization-localization).'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More details on Blazor authentication are available here, and on all its related
    URLs: [https://docs.microsoft.com/en-US/aspnet/core/blazor/security/webassembly/](https://docs.microsoft.com/en-US/aspnet/core/blazor/security/webassembly/).'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
