- en: Introduction to WebAssembly and Emscripten
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the exciting new world of WebAssembly! These are early days for WebAssembly,
    but the technology is currently taking off like a rocket, and by reading this
    book, you are in a position to get in on the ground floor. If you are interested
    in game development on the web, or you are interested in learning as much about
    this new technology as you can to position yourself for when it does reach maturity,
    you are in the right place. Even though WebAssembly is in its infancy, all major
    browser vendors have adopted it. These are early days and use cases are limited,
    but lucky for us, game development is one of them. So, if you want to be early
    to the party for the next generation of application development on the web, read
    on, adventurer!
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I will introduce you to WebAssembly, Emscripten, and some of
    the underlying technologies around WebAssembly. I will teach you the basics of
    the Emscripten toolchain, and how you can use Emscripten to compile C++ code into
    WebAssembly. We will discuss what LLVM is and how it fits into the Emscripten
    toolchain. We will talk about WebAssembly's **Minimum Viable Product** (**MVP**),
    the best use cases for WebAssembly in its current MVP form, and what will soon
    be coming to WebAssembly. I will introduce **WebAssembly text** (**.wat**), how
    we can use it to understand the design of WebAssembly bytecode, and how it differs
    from other machine bytecodes. We will also briefly discuss **asm.js**, and its
    historical significance in the design of WebAssembly. Finally, I will show you
    how to install and run Emscripten on Windows and Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is WebAssembly?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why do we need WebAssembly?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why is WebAssembly faster than JavaScript?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Will WebAssembly replace JavaScript?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is asm.js?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A brief introduction to LLVM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A brief introduction to WebAssembly text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Emscripten and how do we use it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is WebAssembly?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebAssembly is not a high-level programming language like JavaScript, but a
    compiled binary format that all major browsers are currently able to execute.
    WebAssembly is a kind of machine bytecode that was not designed to run directly
    on any real machine hardware, but runs in the JavaScript engine built into every
    browser. In some ways, it is similar to the old **Java Virtual Machine** (**JVM**);
    for example, it is a platform-independent compiled bytecode. One major problem
    with JavaScript bytecode is its requirement for a plugin to be downloaded and
    installed in the browser for the bytecode to run. Not only is **WebAssembly**
    designed to be run directly in a browser without a plugin, but it is also intended
    to produce a compact binary format that executes efficiently inside a web browser.
    The MVP version of the specification leverages existing work by the browser makers
    designing their JavaScript **just-in-time** (**JIT**) compiler. WebAssembly is
    currently a young technology and many improvements are planned. However, developers
    using the current version of WebAssembly have already seen performance improvements
    over JavaScript of 10–800%.
  prefs: []
  type: TYPE_NORMAL
- en: 'An MVP is the smallest set of features that can be given to a product to allow
    it to appeal to early adopters. Because the current version is an MVP, the feature
    set is small. For more information, see this excellent article discussing the
    "post-MVP future" of WebAssembly: [https://hacks.mozilla.org/2018/10/webassemblys-post-mvp-future/](https://hacks.mozilla.org/2018/10/webassemblys-post-mvp-future/).'
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need WebAssembly?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript has been around for a long time. It has evolved from a little scripting
    language that allowed bells and whistles to be added to a web page, to a sprawling
    JIT compiled language with a massive ecosystem that can be used to write fully
    fledged applications. Today, JavaScript is doing a lot of things that were probably
    never imagined when it was created by Netscape in 1995\. JavaScript is an interpreted
    language, meaning that it must be parsed, compiled, and optimized on the fly.
    JavaScript is also a dynamically typed language, which creates headaches for an
    optimizer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Franziska Hinkelmann, a member of the Chrome V8 team, gave a great talk at
    the *Web Rebels 2017* conference where she discusses all the performance improvements
    made to JavaScript over the past 20 years, as well as the difficulties they had
    in squeezing every bit of performance imaginable out of the JavaScript V8 engine:
    [https://youtu.be/ihANrJ1Po0w](https://youtu.be/ihANrJ1Po0w).'
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly solves a lot of the problems created by JavaScript and its long
    history in the browser. Because the JavaScript engine is already in bytecode format,
    it does not need to run a parser, which removes a significant bottleneck in the
    execution of our application. This design also allows the JavaScript engine to
    know what data types it is dealing with at all times. The bytecode makes optimization
    a lot easier. The format allows multiple threads in the browsers to work on compiling
    and optimizing different parts of the code at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a detailed explanation of what is happening when the Chrome V8 engine is
    parsing code, please refer to this video from the *JSConf EU 2017*, in which Marja
    Hölttä (who works on the Chrome V8 tool) goes into more detail than you ever imagined
    you wanted to learn about parsing JavaScript: [https://www.youtube.com/watch?v=Fg7niTmNNLg&t=123s](https://www.youtube.com/watch?v=Fg7niTmNNLg&t=123s).'
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly is not a high-level programming language, but a binary file with
    opcodes for a virtual machine. Currently, it is considered to be in an MVP stage
    of development. The technology is still in its infancy, but even now it offers
    notable performance and file size benefits for many use cases, such as game development.
    Because of the current limitations of WebAssembly, we have only two choices for
    languages to use for its development—C/C++ or Rust. The long-term plan for WebAssembly
    is to support a wide selection of programming languages for its development. If
    I wanted to write at the lowest level of abstraction, I could write everything
    in **Web Assembly Text** (**WAT**), but WAT was developed as a language to support
    debugging and testing and was not intended to be used by developers for writing
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Why is WebAssembly faster than JavaScript?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I have mentioned, WebAssembly is 10–800% faster than JavaScript, depending
    on the application. To understand why, I need to talk a little about what a JavaScript
    engine does when it runs JavaScript code versus what it has to do when it runs
    WebAssembly. I am going to talk specifically about V8 (the Chrome JavaScript engine),
    although, to my knowledge, the same general process exists within SpiderMonkey
    (Firefox) and the Chakra (IE & Edge) JavaScript engines.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing the JavaScript engine does is parse your source code into an
    **Abstract Syntax Tree** (**AST**). The source is broken into branches and leaves
    based on the logic within your application. At this point, an interpreter starts
    processing the language that you are currently executing. For many years, JavaScript
    was just an interpreted language, so, if you ran the same code in your JavaScript
    100 times, the JavaScript engine had to take that code and convert it to machine
    code 100 times. As you can imagine, this is wildly inefficient.
  prefs: []
  type: TYPE_NORMAL
- en: The Chrome browser introduced the first JavaScript JIT compiler in 2008\. A
    JIT compiler contrasts with an **Ahead-of-Time** (**AOT**) compiler in that it
    compiles your code as it is running that code. A profiler sits and watches the
    JavaScript execution looking for code that repeatedly executes. Whenever it sees
    code executed a few times, it marks that code as "warm" for JIT compilation. The
    compiler then compiles a bytecode representation of that JavaScript "stub" code.
    This bytecode is typically an **Intermediate Representation** (**IR**), one step
    removed from the machine-specific assembly language. Decoding the stub will be
    significantly faster than running the same lines of code through our interpreter
    the next time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps needed to run JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9dd90a0a-c663-46b1-9fa2-977cf4d76ee7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: Steps required by a modern JavaScript engine'
  prefs: []
  type: TYPE_NORMAL
- en: While all of this is going on, there is an **optimizing compiler** that is watching
    the profiler for "hot" code branches. The optimizing compiler then takes these
    code branches and optimizes the bytecode that was created by the JIT into highly
    optimized machine code. At this point, the JavaScript engine has created some
    super fast running code, but there is a catch (or maybe a few).
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript engine must make some assumptions about the data types to have
    an optimized machine code. The problem is, JavaScript is a dynamically typed language.
    Dynamic typing makes it easier for a programmer to learn how to program JavaScript,
    but it is a terrible choice for code optimizers. The example I often see is what
    happens when JavaScript sees the expression `c = a + b` (although we could use
    this example for almost any expression).
  prefs: []
  type: TYPE_NORMAL
- en: 'Just about any machine code that performs this operation does it in three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Load the `a` value into a register.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `b` value into a register.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then store the register into `c`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following pseudo code was taken from section 12.8.3 of the *ECMAScript®
    2018 Language Specification* and describes the code that must run whenever the
    addition operator (+) is used within JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can find the *ECMAScript® 2018 Language Specification* on the web at [https://www.ecma-international.org/ecma-262/9.0/index.html](https://www.ecma-international.org/ecma-262/9.0/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'This pseudo code is not the entirety of what we must evaluate. Several of these
    steps are calling high-level functions, not running machine code commands. `GetValue`
    for example, has 11 steps of its own that are, in turn, calling other steps. All
    of this could end up resulting in hundreds of machine opcodes. The vast majority
    of what is happening here is type checking. In JavaScript, when you execute `a
    + b`, each one of those variables could be any one of the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: Integer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Float
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any combination of these
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To make matters worse, objects in JavaScript are also highly dynamic. For example,
    maybe you have defined a function called `Point` and created two objects with
    that function using the new operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have two points that share the same class. Say we added this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This would mean that these two points would then no longer share the same class.
    Effectively, `p2` has become a brand new class, and this has consequences for
    where that object exists in memory and available optimizations. JavaScript was
    designed to be a highly flexible language, but this fact creates a lot of corner
    cases, and corner cases make optimization difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Another problem with optimization created by the dynamic nature of JavaScript
    is that no optimization is definitive. All optimizations around typing have to
    use resources continually checking to see whether their typing assumptions are
    still valid. Also, the optimizer has to keep the non-optimized code just in case
    those assumptions turn out to be false. The optimizer may determine that assumptions
    made initially turn out not to have been correct assumptions. That results in
    a "bailout" where the optimizer will throw away its optimized code and deoptimize,
    causing performance inconsistencies.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, JavaScript is a language with **Garbage Collection** (**GC**), which
    allows the authors of the JavaScript code to take on less of the burden of memory
    management while writing their code. Although this is a convenience for the developer,
    it just pushes the work of memory management on to the machine at run time. GC
    has become much more efficient in JavaScript over the years, but it is still work
    that the JavaScript engine must do when running JavaScript that it does not need
    to do when running WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: Executing a WebAssembly module removes many of the steps required to run JavaScript
    code. WebAssembly eliminates parsing because the AOT compiler completes that function.
    An interpreter is unnecessary. Our JIT compiler is doing a near one-to-one translation
    from bytecode to machine code, which is extremely fast. JavaScript requires the
    majority of its optimizations because of dynamic typing that does not exist in
    WebAssembly. Hardware agnostic optimizations can be done in the AOT compiler before
    the WebAssembly compiles. The JIT optimizer need only perform hardware-specific
    optimizations that the WebAssembly AOT compiler cannot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps performed by the JavaScript engine to run a WebAssembly
    binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1d7fb906-b411-416d-a1a2-b32a2812d1ac.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.2: The steps required to execute WebAssembly'
  prefs: []
  type: TYPE_NORMAL
- en: The last thing that I would like to mention is not a feature of the current
    MVP, but a potential future enabled by WebAssembly. All the code that makes modern
    JavaScript fast takes up memory. Keeping old copies of the nonoptimized code for
    bailout takes up memory. Parsers, interpreters, and garbage collectors all take
    up memory. On my desktop, Chrome frequently takes up about 1 GB of memory. By
    running a few tests on my website using [https://www.classicsolitaire.com](https://www.classicsolitaire.com),
    I can see that with the JavaScript engine turned on, the Chrome browser takes
    up about 654 MB of memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a Task Manager screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d052928-1b7a-4284-a3c1-f65bae8e02e6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.3: Chrome Task Manager process screenshot with JavaScript'
  prefs: []
  type: TYPE_NORMAL
- en: With JavaScript turned off, the Chrome browser takes up about 295MB.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a Task Manager screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a92e10a-f57d-4275-92d0-09154ab9b9ea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.4: Chrome Task Manager process screenshot without JavaScript'
  prefs: []
  type: TYPE_NORMAL
- en: Because this is one of my websites, I know there are only a few hundred kilobytes
    of JavaScript code on that website. It's a little shocking to me that running
    that tiny amount of JavaScript code can increase my browser footprint by about
    350 MB. Currently, WebAssembly runs on top of the existing JavaScript engines
    and still requires quite a bit of JavaScript glue code to make everything work,
    but in the long run, WebAssembly will not only allow us to speed up execution
    on the web but will also let us do it with a much smaller memory footprint.
  prefs: []
  type: TYPE_NORMAL
- en: Will WebAssembly replace JavaScript?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The short answer to this question is not anytime soon. At present, WebAssembly
    is still in its MVP stage. At this stage, the number of use cases is limited to
    applications where WebAssembly has limited back and forth with the JavaScript
    and the **D****ocument Object Model** (**DOM**). WebAssembly is not currently
    able to directly interact with the DOM, and Emscripten uses JavaScript "glue code"
    to make that interaction work. That interaction will probably change soon, possibly
    by the time you are reading this, but in the next few years, WebAssembly will
    need additional features to increase the number of possible use cases.
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly is not a "feature complete" platform. Currently, it cannot be used
    with any languages that require GC. That will change and, eventually, almost all
    strongly typed languages will target WebAssembly. In addition, WebAssembly will
    soon become tightly integrated with JavaScript, allowing frameworks such as React,
    Vue, and Angular to begin replacing significant amounts of their JavaScript code
    with WebAssembly without impacting the **application programming interface** (**API**).
    The React team is currently working on this to improve the performance of React.
  prefs: []
  type: TYPE_NORMAL
- en: In the long run, it is possible that JavaScript may compile into WebAssembly.
    For technical reasons, this is a very long way off. Not only does JavaScript require
    a GC (not currently supported), but because of its dynamic nature, JavaScript
    also requires a runtime profiler to optimize. Therefore, JavaScript would produce
    very poorly optimized code, or significant modifications would be needed to support
    strict typing. It is more likely that a language, such as TypeScript, will add
    features that allow it to compile into WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: The *AssemblyScript* project in development on GitHub is working on a TypeScript-to-WebAssembly
    compiler. This project creates JavaScript and uses Binaryen to compile that JavaScript
    into WebAssembly. How AssemblyScript handles the problem of garbage collection
    is unclear. For more information, refer to [https://github.com/AssemblyScript/assemblyscript](https://github.com/AssemblyScript/assemblyscript).
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is currently ubiquitous on the web; there are a tremendous number
    of libraries and frameworks developed in JavaScript. Even if there were an army
    of developers eager to rewrite the entire web in C++ or Rust, WebAssembly is not
    yet ready to replace these JavaScript libraries and frameworks. The browser makers
    have put immense efforts into making JavaScript run (relatively) fast, so JavaScript
    will probably remain as the standard scripting language for the web. The web will
    always need a scripting language, and countless developers have already put in
    the work to make JavaScript that scripting language, so it seems unlikely that
    JavaScript will ever go away.
  prefs: []
  type: TYPE_NORMAL
- en: There is, however, a need for a compiled format for the web that WebAssembly
    is likely to fulfill. Compiled code may be a niche on the web at the moment, but
    it is a standard just about everywhere else. As WebAssembly approaches feature-complete
    status, it will offer more choices and better performance than JavaScript, and
    businesses, frameworks, and libraries will gradually migrate toward it.
  prefs: []
  type: TYPE_NORMAL
- en: What is asm.js?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One early attempt to achieve native-like speed in the web browser using JavaScript
    was asm.js. Although that goal was reached and asm.js was adopted by all the major
    browser vendors, it never achieved widespread adoption by developers. The beauty
    of asm.js is that it still runs in most browsers, even in those that do not optimize
    for it. The idea behind asm.js was that typed arrays could be used in JavaScript
    to fake a C++ memory heap. The browser simulates pointers and memory allocation
    in C++, as well as types. A well-designed JavaScript engine can avoid dynamic
    type checking. Using asm.js, browser makers could get around many of the optimization
    problems created by the dynamic nature of JavaScript, by just pretending that
    this version of JavaScript is not dynamically typed. Emscripten, designed as a
    C++-to-JavaScript compiler, quickly adopted asm.js as the subset of JavaScript
    that it would compile to because of its improved performance in most browsers.
    The performance improvements driven by asm.js lead the way to WebAssembly. The
    same engine modifications used to make asm.js perform well could be used to bootstrap
    the WebAssembly MVP. Only the addition of a bytecode-to-bytecode compiler was
    required to take the WebAssembly bytecode and directly convert it into the IR
    bytecode used by the browser.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, Emscripten does not compile directly from LLVM to WebAssembly.
    Instead, it compiles to asm.js and uses a tool called Binaryen to convert the
    asm.js output from Emscripten into WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: A brief introduction to LLVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Emscripten is the tool we will be using to compile C++ into WebAssembly. Before
    I discuss Emscripten, I need to explain a technology called LLVM and its relationship
    to Emscripten.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, take a moment to think of airlines (stay with me here). Airlines want
    to get passengers from one airport to another airport. But it''s challenging to
    offer a direct flight from every single airport to every other airport on Earth.
    That would mean that airlines would have to provide a vast number of direct flights,
    such as Akron, Ohio to Mumbai, India. Let''s travel back in time to the 1990s—that
    was the state of the compiler world. If you wanted to compile from C++ to ARM,
    you needed a compiler capable of compiling C++ to ARM. If you needed to compile
    from Pascal to x86, you needed a compiler that could compile from Pascal to x86\.
    These are like having only direct flights between any two cities: a compiler for
    every combination of language and hardware. The result is either that you have
    to limit the number of languages you write compilers for, limit the number of
    platforms you can support with that language, or more likely, both.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In 2003, a student at the University of Illinois named Chris Lattner wondered,
    "What if we created a hub-and-spoke model for programming languages?" His idea
    led to LLVM, which originally stood for "Low-Level Virtual Machine." The idea
    was that, instead of compiling your source code for any possible distribution,
    you compile it for LLVM. There are then compilers between the intermediate language
    and your final output language. In theory, this means that if you develop a new
    target platform on the right side of the following diagram, you get all languages
    on the left side right away:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e5aaec1e-100f-4f61-9bb7-d072053b93dc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.5: LLVM as a hub between programming languages and the hardware'
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about LLVM, visit the LLVM project home page at [https://llvm.org](https://llvm.org)
    or read the *LLVM Cookbook*, *Mayur Padney*, *and Suyog Sarda*, *Packt Publishing*:
    [https://www.packtpub.com/application-development/llvm-cookbook](https://www.packtpub.com/application-development/llvm-cookbook).'
  prefs: []
  type: TYPE_NORMAL
- en: A brief introduction to WebAssembly text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebAssembly binary is not a language, but a build target similar to building
    for ARM or x86\. The bytecode, however, is structured differently than other hardware-specific
    build targets. The designers of the WebAssembly bytecode had the web in mind.
    The aim was to create a bytecode that was compact and streamable. Another goal
    was that the user should be able to do a "view/source" on the WebAssembly binary
    to see what is going on. WebAssembly text is a companion code to the WebAssembly
    binary that allows the user to view the bytecode instructions in a human-readable
    form, similar to the way an assembly language would let you see what opcodes execute
    in a machine-readable form.
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly text may initially look unfamiliar to someone used to writing assembly
    for hardware such as ARM, x86, or 6502 (if you're old school). You write WebAssembly
    text in S-expressions, which has a parentheses-heavy tree structure. Some of the
    operations are also strikingly high level for an assembly language, such as if/else
    and loop opcodes. That makes a lot more sense if you remember that WebAssembly
    was not designed to run directly on computer hardware, but to download and translate
    into machine code quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing that will seem a little alien at first when you are dealing with
    WebAssembly text is the lack of registers. WebAssembly is designed to be a virtual
    *stack machine*, which is an alternative to a *register machine*, such as x86
    and ARM, with which you might be familiar. A stack machine has the advantage of
    producing significantly smaller bytecode than a register machine, which is one
    good reason to choose a stack machine for WebAssembly. Instead of using a series
    of registers to store and manipulate numbers, every opcode in a stack machine
    pushes values on or off a stack (and sometimes does both). For example, a call
    to `i32.add` in WebAssembly pulls two 32-bit integers off the stack, adds them
    together, then pushes their value back on to the stack. The computer hardware
    can make the best use of whichever registers are available to perform this operation.
  prefs: []
  type: TYPE_NORMAL
- en: Emscripten
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know what LLVM is, we can discuss Emscripten. Emscripten was developed
    to compile LLVM IR into JavaScript, but has recently been updated to compile LLVM
    into WebAssembly. The idea is that, when you get the LLVM compiler working, you
    can have the benefit of all the languages that compile to LLVM IR. In practice,
    the WebAssembly specification is still in its early days and does not support
    common language features such as GC. Therefore, only non-GC languages such as
    C/C++ and Rust are currently supported. WebAssembly is still in the early MVP
    phase of its development, but the addition of GC and other common language features
    are coming soon. When that happens, there should be an explosion of programming
    languages that will compile to WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: When Emscripten was released in 2012, it was intended to be an LLVM-to-JavaScript
    compiler. In 2013, support was added for asm.js, which is a faster, easily optimized
    subset of the JavaScript language. In 2015, Emscripten began to add support for
    LLVM-to-WebAssembly compiling. Emscripten also provides a **Software Development
    Kit** (**SDK**) for both C++ and JavaScript that provides glue code to give users
    better tools for interaction between JavaScript and WebAssembly than those currently
    offered by the WebAssembly MVP alone. Emscripten also integrates with a C/C++-to-LLVM
    compiler called Clang, so that you can compile your C++ into WebAssembly. In addition,
    Emscripten will generate the HTML and JavaScript glue code you need to get your
    project started.
  prefs: []
  type: TYPE_NORMAL
- en: Emscripten is a very dynamic project and changes to the toolchain happen frequently.
    To stay up to date with the latest changes in Emscripten, visit the project home
    page at [https://emscripten.org](https://emscripten.org).
  prefs: []
  type: TYPE_NORMAL
- en: Installing Emscripten on Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I am going to keep this section brief because these instructions are subject
    to change. You can supplement these instructions with the official Emscripten
    download and install instructions found on the Emscripten website: [https://emscripten.org/docs/getting_started/downloads.html](https://emscripten.org/docs/getting_started/downloads.html).'
  prefs: []
  type: TYPE_NORMAL
- en: We will need to download and build Emscripten from the emsdk source files on
    GitHub. First, we will walk through what to do on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python 2.7.12 or higher is a prerequisite. If you do not have a version of
    Python higher than 2.7.12 installed, you will need to get the windows installer
    from [python.org](http://python.org) and install that first: [https://www.python.org/downloads/windows/](https://www.python.org/downloads/windows/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have installed Python and you are still getting errors telling you that
    Python is not found, you may need to add Python to your Windows PATH variable.
    For more information, refer to this tutorial: [https://www.pythoncentral.io/add-python-to-path-python-is-not-recognized-as-an-internal-or-external-command/](https://www.pythoncentral.io/add-python-to-path-python-is-not-recognized-as-an-internal-or-external-command/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have Git installed already, cloning the repository is relatively simple:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to clone the repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Wherever you run this command, it will create an `emsdk` directory. Enter that
    directory using the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You may not have Git installed, in which case, the following steps will bring
    you up to speed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the following URL in a web browser: [https://github.com/emscripten-core/emsdk](https://github.com/juj/emsdk).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see a green button on the right-hand side that says Clone or download.
    Download the ZIP file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bb90bfed-56b4-4e14-a43d-455d5d850245.png)'
  prefs: []
  type: TYPE_IMG
- en: Unzip the downloaded file to the `c:\emsdk` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open up a Windows Command Prompt by typing `cmd` into the start menu and pressing
    *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From there, you can change to the `c:\emsdk\emsdk-master` directory by typing
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, it does not matter whether you had Git installed or not. Let''s
    move forward:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `emsdk` from the source code running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then activate the latest `emsdk`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, set up our path and environment variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This last step will need to be rerun from your install directory every time
    you open a new command-line window. Unfortunately, it does not permanently set
    the Windows environment variables. Hopefully, that will change in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Emscripten on Ubuntu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are installing on Ubuntu, you should be able to use the `apt-get` package
    manager and git for the complete install. Let''s move forward:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python is required, so if you do not have Python installed, be sure to run
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you do not already have Git installed, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you will need to clone the Git repository for `emsdk`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Change your directory to move into the `emsdk` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'From here, you need to install the latest version of the SDK tools, activate
    it, and set your environment variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To make sure everything was installed correctly, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Using Emscripten
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We run Emscripten from the command line; therefore, you can use any text editor
    you choose to write your C/C++ code. Personally, I am partial to Visual Studio
    Code, which you can download here: [https://code.visualstudio.com/download](https://code.visualstudio.com/download).'
  prefs: []
  type: TYPE_NORMAL
- en: One beautiful thing about Visual Studio Code is that it has a built-in command-line
    terminal, which lets you compile your code without switching windows. It also
    has an excellent C/C++ extension that you can install. Just search for C/C++ from
    the extensions menu and install the Microsoft C/C++ Intellisense extension.
  prefs: []
  type: TYPE_NORMAL
- en: Whatever you choose for your text editor or integrated development environment,
    you need a simple piece of C code to test out the emcc compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new text file and name it `hello.c`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type the following code into `hello.c`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now I can compile the `hello.c` file into WebAssembly and generate a `hello.html`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `--emrun` flag is necessary if you want to run the HTML page from `emrun`.
    This flag adds code that will capture `stdout`, `stderr`, and exit in the C code
    and `emrun` will not work without it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Running `emrun` with the `--browser` flag will pick the browser where you would
    like to run the script. The behavior of `emrun` seems to be different between
    browsers. Chrome will close the window when the C program exits. That can be annoying
    because we are just trying to display a simple print message. If you have Firefox,
    I would suggest running `emrun` using the `--browser` flag.
  prefs: []
  type: TYPE_NORMAL
- en: I do not want to imply that Chrome cannot run WebAssembly. Chrome does have
    different behavior when a WebAssembly module exits. Because I was trying to keep
    our WebAssembly module as simple as possible, it exits when the main function
    completes. That is what is causing problems in Chrome. These problems will go
    away later when we learn about game loops.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find out what browsers are available to you, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`emrun` should open an Emscripten-templated HTML file in a browser.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you have a browser capable of running WebAssembly. The following
    versions of the major browsers should work with WebAssembly:'
  prefs: []
  type: TYPE_NORMAL
- en: Edge 16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firefox 52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chrome 57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Safari 11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opera 44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are familiar with setting up your own web server, you may want to consider
    using it rather than emrun. After using emrun for the first few chapters of this
    book, I returned to using my Node.js web server. I found it easier to have a Node-based
    web server up and running at all times, rather than restarting the emrun web server
    every time I wanted to test my code. If you know how to set up an alternative
    web server (such as one for Node, Apache, and IIS), you may use whatever web server
    you prefer. Although IIS requires some additional configuration to handle WebAssembly
    MIME types.
  prefs: []
  type: TYPE_NORMAL
- en: Additional installation resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating an installation guide for Emscripten is going to be somewhat problematic.
    The WebAssembly technology changes frequently and the installation process for
    Emscripten may be different by the time you read this. I would recommend consulting
    the download and install instructions on the Emscripten website if you have any
    problems: [https://emscripten.org/docs/getting_started/downloads.html](https://emscripten.org/docs/getting_started/downloads.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You may also want to consult the Emscripten page on GitHub: [https://github.com/emscripten-core/emsdk](https://github.com/emscripten-core/emsdk).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Google Groups has an Emscripten discussion forum where you may ask questions
    if you are having installation problems: [https://groups.google.com/forum/?nomobile=true#!forum/emscripten-discuss](https://groups.google.com/forum/?nomobile=true#!forum/emscripten-discuss).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also contact me on Twitter (`@battagline`), and I will do my best to
    help you: [https://twitter.com/battagline](https://twitter.com/battagline).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned what WebAssembly is and why it will be the future
    of application development on the web. We learned why we need WebAssembly, even
    though we already have a robust language like JavaScript. We learned why WebAssembly
    is so much faster than JavaScript, and how it has the potential to increase its
    performance lead. We have also discussed the possibility of WebAssembly replacing
    JavaScript as the de facto standard for application development on the web.
  prefs: []
  type: TYPE_NORMAL
- en: We have discussed the practical side of creating a WebAssembly module as it
    is done today using Emscripten and LLVM. We have talked about WebAssembly text
    and how it is structured. We have also discussed using Emscripten to compile our
    first WebAssembly module, as well as using it to create the HTML and JavaScript
    glue code to run that module.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will go into further detail on how to use Emscripten
    to create our WebAssembly module, as well as the HTML/CSS and JavaScript used
    to drive it.
  prefs: []
  type: TYPE_NORMAL
