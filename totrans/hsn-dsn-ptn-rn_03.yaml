- en: Styling Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's time to add some looks to our applications. In this chapter, we will explore
    unique styling solutions and mechanisms. React Native StyleSheet may resemble
    web **cascading style sheets** (**CSS**); however, Native application styling
    is different. Similarities in the syntax quickly end and you should spend some
    time with this chapter to learn the basics of styling. Later on in this book,
    we will use an external library that provides ready-made styles. It is crucial
    for you to understand how to make such components yourself, especially if you
    plan to work professionally in React Native in teams who deliver custom designs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Styling components in the React Native environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with limited style inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using density-independent pixels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Positioning elements with Flexbox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling long text issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making animations using the Animated library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measuring your application's speed using the **Frames Per Second** (**FPS**)
    metric
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As in the previous chapters, I have separated every example into a standalone
    application that you can launch on your phone or simulator. To do the examples,
    you will need  the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Simulator or Android/iOS smartphone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git to pull the examples: [https://github.com/Ajdija/hands-on-design-patterns-with-react-native](https://github.com/Ajdija/hands-on-design-patterns-with-react-native).
    Follow the installation instructions from the GitHub page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How React Native styles work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"The core premise for React is that UIs are simply a projection of data into
    a different form of data. The same input gives the same output. A simple pure
    function."'
  prefs: []
  type: TYPE_NORMAL
- en: '- React library README ([https://github.com/reactjs/react-basic/blob/master/README.md](https://github.com/reactjs/react-basic/blob/master/README.md)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will learn about pure functions later in this book. Check out the following
    example to understand the basics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Going back to more practical examples, let's see how the preceding premise is
    implemented in React Native.
  prefs: []
  type: TYPE_NORMAL
- en: '"With React Native, you don''t use a special language or syntax for defining
    styles. You just style your application using JavaScript. All of the core components
    accept a prop named `style`. The style names and values usually match how CSS
    works on the web, except names are written using camel casing, e.g backgroundColor
    rather than background-color.'
  prefs: []
  type: TYPE_NORMAL
- en: The style prop can be a plain old JavaScript object. (...) You can also pass
    an array of styles - the last style in the array has precedence, so you can use
    this to inherit styles.
  prefs: []
  type: TYPE_NORMAL
- en: As a component grows in complexity, it is often cleaner to use StyleSheet.create
    to define several styles in one place."
  prefs: []
  type: TYPE_NORMAL
- en: '- React Native official documentation ([https://facebook.github.io/react-native/docs/style.html](https://facebook.github.io/react-native/docs/style.html)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum up, we have three ways of defining the component style:'
  prefs: []
  type: TYPE_NORMAL
- en: Using style props and passing an object with key-value pairs that represent
    styles.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using style props and passing an array of objects. Each object should contain
    key-value pairs that represent styles. The last style in the array has precedence.
    Use this mechanism to inherit styles or shadow them as you would shadow functions
    and variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the StyleSheet component and its `create` function to create styles.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, you can find all three ways of defining styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Pay attention to the use case with array of objects. You may combine previously-learned
    tricks to achieve conditional styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, let''s discuss why we use the `StyleSheet` component instead of inline
    styles:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Code quality:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By moving styles away from the render function, you're making the code easier
    to understand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Naming the styles is a good way to add meaning to the low-level components in
    the render function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Performance:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a `stylesheet` from a `style` object makes it possible to refer to it
    by ID instead of creating a new style object every time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It also allows you to send the style only once through the bridge. All subsequent
    uses are going to refer an ID (not implemented yet).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '- React Native official documentation'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://facebook.github.io/react-native/docs/stylesheet.html](https://facebook.github.io/react-native/docs/stylesheet.html).'
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the quality and reusability, StyleSheet decouples styles and
    component markup. You could even extract these styles away to a separate file.
    Also, as mentioned in the documentation, it allows you to make your markup easier
    to understand. Instead of a huge styling object, you can see a meaningful name,
    such as **`styles.activeLink`**.
  prefs: []
  type: TYPE_NORMAL
- en: If you undervalue decoupling in your applications, then try to grow your code
    base beyond 5,000 lines. You will likely see that some tightly-coupled code will
    need hacks to be reusable. Bad practices will snowball, making the code base very
    hard to maintain. In backend systems, it usually goes hand-in-hand with monolithic
    structures. The amazing idea that comes to the rescue is Microservices. Learn
    more at [https://en.wikipedia.org/wiki/Microservices](https://en.wikipedia.org/wiki/Microservices)[.](https://en.wikipedia.org/wiki/Microservices)
  prefs: []
  type: TYPE_NORMAL
- en: Surprising styles inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we start to use styles, it is vital to understand that React Native styles
    do not work as a website's CSS. Especially when it comes to inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Styles of the parent component are not inherited unless it is a `Text` component.
    If it is a `Text` component, it will inherit from parent, only if parent is another
    `Text` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you run this code, you will see that the displayed text is green and that
    the later part is also big. `Text` with a big style inherited the green colour
    from the parent `Text` component. Please also note that the whole text is rendered
    inside of a `View` component that has a margin top of 40 dp that is density-independent
    pixels. Jump to the *Learning unitless dimensions* section to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: Workaround for limited inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine a situation where you would like to reuse the same font across the whole
    application. Given the mentioned inheritance limitations, how would you do that?
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is a mechanism that we have learned already: component composition.
    Let''s create a component that satisfies our requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `AppText` component just wraps the `Text` component and specifies its styles.
    In this simple example, it's just `fontFamily`.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the `fontFamily` key in `style` object accepts String values
    and may differ between platforms (some are accepted on Android and some are accepted
    on iOS). For consistency, you may need to use a custom font. The setup is rather
    easy but takes a while and so exceeds the design patterns topic of this book.
    To learn more, visit [https://docs.expo.io/versions/latest/guides/using-custom-fonts](https://docs.expo.io/versions/latest/guides/using-custom-fonts).
  prefs: []
  type: TYPE_NORMAL
- en: Think about how to edit `AppText` to support custom styles so that it will be
    possible to override specified keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Is the style object override the best solution in this case? Perhaps not; you
    have created this component to unify styles, not to allow overrides. But, you
    may say that it could be needed to create another component, such as `HeaderText`
    or something similar. You need a way to reuse existing styles and still enlarge
    the text. Luckily, you can still use `Text` inheritance here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Hence, `HeaderText` would be very simple to implement. Check the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Learning unitless dimensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn the dimensions in which React Native applications
    are measured onscreen.
  prefs: []
  type: TYPE_NORMAL
- en: '"The simplest way to set the dimensions of a component is by adding a fixed
    width and height to style. All dimensions in React Native are unitless, and represent
    density-independent pixels."'
  prefs: []
  type: TYPE_NORMAL
- en: '- React Native official documentation'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://facebook.github.io/react-native/docs/height-and-width.html](https://facebook.github.io/react-native/docs/height-and-width.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike in CSS, for style properties such as `margin`, `bottom`, `top`, `left`, `right`, `height`,
    and `width`, you must provide values in dp or percentages.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s it for the documentation. But you also need to understand the following
    keywords when it comes to working with screens:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pixels**: These are the smallest single elements of the screen that can be
    controlled. Each pixel usually consists of three sub-pixels: red, green, and blue.
    These colors are usually referred to as RGB.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dimensions**: These are the width and height of the screen or window.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resolution**: This is the number of pixels in each dimension that can be
    displayed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DPI**/**PPI**: This is the number of dots/pixels that can be placed per one
    inch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Points**: This is an abstract measurement for iOS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Density-independent pixels**: This is an abstract measurement for Android.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you want to check how these concepts are implemented in Java, have a look
    at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/facebook/react-native/blob/master/ReactAndroid/src/main/java/com/facebook/react/uimanager/LayoutShadowNode.java](https://github.com/facebook/react-native/blob/master/ReactAndroid/src/main/java/com/facebook/react/uimanager/LayoutShadowNode.java).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To calculate the values, we will need `width`, `height`, and `scale`. You can
    get this information from the `Dimensions` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: However, this code is broken. Can you see why? It does not update if you rotate
    the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to force a re-render if the dimensions change. We can detect a dimension
    change by registering our own listener using `Dimensions.addEventListener`. Then
    we need to force a re-render in this listener. Usually people use `state` to do
    so. React checks `state` for changes and re-renders if that happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the result, we have one working `View` that adapts to a dimension change.
    It is done using the custom event listener that we registered using React lifecycle
    methods (`componentWillMount` and `componentWillUnmount`). However, the other,
    which uses `StyleSheet`, is not adapting. It has no access to `this.state`. StyleSheets
    are generally meant to be static to provide optimizations such as sending styles
    only once through the bridge to native.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we want our `StyleSheet` styles to adapt anyway? We can do one of the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Resign from StyleSheet and create a custom function that returns an object
    that represents styles and passes them as inline ones. It will provide similar
    decoupling if that is the goal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `styles` to override the syntax in the markup:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `StyleSheet.flatten` to override `styles` outside of the markup:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As with inline styles, beware of the performance implications. You will lose
    the optimizations when it comes to style-caching. Most likely, on every re-render,
    `styles` will be recalculated and sent over the bridge again.
  prefs: []
  type: TYPE_NORMAL
- en: Absolute and relative positioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section is on the basics of positioning things. In React Native, everything
    is `relative` by default. This means that if I nest `View` into another `View`
    that has `marginTop: 40`,  this positioning will affect my nested `View` too.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In React Native, we can also change positioning to `absolute`. Then the position
    will be calculated by a fixed number of pixels from our parent. Use the `top`/`bottom` *+*
    `left`/`right` keys in StyleSheet. Remember, other Views will not take this position
    into account. This is handy if you want to make Views overlap:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/75fd11a3-1ba8-4161-8aa5-1f214776a315.png)Three boxes overlap other
    because they are absolute-positioned to do so'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following code for the preceding example of three overlapping
    boxes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Components render according to their order in the markup, so `B3` draws over
    `B2`, and `B2` draws over `B1`.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to put some of the components on top, use the `zIndex` prop.
  prefs: []
  type: TYPE_NORMAL
- en: Check out the documentation for a more detailed explanation: [https://facebook.github.io/react-native/docs/layout-props.html#zindex](https://facebook.github.io/react-native/docs/layout-props.html#zindex).
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have three `absolute` boxes, let''s see what happens if we change `B2`
    to `relative`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Suddenly **B1** disappears:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/d073afbb-0f85-40f7-990d-b2394d3c2f8f.png)'
  prefs: []
  type: TYPE_IMG
- en: '**B2** box is now relative to its parent `View`. Hence, its position starts
    from the upper-left corner of the parent position (as we have no paddings or margins).
    The **B1** and **B2** boxes are of the same size; **B2** overlaps all of **B1**.
    If we shrink **B2** a little using `{ width: 50, height: 50 }`, we will see **B1**
    underneath. I have also changed the font size of the text of **B2** to `40` for
    clarity. Check out `App.js` in the `src/Chapter 3/Example 7` directory. The results
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7729cda8-eecf-455d-884f-8711d1fc1f63.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have learned about absolute and relative positioning, it's time
    to learn about a great pattern called Flexbox.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Flexible Box pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is one of the greatest patterns that I have learned about when it comes
    to styling. **Flexible Box** (**Flexbox**) literally make your boxes flexible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a small example. The goal is to flex your box to fill the whole
    width of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the result of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/3c8780b5-14c9-448a-911a-647f47b0b498.png)Box stretches to the whole
    screen width because we used flex: 1 styles'
  prefs: []
  type: TYPE_NORMAL
- en: It's not too fancy, but you don't need to use `Dimensions`. It is obviously
    just a start.
  prefs: []
  type: TYPE_NORMAL
- en: 'You know already that Views are relative to each other by default, so if you
    want to make some stripes, it''s as easy as stacking three `div` on top of each
    other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Check out the following screenshot to see three boxes stretched across the
    whole screen''s width:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a80a3717-b9cf-425a-b20f-46789faa7d71.png)Three boxes in a sequence,
    each stretched with flex: 1 inherited from parent View component'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s use this fairly easy concept to create header, main content, and
    footer components. To achieve that, let''s flex the middle `View`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now the middle `View` stretches to fill all available space, leaving 50 dp for
    the header `View` and another 50 for the footer `View`.
  prefs: []
  type: TYPE_NORMAL
- en: It's time to add some useful content to our divided screen.
  prefs: []
  type: TYPE_NORMAL
- en: In the next sections, I will try to explain Flexbox using examples. But please
    also check out the Flexbox Froggy game to learn flexbox in different scenarios.
    It provides an interactive editor and your goal is to move frogs onto the respective
    leaves [https://github.com/thomaspark/flexboxfroggy/](https://github.com/thomaspark/flexboxfroggy/).
  prefs: []
  type: TYPE_NORMAL
- en: Positioning items with Flexbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first important key is `flexDirection`. We can set it to `row`, `row-reverse`,
    `column`, or `column-reverse`. Flex direction makes content flow in that direction.
    By default in React Native, flex direction is set to `column`. That's why the
    boxes in the previous examples are displayed in a column.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use `flexDirection` to display three small sections in the footer: `Home`,
    `Search`, and `About`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Okay, we have three separate texts within the footer now. We will learn how to
    make them switch screens in [Chapters 7](f5f1ab36-54de-49a6-b245-e0145fe78bf0.xhtml), *Navigation
    Patterns*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our footer looks almost okay:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2f6cd514-de03-4dd3-b36e-648bb09d60ee.png)Three separate footer texts'
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to learn how to spread views evenly on the x axis. If `flexDirection`
    is set to `row` or `row-reverse`, we can use `justifyContent`. `justifyContent`
    accepts the `flex-start`, `flex-end`, `center`, `space-between`, `space-around`,
    and `space-evenly` values. We will play with them later. For now, let''s use `space-between`.
    It will stretch the `Home` view, the `Search` view, and the `About` view in such
    a fashion to leave even spaces between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/8f7c1832-79d5-43b8-a0e9-4918154164e7.png)Three texts in the footer
    are now separated with even spaces'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although it has nothing to do with flexbox, we can add some padding to make
    it nicer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It makes the text easier to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/6c961754-9a94-459a-a3c0-c7d137fae2ea.png)Padding on the right and
    left adds space from the screen edge'
  prefs: []
  type: TYPE_NORMAL
- en: What if we want to also position vertically? There is a key for that called
    `alignItems`. It accepts the `flex-start`, `flex-end`, `center`, `stretch`, and `baseline` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now make our footer higher: 100 density-independent pixels. In addition,
    we want text to be centered vertically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Check out the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7cd4d0cf-2820-4120-97ad-b1c7155d4ebe.png)Text in the footer is now
    vertically centered'
  prefs: []
  type: TYPE_NORMAL
- en: Styling flex items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we build the application, you may quickly realize the styles are a little
    bit ugly. The color palette is a complete disaster. Unless you are a designer,
    I recommend Googling a color-palette generator. I have changed the colors to be
    more palatable: white, black, and blue.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally I have added margins and paddings. Everything is nicely separated
    by a border between the header and content. Let''s check out how it looks on the
    iPhone 8 and iPhone X:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/1261aefe-5759-4bea-859d-13c5edeef2da.png)'
  prefs: []
  type: TYPE_IMG
- en: Full application look on iPhone 8 and iPhone X simulators after colour changes
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of you may not know the basics of styling, so let''s quickly explain what
    margins and paddings are. The **margin** is used to create space around an element.
    This space is created from the border of the element. You may choose top, bottom,
    left, or right if you want to apply space only there. The **padding** is very
    similar, but instead of space outside, it creates space inside. Space is created
    inside from the border. Check out the element inspector to understand this visually.
    I have inspected our app header to see how the styles work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/93cf522c-04ba-4849-a804-9a41a4a5aed1.png)'
  prefs: []
  type: TYPE_IMG
- en: Margin and padding of the Header box
  prefs: []
  type: TYPE_NORMAL
- en: In the previous screenshot, padding is marked with green, and the margin is
    marked with orange. The component space is light blue. For the exact values specified
    in styles, please look at the right part of the image.
  prefs: []
  type: TYPE_NORMAL
- en: To open the element inspector, shake your device and, when the menu opens, choose
    Toggle element inspector. If you are using the simulator, you can simulate a shake
    by choosing the hardware/shake gesture from the simulator menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the styles that I used to create `header`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's make the footer more reusable. What if, at some point, we don't
    need the About link but a Notifications link instead? This word is really long.
    It will not fit into our design. While this is a problem now, if we plan to add
    translations, we will run into this issue there too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most applications fix these issues using icons. Let''s try that:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the icon package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the footer markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The added icons can be observed on the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/10ec45dc-f0a2-4521-b2ac-7d8d8c4fd203.png)Application''s footer is
    now made of icons'
  prefs: []
  type: TYPE_NORMAL
- en: The footer is now reusable and supports any language. Check what icons mean
    in other countries if you support their language.
  prefs: []
  type: TYPE_NORMAL
- en: Styling content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have the footer positioned using the direction row. It's time to position
    the main content and column. In the previous chapters, we created a task list.
    This is the time to integrate it with our design.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `TaskList` component into the content box. I also add the `ScrollView`
    component to make content scrollable in case tasks take up too much space to display
    all of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'My tasks mock in the JSON file is presented as follows. Later on in this book,
    we will learn how to fetch tasks from a backend server and how to separate such
    logic from the markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Having the mock, we can implement the `TaskList` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`LikeCounter` is copy-pasted from `Chapter 2 / Example 8 / src` and tweaked
    to accept likes as props (replaces the default zero). Please note that it uses
    Flexbox too, and that `flexDirection` there is set to row.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are ready to style the content. Here is our starting point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ecb8b650-3477-4530-9dd7-5a4ed34dbc87.png)'
  prefs: []
  type: TYPE_IMG
- en: Current look at iPhone 8 and iPhone X simulators
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to reorganize the contents of each task. The **Like** and **Unlike**
    widget should be displayed on the right side of the task and should use icons.
    The task name should be slightly bigger than the description and should fit on
    70% of the task width. The right-hand side, with the like/dislike widget, should
    be separated by a thin grey border. The border should also separate tasks. Add
    nice paddings and margins where necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/48d8384f-5440-4237-90ff-5a8ecb6ff8cb.png)'
  prefs: []
  type: TYPE_IMG
- en: Desired look of iPhone 8 and iPhone X simulators
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, how do we start? We need to break things up into small pieces that can
    be implemented separately. Create the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A task `View` with the task-container styling and top-border styling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The two inner `Views` – one for the name and description and another for the
    like counter. These should be displayed in a row.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The name and description `View` should have two `Views` inside: one for the
    name and one for the description. Add styling to make `fontSize` bigger for name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The like counter `View` container should define the border on the left. The
    container should have two `Views` inside: one for the number of likes and another
    for the like/dislike icons. These `Views` should use column as the default direction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The View with the like/dislike icons should have row direction flexbox styling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we have that, use `alignItems` and `justifyContent` to position elements
    vertically or horizontally. Please look at helper images from the inspector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/d696a937-dffb-4a83-9bea-c81bc6f1374f.png)'
  prefs: []
  type: TYPE_IMG
- en: Inspector view of implemented components. Serves as a hint for implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The orange highlight represents the `View` margin, and the green highlight represents
    the `View` padding.
  prefs: []
  type: TYPE_NORMAL
- en: Try implementing this yourself. The full solution is available in the `src/
    Chapter_3/ Example_12/ src/` folder, in the `App.js`, `TaskList.js`, and `LikeCounter.js`
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Solving the text overflow problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most common problems is text overflow. The easiest trick to solve
    this is to wrap text, but sometimes it is not possible. Examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Button text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Large number that needs to be displayed (for instance, the  like count)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Long word that should not be broken down
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The question is: how can we approach this problem? There are many solutions.
    Let''s look at a few.'
  prefs: []
  type: TYPE_NORMAL
- en: Scaling the font down
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is possible on iOS right now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'But, the outcome is a complete disaster in our case. The layout feels very
    inconsistent, even if we put some work into this scaling solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/d8571279-3fa0-4228-9325-f04d21172d7b.png)Automatic font adjustment
    using the adjustsFontSizeToFit prop for iOSAs shown earlier in the book, you could
    use `Dimensions` instead of relying on `adjustsFontSizeToFit`. Based on `Dimensions`,
    you can create a scaling function to compute `fontSize`.'
  prefs: []
  type: TYPE_NORMAL
- en: Truncating text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another approach is known as **truncating**. Based on the text length, you
    cut it at some point and add three dots instead, `...`. However, this approach
    is not good for our use case. We work with the likes count number and we want
    to know what the number is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Observe the truncated number of likes in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/3e3f886e-8f39-412c-b1df-7164ab0c92da.png)'
  prefs: []
  type: TYPE_IMG
- en: Truncated numbers are meaningless, this solution works only for text
  prefs: []
  type: TYPE_NORMAL
- en: Using the Kilo social media notation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You know that kilo means 1,000\. Social media designers pushed this idea to
    the web and mobiles. Whenever a number is greater than 1,000, they replace the
    last 3 digits with K. For instance 20Kmeans 20,000.
  prefs: []
  type: TYPE_NORMAL
- en: 'The trivial implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'However, a number such as *9,876,543,210* is going to overflow again. But 9,876,543K
    is still too long. Let''s solve this with a simple recursive function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This algorithm works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The function takes a number in a string format and an optional parameter that
    indicates how many thousands are already stripped of the original number.
  prefs: []
  type: TYPE_NORMAL
- en: It checks whether it can strip another thousand, if so, it returns the outcome
    of itself with the number stripped by three numbers and the number of thousands
    increased by one.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the number length is less than four, compute the text: take the number and
    attach the relevant number of Ks as the suffix. We compute Ks using a neat trick:
    create an array of size equal to the number of Ks, fill every element with the
    K string, and join all the elements into one long string.The JSX is now much simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the result is as follows. The long number is now shown using the kilo
    notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/548a9826-d600-4b6b-87c7-67037f2b3ef0.png)'
  prefs: []
  type: TYPE_IMG
- en: A big like count is now displayed using the kilo (K) notation
  prefs: []
  type: TYPE_NORMAL
- en: It is a safe bet that the number of likes will not exceed 9,000,000,000\. If
    you need to support larger numbers, try the **M** or **B** letters.
  prefs: []
  type: TYPE_NORMAL
- en: React Native animated
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we build our application, we need to focus on the **user experience** (**UX**).
    One part of it is animations that make our screens more vibrant and provide instant
    feedback on the actions. If you played with our application on your own, you could
    see that when you click the like/dislike icon, it makes a little blink. That effect
    comes out of the box with `TouchableOpacity`. It's time to learn how we can implement
    such features on our own.
  prefs: []
  type: TYPE_NORMAL
- en: What are animations?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When I first read the Animated library documentation I freaked out. There are
    so many new words that you will need to get used to. Instead of diving right into
    them, let's understand what animations really are.
  prefs: []
  type: TYPE_NORMAL
- en: Animation is a change to a component style over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: you need a style attribute, its starting value, and its end value.
    Animation is what you see when this value goes from start to end over time. You
    can combine many attributes and possibly animate many components at the same time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The common and recommended way to store variables that will change over time
    is the component state. React Native Animated provides a special class that implements
    this functionality in a very performant way: `Animated.Value`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Changing attributes over time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In React Native, there are three main ways to create animations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Animated.timing()`: Takes time in milliseconds and desired end value, and
    maps them to your `Animated.Value`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Animated.decay()`: Starts with an initial velocity and slowly decays.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Animated.spring()`: Provides a simple spring physics model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see how it works in action. Our goal will be to fade in application
    on the app''s start. To achieve a fade-in effect, we will manipulate opacity from
    0 to 1\. The animation should take two seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/84ff6dee-ace8-495a-becb-45211ddbcf78.png)'
  prefs: []
  type: TYPE_IMG
- en: Sequence of images showing the opacity animation progress over time
  prefs: []
  type: TYPE_NORMAL
- en: '`Animated.timing` expects two arguments: variable to be manipulated and config
    object. In a config object, you need to specify the `toValue` key to tell the
    function what should be the end value of your variable after the duration of milliseconds –
    in our case, 2,000\. I chose two seconds just for the animation to be a little
    easier to see. Play around with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We have also introduced a new component: `Animated.View`. It makes our usual
    `View` component support animations.'
  prefs: []
  type: TYPE_NORMAL
- en: React Native Animated provides animatable components: `Animated.Image`, `Animated.ScrollView`,
    `Animated.Text`, and `Animated.View`, but you can also define your own using the `createAnimatedComponent()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, in the config object, we specified **easing**. Easing is how the
    animation should go. If it should change the value linearly over time then use
    `Easing.linear`. Linear however is not natural. Check the next section to learn
    more about easing functions.
  prefs: []
  type: TYPE_NORMAL
- en: Learning animations takes time. You can create countless different scenarios
    and you should play around with the API on your own. Especially when it comes
    to `Animated.decay` and `Animated.spring`. I'm not covering them in the book as
    it is not a very big pattern, it is just another API you need to learn. In the
    next sections, we will focus on ways to chain animations and then how to make
    them performant.
  prefs: []
  type: TYPE_NORMAL
- en: Think about how to create a draggable box using `Animated.decay`. You will also
    need a `PanResponder` component. On the release of a touch event, it should maintain
    its speed in the same direction and should slowly stop after flying some distance.
  prefs: []
  type: TYPE_NORMAL
- en: The second exercise could be implementing a red square box with a button underneath.
    On a button press, the square box should expand its width and height by another
    15 density-independent pixels. All should be done with a spring animation, thus
    width should go a little beyond 15 and then go back to 15\. Just like a spring
    does.
  prefs: []
  type: TYPE_NORMAL
- en: If these two exercises sound tough, please proceed to the next section. They
    should get easier once you learn about easing functions.
  prefs: []
  type: TYPE_NORMAL
- en: The easing function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An animation is a change over time. This change can be applied in many ways.
    The function that determines the new value over time is known as an easing function.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we use easing functions instead of linear easing? The common example
    I like is a drawer opening. When you open a drawer in the real world, is it a
    linear process? Perhaps not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at the common easing functions. There are a few. Choose the
    one that fits your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/9a122705-48ef-44c2-ae7e-58b8c1162eb6.png)Many different easing functions
    with a visualization of each one changes value over time.'
  prefs: []
  type: TYPE_NORMAL
- en: On the graphs, grey lines indicate the start and end value. The black line represents
    how the value changes over time. Eventually, the black line reaches the upper
    grey line. As you can see, some easing functions go below the start value or beyond
    the end value. Those may be useful for highlighting important actions.
  prefs: []
  type: TYPE_NORMAL
- en: Want to see more easing functions? Check out [http://easings.net/](http://easings.net/).
  prefs: []
  type: TYPE_NORMAL
- en: Most of these functions can be implemented using the RN Easing module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to React Native easings. I have prepared an application for you to play
    around with easing functions. You will find the source code at `src/ Chapter_3/
    Example_14/ App.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/327c9d13-9568-4c15-8e64-778eb6f807af.png)Easing functions playground
    application'
  prefs: []
  type: TYPE_NORMAL
- en: When you click on a button, you will see a box moving from left to right with
    the respective easing function.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for the animation, I do it by manipulating `marginLeft` of the box. The
    animation starts with `marginLeft` set to 20 and applies the easing function to
    reach 300 over 2 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Scheduling events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we know how to create animations, now let's talk about how to schedule them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The trivial approach is a delayed animation dispatch:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Animated.delay()`: Starts an animation after a given delay. Good if you need
    to delay your response to a user action. But usually this is not a case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s talk about array of events that we want to schedule. More than one event
    should be dispatched. If we need all of the events to happen at the same time,
    it is also trivial:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Animated.parallel()`: Starts a number of animations at the same time. But
    what if we need to time them one after another? Here comes sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Animated.sequence()`: Starts the animations in order, waiting for each one
    to complete before starting the next. There is also a variation of parallel. It
    is called stagger.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Animated.stagger()`: Starts animations in order and in parallel, but with
    successive delays.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise time: Fill the screen with rows of colored boxes. Rows should appear
    on the screen one after another in a staggered fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/91d74030-2f9b-485b-8548-65dd4c1049a9.png)'
  prefs: []
  type: TYPE_IMG
- en: Images showing the stagger animation over time
  prefs: []
  type: TYPE_NORMAL
- en: 'The full implementation is available at `src/ Chapter_3/ Example_15/ App.js`. Let''s
    look at a key fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The first function is just a helper. It generates one timed animation. We use
    this helper function to generate all the animations and collect them in the `animations` variable.
    The helper function expects `animatedVal`, which will be eased to 1\. In my implementation,
    I have created a separate `Animated.Value` in the state for each of the boxes.
    In the end, I pass a generated array of animations to stagger and immediately
    start.
  prefs: []
  type: TYPE_NORMAL
- en: Pretty nice animation, right? Now, let's talk about performance.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring FPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Websites and mobile applications use animations pretty rarely. Most of the time,
    it's in response to user actions that tend to be slow. If you've ever played a
    dynamic computer game, you probably remember what a different world it is. Yes,
    as we dive into animations, there is one thing from computer games that you should
    remember: **FPS**.
  prefs: []
  type: TYPE_NORMAL
- en: Frames per second – everything on the screen appears in motion thanks to the
    optical illusion created by quickly changing frames at a consistent speed. 60
    FPS means 60 frames per second, which means you see a new frame every 16.67ms.
    JavaScript needs to deliver that frame in this short period, otherwise the frame
    will be dropped. If so, your FPS metric will drop below 60.
  prefs: []
  type: TYPE_NORMAL
- en: 'React Native is known for its amazing performance in most of the applications:
    **60 FPS**. But, as we start using a lot of animations, we can quickly kill that
    performance. In this section, I want to show you how to measure FPS in your application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check how well we do with our previous animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/66b4e2d1-ae1f-4a0e-8d09-a64d1542b067.png)'
  prefs: []
  type: TYPE_IMG
- en: Images showing the stagger animation over time
  prefs: []
  type: TYPE_NORMAL
- en: We will measure this animation. On a simulator, I get **48** FPS with animations
    halfway started. Near the finish, FPS drops down to **18**. When all animations
    complete, FPS is back to its normal 60\. I have also checked on my real phone
    (iPhone 7 plus) and the results were similar.
  prefs: []
  type: TYPE_NORMAL
- en: This is just an example of the FPS drop in the development environment. However,
    you should test your application on real production builds instead. Learn more
    at [https://facebook.github.io/react-native/docs/performance.html](https://facebook.github.io/react-native/docs/performance.html).
  prefs: []
  type: TYPE_NORMAL
- en: How to measure FPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s time to learn how to check FPS. There are two main ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a tool, such as Perf Monitor. It provides this functionality out of the
    box. It allows you to also measure the native environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write custom JavaScript code to measure FPS. This will only measure the JS thread's
    performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using a performance monitor with the *Create React Native* App is as easy as
    shaking your device and choosing the Show Perf Monitor option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/e7dc8e56-7e84-4300-bd30-6c66f82cdb95.png)Show perf monitor. Numbers
    60 and 45 represent the latest value of the FPS measure'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing your own solution in JavaScript should rely on the fact that a
    desired 60FPS mean a frame every 16.67ms (1000ms/60). I have created a simple
    example for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As this book strives to teach you design patterns, I hope you will also check
    whether your solutions are performant.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to style React Native applications. We introduced
    many different ways of positioning elements and you learned how our designs translate
    to real devices. In the end, we made a few animations and measured them in terms
    of FPS.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we know how to create reusable code using React components and how to
    style them. We worked with limited data stored in the local JSON file. It's time
    to make our application more complex and talk about different scenarios that impact
    big applications. In the next chapter, you will learn about Flux, which is an
    architectural pattern.
  prefs: []
  type: TYPE_NORMAL
