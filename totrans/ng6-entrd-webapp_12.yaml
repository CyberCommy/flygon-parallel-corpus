- en: Google Analytics and Advanced Cloud Ops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have designed, developed, and deployed a word-class web application; however,
    that is only the beginning of the story of your app. The web is an ever-evolving,
    living, breathing environment that demands attention to continue to succeed as
    a business. In [Chapter 11](ba073d6f-c0a0-4681-aea6-aeedac3cbc69.xhtml), *Highly-Available
    Cloud Infrastructure on AWS*, we went over the basic concepts and costs of ownership
    of a cloud infrastructure. In this chapter, we will dig deeper in truly understanding
    how users actually use our application with Google Analytics. We will then use
    that information to create realistic load tests to simulate actual user behavior
    to understand the true capacity of a single instance of our server. Knowing the
    capacity of a single server, we can fine-tune how our infrastructure scales out
    to reduce waste and discuss the implications of various scaling strategies. Finally,
    we will go over advanced analytics concepts such as custom events to gain more
    granular understanding and tracking of user behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Google Analytics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google Tag Manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Budgeting and Scaling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced Load Testing to Predict Capacity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom Analytics Events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Throughout the chapter, you will be setting up these:'
  prefs: []
  type: TYPE_NORMAL
- en: A Google Analytics Account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Google Tag Manager Account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An OctoPerf Account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collecting Analytics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our site is up and running, we need to start collecting metrics to
    understand how it is being used. Metrics are key to operating a web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Google Analytics has many facets; the main three are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Acquisition, which measures how visitors arrive at your website
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Behavior, which measures how visitors interact with your website
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Conversions, which measures how visitors completed various goals on your website
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s a look at the Behavior | Overview from my website [TheJavaScriptPromise.com](http://TheJavaScriptPromise.com):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/50c99fe0-c01a-4f08-90a9-5ac2b43e72d6.png)Google Analytics Behavior
    Overview'
  prefs: []
  type: TYPE_NORMAL
- en: '[TheJavaScriptPromise.com](http://TheJavaScriptPromise.com) is a simple one
    page HTML site, so the metrics are quite simple. Let''s go over the various metrics
    on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: Pageviews show the number of visitors
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unique Pageviews show the number of unique visitors
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Avg. Time on Page shows the amount of time each user spent on the site
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bounce Rate shows that users left the site without navigating to a subpage or
    interacting with the site in any manner, such as clicking on a link or button
    with a custom event
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '% Exit indicates how often users leave the site after viewing a particular
    or set of pages'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At high-level, in 2017, the site had about 1,090 unique visitors and on an average,
    each visitor spent about 2.5 minutes or 157 seconds on the site. Given that this
    is just a one page site, bounce rate and % exit metrics do not apply in any meaningful
    manner. Later, we will use these numbers to calculate the Cost Per User.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to page views, Google Analytics can also capture specific events,
    such as clicking on a button that triggers a server request. These events can
    then be viewed on the Events | Overview page, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/e1e8eabd-a481-4032-bff0-0eb5b2a9b28b.png)Google Analytics Events
    Overview'
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to capture metrics on the server side as well, but this will
    give requests-over-time statistics. You will need additional code and state management
    to track the behavior of a particular user, so you can calculate users-over-time
    statistics. By implementing such tracking on the client side with Google Analytics,
    you gain a far more detailed understanding where the user came from, what they
    did, if they succeeded or not and when they left your app without adding unnecessary
    code complexity and infrastructure load to your backend.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Google Tag Manager to Angular App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start capturing analytics in your Angular app. Google is in the process
    of phasing out the legacy `ga.js` and `analytics.js` products that ships with
    Google Analytics, with its new, more flexible Global Site Tag `gtag.js` that ships
    with Google Tag Manager. This is by no means an end to Google Analytics; instead,
    it's a shift in toward an easier-to-configure and manage analytics tool. Global
    Site Tag can be configured and managed remotely via Google Tag Manager. Tags are
    snippets of JavaScript tracking code that is delivered to the client, and they
    can enable tracking of new metrics and integration with multiple analytics tools
    without having to change already deployed code. You can still continue to use
    Google Analytics to analyze and view your analytics data. Another major advantage
    of Google Tag Manager is that its version controlled, so you can experiment with
    different kinds of tags that are triggered under various kinds of conditions without
    fear of doing any irreversible damage to your analytics configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Set up Google Tag Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start off with setting up a Google Tag Manager account for your application:'
  prefs: []
  type: TYPE_NORMAL
- en: Sign in to Google Tag Manager at [GoogleTagManager.com](https://googletagmanager.com)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new account with a Web container, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/a2d3c667-536f-4c2f-863c-62072247bbd9.png)Google Tag Manager'
  prefs: []
  type: TYPE_NORMAL
- en: 'Paste the generated scripts at or near the top `<head>` and `<body>` sections
    of your `index.html` as instructed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `<noscript>` tag will only execute if the user has disabled JavaScript
    execution in their browser. This way, we can collect metrics from such users,
    rather than being blind to their presence.
  prefs: []
  type: TYPE_NORMAL
- en: Submit and publish your tag manager container
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see the initial setup of your tag manager completed, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/a421aa04-332d-4966-8c6e-d8615847ec3d.png)Published Tag'
  prefs: []
  type: TYPE_NORMAL
- en: Verify that your Angular app runs without any errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that if you don't publish your tag manager container, you will see a 404
    error in loading `gtm.js` in the `dev` console or the Network tab.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Google Analytics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s generate a Tracking ID through Google Analytics:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to Google Analytics at [analytics.google.com](https://analytics.google.com)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the Admin console, pointed out as the *gear* icon in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/382cd801-dc47-4661-809a-d637a7e4c15c.png)Google Analytics admin
    console'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new analytics account
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using the arrows from the image as a guide:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new Property `LemonMart`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the property to your preferences
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Tracking Code
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the Tracking ID that starts with `UA-xxxxxxxxxx-1`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ignore the `gtag.js` code provided
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring Google Analytics Tag in Tag Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s connect our Google Analytics ID to Google Tag Manager:'
  prefs: []
  type: TYPE_NORMAL
- en: At [tagmanager.google.com](https://tagmanager.google.com), open the Workspace
    tab
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Add a new tag
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name it `Google Analytics`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Tag configuration and select Universal Analytics
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under Google Analytics settings, add a new variable
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Paste the Tracking ID you copied in the previous section
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Triggers and add the All pages trigger
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on Save, as shown on the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/d19ac69c-9873-438e-9464-efa05b4ec2b1.png)Creating Google Analytics
    Tag'
  prefs: []
  type: TYPE_NORMAL
- en: 'Submit and publish your changes, and observe the version summary with 1 tag,
    as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/5f1211b6-18b0-445a-ae28-a6ef095c88f7.png)Version Summary Showing
    one Tag'
  prefs: []
  type: TYPE_NORMAL
- en: Now refresh your Angular app, where you'll be on the `/home` route
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a private window, open a new instance of your Angular app and navigate to
    the `/manager/home` route
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At [analytics.google.com](https://analytics.google.com), open the Real-time
    | Overview pane, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/2ec54d66-0dd0-4c50-ad8a-c4b415b25713.png)Google Analytics Real-time
    Overview'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the two active users are being tracked
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under Top Active Pages, you should see the pages that the users are on
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By leveraging Google Tag Manager and Google Analytics together, we have been
    able to accomplish page tracking without changing any code inside of our Angular
    app.
  prefs: []
  type: TYPE_NORMAL
- en: '**Search Engine Optimization** (**SEO**) is an important part of Analytics.
    To gain a better understanding of how crawlers perceive your Angular site, use
    the Google Search Console, found at [https://www.google.com/webmasters/tools](https://www.google.com/webmasters/tools),
    to identify optimizations. Further, consider using Angular Universal to render
    certain dynamic content server side, so crawlers can index your dynamic data sources
    and drive more traffic to your site.'
  prefs: []
  type: TYPE_NORMAL
- en: Budgeting and scaling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the AWS Billing section of [Chapter 11](ba073d6f-c0a0-4681-aea6-aeedac3cbc69.xhtml),
    *Highly-Available Cloud Infrastructure on AWS*, we covered the monthly costs of
    operating a web server, ranging from $5/month to $45/month, from a single-server
    instance scenario to a highly-available infrastructure. For most needs, budgeting
    discussions will begin and end with this monthly number. You can execute load
    tests, as suggested in the Advanced Load Testing section, to predict your per
    server user capacity and get a general idea of how many servers you may need.
    In a dynamically scaling cloud environment with dozens of servers running 24/7,
    this is an overly simplistic way to calculate a budget.
  prefs: []
  type: TYPE_NORMAL
- en: If you operate a web property of any significant scale, things get invariably
    complicated. You will be operating multiple servers on different tech stacks,
    serving different purposes. It can be difficult to gauge or justify how much of
    a budget to spare for seemingly excess capacity or unnecessarily high-performance
    servers. Somehow, you need to be able to communicate the efficiency of your infrastructure
    given the number of users you serve and ensure that your infrastructure is fine-tuned
    so that you don't lose users due to an unresponsive application or overpay because
    you're using more capacity than you need. For this reason, we will take a user-centered
    approach and translate our IT infrastructure costs to a per user cost metric that
    the business and the marketing side of your organization can make sense of.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will investigate what it means to calculate the per
    user cost of your infrastructure and how these calculations change when cloud
    scaling comes in to play using one of my websites as an example.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating per user cost
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be leveraging behavior metrics from Google Analytics with the goal
    of calculating per user cost over a given period of time:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Per User Cost**![](Images/d999dbd8-28df-41cf-a125-8aa31e280ec7.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Using the [TheJavaScriptPromise.com](http://TheJavaScriptPromise.com) data from
    earlier, let's plug in the data to the formula to calculate *perUserCost/month*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This website is deployed on an Ubuntu server on DigitalOcean, so the monthly
    infrastructure cost, including weekly backups, is $6 a month. From Google Analytics,
    we know there were 1,090 unique visitors in 2017:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/4d389358-99b2-4e63-a610-c31d6bf4b788.png)'
  prefs: []
  type: TYPE_IMG
- en: In 2017, I have paid 7 cents per user. Money well spent? At $6/month, I don't
    mind it. In 2017, [TheJavaScriptPromise.com](http://thejavascriptpromise.com/)
    was deployed on a traditional server setup, as a static site that doesn't scale
    out or in. These conditions make it very straightforward to use the unique visitor
    metric and find the per user cost. The very same simplicity that allows for an
    easy calculation also leads to a suboptimal infrastructure. If I were to serve
    1,000,000 users on the same infrastructure, my costs would add up to $70,000 a
    year. If I were to earn $100 per every 1,000 user through Google Ads, my site
    would make a $100,000 per year. After taxes, development expenses, and our unreasonable
    hosting expense, the operation would likely lose money.
  prefs: []
  type: TYPE_NORMAL
- en: If you took advantage of cloud scaling, where instances can scale out or in
    dynamically based on current user demand, the preceding formula becomes useless
    pretty quickly, because you must take provisioning time and target server utilization
    into account. Provisioning time is the amount of time it takes your cloud provider
    to start a new server from scratch. Target server utilization is the maximum usage
    metric of a given server, where a scale-out alert must be sent out so that a new
    server is ready before your current servers max out their capacity. In order to
    calculate these variables, we must execute a series of load tests against our
    servers.
  prefs: []
  type: TYPE_NORMAL
- en: Page views are an overly simplistic way to determine user behavior in SPAs such
    as Angular, where page views do not necessarily correlate to a request or vice
    versa. If we execute load tests simply based on page views, we won't get a realistic
    simulation of how your platform may perform under load.
  prefs: []
  type: TYPE_NORMAL
- en: User behavior, or how users actually use your app, can drastically impact your
    performance forecasts and wildly fluctuate budget numbers. You can use Google
    Analytics custom events to capture complicated sets of actions that result in
    various types of requests served by your platform. Later in this chapter, we will
    explore how you can measure actual use in the *Measuring actual use* section.
  prefs: []
  type: TYPE_NORMAL
- en: Initially, you won't have any of the aforementioned metrics, and any metrics
    you may have will be invalidated any time you make a meaningful change to your
    software or hardware stack. Therefore, it is imperative to execute load tests
    on a regular basis to simulate realistic user loads.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced load testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to be able to predict capacity, we need to run load tests. In [Chapter
    11](ba073d6f-c0a0-4681-aea6-aeedac3cbc69.xhtml), *Highly-Available Cloud Infrastructure
    on AWS, *I discussed a simple load testing technique of just sending a bunch of
    web requests to a server. In a relative comparison scenario, this works fine to
    test raw power. However, actual users generate dozens of requests at varying intervals,
    while they navigate your website resulting in a wide-variety of API calls to your
    backend server.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must be able to model virtual users and unleash a whole bunch of them on
    our servers to find the breaking point of our server. OctoPerf is an easy-to-use
    service to execute such load tests, and it''s located at [https://octoperf.com](https://octoperf.com).
    OctoPerf offers a free-tier that allows for 50 concurrent users/test over unlimited
    test runs with two load generators:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an OctoPerf account
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Login and add a new project for LemonMart, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/c9f916a9-cbce-42e7-a592-d950c1b0cddf.png)OctoPerf Add Project'
  prefs: []
  type: TYPE_NORMAL
- en: OctoPerf allows you to create multiple virtual users with different usage characteristics.
    Since it is a URL-based setup, any click-based user action can also be simulated
    by directly calling the application server URL with test parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create two virtual users: one as a `Manager` who navigates to Manager-based
    pages and second a `POS` user who would only stick to POS functions'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on Create scenario:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/e7ba3d65-b1d4-4b86-a4a5-e0ac810e530f.png)POS User Scenario'
  prefs: []
  type: TYPE_NORMAL
- en: Name the scenario `Evening Rush`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can add a mixture of Managers and POS Users, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/94f055b8-086d-4139-953e-c7dc1d6566a6.png)Evening Rush Scenario'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the Launch 50 VUs button to start the load test
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can observe the number of users and hits/sec being achieved in real time,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/1a83b924-c8f2-4ff8-b161-644afa539427.png)Evening Rush Load Test
    Underway'
  prefs: []
  type: TYPE_NORMAL
- en: 'ECS service metrics also give us a high-level idea of real-time utilization,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/08c773f1-a8eb-497b-b4b3-779110666916.png)ECS Real-time Metrics'
  prefs: []
  type: TYPE_NORMAL
- en: Analyze load test results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can get more accurate results from ECS by clicking on the CPUUtilization
    link from ECS Service Metrics or by navigating to CloudWatch | Metrics section,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/57c634ba-85f7-49ea-a4be-adff93c320f6.png)AWS CloudWatch Metrics'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the preceding graph, CPU utilization was fairly consistent
    around 1.3%, given a sustained 50 user load over 10 minutes. During this period,
    there were no request errors, as shown in the statistics summary from OctoPerf:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2030e153-a12e-45b1-acc6-0ae6b8ac7261.png)OctoPerf Statistics Summary'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ideally, we would measure maximum users/second until the moment errors were
    being generated. However, given only 50 virtuals users and the information we
    already have, we can predict how many users could be handled at 100% utilization:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/187cb266-4556-4d6a-8342-024c2f6a8a5a.png)'
  prefs: []
  type: TYPE_IMG
- en: Our load test results reveal that our infrastructure can handle 3,846 users/second.
    Given this information, we can calculate cost per user in a Scalable Environment
    in the next section. However, performance and reliability go hand in hand. How
    you choose to architect your infrastructure will also provide important information
    of budgeting, because the level of reliability you need will dictate the minimum
    number of instances you must keep around at all times.
  prefs: []
  type: TYPE_NORMAL
- en: Reliable Cloud Scaling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reliability can be expressed in terms of your organization's Recovery Point
    Objective (RPO) and **Recovery Time Objective** (**RTO**) defined. RPO represents
    how much data you're willing to lose, and RTO represents how fast you can rebuild
    your infrastructure in the event of a failure.
  prefs: []
  type: TYPE_NORMAL
- en: Let's suppose that you run an e-commerce site. Around noon every weekday, you
    reach peak sales. Every time a user adds an item to their shopping cart, you store
    the items on a server-side cache so that users can resume their shopping spree
    later at home. In addition, you process hundreds of transactions per minute. Business
    is good, your infrastructure is scale-out beautifully, and everything is going
    smoothly. Meanwhile, a hungry rat or an overly charged lightning cloud decides
    to strike your data center. Initially, a seemingly harmless power unit goes down,
    but it's fine, because nearby power units can pick up the slack. However, this
    is the lunch rush; other websites on the data center are also facing a high traffic
    volume. As a result, several power units overheat and fail. There aren't enough
    power units to pick up the slack, so in quick succession, power units overheat
    one by one and start failing, triggering a cascade of failures that end up taking
    down the entire data center. Meanwhile, some of your users just clicked on add
    to cart, others on the pay button, and some others are just about to arrive on
    your site. If your RPO is one hour, meaning you persisted your shopping cart cache
    every one hour, then you can say goodbye to valuable data and potential sales
    by those night time shoppers. If your RTO is one hour, it will take you up to
    one hour to get your site back up and running again, and you can be assured that
    most of those customers, who just clicked on the buy button or arrived to an unresponsive
    site won't be making a purchase on your site that day.
  prefs: []
  type: TYPE_NORMAL
- en: A well thought out RPO and RTO is a critical business need, but they must also
    be paired with the right infrastructure that makes it possible to implement your
    objectives in a cost-effective manner. AWS is made up of more than two dozen regions
    around the world, each region containing at least their **Availability Zones**
    (**AZs**). Each AZ is a physically separated infrastructure that is not affected
    by a failure in another AZ.
  prefs: []
  type: TYPE_NORMAL
- en: A highly-available configuration on AWS means that your application is up and
    running on at least two AZs, so if a server instance fails, nay even if the entire
    data center fails, you have another instance already live in a physically separate data
    center that is able to pick up incoming requests seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: A fault-tolerant architecture means that your application is deployed across
    multiple regions. Even if an entire region comes down due to a natural disaster,
    **Distributed Denial of Service** (**DDoS**) attack, or a bad software update,
    your infrastructure remains standing and able to respond to user request. Your
    data is protected via layers upon layers of security and via staggered back ups
    of back ups.
  prefs: []
  type: TYPE_NORMAL
- en: AWS has great services such as Shield to protect against DDoS attacks targeted
    against your website, Pilot Light service to keep a minimal infrastructure waiting
    dormant in another region that can scale to full capacity if needed, while keeping
    operational costs down, and Glacier service to store large amounts for data for
    long periods of time in an affordable manner.
  prefs: []
  type: TYPE_NORMAL
- en: A highly-available configuration will require two instances at a minimum in
    a multi-AZ setup at all times. For a fault-tolerant setup, you need two highly-available
    configuration in at least two regions. Most AWS cloud services such as DynamoDB
    for data-storage or Redis for caching are highly available by default, including serverless
    technologies such as Lambda. Lambda charges on a per use basis and can scale to
    match any need you can throw at it in a cost effective manner. If you can move
    heavy compute tasks to Lambda, you can reduce your server utilization and your
    scaling needs dramatically in the process. When planning your infrastructure,
    you should consider all these variables to set up the right scalable environment
    for your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Cost per user in a scalable environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a scalable environment, you can't plan on 100% utilization. It takes time
    to provision a new server. A server that is at 100% utilization can't process
    additional incoming requests in a timely manner, which results in dropped or erroneous
    requests from the users' perspective. So the server in question must send a trigger
    well before it reaches 100% utilization so that no requests are dropped. Earlier
    in the chapter, I suggested a 60-80% target utilization before scaling. The exact
    number will highly depend on your specific choice software and hardware stack.
    Given your custom utilization target, we can calculate the number of users your
    infrastructure is expected to serve on average per instance. Using this information,
    you can calculate a more accurate cost per user, which should allow the right-sizing
    of your IT budget, given your specific needs. It is equally as bad to underspend
    as it is to overspend. You may be foregoing growth, security, data, reliability,
    and resilience than it may be acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will walk through the calculation of an optimal target
    server utilization metric so that you can calculate a more accurate per user cost;
    then, we will explore scaling that can occur during preplanned time frames and
    software deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating target server utilization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, calculate your custom server utilization target, which is the point
    where your server is under increasing load and triggers a new server to provision
    with enough time so that the original server does not reach 100% utilization and
    drop requests. Consider this formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Target Utilization**![](Images/744f4ac5-b88d-4050-bc72-5ea63b0da856.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s demonstrate how the formula works with a concrete example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Load test your instances to find out user capacity per instance: *Load test
    results:* 3,846 users/second'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Requests/sec and users/sec are not equivalents, since a user makes multiple
    requests to complete an action and may execute multiple requests/sec. Advanced
    load testing tools such as OctoPerf are necessary to execute realistic and varied
    workloads and measure user capacity over request capacity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Measure instance provisioning speed, from creation/cold boot to first fulfilled
    request: *Measured instance provisioning speed:* 60 seconds'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to measure this speed, you can put the stopwatch away. Depending on
    your exact setup, AWS provides event and application logs in ECS Service Events
    tab, CloudWatch, and CloudTrail to correlate enough information to figure out
    when a new instance was requested and how long it took for the instance to be
    ready to fulfill requests. For example, in the ECS Service Events tab, take the
    target registration event as the beginning time. Once the task has been started,
    click on the task ID to see the creation time. Using the task ID, check the task's
    logs in CloudWatch to see the time the task served its first web request as the
    end time and then calculate the duration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Measure 95th-percentile user growth rate, excluding known capacity increases:
    *95th-percentile user growth rate:* 10 users/second'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you don't have prior metrics, initially defining user growth rate will be
    an educated guess at best. However, once you start collecting data, you can update
    your assumptions. In addition, it is impossible to operate an infrastructure that
    can respond to any imaginable outlier without dropping a request in a cost-effective
    manner. Given your metrics, a business decision should be consciously made to
    what percentile of outliers should be ignored as an acceptable business risk.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s plug in the numbers to the formula:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/b7f31ebc-1145-43a1-873b-0a6b6930de62.png)'
  prefs: []
  type: TYPE_IMG
- en: The custom target utilization rate, rounded down, would be 84%. Setting your
    scale out trigger at 84% will avoid instances from being over provisioned, while
    avoiding dropping users requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this custom target utilization in mind, let''s update the Per User Cost
    formula with scaling in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Per User Cost with Scaling**![](Images/abb6593b-cac6-4b06-a8c9-f779bf5bd9a9.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'So if our infrastructure cost was $100 per month serving 150 users, at a 100%
    utilization, you calculate the Per User Cost to be $0.67/user/month. If you were
    to take scaling in to account, the cost would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/79087df7-be63-43ad-994a-e695047def40.png)'
  prefs: []
  type: TYPE_IMG
- en: Scaling without dropping requests would cost 16% more of the original $0.67
    at $0.79 per user per month. However, it is important to keep in mind that your
    infrastructure won't always be so efficient, at lower utilization targets, or
    misconfigured with scaling triggers costs can easily double, triple, or quadruple
    the original cost. The ultimate goal here is to find the sweet spot, so you will
    be paying the right amount per user.
  prefs: []
  type: TYPE_NORMAL
- en: There's no prescriptive per user cost you should be targeting for. However,
    if you are running a service where you charge users $5 per month after all other
    operational costs and profit margins are accounted for, you're still left over
    with an additional budget *and* your users complaining about poor performance,
    then you're underspending. However, if you're eating into your profits margins,
    or worse breaking even, then you may be overspending or you may need to reconsider
    your business model.
  prefs: []
  type: TYPE_NORMAL
- en: There are several other factors that can impact your per user cost such as Blue-Green
    deployments. You can also increase the efficiency of your scaling by leveraging
    pre-scheduled provisioning.
  prefs: []
  type: TYPE_NORMAL
- en: Pre-scheduled provisioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dynamic scaling out and then back in is what defines cloud computing. However,
    the algorithms currently available still require some planning if you know certain
    days, weeks, or months of a year will require uncharacteristically higher capacity
    of resources. Given a sudden deluge of new traffic, your infrastructure will attempt
    to dynamically scale out, but if the rate of increase in traffic is logarithmic,
    even an optimized server utilization target won't help. Servers will frequently
    reach and operate at 100% utilization, resulting in dropped or erroneous requests.
    To prevent this from happening, you should proactively provision additional capacity
    during such predictable periods of high demand.
  prefs: []
  type: TYPE_NORMAL
- en: Blue-Green deployments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 11](ba073d6f-c0a0-4681-aea6-aeedac3cbc69.xhtml), *Highly-Available
    Cloud Infrastructure on AWS*, you configured no-downtime Blue-Green deployments.
    Blue-Green deployments are reliable code deployments that ensure continuous up-time
    of your site, while minimizing the risk of bad deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Let's presume that you have a highly-available deployment, meaning you have
    two instances active at any given time. During a blue-green deployment, two additional
    instances would be provisioned. Once these additional instances are ready to fulfill
    requests, their health is determined using your predefined health metric.
  prefs: []
  type: TYPE_NORMAL
- en: If your new instances are found to be healthy, it means they're in working order.
    There will be a period of time, like 5 minutes, while connections in the original
    instance are drained and rerouted to the new instances. At this time, the original
    instances are deprovisioned.
  prefs: []
  type: TYPE_NORMAL
- en: If the new instances are found to be unhealthy, then these new instances will
    be deprovisioned, resulting in a failed deployment. However, a service will remain
    available without interruption, because the original instance will remain intact
    and keep serving users during the entire process.
  prefs: []
  type: TYPE_NORMAL
- en: Revising estimates with metrics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Load testing and predicting user growth rates give you an idea of how your system
    may behave in production. Collecting more granular metrics and data is critical
    in revising your estimates and nailing down a more accurate IT budget.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring actual use
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed earlier, keeping track of page views alone isn't reflective
    of the amount of requests that a user sends to the server. With Google Tag Manager
    and Google Analytics, you can keep track of more than just page views with ease.
  prefs: []
  type: TYPE_NORMAL
- en: 'As of publishing time, here are some of the default events you can configure
    across various categories. This list will grow over time:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Page View: Used to track whether a user is sticking around as page resources
    load and the page is fully rendered:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Page View, fired at first opportunity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DOM Ready, when DOM structure is loaded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Window Loaded, when all elements are finished loading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Click: Used to track user''s click interactions with the page:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All Elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just Links
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'User Engagement: Tracks user behavior:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Element Visibility, whether elements have been shown
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Form Submission, whether a form was submitted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scroll Depth, how far they scrolled down the page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: YouTube Video, if they played an embedded YouTube Video
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other events track:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Custom Event: Defined by programmer to track a single or multistep event, such
    as a user going through the steps of a checkout process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'History Change: Whether the user navigates back in browser''s history'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JavaScript Error: Whether JavaScript errors have been generated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Timer: To trigger or delay time-based analytics events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of these events don't require any extra coding to implement, so we will
    implement a custom event to demonstrate how you can capture any single or series
    of events you want with custom coding. Capturing workflows with a series of events
    can reveal where you should be focusing your development efforts.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on Google Tag Manager events, triggers, or tips and tricks,
    I recommend that you check out the blog by Simo Ahava at [www.simoahava.com](http://www.simoahava.com).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this example, we will capture the event for when a customer is successfully
    checked out and a sale is completed. We will implement two events, one for checkout
    initiation and the other for when the transaction has been successfully completed:'
  prefs: []
  type: TYPE_NORMAL
- en: Log on to your Google Tag Manager Workspace at [tagmanager.google.com](https://tagmanager.google.com)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under the Triggers menu, click on New, as pointed out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/79e158f0-a52a-42df-ba04-03f6ba125296.png)Tag Manager Workspace'
  prefs: []
  type: TYPE_NORMAL
- en: Name your trigger
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the empty trigger card to select the event type
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Custom Event
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a custom event named `checkoutCompleted`, as illustrated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/d5d5ea90-b0e4-4b63-88c4-14c3ad4e7d54.png)Custom Checkout Event'
  prefs: []
  type: TYPE_NORMAL
- en: 'By selecting the Some Custom Events option, you can limit or control the collection
    of a particular event, that is, only when on a particular page or a domain such
    as on `lemonmart.com`. In the following screenshot, you can see a custom rule
    that would filter out any checkout event that didn''t happen on `lemonmart.com`
    to weed out development or test data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/5ad1d833-f404-43fe-96de-eb9a78faa954.png)Some Custom Events'
  prefs: []
  type: TYPE_NORMAL
- en: Save your new event
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the process for an event named `checkoutInitiated`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add two new Google Analytics event tags, as highlighted here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/3ad79369-3bc4-41c1-bbe6-60cfd5204321.png)New Custom Event Tags'
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure the event and attach the relevant trigger you created to it, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/44ae78d9-6d5a-4d56-a169-b88334147094.png)Trigger Setup'
  prefs: []
  type: TYPE_NORMAL
- en: Submit and publish your workspace
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are now ready to receive custom events in our analytics environment.
  prefs: []
  type: TYPE_NORMAL
- en: Adding custom events in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s edit the Angular code to trigger the events:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe the POS template with a Checkout button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The circular checkout button is pointed out at the bottom-left corner of the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/3b63b2bf-fe62-4e9c-8092-0edfe7b21c46.png)POS Page with Checkout
    ButtonOptionally, you can add an `onclick` event handler directly in the template,
    like `onclick="dataLayer.push({''event'': ''checkoutInitiated''})"` on the checkout
    button. This pushes the `checkoutInitiated` event to the `dataLayer` object, made
    available by `gtm.js`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the POS compoment, declare an interface for `dataLayer` events you intend
    to push:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Create the `checkout` function to call `checkoutInitiated` before a service
    call is made
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Simulate a fake transaction using `setTimeout` and call the `checkoutCompleted`
    event, when the timeout ends:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In a real implementation, you would only call `checkoutCompleted` if your service
    call succeeds. To not to miss any data during your analytics collection, consider
    covering failure cases as well, such as adding multiple `checkoutFailed` events
    that cover various failure cases.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to see the analytics in action.
  prefs: []
  type: TYPE_NORMAL
- en: On the POS page, click on the Checkout button
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Google Analytics, observe the Real-Time | Events tab to see events as they
    occur
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After 5-10 minutes, the events will also show up under the Behavior | Events
    tab, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/30f98116-4cc6-4087-8990-a5416a5a8975.png)Google Analytics Top Events'
  prefs: []
  type: TYPE_NORMAL
- en: Using custom events, you can keep track of various nuanced user behavior happening
    on your site. By collecting `checkoutInitiated` and `checkoutCompleted` events,
    you can calculate a conversion rate of how many initiated checkouts are taken
    to completion. In the case of a point-of-sale system, that rate should be very
    high; otherwise, it means you may have systematic issues in place.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Analytics events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to collect additional metadata along with each event, such as
    payment amount or type when checkout is initiated or the `transactionId`, when
    checkout is completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To work with these more advanced features, I would recommend that you check
    out `angulartics2`, which can be found at [https://www.npmjs.com/package/angulartics2](https://angulartics.github.io/angulartics2/).
    `angulartics2` is a vendor-agnostic analytics library for Angular that can enable
    unique and granular event tracking needs using popular vendors, such as Google
    Tag Manager, Google Analytics, Adobe, Facebook, Baidu and more, as highlighted
    on the tool''s homepage, shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c80fff80-b31f-4536-90e6-f6388e6cab25.png)Angulartics2'
  prefs: []
  type: TYPE_NORMAL
- en: '`angulartics2` integrates with the Angular router and the UI-Router with the
    ability to implement custom rules and exceptions on route-per-route basis. The
    library makes it easy to implement custom events and enables metadata tracking
    with data binding. Check out the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We can keep track of a click event named `DownloadClick`, which would have a
    `category` and a `label` attached to it for rich events tracking within Google
    Analytics.
  prefs: []
  type: TYPE_NORMAL
- en: With advanced analytics under your belt, you can use actual usage data to inform
    how you improve or host your app. This topic concludes a journey that started
    by creating pencil drawn mock ups at the beginning of this book, covering a wide-variety
    of tools, techniques, and technologies a full-stack web developer must be familiar
    with in today's web to succeed. We dove deep into Angular, Angular Material, Docker,
    and automation in general to make you the most productive developer you can be,
    delivering the highest quality web app, while juggling a lot of complexity along
    the way. Good luck out there!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have rounded out your knowledge of developing web apps.
    You learned how to work with Google Tag Manager and Google Analytics to capture
    page views of your Angular application. Using high-level metrics, we went over
    how you can calculate the cost of your infrastructure per user. We then investigated the
    nuances of the effect high-availability and scaling can have on your budget. We
    covered load testing complex user workflows to estimate how many users any given
    server can host concurrently. Using this information, we calculated a target server
    utilization to fine-tune your scaling settings.
  prefs: []
  type: TYPE_NORMAL
- en: All of our pre-release calculations were mostly estimates and educated guesses.
    We went over the kinds of metrics and custom events you can use to measure the
    actual use of your application. When your application goes live and you start
    gathering these metrics, you can update your calculations to gain a better understanding
    of the viability and the affordability of your infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Over the course of this book, I've shown that web development is so much more
    than just coding a website. In the first half of the book, we went over a variety
    of topics from process, design, approach, architecture to your development environment,
    the libraries and tools you use, including going over the basics of the Angular
    platform and Angular Material, finally deploying your application on the web using
    Zeit Now.
  prefs: []
  type: TYPE_NORMAL
- en: In the second half of the book, we followed the Router-first approach to designing,
    architecting, and implementing a large line-of-business application going over
    most major design patterns you may encounter in real life. Along the way, we covered
    unit testing, Docker, Continuous Integration with CircleCI, designing APIs with
    Swagger, gathering analytics using Google Tag Manager, and deploying a highly-available
    application on AWS. As you master these wide variety of skills and techniques,
    you will become a true full-stack web developer capable of delivering small and
    large web apps leveraging Angular.
  prefs: []
  type: TYPE_NORMAL
