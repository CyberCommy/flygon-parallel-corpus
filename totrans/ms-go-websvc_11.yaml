- en: Chapter 11. Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we begin this chapter, it's absolutely essential to point out one thing—though
    security is the topic of the last chapter of this book, it should never be the
    final step in application development. As you develop any web service, security
    should be considered prominently at every step. By considering security as you
    design, you limit the impact of top-to-bottom security audits after an application's
    launch.
  prefs: []
  type: TYPE_NORMAL
- en: With that being said, the intent here is to point out some of the larger and
    more rampant security flaws and look at ways in which we can allay their impact
    on our web service using standard Go and general security practices.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, out of the box, Go provides some wonderful security features that
    are disguised as solely good programming practices. Using all the included packages
    and handling all the errors are not only useful for developing good habits, but
    they also help you to secure your application.
  prefs: []
  type: TYPE_NORMAL
- en: However, no language can offer perfect security nor can it stop you from shooting
    yourself in the foot. In fact, the most expressive and utilitarian languages often
    make that as easy as possible.
  prefs: []
  type: TYPE_NORMAL
- en: There's also a large trade-off when it comes to developing your own design as
    opposed to using an existing package (as we've done throughout this book), be
    it for authentication, database interfaces, or HTTP routing or middleware. The
    former can provide quick resolution and less exposure of errors and security flaws.
  prefs: []
  type: TYPE_NORMAL
- en: There is also some security through obscurity that is offered by building your
    own application, but swift responses to security updates and a whole community
    whose eyes are on your code beats a smaller, closed-source project.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll look at:'
  prefs: []
  type: TYPE_NORMAL
- en: Handling error logging for security purposes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing brute-force attempts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging authentication attempts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input validation and injection mitigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, we'll look at a few production-ready frameworks to look at the way they
    handle API and web service integrations and associated security.
  prefs: []
  type: TYPE_NORMAL
- en: Handling error logging for security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A critical step on the path to a secure application involves the use of comprehensive
    logging. The more data you have, the better you can analyze potential security
    flaws and look at the way your application is used.
  prefs: []
  type: TYPE_NORMAL
- en: Even so, the "log it all" approach can be somewhat difficult to utilize. After
    all, finding the needles in the haystack can be particularly difficult if you
    have all the hay.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, we'd want to log all errors to file and have the ability to segregate
    other types of general information such as SQL queries that are tied to users
    and/or IP addresses.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll look at logging authentication attempts but only
    in memory/an application's lifetime to detect brute-force attempts. Using the
    log package more extensively allows us to maintain a more persistent record of
    such attempts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard way to create log output is to simply set the output of the general
    log, `Logger`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to specify a new file instead of our default `stdout` class for
    logging our database errors for analyzing later.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we want multiple log files for different errors (for example, database
    errors and authentication errors), we can break these into separate loggers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we instantiate separate loggers with specific formats for our log files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: By building separate logs for elements of an application in this manner, we
    can divide and conquer the debugging process.
  prefs: []
  type: TYPE_NORMAL
- en: As for logging SQL, we can make use of the `sql.Prepare()` function instead
    of using `sql.Exec()` or `sql.Query()` to keep a reference to the query before
    executing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sql.Prepare()` function returns a `sql.Stmt` struct, and the query itself,
    which is represented by the variable query, is not exported. You can, however,
    use the struct''s value itself in your log file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will leave a detailed account of the query in the log file. For more detail,
    IP addresses can be appended to the `Stmt` class for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Storing every transactional query to a file may, however, end up becoming a
    drag on performance. Limiting this to data-modifying queries and/or for a short
    period of time will allow you to identify potential issues with security.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are some third-party libraries for more robust and/or prettier logging.
    Our favorite is go-logging, which implements multiple output formats, partitioned
    debugging buckets, and expandable errors with attractive formatting. You can read
    more about these at [https://github.com/op/go-logging](https://github.com/op/go-logging)
    or download the documentation via the `go get github.com/op/go-logging` command.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing brute-force attempts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Perhaps the most common, lowest-level attempt at circumventing the security
    of any given system is the brute-force approach.
  prefs: []
  type: TYPE_NORMAL
- en: From the point of view of an attacker, this makes some sense. If an application
    designer allows an infinite amount of login attempts without penalty, then the
    odds of this application enforcing a good password-creation policy are low.
  prefs: []
  type: TYPE_NORMAL
- en: This makes it a particularly vulnerable application. And, even if the password
    rules are in place, there is still a likelihood to use dictionary attacks to get
    in.
  prefs: []
  type: TYPE_NORMAL
- en: Some attackers will look at rainbow tables in order to determine a hashing strategy,
    but this is at least in some way mitigated by the use of unique salts per account.
  prefs: []
  type: TYPE_NORMAL
- en: Brute-force login attacks were actually often easier in the offline days because
    most applications did not have a process in place to automatically detect and
    lock account access attempts with invalid credentials. They could have, but then
    there would also need to be a retrieval authority process—something like "e-mail
    me my password".
  prefs: []
  type: TYPE_NORMAL
- en: With services such as our social network, it makes a great deal of sense to
    either lock accounts or temporarily disable logins after a certain point.
  prefs: []
  type: TYPE_NORMAL
- en: The first is a more dramatic approach, requiring direct user action to restore
    an account; often, this also entails greater support systems.
  prefs: []
  type: TYPE_NORMAL
- en: The latter is beneficial because it thwarts brute-force attempts by greatly
    slowing the rate of attempts, and rendering most attacks useless for all practical
    purposes without necessarily requiring user action or support to restore access.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing what to log
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the hardest things to do when it comes to logging is deciding what it
    is that you need to know. There are several approaches to this, ranging from logging
    everything to logging only fatal errors. All the approaches come with their own
    potential issues, which are largely dependent on a trade-off between missing some
    data and wading through an impossible amount of data.
  prefs: []
  type: TYPE_NORMAL
- en: The first consideration that we'll need to make is what we should log in memory—only
    failed authentications or attempts against API keys and other credentials.
  prefs: []
  type: TYPE_NORMAL
- en: It may also be prudent to note login attempts against nonexistent users. This
    will tell us that someone is likely doing something nefarious with our web service.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll want to set a lower threshold or the maximum amount of login attempts
    before we act.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by introducing a `bruteforcedetect` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can set this directly as a package variable and modify it from the calling
    application, if necessary. Three attempts are likely lower than what we''d like
    for a general invalid login threshold, particularly one that automatically bans
    the IP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `Requester` struct will maintain all incremental values associated with
    any given IP or hostname, including general attempts at a login, failed attempts,
    and failed attempts wherein the requested user does not actually exist in our
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We don't need this as middleware as it needs to react to just one thing—authentication
    attempts. As such, we have a choice as it relates to storage of authentication
    attempts. In a real-world environment, we may wish to grant this process more
    longevity than we will here. We could store these attempts directly into memory,
    a datastore, or even to disk.
  prefs: []
  type: TYPE_NORMAL
- en: However, in this case, we'll just let this data live in the memory space of
    this application by creating a map of the `bruteforce.Requester` struct. This
    means that if our server reboots, we lose these attempts. Similarly, it means
    that multiple server setups won't necessarily know about attempts on other servers.
  prefs: []
  type: TYPE_NORMAL
- en: Both these problems can be easily solved by putting less ephemeral storage behind
    the logging of bad attempts, but we'll keep it simple for this demonstration.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `api.go` file, we''ll bring in `bruteforce` and create our map of `Requesters`
    when we start the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, of course, to take this from being a nil map, we''ll initialize it
    when our server starts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We're now ready to start logging our attempts.
  prefs: []
  type: TYPE_NORMAL
- en: If you've decided to implement middleware for login attempts, make the adjustment
    here by simply putting these changes into the middleware handler instead of the
    separate function named `CheckLogin()` that we originally called.
  prefs: []
  type: TYPE_NORMAL
- en: No matter what happens with our authentication—be it a valid user, valid authentication;
    a valid user, invalid authentication; or an invalid user—we want to add this to
    our `LoginAttempts` function of the respective `Requester` struct.
  prefs: []
  type: TYPE_NORMAL
- en: We'll bind each `Requester` map to either our IP or hostname. In this case,
    we will use the IP address.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `net` package has a function called `SplitHostPort` that properly explodes
    our `RemoteAddr` value from the `http.Request` handler, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also just use the entire `r.RemoteAddr` value, which may be more comprehensive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This means that no matter what, we invoke another attempt to the tally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `CheckLogin()` will always create the map''s key if it doesn''t exist,
    we''re free to safely evaluate on this key further down the authentication pipeline.
    For example, in our `UserLogin()` handler, which processes an e-mail address and
    a password from a form and checks against our database, we first call `UserLogin()`
    before checking the submitted values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If we check against our maximum login attempts following the `CheckLogin()`
    call, we'll never allow database lookups after a certain point.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code of the `UserLogin()` function, we compare the hash from
    the submitted password to the one stored in the database and return an error on
    an unsuccessful match. Let''s use that to increment the `FailedAttempts` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This simply increases our general `FailedAttempts` integer value with each invalid
    login per IP.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we''re not yet doing anything with this. To inject it as a blocking
    element, we''ll need to evaluate it after the `CheckLogin()` call to initialize
    the map''s hash if it does not exist yet:'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the preceding code, you may notice that the mutable `FailedAttempts` value
    that is bound by `RemoteAddr` could theoretically be susceptible to a race condition,
    causing unnatural increments and premature blocking. A mutex or similar locking
    mechanism may be used to prevent this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This call to `Check()` prevents banned IPs from even accessing our database
    at the login endpoint, which can still cause additional strain, bottlenecks, and
    potential service disruptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And, to update our `Check()` method from a brute-force attack, we will use
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This supplies us with an ephemeral way to store information about login attempts,
    but what if we want to find out whether someone is simply testing account names
    along with passwords, ala "guest" or "admin?"
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we''ll just add an additional check to `UserLogin()` to see whether
    the requested e-mail account exists. If it does, we''ll just continue. If it does
    not exist, we''ll increment `FailedInvalidUserAttempts`. We can then make a decision
    about whether we should block access to the login portion of `UserLogin()` at
    a lower threshold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If we decide that the traffic is represented by fully failed authenticated attempts
    (for example, invalid users), we can also pass that information to IP tables or
    our front-end proxy to block the traffic from even getting to our application.
  prefs: []
  type: TYPE_NORMAL
- en: Handling basic authentication in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One area at which we didn't look too deeply in the authentication section of
    [Chapter 7](ch07.html "Chapter 7. Working with Other Web Technologies"), *Working
    with Other Web Technologies*, was basic authentication. It's worth talking about
    as a matter of security, particularly as it can be a very simple way to allow
    authentication in lieu of OAuth, direct login (with sessions), or keys. Even in
    the latter, it's entirely possible to utilize API keys as part of basic authentication.
  prefs: []
  type: TYPE_NORMAL
- en: The most critical aspect of basic authentication is an obvious one—**TLS**.
    Unlike methods that involve passing keys, there's very little obfuscation involved
    in the basic authentication header method, as beyond Base64 encoding, everything
    is essentially cleartext.
  prefs: []
  type: TYPE_NORMAL
- en: This of course enables some very simple man-in-the-middle opportunities for
    nefarious parties.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 7](ch07.html "Chapter 7. Working with Other Web Technologies"),
    *Working with Other Web Technologies*, we explored the concept of creating transaction
    keys with shared secrets (similar to OAuth) and storing valid authentication via
    sessions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can grab usernames and passwords or API keys directly from the `Authorization`
    header and measure attempts on the API by including a check for this header at
    the top of our `CheckLogin()` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we can allow our `CheckLogin()` function to utilize either
    the data posted to our API to obtain username and password combinations, API keys,
    or authentication tokens, or we can also ingest that data directly from the header.
  prefs: []
  type: TYPE_NORMAL
- en: Handling input validation and injection mitigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If a brute-force attack is a rather inelegant exercise in persistence, one in
    which the attacker has no access, input or injection attacks are the opposite.
    At this point, the attacker has some level of trust from the application, even
    if it is minimal.
  prefs: []
  type: TYPE_NORMAL
- en: SQL injection attacks can happen at any level in the application pipeline, but
    cross-site scripting and cross-site request forgeries are aimed less at the application
    and more at other users, targeting vulnerabilities to expose their data or bring
    other security threats directly to the application or browser.
  prefs: []
  type: TYPE_NORMAL
- en: In this next section, we'll examine how to keep our SQL queries safe through
    input validation, and then move onto other forms of input validation as well as
    output validation and sanitization.
  prefs: []
  type: TYPE_NORMAL
- en: Using best practices for SQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few very big security loopholes when it comes to using a relational
    database, and most of them apply to other methods of data storage. We've looked
    at a few of these loopholes such as properly and uniquely salting passwords and
    using secure sessions. Even in the latter, there is always some risk of session
    fixation attacks, which allow shared or persistent shared sessions to be hijacked.
  prefs: []
  type: TYPE_NORMAL
- en: One of the more pervasive attack vectors, which modern database adapters tend
    to eliminate, are injection attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Injection attacks, particularly SQL injections, are among the most prevalent
    and yet most avoidable loopholes that can expose sensitive data, compromise accountability,
    and even make you lose control of entire servers.
  prefs: []
  type: TYPE_NORMAL
- en: A keen eye may have caught it, but earlier in this book, we deliberately built
    an unsafe query into our `api.go` file that can allow SQL injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the line in our original `CreateUser()` handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: It goes without saying, but constructing queries as a straight, direct SQL command
    is frowned upon in almost all languages.
  prefs: []
  type: TYPE_NORMAL
- en: A good general rule of thumb is to treat all externally produced data, including
    user input, internal or administrator user input, and external APIs as malicious.
    By being as suspicious as possible of user-supplied data, we improve the odds
    of catching potentially harmful injections.
  prefs: []
  type: TYPE_NORMAL
- en: Most of our other queries utilized the parameterized `Query()` function that
    allows you to add variadic parameters that correspond to the `?` tokens.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that since we store the user's unique salt in the database (at least
    in our example), losing access to the MySQL database means that we also lose the
    security benefits of having a password salt in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: This doesn't mean that all accounts' passwords are exposed in this scenario,
    but at this point, having direct login credentials for users would only be useful
    for exploiting other services if the users maintain poor personal password standards,
    that is, sharing passwords across services.
  prefs: []
  type: TYPE_NORMAL
- en: Validating output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Normally, the idea of output validation seems foreign, particularly when the
    data is sanitized on the input side.
  prefs: []
  type: TYPE_NORMAL
- en: Preserving the values as they were sent and only sanitizing them when they are
    output may make some sense, but it increases the odds that said values might not
    be sanitized on the way out to the API consumer.
  prefs: []
  type: TYPE_NORMAL
- en: There are two main ways in which a payload can be delivered to the end user,
    either in a stored attack where we, as the application, keep the vector verbatim
    on our server, or in a reflected attack wherein some code is appended via another
    method such as an e-mail message that includes the payload.
  prefs: []
  type: TYPE_NORMAL
- en: APIs and web services can sometimes be especially susceptible to not only **XSS**
    (short form for **Cross-Site Scripting**) but also **CSRF** (short form for **Cross-Site**
    **Request Forgery**).
  prefs: []
  type: TYPE_NORMAL
- en: We'll briefly look at both of these and the ways in which we can limit their
    efficacy within our web service.
  prefs: []
  type: TYPE_NORMAL
- en: Protection against XSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Anytime we're dealing with user input that will later be translated into output
    for the consumption of other users, we need to be wary of Cross-Site Scripting
    or Cross-Site Request Forgery in the resulting data payload.
  prefs: []
  type: TYPE_NORMAL
- en: This isn't necessarily a matter solely for output validation. It can and should
    be addressed at the input stage as well. However, our output is our last line
    of defense between one user's arbitrary text and another user's consumption of
    that text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Traditionally, this is best illustrated through something like the following
    nefarious piece of hypothetical code. A user hits our `/api/statuses` endpoint
    with a `POST` request, after authenticating it via whatever method is selected,
    and posts the following status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If presented in a template, as in our interface example, then this is a problem
    that will be mitigated automatically by using Go's template engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take the preceding example data and see what it looks like on our interface''s
    user profile page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Protection against XSS](img/1304OS_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `html/template` package automatically escapes the HTML output to prevent
    code injection, and it requires an override to allow any HTML tags to come through
    as originally entered.
  prefs: []
  type: TYPE_NORMAL
- en: However, as an API provider, we are agnostic towards the type of consuming application
    language and support or care given to sanitation of input.
  prefs: []
  type: TYPE_NORMAL
- en: The onus on escaping data is a matter that needs some consideration, that is,
    should the data that your application provides to clients come pre-sanitized or
    should it come with a usage note about sanitizing data? The answer in almost all
    cases is the first option, but depending on your role and the type of data, it
    could go either way. On the other hand, unsanitizing the data in certain situations
    (for example, APIs) on the frontend means potentially having to reformat data
    in many different ways.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier in this chapter, we showed you some input validation techniques for
    allowing or disallowing certain types of data (such as characters, tags, and so
    on), and you can apply some of these techniques to an endpoint such as `/statuses`.
  prefs: []
  type: TYPE_NORMAL
- en: It makes more sense, however, to allow this data; but, sanitize it either before
    saving it to a database/datastore or returning it via an API endpoint. Here are
    two ways in which we can use the `http/template` package to do either.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, when we accept data via the `/api/statuses` endpoint, we can utilize
    one or more of the functions in `html/template` to prevent certain types of data
    from being stored. The functions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`template.HTMLEscapeString`: This encodes HTML tags and renders the resulting
    string as non-HTML content'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`template.JSEscapeString()`: This encodes JavaScript-specific pieces of a string
    to prevent proper rendering'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the purpose of keeping this simple for potential output through HTML, we
    can just apply `HTMLEscapeString()` to our data, which will disable any JavaScript
    calls from executing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes the data escape on the input (`StatusCreate`) side. If we want to
    add JavaScript escaping (which, as noted earlier, may not be necessary), it should
    come before the HTML escaping, as noted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If in lieu of escaping on the input side, we wish to do it on the output side,
    the same template escape calls can be made as part of the respective status request
    API calls, like `/api/statuses`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If we want to attempt to detect and log attempts to pass specific HTML elements
    into input elements, we can create a new logger for XSS attempts and capture any
    text that matches a `<script>` element, a `<iframe>` element, or any other element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Doing this can be as complex as a tokenizer or a more advanced security package
    or as simple as a regular expression match, as we will see in the following examples.
    First, we will look at the code in our logging setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And the changes in our initialization code are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, make the following changes back in our application''s `StatusCreate`
    handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Detecting tags this way, through regular expressions, is not airtight nor is
    it intended to be. Remember that we'll be sanitizing the data either on the input
    side or the output side, so if we can catch attempts through this method, it will
    give us some insight into potentially malicious attempts against our application.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to be more idiomatic and comprehensive, we can simply sanitize the
    text and compare it with the original. If the two values do not match, we can
    surmise that HTML was included.
  prefs: []
  type: TYPE_NORMAL
- en: This does mean that we'll get a positive for innocuous HTML tags such as bold
    tags or table tags.
  prefs: []
  type: TYPE_NORMAL
- en: Using server-side frameworks in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We would be remiss if, while detailing how to build a web service from scratch,
    we didn't at least touch upon integrating or exclusively using some existing frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Although you'll never get the same experience by plugging in such a framework
    as you would by designing one from scratch, for practical purposes, there's often
    no reason to reinvent the wheel when you want to start a project.
  prefs: []
  type: TYPE_NORMAL
- en: Go has quite a few readily available and mature web/HTML frameworks, but it
    also has a handful of noteworthy frameworks that are specifically designed for
    web services with some of the delivery methods and additional hooks that you might
    expect to see.
  prefs: []
  type: TYPE_NORMAL
- en: By some measurements, it's fair to describe Gorilla as a framework; however,
    as the name implies, it's a little basic.
  prefs: []
  type: TYPE_NORMAL
- en: Whether you use an existing framework or choose to build your own (either for
    the experience or to completely customize it due to business requirements), you
    should probably consider doing a bit
  prefs: []
  type: TYPE_NORMAL
- en: We'll briefly look at a few of these frameworks and how they can simplify the
    development of small web-based projects.
  prefs: []
  type: TYPE_NORMAL
- en: Tiger Tonic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tiger Tonic is specifically an API-centric framework, so we'll mention it first
    in this section. This takes a very idiomatic Go approach to developing JSON web
    services.
  prefs: []
  type: TYPE_NORMAL
- en: Responses are primarily intended to be in JSON only and multiplexing should
    seem pretty familiar to the style introduced by Gorilla.
  prefs: []
  type: TYPE_NORMAL
- en: Tiger Tonic also provides some quality logging features that allow you to funnel
    logs directly into the Apache format for more detailed analysis. Most importantly,
    it handles middleware in a way that allows some conditional operations based on
    the results of the middleware itself.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read more about Tiger Tonic at [https://github.com/rcrowley/go-tigertonic](https://github.com/rcrowley/go-tigertonic)
    or download the documentation using the `go get github.com/rcrowley/go-tigertonic`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Martini
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The web framework Martini is one of the more popular web frameworks for the
    relatively young Go language, largely due to its similarity in design to both
    the `Node.js` framework Express and the popular Ruby-on-Rails framework Sinatra.
  prefs: []
  type: TYPE_NORMAL
- en: Martini also plays extraordinarily well with middleware, so much so that it's
    often brought in exclusively for this purpose. It also comes with a few standard
    middleware handlers like `Logger()` that takes care of logging in and out and
    `Recovery()` that recovers from panics and returns HTTP errors.
  prefs: []
  type: TYPE_NORMAL
- en: Martini is built for a large swath of web projects, and it may include more
    than what is necessary for a simple web service; however, it is an excellent all-inclusive
    framework that's worth checking out.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read more about Martini at [https://github.com/go-martini/martini](https://github.com/go-martini/martini)
    or download the documentation using the `go get github.com/go-martini/martini`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Goji
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike Martini, which is quite comprehensive and far-reaching, the Goji framework
    is minimalistic and lean. The primary advantages of Goji are its incredibly quick
    routing system, a low overhead for additional garbage collection, and robust middleware
    integrations.
  prefs: []
  type: TYPE_NORMAL
- en: Goji uses Alice for middleware, which we briefly touched on in an earlier chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read more about the Goji micro framework at [https://goji.io/](https://goji.io/)
    and download it with the `go get github.com/zenazn/goji` and `go get github.com/zenazn/goji/web`
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: Beego
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Beego is a more complex type of framework that has quickly become one of the
    more popular Go frameworks for web projects.
  prefs: []
  type: TYPE_NORMAL
- en: Beego has a lot of features that can come in handy for a web service, despite
    the additional feature set that is largely intended for rendered web pages. The
    framework comes with its own sessions, routing, and cache modules, and also includes
    a live monitoring process that allows you to analyze your project dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read more about Beego at [http://beego.me/](http://beego.me/) or download
    it using the `go get github.com/astaxie/beego` command.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final chapter, we looked at how to keep our web service as airtight
    as possible from common security issues and looked at solutions to mitigate issues
    if and when a breach happens.
  prefs: []
  type: TYPE_NORMAL
- en: As APIs scale both in popularity and scope, it is paramount to ensure that users
    and their data are safe.
  prefs: []
  type: TYPE_NORMAL
- en: We hope you have been (and will be) able to utilize these security best practices
    and tools to improve the overall reliability and speed of your application.
  prefs: []
  type: TYPE_NORMAL
- en: While our primary project—the social network—is by no means a complete or comprehensive
    project, we've broken down aspects of such a project to demonstrate routing, caching,
    authentication, display, performance, and security.
  prefs: []
  type: TYPE_NORMAL
- en: If you wish to continue expanding the project, feel free to augment, fork, or
    clone the example at [https://github.com/nkozyra/masteringwebservices](https://github.com/nkozyra/masteringwebservices).
    We'd love to see the project continue to serve as a demonstration of features
    and best practices related to web services and APIs in Go.
  prefs: []
  type: TYPE_NORMAL
