- en: Building Network Web Services with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we were a consumer of the APIs provided by various
    tools. In [Chapter 3](d2c76e60-c005-4efc-85de-c7a3253e4b47.xhtml), *APIs and Intent-Driven
    Networking,* we saw that we can use a `HTTP POST` method to NX-API at the `http://<your
    router ip>/ins` URL with the `CLI` command embedded in the body to execute commands
    remotely on the Cisco Nexus device; the device then returns the command execution
    output in return. In [Chapter 8](5f7e76ef-d93a-4689-8054-8be72d41d69b.xhtml),
    *Network Monitoring with Python – Part 2,* we used the `GET` method for our sFlow-RT
    at `http://<your host ip>:8008/version` with an empty body to retrieve the version
    of the sFlow-RT software. These exchanges are examples of RESTful web services.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to Wikipedia ([https://en.wikipedia.org/wiki/Representational_state_transfer](https://en.wikipedia.org/wiki/Representational_state_transfer)):'
  prefs: []
  type: TYPE_NORMAL
- en: '"Representational state transfer (REST) or RESTful web services is one way
    of providing interoperability between computer systems on the internet. REST-compliant
    web services allow requesting systems to access and manipulate the textual representation
    of web resources using a uniform and predefined set of stateless operations."'
  prefs: []
  type: TYPE_NORMAL
- en: As noted, REST web services using the HTTP protocol is only one of many methods
    of information exchange on the web; other forms of web services also exist. However,
    it is the most commonly used web service today, with the associated `GET`, `POST`,
    `PUT`, and `DELETE` verbs as a predefined way of information exchange.
  prefs: []
  type: TYPE_NORMAL
- en: One of the advantages of using RESTful services is the ability it provides for
    you to hide your internal operations from the user while still providing them
    with the service. For example, in the case of sFlow-RT, if we were to log in to
    the device where our software is installed, we would need more in-depth knowledge
    of the tool to know where to check for the software version. However, by providing
    the resources in the form of a URL, the software abstracts the version-checking
    operations from the requester, making the operation much simpler. The abstraction
    also provides a layer of security, as it can now open up the endpoints only as
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the master of the network universe, RESTful web services provide many notable
    benefits that we can enjoy, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You can abstract the requester from learning about the internals of the network
    operations. For example, we can provide a web service to query the switch version
    without the requester having to know the exact CLI command or API format required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can consolidate and customize operations that uniquely fit our network needs,
    such as a resource to upgrade all our top-of-rack switches.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can provide better security by only exposing the operations as needed. For
    example, we can provide read-only URLs (`GET`) to core network devices and read-write
    URLs (`GET` / `POST` / `PUT` / `DELETE`) to access-level switches.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, we will use one of the most popular Python web frameworks, **Flask**,
    to create our own REST web service for our network. In this chapter, we will learn
    about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Comparing Python web frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Flask
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operations involving static network contents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operations involving dynamic network operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started by looking at the available Python web frameworks and why
    we chose Flask.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing Python web frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python is known for its great many web frameworks. There is a running joke
    at PyCon, which is that you can never work as a full-time Python developer without
    working with any of the Python web frameworks. There is even an annual conference
    held for Django, one of the most popular Python frameworks, called DjangoCon. It
    attracts hundreds of attendees every year. If you sort the Python web frameworks
    on [https://hotframeworks.com/languages/python](https://hotframeworks.com/languages/python),
    you can see that there is no shortage of choices when it comes to Python and web
    frameworks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/15528b62-5084-4ef6-936e-5f53f2f6faa0.png)Python web frameworks ranking'
  prefs: []
  type: TYPE_NORMAL
- en: With so many options to choose from, which framework should we pick? Clearly,
    trying all the frameworks out yourself would be really time-consuming. The question
    about which web framework is better is also a passionate topic among web developers.
    If you ask this question on any of the forums, such as Quora, or search on Reddit,
    get ready for some highly opinionated answers and heated debates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking of Quora and Reddit, here''s an interesting fact: both Quora and Reddit
    were written in Python. Reddit uses Pylons ([https://www.reddit.com/wiki/faq#wiki_so_what_python_framework_do_you_use.3F](https://www.reddit.com/wiki/faq#wiki_so_what_python_framework_do_you_use.3F.)),
    while Quora started with Pylons but replaced a portion of the framework with their
    in-house code ([https://www.quora.com/What-languages-and-frameworks-are-used-to-code-Quora](https://www.quora.com/What-languages-and-frameworks-are-used-to-code-Quora)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, I have my own bias toward programming languages (Python!) and web
    frameworks (Flask!). In this section, I hope to convey to you my reasoning behind
    choosing one over the other. Let''s pick the top two frameworks from the preceding
    HotFrameworks list and compare them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Django**: The self-proclaimed "web framework for perfectionists with deadlines"
    is a high-level Python web framework that encourages rapid development and a clean,
    pragmatic design ([https://www.djangoproject.com/](https://www.djangoproject.com/)).
    It is a large framework with pre-built code that provides an administrative panel
    and built-in content management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flask**: This is a microframework for Python and is based on Werkzeug, Jinja2,
    and good intentions ([http://flask.pocoo.org/](http://flask.pocoo.org/)). By being
    a microframework, Flask intends on keeping the core small and being easy to extend
    when needed. The "micro" in microframework does not mean that Flask is lacking
    in functionality, nor does it mean it cannot work in a production environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Personally, I find Django a bit difficult to extend, and most of the time, I
    only use a fraction of the pre-built code. The Django framework also has a strong
    opinion on how things should be done; any deviation from it would sometimes leave
    the user feeling that they are "fighting with the framework". For example, if
    you look at the Django Database documentation, ([https://docs.djangoproject.com/en/2.1/ref/databases/](https://docs.djangoproject.com/en/2.1/ref/databases/)),
    you will notice that the framework supports a number of different SQL databases.
    However, they are all variants of SQL database such as MySQL, PostgreSQL, SQLite,
    and others. What if you want to use a NoSQL database such as MongoDB or CouchDB?
    It might be possible but could be leaving you in your own hands. Being an opinionated
    framework is certainly not a bad thing, it is just a matter of opinion (no pun intended).
  prefs: []
  type: TYPE_NORMAL
- en: The idea of keeping the core code small and extending it when needed is very
    appealing to me. The initial example on the documentation to get Flask up and
    running consists of only eight lines of code and is easy to understand, even if
    you don't have any prior experience. Since Flask is built with extensions in mind,
    writing your own extensions, such as decorator, is pretty easy. Even though it
    is a microframework, the Flask core still includes the necessary components, such
    as a development server, debugger, integration with unit tests, RESTful request
    dispatching, and more, to get you started out of the box. As you can see, besides
    Django, Flask is the second most popular Python framework by some measure. The
    popularity that comes with community contribution, support, and quick development
    helps it further expand its reach.
  prefs: []
  type: TYPE_NORMAL
- en: For the preceding reasons, I feel that Flask is an ideal choice for us when
    it comes to building network web services.
  prefs: []
  type: TYPE_NORMAL
- en: Flask and lab setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will use `virtualenv` to isolate the environment we will
    work in. As the name indicates, virtualenv is a tool that creates a virtual environment.
    It can keep the dependencies required by different projects in separate places
    while keeping the global site-packages clean. In other words, when you install
    Flask in the virtual environment, it is only installed in the local `virtualenv`
    project directory, not the global site-packages. This make porting the code to
    other places very easy.
  prefs: []
  type: TYPE_NORMAL
- en: The chances are high that you may have already come across `virtualenv` while
    working with Python before, so we will run through this process quickly. If you
    have not, feel free to pick up one of many excellent tutorials online, such as
    [http://docs.python-guide.org/en/latest/dev/virtualenvs/](http://docs.python-guide.org/en/latest/dev/virtualenvs/).
  prefs: []
  type: TYPE_NORMAL
- en: 'To use , we will first need to install `virtualenv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The proceeding command uses the `venv` module (`-m venv`) to get a `venv` folder
    with a full Python interpreter inside it. We can use `source venv/bin/activate`
    and `deactivate` to move in and out of the local Python environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this chapter, we will install quite a few Python packages. To make life
    easier, I have included a `requirements.txt` file on the book''s GitHub repository;
    we can use it to install all the necessary packages (remember to activate your
    virtualenv). You should see packages being downloaded and successfully installed
    at the end of the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For our network topology, we will use a simple four-node network, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1647347c-bb46-4301-82d5-4cd6b61096bc.png) Lab topology'
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at Flask in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that, from here on out, I will assume that you will always execute
    from the virtual environment and that you have installed the necessary packages
    in the `requirements.txt` file.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Flask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like most popular open source projects, Flask has very good documentation, which
    is available at [http://flask.pocoo.org/docs/0.10/](http://flask.pocoo.org/docs/0.10/).
    If any of the examples are unclear, you can be sure to find the answer on the
    project documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'I would also highly recommend Miguel Grinberg''s ([https://blog.miguelgrinberg.com/](https://blog.miguelgrinberg.com/))
    work related to Flask. His blog, book, and video training have taught me a lot
    about Flask. In fact, Miguel''s class *Building Web APIs with Flask* inspired
    me to write this chapter. You can take a look at his published code on GitHub:
    [https://github.com/miguelgrinberg/oreilly-flask-apis-video](https://github.com/miguelgrinberg/oreilly-flask-apis-video).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first Flask application is contained in one single file, `chapter9_1.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will almost always be your design pattern for Flask initially. We create
    an instance of the Flask class with the first argument as the name of the application''s
    module package. In this case, we used a single module; while doing this yourself,
    type in a name of your choice to indicate whether it is started as an application
    or imported as a module. We then use the route decorator to tell Flask which URL
    should be handled by the `hello_networkers()` function; in this case, we indicated
    the root path. We end the file with the usual name ([https://docs.python.org/3.5/library/__main__.html](https://docs.python.org/3.5/library/__main__.html)).
    We only added the host and debug options, which allow more verbose output and
    also allow us to listen on all the interfaces of the host (by default, it only
    listens on loopback). We can run this application using the development server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a server running, let's test the server response with an HTTP
    client.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTPie client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already installed HTTPie ([https://httpie.org/](https://httpie.org/))
    as part of the installation from reading the `requirements.txt` file. Although
    this book is printed in black and white text so it does not show up here, in your
    installation, you can see that HTTPie has better syntax highlighting for HTTP
    transactions. It also has a more intuitive command-line interaction with the RESTful
    HTTP server. We can use it to test our first Flask application (more examples
    on HTTPie to follow):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can also use the `-i` switch with curl to see the HTTP headers:
    `curl -i http://172.16.1.173:5000/`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use `HTTPie` as our client for this chapter; it is worth taking a minute
    or two to take a look at its usage. We will use the free website HTTP Bin ([https://httpbin.org/](https://httpbin.org/))
    to show the use of `HTTPie`. The usage of `HTTPie` follows this simple pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Following the preceding pattern, a `GET` request is very straightforward, as
    we have seen with our Flask development server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'JSON is the default implicit content type for `HTTPie`. If your HTTP body contains
    just strings, no other operation is needed. If you need to apply non-string JSON
    fields, use `:=` or other documented special characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `HTTPie` is a big improvement from the traditional curl syntax
    and makes testing the REST API a breeze.
  prefs: []
  type: TYPE_NORMAL
- en: More usage examples are available at [https://httpie.org/doc#usage](https://httpie.org/doc#usage.).
  prefs: []
  type: TYPE_NORMAL
- en: Getting back to our Flask program, a large part of API building is based on
    the flow of URL routing. Let's take a deeper look at the `app.route()` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: URL routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We added two additional functions and paired them up with the appropriate `app.route()`
    route in `chapter9_2.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is that different endpoints are passed to different functions. We
    can verify this with two `http` requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the routing will be pretty limited if we have to keep it static all
    the time. There are ways to pass variables from the URL to Flask; we will look
    at an example of this in the coming section.
  prefs: []
  type: TYPE_NORMAL
- en: URL variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned previously, we can also pass variables to the URL, as seen in
    the examples discussed in `chapter9_3.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that, in the `/routers/<hostname>` URL, we pass the `<hostname>` variable
    as a string; `<int:interface_number>` will specify that the variable should only
    be an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The converter includes integers, float, and path (it accepts slashes).
  prefs: []
  type: TYPE_NORMAL
- en: Besides matching static routes, we can also generate URLs on the fly. This is
    very useful when we do not know the endpoint variable in advance or if the endpoint
    is based on other conditions, such as the values queried from a database. Let's
    take a look at an example of this.
  prefs: []
  type: TYPE_NORMAL
- en: URL generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In `chapter9_4.py`, we wanted to dynamically create a URL in the form of `''/<hostname>/list_interfaces''`
    in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon its execution, you will have a nice and logical URL, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: For now, you can think of `app.text_request_context()` as a dummy `request`
    object that is necessary for demonstrative purposes. If you are interested in
    the local context, feel free to take a look at [http://werkzeug.pocoo.org/docs/0.14/local/](http://werkzeug.pocoo.org/docs/0.14/local/).
  prefs: []
  type: TYPE_NORMAL
- en: The jsonify return
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another time saver in Flask is the `jsonify()` return, which wraps `json.dumps()`
    and turns the JSON output into a `response` object with `application/json` as
    the content type in the HTTP header. We can tweak the last script a bit, just
    like we will do in `chapter9_5.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We will see the result returned as a `JSON` object with the appropriate header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Having looked at URL routing and the `jsonify()` return in Flask, we are now
    ready to build an API for our network.
  prefs: []
  type: TYPE_NORMAL
- en: Network resource API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, your network consists of network devices that do not change a lot once
    put into production. For example, you would have core devices, distribution devices,
    spine, leaf, top-of-rack switches, and so on. Each of the devices would have certain
    characteristics and features that you would like to keep in a persistent location
    so that you can easily retrieve them later on. This is often done in terms of
    storing data in a database. However, you would not normally want to give other
    users, who might want this information, direct access to the database; nor do
    they want to learn all the complex SQL query language. For this case, we can leverage
    Flask and the **Flask-SQLAlchemy** extension of Flask.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about Flask-SQLAlchemy at [http://flask-sqlalchemy.pocoo.org/2.1/](http://flask-sqlalchemy.pocoo.org/2.1/).
  prefs: []
  type: TYPE_NORMAL
- en: Flask-SQLAlchemy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of course, SQLAlchemy and the Flask extension are a database abstraction layer
    and object relational mapper, respectively. It's a fancy way of saying to use
    the `Python` object for a database. To make things simple, we will use SQLite
    as the database, which is a flat file that acts as a self-contained SQL database.
    We will look at the content of `chapter9_db_1.py` as an example of using Flask-SQLAlchemy
    to create a network database and insert a table entry into the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, we will create a Flask application and load the configuration
    for SQLAlchemy, such as the database path and name, then create the `SQLAlchemy`
    object by passing the application to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then create a `database` object and its associated primary key and various
    columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can invoke the `database` object, create entries, and insert them into the
    database table. Keep in mind that anything we add to the session needs to be committed
    to the database in order to be permanent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We will run the Python script and check for the existence of the database file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the interactive prompt to check the database table entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also create new entries in the same manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Network content API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive into the code, let's take a moment to think about the API that
    we are trying to create. Planning for an API is usually more art than science;
    it really depends on your situation and preference. What I suggest next is, by
    no means, the right way, but for now, stay with me for the purposes of getting
    started.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that, in our diagram, we have four Cisco IOSv devices. Let's pretend
    that two of them, `iosv-1` and `iosv-2`, are of the network role of the spine.
    The other two devices, `iosv-3` and `iosv-4`, are in our network service as leafs.
    These are obviously arbitrary choices and can be modified later on, but the point
    is that we want to serve data about our network devices and expose them via an
    API.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make things simple, we will create two APIs: a devices group API and a single
    device API:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0cf9e61a-6b19-4746-b968-9ef5830d08ab.png)Network content API'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first API will be our `http://172.16.1.173/devices/` endpoint that supports
    two methods: `GET` and `POST`. The `GET` request will return the current list
    of devices, while the `POST` request with the proper JSON body will create the
    device. Of course, you can choose to have different endpoints for creation and
    query, but in this design, we choose to differentiate the two by the HTTP methods.'
  prefs: []
  type: TYPE_NORMAL
- en: The second API will be specific to our device in the form of `http://172.16.1.173/devices/<device
    id>`. The API with the `GET` request will show the details of the device that
    we have entered into the database. The `PUT` request will modify the entry with
    the update. Note that we use `PUT` instead of `POST`. This is typical of HTTP
    API usage; when we need to modify an existing entry, we will use `PUT` instead
    of `POST`.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should have a good idea about what your API will look like.
    To better visualize the end result, I am going to jump ahead and show the end
    result quickly before we take a look at the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `POST` request to the `/devices/` API will allow you to create an entry.
    In this case, I would like to create our network device with attributes such as
    hostname, loopback IP, management IP, role, vendor, and the operating system it
    runs on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'I can repeat the preceding step for the additional three devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If we can use the same API with the `GET` request, we will be able to see the
    list of network devices that we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, using the `GET` request for `/devices/<id>` will return specific
    information related to the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s pretend we have downgraded the `r1` operating system from `15.6` to `14.6`.
    We can use the `PUT` request to update the device record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's take a look at the code in `chapter9_6.py` that helped create the
    preceding APIs. What's cool, in my opinion, is that all of these APIs were done
    in a single file, including the database interaction. Later on, when we outgrow
    the APIs at hand, we can always separate the components out, such as having a
    separate file for the database class.
  prefs: []
  type: TYPE_NORMAL
- en: Devices API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `chapter9_6.py` file starts with the necessary imports. Note that the following
    request import is the `request` object from the client and not the requests package
    that we were using in the previous chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We declared a `database` object with its `id` as the primary key and string
    fields for `hostname`, `loopback`, `mgmt_ip`, `role`, `vendor`, and `os`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `get_url()` function returns a URL from the `url_for()` function. Note
    that the `get_device()` function that''s called is not defined just yet under
    the `''/devices/<int:id>''` route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `export_data()` and `import_data()` functions are mirror images of each
    other. One is used to get the information from the database to the user (`export_data()`) when
    we use the `GET` method. The other is to put information from the user to the
    database (`import_data()`) when we use the `POST` or `PUT` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `database` object in place as well as the import and export functions
    created, the URL dispatch is straightforward for device operations. The `GET`
    request will return a list of devices by querying all the entries in the devices
    table and also return the URL of each entry. The `POST` method will use the `import_data()`
    function with the global `request` object as the input. It will then add the device
    and commit the information to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look at the `POST` method, the returned body is an empty JSON body,
    with the status code `201` (created) as well as extra headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Let's look at the API that queries and returns information pertaining to individual
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: The device ID API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The route for individual devices specifies that the ID should be an integer,
    which can act as our first line of defense against a bad request. The two endpoints
    follow the same design pattern as our `/devices/` endpoint, where we use the same
    `import` and `export` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note the `query_or_404()` method; it provides a convenient way for returning
    `404 (not found)` if the database query returns negative for the ID passed in.
    This is a pretty elegant way of providing a quick check on the database query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the last part of the code creates the database table and starts the
    Flask development server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This is one of the longer Python scripts in this book, which is why we took
    more time to explain it in detail. The script provides a way to illustrate how
    we can utilize the database in the backend to keep track of the network devices
    and only expose them to the external world as APIs, using Flask.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will take a look at how to use the API to perform asynchronous
    tasks on either individual devices or a group of devices.
  prefs: []
  type: TYPE_NORMAL
- en: Network dynamic operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our API can now provide static information about the network; anything that
    we can store in the database can be returned to the requester. It would be great
    if we can interact with our network directly, such as a query for the device information
    or to push configuration changes to the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start this process by leveraging the script we have already seen in
    [Chapter 2](8cefc139-8dfa-4250-81bf-928231e20b22.xhtml), *Low-Level Network Device
    Interactions,* for interacting with a device via Pexpect. We will modify the script
    slightly into a function we can repeatedly use in `chapter9_pexpect_1.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test the new function via the interactive prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that your Pexpect script works before you proceed. The following code
    assumes that you have entered the necessary database information from the previous
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add a new API for querying the device version in `chapter9_7.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be returned to the requester:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also add another endpoint that will allow us to perform a bulk action
    on multiple devices, based on their common fields. In the following example, the
    endpoint will take the `device_role` attribute in the URL and match it up with
    the appropriate device(s):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Of course, looping through all the devices in `Device.query.all()` is not efficient,
    as in the preceding code. In production, we will use a SQL query that specifically
    targets the role of the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we use the REST API, we can see that all the spine, as well as leaf, devices
    can be queried at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As illustrated, the new API endpoints query the device(s) in real time and return
    the result to the requester. This works relatively well when you can guarantee
    a response from the operation within the timeout value of the transaction (30
    seconds, by default) or if you are OK with the HTTP session timing out before
    the operation is completed. One way to deal with the timeout issue is to perform
    the tasks asynchronously. We will look at how to do so in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Asynchronous operations are, in my opinion, an advanced topic of Flask. Luckily,
    Miguel Grinberg ([https://blog.miguelgrinberg.com/](https://blog.miguelgrinberg.com/)),
    whose Flask work I am a big fan of, provides many posts and examples on his blog
    and on GitHub. For asynchronous operations, the example code in `chapter9_8.py`
    referenced Miguel''s GitHub code on the `Raspberry Pi` file ([https://github.com/miguelgrinberg/oreilly-flask-apis-video/blob/master/camera/camera.py](https://github.com/miguelgrinberg/oreilly-flask-apis-video/blob/master/camera/camera.py))
    for the background decorator. We will start by importing a few more modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The background decorator takes in a function and runs it as a background task
    using thread and UUID for the task ID. It returns the status code `202` accepted
    and the location of the new resources for the requester to check. We will make
    a new URL for status checking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we retrieve the resource, it is deleted. This was done by setting `app.config[''AUTO_DELETE_BG_TASKS'']`
    to `true` at the top of the app. We will add this decorator to our version endpoints
    without changing the other part of the code because all of the complexity is hidden
    in the decorator (how cool is that!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The end result is a two-part process. We will perform the `GET` request for
    the endpoint and receive the location header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then make a second request to the location to retrieve the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify that the status code `202` is returned when the resource is not ready,
    we will use the following script, `chapter9_request_1.py`, to immediately make
    a request to the new resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the result, the status code is returned while the resource
    is still being run in the background as `202`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Our APIs are coming along nicely! Because our network resource is valuable to
    us, we should secure API access to only authorized personnel. We will add basic
    security measures to our API in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For user authentication security, we will use Flask''s `httpauth` extension,
    written by Miguel Grinberg, as well as the password functions in Werkzeug. The
    `httpauth` extension should have been installed as part of the `requirements.txt`
    installation at the beginning of this chapter. The new file illustrating the security
    feature is named `chapter9_9.py`; we will start with a few more module imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We will create an `HTTPBasicAuth` object as well as the `user database` object.
    Note that, during the user creation process, we will pass the password value;
    however, we are only storing `password_hash` instead of the `password` itself.
    This ensures that we are not storing a clear text password for the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `auth` object has a `verify_password` decorator that we can use, along
    with Flask''s `g` global context object that was created when the request started
    for password verification. Because `g` is global, if we save the user to the `g`
    variable, it will live through the entire transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a handy `before_request` handler that can be used before any API endpoint
    is called. We will combine the `auth.login_required` decorator with the `before_request`
    handler that will be applied to all the API routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we will use the `unauthorized` error handler to return a `response`
    object for the `401` unauthorized error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we can test user authentication, we will need to create users in our
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you start your Flask development server, try to make a request, like we
    did previously. You should see that, this time, the server will reject the request
    with a `401` unauthorized error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now need to provide the authentication header for our requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We now have a decent RESTful API set up for our network. The user will be able
    to interact with the APIs now instead of the network devices. They can query for
    the static content of the network and perform tasks for individual devices or
    a group of devices. We also added basic security measures to ensure that only
    the users we created are able to retrieve the information from our API. The cool
    part is that this is all done within a single file in less than 250 lines of code
    (less than 200 if you subtract the comments)!
  prefs: []
  type: TYPE_NORMAL
- en: We have now abstracted the underlying vendor API away from our network and replaced
    them with our own RESTful API. We are free to use what is required in the backend,
    such as Pexpect, while still providing a uniform frontend to our requester.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at additional resources for Flask so that we can continue
    to build on our API framework.
  prefs: []
  type: TYPE_NORMAL
- en: Additional resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Flask is no doubt a feature-rich framework that is growing in features and
    in the community. We have covered a lot of topics in this chapter, but we have
    still only scraped the surface of the framework. Besides APIs, you can use Flask
    for web applications as well as your websites. There are a few improvements that
    I think we can still make to our network API framework:'
  prefs: []
  type: TYPE_NORMAL
- en: Separate out the database and each endpoint in its own file so that the code
    is cleaner and easier to troubleshoot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Migrate from SQLite to other production-ready databases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use token-based authentication instead of passing the username and password
    for every transaction. In essence, we will receive a token with finite expiration
    time upon initial authentication and use the token for further transactions until
    the expiration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy your Flask API app behind a production web server, such as Nginx, along
    with the Python WSGI server for production use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use an automation process control system, such as Supervisor ([http://supervisord.org/](http://supervisord.org/)),
    to control the Nginx and Python scripts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obviously, the recommended improvement choices will vary greatly from company
    to company. For example, the choice of database and web server may have implications
    for the company's technical preference as well as the other teams' input. The
    use of token-based authentication might not be necessary if the API is only used
    internally and other forms of security have been put into place. For these reasons,
    I would like to provide you with additional links as extra resources should you
    choose to move forward with any of the preceding items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the links I find useful when thinking about design patterns,
    database options, and general Flask features:'
  prefs: []
  type: TYPE_NORMAL
- en: Best practices on Flask design patterns: [http://flask.pocoo.org/docs/0.10/patterns/](http://flask.pocoo.org/docs/0.10/patterns/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Flask API: [http://flask.pocoo.org/docs/0.12/api/](http://flask.pocoo.org/docs/0.12/api/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Deployment options: [http://flask.pocoo.org/docs/0.12/deploying/](http://flask.pocoo.org/docs/0.12/deploying/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Due to the nature of Flask and the fact that it relies on the extension outside
    of its small core, sometimes, you might find yourself jumping from one document
    to another. This can be frustrating, but the upside is that you only need to know
    about the extension you are using, which I feel saves time in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started to move onto the path of building REST APIs for
    our network. We looked at different popular Python web frameworks, namely Django
    and Flask, and compared and contrasted the two. By choosing Flask, we are able
    to start small and expand on features by using Flask extensions.
  prefs: []
  type: TYPE_NORMAL
- en: In our lab, we used the virtual environment to separate the Flask installation
    base from our global site-packages. The lab network consists of four nodes, two
    of which we have designated as spine routers while the other two are designated
    as leaf routers. We took a tour of the basics of Flask and used the simple HTTPie
    client for testing our API setup.
  prefs: []
  type: TYPE_NORMAL
- en: Among the different setups of Flask, we placed special emphasis on URL dispatch
    as well as the URL variables because they are the initial logic between the requesters
    and our API system. We took a look at using Flask-SQLAlchemy and SQLite to store
    and return network elements that are static in nature. For operation tasks, we
    also created API endpoints while calling other programs, such as Pexpect, to accomplish
    configuration tasks. We improved the setup by adding asynchronous handling as
    well as user authentication to our API. Toward the end of this chapter, we looked
    at some of the additional resource links we can follow to add even more security
    and other features.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 10](1f42ba11-b219-41fa-902c-f85a916429a6.xhtml), *AWS Cloud Networking*,
    we will shift our gear to look at cloud networking using **Amazon Web Services**
    (**AWS**).
  prefs: []
  type: TYPE_NORMAL
