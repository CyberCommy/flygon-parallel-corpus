- en: Chapter 4. User Input for Our Headlines Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember how we allowed the user to specify the publication to be viewed by
    using `<variable>` parts in our URL? Although we were effectively getting input
    from our user, it's a way of retrieving input that has some pretty heavy limitations.
    Let's look at some more powerful ways to interact with our users, and add some
    more useful information to our application. We'll be making quite a few incremental
    changes to our code files from here on, so remember that you can always refer
    to the accompanying code bundle if you need an overview at any point.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll look at some more flexible and powerful ways to get input.
    We'll also bump into some more advanced Git features along the way, and take a
    moment to explain how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting user input using HTTP GET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting user input using HTTP POST
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding weather and currency data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting user input using HTTP GET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'HTTP GET requests are the simplest way of retrieving input from the user. You
    might have noticed question marks in URLs while browsing the Web. When submitting
    a term in the search box on the website, your search term will usually appear
    in the URL, and look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`example.com/search?query=weather`'
  prefs: []
  type: TYPE_NORMAL
- en: The bit after the question mark represents a named GET argument. The name is
    `query` and the value, `weather`. Although arguments like these are usually automatically
    created through HTML input boxes, the user can also manually insert them into
    the URL, or they can be part of a clickable link that is sent to the user. HTTP
    GET is designed to get limited, non-sensitive information from the user in order
    for the server to return a page as requested by the GET arguments. By convention,
    GET requests should never modify the server state in a way that produces side
    effects, that is, the user should be able to make exactly the same request multiple
    times and always be given exactly the same results.
  prefs: []
  type: TYPE_NORMAL
- en: 'GET requests are, therefore, ideal for allowing our user to specify which publication
    to view. Let''s extend our Headlines project to incorporate selecting a headline
    based on a GET request. First, let''s modify the Python code to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the request context from Flask
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove the dynamic URL variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check to see if the user has entered a valid publication as a GET argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass the user query and the publication to the template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Update the `headlines.py` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The first new change is a new import for Flask''s request context. This is
    another piece of Flask magic that makes our life easier. It provides a global
    context which our code can use to access information about the latest request
    made to our application. This is useful for us, because the GET arguments that
    our user passes along as part of a request are automatically available in `request.args`,
    from which we can access key-value pairs as we would with a Python dictionary
    (although it is immutable). The request context simplifies some other parts of
    request handling as well, which means that we don''t have to worry about threads
    or the ordering of requests. You can read more about how the request context works,
    and what it does, at the following website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://flask-cn.readthedocs.org/en/latest/reqcontext/](http://flask-cn.readthedocs.org/en/latest/reqcontext/)'
  prefs: []
  type: TYPE_NORMAL
- en: We check to see if this has the publication key set by using the `get()` method,
    which returns `None`. if the key doesn't exist. If the argument is there, we make
    sure that the value is valid (that is, it is accounted for by our `RSS_FEEDS`
    mapping), and if it is, we return the matching publication.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test out the code by visiting our URL followed by the `get` argument,
    for example: `localhost:5000/?publication=bbc`. Unfortunately, from our user''s
    experience, we''ve made the application less user-friendly, instead of more. Why
    did we do this? It turns out that our user doesn''t have to modify the URL by
    hand—with a very small change, we can have the URL arguments populated automatically
    so that the user doesn''t have to touch the URL at all. Modify the `home.html`
    template, and add the following HTML below the heading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is quite straightforward, but let's pick it apart to see how it all works.
    First we create an HTML form element. By default, this will create an HTTP GET
    request when submitted, by passing any inputs as GET arguments into the URL. We
    have a single text input which has the name `publication`. This name is important
    as the GET argument will use this. The `placeholder` is optional, but it will
    give our user a better experience as the browser will use it to indicate what
    the text field is intended for. Finally, we have another input of type `submit`.
    This automatically creates a nice **Submit** button for our form which, when pressed,
    will grab any text in the input and submit it to our Python backend.
  prefs: []
  type: TYPE_NORMAL
- en: Save the template, and reload the page to see how it works now. You should see
    the input form at the top of the page, as seen in the following screenshot. We've
    gained a lot of functionality for four lines of HTML, and now we can see that,
    although GET arguments initially looked like they were creating more mission and
    admin, they actually make our web application much simpler and more user-friendly.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting user input using HTTP GET](img/B04312_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting user input using HTTP POST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The alternative to HTTP GET is HTTP POST, and it may not always be immediately
    obvious which one to use. HTTP POST is used to post larger chunks of data or more
    sensitive data to the server. Data sent through POST requests is not visible in
    the URL, and although this does not make it inherently more secure (it does not
    by default provide encryption or validation), it does offer some security advantages.
    URLs are often cached by the browser and suggested through autocomplete features
    next time the user types in a similar URL.
  prefs: []
  type: TYPE_NORMAL
- en: Data sent through GET requests may, therefore, be retained. Using POST also
    prevents someone from seeing the data by looking over the user's shoulder (shoulder
    surfing). Passwords especially are often obscured on input by using HTML password
    fields, making them appear as asterisks (********) or dots (••••••••) in the browser.
    The data would still be clearly visible in the URL if sent using GET however,
    and so POST should always be used instead.
  prefs: []
  type: TYPE_NORMAL
- en: Although our search query is hardly confidential or excessively long, we're
    going to take a moment now to see how we'd implement the same functionality using
    POST instead of GET. If you just want to get ahead with finishing off our Headlines
    application, feel free to skip this section, but keep in mind that we'll be using
    POST requests in later projects without extended explanation. Once we're done
    with the POST example, we'll revert our application to the state it is currently
    in (using the GET request), as this is much more suitable for our use case.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a branch in Git
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make a change to our code base that we''re not sure if we want, we''ll use
    Git''s branch functionality. Think of a branch as being like a fork in a road,
    except we can at any time change our mind and go back to the decision point. First,
    we need to make sure our current branch (master) is up to date—that all our local
    changes are committed. Open a terminal, and run the following commands from the
    headlines directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We don''t strictly need to push it to the server—Git keeps a full revision
    history locally, and our changes would still be theoretically safe without the
    push. However, our code is in a working state, so there''s no harm making the
    backup to remote. Now we''re going to create the new branch and switch to using
    it to make our next set of changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We're now working in a new branch of our codebase. Usually, we'd eventually
    merge this branch back into our master branch, but in our case, we'll just abandon
    it once we're done with what we need. It's quite hard to visualize what's happening
    as Git does most things behind the scenes, so it's worth reading up about Git
    if you're interested, and are likely to use it for future projects. Otherwise,
    just think of this as a checkpoint so that we can freely experiment without the
    worry of messing up our code.
  prefs: []
  type: TYPE_NORMAL
- en: Adding POST routes in Flask
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use a POST request, we need to make some small changes to our Python and
    HTML code. In the `headlines.py` file, make the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Change `request.args.get` to `request.form.get`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change `@app.route("/")` to `@app.route("/", methods=['GET', 'POST'])`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The reason for the first change is that we are now grabbing the user data from
    a form, so Flask automatically makes this available to us in `request.form`. This
    works the same way as `request.get` except that it gathers data from POST requests
    instead of from GETs. The second change is not quite as obvious. What we haven''t
    mentioned before is that all route decorators can specify how the function can
    be accessed: either through GET requests, POST requests, or both. By default,
    only GET is permitted, but we now want our default page to be accessible by either
    GET (when we just visit the home main page and are given BBC as a default), or
    POST (for when we''ve requested the page through our form with the additional
    query data). The `methods` parameter accepts a list of HTTP methods which should
    be permitted to access that particular route of our application.'
  prefs: []
  type: TYPE_NORMAL
- en: Making our HTML form use POST
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our template needs similar changes. Change the opening `<form>` tag in the
    `home.html` file to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Just as with Flask, HTML forms use GET by default, so we have to explicitly
    define that we want to use POST instead. The `action` attribute isn't strictly
    necessary, but usually, when we use POST, we redirect users to a confirmation
    page or similar, and the URL for the following page would appear here. In this
    case, we're explicitly saying that we want to be redirected to the same page after
    our form has been submitted.
  prefs: []
  type: TYPE_NORMAL
- en: Save the changes to the Python and HTML files, and refresh the page in your
    browser to see the changes take effect. The functionality should be exactly the
    same except that we don't see any data in the URL. This can be cleaner for many
    applications, but in our case, it is not what we want. For one, we'd like the
    search term to be cached by our users' browsers. If a user habitually makes a
    query for FOX, we want the browser to be able to autocomplete this after he begins
    typing in the URL for our application. Furthermore, we'd like our users to be
    able to easily share links that include the query.
  prefs: []
  type: TYPE_NORMAL
- en: If a user (let's call him Bob) sees a bunch of interesting headlines after typing
    **cnn** into our application, and wants to share all of these headlines with another
    user (Jane), we don't want Bob to have to message Jane, telling her to visit our
    site, and type a specific query into the search form. Instead, Bob should be able
    to share a URL that allows Jane to directly visit the page exactly as he saw it
    (for example, `example.com/?publication=cnn`). Jane can simply click on the link
    sent by Bob and view the same headlines (assuming she visits our page before the
    RSS feed is updated).
  prefs: []
  type: TYPE_NORMAL
- en: Reverting our Git repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to revert the code to how we had it before. Because all the changes
    in the previous section were made in our experimental post-request branch, we
    don''t need to manually re-edit the lines we changed. Instead, we''ll commit our
    changes to this branch, and then switch back to our master branch, where we''ll
    find everything as we left it. In your terminal, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Open the `headlines.py` and `templates/home.html` files to be sure, but they
    should be exactly as we left them before experimenting with POST!
  prefs: []
  type: TYPE_NORMAL
- en: Adding weather and currency data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's add some more functionality. We're showing media headlines from three
    different sources, but our user is probably interested in more than current affairs.
    We're going to see how easy it is to display the current weather and some exchange
    rates at the top of the page. For the weather data, we'll be using the OpenWeatherMap
    API, and for currency data, we'll be using Open Exchange Rates. At the time of
    writing, these APIs are freely available, although they both require registration.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the OpenWeatherMap API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In your web browser, visit the URL [http://api.openweathermap.org/data/2.5/weather?q=London,uk&units=metric&appid=cb932829eacb6a0e9ee4f38bfbf112ed](http://api.openweathermap.org/data/2.5/weather?q=London,uk&units=metric&appid=cb932829eacb6a0e9ee4f38bfbf112ed).
    You should see something that looks similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing the OpenWeatherMap API](img/B04312_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is the JSON weather data for London which is designed to be read automatically
    instead of by humans. Before looking at how to go about reading this data into
    our Headlines application, note that the URL we visited has an `appid` parameter.
    Even though the weather data is provided for free, every developer who accesses
    the data needs to sign up for a free account with OpenWeatherMap, and get a unique
    API key to pass as the value for the `appid` parameter. This is to prevent people
    from abusing the API by making too many requests, and hogging the available bandwidth.
    At the time of writing, OpenWeatherMap allows 60 calls to the API per minute and
    50,000 per day as part of their free access plan, so it's unlikely that we'll
    be hitting these limits for our project.
  prefs: []
  type: TYPE_NORMAL
- en: Signing up with OpenWeatherMap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You should sign up for your own API key instead of using the one published
    in this book. Generally, your API key should remain a secret, and you should avoid
    sharing it (especially avoid publishing it in a book). To get your own API key,
    head over to [www.openweathermap.org](http://www.openweathermap.org) , and complete
    their sign-up progress by clicking the sign-up link at the top of the page. Fill
    out an e-mail address, username, and password. The registration page should look
    similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Signing up with OpenWeatherMap](img/B04312_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Retrieving your OpenWeatherMap API key
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you''ve signed up, you''ll be able to log into OpenWeatherMap. You can
    the find your personal API key by navigating to [home.openweathermap.org](http://home.openweathermap.org)
    and scrolling down to the **API key** text box. You should see your API key as
    indicated by the red rectangle in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Retrieving your OpenWeatherMap API key](img/B04312_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Copy the key to your clipboard, as we'll be using it in our Python code soon.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing JSON with Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we can access structured weather data over HTTP by using a URL. But doing
    so in our browser isn't much good, as we want to read this data automatically
    from our Python code. Luckily, Python has a bunch of useful standard libraries
    for exactly this use case!
  prefs: []
  type: TYPE_NORMAL
- en: Introducing JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JSON is a structured data format very similar to a Python dictionary, as should
    be apparent from the preceding sample. In fact, in this case it's identical, and
    we could very simply convert it to a Python dictionary to use in our Flask application
    by loading it as a string and running the built-in Python `eval` function on it.
    However, JSON is not always identical to a Python dictionary. For example, it
    uses `true` and `false` instead of `True` and `False` (note the case difference)—and
    passing anything that we don't have full control over to `eval()` is generally
    a bad idea. Therefore, we'll use the `Python json` library to safely parse it.
    We'll also use the Python `urllib2` library to download the data from the web,
    and the Python `urllib` library to correctly encode URL parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving and parsing JSON in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For retrieving and parsing JSON in Python, the first step is to add the three
    new imports that we need to our `headlines.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**Style tip:**'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For good Python style, keep the imports ordered alphabetically. You can read
    more about the conventions for ordering imports at the following site: [https://www.python.org/dev/peps/pep-0008/#imports](https://www.python.org/dev/peps/pep-0008/#imports)'
  prefs: []
  type: TYPE_NORMAL
- en: Now add a new function, `get_weather()`, which will make a call to the weather
    API with a specific query. It's pretty straightforward, and looks like the following
    code. Replace the `<your-api-key-here>` placeholder with the API key that you
    copied from the OpenWeatherMap page.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We use the same URL we looked at earlier in our browser, but we make the query
    part-configurable so that the city for which we retrieve the weather data is dynamic.
    We use `urllib.quote()` on the query variable, as URLs cannot have spaces in them,
    but the names of the cities that we want to retrieve weather for may contain spaces.
    The `quote()` function handles this for us by, for example, translating a space
    to "`%20`", which is how spaces are represented in URLs. Then we load the data
    over HTTP into a Python string by using the `urllib2` library. As in our feedparsing
    example, downloading data over the Internet is always potentially unstable, and
    for a real-world application, we would need to add some exception handling, and
    retry logic here.
  prefs: []
  type: TYPE_NORMAL
- en: We then use the json library's `loads()` function (load string) to convert the
    JSON string that we downloaded into a Python dictionary. Finally, we manually
    build up a simpler Python dictionary based on the JSON one returned by the API,
    as OpenWeatherMap supplies a whole bunch of attributes that we don't need for
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: Using our weather code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now make two small changes to the `get_news()` function in order to use our
    `get_weather()` function. We need to call the `get_weather()` function (for now
    we''ll just pass in London as a constant), and then pass the weather data to our
    template. The `get_news()` function should now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This now loads the simplified data for London into the weather variable, and
    passes it along to our template file so that we can display the data to our users.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the weather data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we just need to adapt our template to account for the extra data. We'll
    display the weather data just above the news headlines, and add some level 2 headings
    to keep the different sections of our application organized.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following three lines to the home.html template, right after the opening
    `<h1>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: There's nothing here that we haven't seen before. We simply grab the sections
    we want out of our weather variable using braces. The funny `&#8451;` part is
    to display the symbol for degrees Celsius. If you're one of those people who is
    able to make sense of the notion of Fahrenheit, then remove the `&units=metric`
    from the API URL (which will tell OpenWeatherData to give us the temperatures
    in Fahrenheit), and display the *F* symbol for our users by using `&#8457;` in
    your template instead.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing the user to customize the city
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, we would not always want to display the weather for London.
    Let's add a second search box for city! Searching is usually hard, because data
    input by users is never consistent, and computers love consistency. Luckily, the
    API that we're using does a really good job of being flexible, so we'll just pass
    on the user's input directly, and leave the difficult bit for others to deal with.
  prefs: []
  type: TYPE_NORMAL
- en: Adding another search box to our template
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We'll add the search box to our template exactly as before. This form goes directly
    under the *Current weather* heading in the `home.html` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The form defined in the preceding code snippet simply uses a named text input
    and a submit button, just like the one we added for the publication input.
  prefs: []
  type: TYPE_NORMAL
- en: Using the user's city search in our Python code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In our Python code, we need to look for the `city` argument in the GET request.
    Our `get_news()` function is no longer well-named, as it does more than simply
    getting the news. Let''s do a bit of refactoring. Afterwards, we''ll have a `home()`
    function that makes calls to get the news and the weather data (and later on the
    currency data), and our `get_news()` function will again only be responsible for
    getting news. We''re also going to have quite a few defaults for different things,
    so instead of hard-coding them all, we''ll add a `DEFAULTS` dictionary as a global,
    and whenever our code can''t find information in the GET arguments, it''ll fall
    back to getting what it needs from there. The changed parts of our code (excluding
    the imports, global URLs, and the main section at the end) now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a good separation of concerns—our `get_weather()` function gets
    weather data, our `get_news()` function gets news, and our `home()` function combines
    the two and handles the user's input to display customized data to our visitors.
  prefs: []
  type: TYPE_NORMAL
- en: Checking our new functionality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If all went well, we should now have a site that displays customizable news
    and weather data. The weather search, as mentioned, is pretty flexible. Give it
    a go with some different inputs—you should see a page similar to the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Checking our new functionality](img/B04312_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Handling duplicate city names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The OpenWeatherMap API handles duplicate city names well, although the defaults
    are sometimes a bit counter-intuitive. For example, if we search for Birmingham,
    we'll get the one in the USA. If we want to look for the Birmingham in the UK,
    we can search for Birmingham, UK. In order to not confuse our viewers, we'll make
    a small modification for displaying the country next to the city. Then they'll
    immediately be able to see if they get results for a city different from what
    they were expecting. If you examine the full API response from our weather call,
    you'll find the country code listed under `sys`—we'll grab that, add it to our
    custom dictionary, and then display it in our template.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `get_weather` function, modify the line where we build the dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And in our template, modify the line where we display the city to read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Check that its working – if you restart the application and reload the page,
    you should see that typing `Birmingham` into to the **Current weather** search
    box now displays the country code next to the city name.
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling duplicate city names](img/B04312_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Currency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Currency data is considered more valuable than weather data. Many commercial
    services offer APIs that are frequently updated and very reliable. However, the
    free ones are a bit rare. One service that offers a limited API for free is Open
    Exchange Rates—and again, we need to register a free account to get an API key.
  prefs: []
  type: TYPE_NORMAL
- en: Getting an API key for the Open Exchange Rates API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Head over to [openexchangerates.com](http://openexchangerates.com), and complete
    their registration process. After clicking on the **Sign up** link, it may look
    like they only have paid plans, as these are more prominently displayed. However,
    underneath the large paid plan options, there is a single line of text describing
    their free offering with a link to select it. Click on this, and enter your details.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are not automatically redirected, head over to your dashboard on their
    site, and you''ll see your **API key** (App ID) displayed. Copy this, as we''ll
    need to add it to our Python code. You can see an example of where to find your
    API key in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting an API key for the Open Exchange Rates API](img/B04312_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using the Open Exchange Rates API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `currency` API returns JSON just like the `weather` API, so we can integrate
    it into our Headlines application very easily. We need to add the URL as a global,
    and then add a new function to calculate rates. Unfortunately, the free version
    of the API is restricted to returning all the major currencies against the United
    States Dollar, so we will have to calculate our own approximate rates for conversions
    not involving the dollar, and rely on a perfect market to keep our information
    as accurate as possible (see [http://en.wikipedia.org/wiki/Triangular_arbitrage](http://en.wikipedia.org/wiki/Triangular_arbitrage)).
  prefs: []
  type: TYPE_NORMAL
- en: Add the variable `CURRENCY_URL` to your globals below the existing `WEATHER_URL`,
    as seen in the following code snippet. You'll need to substitute your own App
    ID.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `get_rates()` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note the calculation that we do at the end. If the request was from USD to any
    of the other currencies, we could simply grab the correct number from the returned
    JSON. But in this case, the calculation is simple enough, and it's therefore not
    worth adding the extra step of logic to work out if we need to do the calculation
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: Using our currency function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we need to call the `get_rates()` function from our `home()` function,
    and pass the data through to our template. We also need to add default currencies
    to our `DEFAULTS` dictionary. Make the changes as indicated by the highlighted
    code that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Displaying the currency data in our template
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, we need to modify our template to display the new data. Underneath
    the weather section in `home.html`, add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As always, check that everything is working in your browser. You should see
    the default currency data of the British Pound to US Dollar conversion as in the
    following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying the currency data in our template](img/B04312_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding inputs for the user to select currency
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we need to add yet another user input to customize which currencies to
    display. We could easily add another text search like we did for the previous
    two, but this gets messy. We need two bits of input from the user: the *from*
    currency and the *to* currency. We could add two inputs, or we could ask the user
    to enter both into the same input, but the former makes our page pretty cluttered,
    and the latter means we need to worry about properly splitting the user input
    data (which is almost certainly not consistent). Instead, let''s look at a different
    input element, the HTML `select`. You''ve almost certainly seen these on other
    web pages—they''re drop-down menus with a list of values that the user can choose
    from. Let''s see how to build them in HTML, and how to grab the data from them
    in Flask.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an HTML select drop-down element
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, let''s hard-code four currencies in each drop-down menu. The code should
    be inserted right below the **Currency** heading in the `home.html` template,
    and it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The name used for the GET request argument is an attribute of the select tag
    itself (similar to the name attribute used in our `<input type="text">` tags).
    In our case, these are `currency_from` and `currency_to`, which we specified in
    our Python code earlier. The value is slightly more tricky—we have the value that's
    passed in our GET request (for example, `currency_from=EUR`), and then the value
    that is displayed to the user. In this case, we'll use the same for both—the currency
    code—but this is not compulsory. For example, we could use the full name of the
    currency, such as United States Dollar, in the display value, and the code in
    the value that's passed in the request. The argument value is specified as an
    attribute of the option tags, each a child of `<select>`. The display value is
    inserted between the opening and closing `<option>` and `</option>` tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'Test this out to make sure it''s working, by saving the template and reloading
    the page. You should see drop-down inputs appear, as in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an HTML select drop-down element](img/B04312_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding all the currencies to the select input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Of course, we could do what we did in the preceding section for the full list.
    But we''re programmers, not data capturers, so we''ll make the list dynamic, insert
    the options using a `for` loop, and keep our template up-to-date and clean. To
    get the list of currencies, we can simply take the keys of our JSON `all_currency`
    object, in order to make our `get_rate()` function return a tuple—the calculated
    rate and the list of currencies. We can then pass the (sorted) list to our template,
    which can loop through them and use them to build the drop-down lists. The changes
    for this are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make the following changes in the `home()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `get_rate()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And in the `home.html` template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Displaying the selected currency in the drop-down input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After this, we should easily be able to see the exchange rate for any currency
    we want. One minor irritation is that the dropdowns always display the top item
    by default. It would be more intuitive for our users if they displayed the currently
    selected value instead. We can do this by setting the `selected="selected"` attribute
    in our select tag and a simple, one-line Jinja `if` statement to work out which
    line to modify. Change the `for` loops for the currency inputs in our `home.html`
    template to read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `currency_from` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `currency_to` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Reload the application and the page, and you should now be able to select any
    of the available currencies from both select inputs, and after the page has loaded
    with the desired currency data, the select inputs should automatically display
    the current currencies as well, as seen in the following image. After clicking
    on the select input, you should also be able to type on your keyboard and select
    the option based on the first letters of what you've typed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying the selected currency in the drop-down input](img/B04312_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can now see news, weather, and currency data at the same time! You can refer
    to the complete code from the code bundle of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've looked at the difference between the HTTP GET and POST
    requests, and discussed where it's good to use which. Although we have no good
    use for HTTP POST at the moment, we will use it in future projects where we will
    be getting login data from our users. Luckily, the explanatory work we did with
    HTTP POST is not lost—we also took a look at some more advanced ways that Git
    can help us with version control, and our unused code is safely stored in a different
    branch of our code repository in case we need to refer back to it later. Last
    but not least, we added weather and currency data to our application, and looked
    at a few different options for allowing our user to input data into our application.
    We're nearly done with our first project!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll do some cosmetic touch-ups, and look at remembering
    our users so that they don't have to carry out exactly the same actions every
    time they visit our site.
  prefs: []
  type: TYPE_NORMAL
