- en: Tuning Aspect-Oriented Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we took a deep dive into one of Spring''s key features:
    dependency injection (IoC container). DI is an enterprise design pattern, that
    makes an object loosely-coupled from its required dependencies. We learned about
    Spring''s bean wiring configuration and best practices to follow to achieve optimal
    results.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving further in line with Spring''s core features, in this chapter, we will
    discuss **Aspect-Oriented Programming** (**AOP**). We''ve already learned that
    DI promotes programming to the interface and the decoupling of the application''s
    objects, whereas AOP helps to achieve the decoupling of business logic and crosscutting
    concerns. A** crosscutting concern** is a concern applicable to part of the application
    or the entire application, for example, security, logging, and caching, which
    are required in almost every module of the application. AOP and AspectJ help to
    achieve these crosscutting concerns. In this chapter, we will go through the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: AOP concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AOP proxies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring AOP method for profiling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AOP versus AspectJ comparison
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AOP best programming practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AOP concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at what problems we have to face if we use only
    the **object-oriented programming** (**OOP**) paradigm. Then we will understand
    how AOP solves those problems. We will walk through the concepts of AOP and ways
    to implement AOP concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of OOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the help of OOP fundamentals and design patterns, application development
    was divided into groups of functionalities. OOP protocols made many things easy
    and useful, such as introducing an interface with which we can implement loosely-coupled
    designs, encapsulation with which we can hide object data, and inheritance-extending
    functionalities, by classes, with which we can reuse work.
  prefs: []
  type: TYPE_NORMAL
- en: These advantages of OOP also add complexity as the system grows. With added
    complexities, the cost to maintain it and the chances of failure increase. To
    solve this, modularizing functionalities into simpler and more manageable modules
    helps reduce complexity.
  prefs: []
  type: TYPE_NORMAL
- en: To modularize a system, we started following a practice of dividing applications
    into different logical layers, for example, presentation layer, service layer,
    and data layer. However, even after dividing the functionalities into different
    layers, there are certain functionalities that are required in all layers, for
    example, security, logging, caching, and performance monitoring. These functionalities
    are called crosscutting concerns**.**
  prefs: []
  type: TYPE_NORMAL
- en: 'If we implement these crosscutting concerns using inheritance, it will violate
    the single responsibility of the SOLID principle and increase the object hierarchy.
    And if we implement them using composition, it will be more complicated. So the
    implementation of crosscutting concerns using OOP leads to two problems:'
  prefs: []
  type: TYPE_NORMAL
- en: Code tangling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code scattering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's discuss these problems more.
  prefs: []
  type: TYPE_NORMAL
- en: Code tangling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Code tangling** means mixing crosscutting concerns and business logic, which
    in turn leads to tight coupling. Let''s look at the following diagram to understand
    code tangling:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/67377d05-09ec-425d-840a-a338a3cd835e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Code tangling
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram illustrates how we mix transactions and security code
    along with our business logic in our service implementation. With such implementation,
    code reusability is reduced, maintenance is degraded, and the single responsibility
    principle is violated.
  prefs: []
  type: TYPE_NORMAL
- en: Code scattering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Code scattering means crosscutting concerns are duplicated across all modules
    of an application. Let''s look at the following example to understand code scattering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As we saw in preceding code sample, the permission check (security) is our crosscutting
    concern that is duplicated in all services.
  prefs: []
  type: TYPE_NORMAL
- en: These code tangling and code scattering problems are solved by AOP, but how?
    We will see shortly.
  prefs: []
  type: TYPE_NORMAL
- en: AOP – problem solver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen in the preceding section that with OOP, code tangling and scattering occurs.
    With AOP, we can achieve the following objectives/benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Modularizing crosscutting concerns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decoupling of modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing crosscutting concerns regarding module dependency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring AOP allows us to keep our crosscutting concerns logic separate from our
    business logic so we can focus on our application's main logic. To help us perform
    this separation, Spring provides `Aspects`, a normal class where we would implement
    our crosscutting concerns logic. Spring provides ways to inject these `Aspects`
    into the right place in our application without mixing them with business logic.
    We will see more about `Aspects`, how to implement it, and how to apply it in
    the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'This diagram illustrates Spring AOP:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ea23ba5-9b75-4ba8-9313-bf441b95b1da.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How AOP solves code tangling
  prefs: []
  type: TYPE_NORMAL
- en: Spring AOP terminology and concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'AOP, like every technology, has its own terminologies. It has its own vocabulary.
    Spring uses the AOP paradigm in its Spring AOP module. However, Spring AOP has
    its own terminologies that are Spring-specific. To understand Spring AOP terms,
    let''s look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0fd2ee17-3144-487c-b6e7-a54fbb852387.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Spring AOP terminologies and concepts
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand each concept of Spring AOP mentioned in the preceding diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Join Point:** A point defined in the execution of our program. This execution
    could be method invocation, exception handling, class initialization, or object
    instantiation. Spring AOP supports method invocation only. In case we want a join
    point for anything other than method invocation, we can use Spring and AspectJ
    together. We will walk through AspectJ later in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advice**: A definition of what exactly needs to be done at the join point.
    Different types of advice are `@Before`, `@After`, `@Around`, `@AfterThrowing`,
    and `@AfterReturning`. We will see them in action in the *Types of advice* section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pointcut**: A collection of join point used to define an advice that has
    to be executed. An advice is not necessarily applied to all join points, so pointcut
    gives fine-grained control over an advice that is to be executed on components
    in our application. Pointcuts are defined using an expression and Spring uses
    the AspectJ pointcut expression language. We will shortly see how this is done.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Aspect**: The combination of advice and pointcuts that defines logic in an
    application and where it should execute. Aspect is implemented using the regular
    class annotated with the `@Aspect` annotation. This annotation is from Spring
    AspectJ support.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's too much theory, isn't it? Now, let's dive into how to apply these Spring
    AOP concepts in real programming. You might have implemented these AOP concepts
    in your projects; however, did you know the background of why it was needed? No,
    so now you know why we need Spring AOP.
  prefs: []
  type: TYPE_NORMAL
- en: Since Spring 2.0, AOP implementation is made simpler using the AspectJ pointcut
    language defined either in the schema-based approach (XML) or annotations. We
    will discuss Spring 2.0 AspectJ support with annotations further in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Defining pointcuts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we learned before, pointcuts define a point where advice should be applied.
    Spring AOP uses AspectJ''s expression language to define a point where advice
    should be applied. The following are the set of pointcut designators supported
    in Spring AOP:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Designator** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `execution` | It restricts matching to join points by a method execution. 
    |'
  prefs: []
  type: TYPE_TB
- en: '| `within` | It restricts matching to join points within certain types only.Example:
    `within(com.packt.springhighperformance.ch3.TransferService)`. |'
  prefs: []
  type: TYPE_TB
- en: '| `args` | It restricts matching to join points where arguments are of the
    given type.Example: `args(account,..)`. |'
  prefs: []
  type: TYPE_TB
- en: '| `this` | It restricts matching to join points where the bean reference or
    Spring proxy object is an instance of the given type.Example: `this(com.packt.springhighperformance.ch3.TransferService)`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `target` | It restricts matching to join points where the target object is
    an instance of the given type.Example: `target(com.packt.springhighperformance.ch3.TransferService)`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `@within` | It restrict matching to join points where the declared type has
    the given type of annotation.Example: `@within(org.springframework.transaction.annotation.Transactional)`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `@target` | It restricts matching to join points where the target object
    has the given type of annotation.Example: `@target(org.springframework.transaction.annotation.Transactional)`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `@args` | It restricts matching to join points where the type of the actual
    arguments passed have annotations of the given type.Example: `@args(com.packt.springhighperformance.ch3.Lockable)`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `@annotation` | It restricts matching to join points where the executing
    method has the given annotation.Example: `@annotation(org.springframework.transaction.annotation.Transactional)`.
    |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s see how to write the point expression using the `execution` designator:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `execution(<method-pattern>)`: Method matching to the pattern would be
    advised. The following is the method pattern:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To create composite pointcuts by joining other pointcuts, we can use the `&&`,
    `||`, and `!` operators (these mean AND, OR, and NOT, respectively).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the preceding method pattern, anything defined in `[ ]` is optional. Values
    without `[ ]` are mandatory to define.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram will illustrate point expression using the `execution`
    designator to apply advice whenever the `findAccountById()` method is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f9aa8b5-8a9b-4ee7-b5b9-e7e8ab78d487.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Execution join point pattern
  prefs: []
  type: TYPE_NORMAL
- en: Types of advice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding section, we learned different terminologies of AOP and how
    to define the pointcut expression. In this section, we will learn about the different
    types of advice in Spring AOP:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Before`: This advice is executed before the join point and it is defined
    in `aspect` using the `@Before` annotation. The declaration is shown in the following
    code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If the `@Before` method throws an exception, the `transfer` target method would
    not get called. This is a valid use of `@Before` advice.
  prefs: []
  type: TYPE_NORMAL
- en: '`@After`: This advice is executed after the join point (method) exits/returns
    either normally or with any exception. To declare this advice, use the `@After`
    annotation. The declaration is shown in the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`@AfterReturning`: As we know in `@After` advice, the advice is executed in
    any case where the join point exits normally or with an exception. Now, if we
    want to run an advice only after a matched method returns normally, then what?
    Then we need `@AfterReturning`. Sometimes we need to perform some operation based
    on the value returned by the method. In those cases, we can use the `@AfterReturning`
    annotation. The declaration is shown in the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`@AfterThrowing`**:** This advice is called when an exception is thrown by
    a matched method in an expression. This is useful when we want to take some action
    when any particular type of exception is thrown or we want to track method execution
    to correct errors. It is declared using the `@AfterThrowing` annotation, as shown
    in the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Similar to `@AfterThrowing` `returning` attribute, the `throwing` attribute
    in the `@AfterThrowing` advice must match the name of the parameter in the advice
    method. The `throwing` attribute restricts matching to those method executions
    that throws an exception of the specified type.
  prefs: []
  type: TYPE_NORMAL
- en: '`@Around`**:** The last and final advice that is applied around the matched
    method. This means that it is a combination of the `@Before` and `@After` advice
    we saw earlier. However, the `@Around` advice is more powerful than `@Before`
    and `@After` combined. It is powerful because it can decide whether to proceed
    to the join point method or return its own value or throw an exception. The `@Around`
    advice can be used with the `@Around` annotation. The first parameter of the advice
    method in `@Around` advice should be `ProceedingJoinPoint`. The following is the
    code sample of how to use the `@Around` advice:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We can invoke `proceed` once, many times, or not at all within the body of the
    `@Around` advice.
  prefs: []
  type: TYPE_NORMAL
- en: Aspect instantiation models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, the declared `aspect` is `singleton`, so there will be only one
    instance of our `aspect` per class loader (and not per JVM). The instance of our
    `aspect` will be destroyed only when the class loader is garbage.
  prefs: []
  type: TYPE_NORMAL
- en: If we need to have our `aspect` with private attributes hold data relative to
    class instances, the `aspect` needs to be stateful. To do so, Spring with its
    AspectJ support provides a way using `perthis` and `pertarget` instantiation models.
    AspectJ is an independent library, and has other instantiation models in addition
    to `perthis` and `pertarget`, such as `percflow`, `percflowbelow`, and `pertypewithin`,
    which are not supported in Spring's AspectJ support.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a stateful `aspect` using `perthis`, we need to declare `perthis`
    as follows in our `@Aspect` declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Once we declare our `@Aspect` with the `perthis` clause, one `aspect` instance
    will be created for each unique `TransferService` object executing the `transfer`
    method (each unique object that is bound to `this` at join points matched by the
    pointcut expression). The instance of aspect goes out of scope when the `TransferService`
    object goes out of scope.
  prefs: []
  type: TYPE_NORMAL
- en: '`pertarget` works the same as `perthis`; however, in `pertarget`, it creates
    one `aspect` instance per unique target object at join points matched by the pointcut
    expression.'
  prefs: []
  type: TYPE_NORMAL
- en: Now you might be wondering how Spring would have applied advice without making
    calls from the business logic classes to the crosscutting concern class (`Aspects`).
    So the answer is, Spring does this using the proxy pattern. It weaves your `Aspects`
    to the target objects by creating proxied objects. Let's look at the Spring AOP
    proxy in detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: AOP proxies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is the proxy pattern that made Spring AOP able to decouple crosscutting concerns
    from the core application's business logic or functionalities. The proxy pattern
    is a structural design pattern included in a book by the **Gang of Four** (**GoF**).
    In practice, the proxy pattern creates different object wrapping out of an original
    object without changing the behavior of the original object to allow intercepting
    its method call, and the outside world would feel they are interacting with the
    original object and not a proxy.
  prefs: []
  type: TYPE_NORMAL
- en: JDK dynamic proxies and CGLIB proxies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The proxy in Spring AOP can be created in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'JDK proxy (dynamic proxy): The JDK proxy creates a new proxy object by implementing
    interfaces of the target object and delegating method calls'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CGLIB proxy: The CGLIB proxy creates a new proxy object by extending the target
    object and delegating method calls'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at these proxy mechanisms and how they differ in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **JDK proxy** | **CGLIB proxy** |'
  prefs: []
  type: TYPE_TB
- en: '| It is built in JDK. | It is a custom-developed library. |'
  prefs: []
  type: TYPE_TB
- en: '| JDK proxy works on the interface. | CGLIB proxy works on subclassing. This
    is used when the interface is not present. |'
  prefs: []
  type: TYPE_TB
- en: '| It will proxy all interfaces. | It cannot work when the method and class
    are final. |'
  prefs: []
  type: TYPE_TB
- en: From Spring 3.2, the CGLIB library is packaged with Spring Core, so there's
    no need to include this library separately in our application.
  prefs: []
  type: TYPE_NORMAL
- en: From Spring 4.0, the constructor of the proxied object will not be called twice,
    as the CGLIB proxy instance will be created via Objenesis.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Spring will try to use the JDK dynamic proxy if the class of the
    target object implements the interface; if the class of the target object does
    not implement any interface then Spring will create a proxy using the CGLIB library.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the class of the target object implements an interface and it is injected
    as a concrete class in another bean, then Spring will throw an exception: `NoSuchBeanDefinitionException`.
    The solution to this problem is either to inject through the interface (which
    is a best practice) or to annotate the injection with `Scope(proxyMode=ScopedProxyMode.TARGET_CLASS)`.
    Then Spring will create a proxy object using the CGLIB proxy. This configuration
    disables Spring''s use of JDK proxies. Spring will then always extend concrete
    classes, even if an interface is injected. The CGLIB proxy uses the decorator
    pattern to weave advice to the target object by creating a proxy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39e2351e-1d2b-4566-aa34-d6d2266ad700.jpg)'
  prefs: []
  type: TYPE_IMG
- en: JDK dynamic proxy and CGLIB proxy
  prefs: []
  type: TYPE_NORMAL
- en: Creating a proxy would be able to delegate all calls to a method to interceptors
    (advice). However, once a method call reaches the target object, any internal
    method call made within that target object is not going to be intercepted. So,
    any method call within the object reference would not result in any advice execution.
    In order to solve this, either refactor the code so that direct self-invocation
    doesn't happen or use AspectJ weaving. To solve this in Spring, we need to set
    the expose a proxy property to true and use `AopContext.currentProxy()` to make
    self-invocation.
  prefs: []
  type: TYPE_NORMAL
- en: Spring recommends using the JDK proxy wherever possible. Hence, try to implement
    the abstraction layer almost everywhere in your application so that the JDK proxy
    will be applied when the interface is available and we have not explicitly set
    it to use the CGLIB proxy only.
  prefs: []
  type: TYPE_NORMAL
- en: ProxyFactoryBean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring provides a classic way of creating proxies of objects manually using
    `ProxyFactoryBean`, which will create an AOP proxy wrapping the target object.
    `ProxyFactoryBean` provides a way to set advice and advisors that are eventually
    merged into an AOP proxy. The key properties inherited from the `org.springframework.aop.framework.ProxyConfig`
    superclass for all AOP proxy factories in Spring are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`proxyTargetClass`: If it''s true, then the proxy is created using CGLIB only.
    If it''s not set, the proxy will be created using the JDK proxy if the target
    class implements the interface; otherwise, the proxy will be created using CGLIB.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`optimize`: For the CGLIB proxy, this instructs the proxy to apply some aggressive
    optimizations. Currently, it is not supported by the JDK proxy. This needs to
    be used wisely.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`frozen`: If a proxy is set as `frozen`, then changes to the configuration
    are not allowed. This is useful when we don''t want callers to modify the proxy
    after the proxy has been created. This is used for optimization. The default value
    of this property is `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exposeProxy`: Setting this property to true determines whether the current
    proxy should be exposed to `ThreadLocal` or not. If it''s exposed to `ThreadLocal`,
    then the target can use the `AopContext.currentProxy()` method for self-invocation
    of the method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ProxyFactoryBean in action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will define a regular Spring bean as target bean, say `TransferService`,
    and then, using `ProxyFactoryBean`, we will create a proxy that will be accessed
    by our application. To advice the `transfer` method of `TransferService`, we will
    set the point expression using `AspectJExpressionPointcut` and we will create
    the interceptor, which we will set into `DefaultPointcutAdvisor` to create the
    advisor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The target object or bean is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is for the method interceptor or advice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The Spring configuration is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code samples, we have not separately defined `TransferService`
    as Spring bean. We have created an anonymous bean of `TransferService` and then
    created its proxy using `ProxyFactoryBean`. This has an advantage that there will
    be only one object of the `TransferService` type and no one can obtain an unadvised
    object. This also reduces ambiguity if we want to wire this bean to any other
    bean using the Spring IoC.
  prefs: []
  type: TYPE_NORMAL
- en: With `ProxyFactoryBean`, we can configure AOP proxies that provide all flexibility
    of the programmatic method without needing our application to do AOP configurations.
  prefs: []
  type: TYPE_NORMAL
- en: It is best to use the declarative method of proxy configuration over the programmatic
    method unless we need to perform a manipulative action at runtime or we want to
    gain fine-grained control.
  prefs: []
  type: TYPE_NORMAL
- en: Performance JDK dynamic proxy versus CGLIB proxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We learned what proxies are used for. According to the GoF book, *Design Patterns:
    Elements of Reusable Object-Oriented Software*, a proxy is a placeholder for another
    object to control access to it. As the proxy lies in between the caller of an
    object and the real object, it can decide whether to prevent the invocation of
    the real (or target) object or perform some action before the target object is
    invoked.'
  prefs: []
  type: TYPE_NORMAL
- en: Many object-relational mappers use proxy patterns to implement a behavior that
    prevents data from being loaded until it is actually needed. Sometimes this is
    called **lazy loading**. Spring also uses proxies to develop some of its functionality,
    such as its transaction management, security, caching, and the AOP framework.
  prefs: []
  type: TYPE_NORMAL
- en: As proxies objects are an additional object created at runtime, either by JDK
    proxy or CGLIB library, and sit between the caller object and the target object,
    it is going to add some overhead to a plain method invocation.
  prefs: []
  type: TYPE_NORMAL
- en: Let's find out how much overhead proxies add to a plain method invocation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows the Spring Java-based configuration class for the
    CGLIB proxy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The Spring Java-based configuration class for the JDK proxy is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The JUnit class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The overhead time varies based on hardware tools, such as CPU and memory. The
    following is the kind of output we would get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We can do benchmarking using tools such as Google's Caliper, found at [https://github.com/google/caliper](https://github.com/google/caliper),
    or **Java Microbenchmark Harness** (**JMH**), found at [http://openjdk.java.net/projects/code-tools/jmh/](http://openjdk.java.net/projects/code-tools/jmh/).
    Many performance tests, using different tools and scenarios, delivered different
    results. A few tests showed CGLIB is faster than the JDK proxy, and a few got
    other results. If we test AspectJ, which we'll discuss later in this chapter,
    performance is still better than the JDK proxy and CGLIB proxy, due to its bytecode-weaving
    mechanism instead of a proxy object.
  prefs: []
  type: TYPE_NORMAL
- en: The question here is do we really need to worry about the overhead we saw? The
    answer is both yes and no. We will discuss both these answers.
  prefs: []
  type: TYPE_NORMAL
- en: We don't have to really worry about the overhead because that amount of time
    the proxy added is negligible and the amount of benefits provided by AOP or the
    proxy pattern is high. We already saw the benefits of AOP in the preceding sections
    of this chapter, such as transaction management, security, lazy loading, or anything
    that is crosscutting but with code simplification, centralized management, or
    maintenance of code.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we need to worry about the overhead when our application has **Service
    Level Agreement** (**SLA**) to deliver in milliseconds or our application has
    a very high volume of concurrent requests or loads. In this case, each millisecond
    spent is important for our application. However, we still need to use AOP in our
    application in order to implement crosscutting concerns. So, what we need to take
    care of here is the right AOP configuration, avoiding the unnecessary scanning
    of objects for advice, configuring the exact join point to which we want advice,
    and avoiding the implementation of fine-grained requirements through AOP. For
    fine-grained requirements user AspectJ (the byte-code-weaving approach).
  prefs: []
  type: TYPE_NORMAL
- en: So the rule of thumb is, use AOP to implement crosscutting concerns and leverage
    its benefits. However, implement it cautiously, and with the right configurations
    that do not degrade system performance, by applying advice or proxies to each
    and every operation.
  prefs: []
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to improve the performance of an application, caching heavy operations
    is inevitable. Spring 3.1 added a great abstraction layer called **caching** that
    helped to abandon all custom-implemented `aspects`, decorators, and code injected
    into the business logic related to caching.
  prefs: []
  type: TYPE_NORMAL
- en: Spring applies caching to the methods of Spring beans using AOP concepts; we
    learned about it in the *AOP concepts* section of this chapter. Spring creates
    proxies of the Spring beans where the methods are annotated to be cached.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to leverage the benefits of Spring''s caching abstraction layer, just
    annotate heavy methods with `@Cacheable`. Also, we need to notify our application
    that methods are cached by annotating our configuration class with `@EnableCaching`.
    The following is the example of caching a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@Cacheable` annotation has the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`value`: Name of cache'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`key`: Caching key for each cached item'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`condition`: Defines whether to apply caching or not based on the evaluation
    of the **Spring Expression Language** (**SpEL**) expression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unless`: This is another condition written in SpEL, and if it is true, it
    prevents the return value from being cached'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are additional annotations provided by Spring related to caching:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@CachePut`: It will let the method execute and update the cache'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@CacheEvict`: It will remove stale data from the cache'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Caching`: It allows you to group multiple annotations `@Cacheable`, `@CachePut`,
    and `@CacheEvict` on the same method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@CacheConfig`: It will allow us to annotate our entire class instead of repeating
    on each method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use `@Cacheable` on methods that are retrieving data and use `@CachePut`
    on a method that performs insertion to update the cache. The code sample is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Annotating methods to cache the data would not store the data; for that, we
    need to implement or provide `CacheManager`. Spring, by default, provides some
    cache managers in the `org.springframework.cache` package and one of them is `SimpleCacheManager`.
    The `CacheManager` code sample is as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Spring also provides support to integrate the following third-party cache managers:'
  prefs: []
  type: TYPE_NORMAL
- en: EhCache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guava
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caffeine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hazelcast
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your custom cache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AOP method profiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applications can have many business methods. Due to some implementation issues,
    some methods take time and we want to measure how much time is taken by those
    methods and we may want to analyze method arguments, as well. Spring AOP provides
    a way to perform method profiling without touching business methods. Let's see
    how.
  prefs: []
  type: TYPE_NORMAL
- en: PerformanceMonitorInterceptor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's see how to perform profiling or monitoring on our method execution. This
    is done with the help of a simple option provided by Spring AOP using the `PerformanceMonitorInterceptor`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: As we have learned, Spring AOP allows the defining of crosscutting concerns
    in applications by intercepting the execution of one or more methods to add extra
    functionality without touching the core business classes.
  prefs: []
  type: TYPE_NORMAL
- en: The `PerformanceMonitorInterceptor` class from Spring AOP is an interceptor
    that can be tied to any custom method to be executed at the same time. This class
    uses a `StopWatch` instance to log the beginning and ending time of the method
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s monitor the `transfer` method of `TransferService`. The following is
    the `TransferService` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is `@Pointcut` to monitor the advice method using Spring
    interceptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is the advisor class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is the Spring Java configuration class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The expression in pointcut identifies the methods that we want to intercept.
    We have defined `PerformanceMonitorInterceptor` as a bean and then created `PerformanceMonitorAdvisor`
    to associate pointcut with the interceptor.
  prefs: []
  type: TYPE_NORMAL
- en: In our `Appconfig`, we have annotated with the `@EnableAspectJAutoProxy` annotation
    to enable AspectJ support for our beans to create a proxy automatically.
  prefs: []
  type: TYPE_NORMAL
- en: To have `PerformanceMonitorInterceptor` work, we need to set the log level of
    the target object, `TransferServiceImpl`, to the `TRACE` level as this is the
    level at which it logs messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'For every execution of the `transfer` method, we will see the `TRACE` message
    in the console log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Custom monitoring interceptor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`PerformanceMonitorInterceptor` is a very basic and simple way to monitor the
    execution of our method time. However, most of the time we would need more a controlled
    way to monitor the method and its parameters. For that, we can implement our custom
    interceptor, either by extending `AbstractMonitoringInterceptor` or writing around
    advice or a custom annotation. Here we will write a custom interceptor extending
    `AbstractMonitoringInterceptor`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s extend the `AbstractMonitoringInterceptor` class and override the `invokeUnderTrace`
    method to log the `start`, `end`, and duration of a method. We can also log a
    warning if the method execution lasts more than `5` milliseconds. The following
    is the code sample for the custom monitoring interceptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Every other step we saw in the basic `PerformanceMonitorInterceptor` would be
    same, just replace `PerformanceMonitorInterceptor` with `CustomPerformanceMonitorInterceptor`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Spring AOP versus AspectJ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen AOP using proxy patterns and runtime weaving. Now let's
    look at AOP at compile time and load time weaving.
  prefs: []
  type: TYPE_NORMAL
- en: What is AspectJ?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we know from the start of this chapter, AOP is a programming paradigm that
    helps to decouple our code by separating the implementation of crosscutting concerns. AspectJ
    is the original implementation of AOP, which implements both concerns and the
    weaving of crosscutting concerns using extensions of Java programming language.
  prefs: []
  type: TYPE_NORMAL
- en: To enable AspectJ in our project, we need AspectJ libraries and AspectJ provides
    different libraries based on its usage. One can find all its libraries, at [https://mvnrepository.com/artifact/org.aspectj](https://mvnrepository.com/artifact/org.aspectj).
  prefs: []
  type: TYPE_NORMAL
- en: 'In AspectJ, `Aspects` will be created in a file with the extension `.aj`*.* The
    following is the sample `TransferAspect.aj` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable compile-time weaving, when we have both `aspect` code and code to
    which we want to weave `aspects`, use the Maven plugin as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To perform post-compile time weaving, when we want to weave existing class
    files and JAR files, use Mojo''s AspectJ Maven plugin as follows. The artifact
    or JAR files we reference to weave must be listed as `<dependencies/>` in the
    Maven project and listed as `<weaveDependencies/>` in the `<configuration>` of
    the AspectJ Maven plugin. The following is the Maven sample for how to define
    weaving dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To perform **Load-time weaving** (**LTW**), when we want to defer our weaving
    until the class loader loads a class file, we would need a weaving agent; use
    the Maven plugin as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'For LTW, it looks for `aop.xml` in the classpath under the `META-INF` folder.
    The file contains the `aspect` and `weaver` tags as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: So this was just an introduction for how to enable AspectJ in our project.
  prefs: []
  type: TYPE_NORMAL
- en: Differences between Spring AOP and AspectJ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at the differences between Spring AOP (runtime weaving) and AspectJ
    (compile-time and LTW).
  prefs: []
  type: TYPE_NORMAL
- en: Capabilities and goals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring AOP provides a simple AOP implementation to implement crosscutting concerns
    using the proxy pattern and decorator pattern. It is not considered a complete
    AOP solution, Spring can be applied to the beans that are managed by a Spring
    container.
  prefs: []
  type: TYPE_NORMAL
- en: AspectJ is the original AOP technology, aiming to provide a complete AOP solution.
    It is more robust, however, and more complicated than Spring AOP. The benefit
    of AspectJ is that it can be applied across all domain objects.
  prefs: []
  type: TYPE_NORMAL
- en: Weaving
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both Spring AOP and AspectJ use the different types of weaving and, based on
    their weaving mechanism, their behavior regarding performance and ease of use
    are different.
  prefs: []
  type: TYPE_NORMAL
- en: To perform runtime weaving of our `aspects` during the execution of the application,
    Spring creates proxies of the targeted object using either the JDK dynamic proxy
    or CGLIB proxy, which we discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: As opposed to Spring AOP's runtime weaving, AspectJ performs weaving at compile-time
    or classload-time. We already saw different types of AspectJ weaving in the preceding
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Join points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As Spring AOP creates proxies of target classes or objects to apply crosscutting
    concerns (`Aspects`), it needs to perform subclassing of the targeted class or
    object. As we already know, with subclassing, Spring AOP cannot apply crosscutting
    concerns on classes or methods that are final or static.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, AspectJ weaves crosscutting concerns into the actual code
    using byte-code weaving and hence it doesn't need to subclass the targeted class
    or object.
  prefs: []
  type: TYPE_NORMAL
- en: Simplicity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Spring AOP, the runtime weaving of `Aspects` will be performed by the container
    at startup and hence it integrates seamlessly with our building process.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, in AspectJ, we have to perform this using an extra compiler
    (`ajc`) unless we are doing this post-compilation or in LTW. For this reason,
    Spring is simpler and more manageable than AspectJ.
  prefs: []
  type: TYPE_NORMAL
- en: With Spring AOP, we cannot use or apply the full power of AOP because Spring
    AOP is proxy-based and can only be applied to Spring-managed beans.
  prefs: []
  type: TYPE_NORMAL
- en: AspectJ is based on byte-code weaving, meaning it modifies our code and hence
    it enables us to use the full power of AOP on any bean of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From a performance point of view, compile-time weaving would be faster than
    run-time weaving. Spring AOP is a proxy-based framework, so it creates additional
    objects for proxies at runtime and there are more method invocations per `aspect`,
    which affects performance negatively.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, AspectJ weaves `aspects` into the main code before the application
    starts and hence there's no additional runtime overhead. There are benchmarks
    available on the internet that say AspectJ is much faster than Spring AOP.
  prefs: []
  type: TYPE_NORMAL
- en: It is not like one framework is better than another. A choice would be made
    based on the requirements and many different factors, such as overhead, simplicity,
    manageability/maintainability, complexity, and learning curve. If we are using
    fewer `aspects` and there is no need to apply `aspect` apart from a Spring bean
    or method executions, then the performance difference between Spring AOP and AspectJ
    is trivial. We can use AspectJ and Spring AOP together to achieve our requirements
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: AspectJ with Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring provides small libraries to enable AspectJ `aspects` into Spring projects.
    This library is named `spring-aspects.jar`. As we know from our earlier discussion,
    Spring allows dependency injection or AOP advice only on Spring bean. With Spring's
    AspectJ support using this small library, we can enable any object created outside
    the container for Spring-driven configuration. Just annotate the outside object
    with `@Configurable`. Annotating a non-Spring bean with `@Configurable` would
    require `AnnotationBeanConfigurerAspect` in `spring-aspects.jar`. The `AnnotationBeanConfigurerAspect`
    configuration needed by Spring can be done by annotating our configuration Java configuration
    class with `@EnableSpringConfigured`.
  prefs: []
  type: TYPE_NORMAL
- en: Spring provides a finer way to enable **Load-time weaving** (**LTW**) by enabling
    a per-class loader basis. This gives much more fine-grained control, especially
    when we are deploying large or multiple applications into a single JVM environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use LTW with Spring, we need to implement our `aspect` or advice as we had
    implemented earlier in the *AOP concepts* sections and, as per the AspectJ concepts,
    we need to create `aop.xml` in the `META-INF` folder, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The last thing we need to do is annotate our Java-based Spring configuration
    with `@EnableLoadTimeWeaving`. We need to add `-javaagent:path/to/org.springframework.instrument-{version}.jar`
    in our server launch script.
  prefs: []
  type: TYPE_NORMAL
- en: AOP best programming practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned about why AOP is needed in our application. We learned about
    its concepts and how to use it in detail. Let's see what best practices should
    be followed when using AOP in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Pointcut expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We learned about pointcut in terms of AOP. Now let''s see what we should take
    care of when using pointcut:'
  prefs: []
  type: TYPE_NORMAL
- en: Spring with AspectJ processes the pointcuts during compilation and tries to
    match and optimize matching performance. However, examining code and matching
    (statically or dynamically) would be a costly process. So, for optimal performance,
    think twice about what we want to achieve and narrow down our search or matching
    criteria as much as possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All the designators we learned earlier in this chapter are divided into three
    categories:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Method signature pattern: `execution`, `get`, `set`, `call`, `handler`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Type signature pattern: `within`, `withincode`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Contextual signature pattern: `this`, `target`, `@annotation`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to achieve good performance, write pointcut that includes the method
    at least and type signature pattern. It is not like matching would not work if
    we use only the method or type pattern; however, it is always recommended to join
    the method and type signature together. The type signature is very fast as it
    narrows down the search space by quickly opting out join points that could not
    be further processed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declare pointcuts on empty methods and refer to those pointcuts by their empty
    method name (named pointcut), so in case of any change to an expression, we have
    to change only at one place.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is also recommended to declare small-named pointcuts and combine them by
    name to build complex pointcuts. Referring to pointcuts by name would follow the
    default Java method visibility rules. The following is the code sample of defining
    small pointcuts and joining them:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Try to create anonymous beans for pointcuts when they are not shared to avoid
    direct access by an application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to use static pointcuts where arguments need not be matched. These are faster
    and cached by Spring when the method is invoked first. Dynamic pointcuts are costly
    because they are evaluated on every method invocation because caching cannot be
    done as the argument would differ.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advice ordering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we know how to write advice and how to create `Aspect`. Let''s see how
    advice ordering can help us to prioritize our advice when we have multiple advice
    on the same join point:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's say we wrote two before or after advice in different aspects and both
    want to run at the same join point. In this case, the order of execution of the
    advice would be based on the which aspect comes first in the execution of classes.
    To avoid this and apply our advice one after the other, Spring provides a way
    to specify the order of execution by either implementing the `Ordered` interface
    by an aspect or applying the `@Order` annotation. The lower the value of the order,
    the higher the precedence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While declaring an advice, always use the least powerful form of advice; for
    example, if a simple before advice would achieve our requirement, we should not
    use the around advice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices of AOP proxies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We learned about AOP proxies and how AOP proxies work. We learned about different
    types of proxies in Spring AOP. The following are best practices to be followed
    while implementing AOP proxies in Spring:'
  prefs: []
  type: TYPE_NORMAL
- en: Unless we need to perform a manipulative action at runtime or we want to gain
    fine-grained control of our proxies, use the declarative method of proxy configuration
    over the programmatic method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring recommends JDK dynamic proxy over the CGLIB proxy wherever possible.
    If we are building our application from scratch and there is no requirement to
    create proxies of third-party APIs, implement the abstraction layer to loosely-couple
    the implementation using the interface and let Spring use the JDK dynamic proxy
    mechanism to create proxies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In case of CGLIB proxies, make sure the methods are not `final`, as `final`
    methods cannot be overridden and hence they cannot be advised.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'According to Spring, it is not possible to have `aspects` themselves be the
    target of advice from other `aspects`. There are workarounds for this situation;
    move the `aspect` method to a  new Spring bean annotated with `@Component`, `@Autowire`
    this new Spring bean to `aspect`, and just call the advised method. `MethodProfilingAspect`
    is `aspect` defining a pointcut on all join points under `com.packt.springhighperformance.ch3.bankingapp`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The following `ValidatingAspect` is `aspect` defined under the `com.packt.springhighperformance.ch3.bankapp`
    package, however a call to the `validate` method would not be advised by `MethodProfilingAspect`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the solution by creating a separate class with the `@Component`
    annotation and implementing the `validate` method. This class will be a Spring-managed
    bean and it will be advised:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code of `ValidatingAspect` injects the `ValidateDefault` Spring
    bean and calls the `validate` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Never implement fine-grained requirements through AOP or use AspectJ for such
    requirements. Do not use `@Configurable` on Spring-managed bean classes, otherwise
    it would do double initialization, once through the container and once through
    the aspect.
  prefs: []
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen how to improve our application''s performance with the use of
    caching. The following are the best practices to be followed when implementing
    caching in Spring:'
  prefs: []
  type: TYPE_NORMAL
- en: Spring cache annotations should be used on concrete classes and not on interfaces.
    If we choose to use `proxy-target-class="true"`, caching will not work because
    the Java annotation from the interfaces cannot be inherited.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try not use `@Cacheable` and `@CachePut` together on the same method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not cache very low-level methods close, such as CPU-intensive and in-memory
    computations. Spring's caching might be overkill in those scenarios.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the Spring AOP module. AOP is a powerful programming
    paradigm that complements object-oriented programming. AOP helps to decouple crosscutting
    concerns from business logic and helps us to focus only on business logic when
    working on business requirements. Decoupled crosscutting concerns help to implement
    the reusable code.
  prefs: []
  type: TYPE_NORMAL
- en: We learned about AOP concepts, its terminologies, and how to implement advice.
    We learned about proxies and how Spring AOP is implemented using the proxy pattern.
    We learned best practices to be followed while working on Spring AOP to achieve
    better quality and performance.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about Spring MVC. Spring Web MVC provides
    a web framework that is based on MVC. Using Spring Web MVC as a web framework
    enables us to develop loosely-coupled web applications with the benefit of writing
    test cases without using request and response objects. We will see how can we
    optimize the Spring MVC implementation to achieve better results using async method
    features, multithreading, and authentication caching.
  prefs: []
  type: TYPE_NORMAL
