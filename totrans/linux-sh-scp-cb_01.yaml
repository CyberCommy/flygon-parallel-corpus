- en: Chapter 1. Shell Something Out
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Printing in the terminal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing with variables and environment variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doing Math calculations with the shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing with file descriptors and redirection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays and associative arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visiting aliases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grabbing information about the terminal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting, setting dates, and delays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging the script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions and arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading output of a sequence of commands in a variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading "n" characters without pressing Return
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Field separators and iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparisons and tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UNIX-like systems are amazing operating system designs. Even after many decades,
    the UNIX-style architecture for operating systems serves as one of the best designs.
    One of the most important features of this architecture is the command-line interface
    or the shell. The shell environment helps users to interact with and access core
    functions of the operating system. The term scripting is more relevant in this
    context. Scripting is usually supported by interpreter-based programming languages.
    Shell scripts are files in which we write a sequence of commands that we need
    to perform. And the script file is executed using the shell utility.
  prefs: []
  type: TYPE_NORMAL
- en: In this book we are dealing with **Bash** (**Bourne Again Shell**), which is
    the default shell environment for most GNU/Linux systems. Since GNU/Linux is the
    most prominent operating system based on a UNIX-style architecture, most of the
    examples and discussions are written by keeping Linux systems in mind.
  prefs: []
  type: TYPE_NORMAL
- en: 'The primary purpose of this chapter is to give readers an insight about the
    shell environment and become familiar with the basic features that come around
    the shell. Commands are typed and executed in a shell terminal. When opened, in
    a terminal, a prompt is available. It is usually in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Or simply as **$** or **#.**
  prefs: []
  type: TYPE_NORMAL
- en: '`$` represents regular users and `#` represents the administrative user root.
    Root is the most privileged user in a Linux system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A shell script is a text file that typically begins with a shebang, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: For any scripting language in a Linux environment, a script starts with a special
    line called shebang. Shebang is a line for which `#!` is prefixed to the interpreter
    path. `/bin/bash` is the interpreter command path for Bash.
  prefs: []
  type: TYPE_NORMAL
- en: Execution of a script can be done in two ways. Either we can run the script
    as a command-line argument for `sh` or run a self executable with execution permission.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script can be run with the filename as a command-line argument as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If a script is run as a command-line argument for `sh`, the shebang in the script
    is of no use.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to self execute a shell script, it requires executable permission.
    While running as a self executable, it makes use of the shebang. It runs the script
    using the interpreter path that is appended to `#!` in shebang. The execution
    permission for the script can be set as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This command gives the `script.sh` file the executable permission for all users.
    The script can be executed as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The shell program will read the first line and see that the shebang is `#!/bin/bash`.
    It will identify the `/bin/bash` and execute the script internally as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When a terminal is opened it initially executes a set of commands to define
    various settings like prompt text, colors, and many more. This set of commands
    (run commands) are read from a shell script called `.bashrc`, which is located
    in the home directory of the user (`~/.bashrc`). The bash shell also maintains
    a history of commands run by the user. It is available in the file `~/.bash_history`.
    `~` is the shorthand for the user home directory path.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Bash, each command or command sequence is delimited by using a semicolon
    or a new line. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the `#` character is used to denote the beginning of unprocessed comments.
    A comment section starts with `#` and proceeds up to the end of that line. The
    comment lines are most often used to provide comments about the code in the file
    or to stop a line of code from being executed.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's move on to the basic recipes in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Printing in the terminal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The terminal is an interactive utility by which a user interacts with the shell
    environment. Printing text in the terminal is a basic task that most shell scripts
    and utilities need to perform regularly. Printing can be performed via various
    methods and in different formats.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`echo` is the basic command for printing in the terminal.'
  prefs: []
  type: TYPE_NORMAL
- en: '`echo` puts a newline at the end of every invocation by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Simply using double-quoted text with the `echo` command prints the text in
    the terminal. Similarly, text without double-quotes also gives the same output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to do the same task is by using single quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'These methods may look similar, but some of them have got a specific purpose
    and side effects too. Consider the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Hence, if you want to print `!`, do not use within double-quotes or you may
    escape the `!` with a special escape character (`\`) prefixed with it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: When using `echo` with double-quotes, you should add `set +H` before issuing
    `echo` so that you can use `!`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The side effects of each of the methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When using `echo` without quotes, we cannot use a semicolon as it acts as a
    delimiter between commands in the bash shell.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`echo hello;hello` takes `echo hello` as one command and the second `hello`
    as the second command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using `echo` with single quotes, the variables (for example, `$var` will
    not be expanded) inside the quotes will not be interpreted by Bash, but will be
    displayed as is.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This means:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ echo ''$var''` will return `$var`'
  prefs: []
  type: TYPE_NORMAL
- en: whereas
  prefs: []
  type: TYPE_NORMAL
- en: '`$ echo $var` will return the value of the variable `$var` if defined or nothing
    at all if it is not defined.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another command for printing in the terminal is the `printf` command. `printf`
    uses the same arguments as the `printf` command in the C programming language.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`printf` takes quoted text or arguments delimited by spaces. We can use formatted
    strings with `printf`. We can specify string width, left or right alignment, and
    so on. By default, `printf` does not have newline as in the `echo` command. We
    have to specify a newline when required, as shown in the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We will receive the formatted output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`%s`, `%c`, `%d`, and `%f` are format substitution characters for which an
    argument can be placed after the quoted format string.'
  prefs: []
  type: TYPE_NORMAL
- en: '`%-5s` can be described as a string substitution with left alignment (`-` represents
    left alignment) with width equal to `5`. If `-` was not specified, the string
    would have been aligned to the right. The width specifies the number of characters
    reserved for that variable. For `Name`, the width reserved is `10`. Hence, any
    name will reside within the 10-character width reserved for it and the rest of
    the characters will be filled with space up to 10 characters in total.'
  prefs: []
  type: TYPE_NORMAL
- en: For floating point numbers, we can pass additional parameters to round off the
    decimal places.
  prefs: []
  type: TYPE_NORMAL
- en: For marks, we have formatted the string as `%-4.2f`, where `.2` specifies rounding
    off to two decimal places. Note that for every line of the format string a `\n`
    newline is issued.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It should be always noted that flags (such as -e, -n, and so on) for `echo`
    and `printf` should appear before any strings in the command, else Bash will consider
    the flags as another string.
  prefs: []
  type: TYPE_NORMAL
- en: Escaping newline in echo
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, `echo` has a newline appended at the end of its output text. This
    can be avoided by using the `-n` flag. `echo` can also accept escape sequences
    in double-quoted strings as argument. For using escape sequences, use `echo` as
    `echo -e "string containing escape sequences"`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Printing colored output
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Producing colored output on the terminal is very interesting stuff. We produce
    colored output using escape sequences.
  prefs: []
  type: TYPE_NORMAL
- en: Color codes are used to represent each color. For example, reset=0, black=30,
    red=31, green=32, yellow=33, blue=34, magenta=35, cyan=36, and white=37.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to print colored text, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here `\e[1;31` is the escape string that sets the color to red and `\e[0m` resets
    the color back. Replace `31` with the required color code.
  prefs: []
  type: TYPE_NORMAL
- en: For a colored background, reset = 0, black = 40, red = 41, green = 42, yellow
    = 43, blue = 44, magenta = 45, cyan = 46, and white=47, are the color code that
    are commonly used.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to print a colored background, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Playing with variables and environment variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variables are essential components of every programming language and are used
    to hold varying data. Scripting languages usually do not require variable type
    declaration before its use. It can be assigned directly. In Bash, the value for
    every variable is string. If we assign variables with quotes or without quotes,
    they are stored as string. There are special variables used by the shell environment
    and the operating system environment to store special values, which are called
    environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Variables are named with usual naming constructs. When an application is executing,
    it will be passed with a set of variables called environment variables. From the
    terminal, to view all the environment variables related to that terminal process,
    issue the `env` command. For every process, environment variables in its runtime
    can be viewed by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Set the `PID` with the process ID of the relevant process (PID is always an
    integer).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, assume that an application called gedit is running. We can obtain
    the process ID of gedit with the `pgrep` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You can obtain the environment variables associated with the process by executing
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note that many environment variables are stripped off for convenience. The actual
    output may contain numerous variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The above mentioned command returns a list of environment variables and their
    values. Each variable is represented as a `name=value` pair and are separated
    by a null character (`\0`). If you can substitute the `\0` character with `\n`,
    you can reformat the output to show each `variable=value` pair in each line. Substitution
    can be made using the `tr` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's see how to assign and manipulate variables and environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A variable can be assigned as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`var` is the name of a variable and value is the value to be assigned. If `value`
    does not contain any white space characters (like a space), it need not be enclosed
    in quotes, else it must be enclosed in single or double quotes.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that `var = value` and `var=value` are different. It is a common mistake
    to write `var =value` instead of `var=value`. The later is the assignment operation,
    whereas the former is an equality operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Printing the contents of a variable is done using by prefixing `$` with the
    variable name as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We can use variable values inside `printf` or `echo` in double quotes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Environment variables are variables that are not defined in the current process,
    but are received from the parent processes. For example, `HTTP_PROXY` is an environment
    variable. This variable defines which proxy server should be used for an Internet
    connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, it is set as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The export command is used to set the `env` variable. Now any application, executed
    from the current shell script will receive this variable. We can export custom
    variables for our own purposes in an application or shell script that is executed.
    There are many standard environment variables that are available for the shell
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, `PATH`. A typical `PATH` variable will contain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'When given a command for execution, shell automatically searches for the executable
    in the list of directories in the `PATH` environment variable (directory paths
    are delimited by the ":" character). Usually, `$PATH` is defined in `/etc/environment`
    or `/etc/profile` or `~/.bashrc`. When we need to add a new path to the `PATH`
    environment, we use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, alternately, we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here we have added `/home/user/bin` to `PATH`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the well-known environment variables are: `HOME`, `PWD`, `USER`, `UID`,
    `SHELL`, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's see some more tips associated with regular and environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: Finding length of string
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Get the length of a variable value as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '`length` is the number of characters in the string.'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the current shell
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Display the currently used shell as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, you can also use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Check for super user
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'UID is an important environment variable that can be used to check whether
    the current script has been run as root user or regular user. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The UID for the root user is 0.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the Bash prompt string (username@hostname:~$)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we open a terminal or run a shell, we see a prompt string like `user@hostname:
    /home/$`. Different GNU/Linux distributions have slightly different prompts and
    different colors. We can customize the prompt text using the `PS1` environment
    variable. The default prompt text for the shell is set using a line in the `~/.bashrc`
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can list the line used to set the `PS1` variable as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to set a custom prompt string, enter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We can use colored text by using the special escape sequences like `\e[1;31`
    (refer to the *Printing in the terminal* recipe of this chapter).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are also certain special characters that expand to system parameters.
    For example,`\u` expands to username, `\h` expands to hostname, and `\w` expands
    to the current working directory.
  prefs: []
  type: TYPE_NORMAL
- en: Doing math calculations with the shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arithmetic operations are an essential requirement for every programming language.
    The Bash shell comes with a variety of methods for arithmetic operations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Bash shell environment can perform basic arithmetic operations using the
    commands `let`, `(( ))`, and `[]`. The two utilities `expr` and `bc` are also
    very helpful in performing advanced operations.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A numeric value can be assigned as a regular variable assignment, which is stored
    as string. However, we use methods to manipulate as numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `let` command can be used to perform basic operations directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'While using `let`, we use variable names without the `$` prefix, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Increment operation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Decrement operation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Shorthands:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: These are equal to `let no=no+6` and `let no=no-6` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternate methods:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `[]` operator can be used similar to the `let` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `$` prefix inside `[]` operators are legal, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '`(( ))` can also be used. `$` prefixed with a variable name is used when the
    `(( ))` operator is used, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '`expr` can also be used for basic operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: All of the above methods do not support floating point numbers, and operate
    on integers only.
  prefs: []
  type: TYPE_NORMAL
- en: '`bc` the precision calculator is an advanced utility for mathematical operations.
    It has a wide range of options. We can perform floating point operations and use
    advanced functions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Additional parameters can be passed to `bc` with prefixes to the operation with
    semicolon as delimiters through `stdin`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Specifying decimal precision (scale):** In the following example the `scale=2`
    parameter sets the number of decimal places to `2`. Hence the output of `bc` will
    contain a number with two decimal places:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '**Base conversion with bc:** We can convert from one base number system to
    another one. Let''s convert from decimal to binary, and binary to octal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Calculating squares and square roots can be done as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Playing with file descriptors and redirection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: File descriptors are integers that are associated with file input and output.
    They keep track of opened files. The best-known file descriptors are `stdin` ,
    `stdout` , and `stderr` . We can redirect the contents of one file descriptor
    to another. The following recipe will give examples on how to manipulate and redirect
    with file descriptors.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While writing scripts we use standard input (`stdin`), standard output (`stdout`),
    and standard error (`stderr`) frequently. Redirection of output to a file by filtering
    the contents is one of the essential things we need to perform. While a command
    outputs some text, it can be either an error or an output (non-error) message.
    We cannot distinguish whether it is output text or an error text by just looking
    at it. However, we can handle them with file descriptors. We can extract text
    that is attached to a specific descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: 'File descriptors are integers associated with an opened file or data stream.
    File descriptors 0, 1, and 2 are reserved as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 0 – `stdin` (standard input)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 – `stdout` (standard output)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 – `stderr` (standard error)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Redirecting or saving output text to a file can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This would store the echoed text in `temp.txt` by truncating the file, the contents
    will be emptied before writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This would append the text into the file.
  prefs: []
  type: TYPE_NORMAL
- en: '`>` and `>>` operators are different. Both of them redirect text to a file,
    but the first one empties the file and then writes to it, whereas the later one
    adds the output to the end of the existing file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'View the contents of the file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: When we use a redirection operator, it won't print in the terminal but it is
    directed to a file. When redirection operators are used, by default, it takes
    standard output. In order to explicitly take a specific file descriptor, you must
    prefix the descriptor number to the operator.
  prefs: []
  type: TYPE_NORMAL
- en: '`>` is equivalent to `1>` and similarly it applies for `>>` (equivalent to
    `1>>`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what a standard error is and how you can redirect it. `stderr` messages
    are printed when commands output an error message. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Here `+` is an invalid argument and hence an error is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Successful and unsuccessful command**'
  prefs: []
  type: TYPE_NORMAL
- en: When a command returns after error, it returns a non-zero exit status. The command
    returns zero when it terminates after successful completion. Return status can
    be read from special variable `$?` (run `echo $?` immediately after the command
    execution statement to print the exit status).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command prints the `stderr` text to the screen rather than to
    a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'However, in the following command the `stdout` output is empty, so an empty
    file `out.txt` is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'You can redirect `stderr` exclusively to a file and `stdout` to another file
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to redirect `stderr` and `stdout` to a single file by converting
    `stderr` to `stdout` using this preferred method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'or an alternate approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes the output may contain unnecessary information (such as debug messages).
    If you don't want the output terminal burdened with the `stderr` details, then
    you should redirect `stderr` output to `/dev/null`, which removes it completely.
    For example, consider that we have three files a1, a2, and a3\. However, a1 does
    not have read-write-execute permission for the user. When you need to print the
    contents of files starting with `a`, you can use the `cat` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up the test files as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'While displaying contents of the files using wildcards (`a*`), it will show
    an error message for file `a1` as it does not have the proper read permission:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Here `cat: a1: Permission denied` belongs to `stderr` data. We can redirect
    `stderr` data into a file, whereas `stdout` remains printed in the terminal. Consider
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `stderr` output is dumped to the `/dev/null` file. `/dev/null`
    is a special device file where any data received by the file is discarded. The
    null device is often called the bit bucket or black hole.
  prefs: []
  type: TYPE_NORMAL
- en: When redirection is performed for `stderr` or `stdout`, the redirected text
    flows into a file. As the text has already been redirected and has gone into the
    file, no text remains to flow to the next command through pipe (`|`), and it appears
    to the next set of command sequence through `stdin`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is a tricky way to redirect data to a file as well as provide
    a copy of redirected data as `stdin` for the next set of commands. This can be
    done using the `tee` command. For example, to print the `stdout` in the terminal
    as well as redirect `stdout` into a file, the syntax for`tee` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`command | tee FILE1 FILE2`'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, `stdin` data is received by the `tee` command. It writes
    a copy of `stdout` to the file `out.txt` and sends another copy as `stdin` for
    the next command. The `cat –n` command puts a line number for each line received
    from `stdin` and writes it into `stdout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Examine the contents of `out.txt` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `cat: a1: Permission denied` does not appear because it belongs to
    `stdin`. `tee` can read from `stdin` only.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the `tee` command overwrites the file, but it can be used with
    appended options by providing the `-a` option, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Commands appear with arguments in the format: `command FILE1 FILE2…` or simply
    `command FILE`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `stdin` as a command argument. It can be done by using `–` as the
    filename argument for the command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Alternately, we can use `/dev/stdin` as the output filename to use `stdin`.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, use `/dev/stderr` for standard error and `/dev/stdout` for standard
    output. These are special device files that correspond to `stdin`, `stderr`, and
    `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A command that reads `stdin` for input can receive data in multiple ways. Also,
    it is possible to specify file descriptors of our own using `cat` and pipes, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Redirection from file to command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By using redirection, we can read data from a file as `stdin` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Redirecting from a text block enclosed within a script
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes we need to redirect a block of text (multiple lines of text) as standard
    input. Consider a particular case where the source text is placed within the shell
    script. A practical usage example is writing a log file header data. It can be
    performed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The lines that appear between `cat <<EOF >log.txt` and the next `EOF` line
    will appear as `stdin` data. Print the contents of `log.txt` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Custom file descriptors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A file descriptor is an abstract indicator for accessing a file. Each file access
    is associated with a special number called a file descriptor. 0, 1, and 2 are
    reserved descriptor numbers for `stdin`, `stdout`, and `stderr`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create our own custom file descriptors using the `exec` command. If
    you are already familiar with file programming with any other programming languages,
    you might have noticed modes for opening files. Usually, three modes are used:'
  prefs: []
  type: TYPE_NORMAL
- en: Read mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write with truncate mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write with append mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<` is an operator used to read from the file to `stdin`. `>` is the operator
    used to write to a file with truncation (data is written to the target file after
    truncating the contents). `>>` is an operator used to write to a file with append
    (data is appended to the existing file contents and the contents of the target
    file will not be lost). File descriptors can be created with one of the three
    modes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file descriptor for reading a file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'We could use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can use file descriptor `3` with commands. For example, `cat <&3` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: If a second read is required, we cannot reuse file descriptor `3`. It is needed
    to reassign file descriptor `3` for read using `exec` for making a second read.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file descriptor for writing (truncate mode) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file descriptor for writing (append mode) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Arrays and associative arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arrays are a very important component for storing a collection of data as separate
    entities using indexes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bash supports regular arrays as well as associative arrays. Regular arrays are
    arrays which can use only integers as its array index. But associative arrays
    are arrays which can take a string as its array index.
  prefs: []
  type: TYPE_NORMAL
- en: Associative arrays are very useful in many types of manipulations. Associative
    array support came with version 4.0 of Bash. Therefore, older versions of Bash
    will not support associative arrays.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An array can be defined in many ways. Define an array using a list of values
    in a line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternately, define an array as a set of index-value pairs as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the contents of an array at a given index using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Print all of the values in an array as a list using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternately, you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the length of an array (the number of elements in an array), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Associative arrays have been introduced to Bash from version 4.0\. They are
    useful entities to solve many problems using the hashing technique. Let's go into
    more details.
  prefs: []
  type: TYPE_NORMAL
- en: Defining associative arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In an associative array, we can use any text data as an array index. However,
    ordinary arrays can only use integers for array indexing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, a declaration statement is required to declare a variable name as
    an associative array. A declaration can be made as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'After the declaration, elements can be added to the associative array using
    two methods, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'By using inline index-value list method, we can provide a list of index-value
    pairs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternately, you could use separate index-value assignments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, consider the assignment of prices for fruits using an associative
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Display the content of an array as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Listing of array indexes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Arrays have indexes for indexing each of the elements. Ordinary and associative
    arrays differ in terms of index type. We can obtain the list of indexes in an
    array as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we can also use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous `fruits_value` array example, consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: This will work for ordinary arrays too.
  prefs: []
  type: TYPE_NORMAL
- en: Visiting aliases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An alias is basically a shortcut that takes the place of typing a long command
    sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Aliases can be implemented in multiple ways, either by using functions or by
    using the `alias` command.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An alias can be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Giving a shortcut to the install command, `apt-get install`, can be done as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, we can use `install pidgin` instead of `sudo apt-get install pidgin`.
  prefs: []
  type: TYPE_NORMAL
- en: The `alias` command is temporary; aliasing exists until we close the current
    terminal only. In order to keep these shortcuts permanent, add this statement
    to the `~/.bashrc` file. Commands in `~/.bashrc` are always executed when a new
    shell process is spawned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: To remove an alias, remove its entry from `~/.bashrc` or use the `unalias` command.
    Another method is to define a function with a new command name and write it in
    `~/.bashrc`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can alias `rm` so that it will delete the original and keep a copy in a
    backup directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: When you create an alias, if the item being aliased already exists, it will
    be replaced by this newly aliased command for that user.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are situations when aliasing can also be a security breach. See how to
    identify them:'
  prefs: []
  type: TYPE_NORMAL
- en: Escaping aliases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `alias` command can be used to alias any important command, and you may
    not always want to run the command using the alias. We can ignore any aliases
    currently defined by escaping the command we want to run. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: The `\` character escapes the command, running it without any aliased changes.
    While running privileged commands on an untrusted environment, it is always a
    good security practise to ignore aliases by prefixing the command with `\`. The
    attacker might have aliased the privileged command with his own custom command
    to steal the critical information that is provided to the command by the user.
  prefs: []
  type: TYPE_NORMAL
- en: Grabbing information about terminal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While writing command-line shell scripts, we will often need to heavily manipulate
    information about the current terminal, such as number of columns, rows, cursor
    positions, masked password fields, and so on. This recipe helps to learn about
    collecting and manipulating terminal settings.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`tput` and `stty` are utilities that can be used for terminal manipulations.
    Let''s see how to use them to perform different tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Get number of columns and rows in a terminal as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to print the current terminal name, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'For moving the cursor to a position 100,100 you can enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the background color for terminal as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '`no` can be a value in the range of 0 to 7.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the foreground color for text as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '`no` can be a value in the range of 0 to 7.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to make the text bold use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Start and end underlining by using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to delete from cursor to end of the line use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'While typing a password, we should not display the characters typed. In the
    following example, we will see how to do it using `stty`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: The `-echo` option above disables output to the terminal, whereas `echo` enables
    output.
  prefs: []
  type: TYPE_NORMAL
- en: Getting, setting dates, and delays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many applications require printing dates in different formats, setting the date
    and time, and performing manipulations based on the date and time. Delays are
    commonly used to provide a wait time (for example, 1 second) during the program's
    execution. Scripting contexts, such as performing a monitoring task every five
    seconds, demand the understanding of writing delays in a program. This recipe
    will show you how to work with dates and time delays.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dates can be printed in a variety of formats. We can also set dates from the
    command line. In UNIX-like systems, dates are stored as an integer in seconds
    since 1970-01-01 00:00:00 UTC. This is called epoch or UNIX time. Let's see how
    to read dates and set them.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can read the date as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'The epoch time can be printed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Epoch is defined as the number of seconds that have elapsed since midnight proleptic
    Coordinated Universal Time (UTC) of January 1, 1970, not counting leap seconds.
    Epoch time is useful when you need to calculate the difference between two dates
    or time. You may find out the epoch times for two given timestamps and take the
    difference between the epoch values. Therefore, you can find out the total number
    of seconds between two dates.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can find out epoch from a given formatted date string. You can use dates
    in multiple date formats as input. Usually, you don''t need to bother about the
    date string format that you use if you are collecting the date from a system log
    or any standard application generated output. You can convert a date string into
    epoch as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: The `--date` option is used to provide a date string as input. However, we can
    use any date formatting options to print output. Feeding input date from a string
    can be used to find out the weekday, given the date.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'The date format strings are listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Date component | Format |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Weekday | `%a` (for example:. Sat)`%A` (for example: Saturday) |'
  prefs: []
  type: TYPE_TB
- en: '| Month | `%b` (for example: Nov)`%B` (for example: November) |'
  prefs: []
  type: TYPE_TB
- en: '| Day | `%d` (for example: 31) |'
  prefs: []
  type: TYPE_TB
- en: '| Date in format (mm/dd/yy) | `%D` (for example: 10/18/10) |'
  prefs: []
  type: TYPE_TB
- en: '| Year | `%y` (for example: 10)`%Y` (for example: 2010) |'
  prefs: []
  type: TYPE_TB
- en: '| Hour | `%I` or `%H` (for example: 08) |'
  prefs: []
  type: TYPE_TB
- en: '| Minute | `%M` (for example: 33) |'
  prefs: []
  type: TYPE_TB
- en: '| Second | `%S` (for example: 10) |'
  prefs: []
  type: TYPE_TB
- en: '| Nano second | `%N` (for example:695208515) |'
  prefs: []
  type: TYPE_TB
- en: '| epoch UNIX time in seconds | `%s` (for example: 1290049486) |'
  prefs: []
  type: TYPE_TB
- en: 'Use a combination of format strings prefixed with `+` as an argument for the
    `date` command to print the date in the format of your choice. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'We can set the date and time as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes we need to check the time taken by a set of commands. We can display
    it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: An alternate method would be to use `timescriptpath` to get the time that it
    took to execute the script.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Producing time intervals are essential when writing monitoring scripts that
    execute in a loop. Let's see how to generate time delays.
  prefs: []
  type: TYPE_NORMAL
- en: Producing delays in a script
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to delay execution in a script for some period of time, use `sleep:$
    sleep no_of_seconds`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following script counts from 0 to 40 by using `tput` and `sleep`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: In the above example, a variable count is initialized to 0 and is incremented
    on every loop execution. The `echo` statement prints the text. We use `tput sc`
    to store the cursor position. On every loop execution we write the new count in
    the terminal by restoring the cursor position for the number. The cursor position
    is restored using `tput rc. tput ed` clears text from the current cursor position
    to the end of the line, so that the older number can be cleared and the count
    can be written. A delay of 1 second is provided in the loop by using the sleep
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging the script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging is one of the critical features every programming language should
    implement to produce race-back information when something unexpected happens.
    Debugging information can be used to read and understand what caused the program
    to crash or to act in an unexpected fashion. Bash provides certain debugging options
    that every sysadmin should know. There are also some other tricky ways to debug.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No special utilities are required to debug shell scripts. Bash comes with certain
    flags that can print arguments and inputs taken by the scripts. Let's see how
    to do it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add the `-x` option to enable debug tracing of a shell script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Running the script with the `-x` flag will print each source line with current
    status. Note that you can also use `sh –x script`.
  prefs: []
  type: TYPE_NORMAL
- en: The `-x` flag outputs every line of script as it is executed to `stdout`. However,
    we may require only some portions of the source lines to be observed such that
    commands and arguments are to be printed at certain portions. In such conditions
    we can use `set built-in` to enable and disable debug printing within the script.
  prefs: []
  type: TYPE_NORMAL
- en: '`set -x`: Displays arguments and commands upon their execution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set +x`: Disables debugging'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set –v`: Displays input when they are read'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set +v`: Disables printing input'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: In the above script, debug information for `echo $i` will only be printed as
    debugging is restricted to that section using `-x` and `+x`.
  prefs: []
  type: TYPE_NORMAL
- en: The above debugging methods are provided by bash built-ins. But they always
    produce debugging information in a fixed format. In many cases, we need debugging
    information in our own format. We can set up such a debugging style by passing
    the `_DEBUG` environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run the above script with debugging set to "on" as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: We prefix `DEBUG` before every statement where debug information is to be printed.
    If `_DEBUG=on` is not passed to script, debug information will not be printed.
    In Bash the command ':' tells the shell to do nothing.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can also use other convenient ways to debug scripts. We can make use of shebang
    in a trickier way to debug scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Shebang hack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The shebang can be changed from `#!/bin/bash` to `#!/bin/bash –xv` to enable
    debugging without any additional flags (`-xv` flags themselves).
  prefs: []
  type: TYPE_NORMAL
- en: Functions and arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like any other scripting languages, Bash also supports functions. Let's see
    how to define and use functions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A function can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Or alternately,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'A function can be invoked just by using its name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Arguments can be passed to functions and can be accessed by our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Following is the definition of the function `fname`. In the `fname` function,
    we have included various ways of accessing the function arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, arguments can be passed to scripts and can be accessed by `script:$0`
    (the name of the script):'
  prefs: []
  type: TYPE_NORMAL
- en: '`$1` is the first argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$2` is the second argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$n` is the nth argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"$@"` expands as `"$1" "$2" "$3"` and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"$*"` expands as `"$1c$2c$3"`, where `c` is the first character of IFS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"$@"` is the most used one. `"$*"` is used rarely since it gives all arguments
    as a single string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's explore more tips on Bash functions.
  prefs: []
  type: TYPE_NORMAL
- en: Recursive function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functions in Bash also support recursion (the function that can call itself).
    For example, `F() { echo $1; F hello; sleep 1; }`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Fork bomb**'
  prefs: []
  type: TYPE_NORMAL
- en: ':(){ :|:& };:'
  prefs: []
  type: TYPE_NORMAL
- en: This recursive function is a function that calls itself. It infinitely spawns
    processes and ends up in a denial of service attack. `&` is postfixed with the
    function call to bring the subprocess into the background. This is a dangerous
    code as it forks processes and, therefore, it is called a fork bomb.
  prefs: []
  type: TYPE_NORMAL
- en: You may find it difficult to interpret the above code. See Wikipedia page [http://en.wikipedia.org/wiki/Fork_bomb](http://en.wikipedia.org/wiki/Fork_bomb)
    for more details and interpretation of the fork bomb.
  prefs: []
  type: TYPE_NORMAL
- en: It can be prevented by restricting the maximum number of processes that can
    be spawned from the config file `/etc/security/limits.conf`.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A function can be exported like environment variables using `export` such that
    the scope of the function can be extended to subprocesses, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Reading command return value (status)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can get the return value of a command or function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '`$?` will give the return value of the command `cmd`.'
  prefs: []
  type: TYPE_NORMAL
- en: The return value is called exit status. It can be used to analyze whether a
    command completed its execution successfully or unsuccessfully. If the command
    exits successfully, the exit status will be zero, else it will be non-zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check whether a command terminated successfully or not as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Passing arguments to commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Arguments to commands can be passed in different formats. Suppose `–p` and
    `-v` are the options available and `-k NO` is another option that takes a number.
    Also the command takes a filename as argument. It can be executed in multiple
    ways as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: Reading the output of a sequence of commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the best-designed features of shell scripting is the ease of combining
    many commands or utilities to produce output. The output of one command can appear
    as the input of another, which passes its output to another command, and so on.
    The output of this combination can be read in a variable. This recipe illustrates
    how to combine multiple commands and how its output can be read.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Input is usually fed into a command through `stdin` or arguments. Output appears
    as `stderr` or `stdout`. While we combine multiple commands, we usually use `stdin`
    to give input and `stdout` for output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Commands are called as filters. We connect each filter using pipes. The piping
    operator is "`|`". An example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Here we combine three commands. The output of `cmd1` goes to `cmd2` and output
    of `cmd2` goes to `cmd3` and the final output (which comes out of `cmd3`) will
    be printed or it can be directed to a file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Here the output of `ls` (the listing of the current directory) is passed to
    `cat -n`. `cat –n` puts line numbers to the input received through `stdin`. Therefore,
    its output is redirected to the `out.txt` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can read the output of a sequence of commands combined by pipes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'This is called the subshell method. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'Another method, called back-quotes can also be used to store the command output
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: Back quote is different from the single quote character. It is the character
    on the *~* button in the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are multiple ways of grouping commands. Let's go through few of them.
  prefs: []
  type: TYPE_NORMAL
- en: Spawning a separate process with subshell
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Subshells are separate processes. A subshell can be defined using the `( )`operators
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: When some commands are executed in a subshell none of the changes occur in the
    current shell; changes are restricted to the subshell. For example, when the current
    directory in a subshell is changed using the `cd` command, the directory change
    is not reflected in the main shell environment.
  prefs: []
  type: TYPE_NORMAL
- en: The `pwd` command prints the path of the working directory.
  prefs: []
  type: TYPE_NORMAL
- en: The `cd` command changes the current directory to the given directory path.
  prefs: []
  type: TYPE_NORMAL
- en: Subshell quoting to preserve spacing and newline character
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Suppose we are reading the output of a command to a variable using a subshell
    or the back-quotes method, we always quote them in double-quotes to preserve the
    spacing and newline character (\n). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: Reading "n" characters without pressing Return
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`read` is an important Bash command that can be used to read text from keyboard
    or standard input. We can use `read` to interactively read an input from the user,
    but `read` is capable of much more. Let''s look at a new recipe to illustrate
    some of the most important options available with the `read` command.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the input libraries in any programming language read the input from
    the keyboard; but string input termination is done when *Return* is pressed. There
    are certain critical situations when *Return* cannot be pressed, but the termination
    is done based on number of characters or a single character. For example, in a
    game a ball is moved up when up + is pressed. Pressing `+` and then pressing *Return*
    everytime to acknowledge the + press is not efficient. The read command provides
    a way to accomplish this task without having to press *Return*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following statement will read "n" characters from input into the variable
    `variable_name`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`read -n number_of_chars variable_name`'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Many other options are possible with `read`. Let's see take a look at these.
  prefs: []
  type: TYPE_NORMAL
- en: 'Read a password in non-echoed mode as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Display a message with `read` using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'Read the input after a timeout as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'Use a delimiter character to end the input line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: Field separators and iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Internal Field Separator is an important concept in shell scripting. It
    is very useful while manipulating text data. We will now discuss delimiters that
    separate different data elements from single data stream. An Internal Field Separator
    is a delimiter for a special purpose. An **Internal Field Separator** (**IFS**)
    is an environment variable that stores delimiting characters. It is the default
    delimiter string used by a running shell environment.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the case where we need to iterate through words in a string or **comma
    separated values** (**CSV**). In the first case we will use `IFS=" "` and in the
    second,`IFS=","`. Let's see how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the case of CSV data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: The default value of IFS is a space component (newline, tab, or a space character).
  prefs: []
  type: TYPE_NORMAL
- en: When IFS is set as "," the shell interprets the comma as a delimiter character,
    therefore, the `$item` variable takes substrings separated by a comma as its value
    during the iteration.
  prefs: []
  type: TYPE_NORMAL
- en: If IFS were not set as "`,`" then it would print the entire data as a single
    string.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's go through another example usage of IFS by taking `/etc/passwd` file into
    consideration. In the `/etc/passwd` file, every line contains items delimited
    by `":"`. Each line in the file corresponds to an attribute related to a user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the input:`root:x:0:0:root:/root:/bin/bash`. The last entry on each
    line specifies the default shell for the user. In order to print users and their
    default shells, we can use the IFS hack as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: Loops are very useful in iterating through a sequence of values. Bash provides
    many types of loops. Let's see how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: '**For loop**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: We can generate different sequences easily.
  prefs: []
  type: TYPE_NORMAL
- en: '`echo {1..50}`can generate a list of numbers from 1 to 50'
  prefs: []
  type: TYPE_NORMAL
- en: '`echo {a..z}`or`{A..Z}` or we can generate partial list using `{a..h}`. Similarly,
    by combining these we can concatenate data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, in each iteration, the variable `i` will hold a character
    in the range `a` to `z`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'The `for` loop can also take the format of the `for` loop in C. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '**While loop**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: For an infinite loop, use `true` as the condition.
  prefs: []
  type: TYPE_NORMAL
- en: '**Until loop**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A special loop called `until` is available with Bash. This executes the loop
    until the given condition becomes true. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: Comparisons and tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flow control in a program is handled by comparison and test statements. Bash
    also comes with several options to perform tests that are compatible with the
    UNIX system-level features.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use `if`, `if else`, and logical operators to perform tests and certain
    comparison operators to compare data items. There is also a command called `test`
    available to perform tests. Let's see how to use those commands.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'else if and else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'Nesting is also possible with if and else. `if` conditions can be lengthy.
    We can use logical operators to make them shorter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '`&&` is the logical AND operation and `||` is the logical OR operation. This
    is a very helpful trick while writing Bash scripts. Now let''s go into conditions
    and comparisons operations.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mathematical comparisons**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, conditions are enclosed in square brackets `[]`. Note that there is
    a space between `[` or `]` and operands. It will show an error if no space is
    provided. An example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'Performing mathematical conditions over variables or values can be done as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'Other important operators are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-gt`: Greater than'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-lt`: Less than'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-ge`: Greater than or equal to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-le`: Less than or equal to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Multiple test conditions can be combined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '**Filesystem related tests**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test different filesystem related attributes using different condition
    flags as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[ -f $file_var ]`: Returns true if the given variable holds a regular filepath
    or filename.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[ -x $var ]`: Returns true if the given variable holds a file path or filename
    which is executable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[ -d $var ]`: Returns true if the given variable holds a directory path or
    directory name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[ -e $var ]`: Returns true if the given variable holds an existing file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[ -c $var ]`: Returns true if the given variable holds path of a character
    device file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[ -b $var ]`: Returns true if the given variable holds path of a block device
    file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[ -w $var ]`: Returns true if the given variable holds path of a file which
    is writable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[ -r $var ]`: Returns true if the given variable holds path of a file which
    is readable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[ -L $var ]`: Returns true if the given variable holds path of a symlink.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example of the usage is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '**String comparisons**:'
  prefs: []
  type: TYPE_NORMAL
- en: While using string comparison, it is best to use double square brackets since
    use of single brackets can sometimes lead to errors. Usage of single brackets
    sometimes lead to error. So it is better to avoid them.
  prefs: []
  type: TYPE_NORMAL
- en: Two strings can be compared to check whether they are the same as follows;
  prefs: []
  type: TYPE_NORMAL
- en: '`[[ $str1 = $str2 ]]`: Returns true when str1 equals str2, that is, the text
    contents of str1 and str2 are the same'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[[ $str1 == $str2 ]]`: It is alternative method for string equality check'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can check whether two strings are not the same as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[[ $str1 != $str2 ]]`: Returns true when str1 and str2 mismatches'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can find out the alphabetically smaller or larger string as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[[ $str1 > $str2 ]]`: Returns true when str1 is alphabetically greater than
    str2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[[ $str1 < $str2 ]]`: Returns true when str1 is alphabetically lesser than
    str2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that a space is provided after and before `=`. If space is not provided,
    it is not a comparison, but it becomes an assignment statement.
  prefs: []
  type: TYPE_NORMAL
- en: '`[[ -z $str1 ]]`: Returns true if str1 holds an empty string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[[ -n $str1 ]]`: Returns true if str1 holds a non-empty string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is easier to combine multiple conditions using the logical operators `&&`
    and `||` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: The `test` command can be used for performing condition checks. It helps to
    avoid usage of many braces. The same set of test conditions enclosed within `[]`
    can be used for the test command.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
