- en: Measuring Distance and Detecting Movement
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: Welcome to our final core electronics-based chapter. In the previous chapter,
    we learned how to control three different forms of motors in complex ways. In
    this chapter, we will direct our attention to detecting movement and measuring
    the distance with our Raspberry Pi and electronics.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Detecting movement is very useful for automation projects such as turning on
    lights when you walk into a room or building, an alarm system, building counters,
    or detecting revolutions of a shaft. We will be looking at two techniques for
    movement detection, including a **Passive Infrared** (**PIR**) sensor that uses
    heat detection to detect the presence of a person (or animal), and a digital Hall-effect
    sensor that detects the presence of a magnetic field (or, more liberally, we can
    say that the Hall-effect sensor can detect when a magnet moves past it).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Distance measurement is also useful for many projects, from collision detection
    circuits to measuring water tank levels. We will be looking at two forms of distance
    measurement, including the use of an ultrasonic sound sensor that can measure
    distances of around 2 centimeters to 4 meters, and also an analog Hall-effect
    sensor that can measure the proximity of a magnetic field down to millimeters.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what we will cover in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Detecting movement with a PIR sensor
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measuring distance with an ultrasonic sensor
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting movement and distance with Hall-effect sensors
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To perform the exercises in this chapter, you will need the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi 4 Model B
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raspbian OS Buster (with desktop and recommended software)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimum Python version 3.5
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These requirements are what the code examples in this book are based on. It's
    reasonable to expect that the code examples should work without modification on
    Raspberry Pi 3 Model B or a different version of Raspbian OS as long as your Python
    version is 3.5 or higher.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: You will find this chapter's source code in the `chapter11` folder in the GitHub
    repository available at [https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT](https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to execute the following commands in a terminal to set up a virtual
    environment and install the Python libraries required for the code in this chapter:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following dependencies are installed from `requirements.txt`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '**PiGPIO**: The PiGPIO GPIO library ([https://pypi.org/project/pigpio](https://pypi.org/project/pigpio))'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ADS1X15**: The ADS11x5 ADC library ([https://pypi.org/project/adafruit-circuitpython-ads1x15](https://pypi.org/project/adafruit-circuitpython-ads1x15))'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The electronic components we will need for this chapter''s exercises are as
    follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 1 x 1kΩ resistor
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x 2kΩ resistor
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x HC-SR501 PIR sensor (datasheet: [https://www.alldatasheet.com/datasheet-pdf/pdf/1131987/ETC2/HC-SR501.html](https://www.alldatasheet.com/datasheet-pdf/pdf/1131987/ETC2/HC-SR501.html))
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x A3144 Hall-effect sensor (non-latching) (datasheet: [https://www.alldatasheet.com/datasheet-pdf/pdf/55092/ALLEGRO/A3144.html](https://www.alldatasheet.com/datasheet-pdf/pdf/55092/ALLEGRO/A3144.html))
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x AH3503 Hall-effect sensor (ratiometric) (datasheet: [https://www.alldatasheet.com/datasheet-pdf/pdf/1132644/AHNJ/AH3503.html](https://www.alldatasheet.com/datasheet-pdf/pdf/1132644/AHNJ/AH3503.html))
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x HC-SR04 or HC-SR04P ultrasonic distance sensor (datasheet: [https://tinyurl.com/HCSR04DS](https://tinyurl.com/HCSR04DS))
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A small magnet for use with the Hall-effect sensors
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are two variations of the HC-SR04 available. The more common HC-SR04,
    which outputs 5-volt logic and the HC-SR04**P**, which can operate at between
    3 volts and 5.5 volts. Either module will be suitable for the exercise in this
    chapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Detecting movement with a PIR sensor
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A PIR sensor is a device that can detect infrared light (heat) emitted by an
    object (for example, a person). We see these types of sensors all around us in
    applications such as security systems and automatic doors and lights that react
    to our presence. The *passive* in PIR means the sensor just detects movement.
    To detect *what* moved and *how*, you would need an active infrared device, such
    as a thermal camera.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: PIR sensors come in a few different forms and varieties; however, their basic
    usage is the same – they act as a simple digital switch. When they do not detect
    movement, they output a digital `LOW`, and when movement is detected, they output
    a digital `HIGH`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'Shown in the following figure is the HC-SR501 PIR sensor module that we will
    be using for our example. Pictured are the top of the module, the underside, and
    a common schematic symbol for a PIR sensor:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/15a71ea4-9918-4be8-a0fc-27240f8add81.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – HC-SR501 PIR sensor module
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Some PIR sensors, including our HC-SR501, have an onboard setting and calibration
    adjustments on them. These adjustments are used to change the sensitivity range
    and triggering mode of the sensor. To use a PIR device without on-board calibration
    means we would need to handle sensitivity adjustments ourselves in code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'In regard to the HC-SR501, its terminals are as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '**GND**: Connection to ground.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vcc**: Connection to a power source between 5 volts and 20 volts.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data**: Digital output that we connect to a GPIO pin. When the PIR detects
    movement, this pin goes `HIGH`; otherwise, it remains `LOW` in the absence of
    movement. The HC-SR501 outputs a 3.3-volt signal, even though it requires a 5-
    to 20-volt power source. As we will see next, the onboard *sensitivity adjust*, *timing
    adjust* trims, and *trigger mode* jumper influence how, when, and for how long
    this data pin remains `HIGH` when movement is detected.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The HC-SR501 onboard settings are as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '**Sensitivity Adjust**: Changes the effective movement sensing range between
    about 3 meters to about 7 meters. Use a small screwdriver to rotate this setting''s
    dial.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Time Delay Adjust**: How long the data terminal remains `HIGH` after movement
    is detected. The adjustment range is approximately 5 seconds to 300 seconds. Use
    a small screwdriver to rotate this setting''s dial.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Trigger Mode Jumper**: In the presence of continued movement detection, this
    jumper setting means that after the time delay expires (as set by **Time Delay
    Adjust**), the data terminal will do the following:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remain `HIGH`. This is the *repeatable* trigger setting, set by placing the
    jumper into the **H** position.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revert to `LOW`. This is the *single-shot* setting, set by placing the jumper
    into the **L** position.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The best settings for your PIR will depend on how you intend to use it and the
    environment in which you deploy your sensor. My suggestion is to play around with
    the setting adjustments after you complete the circuit build and run the example
    code in the subsequent sections to get a feel for how changing the settings affects
    the operation of the sensor. Remember to consult the HC-SR501 datasheet for more
    information on the sensor and its onboard settings.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Let's wire up our PIR sensor and connect it to our Raspberry Pi.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Creating the PIR sensor circuit
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will connect our PIR sensor to our Raspberry Pi. The following
    is the schematic diagram of the circuit we are about to build. As you can see,
    it has relatively straightforward wiring from the perspective of the PIR sensor:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a71c4b1a-0925-4a7a-871b-16feb2158fa8.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – PIR sensor module circuit
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s connect it to our Raspberry Pi as illustrated in the following figure:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2ed19997-c875-442a-97a5-377aac349c70.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – PIR sensor circuit breadboard layout
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to follow to create your breadboard build. The step numbers
    match the numbers in black circles in *Figure 11.3*:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Connect each terminal of your PIR sensor to your breadboard. You will need three
    male-to-male jumper cables.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的PIR传感器的每个端子连接到面包板上。您将需要三根公对公跳线。
- en: Connect a 5-volt pin on your Raspberry Pi to the same breadboard row used by
    the PIR's Vcc terminal. PIR sensors only use a little current, so it will be okay
    to connect the 5-volt Vcc pin directly to your Raspberry Pi.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将树莓派上的5伏特引脚连接到PIR的Vcc端使用的面包板行。PIR传感器只使用少量电流，因此将5伏特Vcc引脚直接连接到树莓派上是可以的。
- en: Connect a GND pin on your Raspberry Pi to the same breadboard row used by the
    PIR's GND terminal.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将树莓派上的GND引脚连接到PIR的GND端使用的面包板行。
- en: Connect GPIO 21 on your Raspberry Pi to the same breadboard row used by the
    PIR's data terminal.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将树莓派上的GPIO 21引脚连接到PIR的数据端使用的面包板行。
- en: '**IMPORTANT**: Our reference HC-SR501 PIR sensor requires >4.5 volts for its
    power (Vcc), and outputs 3.3 volts on its Sig output pin. If you are using a different
    PIR sensor, then consult its datasheet and check the output pin voltage. If it
    is >3.3 volts, you will need to use a voltage divider or logic level shifter.
    We will cover this exact scenario in the next section when we couple a voltage
    divider with an HC-SR04 sensor to convert its 5-volt output into a Raspberry Pi-friendly
    3.3 volts.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**：我们参考的HC-SR501 PIR传感器需要>4.5伏特的电源（Vcc），并在其Sig输出引脚上输出3.3伏特。如果您使用的是不同的PIR传感器，请查阅其数据表并检查输出引脚电压。如果它大于3.3伏特，您将需要使用电压分压器或逻辑电平转换器。在下一节中，我们将涵盖这种确切的情况，当我们将电压分压器与HC-SR04传感器配对，将其5伏特输出转换为树莓派友好的3.3伏特。'
- en: Once you have created your circuit, we will proceed and run our PIR example
    code, which will let us detect movement.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 创建电路后，我们将继续并运行我们的PIR示例代码，这将让我们检测运动。
- en: Running and exploring the PIR sensor code
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行和探索PIR传感器代码
- en: The code for out PIR circuit is found in the `chapter11/hc-sr501.py` file. Please
    review the source code before proceeding to get a broad understanding of what
    this file contains.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的PIR电路代码可以在`chapter11/hc-sr501.py`文件中找到。在继续之前，请查看源代码，以对该文件的内容有一个广泛的了解。
- en: The HC-SR501 datasheet stipulates that the sensor needs around 1 minute after
    power-on to initialize and stabilize itself. If you try and use the sensor before
    it becomes stable, you may receive a few erroneous triggers when you start the
    program.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: HC-SR501数据表规定，传感器在上电后需要大约1分钟的时间来初始化和稳定自身。如果在传感器变得稳定之前尝试使用传感器，可能会在启动程序时收到一些错误的触发。
- en: 'Run the `hc-sr501.py` file in a terminal. When the HC-SR501 detects movement,
    the program will print `Triggered` on the terminal, or `Not Triggered` when no
    movement is detected, as shown in the following output:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中运行`hc-sr501.py`文件。当HC-SR501检测到运动时，程序将在终端上打印`Triggered`，或者在未检测到运动时打印`Not
    Triggered`，如下所示：
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If your program is not responding as expected, try adjusting one or more of
    the **Sensitivity Adjustment**, **Time Delay Adjustment**, or **Trigger Mode Jumper**
    settings that we discussed earlier in the section titled *Detecting movement with
    a PIR sensor*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的程序没有按预期响应，请尝试调整我们之前在*使用PIR传感器检测运动*部分中讨论的**灵敏度调整**、**时间延迟调整**或**触发模式跳线**设置中的一个或多个。
- en: You can consider the HC-SR501 as a basic switch. It's either on (`HIGH`) or
    off (`LOW`), just like a common push-button switch. In fact, our code is similar to
    the PiGPIO button example presented in the *Responding to a button press with
    PiGPIO* section back in [Chapter 2](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml),* Getting
    Started with Python and IoT*. We'll just brush over the core code parts here;
    however, if you need a deeper explanation or a refresher, please revisit the PiGPIO
    sections in [Chapter 2](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml), *Getting
    Started with Python and IoT.*
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将HC-SR501视为基本开关。它要么是打开的（`HIGH`），要么是关闭的（`LOW`），就像普通的按钮开关一样。实际上，我们的代码类似于[第2章](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml)中*使用Python和物联网入门*部分中介绍的PiGPIO按钮示例。我们只会在这里简要介绍核心代码部分；但是，如果您需要更深入的解释或复习，请重新查看[第2章](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml)中的PiGPIO部分，*使用Python和物联网入门*。
- en: 'Let''s discuss the example code. Firstly, we start on line 1 by setting up
    our GPIO pin as an input pin with pull-down enabled, while on line 2, we have
    debouncing enabled. Our HC-SR501 module won''t actually require the pull-down
    to be activated in code, nor will it require the debouncing; however, I''ve added
    it in for completeness:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论示例代码。首先，我们在第1行开始设置我们的GPIO引脚为带有下拉使能的输入引脚，而在第2行，我们启用了去抖动。我们的HC-SR501模块实际上不需要在代码中激活下拉，也不需要去抖动；但是，我为了完整性而添加了它：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, on line 3, we define the `callback_handler()` function, which will get
    called whenever the GPIO pin changes its `HIGH`/`LOW` state:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在第3行，我们定义了`callback_handler()`函数，每当GPIO引脚改变其`HIGH`/`LOW`状态时都会被调用：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, on line 4, we register our callback function. It''s the second parameter,
    `pigpio.EITHER_EDGE`, that causes `callback_handler()` to be called whenever GPIO
    changes to `HIGH` or `LOW`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第4行，我们注册了回调函数。正是第二个参数`pigpio.EITHER_EDGE`导致`callback_handler()`在GPIO变为`HIGH`或`LOW`时被调用：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For comparison, in [Chapter 2](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml),
    *Getting Started with Python and IoT*, for our push-button example, this parameter
    was `pigpio.FALLING_EDGE`, meaning the callback only got called when the button
    was pressed, and not when it was released.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对比，在[第2章](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml)中，*使用Python和物联网入门*，对于我们的按钮示例，此参数为`pigpio.FALLING_EDGE`，意味着只有在按下按钮时才会调用回调，而松开按钮时不会调用。
- en: As we have seen, a PIR sensor can only detect the proximity of an object – for
    example, is someone near our sensor? – but it cannot give us an indication of
    how far or near that object is.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，PIR传感器只能检测物体的接近 - 例如，有人靠近我们的传感器吗？ - 但它无法告诉我们物体的距离有多远或多近。
- en: We've now learned how to create and connect a simple PIR sensor circuit to our
    Raspberry Pi, and how to use it to detect movement in Python. Armed with this
    knowledge, you can now start building your own motion detection projects, such
    as turning things on and off when someone or some animal is detected, by combining
    the examples from [Chapter 7](36313176-0d8b-4a0e-916a-7d4ffd58305a.xhtml), *Turning
    Things On and Off,* or as an important part of your own alarm and monitoring system.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学会了如何创建和连接一个简单的PIR传感器电路到我们的树莓派，并且学会了如何在Python中使用它来检测运动。有了这些知识，你现在可以开始构建自己的运动检测项目，比如结合[第7章](36313176-0d8b-4a0e-916a-7d4ffd58305a.xhtml)中的示例，*打开和关闭东西*，或者作为你自己的警报和监控系统的重要部分。
- en: Next, we will look at a sensor that is capable of estimating distance.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一下能够估算距离的传感器。
- en: Measuring distance with an ultrasonic sensor
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用超声波传感器测量距离
- en: In the previous section, we learned how to detect movement with a PIR sensor.
    As we discovered, our PIR sensor was a digital device that signaled movement detection
    by making its output a digital `HIGH`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学会了如何使用PIR传感器检测运动。正如我们发现的那样，我们的PIR传感器是一个数字设备，通过使其输出为数字`HIGH`来表示检测到运动。
- en: 'It''s time to learn how to measure distance with our Raspberry Pi. There are
    a variety of sensors that are capable of performing this task, and they commonly
    either work with sound or light. Our example will be based around the popular HC-SR04
    ultrasonic distance sensor (it works on sound), as pictured in the following figure:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候学习如何用树莓派测量距离了。有各种各样的传感器可以执行这项任务，它们通常要么使用声音，要么使用光。我们的示例将基于流行的HC-SR04超声波距离传感器（它使用声音），如下图所示：
- en: '![](assets/dde3ee8c-3469-4a0d-824d-8b6fa7984f25.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dde3ee8c-3469-4a0d-824d-8b6fa7984f25.png)'
- en: Figure 11.4 – HC-SR04 ultrasonic distance sensor module
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 - HC-SR04超声波距离传感器模块
- en: A place where you commonly find ultrasonic distance sensors is modern car bumper
    bars (they're often little round circles, which is a different form factor than
    the HC-SR04 pictured in the preceding figure). These sensors calculate the distance
    between your car and a nearby object and, for example, make a beeper inside your
    car beep faster and faster as you get closer and closer to the object
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常会在现代汽车保险杠上找到超声波距离传感器（它们通常是小圆圈，这是与前面图中的HC-SR04不同的形状）。这些传感器计算你的车和附近物体之间的距离，例如，当你越来越接近物体时，会让车内的蜂鸣器越来越快地响起。
- en: Another common application is for measuring liquid levels, such as in a water
    tank. In this scenario, a (waterproof) ultrasonic sensor measures the distance
    from, for example, the top of the tank to the water level (the sound pulse bounces
    off the water). The measured distance can then be translated into an estimate
    of how full the tank is.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的应用是用于测量液体水平，比如水箱中的水位。在这种情况下，（防水）超声波传感器测量从水箱顶部到水位的距离（声音脉冲反射在水上）。然后可以将测得的距离转换为水箱的大致容量。
- en: 'Let''s take a closer look at our HC-SR04 sensor. The core specifications from
    the reference HC-SR04 datasheet are as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下我们的HC-SR04传感器。参考HC-SR04数据表中的核心规格如下：
- en: Power voltage 5 volts (HC-SR04) or 3 volts to 5.5 volts (HC-SR04P)
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电源电压5伏（HC-SR04）或3伏至5.5伏（HC-SR04P）
- en: Logic voltage 5 volts (HC-SR04) or 3 volts to 5.5 volts (HC-SR04P)
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑电压5伏（HC-SR04）或3伏至5.5伏（HC-SR04P）
- en: Working current 15 mA, resting current 2 mA
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作电流15毫安，静态电流2毫安
- en: Effective measurement range 2 cm–4 m, with an accuracy of +/- 0.3 cm
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效测量范围为2厘米至4米，精度为+/- 0.3厘米
- en: A trigger pulse width of 10 µs (10 microseconds). We'll revisit this pulse width
    and discuss it more in the section titled *HC-SR04 distance measurement process*.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10微秒的触发脉冲宽度。我们将在标题为*HC-SR04距离测量过程*的部分重新讨论这个脉冲宽度并进行更多讨论。
- en: 'The SC-SR04 has two round cylinders. They are as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: SC-SR04有两个圆柱体。它们如下：
- en: '**T** or **TX**: A transmitter that produces ultrasonic sound pulses'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**T**或**TX**：产生超声波脉冲的发射器'
- en: '**R** or **RX**: A receiver that detects ultrasonic sound pulses'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**R**或**RX**：检测超声波脉冲的接收器'
- en: We will discuss how the transmitter and receiver pair work to measure distance
    in the next section.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节讨论发射器和接收器如何一起工作来测量距离。
- en: 'The HC-SR04 has four terminals, which are as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: HC-SR04有四个端子，它们如下：
- en: '**Vcc**: The power source (a Raspberry Pi 5-volt pin will be okay given the
    max current of 15 mA).'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Vcc**：电源（树莓派5伏引脚将是可以的，考虑到最大电流为15毫安）。'
- en: '**GND**: Connection to ground.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GND**：接地连接。'
- en: '**TRIG**: Trigger *input* terminal – when `HIGH`, the sensor sends out ultrasonic
    pulses.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TRIG**：触发*输入*端子 - 当`HIGH`时，传感器发送超声波脉冲。'
- en: '**ECHO**: Echo *output* terminal – this pin goes `HIGH` when `TRIG` is made
    `HIGH`, then transitions to `LOW` when it detects an ultrasonic pulse.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ECHO**：回声*输出*端子 - 当`TRIG`变为`HIGH`时，此引脚变为`HIGH`，然后在检测到超声脉冲时变为`LOW`。'
- en: We will discuss the use of the `TRIG` and `ECHO` terminals in the section titled *HC-SR04
    distance measurement process.*
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在标题为*HC-SR04距离测量过程*的部分讨论`TRIG`和`ECHO`端子的使用。
- en: Now that we understand the basic use of an ultrasonic distance sensor and the
    basic properties and layout of the HC-SR04, let's discuss how it works.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了超声波距离传感器的基本用法和HC-SR04的基本特性和布局，让我们讨论一下它是如何工作的。
- en: How an ultrasonic distance sensor works
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超声波距离传感器的工作原理
- en: 'Let''s see how the transmitter (TX) and receiver (RX) work together to measure
    distance. The basic operating principle of an ultrasonic sensor is illustrated
    in the following figure:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看发射器（TX）和接收器（RX）如何一起工作来测量距离。超声波传感器的基本工作原理如下图所示：
- en: '![](assets/04fb297a-ba3e-4828-bef7-85587791b615.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/04fb297a-ba3e-4828-bef7-85587791b615.png)'
- en: Figure 11.5 – Ultrasonic distance sensor operation
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 - 超声波距离传感器操作
- en: 'Here is what happens:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是发生的事情：
- en: First, the sensor sends out an ultrasonic pulse from the transmitter (TX).
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，传感器从发射器（TX）发送超声波脉冲。
- en: If there is an object in front of the sensor, this pulse is bounced off the
    object and returns to the sensor, and is detected by the receiver (RX).
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By measuring the time between transmitting a pulse and receiving it back, we
    can calculate the distance between the sensor and the object.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this high-level understanding of how the sensor works, next, we will go
    deeper and discuss how to use the TRIG and ECHO terminals on the HC-SR04 together
    in a process to estimate distance.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: HC-SR04 distance measurement process
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will cover the process used to measure distance with the
    HC-SR04\. Don't get concerned if this does not make immediately sense. I've provided
    the details here as background material, as this is the logical process that is
    implemented by our example program to make the sensor work. You will also find
    the process documented in the sensor's datasheet.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'We measure distance with the HC-SR04 through the correct use and monitoring
    of the TRIG and ECHO pins. The process looks like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Pull the TRIG pin `HIGH` for 10 microseconds. Pulling TRIG `HIGH` also makes
    the ECHO pin `HIGH`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start a timer.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Wait for either of the following to happen:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ECHO to go `LOW`
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 38 milliseconds to elapse (from the datasheet, this is the time for >4 meters)
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stop the timer.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If 38 milliseconds have passed, we conclude that there is no object in front
    of the sensor (at least within the effective range of 2 centimeters to 4 meters). Otherwise,
    we take the elapsed time divided by 2 (because we want the time interval between
    the sensor and the object, not the sensor to the object and back to the sensor),
    and then using basic physics, calculate the distance between the sensor and the
    object using the following formula:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8e34f8a8-c9d8-4330-ad69-d2bd3f0a2338.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: 'Here, we have the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '*d* is the distance in meters.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*v* is the velocity in meters per second, for which we use the speed of sound,
    which is approximately 343 meters per second at 20°C (68°F).'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*t* is the time in seconds.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The HC-SR04 will only estimate distance. There are several parameters that influence
    its accuracy. Firstly, as hinted previously, the speed of sound varies in accordance
    with temperature. Secondly, the sensor has a resolution of ± 0.3 cm. Furthermore,
    the size of the object being measured, the angle of the object relative to the
    sensor, and even the material it is made of can all impact the ECHO timing result
    and thus the calculated distance.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: With this basic understanding of how to use the HC-SR04 to estimate distance,
    let's build our circuit to connect an HC-SR04 to our Raspberry Pi.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Building the HC-SR04 circuit
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s time to build our HC-SR04 circuit. A schematic of our circuit is shown
    in the following figure. This wiring will be suitable for both an HC-SR04 or HC-SR04P
    module:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/03adb9b5-5121-4443-b68d-1260bd41e2f0.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – HC-SR04 (5-volt logic ECHO pin) circuit
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder, the HC-SR04 module (or an HC-SR04P wired like this to a 5-volt
    source) is a 5-volt logic module, and hence you will notice the voltage divider
    in the circuit created by the two resistors to convert 5 volts into 3.3 volts.
    If you need a refresher on voltage dividers, we covered them in detail in [Chapter
    6](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml),* Electronics 101 for the Software
    Engineer*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build this circuit on our breadboard:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d7c2f5d8-4f07-4387-a2d7-ac26fbce53f5.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
- en: Figure 11.7 – HC-SR04 circuit breadboard layout (part 1 of 2)
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to follow to create the first part of your breadboard build.
    The step numbers match the numbers in black circles in *Figure 11.7*:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Place a 1kΩ resistor (R1) into your breadboard.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a 2kΩ resistor (R2) into your breadboard. A leg of this second resistor
    shares the same row as a leg of the first resistor. In the illustration, this
    can be seen in row 21 on the right-hand side bank.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the left-hand side and right-hand side negative power rails together.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect a GND pin on your Raspberry Pi to the negative rail of the left-hand
    side power rail.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the second leg 2kΩ resistor (R2) to the negative rail of the right-hand
    side power rail.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the GND terminal on your HC-SR04 sensor to the negative rail of the
    right-hand side power rail.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the Vcc terminal on your HC-SR04 sensor to the positive rail of the
    right-hand side power rail.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the R1 and R2 resistors are connected as shown in the preceding figure
    – that is, R1 (1kΩ) is connected to the ECHO pin on the HC-SR04\. The voltage
    divider created by R1 and R2 shifts an ECHO pin `HIGH` of 5 volts into ~3.3 volts.
    If you installed the resistors back to front, the 5 volts get shifted to ~1.67
    volts, which is not enough to register a logic `HIGH` on your Raspberry Pi.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have laid out our basic components and performed a few preliminary
    wiring connections, let''s complete our build:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e2285741-5fdb-4ed7-ad55-da4add757bc9.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
- en: Figure 11.8 – HC-SR04 circuit breadboard layout (part 2 of 2)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to follow. The step numbers match the numbers in black circles
    in *Figure 11.8*:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Connect GPIO 20 on your Raspberry Pi to the Trig terminal on your HC-SR04 sensor.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect GPIO 21 on your Raspberry Pi to the junction of the 1kΩ (R1) and 2kΩ
    (R2) resistors. This connection is shown in the illustration at hole F21.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the Echo terminal of your HC-SR04 sensor to the 1kΩ resistor (R1). This
    connection is shown at hole J17.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the positive terminal of a 5-volt power source to the positive rail
    of the right-hand side power rail.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the negative terminal of a 5-volt power source to the negative rail
    of the right-hand side power rail.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As mentioned, our circuit build will work with both the HC-SR04 and HC-SR04P
    modules. If you do have the HC-SR04P module, there is a simpler wiring option
    available to you that you may like to try on your own. Since the HC-SR04P will
    work at 3.3 volts, here is what you can do:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Connect Vcc to a 3.3-volt power source or a 3.3-volt pin on your Raspberry Pi.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connect the ECHO terminal directly to GPIO 21.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GND still connects to GND, and TRIG still connects directly to GPIO 20.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since this configuration is powered at 3.3 volts, the logic output on the ECHO
    terminal is also 3.3 volts and is therefore safe to connect directly to a Raspberry
    Pi GPIO pin.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Great! Now that our circuit is complete, next we will run our example program
    and use the HC-SR04 to measure distance and learn about the code that makes this
    happen.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Running and exploring the HC-SR04 example code
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example code for the HC-SR04 can be found in the `chapter11/hc-sr04.py` file.
    Please review the source code before proceeding to get a broad understanding of
    what this file contains.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Place a solid object in front of the HC-SR04 (about 10 cm) and run the code
    in a terminal. As you move the object nearer or further from the sensor, the distance
    printed in the terminal will change, as indicated here:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let's review the code.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we define the `TRIG_GPIO` and `ECHO_GPIO` pins on line 1, and the `VELOCITY`
    constant for the speed of sound at line 2\. We're using 343 meters per second.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Our code is using 343 m/s for the speed of sound, while the datasheet suggests
    the value 340 m/s. You will also find other HC-SR04 examples and libraries that
    use slightly different values. These differences are one reason why different
    code samples and libraries may produce slightly different readings for the same
    sensor-to-object distance.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'On line 3, we define `TIMEOUT_SECS = 0.1`. The value of `0.1` is a number greater
    than 38 milliseconds (from the datasheet). Any time greater than this and we conclude
    that there is no object in front of our HC-SR04 sensor and return the `SENSOR_TIMEOUT` value, rather
    than a distance in the `get_distance_cms()` function, which we will come to shortly:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, starting on line 4, we find several variables used to help measure the
    timing of the sensor''s ultrasonic pulse and if we have a successful reading:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从第4行开始，我们找到了几个变量，用于帮助测量传感器超声脉冲的时间以及我们是否有一个成功的读数：
- en: '[PRE7]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`echo_callback` will contain a GPIO callback reference for later clean-up purposes,
    while `tick_start` and `tick_end` hold the start and end timings used to calculate
    the elapsed time for an ultrasonic pulse-echo. The term `tick` is used to be consistent
    with PiGPIO timing functions, which we will come to shortly. `reading_success` is
    `True` only when we have a distance reading before `TIMEOUT_SECS` elapses.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo_callback`将包含一个GPIO回调引用，以供稍后进行清理，而`tick_start`和`tick_end`保存了用于计算超声脉冲回波的经过时间的开始和结束时间。术语“tick”用于与PiGPIO定时函数保持一致，我们将很快讨论这一点。只有在`TIMEOUT_SECS`过去之前我们有一个距离读数时，`reading_success`才为`True`。'
- en: 'We use the `trigger()` function shown on line 5 to start our distance measurement.
    We simply apply the process set out in the datasheet on line 6 – that is, we make
    the TRIG pin `HIGH` for 10 μs:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用第5行显示的`trigger()`函数来启动我们的距离测量。我们在第6行简单地应用了数据表中的流程 - 也就是说，我们使TRIG引脚在10微秒内变为`HIGH`：
- en: '[PRE8]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `get_distance_cms()` function shown at line 7 is our primary function that
    kicks off the distance measurement process by making a call to `trigger()`, before
    waiting from line 8 until we have either a successful reading (that is, `reading_success
    = True`) or `TIMEOUT_SECS` elapses, in which case, we return `SENSOR_TIMEOUT`.
    While we are waiting, a callback handler named `echo_handler()` is monitoring
    the `ECHO_GPIO` pin in the background for a successful read. We will discuss `echo_handler()` later
    in this section:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7行显示的`get_distance_cms()`函数是我们的主要函数，它通过调用`trigger()`来启动距离测量过程，然后在第8行等待，直到我们有一个成功的读数（也就是`reading_success
    = True`），或者`TIMEOUT_SECS`过去，此时我们返回`SENSOR_TIMEOUT`。在等待期间，一个名为`echo_handler()`的回调处理程序在后台监视`ECHO_GPIO`引脚以获取成功的读数。我们将在本节后面讨论`echo_handler()`。
- en: '[PRE9]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When we have a successful reading, our function continues. On line 9, we take
    the `tick_start` and `tick_end` variables (which will now have values set by the
    echo callback handler) and calculate the elapsed time. Remember, we''re dividing
    the elapsed time at line 9 by 2 because we want the timing from the sensor to
    the object, *not* the complete ultrasonic pulse round trip from the sensor to
    the object, back to the sensor:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个成功的读数时，我们的函数继续。在第9行，我们取`tick_start`和`tick_end`变量（现在已经由回声回调处理程序设置了值）并计算经过的时间。记住，我们在第9行将经过的时间除以2，因为我们想要从传感器到物体的时间，*而不是*从传感器到物体再返回传感器的完整超声脉冲往返时间：
- en: '[PRE10]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It is on line 10 where we apply the formula, *d* = *v* × *t*, which we discussed
    previously, to work out the distance between the sensor and an object.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在第10行，我们应用了我们之前讨论过的公式，*d* = *v* × *t*，来计算传感器和物体之间的距离。
- en: 'Next, we encounter the `echo_handler()` function on line 11, which monitors
    the `ECHO_GPIO` pin for changes in state:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在第11行，我们遇到了`echo_handler()`函数，它监视`ECHO_GPIO`引脚的状态变化：
- en: '[PRE11]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Applying the process set out in the datasheet, we are capturing the time between
    sending a pulse at line 12 when `ECHO_GPIO` goes `HIGH` and receiving it back
    on line 13 when `ECHO_GPIO` goes `LOW`. If we have detected `ECHO_GPIO` as `LOW`
    before the timeout (back on line 8), we set `reading_success = True` so that `get_distance_cms()` knows
    we have a valid reading.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 根据数据表中的流程，我们捕获了在第12行发送脉冲时的时间，当`ECHO_GPIO`变为`HIGH`，并在第13行接收到脉冲回来时的时间，当`ECHO_GPIO`变为`LOW`。如果我们在超时之前（在第8行）检测到`ECHO_GPIO`为`LOW`，我们将`reading_success
    = True`，这样`get_distance_cms()`就知道我们有一个有效的读数。
- en: 'Finally, we register the `echo_handler()` callback with PiGPIO on line 14\.
    The `pigpio.EITHER_EDGE` parameter means we want this callback to be called whenever
    `ECHO_GPIO` transitions to either a `HIGH` or `LOW` state:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在第14行使用PiGPIO注册了`echo_handler()`回调函数。`pigpio.EITHER_EDGE`参数表示我们希望在`ECHO_GPIO`转换为`HIGH`或`LOW`状态时调用此回调函数：
- en: '[PRE12]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Well done! You've just wired up, tested, and learned how to use the HC-SR04
    sensor together with PiGPIO to estimate distances. The circuit and code examples
    you have just learned could be adapted and used to measure water tank levels,
    or even as collision detection for a robot (a very common application of an HC-SR04
    in amateur robotics), or in any other project you dream up where distance plays
    a part.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！你刚刚连接、测试和学习了如何使用HC-SR04传感器以及PiGPIO来估算距离。你刚刚学到的电路和代码示例可以被改编并用于测量水箱水位，甚至作为机器人的碰撞检测（这是HC-SR04在业余机器人中非常常见的应用），或者在任何其他需要距离的项目中。
- en: Next, we will briefly explore Hall-effect sensors and learn how they can be
    used to detect movement and relative distances.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将简要探讨霍尔效应传感器，并学习它们如何用于检测运动和相对距离。
- en: Detecting movement and distance with Hall-effect sensors
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用霍尔效应传感器检测运动和距离
- en: Our final practical example in this chapter will illustrate the use of a Hall-effect
    sensor. Hall-effect sensors are simple components that detect the presence (or
    absence) of a magnetic field. In contrast to a PIR or distance sensor, you can
    use a Hall-effect sensor together with a magnet to monitor small-range – and even
    very rapid – movements. For example, you could attach a small magnet to the shaft
    of a DC motor and use a Hall-effect sensor to determine the motor's revolutions
    per minute.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后一个实际示例将说明霍尔效应传感器的使用。霍尔效应传感器是简单的组件，用于检测磁场的存在（或不存在）。与PIR或距离传感器相比，您可以使用霍尔效应传感器与磁铁一起监测小范围甚至非常快速的运动。例如，您可以将一个小磁铁固定在直流电机的轴上，并使用霍尔效应传感器来确定电机的每分钟转数。
- en: Another common application of a Hall-effect sensor is in mobile phones and tablets.
    Some phone and tables covers and cases have a small magnet in them. As you open
    or close the case, your device detects the presence or absence of this magnet
    with a Hall-effect sensor and automatically turns on or off the display for you.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 霍尔效应传感器的另一个常见应用是在手机和平板电脑中。一些手机和平板电脑的外壳和套子中有一个小磁铁。当您打开或关闭外壳时，您的设备会通过霍尔效应传感器检测到这个磁铁的存在或不存在，并自动为您打开或关闭显示屏。
- en: 'Hall-effect sensors come in three types, described as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '**Non-latching switch types (digital)**: They output a digital state (that
    is, `HIGH` or `LOW`) in the presence of magnetism and the opposite digital state
    in its absence. Whether the signal is `HIGH` or `LOW` in the presence of magnetism
    all depends on the sensor and whether it''s active `LOW` or active `HIGH` (please
    refer to [Chapter 6](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml), *Electronics
    101 for the Software Engineer*, if you need a refresher on the concepts of active
    `LOW` and active `HIGH`).'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Latching switch types (digital)**: They output (and latch to) `LOW` (or `HIGH`)
    when one pole (for example, south) of a magnet is detected, and return to `HIGH`
    (or `LOW`) (unlatch) when the alternative pole (for example, north) is detected.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ratiometric types (analog)**: They output a varying voltage depending on
    how close they are to a magnetic field.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some readers may be familiar with a component called a r*eed switch*, which
    is a magnetically controlled switch. At a glance, they seem similar in basic principle
    and operation to a non-latching Hall-effect sensor. Here are the important differences
    – unlike a classic reed switch, Hall-effect sensors are a solid-state device (no
    moving parts), they can be switched/triggered very, very rapidly (thousands of
    times a second), and they require an appropriate circuit to make them work.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Our examples will use the A3144 (non-latching digital switch) and AH3503 (analog
    ratiometric) Hall-effect sensors. These specific parts have been chosen due to
    their availability and low cost; however, the general principles we will discuss
    will also be applicable to other Hall-effect sensors.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'A picture of an A3144 Hall-effect sensor and common schematic symbols are shown
    in the following figure:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6c43f66c-4239-47e0-8db7-0a951ebdb90e.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
- en: Figure 11.9 – Hall-effect sensor and symbols
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that the far-right symbol has four protruding outputs because
    some Hall-effect sensors do have four legs. You can expect the outputs of this
    symbol to be annotated in a schematic diagram appropriate for the sensor it refers
    to. We will be sticking to the three-legged type sensor and the corresponding
    three outputs symbol.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'The legs of our components are as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '**Vcc**: 5-volt source power.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GND**: Ground connection.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Out**: 5-volt signal output. Note that the A3144 is active `LOW`, meaning
    that in the presence of a magnetic field, the **Out** leg becomes `LOW`.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Out** leg will behave differently depending on the type of Hall-effect
    sensor:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '**Latching and non-latching switching types**: The **Out** leg will output
    either digital `LOW` or a digital `HIGH`.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ratiometric type**: The output will be a varying voltage (that is, an analog
    output*). *Note that the range of varying voltage will not be the full range between
    0 to 5 volts, but more likely a range of only a few hundredths of a volt.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we understand the leg configurations of a Hall-effect sensor, let's
    build our circuit.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Hall-effect sensor circuit
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will be building the following circuit on our breadboards. Similar to our
    HC-SR04 example and circuit in *Figure 11.5*, we need to use a voltage divider
    since our Hall-effect sensor outputs 5-volt logic, which we need to shift down
    to 3.3 volts:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/209e5779-2f47-45e4-a894-cd29d7db6ce6.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
- en: Figure 11.10 – Hall-effect sensor circuit
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice that the output of this circuit is dualistic and will depend
    on which sensor you are using:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: For a *non-latching switch* or *latching switch* type Hall-effect sensor, you
    will connect the circuit directly to GPIO 21 since the sensor will output a digital
    `HIGH`/`LOW` signal.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a *ratiometric* type Hall-effect sensor, you will need to connect the sensor
    to your Raspberry Pi via your ADS1115 analog-to-digital converter since the sensor
    outputs a varying analog voltage.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I have not included the ADS1115 wiring in *Figure 11.9* or in the following
    stepped breadboard layouts. We have already seen how to connect an analog output
    to our Raspberry Pi using the ADS1115 in previous chapters – refer to [Chapter
    5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml), *Connecting Your Raspberry Pi
    to the Physical World*, and/or [Chapter 9](a77d6d94-a71a-4d7e-a66f-7c552af5b051.xhtml),
    *Measuring Temperature, Humidity, and Light Levels*, for example circuits and
    code using the ADS1115.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s construct this circuit on our breadboard. This layout is for a *switching-type* Hall-effect
    sensor:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c0b6ae7e-1802-49ff-b1a3-9b1cff719d69.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
- en: Figure 11.11 – Hall-effect sensor circuit breadboard layout
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to follow to complete your breadboard build. The step numbers
    match the numbers in black circles in *Figure 11.10*:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Place your A3144 Hall-effect sensor into your breadboard, paying careful attention
    to its orientation regarding its legs. Please refer to *Figure 11.8* if you need
    help identifying the component's legs.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a 1kΩ resistor (R1) into your breadboard.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a 2kΩ resistor (R2) into your breadboard. A leg of this second resistor
    shares the same row as a leg of the first resistor. In the illustration, this
    can be seen in row 17 on the left-hand side bank.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect a 5-volt pin from your Raspberry Pi to the positive rail of the left-hand
    side power rail.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect a GND pin from your Raspberry Pi to the negative rail of the left-hand
    side power rail.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the Hall-effect sensor's Vcc leg to the positive power rail.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the Hall-effect sensor's GND leg to the negative power rail.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the Hall-effect sensor's Out leg to the 1kΩ resistor (R1). In the illustration,
    this is shown at hole E13.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the junction of the 1kΩ (R1) and 2kΩ (R2) resistors to GPIO 21 on your
    Raspberry Pi.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the left of the 2kΩ resistor (R2) to the negative power rail.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To use the AH3503 ratiometric type Hall-effect sensor at *step 1* in this circuit,
    the wire at *step 9* will instead need to be connected to an input port (for example,
    A0) of an ADS1115 module.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have built our Hall-effect sensor circuit, get a magnet ready, as
    we're ready to run our example code and see how a magnet triggers the sensor.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Running and exploring the Hall-effect sensor code
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will find the code for Hall-effect sensors in the `chapter11/hall_effect_digital.py` file
    for switch and latching switch type Hall-effect sensors and the `chapter11/hall_effect_analog.py` file
    for ratiometric type Hall-effect sensors.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'What you will find when you review these two files is the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '`chapter11/hall_effect_digital.py` is functionally identical to the PIR code
    example we covered previously in this chapter in the section titled *Running and
    exploring the PIR sensor code*. Both the PIR and non-latching/latching Hall-effect
    sensors are digital switches. The only difference is that our reference Hall-effect
    sensor is *active* `LOW`.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chapter11/hall_effect_analog.py` is similar to other analog-to-digital examples
    we have seen using the ADS1115 ACD, including the circuit wiring and code from
    [Chapter 5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml), *Connecting Your Raspberry
    Pi to the Physical World.*'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The varying voltage range outputted by the AH3503 ratiometic Hall-effect sensor
    and measured by your ADC via the voltage divider is likely to be in the range
    of a few hundred millivolts.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: As you run the example code, move a magnet past your Hall-effect sensor. The
    magnet will need to be close to the casing of the sensor; however, it will not
    need to physically touch the sensor. How *close* will all depend on the strength
    of your magnet.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: If you cannot get your circuit and code to work, try rotating your magnet to
    reverse the north/south pole that passes past the sensor. Also note that for a
    *latching* type Hall-effect sensor, it is common for one pole of the magnet to *latch*
    (trigger) the sensor, while the opposite pole will *unlatch* (un-trigger) the
    sensor.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Due to the code similarities, we won't cover the code again here. However, I
    would like to say that at this point in the book, you now have both the digital
    and analog base circuits and code available for you to connect up and use any
    simple analog or digital component. As noted already in this chapter, just be
    wary of the voltages and currents needed to power the component, and especially
    what the output voltage is, because if it is more than 3.3 volts, you will need
    to use a voltage divider or level-shifter.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at ways to detect movement and estimate distance
    with our Raspberry Pi. We learned how to use a PIR sensor to detect broad movements,
    and how a switch-type Hall-effect sensor can be used to detect the movement of
    a magnetic field. We also discovered how to use an ultrasonic range sensor to
    estimate absolute distance on a larger scale, and how to use a ratiometric-type
    Hall-effect sensor to measure relative distances on a small scale.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: All our circuits and examples in this chapter have been *input* focused – telling
    our Raspberry Pi that some event has occurred, such as the detection of a person
    moving or that a distance is being measured.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: You are in a great position now to combine input circuits such as those covered
    in this chapter (and also in [Chapter 9](a77d6d94-a71a-4d7e-a66f-7c552af5b051.xhtml), *Measuring
    Temperature, Humidity, and Light Levels*), with output-based circuits and examples
    from [Chapter 7](36313176-0d8b-4a0e-916a-7d4ffd58305a.xhtml), *Turning Things
    On and Off*, [Chapter 8](d37dafc4-afc7-460c-b200-c2b6e19d0083.xhtml), *Lights,
    Indicators, and Displaying Information*, and [Chapter 10](8b0b4483-ccde-4a92-896b-039eb94d911a.xhtml),
    *Movement with Servos, Motors, and Steppers*, to create end-to-end projects that
    can both control and measure the environment!
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget about what we learned in [Chapter 2](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml), *Getting
    Started with Python and IoT*, [Chapter 3](b9f3d19f-a490-4752-ac4a-5607496dc3d9.xhtml),
    *Networking with RESTful APIs and Web Sockets Using Flask,* and [Chapter 4](6947b564-6182-4ec9-998a-37f636c0bce6.xhtml),
    *Networking with MQTT, Python, and the Mosquitto MQTT Broker*. These three chapters
    provide you with the foundations for creating web interfaces and integration to
    external systems that can control and monitor the environment.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Many of the electronic and code examples presented so far in this book have
    evolved around a single sensor or actuator. In the next chapter, we will explore
    several Python-based design patterns that are useful when building more complex
    automation and IoT projects that involve multiple sensors and/or actuators that
    need to communicate with one another.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    of this chapter''s material. You will find the answers in the *Assessments* section
    of the book:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Can a PIR sensor detect the direction that an object is moving?
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some factors that can affect the measurement accuracy of an ultrasonic
    distance sensor?
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does the output of a latching or non-latching Hall-effect sensor differ
    from the output of a ratiometric Hall-effect sensor?
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In relation to this PiGPIO function call, `callback = pi.callback(GPIO, pigpio.EITHER_EDGE,
    callback_handler)`, what does the `pigpio.EITHER_EDGE` parameter mean?
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a 5-volt to 3.3-volt resistor-based voltage divider consisting of a 1k Ω
    and 2k Ω resistor, why is important to connect the two resistor values the correct
    way around in a circuit?
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both the HC-SR04 ultrasonic distance sensor and the HC-SR501 PIR sensor were
    powered using 5 volts connected to their respective Vcc pins. Why did we use a
    voltage divider with the HC-SR04 to drop the output from 5 volts to 3.3 volts,
    but not with the HC-SR501?
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HC-SR04超声波距离传感器和HC-SR501 PIR传感器都使用5伏电压连接到它们各自的Vcc引脚。为什么我们要使用电压分压器将HC-SR04的输出从5伏降到3.3伏，而不是HC-SR501？
