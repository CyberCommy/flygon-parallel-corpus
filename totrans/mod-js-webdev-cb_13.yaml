- en: Creating a Desktop Application with Electron
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will look at the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Electron with React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Node functionality to your app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a more windowy experience
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing and debugging your app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a distributable package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we used `Node` to set up servers, and `React` to create
    web pages. In this chapter, we'll bring both together, adding another tool called `Electron`,
    and we'll see how we can use JS to write desktop apps that work exactly like any
    native executable app.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Electron with React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Electron` is an open source framework, created by GitHub, that lets you develop
    desktop executables that bring together Node and Chrome to provide a full GUI
    experience. `Electron` has been used for several well-known projects, including
    developer tools such as Visual Studio Code, Atom, and Light Table. Basically,
    you can define the UI with HTML, CSS, and JS (or using `React`, as we''ll be doing),
    but you can also use all of the packages and functions in `Node`, so you won''t
    be limited to a sandboxed experience, being able to go beyond what you could do
    with just a browser.'
  prefs: []
  type: TYPE_NORMAL
- en: You may also want to read about **Progressive Web Apps** (**PWA**) which are
    web apps that can be "installed" at your machine, very much like they were native
    apps. These apps are launched as any other app, and run in a common app window,
    without tabs or a URL bar as a browser would show. PWAs may not (yet?) have access
    to full desktop functionality, but for many cases they may be more than enough.
    Read more about PWAs at [https://developers.google.com/web/progressive-web-apps/](https://developers.google.com/web/progressive-web-apps/).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For now, in this recipe, let's first install `Electron`, and then in the later
    recipes, we'll see how we can turn one of our `React` apps into a desktop program.
  prefs: []
  type: TYPE_NORMAL
- en: 'I started out with a copy of the repository from [Chapter 8](70dac9ad-13ec-4c7b-a09c-eb97f396cab1.xhtml),
    *Expanding Your Application*, to get the countries and regions app, the same we
    also used for an RN example. It just so happens that you can work perfectly well
    with `Electron` with a CRA-built app, without even needing to eject it, so that''s
    what we''ll do here. First, we need to install the basic `Electron` package, so
    in the same directory where we wrote our `React` app, we''ll execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll need a starter JS file. Taking some tips from the `main.js` file
    at [https://github.com/electron/electron-quick-start](https://github.com/electron/electron-quick-start),
    we''ll create the following `electron-start.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some points to note regarding the preceding code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: This code runs in `Node`, so we are using `require()` instead of `import`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `mainWindow` variable will point to the browser instance where our code
    will run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll start by running our React app, so Electron will be able to load the code
    from [http://localhost:3000](http://localhost:3000)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our code, we also have to process the following events:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"ready"` is called when `Electron` has finished its initialization, and can
    start creating windows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"closed"` means your window was closed; your app might have several windows
    open, so at this point you should delete the closed one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"window-all-closed"` implies your whole app was closed. In Windows and Linux,
    this means quitting, but for macOS, you don''t usually quit applications, because
    of Apple'' s usual rules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"activate"` is called when your app is reactivated, so if the window had been
    deleted (as in Windows or Linux), you have to create it again.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The complete list of events that `Electron` can emit is at [https://github.com/electron/electron/blob/master/docs/api/app.md](https://github.com/electron/electron/blob/master/docs/api/app.md);
    check it out.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already have our `React` app in place, so we just need a way to call `Electron`.
    Add the following script to `package.json`, and you''ll be ready:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We are set; let's see how it all comes together.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run the `Electron` app in development mode (we''ll get on to creating an
    executable file later), we have to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Run our `restful_server_cors` server code from [Chapter 4](6b0f5248-5e86-4182-b7fe-1501f2ff09a3.xhtml),
    *Implementing RESTful Services with Node*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the `React` app, which requires the server to be running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait until it's loaded, and then and only then, move on to the next step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start `Electron`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, basically, you''ll have to run the two following commands, but you''ll
    need to do so in separate terminals, and you''ll also have to wait for the `React`
    app to show up in the browser before starting `Electron`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'After starting `Electron`, a screen quickly comes up, and we again find our
    countries and regions app, now running independently of a browser. See the following
    screenshot—note that I resized the window from its 1024 × 768 size:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d82abd1a-1bbf-4d4f-b534-22deedffeebc.png)'
  prefs: []
  type: TYPE_IMG
- en: Our app, running as an independent executable
  prefs: []
  type: TYPE_NORMAL
- en: 'The app works as always; as an example, I selected a country, Canada, and correctly
    got its list of regions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a1a907c-f625-43ee-b7ee-827ed2d05df2.png)'
  prefs: []
  type: TYPE_IMG
- en: The app works as before; pick a country, and a call to our RESTful server will
    get its regions
  prefs: []
  type: TYPE_NORMAL
- en: We are done! You can see that everything is interconnected, as before, in the
    sense that if you make any changes to the `React` source code, they will be instantly
    reflected in the `Electron` app.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have seen that we can make an executable out of a web page; let's
    now see how to make it more powerful.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Node functionality to your app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we saw that with just a few small configuration changes,
    we can turn our web page into an application. However, you're still restricted
    in terms of what you can do, because you are still using only those features available
    in a sandboxed browser window. You don't have to think this way, for you can add
    basically all `Node` functionality using functions that let you go beyond the
    limits of the web. Let's see how to do it in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to add some functionality to our app of the kind that a typical desktop
    would have. Let's see how can we do that. The key to adding `Node` functions to
    your app is to use the `remote` module in `Electron`. With it, your browser code
    can invoke methods of the main process, and thus gain access to extra functionality.
  prefs: []
  type: TYPE_NORMAL
- en: See [https://github.com/electron/electron/blob/master/docs/api/remote.md](https://github.com/electron/electron/blob/master/docs/api/remote.md) for
    more on the remote module. There is also extra information that might come in
    handy at [https://electronjs.org/docs/api/remote](https://electronjs.org/docs/api/remote).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we wanted to add the possibility of saving the list of a country''s
    regions to a file. We''d require access to the `fs` module to be able to write
    a file, and we''d also need to open a dialog box to select what file to write
    to. In our `serviceApi.js` file, we would add the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Having added this, we can now write files and show dialog boxes from our main
    code. To use this functionality, we could add a new action to our `world.actions.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `saveRegionsToDisk()` action is dispatched, it will show a dialog
    to prompt the user to select what file is to be written, and will then write the
    current set of regions, taken from `getState().regions`, to the selected file
    in JSON format. We just have to add the appropriate button to our `<RegionsTable>`
    component to be able to dispatch the necessary action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We are almost done! When we connect this component to the store, we''ll simply
    add the new action, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, everything's ready—let's see it working.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code we added showed how we could gain access to a `Node` package (`fs`,
    in our case) and some extra functions, such as showing a Save to disk dialog.
    (The latter function has more to do with the native look of your app, and we''ll
    see more about it in the upcoming *Building a more windowy experience* section.)
    When we run our updated app and select a country, we''ll see our newly added button,
    as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d8572940-7b7d-43e5-8ee0-a80168759e00.png)'
  prefs: []
  type: TYPE_IMG
- en: We now have a Save regions to disk button after the regions list
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on the button will pop up a dialog, allowing you to select the destination
    for the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5ae729f-5ea2-44c1-a4d4-98046a461102.png)'
  prefs: []
  type: TYPE_IMG
- en: Clicking on the button brings up a Save screen, to specify to which file to
    save the results
  prefs: []
  type: TYPE_NORMAL
- en: 'If you click Save, the list of regions will be written in JSON format, as we
    specified earlier in our `writeRegionsToDisk()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'A final detail to note is that your app won''t be able to run in a browser
    now, and you''ll have to get used to seeing something as in the following screenshot,
    even though your code will run fine with `Electron`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98c69b03-212c-4156-8085-84a9468a6f5a.png)'
  prefs: []
  type: TYPE_IMG
- en: If you use Node's or Electron's functions, your code will no longer run in the
    browser, though it will perform perfectly well with Electron
  prefs: []
  type: TYPE_NORMAL
- en: That's it! Without much hassle, we were able to go beyond the limits of normal
    browser apps. You can see that there's practically no limit to what you can do
    in an `Electron` app.
  prefs: []
  type: TYPE_NORMAL
- en: Building a more windowy experience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous recipe, we added the possibility of using any and all of the
    functions provided by `Node`. In this recipe, let''s now focus on making our app
    more window-like, with icons, menus, and so on. We want the user to really believe
    that they''re using a native app, with all the features that they would be accustomed
    to. The following list of interesting subjects from [https://electronjs.org/docs/api](https://electronjs.org/docs/api)
    is just a short list of highlights, but there are many more available options:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `clipboard` | To do copy and paste operations using the system''s clipboard
    |'
  prefs: []
  type: TYPE_TB
- en: '| `dialog` | To show native system dialogs for messages, alerts, opening and
    saving files, and so on |'
  prefs: []
  type: TYPE_TB
- en: '| `globalShortcut` | To detect keyboard shortcuts |'
  prefs: []
  type: TYPE_TB
- en: '| `Menu`, `MenuItem` | To create a menu bar with menus and submenus |'
  prefs: []
  type: TYPE_TB
- en: '| `Notification` | To add desktop notifications |'
  prefs: []
  type: TYPE_TB
- en: '| `powerMonitor`, `powerSaveBlocker` | To monitor power state changes, and
    to disable entering sleep mode |'
  prefs: []
  type: TYPE_TB
- en: '| `screen` | To get information about the screen, displays, and so on |'
  prefs: []
  type: TYPE_TB
- en: '| `Tray` | To add icons and context menus to the system''s tray |'
  prefs: []
  type: TYPE_TB
- en: Let's add a few of these functions so that we can get a better-looking app that
    is more integrated to the desktop.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any decent app should probably have at least an icon and a menu, possibly with
    some keyboard shortcuts, so let's add those features now, and just for the sake
    of it, let's also add some notifications for when regions are written to disk.
    Together with the Save dialog we already used, this means that our app will include
    several native windowing features. Let's implement the following steps and understand
    how to add these extras.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, let''s add an icon. Showing an icon is the simplest thing, because
    it just requires an extra option when creating the `BrowserWindow()` object. I''m
    not very *graphics-visual-designer* oriented, so I just downloaded the Alphabet,
    letter, r Icon Free file from the Icon-Icons website, at [https://icon-icons.com/icon/alphabet-letter-r/62595](https://icon-icons.com/icon/alphabet-letter-r/62595).
    Implement the icon as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can also choose icons for the system tray, although there's no way of using
    our regions app in that context, but you may want to look into it nonetheless.
  prefs: []
  type: TYPE_NORMAL
- en: There's another way of adding an icon to your app when you do the build, by
    adding an extra configuration item to the `"build"` entry in `package.json`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To continue, the second feature we''ll add is a menu, with some global shortcuts
    to boot. In our `App.regions.js` file, we''ll need to add a few lines to access
    the `Menu` module, and to define our menu itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Using a template is a simple way to create a menu, but you can also do it manually,
    adding item by item. I decided to have a Countries menu with two options to show
    the regions for Uruguay (where I was born) and Hungary (from where my father''s
    father came). The `click` property dispatches the appropriate action. I also used
    the `accelerator` property to define global shortcuts. See [https://github.com/electron/electron/blob/master/docs/api/accelerator.md](https://github.com/electron/electron/blob/master/docs/api/accelerator.md)
    for the list of possible key combinations to use, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Command keys*, such as `Command` (or `Cmd`), `Control` (or `Ctrl`), or both
    (`CommandOrControl` or `CmdOrCtrl`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Alternate keys*, such as `Alt`, `AltGr`, or `Option`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Common keys*, such as `Shift`, `Escape` (or `Esc`), `Tab`, `Backspace`, `Insert`,
    or `Delete`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Function keys*, such as `F1` to `F24`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Cursor keys*, including `Up`, `Down`, `Left`, `Right`, `Home`, `End`, `PageUp`,
    and `PageDown`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Media keys*, such as `MediaPlayPause`, `MediaStop`, `MediaNextTrack`, `MediaPreviousTrack`, `VolumeUp`,
    `VolumeDown`, and `VolumeMute`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I also want to be able to quit the application (never mind that the window
    created by `Electron` already has an × icon to close it!)—that''s a predefined
    *role* for which you don''t need to do anything special. A complete list of roles
    is available at [https://electronjs.org/docs/api/menu-item#roles](https://electronjs.org/docs/api/menu-item#roles).
    With these roles, you can do a huge amount, including some specific macOS functions,
    along with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Work with the clipboard (`cut`, `copy`, `paste`, and `pasteAndMatchStyle`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle the window (`minimize`, `close`, `quit`, `reload`, and `forceReload`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zoom (`zoomIn`, `zoomOut`, and `resetZoom`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To finish, and really just for the sake of it, let''s add a notification trigger
    for when a file is written. `Electron` has a `Notification` module, but I opted
    to use `node-notifier` from [https://github.com/mikaelbr/node-notifier](https://github.com/mikaelbr/node-notifier),
    which is quite simple to use. First, we''ll add the package in the usual fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In `serviceApi.js`, we''ll have to export the new function, so we''ll able
    to import from elsewhere, as we''ll see shortly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s use this in our `world.actions.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'With all our setup, actually sending a notification is quite simple, requiring
    very little code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We are set! Let's see what our more *windowy* app looks like now.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we can easily check that the icon appears. See the following screenshot,
    and compare it with the very first screenshot in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/20c41f3f-3f44-4cfa-a477-2fa53e2a844e.png)'
  prefs: []
  type: TYPE_IMG
- en: Our app now has its own icon, possibly not too exclusive or original, but better
    than nothing
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the menu. It has our options, including the shortcuts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cdff7282-3cd4-426c-a3f8-f0826f616e04.png)'
  prefs: []
  type: TYPE_IMG
- en: Our app now also has a menu, as any self-respecting app should
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, if we select an option (let''s say Uruguay) with either the mouse or
    the global shortcut, the screen correctly loads the expected regions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0fcc9fda-b118-4eb9-8416-658f01cf18bb.png)'
  prefs: []
  type: TYPE_IMG
- en: The menu entries work as expected; we can use the Uruguay option to see my country's
    19 departments
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s see if the notifications work as expected. If we click on the
    Save regions to disk button and select a file, we''ll see a notification, as in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/95d43e2b-5b57-45fc-a614-26e9fe26c9fc.png)'
  prefs: []
  type: TYPE_IMG
- en: Saving a file now shows a notification; in this case, for Linux with KDE
  prefs: []
  type: TYPE_NORMAL
- en: We've now seen how to expand our browser page to include `Node` features and
    windowing native functions. Now, let's go back to more basic requirements, and
    learn how to test and debug our code.
  prefs: []
  type: TYPE_NORMAL
- en: Testing and debugging your app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we get to a common requirement: testing and debugging your app. The first
    thing I''ll have to tell you is that there''s no news in regards to testing! All
    the techniques we saw for testing browser and `Node` code still apply, since your
    `Electron` app is essentially just a browser app (albeit possibly with some extra
    functions) that you''ll mock in the same way you did earlier, so there''s nothing
    new to be learned here.'
  prefs: []
  type: TYPE_NORMAL
- en: However, with regard to debugging, there will be some new requirements, since
    your code is not running in a browser. In a similar way as with `React Native`,
    we'll have to use some tools in order to be able to look into our code as it runs.
    Let's see, in this recipe, how to go about all of this.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want to install and configure all the necessary tools for debugging. Let''s
    do that in this section. The key tool for debugging will be `electron-devtools-installer`,
    which you can get from [https://github.com/MarshallOfSound/electron-devtools-installer](https://github.com/MarshallOfSound/electron-devtools-installer).
    We''ll install it, as well as the `Redux Devtools` extension we used before, with
    a simple command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the `Redux Devtools`, we''ll have to start by fixing the store, as we
    did earlier; nothing new here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'For the tools themselves, we''ll also have to tweak our starter code a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The good thing is that you can add all the tools from code, with no special
    installation or any other procedure. After these simple changes, you are done;
    now, let's see it work!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you start the modified code, you''ll see that the `Electron` window now
    includes the classic Chrome tools, including `React` and `Redux`. See the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f6658a1-4e0d-4ea0-81b4-def111922f9f.png)'
  prefs: []
  type: TYPE_IMG
- en: The electron-devtools-installer package lets you add all the tools you need,
    with a simple procedure
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the console, you can use the `React Devtools` to inspect components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/db13bb2d-99c6-4601-9f08-6d07073d3f41.png)'
  prefs: []
  type: TYPE_IMG
- en: The React Devtools can be used to inspect components and their props
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the `Redux DevTools` let you inspect actions and the store. See
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba5cb884-220b-4ea3-86f5-44d5615ca827.png)'
  prefs: []
  type: TYPE_IMG
- en: You also installed the Redux developer tools, which let you inspect everything
    Redux-related
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we've got all the tools we were accustomed to, with one exception—what
    about network calls? Let's see to that now.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may have noticed that the Network tab doesn''t show the API calls done
    from the app. With RN, we solved that because the tools we used included the ability
    to inspect all network traffic, but that doesn''t happen here. So, instead of
    an easy, automated solution, we''ll have to do a bit of extra work. If you do
    all of your API calls with `axios`, you can simply modify its original methods
    to produce logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The change shown will cause every successful `GET` to log everything you need,
    as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b31c2611-d73b-4458-b211-a0664279de46.png)'
  prefs: []
  type: TYPE_IMG
- en: Our changed `axios.get()` method produces a satisfying log
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this is just the tip of the required changes. You'll have to add
    code for a failed call (so, add some logging in `.catch()`, too) and you'll also
    want to do this sort of change for the other methods (`.post()`, `.delete()`,
    and so on), but the necessary code is simple, so I'll leave it as an exercise
    for the reader!
  prefs: []
  type: TYPE_NORMAL
- en: Making a distributable package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a full app, all that's left to do is package it up so that
    you can deliver it as an executable file for Windows, Linux, or macOS users. Let's
    finish the chapter by looking at how to do that in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many ways of packaging an app, but we'll use a tool, `electron-builder`,
    that will make it even easier, if you can get its configuration right!
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about `electron-builder`, its capabilities, and its configuration
    at [https://www.electron.build/](https://www.electron.build/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the necessary steps. First of all, we''ll have to begin
    by defining the build configuration, and our initial step will be, as always,
    to install the tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To access the added tool, we''ll require a new script, which we''ll add in
    `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also have to add a few more details to `package.json`, which are needed
    for the build process and the produced app. In particular, the `homepage` change
    is required, because the CRA-created `index.html` file uses absolute paths that
    won''t work later with `Electron`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, some specific building configuration will be required. You cannot
    build for macOS with a Linux or Windows machine, so I''ll leave that configuration
    out. We have to specify where the files will be found, what compression method
    to use, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Read more about building for different platforms at [https://www.electron.build/multi-platform-build](https://www.electron.build/multi-platform-build).
    For more on all of the configuration options, see [https://www.electron.build/configuration/configuration#configuration](https://www.electron.build/configuration/configuration#configuration).
  prefs: []
  type: TYPE_NORMAL
- en: 'We have completed the required configuration, but there are also some changes
    to do in the code itself, and we''ll have to adapt the code for building the package.
    When the packaged app runs, there won''t be any webpack server running; the code
    will be taken from the built `React` package. Also, you won''t want to include
    debugging tools. So, the starter code will require the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Mainly, we are taking icons and code from the `build/` directory. An `npm run
    build` command will take care of generating that directory, so we can proceed
    with creating our executable app.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After doing this setup, building the app is essentially trivial. Just do the
    following, and all the distributable files will be found in the `dist/` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You may want to add a new line to the `.gitignore` file so that the distribution
    directory won't be committed. I included a `**/dist` line to mine, paralleling
    the previous `**/node_modules` and `**/dist` existing lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the Linux app, we can run it by unzipping the `.zip` file
    and clicking on the `chapter13` executable. (The name came from the `"name"` attribute
    in `package.json`, which we modified earlier.) The result should be like what''s
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d4b11ce-77df-40c5-81c9-7a860b8375c4.png)'
  prefs: []
  type: TYPE_IMG
- en: The Linux executable runs as a native app, showing the same screen as we saw
    earlier
  prefs: []
  type: TYPE_NORMAL
- en: I also wanted to try out the Windows `EXE` file. Since I didn't have a Windows
    machine, I made do by downloading a free `VirtualBox` virtual machine from [https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/](https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/)—they
    only work for 90 days, but I needed it for just a few minutes.
  prefs: []
  type: TYPE_NORMAL
- en: 'After downloading the virtual machine, setting it up in `VirtualBox`, and finally
    running it, the result that was produced was the same as for Linux, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c2ccbf1b-74d5-430b-a6f3-d88513be4cf8.png)'
  prefs: []
  type: TYPE_IMG
- en: Our native Windows app runs equally in a Windows machine
  prefs: []
  type: TYPE_NORMAL
- en: So, we've managed to develop a `React` app, enhanced it with the `Node` and
    `Electron` features, and finally packaged it for different operating systems.
    With that, we are done!
  prefs: []
  type: TYPE_NORMAL
