- en: Operating Applications on Kubernetes
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss the provisioning tools available to deploy
    cloud-native applications on Kubernetes. You will learn how to deploy DevOps tools
    and **CI**/**CD** (short for **continuous integration**/**continuous delivery**
    or **continuous deployment**) infrastructure on Kubernetes using the most popular
    life cycle management options. You will gain the skills to perform Day 1 and some
    Day 2 operations, such as installing, upgrading, and version controlling Deployments,
    ruling out a new application, and removing Deployments when they are no longer
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Deploying workloads using YAML files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying workloads using Customize
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying workloads using Helm charts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying and operating applications using Kubernetes operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying and managing the life cycle of Jenkins X
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying and managing the life cycle of GitLab
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recipes in this section assume that you have a functional Kubernetes cluster
    deployed following one of the recommended methods described in [Chapter 1](a8580410-3e1c-4e28-8d18-aaf9d38d011f.xhtml),
    *Building Production-Ready Kubernetes Clusters*.
  prefs: []
  type: TYPE_NORMAL
- en: The Kubernetes Operations tool kubectl will be used for the rest of the recipes
    in this section since it's the main command-line interface for running commands
    against Kubernetes clusters. If you are using a Red Hat OpenShift cluster, you
    can replace `kubectl` with `oc` and all commands are expected to function similarly.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying workloads using YAML files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will create the resource configurations required to deploy
    your applications in Kubernetes. You will learn how to create a Kubernetes manifest,
    deploy a workload, and roll out a new version using **Yet Another Markup Language**
    (**YAML**) files.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you start, clone the repository of the examples used in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Make sure you have a Kubernetes cluster ready and kubectl configured to manage
    the cluster resources.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section is further divided into the following subsections to ease the
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying a Deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editing a Deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rolling back a Deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting a Deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Deployment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This recipe will take you through instructions to create a Deployment using
    a manifest file that keeps a set of pods running. Deployments are used to declare
    how many replicas of a pod should be running. A Deployment can be scaled up and
    down; we will see more on that topic later in [Chapter 7](7b696c2a-de7c-4adc-9ecc-f5bf65c288c5.xhtml),* Scaling
    and Upgrading* *Applications*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change directory to `src/chapter2/yaml/`, where the example files for this
    recipe are located:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Review the Deployment manifest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: YAML is white space sensitive. Review the example file to understand the structure
    of the file. You will see that YAML files do not use tabs instead of a space character.
  prefs: []
  type: TYPE_NORMAL
- en: If in doubt, use a linter for your YAML files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Deployment by applying the YAML manifest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: After you run the preceding command, the container image mentioned in the YAML
    manifest will be pulled from the container registry and the application will be
    scheduled in your Kubernetes cluster as defined in the Deployment manifest. Now
    you should be able to verify the Deployment by following the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying a Deployment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This recipe will take you through the instructions to verify the status of the
    Deployment and troubleshoot it if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Confirm that the Deployment status shows a `successfully rolled out` message
    by watching the rollout status:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that the number of `DESIRED` and `CURRENT` values is equal, in our case
    `2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, also check the ReplicaSets (`rs`) and `pods` deployed as part of the
    Deployment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now you have verified that the new Deployment is successfully deployed and running.
    In a production environment, you will also need to edit, update, and scale an
    existing application. In the next recipe, you will learn how to perform these
    modify operations on an existing Deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Editing a Deployment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This recipe will take you through the instructions to edit an existing Kubernetes
    object, and you will learn how to change a Deployment object's parameters when
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the Deployment object and change the container image from image nginx
    1.7.9 to image nginx 1.16.0:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that the Deployment first goes into pending termination and later
    the rollout status shows a `successfully rolled out` message after you run the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Confirm that your Deployment spins up the new pods by creating a new ReplicaSet
    and scaling down the old one from `2` to `0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We will create a change cause annotation. The following command will add the
    description defined in the `kubernetes.io/change-cause` parameter to your current
    Deployment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, as an alternative way to edit a Deployment, edit the `deployment-nginx.yaml`
    file and change the replicas from `replicas: 2` to `replicas: 3` and `nginx:1.7.9`
    to `image: nginx:1.17.0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the Deployment by applying the updated YAML manifest with your changes.
    This step will apply the change of image tag used for the Deployment and the number
    of replicas we increased in *step 5*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Confirm that your Deployment spins up the new pods by creating a new ReplicaSet
    and scaling down the old pods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Create another change cause annotation by defining the changes we made using
    the `kubernetes.io/change-cause` parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now you have learned how to edit, scale up, and also roll out a new version
    of the application using a ReplicaSet.
  prefs: []
  type: TYPE_NORMAL
- en: Rolling back a deployment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This recipe will take you through the instructions for reviewing changes made
    by comparing the annotations and rolling back the Deployment to an older revision
    when needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the details and events for the Deployment and note recent `ScalingReplicaSet`
    events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, display the rollout history for the Deployment. The output will show the
    revisions along with the annotations we have created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Roll back the last rollout. This command will take your Deployment to the previous
    revision, in this recipe, revision 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Confirm that the Deployment has rolled back to the previous version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the rollback command only takes the Deployments back to different
    image version rollouts, and does not undo the other spec changes, such as the
    number of replicas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, roll back to a specific revision. This command will take your Deployment
    to a specific revision defined using the `--to-revision` parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now you have learned how to review the rollout history and roll back a change
    when required.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a Deployment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kubernetes schedules resources on the worker nodes based on the availability
    of resources. If you are using a small cluster with limited CPU and memory resources,
    you may easily run out of resources, which would cause new Deployments to fail
    to get scheduled on worker nodes. Therefore, unless it is mentioned in the requirement
    of the recipe, always clean up the old Deployments before you move onto the next
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following step to remove `nginx-deployment`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Delete the Deployment before moving onto the next recipes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will immediately terminate the Deployment and remove the
    application from your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating a Deployment* recipe showed you how to apply the desired state
    of your pods and ReplicaSets to the Deployment controller using YAML manifest
    files.
  prefs: []
  type: TYPE_NORMAL
- en: In step 2, we used the `kubectl apply` command, which is a part of the declarative
    management approach and makes incremental changes rather than overwriting them.
    The first time you create a resource intent, you could instead use the `kubectl
    create` command, which is considered an imperative management method.
  prefs: []
  type: TYPE_NORMAL
- en: I prefer to use the `apply` command, where declarative patterns are allowed,
    instead of `create` since it is better for creating the CI script and does not
    raise an error if the resource already exists.
  prefs: []
  type: TYPE_NORMAL
- en: Now you have learned the fundamental steps to get a single Deployment running
    in Kubernetes, we can move on to more complex Deployment use cases to compose
    a collection of objects using Kustomize, Helm, and Operator frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A linter for YAML files: [https://github.com/adrienverge/yamllint](https://github.com/adrienverge/yamllint)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Online Kubernetes YAML validator: [https://kubeyaml.com/](https://kubeyaml.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read more on the declarative management of Kubernetes objects using configuration
    files: [https://kubernetes.io/docs/tasks/manage-kubernetes-objects/declarative-config/](https://kubernetes.io/docs/tasks/manage-kubernetes-objects/declarative-config/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Authoring Kubernetes manifests guide: [https://github.com/bitnami/charts/blob/master/_docs/authoring-kubernetes-manifests.md ](https://github.com/bitnami/charts/blob/master/_docs/authoring-kubernetes-manifests.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying workloads using Kustomize
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will show you how to generate resources from files and compose
    and customize collections of resources in Kubernetes. You will learn about the
    declarative management of Kubernetes objects using Kustomize.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure you have a Kubernetes cluster ready and `kubectl` configured to manage
    the cluster resources.
  prefs: []
  type: TYPE_NORMAL
- en: The source files created in this section can be found on my GitHub repository
    located at [https://github.com/k8sdevopscookbook/src/tree/master/chapter2/kustomize](https://github.com/k8sdevopscookbook/src/tree/master/chapter2/kustomize).
    It is recommended that you follow the instructions to create and edit them and
    only use the files in the repository to compare with your files if you run into
    an issue.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section is further divided into the following subsections to ease the
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: Validating the Kubernetes cluster version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating Kubernetes resources from files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a base for a development and production Deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating the Kubernetes cluster version
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For Kustomize to function, Kubernetes cluster version 1.14.0 or later is required,
    since Kustomize support is only included with kubectl v.1.14.0 and later.
  prefs: []
  type: TYPE_NORMAL
- en: 'List the nodes to confirm your Kubernetes cluster version and make sure that
    it is 1.14.0 or later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the version shows `v1.15.0`.
  prefs: []
  type: TYPE_NORMAL
- en: Generating Kubernetes resources from files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s learn how to customize the nginx rollout we did in the previous recipe
    using Kustomize this time:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a directory named `nginx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the `deployment-nginx.yaml` file you created in the *Deploying workload
    using YAML files* recipe under the `nginx` directory. This file still uses `image:
    nginx:1.7.9` as the container image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `kustomization.yaml` file by specifying a new image version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Check that the new version is injected into your Deployment by running the
    following command. In the output, you will see `image: nginx:1.16.0` instead of
    the original image version `nginx:1.7.9` that we have previously used in the `deployment-nginx.yaml`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the Deployment with customizations using the `-k` parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `kustomization.yaml` file by specifying a newer image version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the customized Deployment using the `-k` parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, display the rollout history for the Deployment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now you have learned how to edit, scale up, and also roll out a new version
    of the application using Kustomize.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a base for a development and production Deployment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to create a base for a local Docker image
    registry Deployment that we will use later in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a directory named `registry` and another one underneath called `base`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Under `registry/base`, download the Deployment file named `deployment-registry.yaml`
    from the example repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Review the file to understand its structure. You will see that it is a `Deployment` manifest
    consisting of two containers named `registry` and `registryui`. You will see that
    the registry container has a `volumeMount` named `registry-storage` and this volume
    is provided by a persistent volume claim named `registry-pvc`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Under the same `registry/base`, download the service manifest file named `service-registry.yaml` from
    the example repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Review the file to understand its structure. You will see that it is a service
    manifest that exposes the service on each Node''s IP at a static port; in this
    recipe, port `5000` for the `registry` service and port `80` for the `registry-ui`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `PersistentVolumeClaim` manifest file named `pvc-registry.yaml` with
    the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you can deploy the workload using all the resource files under
    the `registry` directory, by using `kubectl apply -f registry/base`. But every
    time you need to change a parameter in resources, such as `app` or `label`, you
    need to edit the files. The whole point of using Kustomize is to take advantage
    of reusing the files without modifying the source of the files.
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally, create the `kustomization.yaml` file. The following command will
    create the Kustomize resource content with the three separate manifest files we
    created previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create two overlays to be used for development and production Deployments.
    The first one is for development:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'And the second manifest will create the overlay for production:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Check that `dev` and `prod` prefixes are injected into your Deployment. When
    you point to the `prod` folder, the annotation note will display `"Hello, I am
    production!"`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'When you point to the `dev` folder, the annotation note will display `"Hello,
    I am development!"`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, deploy the `dev` version of your application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, you can inject labels, patch image versions, change the number of
    replicas, and deploy resources into a different namespace.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe showed you how to manage and implement basic version control of
    your configuration files using Git.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Creating a base for a development and production Deployment* recipe,
    the resources we created between step 2 and step 6 under the `base` directory
    represents an upstream repository of the application/workload, and the customizations
    we created between step 8 and step 10 under the `overlay` directory are the changes
    you control and store in your repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later, if you need to see the difference of a variant, you can use the `diff`
    parameter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: By separating the changes from the base, we were able to customize template-free
    YAML files for multiple purposes, leaving the original YAML files unchanged, making
    the version controlling of source and changes possible.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Kustomize concepts overview slides: [https://speakerdeck.com/spesnova/introduction-to-kustomize](https://speakerdeck.com/spesnova/introduction-to-kustomize)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declarative application management in Kubernetes background whitepaper – a highly
    recommended read: [https://goo.gl/T66ZcD](https://goo.gl/T66ZcD)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common terms in Kustomize: [https://github.com/kubernetes-sigs/kustomize/blob/master/docs/glossary.md](https://github.com/kubernetes-sigs/kustomize/blob/master/docs/glossary.md)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional Kustomize examples: [https://github.com/kubernetes-sigs/kustomize/tree/master/examples](https://github.com/kubernetes-sigs/kustomize/tree/master/examples)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying workloads using Helm charts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will show you how to use Helm charts in Kubernetes. Helm
    is the package manager for Kubernetes, which helps developers and SREs to easily
    package, configure, and deploy applications.
  prefs: []
  type: TYPE_NORMAL
- en: You will learn how to install Helm on your cluster and use Helm to manage the
    life cycle of third-party applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure you have a Kubernetes cluster ready and `kubectl` configured to manage
    the cluster resources.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section is further divided into the following subsections to ease the
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Helm 2.x
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing an application using Helm charts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching for an application in Helm repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating an application using Helm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rolling back an application using Helm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding new Helm repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting an application using Helm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a Helm chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Helm 2.x
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to configure the prerequisites and install
    Helm:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `ServiceAccount` by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `ClusterRoleBinding` by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Download the Helm installation script. This `install-helm.sh` script will detect
    the architecture of your system and get the latest correct binaries to install
    Helm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script to install Helm. The following command will install the two
    important binaries, Helm and Tiller, required to run Helm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `init` parameter to configure Helm with the service account we created
    in step 1*.* The `--history-max` parameter is used to purge and limit the Helm
    history, since without this setting the history can grow indefinitely and cause
    problems:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This process with install the Helm server-side component Tiller in your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: If you get a message complaining that `Tiller is already installed in the cluster.`,
    you can run the same command by adding the `--upgrade` parameter to the end of
    the command and force-upgrading the existing version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Confirm the Helm version by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: At the time of writing this recipe, the latest stable version of Helm was v2.15.1
    and the next version, Helm 3, was still in beta. In the following chapters and
    recipes, we will base our instruction on the Helm 2.x version.
  prefs: []
  type: TYPE_NORMAL
- en: Installing an application using Helm charts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to install a Helm chart from the official
    Helm repository location:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you install a chart, always sync the repository to pull the latest content.
    Otherwise, you may end up with the old version of the Helm charts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Install an example chart, in this case, `stable/mysql`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, you can install other applications from the Helm charts stable repository
    or add your own repositories for custom charts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every time you install a chart, a new release with a random name is created
    unless specified with the `--name` parameter. Now, list the releases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the status in the release, in our example, `my-mysqlrelease`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: You will get the Deployment status and information on all resources.
  prefs: []
  type: TYPE_NORMAL
- en: Searching for an application in Helm repositories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to search for an application you would like
    to deploy on Kubernetes from the Helm chart repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Search for a chart in the repository. The following command will look for your
    search words in the Helm repositories that you have access to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find the complete list of workloads in helm/stable and the source of
    the repository at the following GitHub link: [https://github.com/helm/charts/tree/master/stable ](https://github.com/helm/charts/tree/master/stable)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `search` keyword doesn''t have to be the exact name of the project. You
    can also search for keywords such as `Storage`, `MQ`, or `Database`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: By default, your repository list is limited to the `helm/stable` location but
    later, in the *A**dding new Helm repositories* recipe, you will also learn how
    to add new repositories to extend your search coverage to other repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading an application using Helm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are a couple of ways to use an upgrade. Let''s perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Upgrade the release, in our case, `my-mysqlrelease`, with a newer chart version
    when available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'In the future, you may find a specific version of the application that is more
    stable in your environment or keep the installations identical in multiple clusters.
    In that case, you can update the chart version with your preferred chart version
    using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Confirm the chart version change using the following command. After upgrading
    the version in step 2, you should expect to see `mysql --version 1.2.0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'See the history of revisions using the following command. Since we recently
    updated the chart version, you should see at least two revisions in the history:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `helm upgrade` function to update a parameter on an existing release
    by specifying a parameter using the `--set key=value[,key=value]` argument. The
    following command will set two MySQL password using the `--set mysqlRootPassword`
    parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Confirm that the password is actually updated. You should expect to get the
    same password you set in step 4:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Now you have learned how to upgrade a Helm release with new parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Rolling back an application using Helm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to recall an upgrade and bring your application
    status to a previous revision:'
  prefs: []
  type: TYPE_NORMAL
- en: 'List the revision history for your release, in our example, `coy-jellyfish`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s say you need to roll back from the last upgrade to revision `4`. Roll
    back to a specific revision:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The revision history will be updated to reflect your rollback:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Now you have learned how to review the release history and roll back a Helm
    release when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting an application using Helm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to remove an application deployed with Helm
    from your Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `helm ls` command with the `--all` parameter to list all the releases,
    including deleted revisions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Delete a release using the `--purge` parameter. The following command will
    completely remove the application from your cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will immediately terminate the Deployment and remove the
    Helm release from your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Adding new Helm repositories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, Helm only uses the official Helm/stable repository for lookups and
    often in the following chapters, we will need to add additional repositories from
    third-party vendors using the method explained in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to add additional Helm repositories to your
    source list:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the list of existing repositories. You should only see `stable` and `local` on
    the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'We need a persistent volume and authentication configured for our repository
    server. Create a file called `customhelmrepo.yaml` using the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a repository server using a persistent volume:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the service IP for `chartmuseum`. The following command will return an
    IP address, in our example, `10.3.0.37`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the new Helm repository to your list of repositories; in our case, the
    IP is `10.3.0.37`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the list of existing repositories:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: There are many options available to host your chart repository. You can deploy
    a local repository using an open source Helm repository server called **ChartMuseum**,
    on an S3 bucket, GitHub pages, or a classic web server. For simplicity, we used
    Helm itself to deploy a server. You can find alternative hosting methods for Helm
    charts under the *See also* section.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Helm chart
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to build a custom Helm chart to be published
    in your local `chartmuseum` repository:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a chart called `mychart`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit your chart structure as you like and test the templates for possible errors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Test your application using `--dry-run`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '4\. Build the Helm chart. By running the following command, you will generate
    a tarball package of your Helm repository from the `mychart` location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the Helm repository server address with your Helm server and upload
    this Helm chart package using a URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Now you have learned how to create, lint, test, package, and upload your new
    chart to your local ChartMuseum-based Helm repository.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe showed you how to install the Helm package manager and build your
    first Helm chart.
  prefs: []
  type: TYPE_NORMAL
- en: When we built the Helm chart in the *Building a Helm chart* recipe, in step
    1, the `helm create` command created a couple of files as a template under the
    `chart` folder. You can start by editing these files or create them from scratch
    when you become more comfortable with the structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `helm create` command creates the templates that construct our Helm chart.
    The contents and their functionality are explained here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: In the *Building a Helm chart* recipe, in step 3, `helm install`, when used
    along with the `--dry-run` parameter, sends the chart to the server and returns
    the rendered template only instead of installing it. This is usually used for
    testing Helm charts.
  prefs: []
  type: TYPE_NORMAL
- en: In the same recipe, in step 4, the `helm package` command packages your complete
    chart into a chart archive, basically a tarball.
  prefs: []
  type: TYPE_NORMAL
- en: In step 5, we used the `curl` command to send the packaged tarball binary to
    our ChartMuseum server, an HTTP server, so it can serve our Helm chart archives
    when it receives `GET` requests from the `helm` command.
  prefs: []
  type: TYPE_NORMAL
- en: Now you have learned how to install Helm charts and create your Helm charts
    in your local repositories, you will be able to install the third-party charts
    required in the next chapters, as well as building your own artifacts in your
    CI/CD pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Helm documentation: [https://docs.helm.sh](https://docs.helm.sh)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternative hosting methods for Helm charts: https://v2.helm.sh/docs/chart_repository/
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with a chart template: [https://helm.sh/docs/chart_template_guide/ ](https://helm.sh/docs/chart_template_guide/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fields required to build the `Chart.yaml` file: [https://v2.helm.sh/docs/chart_template_guide/](https://v2.helm.sh/docs/chart_template_guide/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: J-Frog Container Registry, a powerful Hybrid Docker and Helm registry: [https://jfrog.com/container-registry/](https://jfrog.com/container-registry/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying and operating applications using Kubernetes operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes operators are another method of bundling, deploying, and managing application
    for Kubernetes. Operators are a bit more complex than a package manager like Helm.
    An operator helps to remove manual steps, application-specific preparation, and
    post-deployment steps, and even automates second-day operations such as scaling
    or upgrading them for the user.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, an application's requirements might be validated differently
    based on the platform on which it is installed or may require changes to its configuration
    and interaction with external systems.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will deploy two operators for popular stateful applications
    based on two different operator frameworks and learn what functionalities they
    offer.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure you have a Kubernetes cluster ready and kubectl configured to manage
    the cluster resources.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section is further divided into the following subsections to ease the
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing **KUDO** (short for **Kubernetes Universal Declarative Operator**)
    and the KUDO kubectl plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the Apache Kafka operator using KUDO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Operator Lifecycle Manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the Zalando PostgreSQL operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing KUDO and the KUDO kubectl plugin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before you can install applications using KUDO operators, you need to install
    KUDO. We will install KUDO using `brew`, a package manager used in Linux for the
    simple installation of binaries on Linux; therefore, you will also need brew installed
    if you haven''t done it already:'
  prefs: []
  type: TYPE_NORMAL
- en: Follow the Helm instructions in the *Deploying workloads using Helm charts* recipe
    to get Helm running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install `brew` by using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Install KUDO and the `kudo kubectl` plugin using `brew install` by running
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Install KUDO as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: It is worth mentioning that Kubernetes operators are a developing concept in
    the Kubernetes community. There are multiple operator frameworks, such as the
    Red Hat Operator Framework, D2iQ's KUDO, and many others out there. Also, for
    each workload, you will find a number of operators developed by the community.
    I recommend testing a few flavors before you decide to use an operator to find
    the operator that fits your use case.
  prefs: []
  type: TYPE_NORMAL
- en: Now you have the KUDO controller installed to test some stateful running applications
    using Kubernetes Operators.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Apache Kafka Operator using KUDO
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are multiple Kafka operators listed in the *See also* section, such as
    Strimzi, Banzai Cloud, Confluent, krallistic, and others. Although I don't have
    any preference in this recipe, as an example, we will deploy the Apache Kafka
    Operator based on the KUDO Operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Kafka requires ZooKeeper. Let''s create a ZooKeeper cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a Kafka cluster using the KUDO Kafka Operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'List KUDO Operators by querying the `Operators` CRD APIs as follows. After
    deploying Kafka, which also has a ZooKeeper dependency, you should see both `kafka`
    and `zookeeper` operators:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'List KUDO instances:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Now you have learned how to deploy both ZooKeeper and Kafka using the KUDO Operator.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Operator Lifecycle Manager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before you can install applications using Red Hat Operator Framework Operators,
    you need to install **Operator Lifecycle Manager** (**OLM**). Note that OLM is
    installed by default in OpenShift 4.0 and precedent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install OLM. It is required for our next recipe,* Installing the Zalando PostgreSQL
    Operator*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Now you have OLM installed to test some stateful running applications using
    an Operator Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Zalando PostgreSQL Operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are multiple PostgreSQL Operators listed in the *See also* section, such
    as CrunchyDB and Zalando. In this recipe, as an example, we will deploy the Zalando
    PostgreSQL Operator to manage the life cycle of PostgreSQL Deployments in your
    Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to get the Zalando PostgreSQL Operator deployed
    using the Operator Hub:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `postgres-Operator` from the Operator Hub:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that `postgres-Operator` is running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the PostgreSQL Operator is up and running, let''s deploy the Postgres
    Operator UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Deploy PostgreSQL. The following command will create a small two-instance PostgreSQL
    cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'List PostgreSQL instances that are managed by the Zalando Operator. It will
    show a cluster named `acid-minimal-cluster`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'First get your cluster credentials and connect to your PostgreSQL using the
    `psql` interactive PostgreSQL terminal as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Delete your PostgreSQL cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Now you have learned how to simply use popular Kubernetes Operators to deploy
    and manage workloads on Kubernetes. You can apply this knowledge later to simplify
    the life cycle management of stateful workloads you use in the development and
    production environment.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deep dive on the Kubernetes Operators at KubeCon 2018: [https://developers.redhat.com/blog/2018/12/18/kubernetes-Operators-in-depth/](https://developers.redhat.com/blog/2018/12/18/kubernetes-operators-in-depth/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List of Kubernetes Operators by community: [https://github.com/Operator-framework/awesome-Operators](https://github.com/operator-framework/awesome-operators)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List of Kubernetes Operators build using the Red Hat Operator SDK: [https://Operatorhub.io/](https://operatorhub.io/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Kubernetes Universal Declarative Operator** (**KUDO**): [https://kudo.dev/](https://kudo.dev/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Repository for KUDO-based Operators: [https://github.com/kudobuilder/Operators](https://github.com/kudobuilder/operators)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Python framework to write Kubernetes Operators in just a few lines of code: [https://github.com/zalando-incubator/kopf](https://github.com/zalando-incubator/kopf)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A list of alternative Kafka Operators:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apache Kafka Operator running on OpenShift: [http://strimzi.io/](http://strimzi.io/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: KUDO Kafka Operator: [https://github.com/kudobuilder/Operators/tree/master/repository/kafka](https://github.com/kudobuilder/operators/tree/master/repository/kafka)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yet another Kafka Operator for Kubernetes: [https://github.com/banzaicloud/kafka-Operator](https://github.com/banzaicloud/kafka-operator)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Istio Operator: [https://github.com/banzaicloud/istio-Operator](https://github.com/banzaicloud/istio-operator)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A list of alternative PostgreSQL Operators:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Crunchy Data PostgreSQL Operator: [https://github.com/CrunchyData/postgres-Operator](https://github.com/CrunchyData/postgres-operator)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zalando PostgreSQL Operator: [https://github.com/zalando/postgres-Operator](https://github.com/zalando/postgres-operator)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying and managing the life cycle of Jenkins X
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jenkins X is an open source solution that offers software developers pipeline
    automation, built-in GitOps, CI, automated testing, and CD, known as CI/CD, in
    Kubernetes. Jenkins X is highly focused on accelerating software delivery at a
    large scale using the Kubernetes ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will focus on Jenkins X recipes and create a Kubernetes
    cluster with CI/CD capabilities on your cloud provider.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the following recipes, you will learn how to create a static Jenkins Server
    to deploy Kubernetes clusters with pipeline automation and automated CI/CD with
    GitOps promotion and preview environments.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe requires kubectl and Helm. For this recipe, we will use **GKE** (short
    for** Google Kubernetes Engine**), therefore the gcloud CLI tool needs to be installed
    as well. You also need to have a proper GitHub organization and GitHub account
    created.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section is further divided into the following subsections to ease the
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Jenkins X CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Jenkins X Kubernetes cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying Jenkins X components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Switching Kubernetes clusters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating cluster conformance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the Jenkins X CLI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Jenkins X CLI `jx` is used along with your preferred cloud provider CLI
    to orchestrate the Deployment of the Kubernetes cluster. Jenkins X supports Azure,
    AWS, **GCP** (short for** Google Cloud Platform**), IBM Cloud, Oracle Cloud, Minikube,
    Minishift, and OpenShift as the provider for the Deployment. For this recipe,
    we will use GKE. See the Jenkins X documentation for other vendor instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to install Jenkins X CLI tool:'
  prefs: []
  type: TYPE_NORMAL
- en: Visit the JX release site ([https://github.com/jenkins-x/jx/releases](https://github.com/jenkins-x/jx/releases))
    and note the latest release version. At the time of writing, the latest release
    was v2.0.905.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the release version in the following command. Download and install the
    latest version of the Jenkins X CLI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Now you have the Jenkins X CLI installed, you can move on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Jenkins X Kubernetes cluster
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may prefer other cloud vendors or on-premises deployment. For this recipe,
    we will use GKE. See the Jenkins X documentation for other vendor instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to create your first Jenkins X Kubernetes
    cluster using `jx`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Kubernetes cluster with GKE using the `jx` command with the `gke`
    parameter as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Select your Google Cloud project; in our example, `devopscookbook`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `us-central1-a` when asked to pick a Google Cloud zone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Static Jenkins Server and Jenkinsfiles as the installation type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter your GitHub username:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter your GitHub API token. Go to the GitHub Token page at [https://github.com/settings/tokens/new?scopes=repo,read:user,read:org,user:email,write:repo_hook,delete_repo](https://github.com/settings/tokens/new?scopes=repo,read:user,read:org,user:email,write:repo_hook,delete_repo)
    to get your API token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, Jenkins X will set the ingress rules to use the magic DNS `nip.io`
    domain:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter `Yes` to the following question:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Select the GitHub organization where you want to create the environment repository;
    in our case, `k8devopscookbook`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see a message similar to the following when your Deployment is successful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: You can also find your admin password in the preceding output.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying Jenkins X components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to verify that all Jenkins X components
    are running as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Confirm that all pods are running. All pods in the `jx` namespace should be
    in a running state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the list of Jenkins X service URLs that we will need to connect. You will
    have a list of `jenkins`, `chartmuseum`, `docker-registry`, and `nexus` URLs similar
    to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Now you can connect to the Jenkins UI by visiting the first URL from the preceding
    output of the `jx get urls` command.
  prefs: []
  type: TYPE_NORMAL
- en: Switching Kubernetes clusters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to switch between the Kubernetes clusters
    that you have access to using Jenkins X:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get the existing Kubernetes clusters by listing the contexts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Select the cluster you would like to use. In our case, we switch to the `gke_devopscookbook` cluster
    that we created using Jenkins X:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Now you know how to switch context using the Jenkins X CLI.
  prefs: []
  type: TYPE_NORMAL
- en: Validating cluster conformance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you switch between the existing Kubernetes clusters, it is suggested that
    you validate the cluster configuration before you run your pipelines. Let''s perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Validate that your cluster is compliant. These tests will typically take an
    hour:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the status. This command will return a `Compliance tests completed` message
    only after tests are completed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Review the results. If your cluster is compliant all executed test results
    should be displayed as `PASSED`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Now you know how to check cluster conformance results.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating a Jenkins X Kubernetes cluster* recipe showed you how to provision
    the Kubernetes cluster for pipeline automation and automated CI/CD.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Creating a Jenkins X Kubernetes cluster* recipe, in step 1, we created
    the cluster using the Jenkins X CLI. By default, Jenkins X uses `n1-standard-2`
    as the machine type on GKE and creates a cluster with a minimum of three and a
    maximum of five nodes settings. Remember that you could also use an existing Kubernetes
    cluster instead of creating a new one. Most of the settings will be saved and
    remembered next time you run the `create cluster` command.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins X deploys a couple of services, including Jenkins, a private Docker
    registry, a private Helm repository ChartMuseum, Monocular to manage Helm charts,
    and a Maven and npm repository called **Nexus**.
  prefs: []
  type: TYPE_NORMAL
- en: As you will find in your repository after the installation, Jenkins X creates
    two Git repositories, one for your staging environment and one for production.
    Jenkins X uses the GitOps approach to promote code from one repo to another through
    Git **pull requests** (**PRs**). Therefore each repo contains a Jenkins pipeline
    to handle promotions.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Creating a Jenkins X Kubernetes cluster* recipe, in step 7, Jenkins
    X uses the magic DNS service and converts the IP address of your GKE cluster into
    a DNS discoverable hostname using a service via `nip.io`. If you have your own
    domain and the DNS is configured to point to your cluster, you can update the
    settings later using the `jx upgrade ingress --cluster` command.
  prefs: []
  type: TYPE_NORMAL
- en: Later, in step 10, you will get the default password assigned to your admin
    user. You will be asked to change this password when you first connect to the
    Jenkins UI via the URL provided in this step.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is also useful to have knowledge of the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: Importing an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upgrading Jenkins X
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting a Jenkins X Kubernetes cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing an application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to import an existing application into the
    Jenkins X environment:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone or use an existing application. As an example, we will create a clone
    of the `hello-world` example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove the Git files from the `cloned` directory. This will remove the Git
    history from the directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command in the folder to import the source code into Jenkins
    X:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Upgrading a Jenkins X application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to upgrade a Jenkins X application and its
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, upgrade the `jx` CLI. This command will upgrade the application if there
    is a new version available in the remote repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you are on the latest CLI, upgrade the platform using the following command.
    The new `jx` CLI command will upgrade the platform components if a new version
    exists:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Deleting a Jenkins X Kubernetes cluster
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Removing managed Kubernetes clusters may be tricky, especially if you are not
    the one who created them. Since we used GKE to create them, it is faster to use
    the gcloud CLI tool to delete them. Let''s perform the following steps to delete
    the Kubernetes cluster we created with Jenkins X:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your cloud provider''s instructions to delete the Kubernetes cluster. In
    our case, we used GKE for the recipe. First, list the clusters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Delete the cluster using the `clustername` from the output of step 1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Now you have learned how to use Jenkins X to create your cluster. This knowledge
    has prepared you for [Chapter 3](811c24c7-debf-4487-91e9-81db1520c0aa.xhtml),
    *Building CI/CD Pipelines*, where you will continue to use the environment and
    learn to import an application as a pipeline in Jenkins X.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Introduction to Jenkins: [https://jenkins.io/blog/2018/03/19/introducing-jenkins-x/](https://jenkins.io/blog/2018/03/19/introducing-jenkins-x/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Jenkins X repository and binaries: [https://github.com/jenkins-x/jx](https://github.com/jenkins-x/jx)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Jenkins X tutorials: [https://jenkins-x.io/tutorials/](https://jenkins-x.io/tutorials/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Jenkins X getting started instructions: [https://jenkins-x.io/getting-started/install-on-cluster/](https://jenkins-x.io/getting-started/install-on-cluster/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Jenkins X CLI commands and an explanation of how to use them: [https://jenkins-x.io/commands/jx/](https://jenkins-x.io/commands/jx/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying and managing the life cycle of GitLab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitLab is a complete DevOps tool chain, delivered in a single application platform.
    GitLab provides all the necessary tooling you need to manage, plan, create, verify,
    package, release, configure, monitor, and secure your applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will cover the deployment and life cycle management of GitLab
    using Helm charts.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the following recipe, you will learn how to install GitLab on an existing
    Kubernetes cluster where you can manage the entire DevOps life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe requires kubectl and Helm, as well as an existing Kubernetes cluster.
    For this recipe, we will use the cluster we deployed on AWS in [Chapter 1](a8580410-3e1c-4e28-8d18-aaf9d38d011f.xhtml), *Building
    Production-Ready Kubernetes Clusters.* You should be able to run the same recipe
    on any Kubernetes cluster version 1.11 or higher with a minimum of 6vCPU and 16
    GB of RAM.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section is further divided into the following subsections to ease the
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing GitLab using Helm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to the GitLab dashboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the first GitLab user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upgrading GitLab
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting GitLab
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing GitLab using Helm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For this recipe, we will use the Kubernetes cluster on Amazon EC2, which we
    deployed in *[Chapter 1,](a8580410-3e1c-4e28-8d18-aaf9d38d011f.xhtml) Building
    Production-Ready Kubernetes Clusters* under the *Configuring a Kubernetes cluster
    on Amazon Web Services *section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add GitLab Helm chart repos to your local repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the following `externalUrl` with your domain name and deploy GitLab
    using Helm in the `gitlab` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: For simplicity, I would recommend using your own certificates following the
    *Using auto-generated self-signed certificates* sections. Then you can map your
    DNS name to the created ELB using a `CNAME` record.
  prefs: []
  type: TYPE_NORMAL
- en: 'The deployment may take around 10-15 minutes. Confirm the service status and
    note the external IP of the `gitlab-gitlab-ce` service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Connecting to the GitLab dashboard
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to get the GitLab service address to connect
    using your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get the external address of your GitLab service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Open the address returned to the preceding command in a browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Get the default root password created by GitLab by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Set a new password and sign in using the `root` user and your new password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To use a custom URL, create a `CNAME` record on your DNS with an alias to the
    external URL used in step 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating the first GitLab user
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, we use the root account to manage the GitLab Deployment. All new
    users need to log in to GitLab using their own credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to create new users:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in as the `root` user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After you log in to the GitLab dashboard, you will see a welcome screen similar
    to the following. Click Add people on the Welcome to GitLab screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/8587bddd-31a1-4045-ab3a-7dae018094fa.png)'
  prefs: []
  type: TYPE_IMG
- en: Under the New User menu, enter at least the name, username, and email fields,
    and then click on Create User to save the changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upgrading GitLab
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'GitLab frequently releases new versions with additional functionality. Once
    in a while, you may also need to upgrade to get bug fixes. Upgrading can be done
    easily using the Helm upgrade. Let''s perform the following steps to upgrade GitLab
    to a new version:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, export the currently used arguments into a YAML file using the `helm
    get values` command as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Upgrade the chart repositories to get new versions available from the remote
    repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'List the available chart versions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the same arguments with the new version to upgrade:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Installing GitLab using Helm* recipe showed you how to provision GitLab
    with all built-in components and external dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Installing GitLab using Helm* recipe, in step 1, we made sure that official
    up-to-date GitLab Helm chart repos were added into the local repository list.
    Otherwise, older versions of the GitLab charts from the stable/gitlab repo would
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: In the same recipe, in step 2, we deployed GitLab using Helm charts in the `gitlab`
    namespace using the `--namespace gitlab` parameter. This command not only deployed
    GitLab components but also Redis, PostgreSQL, Minio object storage for data persistence,
    Cert Manager, a local container registry, and the nginx ingress controller.
  prefs: []
  type: TYPE_NORMAL
- en: To use existing Deployments of PostgreSQL, Redis, Gitaly, S3 Storage, and the
    ingress controller, follow the advanced configuration instruction a described
    here: [https://docs.gitla](https://docs.gitlab.com/charts/advanced/)[b.com/charts/advanced/](https://docs.gitlab.com/charts/advanced/).
  prefs: []
  type: TYPE_NORMAL
- en: By default, GitLab Helm charts deploy the enterprise version of GitLab. By using
    the `--set global.edition=ce` parameter, we switched the Deployment to the free
    Community Edition.
  prefs: []
  type: TYPE_NORMAL
- en: After we executed the command in the *Installing GitLab using Helm* recipe,
    in step 2, the Helm chart assumes that we have an existing default storage class
    and it uses the default one to create the PVCs and PVs for the stateful application.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is also useful to have knowledge of the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: Using your own wildcard certificate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using autogenerated self-signed certificates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling a GitLab Operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting GitLab
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using your own wildcard certificate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Helm chart installation of GitLab supports TLS termination using the nginx
    controller. When you install GitLab, you have options. For improved security,
    you can use Cert Manager and Let''s Encrypt or choose to use your own wildcard
    certificate. In this recipe, we will explain using your own wildcard certificates
    option, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add your certificate and key to the cluster as a secret:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Deploy GitLab from the Helm chart using the following additional parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Using autogenerated self-signed certificates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you can''t effo using your own wildcard certificate and still want to get
    GitLab quickly up for testing or smaller use cases, you can also use autogenerated
    self-signed certificates. In this recipe, we will explain using self-signed certificates,
    which can be useful in environments where Let''s Encrypt is not an option, but
    SSL security is still needed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In cases where your domain is not reachable from the Let''s Encrypt servers,
    you can provide an autogenerated self-signed wildcard certificate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Retrieve the certificate, which can be imported into a web browser or system
    store later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Enabling the GitLab Operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'GitLab provides an experimental Operator. This Operator controls the upgrade
    process and helps to perform rolling upgrades without downtime. Let''s perform
    the following steps to get the GitLab Operator running:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, make sure CRD is in place by enabling the global Operator using the
    Helm parameters as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Deploy the GitLab Operator using the Helm charts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Deleting GitLab
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to completely remove the GitLab Deployment
    we created in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Delete the existing release of GitLab using Helm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'You may also want to remove the namespace to make sure there is nothing left
    behind:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Now you have learned how to get GitLab up and running on Kubernetes. This knowledge
    will be required in [Chapter 3](811c24c7-debf-4487-91e9-81db1520c0aa.xhtml), *Building
    CI*/*CD Pipelines*, in the *GitLab* section, where you will learn how to import
    an application and create a pipeline in GitLab.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GitLab cloud-native Helm chart documentation: [https://docs.gitlab.com/charts/](https://docs.gitlab.com/charts/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Advanced configuration options: [https://docs.gitlab.com/charts/advanced/](https://docs.gitlab.com/charts/advanced/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GitLab Operator: [https://docs.gitlab.com/charts/installation/Operator.html](https://docs.gitlab.com/charts/installation/operator.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternative ways to install GitLab Community Edition: [https://about.gitlab.com/install/?version=ce/](https://about.gitlab.com/install/?version=ce/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
