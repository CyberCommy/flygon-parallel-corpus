- en: Template Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Generic programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overloading function templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicit class specializations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partial specializations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's now start learning generic programming.
  prefs: []
  type: TYPE_NORMAL
- en: Generic programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generic programming is a style of programming that helps you develop reusable
    code or generic algorithms that can be applied to a wide variety of data types.
    Whenever a generic algorithm is invoked, the data types will be supplied as parameters
    with a special syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we would like to write a `sort()` function, which takes an array
    of inputs that needs to be sorted in an ascending order. Secondly, we need the
    `sort()` function to sort `int`, `double`, `char`, and `string` data types. There
    are a couple of ways this can be solved:'
  prefs: []
  type: TYPE_NORMAL
- en: We could write four different `sort()` functions for each data type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could also write a single macro function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Well, both approaches have their own merits and demerits. The advantage of the
    first approach is that, since there are dedicated functions for the `int`, `double`,
    `char`, and `string` data types, the compiler will be able to perform type checking
    if an incorrect data type is supplied. The disadvantage of the first approach
    is that we have to write four different functions even though the logic remains
    the same across all the functions. If a bug is identified in the algorithm, it
    must be fixed separately in all four functions; hence, heavy maintenance efforts
    are required. If we need to support another data type, we will end up writing
    one more function, and this will keep growing as we need to support more data
    types.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of the second approach is that we could just write one macro for
    all the data types. However, one very discouraging disadvantage is that the compiler
    will not be able to perform type checking, and this approach is more prone to
    errors and may invite many unexpected troubles. This approach is dead against
    object-oriented coding principles.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++ supports generic programming with templates, which has the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: We just need to write one function using templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Templates support static polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Templates offer all the advantages of the two aforementioned approaches, without
    any disadvantages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic programming enables code reuse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The resultant code is object-oriented
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The C++ compiler can perform type checking during compile time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy to maintain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports a wide variety of built-in and user-defined data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, the disadvantages are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Not all C++ programmers feel comfortable writing template-based coding, but
    this is only an initial hiccup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In certain scenarios, templates could bloat your code and increase the binary
    footprint, leading to performance issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A function template lets you parameterize a data type. The reason this is referred
    to as generic programming is that a single template function will support many
    built-in and user-defined data types. A templatized function works like a **C-style
    macro**, except for the fact that the C++ compiler will type check the function
    when we supply an incompatible data type at the time of invoking the template
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'It will be easier to understand the template concept with a simple example,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Isn't it really interesting to see just one template function doing all the
    magic? Yes, that's how cool C++ templates are!
  prefs: []
  type: TYPE_NORMAL
- en: Are you curious to see the assembly output of a template instantiation? Use
    the command, **`g++ -S main.cpp`**.
  prefs: []
  type: TYPE_NORMAL
- en: Code walkthrough
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code defines a function template. The keyword, `template <typename
    T, int size>`, tells the compiler that what follows is a function template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The line, `void sort ( T input[] )`, defines a function named `sort`, which
    returns `void` and receives an input array of type `T`. The `T` type doesn't indicate
    any specific data type. `T` will be deduced at the time of instantiating the function
    template during compile time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code populates an integer array with some unsorted values and
    prints the same to the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following line will instantiate an instance of a function template for
    the `int` data type. At this point, `typename T` is substituted and a specialized
    function is created for the `int` data type. The scope-resolution operator in
    front of `sort`, that is, `::sort()`, ensures that it invokes our custom function, `sort()`,
    defined in the global namespace; otherwise, the C++ compiler will attempt to invoke
    the `sort()` algorithm defined in the `std namespace`, or from any other namespace
    if such a function exists. The `<int, 10>` variable tells the compiler to create
    an instance of a function, substituting `typename T` with `int`, and `10` indicates
    the size of the array used in the template function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines will instantiate two additional instances that support
    a `double` array of `5` elements and a `string` array of `6` elements respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are curious to know some more details about how the C++ compiler instantiates
    the function templates to support `int`, `double`, and `string`, you could try
    the Unix utilities, `nm` and `c++filt`. The `nm` Unix utility will list the symbols
    in the symbol table, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there are three different overloaded `sort` functions in the
    binary; however, we have defined only one template function. As the C++ compiler
    has mangled names to deal with function overloading, it is difficult for us to
    interpret which function among the three functions is meant for the `int`, `double`,
    and `string` data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is a clue: the first function is meant for `double`, the second
    is meant for `int`, and the third is meant for `string`. The name-mangled function
    has `_Z4sortIdLi5EEvPT_` for `double`, `_Z4sortIiLi10EEvPT_` for `int`, and `_Z4sortINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEELi6EEvPT_`
    for `string`. There is another cool Unix utility to help you interpret the function
    signatures without much struggle. Check the following output of the `c++filt`
    utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Hopefully, you will find these utilities useful while working with C++ templates.
    I'm sure these tools and techniques will help you to debug any C++ application.
  prefs: []
  type: TYPE_NORMAL
- en: Overloading function templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overloading function templates works exactly like regular function overloading
    in C++. However, I'll help you recollect the C++ function overloading basics.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function overloading rules and expectations from the C++ compiler are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The overloaded function names will be the same.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The C++ compiler will not be able to differentiate between overloaded functions
    that differ only by a return value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of overloaded function arguments, the data types of those arguments,
    or their sequence should be different. Apart from the other rules, at least one
    of these rules described in the current bullet point should be satisfied, but
    more compliance wouldn't hurt, though.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The overloaded functions must be in the same namespace or within the same class
    scope.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If any of these aforementioned rules aren't met, the C++ compiler will not treat
    them as overloaded functions. If there is any ambiguity in differentiating between
    the overloaded functions, the C++ compiler will report it promptly as a compilation
    error.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is time to explore this with an example, as shown in the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Code walkthrough
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code is a non-template version of our custom `sort()`  function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Non-template functions and template functions can coexist and participate in
    function overloading. One weird behavior of the preceding function is that the
    size of the array is hardcoded.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second version of our `sort()` function is a template function, as shown
    in the following code snippet. Interestingly, the weird issue that we noticed
    in the first non-template `sort()` version is addressed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, both the data type and the size of the array are passed
    as template arguments, which are then passed to the function call arguments. This
    approach makes the function generic, as this function can be instantiated for
    any data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third version of our custom `sort()` function is also a template function,
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding template function takes a C-style array; hence, it also expects
    the user to indicate its size. However, the size of the array could be computed
    within the function, but for demonstration purposes, I need a function that takes
    two arguments. The previous function isn't recommended, as it uses a C-style array;
    ideally, we would use one of the STL containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s understand the main function code. The following code declares
    and initializes the STL array container with six values, which is then passed
    to our `sort()` function defined in the default namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will invoke the non-template `sort()` function. An important
    point to note is that, whenever C++ encounters a function call, it first looks
    for a non-template version; if C++ finds a matching non-template function version,
    its search for the correct function definition ends there. If the C++ compiler
    isn't able to identify a non-template function definition that matches the function
    call signature, then it starts looking for any template function that could support
    the function call and instantiates a specialized function for the data type required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This will invoke the template function that receives a single argument. As there
    is no non-template `sort()` function that receives an `array<float,6>` data type,
    the C++ compiler will instantiate such a function out of our user-defined `sort()`
    template function with a single argument that takes `array<float, 6>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same way, the following code triggers the compiler to instantiate a
    `double` version of the template `sort()` function that receives `array<double,
    6>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the following code will instantiate an instance of the template `sort()`
    that receives two arguments and invokes the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If you have come this far, I'm sure you like the C++ template topics discussed
    so far.
  prefs: []
  type: TYPE_NORMAL
- en: Class template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ templates extend the function template concepts to classes too, and enable
    us to write object-oriented generic code. In the previous sections, you learned
    the use of function templates and overloading. In this section, you will learn
    writing template classes that open up more interesting generic programming concepts.
  prefs: []
  type: TYPE_NORMAL
- en: A `class` template lets you parameterize the data type on the class level via
    a template type expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand a `class` template with the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: C++ template function overloading is a form of static or compile-time polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use `myalgorithm.h` in the following `main.cpp` program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s quickly compile the program using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Code walkthrough
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code declares a class template. The keyword, `template <typename
    T, int size>`, can be replaced with `<class T, int size>`. Both keywords can be
    interchanged in function and class templates; however, as an industry best practice, `template<class
    T>` can be used only with class templates to avoid confusion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the overloaded `sort()` methods is defined inline as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The second overloaded `sort()` function is just declared within the class scope,
    without any definition, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `sort()` function is defined outside the class scope, as shown
    in the following code snippet. The weird part is that we need to repeat the template
    parameters for every member function that is defined outside the class template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Otherwise, the class template concepts remain the same as that of function templates.
  prefs: []
  type: TYPE_NORMAL
- en: Would you like to see the compiler-instantiated code for templates?  Use the
    **`g++ -fdump-tree-original main.cpp -std=c++17`** command.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit class specializations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this chapter, you have learned how to do generic programming with
    function templates and class templates. As you understand the class template,
    a single template class can support any built-in and user-defined data types.
    However, there are times when we need to treat certain data types with some special
    treatment with respect to the other data types. In such cases, C++ offers us explicit
    class specialization support to handle selective data types with differential
    treatment.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the STL `deque` container; though `deque` looks fine for storing, let's
    say, `string`, `int`, `double`, and `long`, if we decide to use `deque` to store
    a bunch of `boolean` types, the `bool` data type takes at least one byte, while
    it may vary as per compiler vendor implementation. While a single bit can efficiently
    represent true or false, a boolean at least takes one byte, that is, 8 bits, and
    the remaining 7 bits are not used. This may appear as though it's okay; however,
    if you have to store a very large `deque` of booleans, it definitely doesn't appear
    to be an efficient idea, right? You may think, what's the big deal? We could write
    another specialized class or template class for `bool`. But this approach requires
    end users to use different classes for different data types explicitly, and this
    doesn't sound like a good design either, right? This is exactly where C++'s explicit
    class specialization comes in handy.
  prefs: []
  type: TYPE_NORMAL
- en: The explicit template specialization is also referred to as full-template specialization.
  prefs: []
  type: TYPE_NORMAL
- en: Never mind if you aren't convinced yet; the following example will help you
    understand the need for explicit class specialization and how explicit class specialization
    works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us develop a `DynamicArray` class to support a dynamic array of any data
    type. Let''s start with a class template, as shown in the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `DynamicArray` template class internally makes use of the STL
    `deque` class. Hence, you could consider the `DynamicArray` template class a custom
    adapter container. Let''s explore how the `DynamicArray` template class can be
    used in `main.cpp` with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s quickly compile the program using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Great! Our custom adapter container seems to work fine.
  prefs: []
  type: TYPE_NORMAL
- en: Code walkthrough
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s zoom in and try to understand how the previous program works. The following
    code tells the C++ compiler that what follows is a class template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `DynamicArray` class makes use of STL `deque` internally,
    and an iterator for `deque` is declared with the name, `pos`.  This iterator, `pos`,
    is utilized by the `Dynamic` template class to provide high-level methods such
    as the `initialize()`, `appendValue()`, `hasNextValue()`, and `getValue()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: The `initialize()` method initializes the `deque` iterator `pos` to the first
    data element stored within `deque`. The `appendValue( T element )` method lets
    you add a data element at the end of `deque`.  The `hasNextValue()` method tells
    whether the `DynamicArray` class has further data values stored--`true` indicates
    it has further values and `false` indicates that the `DynamicArray` navigation
    has reached the end of `deque`. The `initialize()` method can be used to reset
    the `pos` iterator to the starting point when required. The `getValue()` method
    returns the data element pointed by the `pos` iterator at that moment. The `getValue()`
    method doesn't perform any validation; hence, it must be combined with `hasNextValue()`
    before invoking `getValue()`  to safely access the values stored in `DynamicArray`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s understand the `main()` function. The following code declares a
    `DynamicArray` class that stores the `int` data type; `DynamicArray<int> intArray`
    will trigger the C++ compiler to instantiate a `DynamicArray` class that is specialized
    for the `int` data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The values `100`, `200`, `300`, and `400` are stored back to back within the
    `DynamicArray` class. The following code ensures that the `intArray` iterator
    points to the first element. Once the iterator is initialized, the values stored
    in the `DynamicArray` class are printed with the `getValue()` method, while `hasNextValue()`
    ensures that the navigation hasn''t reached the end of the `DynamicArray` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Along the same lines, in the main function, a `char DynamicArray` class is created,
    populated with some data, and printed. Let's skip `char` `DynamicArray` and directly
    move on to the `DynamicArray` class that stores `bool`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding code snippet, we can see everything looks okay, right? Yes,
    the preceding code works perfectly fine; however, there is a performance issue
    with the `DynamicArray` design approach. While `true` can be represented by `1`
    and `false` can be represented by `0`, which requires just 1 bit, the preceding `DynamicArray` class
    makes use of 8 bits to represent `1` and 8 bits to represent `0`, which we must
    fix without forcing end users to choose a different `DynamicArray` class that
    works efficiently for `bool`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s fix the issue by using explicit class template specialization with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Did you notice the template class declaration? The syntax for template class
    specialization is `template <> class DynamicArray<bool> { };`.  The `class` template
    expression is empty `<>` and the name of the `class` template that works for all
    data types and the name of the class that works the for the `bool` data type are
    kept the same with the template expression, `<bool>`.
  prefs: []
  type: TYPE_NORMAL
- en: If you observe closely, the specialized `DynamicArray` class for `bool` internally
    makes use of `deque< bitset<8> >`, that is, `deque` of `bitsets` of 8 bits, and,
    when required, `deque` will automatically allocate more `bitset<8>` bits. The
    `bitset` variable is a memory-efficient STL container that consumes just 1 bit
    to represent `true` or `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'With the class template specialization in place, we can observe from the following that the
    main code seems the same for `bool`, `char`, and `double`, although the primary
    template class, `DynamicArray`, and the specialized `DynamicArray<bool>` class
    are different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: I'm sure you will find this C++ template specialization feature quite useful.
  prefs: []
  type: TYPE_NORMAL
- en: Partial template specialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike explicit template specialization, which replaces the primary template
    class with its own complete definitions for a specific data type, partial template
    specialization allows us to specialize a certain subset of template parameters supported
    by the primary template class, while the other generic types can be the same as
    the primary template class.
  prefs: []
  type: TYPE_NORMAL
- en: 'When partial template specialization is combined with inheritance, it can do
    more wonders, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main.cpp` file will have the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, you may have noticed that the primary template class
    name and the partially specialized class name are the same as in the case of full
    or explicit template class specialization. However, there are some syntactic changes
    in the template parameter expression. In the case of a complete template class
    specialization, the template parameter expression will be empty, whereas, in the
    case of a partially specialized template class, listed appears, as shown in the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The expression, `template<typename T1, typename T2, typename T3>`, is the template
    parameter expression used in the primary class template class, and `MyTemplateClass<
    T1, T2*, T3*>` is the partial specialization done by the second class. As you
    can see, the second class has done some specialization on `typename T2` and `typename
    T3`, as they are used as pointers in the second class; however, `typename T1`
    is used as is in the second class.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the facts discussed so far, the second class also inherits the primary
    template class, which helps the second class reuse the public and protected methods
    of the primary template class. However, a partial template specialization doesn't
    stop the specialized class from supporting other functions.
  prefs: []
  type: TYPE_NORMAL
- en: While the `F1` function from the primary template class is replaced by the partially
    specialized template class, it reuses the `F2` function from the primary template
    class via inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s quickly compile the program using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: I hope that you find the partially specialized template class useful.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You are now aware of the motivation for using generic programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You are now familiar with function templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You know how to overload function templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You are aware of class templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You are aware of when to use explicit template specialization and when to use
    partially specialized template specialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Congrats! Overall, you have a good understanding of C++'s template programming.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn smart pointers.
  prefs: []
  type: TYPE_NORMAL
