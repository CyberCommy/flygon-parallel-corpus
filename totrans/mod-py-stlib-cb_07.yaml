- en: Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Searching, sorting, filtering—high-performance searching in sorted containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting the n^(th) element of any iterable—grabbing the *n^(th)* element of
    any iterable, generators too
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grouping similar items—splitting an iterable into groups of similar items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zipping—merging together data from multiple iterables into a single iterable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flattening a list of lists—converting a list of lists into a flat list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Producing permutations and—computing all possible permutations of a set of elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accumulating and reducing—applying binary functions to iterables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memoizing—speeding up computation by caching functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operators to functions—how to keep references to callables for a Python operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partials—reducing the number of arguments of a function by preapplying some
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic functions—functions that are able to change behavior according to the
    provided argument type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proper decoration—properly decorating a function to avoid missing its signature
    and docstring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Context managers—automatically running code whenever you enter and exit a block
    of code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying variable context managers—how a variable number of context managers
    can be applied
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing software, there are a whole bunch of things that you will find
    yourself doing over and over independently from the type of application you are
    writing.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from whole features that you might have to reuse across different applications
    (such as login, logging, and authorization), there are a bunch of little building
    blocks that you can reuse across any kind of software.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will try to gather a bunch of recipes that can be used as reusable
    snippets to achieve very common operations that you might have to perform independently
    from your software's purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Searching, sorting, filtering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Searching for an element is a very common need in programming. Looking up an
    item in a container is basically the most frequent operation that your code will
    probably do, so it's very important that it's quick and reliable.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting is frequently connected to searching, as it's often possible to involve
    smarter lookup solutions when you know your set is sorted, and sorting means continuously
    searching and moving items until they are in sorted order. So they frequently
    go together.
  prefs: []
  type: TYPE_NORMAL
- en: Python has built-in functions to sort containers of any type and look up items
    in them, even with functions that are able to leverage the sorted sequence.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, the following steps are to be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the following set of elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking up an element in the sequence can be done through the `in` operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Sorting can be done through the `sorted` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have a sorted container, we can actually use the `bisect` module to
    find contained entries faster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`bisect_search` can be used to know whether an entry is in the list, much like
    the `in` operator did:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'But, the advantage is that it can be a lot faster for many sorted entries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: So, the `bisect_search` function is 17 times faster than a plain lookup in our
    example.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `bisect` module uses dichotomic searching to look for the point of insertion
    of an element in a sorted container.
  prefs: []
  type: TYPE_NORMAL
- en: 'If an element exists in the array, its insertion position is exactly where
    the element is (as it should go exactly where it is):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If the element is missing, it will return the position of the next, immediately
    bigger element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This means we will get a position even for elements that do not exist in our
    container. That's why we compare the element at the returned position with the
    element that we were looking for. If the two are different, it means that the
    nearest element was returned and so the element itself was not found.
  prefs: []
  type: TYPE_NORMAL
- en: For the same reason, if the element is not found and it's bigger than the biggest
    value contained in the container, the length of the container itself is returned
    (as the element should go at the end), so we need to also ensure that we `index
    < len(container)` to check for elements that were not in the container.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've only sorted and looked up the entries themselves, but in many
    cases you will have complex objects where you are interested in sorting and searching
    for a specific property of an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you might have a list of people and you want to sort by their
    names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Sorting those people by name can be done by relying on the `key` argument of
    the `sorted` function, which specifies a callable that should return the value
    for which the entry should be sorted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Sorting through a `key` function is much faster than sorting through a comparison
    function. Because the `key` function only needs to be called once per item (then
    the result is preserved), while the `comparison` function needs to be called over
    and over every time that there are two items that need to be compared. So, if
    computing the value for which we should sort is expensive, the `key` function
    approach can achieve significant performance improvements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the problem is that `bisect` doesn''t allow us to provide a key, so to
    be able to use `bisect` on the people list, we would have to first build a `keys`
    list where we can apply the `bisect`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This requires one more pass through the list to build the `keys` list, so it's
    only convenient if you have to look up multiple entries (or the same entry multiple
    times), otherwise a linear search across the list will be faster.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you would have to build the `keys` list even to be able to use the
    `in` operator. So, if you want to search for a property without building an ad
    hoc list, you will have to rely on filtering as `filter` or list comprehensions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the nth element of any iterable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Randomly accessing to containers is something we are used to doing frequently
    and without too many issues. For most container types, it's even a very cheap
    operation. When working with generic iterables and generators on the other side,
    it's not as easy as we would expect and it often ends up with us converting them
    to lists or ugly `for` loops.
  prefs: []
  type: TYPE_NORMAL
- en: The Python standard library actually has ways to make this very straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `itertools` module is a treasure of valuable functions when working with
    iterables, and with minor effort it''s possible to get the *n^(th)* item of any
    iterable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Given a random iterable, we can use it to grab the element we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `itertools.islice` function is able to take a slice of any iterable. In
    our specific case, we want the slice that goes from the element we are looking
    for to the next one.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the slice containing the element we were looking for, we need to
    extract that item from the slice itself.
  prefs: []
  type: TYPE_NORMAL
- en: As `islice` acts on iterables, it returns an iterable itself. This means we
    can use `next` to consume it, and as the item we were looking for is actually
    the first of the slice, using `next` will properly return the item we were looking
    for.
  prefs: []
  type: TYPE_NORMAL
- en: In case the item is out of bounds (for example, we look for the fourth item
    out of just three), a `StopIteration` error is raised and we can trap it like
    we would for `IndexError` in normal lists.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping similar items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes you might face a list of entries that has multiple, repeated entries
    and you might want to group the similar ones based on some kind of property.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here is a list of names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We might want to build a group of all people whose names start with the same
    character, so we can keep our phone book in alphabetical order instead of having
    names randomly scattered here and there.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `itertools` module is again a very powerful tool that provides us with
    the foundations we need to handle iterables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Given our list of names, we can apply a key function that grabs the first character
    of the name so that all entries will be grouped by it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The core of the function here is provided by `itertools.groupby`.
  prefs: []
  type: TYPE_NORMAL
- en: This function moves the iterator forward, grabs the item, and adds it to the
    current group. When an item with a different key is faced, a new group is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in fact, it will only group nearby entries that share the same key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there are three groups instead of the expected two, because
    the first group of `1` is immediately interrupted by number `2`, and so we end
    up with two different groups of `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We sort the elements before grouping them, the reason being that sorting ensures
    that equal elements are all near to one another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'At that point, the grouping function will create the correct amount of groups
    because there is a single chunk for each equivalent element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We frequently work with complex objects in real life, so the `group_by_key`
    function also accepts a `key` function. That will state for which key the elements
    should be grouped.
  prefs: []
  type: TYPE_NORMAL
- en: As sorted accepts a key function when sorting, we know that all our elements
    will be sorted for that key before grouping and so we will return the right number
    of groups.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, as `groupby` returns an iterator or iterators (each group within the
    top iterable is an iterator too), we cast each group to a list and build a dictionary
    out of the groups so that they can be easily accessed by `key`.
  prefs: []
  type: TYPE_NORMAL
- en: Zipping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Zipping means attaching two different iterables to create a new one that contains
    values from both.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is very convenient when you have multiple tracks of values that should
    proceed concurrently. Imagine you had names and surnames and you want to just
    get a list of people:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want to zip together names and surnames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Zip will make a new iterable where each item in the newly-created iterable is
    a collection that is made by picking one item for each one of the provided iterables.
  prefs: []
  type: TYPE_NORMAL
- en: So, `result[0] = (i[0], j[0])`, and `result[1] = (i[1], j[1])`, and so on. If
    `i` and `j` have different lengths, it will stop as soon as one of the two is
    exhausted.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to proceed until you exhaust the longest one of the provided iterables
    instead of stopping on the shortest one, you can rely on `itertools.zip_longest`.
    Values from the iterables that were already exhausted will be filled with a default
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Flattening a list of lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you have multiple nested lists, you often need to just iterate over all
    the items contained in the lists without much interest in the depth at which they
    are actually stored.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say you have this list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If you just want to grab all the items within it, you really don't want to iterate
    over the lists within the list and then on the items of each one of them. We just
    want the leaf items and we don't care at all that they are in a list within a
    list.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What we want to do is just join all the lists into a single iterable that will
    yield the items themselves, as we are talking about iterators, the `itertools`
    module has the right function that will allow us to chain all the lists as if
    they were a single one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting `chained` iterator will yield the underlying items, one by one,
    when consumed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `itertools.chain` function is a very convenient one when you have to consume
    multiple iterables one after the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, it accepts those iterables as arguments, so we would have to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: But, for convenience, `itertools.chain.from_iterable` will chain the entries
    contained in the provided argument instead of having to pass them explicitly one
    by one.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you know how many items the original lists contained and they have the same
    size, it's easy to apply the reverse operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already know it''s possible to merge entries from multiple sources using
    `zip`, so what we actually want to do is zip together the elements that were part
    of the same original list, so that we can go back from being `chained` to the
    original list of lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we had three items lists, so we had to provide `chained` three
    times.
  prefs: []
  type: TYPE_NORMAL
- en: This works because `zip` will sequentially consume one entry from each provided
    argument. So, as we are providing the same argument three times, we are in fact
    consuming the first three entries, then the next three, and then the last three.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `chained` was a list instead of an iterator, we would have to create an
    iterator out of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If we didn''t use `ichained` but instead we used the original `chained`, the
    result would be pretty far from what we wanted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Producing permutations and combinations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given a set of elements, if you ever felt the need to do something for each
    possible permutation of those elements, you might have wondered what the best
    way to generate all those permutations was.
  prefs: []
  type: TYPE_NORMAL
- en: Python has various functions in the `itertools` module that will help with permutations
    and combinations, the differences between those are not always easy to grasp,
    but once you investigate what they do, they will become clear.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Cartesian product is usually what people think of when talking about combinations
    and permutations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a set of elements, `A`, `B`, and `C`, we want to extract all possible
    couples of two elements, `AA`, `AB`, `AC`, and so on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In case you want to omit the duplicated entries (`AA`, `BB`, `CC`), you can
    just use permutations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You might even want to ensure that the same couple doesn''t happen twice (such
    as `AB` versus `BA`), in such a case, `itertools.combinations` might be what you
    are looking for:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: So most needs of combining values from a set can be easily solved through the
    function provided by the `itertools` module.
  prefs: []
  type: TYPE_NORMAL
- en: Accumulating and reducing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: List comprehensions and `map` are very convenient tools when you need to apply
    a function to all elements of an iterable and get back the resulting values. But
    those are mostly meant to apply unary functions and keep a collection of the transformed
    values (such as add `1` to all numbers), but if you want to apply functions that
    should receive more than one element at the time, they don't fit very well.
  prefs: []
  type: TYPE_NORMAL
- en: The reduction and accumulation functions instead are meant to receive multiple
    values from the iterable and return a single value (in the case of reduction)
    or multiple values (in the case of accumulation).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps for this recipe are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most simple example of reduction is summing all items in an iterable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This is something that can easily be done by `sum`, but for the sake of this
    example, we will use `reduce`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If instead of having a single final result, you want to keep the results of
    the intermediate steps, you can use `accumulate`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`accumulate` and `reduce` are not limited to mathematical uses. While those
    are the most obvious examples, they are very flexible functions and their purpose
    changes depending uniquely on the function they are going to apply.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you have multiple lines of text, you can also use `reduce`
    to compute the total sum of all text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if you have multiple dictionaries you need to collapse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s even a very convenient way to access deeply nested dictionaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Memoizing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When running a function over and over, avoiding the cost to call that function
    can greatly speed up the resulting code.
  prefs: []
  type: TYPE_NORMAL
- en: Think of a `for` loop or a recursive function that maybe has to call that function
    dozens of times. If instead of calling it, it could preserve the known results
    of a previous call to the function, it could make code much faster.
  prefs: []
  type: TYPE_NORMAL
- en: The most common example for is the Fibonacci sequence. The sequence is computed
    by adding the first two numbers, then the second number is added to the result,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: This means that in the sequence `1`, `1`, `2`, `3`, `5`, computing `5` required
    us to compute `3 + 2`, which required us to compute `2 + 1`, which required us
    to compute `1 + 1`.
  prefs: []
  type: TYPE_NORMAL
- en: Doing the Fibonacci sequence in a recursive manner is the most obvious approach
    as it leads to `5 = fib(n3) + fib(n2)`, which was made of `3 = fib(n2) + fib(n1)`,
    so you can easily see that we had to compute `fib(n2)` twice. Memoizing the result
    of `fib(n2)` would allow us to perform such computation only once and then reuse
    the result on the next call.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the steps for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python provides an LRU cache built-in, which we can use for memoization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use the function to compute the full sequence:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be a list with all the Fibonacci numbers up to the 100^(th):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The difference in performance is huge. If we use the `timeit` module to time
    our function, we can easily see how much memoizing helped with performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the memoized version of the `fibonacci` function is used, the computation
    ends in less than a millisecond:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Then if we remove `@functools.lru_cache()`, which implemented the memoization,
    the timing changes radically:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: So it's easy to see how memoization changed the performance to fractions of
    a second from 89 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever the function is invoked, `functools.lru_cache` saves the returned value
    together with the provided arguments.
  prefs: []
  type: TYPE_NORMAL
- en: The next time the function will be called, the arguments are searched in the
    saved arguments and, if they are found, the previously returned value is provided
    instead of calling the function.
  prefs: []
  type: TYPE_NORMAL
- en: This, in fact, changes the cost of calling our function to being just the cost
    of a lookup in a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: So the first time we call `fibonacci(5)`, it gets computed, then next time it
    will be called, it will do nothing and the value previously stored for `5` will
    be returned. As `fibonacci(6)` has to call `fibonacci(5)` to be able to compute,
    it's easy to see how we provided a major performance benefit for any `fibonacci(n)`
    where `n>5`.
  prefs: []
  type: TYPE_NORMAL
- en: Also as we wanted the whole sequence, the saving is not just for a single call,
    but for each call in the list comprehension following the first one that needs
    a memoized value.
  prefs: []
  type: TYPE_NORMAL
- en: The `lru_cache` function was born as a **least recently used** (**LRU**) cache,
    so by default, it will keep around only the `128` most recent, but by passing
    `maxsize=None`, we can use it as a standard cache and discard the LRU part of
    it. All calls will be cached forever without a limit.
  prefs: []
  type: TYPE_NORMAL
- en: Purely for the Fibonacci case, you will notice that setting `maxsize` to any
    value greater than `3` changes nothing, as each Fibonacci number only requires
    the previous two calls to be able to compute.
  prefs: []
  type: TYPE_NORMAL
- en: Operators to functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose you want to create a simple calculator. The first step is parsing the
    formula the user is going to write to be able to perform it. The basic formula
    is made of an operator and two operands, so you have, in practice, a function
    and its arguments.
  prefs: []
  type: TYPE_NORMAL
- en: But given `+`, `-`, and so on, how can we have our parser return the associated
    functions? Usually to sum two numbers, we just write `n1 + n2`, but we can't pass
    around `+` itself to be called with any `n1` and `n2`.
  prefs: []
  type: TYPE_NORMAL
- en: This is because `+` is an operator and not a function, but underlying that it's
    still just a function in CPython that gets executed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use the `operator` module to get a callable that represents any Python
    operator that we can store or pass around:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `calculate` function acts as a very basic calculator (without operators
    precedence, real numbers, negative numbers, and so on):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, we were able to store functions for the four mathematical operators in the
    `operators` dictionary and look them up based on the text that was encountered
    in the expression.
  prefs: []
  type: TYPE_NORMAL
- en: In `calculate`, the expression is split by space, so `5 + 3` becomes `['5',
    '+', '3']`. Once we have the three elements of the expression (the two operands
    and the operator), we can just iterate over the parts and when we encounter the
    `+`, look it up in the `operators` dictionary to get back the associated function
    that should be called, which is `operator.add`.
  prefs: []
  type: TYPE_NORMAL
- en: The `operator` module contains functions for the most common Python operators,
    from comparisons (`operator.gt`) to dot-based attribute access (`operator.attrgetter`).
  prefs: []
  type: TYPE_NORMAL
- en: Most of the provided functions are meant to be paired with `map`, `sorted`,
    `filter`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Partials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already know that we can apply unary functions to multiple elements using `map`,
    and apply binary functions using `reduce`.
  prefs: []
  type: TYPE_NORMAL
- en: There is a whole set of functions that accepts a callable in Python and applies
    it to a set of items.
  prefs: []
  type: TYPE_NORMAL
- en: The major problem is that frequently the callable we want to apply might have
    a slightly different signature, and while we can solve the issue by wrapping the
    callable into another callable that adapts the signature, this is not very convenient
    if you just want to apply a function to a set of items.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you want to multiply all numbers in a list by 3, there is no
    function that multiplies a given argument by 3.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can easily adapt `operator.mul` to be a unary function and then pass it
    to `map` to apply it to the whole list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `operator.mul` was called with `3` and the item as its arguments,
    and thus returned `item*3`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We created a new `mul3` callable through `functools.partial`. This callable
    just calls `operator.mul`, passing `3` as the first argument and then passing
    any argument provided to the callable to `operator.mul` as the second, third,
    and so on arguments.
  prefs: []
  type: TYPE_NORMAL
- en: So, in the end, doing `mul3(5)` means `operator.mul(3, 5)`.
  prefs: []
  type: TYPE_NORMAL
- en: This is because `functools.partial` creates a new function out of a provided
    function hardwiring the provided arguments.
  prefs: []
  type: TYPE_NORMAL
- en: It is, of course, also possible to pass keyword arguments, so that instead of
    hardwiring the first argument, we can set any argument.
  prefs: []
  type: TYPE_NORMAL
- en: The resulting function is then applied to all numbers through `map`, which leads
    to creating a new list with all the numbers from 0 to 10 multiplied by 3.
  prefs: []
  type: TYPE_NORMAL
- en: Generic functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generic functions are one of my favorite features of the standard library. Python
    is a very dynamic language and through duck-typing, you will frequently be able
    to write code that works in many different conditions (it doesn't matter if you
    receive a list or a tuple), but in some cases, you will really need to have two
    totally different code bases depending on the received input.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we might want to have a function that prints content of the provided
    dictionary in a human-readable format, but we want it also to work properly on
    lists of tuples and report errors for unsupported types.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `functools.singledispatch` decorator allows us to implement a generic dispatch
    based on argument type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling the three functions will properly dispatch the request to the right
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The function decorated with `@singledispatch` actually gets replaced by a check
    for the argument type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each call to `human_readable.register` will record into a registry which callable
    should be used for each argument type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Whenever the decorated function gets called, it will instead look up the type
    of the argument in the registry and will forward the call to the associated function
    for execution.
  prefs: []
  type: TYPE_NORMAL
- en: The function decorated with `@singledispatch` should always be the generic implementation,
    the one that should be used in case the argument is not explicitly supported.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, this just throws an error, but frequently it will instead try
    to provide an implementation that works in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: Then the specific implementations can be registered with `@function.register`
    to cover the cases that the primary function couldn't cover or to actually implement
    the behavior if the primary function just throws an error.
  prefs: []
  type: TYPE_NORMAL
- en: Proper decoration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Decorators are usually not straightforward for anyone who faces them for the
    first time, but once you get used to them, they become a very convenient tool
    to extend a function's behavior or implement a lightweight form of aspect-oriented
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: But even once decorators become natural and part of everyday development, they
    have subtleties that are not obvious until you face them for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: 'It might not be immediately obvious when you are applying a `decorator`, but
    by using them, you are changing the signature of the `decorated` function, up
    to the point that the name of the function itself and its documentation are lost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sumtwo` function was decorated with `decorator`, but now, if we try to
    access the function documentation or name, they won''t be accessible anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Even though we provided a docstring for `sumtwo` and we know for sure that it
    was named `sumtwo`, we need to ensure that our decorations are properly applied
    and preserve properties of the original functions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need to perform the following steps for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python standard library provides a `functools.wraps` decorator that can
    be applied to decorators to have them preserve the properties of the decorated
    functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we apply the decorator to a function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it will properly retain the name and docstring of the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: If the decorated function had custom attributes, those will be copied to the
    new function too.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`functools.wraps` is a very convenient tool and does its best to ensure that
    the decorated function looks exactly like the original one.'
  prefs: []
  type: TYPE_NORMAL
- en: But while the properties of the function can easily be copied, the signature
    of the function itself is not as easy to copy.
  prefs: []
  type: TYPE_NORMAL
- en: 'So inspecting our decorated function arguments won''t return the original arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'So the reported arguments are just `*args` and `**kwargs` instead of `a` and
    `b`. To access the real arguments, we must dive into the underlying functions
    through the `__wrapped__` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Luckily, the standard library provides an `inspect.signature` function that
    does this for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: So, it's better to rely on `inspect.signature` whenever we want to check arguments
    of a function to be able to support both decorated and undecorated functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Applying decorations can also collide with other decorators. The most common
    example is `classmethod`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Trying to decorate `classmethod` won''t usually work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'You need to make sure that `@classmethod` is always the last applied decorator,
    to ensure it will work as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'At that point, the `classmethod` will work as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: There are so many decorator-related quirks that the Python environment has libraries
    that try to implement decoration properly for everyday usage. If you don't want
    to think about how to handle them, you might want to try the `wrapt` library,
    which will take care of most decoration oddities for you.
  prefs: []
  type: TYPE_NORMAL
- en: Context managers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Decorators can be used to ensure that something is executed when you enter and
    exit a function, but in some cases, you might want to ensure that something is
    always executed at the beginning and end of a block of code without having to
    move it to its own function or without rewriting those parts that should be executed
    every time.
  prefs: []
  type: TYPE_NORMAL
- en: Context managers exist to solve this need, factoring out code that you would
    have to rewrite over and over in place of `try:except:finally:` clauses.
  prefs: []
  type: TYPE_NORMAL
- en: The most common usage of context managers is probably the closing context manager,
    which ensures that files get closed once the developer is done working with them,
    but the standard library makes it easy to write new ones.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, the following steps are to be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`contextlib` provides features related to context managers, `contextlib.contextmanager`
    can make it very easy to write context managers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the context manager created can be used like any other context manager:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Exceptions raised within the wrapped block will be propagated to the context
    manager, so it''s possible to handle them with a standard `try:except:finally:`
    clause and do any proper cleanup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The changed context manager will be able to log exceptions without interfering
    with the exception propagation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Applying variable context managers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When using context managers, you must rely on the `with` statement to apply
    them. While it''s possible to apply more than one context manager per statement
    by separating them with commas, it''s not as easy to apply a variable number of
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The context managers that we want to apply must be known when writing the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: But what if sometimes we only want to apply the `first` context manager, and
    sometimes we want to apply both?
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`contextlib.ExitStack` serves various purposes, one of which is to allow us
    to apply a variable number of context managers to a block.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we might want to apply both context managers only when we are
    printing an even number in a loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be that the `second` is only added to the context, and thus
    invoked for even numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, for `1` and `3`, only `First` is printed.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, when exiting the context declared through the `ExitStack` context
    manager, all the context managers registered within the `ExitStack` will be exited
    too.
  prefs: []
  type: TYPE_NORMAL
