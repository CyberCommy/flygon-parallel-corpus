- en: Chapter 2. Getting Started with WebSockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Client server communication is one of the most important parts of any web application.
    Data communication between the server and client has to be smooth and fast so
    that the user can have an excellent experience. If we look into the traditional
    methods of server communication, we will find that those methods were limited
    and were not really the best solutions. These methods have been used by people
    for a long period of time and made HTML the second choice for data communication.
  prefs: []
  type: TYPE_NORMAL
- en: Why WebSockets?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The answer to why we need WebSockets lies in the question—what are the problems
    with the other methods of communication? Some of the methods used for server communication
    are request/response, polling, and long-polling, which have been explained as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Request/Response: This is a commonly used mechanisms in which the client requests
    the server and gets a response. This process is driven by some interaction like
    the click of a button on the webpage to refresh the whole page. When AJAX came
    into the picture, it made the webpages dynamic and helped in loading some part
    of the webpage without loading the whole page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Polling: There are scenarios where we need the data to be reflected without
    user interaction, such as the score of a football match. In polling, the data
    is fetched after a period of time and it keeps hitting the server, regardless
    of whether the data has changed or not. This causes unnecessary calls to the server,
    opening a connection and then closing it every time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Long-polling: This is basically a connection kept open for a particular time
    period. This is one of the ways of achieving real-time communication, but it works
    only when you know the time interval.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The problems with these methods lead to the solution, which is WebSockets. It
    solves all the problems faced during the use of the old methods.
  prefs: []
  type: TYPE_NORMAL
- en: Importance of WebSockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebSockets comes into the picture to save us from the old heavy methods of server
    communication. WebSockets solved one of the biggest problems of server communication
    by providing a full-duplex two-way communication bridge. It provides both the
    server and client the ability to send data at any point of time, which was not
    provided by any of the old methods. This has not only improved performance but
    also reduced the latency of data. It creates a lightweight connection which we
    can keep open for a long time without sacrificing the performance. It also gives
    us full control to open and close the connection at any point of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'WebSockets comes as a part of HTML5 standard, so we do not need to worry about
    adding some extra plugin to make it work. WebSockets API is fully supported and
    implemented by JavaScript. Almost all modern browsers now support WebSockets;
    this can be checked using the website [http://caniuse.com/#feat=websockets](http://caniuse.com/#feat=websockets)
    which gives the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Importance of WebSockets](img/B03854_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: WebSockets need to be implemented on both the client and server side. On the
    client side, the API is a part of HTML5\. But on the server side, we need to use
    a library that implements WebSockets. There are many—or we can say almost all—servers
    that support WebSockets API libraries now. Node.js, which is a modern JavaScript
    based platform also supports WebSockets based server implementation using different
    packages, which makes it really easy for developers to code both server and client-side
    code without learning another language.
  prefs: []
  type: TYPE_NORMAL
- en: When to use?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebSockets being a very powerful way of communication between the client and
    server, it is really useful for applications which need a lot of server interaction.
    As WebSockets gives us the benefit of real-time communication, applications that
    require real-time data transfer, like chatting applications, can leverage WebSockets.
    It is not only used for real-time communication but also for scenarios where we
    need only the server to push the data to the client.
  prefs: []
  type: TYPE_NORMAL
- en: The decision to use WebSockets can be made when we know the exact purpose of
    its usage. We should not use WebSockets when we just have to create a website
    with static pages and hardly any interaction. We should use WebSockets where the
    communication is higher in terms of data passing between the client and server.
  prefs: []
  type: TYPE_NORMAL
- en: There are many applications like stock applications where the data keeps updating
    in real time. Collaborative applications need real-time data sharing, such as
    a game of chess or a Ping-Pong game. WebSockets is majorly utilized in real-time
    gaming web applications.
  prefs: []
  type: TYPE_NORMAL
- en: How it works?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'WebSockets communicates using the TCP layer. The connection is established
    over HTTP and is basically a handshake mechanism between the client and server.
    After the handshake, the connection is upgraded to TCP. Let''s see how it works
    through this flow diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works?](img/B03854_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following steps will take you through the flow shown in the preceding diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is the HTTP call that is initiated from the client side; the
    header of the HTTP call looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, `Host` is the name of the server that we are hitting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Upgrade` shows that it is an upgrade call for, in this case, WebSockets. Connection
    defines that it is an upgrade call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sec-Websocket-Key` is a randomly generated key which is further used to authenticate
    the response. It is the authentication key of the handshake.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Origin` is also another important parameter which shows where the call originated
    from; on the server side, it is used to check the requester''s authenticity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once the server checks the authenticity a response is sent back, which looks
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, `Sec-WebSocket-Accept` has a key which is decoded and checked with the
    key sent for confirmation that the response is coming to the right originator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, once the connection is open, the client and server can send the data to
    each other.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The data is sent in the form of small packets using TCP protocol. These calls
    are not HTTP so they are not visible directly under the Network tab of Developer
    Tools of a browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: WebSocket API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'WebSockets standard is defined by W3\. The API interface for WebSockets looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We can see from the interface the types of ready states, networking events,
    and types of messages that WebSockets API provides.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: Ready states
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following are the ready states:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING**: The connection has not yet been established.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OPEN**: The WebSockets connection is established and communication is possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CLOSING**: The connection is going through the closing handshake or the `close()`
    method has been invoked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CLOSED**: The connection has been closed or could not be opened.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following are the events triggered:'
  prefs: []
  type: TYPE_NORMAL
- en: '**onopen**: Triggered when the connection is opened.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**onclose**: Triggered when the connection is closed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**onerror**: Triggered when an error is encountered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**onmessage**: Triggered when a message is received from the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Echo Test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us start with the **Echo Test** application. Go to the URL [https://www.websocket.org/echo.html](https://www.websocket.org/echo.html).
    Here you can see a readymade **Echo** server which we can hit and then receive
    a message. It just gives you a server; when you send a message to this server
    it will send the same message in return. Go ahead and play with your Echo application.
    After this, we will see how to write our own client code to hit this Echo server.
  prefs: []
  type: TYPE_NORMAL
- en: '![Echo Test](img/B03854_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The WebSockets client app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us start with writing client-side code in JavaScript. We will be hitting
    the same Echo server for now. Let''s get started with our client-side code. Here
    is how the client code will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this code, we will get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The WebSockets client app](img/B03854_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is a pretty straightforward code; developers with a little experience
    in JavaScript can also understand it. Let''s go through the code and understand
    what is happening. The sequence here is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We open the connection with the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it is successful, then we send the message to the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we receive the message from the server, we display it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we close the connection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's talk about the important phases that we need to take care of whenever
    we are going to create any application using WebSockets.
  prefs: []
  type: TYPE_NORMAL
- en: Instantiation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can create an instance of a WebSockets object just like we create the instance
    of any other class. Here is how we can do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is only one important parameter that we need to pass, and that is the
    URI of the server. You will notice that we have used the **ws://** URL schema,
    which basically defines which protocol should be used for the communication. There
    is another URL schema, that is, **wss://**, which is used in case we want to use
    the secure communication, just like we have HTTPS for a secure connection.
  prefs: []
  type: TYPE_NORMAL
- en: Adding events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can add event handlers to a WebSockets object that are triggered in case
    of any event. There are four main events which we need to add handlers to and
    these are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we create an instance of the WebSockets object, we get the open event
    triggered, which tells us that the connection is now open. Here is how we have
    added the event:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When the connection is closed, the `onClose` method is called:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When we receive a message from a server, the `onmessage` event is triggered
    and we can handle it and get the data from it using the data property of the event:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes we face some errors during connection because the server is down
    or some configuration issue has occurred, or due to other reasons. Due to these
    different possible reasons, we can get an error which is captured and given to
    the client in the `onerror` event handler:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Sending messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can send not only strings but also objects, blobs, and array buffers as
    well to the server and vice versa. The send method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It is one of the important methods because we use it to send data to the server.
  prefs: []
  type: TYPE_NORMAL
- en: Receiving messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Receiving data is also simple as we have already placed a handler for the event.
    So here we will get the data under the data property of the event object. In this
    scenario, we have added some styling and added that to the HTML page so that we
    can just have a visually attractive message, which we can see from the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Closing the connection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Connections also need to be closed; the best practice is to close the connection
    when we are done using it. Similarly we want the connection to the server to be
    closed once we receive the message. We have to make sure that we close the connection
    before exiting the application. We just simply have to call the `close()` method
    of the WebSocket object to close the open connection.The method to close the connection
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The WebSocket server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how the client works and how we can send the data to the server
    and receive it from server. Now we will see how we can make our own server code
    handle the messages.
  prefs: []
  type: TYPE_NORMAL
- en: Using modern web technology, we will explore the implementation of the WebSocket
    server using Node.js. Node.js is a very friendly, lightweight, and easy-to-use
    platform. So let's see how we can make our own WebSockets server.
  prefs: []
  type: TYPE_NORMAL
- en: The Node.js server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Node.js server gives us a lot of flexibility to create our own server. There
    are many library packages available via NPM. We will be using a library created
    by Einar Otto Stangvik which basically handles general mechanisms, such as upgrading
    the HTTP protocol and others. It is a very robust, clean, and lightweight library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to set up the server you must have Node.js installed on your machine.
    If you don''t have it installed, then go ahead and check out the website of Node.js
    ([https://nodejs.org/](https://nodejs.org/)), read the documentation, and install
    it. Refer to the following steps to install WebSocket server:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project in Node.js using NPM. You just need to run the `npm init`
    command. Follow the instructions that come after it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will create a `package.json` file which will have all the information of
    the project and related packages. This is very useful for version and package
    controlling. Here is how the Node.js command prompt will look after firing the
    `npm init` command:![The Node.js server](img/B03854_02_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, we need to set up the WebSockets package using the `npm install ws`
    command. This command will install the necessary libraries for the WebSocket connection,
    which will look like the following:![The Node.js server](img/B03854_02_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is possible that you may get some error related to Python. Please ignore
    it. This library has some other features which require Python to be installed,
    but the features we are utilizing are not related to Python, so we can ignore
    it. This error will not affect our development process and our code will work
    fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are ready to code. First, we will create our server JavaScript file
    named `server.js`, which will be our main server file. Please note that it should
    be created within the same folder wherein we have run the previous command `npm
    init`. The server code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a very simple server. Let''s go through the code step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we are just creating an instance of WebSocketServer and defining on which
    port it should listen. Sometimes port `8080` is not available so you may get an
    error. Don''t worry; you can simply change it by doing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the instance we have to add the connection listener, which is
    triggered if the connection is established:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the connection is established, we need to add the listener for that particular
    WebSockets connection instance. This instance can be used for many purposes like
    sending messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then comes the message sending part. As we are creating an Echo server, we
    just need to send the message we received back. So we are using the same message
    and sending it through the WebSockets instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we write the code it is time to test it. We need to start our Node.js
    server which we can do using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the server is started, we just have to change a single line from the client
    side code, which we developed earlier in the chapter—the server URI that we were
    hitting. Earlier, we were hitting the [www.websocket.org](http://www.websocket.org)
    website, but now we have to hit the server we have made. We just replace the URI
    from `ws://demo.websocket.org` to `ws://localhost:8080` and we are good to go.
    We can run our client application file the same way we did in our last client
    application and see the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![The Node.js server](img/B03854_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The result will be same as the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have just made your first WebSockets Echo application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to write client and server side code. We
    understood how Node.js can be used as a server for WebSockets and how we can leverage
    it to create a small server so quickly.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be making a simple application where we will see
    how WebSockets can be used.
  prefs: []
  type: TYPE_NORMAL
