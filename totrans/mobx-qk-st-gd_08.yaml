- en: Exploring mobx-utils and mobx-state-tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you start going deeper into the world of MobX, you will realize that certain
    types of use cases recur quite often. The first time you solve them, there is
    a definite sense of achievement. However, after the fifth time, you want to standardize
    the solution. `mobx-utils` is an NPM package that gives you several standard utilities
    to handle common use cases in MobX.
  prefs: []
  type: TYPE_NORMAL
- en: To push the level of standardization even further, we can bring more structured
    opinions into our MobX solutions. These opinions have been formed out of several
    years of MobX usage, and carry a variety of ideas for rapid development. This
    is all possible with the `mobx-state-tree` NPM package.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following packages in greater detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mobx-utils` for a tool belt of utility functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mobx-state-tree` (**MST**) for an opinionated MobX'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be required to have Node.js installed on a system. Finally, to use
    the Git repository of this book, the user needs to install Git.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Mobx-Quick-Start-Guide/tree/master/src/Chapter08](https://github.com/PacktPublishing/Mobx-Quick-Start-Guide/tree/master/src/Chapter08)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2LiFSJO](http://bit.ly/2LiFSJO)'
  prefs: []
  type: TYPE_NORMAL
- en: The utility functions of mobx-utils
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`mobx-utils` provides a variety of utility functions that can simplify programming
    tasks in MobX. You can install `mobx-utils` using `npm` or `yarn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the rest of this section, we will focus on some utilities that are frequently
    used. These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fromPromise()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lazyObservable()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fromResource()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`now()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`createViewModel()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizing async-operations with fromPromise()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Promises, a way of life in JavaScript, are great for dealing with asynchronous
    operations. When representing the state of operations on the React UI, we have
    to ensure each of the three states of a promise is handled. This includes the
    state when the promise is `pending` (operation in progress), `fulfilled` (operation
    completed successfully), or `rejected` (in case of failures). `fromPromise()`
    is a convenient way to handle a promise, and gives a nice API to visually represent
    the three states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`promiseLike`: instance of `Promise` or `(resolve, reject) => { }`'
  prefs: []
  type: TYPE_NORMAL
- en: '`fromPromise()` wraps the given promise and gives back a new, MobX-charged promise
    with some additional observable properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`state`: One of the three string values: `pending`, `fulfilled`, or `rejected`:
    These are also available as constants on the `mobx-utils` package: `mobxUtils.PENDING`,
    `mobxUtils.FULFILLED`, and `mobxUtils.REJECTED`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value`: The resolved `value` or the `rejected` error. Use `state` to distinguish
    the value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`case({pending, fulfilled, rejected})`: This is used to provide the React components
    for the three states.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see all of this in action with an example. We will create a simple `Worker` class
    that performs some operation, which can randomly fail. Here is the `Worker` class
    that tracks the operation by calling `fromPromise()`. Notice that we are passing
    a `promise` as argument into `fromPromise()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To visualize this operation, we can leverage the `case()` API to show the corresponding
    React component for each state. This can be seen in the following code. As the
    operation progresses from `pending` to `fulfilled` or `rejected`, these states
    will be rendered with the correct React component. For the `fulfilled` and `rejected`
    states, the resolved `value` or the `rejected` `error` is passed in as the first
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Instead of the `case()` function, we could have also switched manually on the
    observable `state` property. In fact, `case()` does that internally.
  prefs: []
  type: TYPE_NORMAL
- en: Using lazyObservable() for deferred updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For operations that are expensive to perform, it makes sense to defer them
    until needed. With `lazyObservable()`, you can track the result of these operations
    and update only when needed. It takes in a function that performs the computation
    and pushes values when ready:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, `sink` is the callback to be invoked to push the value onto `lazyObservable`.
    The lazy-observable can also start with some `initialValue`.
  prefs: []
  type: TYPE_NORMAL
- en: The current value of `lazyObservable()` can be retrieved using `result.current()`.
    Once a lazy-observable has been updated, `result.current()` will have some value. To
    update the lazy-observable again, you can use `result.refresh()`. This will re-invoke
    the computation and eventually push new values via the `sink` callback. Note that
    the `sink` callback can be invoked as many times as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following snippet, you can see the use of `lazyObservable()` to update
    the value of the operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The call to the `current()` method is tracked by MobX, so make sure you only
    call it when needed. The use of this method inside `render()` causes MobX to re-render
    the component. After all, `render()` of a component translates to a reaction in
    MobX, which re-evaluates whenever any of its tracked observables change.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the lazy-observable inside a React component (an *observer*), we rely
    on the `current()` method to fetch its value. MobX will track this value and re-render
    the component whenever it changes. Notice in the `onClick` handler of the button,
    we are causing an update of the lazy-observable by calling its `refresh()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: A generalized lazyObservable() with fromResource()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is also a more generalized form of `lazyObservable()` called `fromResource()`.
    Similar to `lazyResource()`, it takes in a function with the `sink` callback.
    This acts as a *subscribing* function, which is invoked only when the resource
    is actually requested. Additionally, it takes a second argument, an *unsubscribing*
    function, which can be used to clean up when the resource is no longer needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`fromResource()` gives back an observable which will start fetching values
    when its `current()` method is invoked the first time. It gives back an observable
    that also has the `dispose()` method to stop updating values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following snippet, you can see a `DataService` class relying on `fromResource()`
    to manage its WebSocket connection. The value of the data can be retrieved with
    `data.current()`. Here, *data* acts as the lazy-observable. In the *subscribing*
    function, we set up our WebSocket and subscribe to a specific channel. We unsubscribe
    from this channel in the *unsubscribing* function of `fromResource()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We can explicitly dispose of the resource with the `dispose()` method. However,
    MobX is smart enough to know when there are no more observers of this resource
    and automatically calls the *unsubscribe *function.
  prefs: []
  type: TYPE_NORMAL
- en: 'A special kind of lazy-observable provided by `mobx-utils` is `now(interval:
    number)`. It treats time as an observable and updates at the given interval. You
    can retrieve its value by simply calling `now()`, which, by default, updates every
    second. By the virtue of being an observable, it will also cause any reaction
    to execute every second. Internally, `now()` uses the `fromResource()` utility
    to manage the timer.'
  prefs: []
  type: TYPE_NORMAL
- en: A view model to manage edits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a data-entry-based application, it is quite common to have forms to accept
    a variety of fields. In these forms, the original model is not mutated until the
    user submits the form. This allows the user to cancel out of the editing process
    and go back to the previous values. A scenario like this requires creating a clone
    of the original model and pushing the edits upon submit. Although this technique
    is not terribly complex, it does add some boilerplate.
  prefs: []
  type: TYPE_NORMAL
- en: '`mobx-utils` provides a handy utility called `createViewModel()` that is tailor-made
    for this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`model` is the original model containing observable properties. `createViewModel()`
    wraps this model and proxies all the reads and writes. This utility has some interesting
    characteristics, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: As long as a property of `viewModel` is not changed, it will return the value
    from the original model. After a change, it will return the updated value and
    also treat `viewModel` as dirty.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To finalize the updated values on the original model, you must call the `submit()`
    method of `viewModel`*.* To reverse any changes, you can invoke the `reset()`
    method. To revert a single property, use `resetProperty(propertyName: string)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To check if `viewModel` is dirty, use the `isDirty` property. To check if a
    single property is dirty, use `isPropertyDirty(propertyName: string)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To get the original model, use the handy `model()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The advantage of using `createViewModel()` is that you can treat the whole editing
    process as a single transaction. It is final only when `submit()` is invoked.
    This allows you to cancel out prematurely and retain the original model in its
    previous state.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we are creating a `viewModel` that wraps the `FormData`
    instance and logs the `viewModel` and `model` properties. You will notice the
    proxying effect of `viewModel` and how values propagate back to the model upon
    `submit()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The log from `autorun()` is as follows. You can see the effect of `submit()`
    and `reset()` on the `viewModel.name` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: There is lot more to discover
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The handful of utilities described here is by no means exhaustive. `mobx-utils`
    provides many more utilities, and we strongly encourage you to take a look at
    the GitHub project ([https://github.com/mobxjs/mobx-utils](https://github.com/mobxjs/mobx-utils))
    to discover the remaining utility functions.
  prefs: []
  type: TYPE_NORMAL
- en: There are functions to convert between RxJS streams and MobX Observables, *processor-functions*
    that can perform an operation anytime an observable-array is appended, a variant
    of the MobX `when()`, which automatically disposes after a timeout, and many more.
  prefs: []
  type: TYPE_NORMAL
- en: An opinionated MobX with mobx-state-tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MobX is very flexible in how you organize your state and apply the various
    actions and reactions. However, it does leave some questions for you to answer:'
  prefs: []
  type: TYPE_NORMAL
- en: Should classes be used or just plain objects with `extendObservable()`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How should the data be normalized?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to deal with circular references when serializing the state?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And many more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mobx-state-tree` is a package that gives you prescriptive guidance for organizing
    and structuring your observable state. Adopting the MST style of thinking gives
    you several benefits out of the box. In this section, we will explore this package
    and its benefits.'
  prefs: []
  type: TYPE_NORMAL
- en: Models – properties, views, and actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`mobx-state-tree` as the name suggests, organizes the state in a tree of models.
    It''s a model-first approach, where each model defines the state that needs to
    be captured. Defining the model adds the ability to type-check the model assignments
    at runtime and guard you against inadvertent changes. Combining the runtime checks
    with the use of a language like TypeScript also gets you compile-time (or rather,
    design-time) type-safety. With a strictly typed model, `mobx-state-tree` gives
    you safe guarantees and ensures the integrity and constraints of your typed-models.
    This in itself is a huge benefit, especially when dealing with a dynamic language
    like JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put MST into action with a simple model for `Todo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: A model describes the shape of data it holds. In case of the `Todo` model, it
    only needs a `title` *string* and a *boolean* `done` property. Note that we assigned
    our model to a capitalized name (`Todo`). This is because MST really defines a
    type and not an instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the built-in types in MST are part of the `types` namespace. The `types.model()`
    method takes two arguments: an optional string *name* (used for debugging and
    error reporting) and an *object* defining the various properties of the type.
    All of these properties will be qualified with strict types. Let''s try creating
    an instance of this model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we have passed the same structure of data into `Todo.create()` as
    defined in the model. Passing any other kind of data will result in MST throwing
    type-errors. Creating an instance of the model has also made all its properties
    into observables. This means we can now use the full power of the MobX API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a simple reaction that will log the changes to the `todo` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this code, you will notice an exception being thrown, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This happens because we have modified the `todo.done` property outside of an
    action. You will recollect from earlier chapters that it''s a good practice to
    wrap all observable-mutations inside an action. In fact, there is even a MobX
    API: `configure({ enforceActions: ''strict'' })`, to ensure this happens. MST
    is very *protective* about the data in its state-tree and mandates the use of
    actions for all mutations.'
  prefs: []
  type: TYPE_NORMAL
- en: This may sound very rigid, but it does come with added benefits. For example,
    the use of actions allows MST to provide first-class support for middleware. Middleware
    can *intercept* any changes happening to the state-tree and make it trivial to
    implement features such as *Logging, Time Traveling*, *Undo*/*Redo*, *Database
    Synchronization*, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Defining actions on the model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The model type `Todo` that we created earlier can be extended with a chained
    API. `actions()` is one such API that can be used to extend the model type with
    all the action definitions. Let''s do that for our `Todo` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `actions()` method takes in a function that receives the instance of the
    model as its argument. Here, we are calling it `self`. This function is supposed
    to return a key-value map that defines all the actions. In the preceding snippet,
    we are leveraging the object-literal syntax of ES2015 to make the actions object
    look more readable. There are some striking benefits of this style of accepting
    the actions:'
  prefs: []
  type: TYPE_NORMAL
- en: The use of a function allows you to create a closure that can be used to track
    the private state that is only used by the actions. For example, a WebSocket connection
    that is set up inside one of the actions that should never be exposed to the outside
    world.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By passing an instance of the model to `actions()`, you can guarantee that the
    `this` pointer is always correct. You never have to worry about the context of
    the functions defined in `actions()` anymore. The `toggle()` action makes use
    of `self` to mutate the model instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The actions defined can be invoked directly on the model instance, which is
    what we do with `todo.toggle()`. MST has no more complaints about direct mutation,
    and `autorun()` will also fire when `todo.done` changes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating derived information with views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to actions, we can also extend the model type with `views()`. Derived
    information in a model is defined using `views()` in MST. Just like the `actions()`
    method, it can be chained to the model type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two views introduced on the `Todo` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '`asMarkdown()` is a *getter* that translates to a MobX computed-property. Like
    every computed-property, its output is cached.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contains()` is a regular function whose output is not cached. However, it
    does have the ability to re-execute when used in a reactive context such as `reaction()`
    or `autorun()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mobx-state-tree` introduces a very strict concept of models with clearly defined
    *state*, *actions*, and *derivations*. If you feel uncertain about structuring
    your code in MobX, MST can help you apply the MobX philosophy with clear guidance.'
  prefs: []
  type: TYPE_NORMAL
- en: Fine-tuning primitive types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The single model type that we have seen so far is just the beginning and can
    barely be called a tree. We can expand the domain-model to make it more realistic.
    Let''s add a `User` type, who will be creating the `todo` items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'There are some interesting details in the preceding definition, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `age` property has been defined as the constant `42`, which translates
    to a default value for `age`. When no value is provided for a user, it will be
    set to this default value. Additionally, MST is smart enough to derive the type
    to be `number`. This works well for all the primitive types, where the type of
    the default value will be inferred as the type of the property. Also, by giving
    a default value, we are suggesting that the `age` property is optional. A more
    verbose form of declaring the property is: `types.optional(types.number, 42)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `twitter` property has a more complicated definition but can be broken down
    easily. `types.maybe()` suggests that a `twitter` handle is optional, so it could
    be *undefined*. When a value is provided, it must be of type string. But not any
    string; only strings that match the provided regular-expression. This gives you
    runtime type-safety and rejects invalid Twitter handles such as `Calvin & Hobbes` or
    an empty string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type system provided by MST is very powerful and can handle a variety of
    complex type specifications. It also composes well, and gives you a functional
    approach to combining many smaller types into a larger type definition. These
    type specifications give you runtime safety and ensure the integrity of your domain
    model.
  prefs: []
  type: TYPE_NORMAL
- en: Composing trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have the `Todo` and `User` types, we can define the top-level `App`
    type that composes the types defined previously. The `App` type represents the
    state of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We have defined the `App` type by using *higher-order types* (types that take
    a type as input and create a new type). In the preceding snippet, `types.map()`
    and `types.array()` create these higher-order types.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an instance of the `App` type is just a matter of providing the right
    JSON payload. As long as the structure matches the type-specification, MST will
    have no problem in constructing the model instances at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: The shape of the data will always be validated by MST. It will never
    allow data updates that don''t match the model''s type specification.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice in the preceding snippet, we are able to call the `app.todos[0].toggle()`
    method seamlessly. This is because MST was able to build the `app` instance successfully
    and wrap the JSON nodes with proper types.
  prefs: []
  type: TYPE_NORMAL
- en: '`mobx-state-tree` elevates the importance of modeling your application state.
    Defining the proper types for the various entities in your application is paramount
    for its structural and data integrity. A nice way to get started is to encode
    the JSON you receive from the server in MST models. The next step is to ***fatten*** the
    model by adding more rigid typing, and attaching actions and views.'
  prefs: []
  type: TYPE_NORMAL
- en: References and identifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, this chapter has been entirely about capturing the state of the application
    in a *tree*. Trees have many interesting properties and are easy to comprehend
    and explore. But often, when one starts to apply a new technology to real problem
    domains, it turns out that trees are conceptually not sufficient to describe problem
    domains. For example, *friendship-relationships* are bidirectional and don't fit
    unidirectional trees. Dealing with relationships that are not *compositional*
    in nature, but rather *associative*, often requires introducing new abstraction
    layers and techniques such as *data normalization*.
  prefs: []
  type: TYPE_NORMAL
- en: A quick example of such a relationship can be introduced in our application
    by giving `Todo` an `assignee` property. Now, it is clear that `Todo` does not *own* its `assignee`, and
    neither is the inverse true; *todos* are not owned by a single user, as they can
    be *reassigned* later. So when composition does not suffice to describe the relationship,
    we often fall back to using *foreign keys* to describe the relationships.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, the JSON of a `Todo` item could be like the following code,
    where the `assignee` field of `Todo` corresponds to the `userid` field of a `User` object:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `name` to store the `assignee` relationship would be a bad idea, as the
    `name` of a person is not unique and it might change over time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Our initial take on this might be to type the `assignee` and `userid` attributes
    as `types.string` fields. Then, whenever we need it, we could look up the designated
    user in the `users` map, since the user is stored under its own `userid`. Since
    the user lookup could be a commonly needed operation, we could even introduce
    a *view* and *action* to read or write to that user. That will make our user model
    as seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the `getAssignee()` view, we conveniently use the fact that every MST node
    knows its own location in the tree. By leveraging the `getRoot()` utility, we
    can navigate to the `users` map and grab the correct `User` object. By using the `getAssignee()` view,
    we obtain a real `User` object so that we can directly access and print its `name`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: There are several useful utilities that can be used to reflect on or work with
    the location in a tree, such as `getPath()`, `getParent()` , `getParentOfType()`,
    and so on. As an alternative, we could have expressed the `getAssignee()` view
    as `return resolvePath(self, "../../users/" + self.assignee)`.
  prefs: []
  type: TYPE_NORMAL
- en: We can treat the MST tree as a filesystem for state! `getAssignee()` just translates
    to a symlink.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, an action to update the `assignee` property has been introduced.
    To make sure the `setAssignee()` action can be conveniently invoked by either
    providing `userid,` or an actual *user* object, we apply some *type-discrimination*.
    In MST, every type not only exposes the `create()` method, but also the `is` method,
    to check if a given value is of the respective type.
  prefs: []
  type: TYPE_NORMAL
- en: Referencing by types.identifier() and types.reference()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is nice that we can neatly express these lookup/update utilities in MST,
    but if your problem domain is large, this becomes quite a repetitive pattern.
    Luckily, this pattern is built into MST. The first type we can leverage is `types.identifier()`,
    which indicates that a certain field uniquely identifies an instance of a certain
    model type. So, in our example, rather than typing `userid` as `types.string` we
    can type it as `types.identifier()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Secondly, there is `types.reference()`. This type indicates that a certain
    field is serialized as a primitive value, but actually denotes a reference to
    another type in the tree. MST will automatically match `identifier` fields with `reference` fields
    for us, so we can simplify our previous state-tree model to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to the reference type, reading the `assignee` attribute of `Todo` will
    actually resolve the stored identifier and return the correct `User` object. Thus,
    we can immediately print its name in the preceding example. Note that, behind
    the scenes, our state is still a tree. It is also important to notice that we
    don't have to specify where or how references to `User` instances should be resolved.
    MST will automatically maintain an internal *type + identifier* based lookup table
    for resolving references. By using *references* and *identifiers*, MST has enough
    type information to automatically handle the *data (de)normalization* for us.
  prefs: []
  type: TYPE_NORMAL
- en: '`types.reference` is quite powerful and can be customized to, for example,
    resolve objects based on relative paths (like a real symlink!) instead of identifiers. In
    many cases, you will combine `types.reference` with `types.maybe` as above, to
    express that `Todo` does not necessarily have an `assignee`. Likewise, arrays
    and maps of references can be modeled in similar ways.'
  prefs: []
  type: TYPE_NORMAL
- en: Out-of-the-box benefits of declarative models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MST helps you organize and model complex problem domains in a declarative fashion.
    Because of a consistent approach to defining the types in your domain, we get
    the benefit of a clean and simple mental model. This consistency also gets us
    many *out-of-the-box* features, since MST has deep knowledge of the state-tree.
    One example we saw earlier was with automatic *data-normalization* with the use
    of *identifiers* and *references*. There are many more features built into MST.
    Of the lot, a few stand out as being most practical. We will briefly discuss them
    in the rest of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable snapshots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MST always keeps an immutable version of the state-tree in memory, which can
    be retrieved using the `getSnapshot()` API. Essentially, `const snapshot = getSnapshot(tree)` is
    the inverse of `const tree = Type.create(snapshot)`. `getSnapshot()` makes it very
    convenient to quickly serialize the entire state of a tree. Since MST is powered
    by MobX, we can nicely track this as well.
  prefs: []
  type: TYPE_NORMAL
- en: S*napshots* translate to *computed-properties* on the model instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet automatically stores the state of the tree in *local-storage*
    upon each change, but no more than once per second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: It should be pointed out that every node in an MST tree is an MST tree in itself.
    This means, any operation invoked on the root could also be invoked on any of
    its subtrees. For example, if we only want to store a part of the entire state,
    we could just get a snapshot of the subtree.
  prefs: []
  type: TYPE_NORMAL
- en: A corollary API that goes hand in hand with `getSnapshot()` is `applySnapshot()`.
    This can be used to update a tree with a snapshot in an efficient manner. By combining `getSnapshot()` and `applySnapshot()`, you
    can build a time traveler in just a few lines of code! This is left as an exercise
    for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: JSON patches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although snapshots efficiently capture the state of the entire application,
    they are not suitable for frequent communication with a server or other clients.
    This is because the size of a snapshot grows linearly with the size of the state
    you want to serialize. Instead, for real-time changes, it is better to send incremental
    updates to the server. *JSON-patch* (RFC-6902) is an official standard on how
    these incremental updates should be serialized, and MST supports this standard
    out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `onPatch()` API can be used to listen to the `patches` being generated
    as a side effect of your changes. On the other hand, `applyPatch()` performs the
    inverse process: given a patch, it can update an existing tree. The `onPatch()` listener
    emits the `patches` generated as a result of the state changes made by actions.
    It also exposes the so-called *inverse-patches*: a set that can undo the changes
    made by the `patches`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code, which toggles the `todo`, prints the following to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Middlewares
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We briefly mentioned middlewares in an earlier section, but let''s expand on
    it here. Middlewares act as interceptors of the actions invoked on the state-tree.
    Because MST mandates the use of actions, we are assured that every *action* will
    pass through the middleware. The presence of middleware makes it trivial to implement
    several cross-cutting features, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time travel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Undo/Redo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In fact, the `mst-middlewares` NPM package contains some of the previously mentioned
    middlewares, as well as a few more. For more details about these middlewares,
    refer to: [https://github.com/mobxjs/mobx-state-tree/blob/master/packages/mst-middlewares/README.md](https://github.com/mobxjs/mobx-state-tree/blob/master/packages/mst-middlewares/README.md).
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have hardly scratched the surface of MobX-State-Tree, but hopefully it has
    left an impression around organizing and structuring the observable state in MobX.
    It is a well-defined, community-driven approach that bakes in many of the best
    practices discussed throughout this book. For a deeper exploration of MST, you
    can refer to the official getting-started guide at: [https://github.com/mobxjs/mobx-state-tree/blob/master/docs/getting-started.md#getting-started](https://github.com/mobxjs/mobx-state-tree/blob/master/docs/getting-started.md#getting-started).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the practical aspects of adopting MobX with packages
    such as `mobx-utils` and `mobx-state-tree`. These packages codify the community
    wisdom around using MobX for a variety of scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: '`mobx-utils` gives you a set of utilities for tackling asynchronous tasks,
    dealing with expensive updates, creating view models for transactional-editing,
    and much more.'
  prefs: []
  type: TYPE_NORMAL
- en: '`mobx-state-tree` is a comprehensive package that is meant to simplify application
    development with MobX. It takes a prescriptive approach to structuring and organizing
    the observable state in MobX. With such a declarative approach, MST is able to
    get a deeper understanding of the state-tree and offer a variety of features,
    such as runtime type-checking, snapshots, JSON-patches, middlewares, and so on.
    Overall, it helps in developing a crisp mental model of your MobX application
    and puts the typed-domain-model at the forefront.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will culminate the journey on MobX with a peek into
    its inner workings. If there are parts of MobX that seem like *black magic*, the
    next chapter will dispel all such myths.
  prefs: []
  type: TYPE_NORMAL
