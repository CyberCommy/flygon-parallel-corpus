- en: Creating RESTful Endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have understood what a RESTful web services. We have also seen the
    new features in PHP7 which will make our code better and cleaner. Now, it is time
    to implement RESTful web services in PHP. So, this chapter is all about implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have seen an example of a blog having blog posts and comment endpoints.
    In this chapter, we will implement those endpoints. Here are the topics that we
    will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating REST API for a blog in PHP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a database schema
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blog user/author table schema
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blog post table schema
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blog post comments schema
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating REST API's endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating blog post endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To do
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visible flaws
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proper 404 pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a REST API for a blog in PHP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create REST API or RESTful web service for a blog, we first need to have
    blog entities. As we will be storing blog entities in a database and fetching
    the data from a database, we first need to create a database schema for those
    entities.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a database schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to create endpoints for two resources/entities, which are :'
  prefs: []
  type: TYPE_NORMAL
- en: Blog post
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Post comments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, we will be creating a database schema for these two resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how we will design a database schema for a blog having posts and comments.
    A post can have multiple comments and a comment always belongs to post. Here,
    we have SQL for the database schema. You will first need to create a database
    and you will need to run the following SQL to have posts and comments tables.
    If you haven''t created the database, then create it now. You can create it via
    some DB UI tool, or you can run the following SQL query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will create a database with the name `blog`.
  prefs: []
  type: TYPE_NORMAL
- en: Before creating a blog posts table and a blog post comments table, we will need
    to create a *users* table which will store the post or comment author's information.
    So first, let's create a users table.
  prefs: []
  type: TYPE_NORMAL
- en: Blog user/author table schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A users table can have the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`: It will have type integer, which will be unique and will have auto-incremented
    values. `id` will be the primary key of the users table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: It will have type `VARCHAR` with a length of 100 characters. In the
    case of `VARCHAR` 100, 100 characters is the limit. If the title in one entry
    will be less than 100 characters, let''s say only 13 character''s, then it will
    occupy 14 characters space. This is how `VARCHAR` works. It occupies one character
    more than the actual characters in the value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`email`: Email address will have type `VARCHAR` with a length of 50\. And the
    email field will be unique.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`password`: Password will have type `VARCHAR` with a length of 50\. We will
    be having the `password` field because later, at some stage, we will make the
    user log in using the `email` and `password`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There can be a lot more fields but for simplicity, we will only keep these fields
    for now.
  prefs: []
  type: TYPE_NORMAL
- en: SQL for users table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is the SQL for `users` table. Note, we are using MySQL as RDBMS
    in our example. There can be a slight change in the queries for other databases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This query will create a posts table as described above. The only thing that
    we haven't discussed is the database engine. The last line of this query `ENGINE
    = InnoDB` sets the database engine for this table as `InnoDB`. Also, on line 1,
    ``blog`` represents the name of the database. If you have named the database anything
    else other than blog, replace it with your database name.
  prefs: []
  type: TYPE_NORMAL
- en: We are only going to write the API's endpoint for posts and comments and are
    not going to write the endpoints for users, so we will add data to the users table
    manually using SQL Insert Queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the SQL Insert Queries to populate the `users` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As we are inserting two records having the `name`, `email`, and `password`,
    we set `id` to `null`. Since it is auto-incremented, it will be set automatically.
    Also, you can see a long random string in both records. This random string is
    the password. We set the same password for both users. However, the user will
    not be entering this random string as the password. This random string is encrypted
    an version of the user''s actual password. The user''s password is `qwerty`. This
    password was encrypted using the following PHP code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `password_hash()` function is the PHP recommended function for encrypting
    passwords. The first parameter is a `password` string. The second parameter is
    an encryption algorithm. While, the third parameter is an options array where
    we set a random string as salt. You can add a different salt as well.
  prefs: []
  type: TYPE_NORMAL
- en: However, this salt needs to be fixed for encrypting passwords every time because
    this encryption is a one-way encryption. That means the passwords can't be decrypted.
    So every time you need to match passwords, you will always have to encrypt the
    user provided password and match it with the one in the database. In order to
    match the user provided password and the one in the database, we need to use the
    same password function with the same arguments.
  prefs: []
  type: TYPE_NORMAL
- en: We are not making the user login functionality now, however, we will do that
    later.
  prefs: []
  type: TYPE_NORMAL
- en: Blog post table schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A blog post can have the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id` : It will have type integer. It will be unique and have auto-incremented
    values. `id` will be the primary key of the blog post.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title`: It will have type `varchar` with a length of 100 characters. In the
    case of `varchar` 100, 100 characters is the limit. If one post title will be
    less than 100 characters, let''s say a post''s title takes only 13 characters,
    then it will occupy 14 character''s space. It is how `varchar` works. It occupies
    one character more than the actual characters in the field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`status`: Status will be either published or draft. We will use `enum` for
    it. It has two possible values, `published` and `draft`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`content`: Content will be the body of the post. We will use the `text` data
    type for the content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`user_id`: `user_id` will be of type integer. It will be a foreign key and
    will relate with the `id` in the users table. This user will be the author of
    the blog post.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the sake of simplicity, we will have only these five fields. The `user_id`
    will contain the information of the user who is the author of the post.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an SQL query for creating a posts table:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the SQL for a posts table. Note, we are using MySQL as RDBMS
    in our example. There can be a slight change in the queries for other databases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This query will create a posts table as described earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we add foreign keys to restrict the `user_id` to have only values which
    are present in the users table. Here is how we will add that constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Blog post comments schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A blog post comment can have the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`: It will have type `integer`. It will be unique and will have auto-incremented
    values. `id` will be the primary key of the blog post.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`comment`: It will have type `varchar` with a length of `250` characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`post_id`: `post_id` will be of type integer. It will be the foreign key related
    to the `id` from the posts table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`user_id`: `user_id` will be of type `integer`, it will be the foreign key,
    and will relate with the `id` in the users table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, `user_id` is the ID of the author/writer of the comment while `post_id`
    is the ID of the post on which the comment is made.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an SQL query for creating a `comments` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding foreign key constraints for both `user_id` and `post_id`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: By running all these SQL queries, you will have most of the DB structure set
    up to proceed toward creating the RESTful API's endpoint in PHP.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a RESTful API's endpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before creating the RESTful API''s endpoint specific to resources, let''s first
    create directories in which we will place our code. Create a `blog` directory
    somewhere, your `home` directory, in case Linux is preferable. Then, create an
    `api` directory in the `blog` directory. We will place all our code in the `api`
    directory. If you are a command line fan or a seasoned Ubuntu user, simply run
    the following command to create these directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'So, `api` is the directory where we will place our code. As you know, we are
    going to write code for endpoints related to two resources: blog posts and post
    comments. Before proceeding toward writing code specific to blog posts, let''s
    first see how we are going to structure our code.'
  prefs: []
  type: TYPE_NORMAL
- en: Code structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Code can be written in many ways. We can either create different files for
    posts and comments such as `posts.php` and `comments.php` and let the user access
    them from a URL; for example, the user can write: [http://localhost:8000/posts.php](http://localhost:8000/posts.php)
    which can execute code in `posts.php`. The same can also be done in `comments.php`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a very simple way but it has two problems:'
  prefs: []
  type: TYPE_NORMAL
- en: The first problem is that `posts.php` and `comments.php` will have different
    code. This means, if we have to use the same code across these different files,
    we will need to either write or include all common things in both these two files.
    In fact, if there will be more resources, then we will need to create a different
    file for every resource and in every new file, we will need to include all that
    common code. Although there are only two resources right now, we also need to
    think for extensibility. So in this approach, we will need to have the same code
    in all the files. Even if we are just doing include or require, we will need to
    do so in all files. However, this can be solved or minimized by having the minimum
    files to include or require.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second problem is related to how it will look in the URL. In the URL, the
    fact file to be used is mentioned, so what if after having our endpoints done
    and the API is given to frontend developers, we need to change the file name on
    the server? The web service from the frontend application will not work unless
    we change the file name in the URL in the frontend application. This points toward
    an important issue about our request and how the things stored on the server.
    So that means our code will be tightly coupled. This shouldn't happen as we stated
    in the constraints of REST in [Chapter 1](42e167df-3aca-4f21-8d1d-c39d5865ab39.xhtml),
    *RESTful Web Services, Introduction and Motivation*. This `.php` extension exposes
    not only that we are using PHP at server side, but also our file structure is
    exposed to everyone who knows the endpoint URL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The solution to problem one can be the include and require statements. Although,
    require or include statements will still be required to be in all files, and if
    one include statement needs to be changed in one file, we will need to do it in
    all the files. So, not a good way but the first problem can be solved. However,
    the second problem is a bit more critical. Some of you who have used the `.htaccess`
    file of Apache for URL rewriting will probably be thinking that URL rewriting
    will solve the problem. Yes, it can solve the problem of tight coupling between
    the request URL and the files on the file system but it will work only if we are
    using Apache as a server.
  prefs: []
  type: TYPE_NORMAL
- en: However, with the passage of time, you will see more and more use cases and
    you will realize that this way is not very scalable. In this, we are not following
    some pattern except that we are including the same code in all resource files.
    Also, using `.htaccess` for URL rewriting may work but it is not recommended to
    use it as a complete router because it will have its own limitations.
  prefs: []
  type: TYPE_NORMAL
- en: 'So what is the solution of this? What if we can have a single entry point?
    What if all the requests will go through that same entry point and then route
    toward the appropriate code? That will be a better approach. The request will
    be related to the post or comment, it must go through the same single entry point,
    and at that entry point we can include whatever code we want. That entry point
    will then route the request toward the appropriate code. This will solve both
    problems. Also, things will be in a pattern, as the code for each resource will
    follow the same pattern. This pattern that we just discussed is also known as
    the front controller. You can read more about the front controller at wiki: [https://en.wikipedia.org/wiki/Front_controller](https://en.wikipedia.org/wiki/Front_controller).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we know that we will be using the front controller pattern so for that,
    our entry point will be `index.php` file. So let''s create `index.php` in the
    `api` directory. For now, let''s put an echo statement so we can test and run
    and see at least `hello world` using the PHP built-in server. Later, we will add
    proper content in the `index.php` file. So, put this in `index.php` for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To test it, you will need to run the PHP built-in server. Note, you don''t
    need to have Apache or NGINX just to run PHP code. PHP has a built-in server and,
    although this is good for testing and the development environment, this is not
    recommended for production use. As we are in the development environment on our
    local machine, let''s run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This will let you hit `http://localhost:8000` and will output `hello World`
    through the PHP built-in server. So now, we are ready to start writing actual
    code to have our RESTful endpoints working.
  prefs: []
  type: TYPE_NORMAL
- en: Common components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before proceeding toward endpoints, let''s first identify and tackle things
    that we will need in serving all endpoints. Here are those things:'
  prefs: []
  type: TYPE_NORMAL
- en: Error reporting settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open `index.php`, remove the old hello world code and place this code in the
    `index.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: On the first two lines, we are basically making sure that we can see errors
    if there are errors in our code. The actual magic is happening in the last statement
    where we are requiring `bootstrap.php`.
  prefs: []
  type: TYPE_NORMAL
- en: It is just another file that we are going to create in the `~/blog/core` directory.
    In the blog directory, we are going to create a core directory as we will keep
    a part of the code that is relevant to the flow and pattern of our code execution
    in the core directory. It will be the code that is not relevant to the endpoints
    or logic of our API. This core code will be created once and we can use the same
    core across different applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s create `bootstrap.php` in the `blog/core` directory. Here is what
    we will write in `bootstrap.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Basically, this is going to load everything and execute. `bootstrap.php` is
    the structure of how our application will run. So let's dig into it.
  prefs: []
  type: TYPE_NORMAL
- en: The first statement requires a `DB` class from the same directory, that is the
    core directory. The `DB` class is also a core class and it will be responsible
    for DB related stuff. The second statement requires a router that will direct
    the URL to proper files. While the third requires routes telling which file to
    serve in case of which URL.
  prefs: []
  type: TYPE_NORMAL
- en: We will look into both the `DB` and `Router` classes one by one but let's first
    look at `routes.php` having routes specified. Note that `routes.php` is application
    specific so it's content will vary based on our application URLs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the content of `blog/routes.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You can see it is just populating a `$routes` array. Here, posts and comments
    are part of the URL that we are expecting and if the URL will have posts, it will
    serve the `posts.php` file, and it will serve `comments.php` if the URL will have
    comments in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth requirement in `bootstrap.php` is having application configurations
    such as `DB` settings. Here is a sample content of `blog/config.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's look at the `DB` and `Router` classes one by one so we can understand
    what exactly is going on in `blog/core/bootstrap.php`.
  prefs: []
  type: TYPE_NORMAL
- en: DB class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is the code of the `DB` class in `blog/core/DB.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This class is related to the database. Right now, we have a constructor that
    is actually connecting to the database using `PDO` and `$db` arrays defined in
    `blog/config.php`. However, we will add more in this class later.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see we are using a `PDO` object here: **PDO** (**PHP Data Objects**).
    It is used to interact with databases and is a recommended one because it doesn''t
    matter which database we want to use, we just need to change the connection string
    and the remaining will work fine. This string: `"mysql:host=$host;dbname=blog"`
    is the connection string. This code in `DB.php` will create a connection with
    the database and this connection will close with the end of the script. We used
    `try catch` here because it is good to use exception handling when anything from
    outside of our code is being triggered.'
  prefs: []
  type: TYPE_NORMAL
- en: Till now, we have looked into the `DB` class, `routes.php` (routes associative
    array), and `config.php` (settings associative array). Now we need to look into
    the content of the `Router` class.
  prefs: []
  type: TYPE_NORMAL
- en: Router class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is an implementation of the `Router` class at `blog/core/Router.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`Router` has two methods, `Router::setRoutes(Array $routes)` and `Router::getFilename()`.
    `setRoutes()` is taking an array of routes and storing it. Then, the `getFilename()`
    method is responsible for deciding which file to serve against which URL. We are
    not comparing the whole URL but we are using `strpos()` that checks if the string
    in `$route` exists in `$url` and, if it exists, it returns the appropriate filename.'
  prefs: []
  type: TYPE_NORMAL
- en: Code sync
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make sure we are on the same page, here is what should be in your `blog`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '`blog`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`blog/config.php`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`blog/routes.php`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`blog/core`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`blog/core/DB.php`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`blog/core/Router.php`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`blog/core/bootstrap.php`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`blog/api`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`blog/api/index.php`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`blog/api/posts.php`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note, `blog/api/posts.php` doesn't have any proper content till now, so you
    can keep anything that can be just viewed in the browser so you know that this
    content is coming from `posts.php`. Other than that, if you are missing anything,
    then compare it with the code provided to you with this `book.boostrap.php` review.
  prefs: []
  type: TYPE_NORMAL
- en: 'Anyway, you have seen the content of all files included in `bootstrap.php`,
    so now you can look back at the `bootstrap.php` code to understand things better.
    That content is placed again so you can see it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is just including the `config` and `routes` files and including
    `Router` and `DB` classes. Here, it is setting the routes coming in `$routes`,
    as written in `routes.php`. And then, based on the URL, it is getting the filename
    which will serve that URL and require that file. We are using `$_SERVER['REQUEST_URI']`;
    it is a super global variable having a URL path that is after the host name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Till now, we are done with common code making application structure. Now if
    your `blog/api/posts.php` contains code like my `posts.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'On starting the PHP server by saying: `php -S localhost:8000` and then in the
    browser hitting: `http://localhost:8000/posts`, you should see: *Posts will come
    here*.'
  prefs: []
  type: TYPE_NORMAL
- en: In case you are unable to run it, I would suggest to go back and check what
    you have missed. You can also use the code given to you with this book. In any
    case, it is important to have this code written and running successfully at this
    point because just reading is not enough, practice makes you better.
  prefs: []
  type: TYPE_NORMAL
- en: Creating blog post endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Till now, we are done with most of the common code. So let's look at blog post
    endpoints. In blog post endpoints, the first one is the blog posts listing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Blog posts listing endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: 'URI: `/api/posts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Method: `GET`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, let''s replace the previous code in `posts.php` with the proper code to
    serve posts. And to serve this, put the following code in the `posts.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are checking if the method is `GET` and the URL is `/posts`, and we
    are getting data from a function named `getAllPosts()`. For the sake of simplicity,
    we are getting data from a hardcoded array instead of a database. However, we
    actually need to get the data from the database. Let''s add the code to get the
    data from the database. Here is what it will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If you execute this code, you will get an empty array in JSON format, which
    is fine. An empty array is shown as there is no record in the posts table right
    now. Let's create and use the add post endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Blog post creation endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: 'URI: `/api/posts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Method: `POST`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Parameters: `title`, `status`, `content`, `user_id`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we are just making these endpoints work without user authentication so
    we are passing `user_id` by ourselves. So, it should be `id` from users table.
  prefs: []
  type: TYPE_NORMAL
- en: 'To have this working, we need to add in `posts.php`. Then new code is mentioned
    in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have placed another check, so if the method will be `POST`
    then it will run the `addPost()` method. In the `addPost()` method, `POST` is
    being added. We have used the same `PDO` prepare and execute statements.
  prefs: []
  type: TYPE_NORMAL
- en: However, this time we have also used `bindValue()`. First, we add a static string
    in the `INSERT` statement with a colon, such as `:title, :status`, and then we
    use a bind statement to bind the variable with those static strings. So what is
    the purpose of doing this? The reason is that we can't trust user input. Directly
    adding user input inside an SQL query can result in SQL injection. So to avoid
    SQL injection, we can use the `PDO::prepare()` function with `PDOStatement::bindValue()`.
    In the `prepare()` function, we provide a string while `bindValue()` binds the
    user input with that string. So, this `PDOStatement::bindValue()` doesn't only
    replace those strings with input parameters but makes sure that SQL injection
    doesn't occur.
  prefs: []
  type: TYPE_NORMAL
- en: We have also used `PDO::lastInsertId()`. This is to return the auto-incremented
    `id` of the record that was just created.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `addPost()` method, we are using the `bindValue()` method repeatedly
    for different fields. If there will be more fields then we probably need to write
    it even more times repeatedly. To avoid that, we change the `addPost()` method
    code to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see `PDOStatement::bindValue()` calls are replaced with one `bindAllValues()`
    function call which takes `PDOStatement` as the first parameter and user input
    as the second parameter. `bindAllValues()` is a custom function that we have written,
    so here is an implementation of the `bindAllValues()` method that we will write
    in the same `posts.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Since we have written it as a separate generic function, we can use it in multiple
    places. Also, no matter how many fields in the posts tables we have, we will not
    need to call the same `PDOStatement::bindValue()` method repeatedly in our code.
    We will just add more fields in the `$allowedFields` array and the `bindValue()`
    method will be called automatically.
  prefs: []
  type: TYPE_NORMAL
- en: In order to test a `POST` request, we can't simply hit a URL from the browser.
    For testing a `POST` request, we need to use some sort of REST client or create
    and submit a form with `POST`. REST client is a better, easier and simpler way.
  prefs: []
  type: TYPE_NORMAL
- en: REST client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the very popular REST clients is Postman. Postman is a Google Chrome
    app. If you are using Chrome, then you can install this app from here: [https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop/related?hl=en](https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop/related?hl=en).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you open Postman, you will be able to select the method as POST or any
    other method and, on selecting the Body tab, you will be able to set field names
    and values and then hit Send. Check the following screenshot of Postman having
    fields set and the responses. This will give you an idea about how Postman can
    be used for post requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f2c4dc92-00bf-4465-b0c6-2b8aa9f8ae90.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see the POST request has been sent through this Postman and it's result
    is successful as we intended. For all the endpoints testing, Postman can be used.
  prefs: []
  type: TYPE_NORMAL
- en: After running this POST based post creation endpoint, we can again test the
    listing of a post's endpoint and it will return data this time as now there is
    a post.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look into get single post, update post, and delete post's endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Get single post endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: 'URI: `/api/posts/{id}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Method: `GET`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This URL with a `GET` method should return a single post based on the ID provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it happen, we need to do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Add` a condition where the method is `GET` and the URL is of this pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to write and call the `getPost()` method that fetches a single post
    from the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to add the following code in `posts.php`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will add a condition and code to return single post:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are checking if the pattern is `/posts/{id}` where `id` can be any
    number. And then we are calling our custom function `getPost()` that will fetch
    the post record from the database. So, here is the `getPost()` implementation
    that we will add in the same `posts.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This code is simply fetching a single record from the database as an associative
    array which can be clearly seen from the last line. Other than that, the `SELECT`
    query and its execution is simple enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update post endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: 'URI: `/api/posts/{id}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Method: `PATCH`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Parameters: `title`, `status`, `content`, `user_id`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here `{id}` will be replaced by the actual post's ID. Note, as we are using
    the `PATCH` method, only those attributes should be updated that will be present
    in the input method.
  prefs: []
  type: TYPE_NORMAL
- en: Here we are passing `user_id` as a parameter but it is just because we don't
    have authentication working otherwise it is strictly prohibited to pass `user_id`
    as parameter. `user_id` should be the id of authenticated user and that should
    be used instead of getting `user_id` in parameter. Because it can let any user
    pretend to be someone else by passing another `user_id` in parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that while using `PUT` or `PATCH`, parameters should be passed through
    a query string, only `POST` has parameters in the body.
  prefs: []
  type: TYPE_NORMAL
- en: Let's update our code of `posts.php` to support the update operation as well
    and we will then look more into that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code to add in `posts.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'First, it checks if the URL is of the format : `/posts/{id}` and then checks
    if the `Request` method is `PATCH`. In that case, it calls the `updatePost()`
    method. The `updatePost()` method gets key value pairs as comma separated strings
    through the `getParams()` method. Then make a query, bind values, and `postId`.
    This is very similar to the `INSERT` method. And then in the condition block,
    we echo a JSON encoded form of the record that is updated. This is all very similar
    to what we did in the case of post creation and get single post.'
  prefs: []
  type: TYPE_NORMAL
- en: One thing you should note is, we are getting parameters from `$_GET` that are
    query strings. It is because, in the case of `PATCH` and `PUT`, parameters are
    passed in query strings. So while testing through Postman or any other REST client,
    we need to pass parameters in query strings, not the body.
  prefs: []
  type: TYPE_NORMAL
- en: 'Delete post endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: 'URI: `/api/posts/{id}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Method: `DELETE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is very similar to getting a single blog post endpoint but here, the method
    is `DELETE`, so the record will be deleted instead of being viewed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code to add in `posts.php` to delete a blog post record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: After looking at insert, get, and update post's endpoint code, this code is
    very simple. Here, the main work is in the `deletePost()` method but it is also
    very similar to the other methods.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we are now done with posts related to endpoints. However, right now
    all the data that we are returning as JSON it not actually JSON for client(browser
    or Postman). It is still viewing it as a string and considering it as HTML. It
    is because we are returning as JSON but it is still a string. To tell client to
    take it as JSON we need to specify `Content-Type` in header before any output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Just to make sure that our `posts.php` file is the same, here is a complete
    code of `posts.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note, this code is very basic and it has many flaws that we will see in the
    next chapters. This is just to give you a direction of how you can do it in core
    PHP but this is not the best approach.
  prefs: []
  type: TYPE_NORMAL
- en: To do
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we are done with Post CRUD endpoints, you need to create the Comments CRUD
    endpoints. It shouldn't be difficult as we have already put comments in routes
    by which you know that we will add `comments.php` similar to `posts.php`. And
    you can also view the logic in the `posts.php` file, as `comments.php` will have
    same operations and will have the similar code. So now, it is your time to code
    for `comments.php` CRUD related endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Visible flaws
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although the code we discussed in the previous sections will work, there are
    many loopholes in it. We will look into the different problems in the next chapters,
    however here let''s see three of them here and also see how we can solve them:'
  prefs: []
  type: TYPE_NORMAL
- en: Validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No response in case of 404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Right now in our code, although we are using `PDO` prepare and `bindValue()`
    methods, it will just save it from SQL injection. However, we are not validating
    all fields in the case of insert and update. We need to validate that the title
    should be of a specific limit, the status should be either draft or published,
    and the `user_id` should be always one of IDs in the users table.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first and simple solution is to place manual checks to validate data coming
    from the user's end. This is simple but it is a lot of work. That means it will
    work but we can miss something, and if we do not miss any check, it will be a
    lot of low level detail to deal with.
  prefs: []
  type: TYPE_NORMAL
- en: So a better way is to utilize some open source package or tool already available
    in the community. We will look and use such tools or packages in the upcoming
    chapters. We will also use such packages to validate data in the upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, this is not only true about validation, but there is still a lot of
    low level work that we are doing by ourselves in this chapter. So, we will look
    at how we can minimize our efforts on low level stuff by using different tools
    available in the PHP community.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Right now, we are letting anyone add, read, update, and delete any record. It
    is because there is no authenticated user. Once there is an authenticated user,
    we can place different constraints such as that a user shouldn't be able to delete
    or update the content of a different user and so on.
  prefs: []
  type: TYPE_NORMAL
- en: So why didn't we simply put in place session based authentication having a **Session
    ID** in an HTTP Only cookie? This is done in traditional websites. We start the
    session, put the user data in session variables and the session ID is stored in
    an HTTPOnly cookie. The server always reads that HTTP Only cookie and gets a session
    ID to know which session data belongs to this user. This is what happens in a
    typical website developed in PHP. So why don't we simply use the same thing for
    authentication in the case of RESTful web services?
  prefs: []
  type: TYPE_NORMAL
- en: Because RESTful web services are not intended to be only called through a web
    browser. It can be anything such as a mobile device, another server, or it can
    be a **SPA** (**Single Page Application**). So, we need a way that can work with
    any of these things.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A solution is that we will use a simple token, instead of a session ID. And
    instead of cookies, that token will be just sent to the client and the client
    will always take that token in every request to identify the client. Once the
    client is taking the token in every request, it doesn't matter if the client is
    a mobile application, SPA, or anything else. We will simply identify the user
    based on the token.
  prefs: []
  type: TYPE_NORMAL
- en: Now the question is how to create and send back a token? This can be done manually
    but again, why create it if this is already available in open source and tested
    by the community? In fact, in the later chapters, we will use such a package,
    and use tokens for authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Proper 404 pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we don't have a proper 404 page if the page or record we are looking for
    doesn't exist. It is because we are not handling this in our router. The router
    is very basic but again, this is low level stuff and we can find such routers
    in open source. We will use this in later chapters as well.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We created a basic RESTful web service and provided basic CRUD operations. However,
    there are a lot of issues in the current code which we will see and address in
    the next chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have written PHP code to create a basic RESTful web service in this chapter,
    though it is not the best way to do it--this is just to give you a direction.
    Here are some resources from where you can learn to write better PHP code. This
    is a quick reference for PHP best practices: [http://www.phptherightway.com/](http://www.phptherightway.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: To adopt the standard coding style and practice, you can read PHP coding standards
    and style at [http://www.php-fig.org/](http://www.php-fig.org/).
  prefs: []
  type: TYPE_NORMAL
- en: I recommend that you spend some time on these two URLs so that you can write
    better code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look into this in detail and will identify different
    flaws in this code including security and design flaws. And also, look at different
    solutions.
  prefs: []
  type: TYPE_NORMAL
