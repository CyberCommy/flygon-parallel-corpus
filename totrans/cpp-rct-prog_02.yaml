- en: A Tour of Modern C++ and its Key Idioms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The classic C++ programming language was standardized in 1998 and it was followed
    by a small revision (mostly corrections) in 2003\. To support advanced abstractions,
    developers relied on the Boost ([http://www.boost.org](http://www.boost.org))
    library and other public domain libraries. Thanks to the next wave of standardization,
    the language (from C++ 11 onward) was enhanced, and now developers can encode
    most widely used abstractions (supported by other languages) without relying on
    external libraries. Even threads and file-system interfaces, which came squarely
    under the aegis of libraries, are now part of the standard language. Modern C++
    (which stands for C++ versions 11/14/17 ) contains superb additions to the language
    and its libraries, that make C++ the de-facto choice for writing industrial strength
    production software. The features covered in this chapter are the minimum set
    of features that a programmer has to understand to work with Reactive Programming
    constructs in general and RxCpp in particular. The primary objective of this chapter
    is to cover the most important additions to the language which makes implementing
    Reactive Programming constructs easier without resorting to esoteric language
    techniques. Constructs such as Lambda functions, automatic type inference, rvalue
    references, move semantics, and language level concurrency are some of the constructs
    which the authors of this book feel that every  C++ programmer should know. In
    this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Key concerns for C++ programming language design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some enhancements to C++ for writing better code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Better memory management through rvalue references and move semantics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Better object lifetime management using an enhanced set of smart pointers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behavioral parameterization using Lambda functions and expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function Wrappers (the `std::function` type)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Miscellaneous features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing Iterators and Observers (to put everything together)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The key concerns of the C++ programming language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As far as developers are concerned, the three key concerns that C++ programming
    language designers keep in mind were (and still are) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Zero Cost Abstraction - No performance penalty for higher level abstraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expressivity - A **user defined type** (**UDT**) or class should be as expressive
    as built-in types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Substitutability - A UDT can be substituted wherever built-in-types are expected
    (as in generic data structures and algorithms)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss these briefly.
  prefs: []
  type: TYPE_NORMAL
- en: Zero cost abstraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++ programming language has always helped developers to write code that
    exploits the microprocessor (on which generated code runs) and also raise the
    level of abstraction when it matters. While raising the abstraction, the designers
    of the language have always tried to minimize (almost eliminate) their performance
    overhead. This is called Zero Cost Abstraction or Zero Overhead Cost Abstraction.
    The only notable penalty you pay is the cost of indirect calls (through function
    pointers) while dispatching virtual functions. Despite adding tons of features
    to the language, the designers have maintained the "Zero Cost Abstraction" guarantee
    implied by the language from its inception.
  prefs: []
  type: TYPE_NORMAL
- en: Expressivity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C++ helps a developer to write user defined types or classes that can be as
    expressive as the built-in types of the programming languages. This enables one
    to write a arbitrary-precision arithmetic class (monikered as `BigInteger`/`BigFloat`
    in some languages), which contains all the features of a double or float. For
    the sake of explanation, we have defined a `SmartFloat` class that wraps IEEE
    double precision floating point numbers and most of the operators available to
    the double data type is overloaded. The following code snippets show that one
    can write types that mimic the semantics of built-in types such as int, float,
    or double:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SmartFloat` class wraps a double value and has defined some constructors
    and assignment operators to initialize instances properly. In the following snippet,
    we will define some operators that help to increment the value. Both the prefix
    and postfix variants of operators are defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippets implement increment operators (both prefix and postfix)
    and are meant for demonstration purposes only. In a real-world class, we will
    check for floating point overflow and underflow to make the code more robust.
    The whole purpose of wrapping a type is to write robust code!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippets implement C++ style assignment operators and once
    again, to make the listing short, we have not checked whether any floating point
    overflow or underflow is there. We do not handle exceptions as well here to keep
    the listing brief.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code implements relational operators and most of the semantics
    associated with double precision floating points have been implemented as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'For the sake of completeness, we have implemented conversion operators to `int`
    and `double`. We will write two functions to aggregate values stored in an array.
    The first function expects an array of `double` as parameter and the second one
    expects a `SmartFloat` array as parameter. The code is identical in both routines
    and only the type changes. Both will produce the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The C++ language helps us write expressive types that augment the semantics
    of basic types. The expressiveness of the language also helps one to write good
    value types and reference types using a myriad of techniques supported by the
    language. With support for operator overloading, conversion operators, placement
    new, and other related techniques, the language has taken the class design to
    a higher level compared to other languages of its time. But, with power comes
    responsibility and the language sometimes gives you enough rope to shoot yourself
    in the foot.
  prefs: []
  type: TYPE_NORMAL
- en: Substitutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous example, we saw how a user-defined type can be used to express
    all the operations done on a built-in type. Another goal of C++ is to write code
    in a generic manner where we can substitute a user-defined class that mimics the
    semantics of one of the built-in types such as `float`, `double`, `int`, and so
    on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The C++ programming language supports different programming paradigms and the
    three principles outlined previously are just some of them. The language gives
    support for constructs that can help create robust types (domain-specific) for
    writing better code. These three principles gave us a powerful and fast programming
    language for sure. Modern C++did add a lot of new abstractions to make the life
    of a programmer easier. But the three design principles outlined previously have
    not been sacrificed in any way  to achieve those objectives. This was partly possible
    because of the meta programming support the language had due to the inadvertent
    Turing completeness of the template mechanism. Read about **template meta programming**
    (**TMP**) and Turing Completeness  with the help of your favorite search engine.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancements to C++ for writing better code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The programming language universe has changed a lot in the last decade and those
    changes should reflect in the  C++ programming language in its new avatar. Most
    of the innovations in Modern C++ involve handling advanced abstractions and the
    introduction of functional programming constructs to support language level concurrency.
    Most modern languages have got a garbage collector and a run-time manages these
    complexities. The C++ programming language does not have automatic garbage collection
    as part of the language standard. The C++ programming languages with its implicit
    guarantee of Zero cost abstraction (you do not pay for what you do not use) and
    maximum run-time performance, has to resort to a lot of compile-time tricks and
    meta programming techniques to achieve the abstraction level supported by a language
    such as C#, Java, or Scala. Some of them are outlined in the following sections
    and you can delve into these topics yourself. The website [http://en.cppreference.com](http://en.cppreference.com)
    is a good site for advancing your knowledge of the C++ programming language.
  prefs: []
  type: TYPE_NORMAL
- en: Type deduction and inference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Modern C++ language compiler does a wonderful job of deducing types from
    the expressions and statements specified by the programmers. Most modern programming
    languages do have support for type inference and so does Modern C++. This is an
    idiom borrowed from Functional Programming languages such as Haskell and ML. Type
    inferences are already available with the C# and Scala programming languages.
    We will write a small program to kick-start us with type inference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `auto` keyword specifies that the type of the variable will be deduced
    by the compiler based on initialization and the return values of functions specified
    in the expression. In this particular example, we do not gain much. As our declarations
    get more complicated, it is better to let the compiler do the type inference.
    Our code listings will use auto to simplify the code throughout the book. Now,
    let us write a simple program to make the idea even more clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code demonstrates the use of type inference while writing Modern
    C++ code. The C++ programming language also has a new keyword that helps to query
    the type of expression given as arguments. The general form of the keyword is
    `decltype(<expr>)`. The following program helps to demonstrate the use of this
    particular keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `decltype` is a compile-time construct and it helps to specify the type
    of a variable (the compiler will do the hard work to figure it out) and also helps
    us to force a type on a variable (see the preceding `fancy()` function).
  prefs: []
  type: TYPE_NORMAL
- en: Uniform initialization of variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Classic C++ had some kind of ad-hoc syntax for the initialization of variables.
    Modern C++ supports uniform initialization (we have already seen examples in the
    type inference section). The language provides helper classes to developers to
    support uniform initialization for their custom types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding listing shows how one can enable initialization lists for a custom
    class created by a programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Variadic templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In C++ 11 and above, there is support for variadic templates as part of the
    standard language. A variadic template is a template class or template function
    that takes a variable number in a template argument. In classic C++, template
    instantiation happens with a fixed number of parameters. Variadic templates are
    supported both at class level and function level. In this section, we will deal
    with variadic functions as they are used extensively in writing functional-style
    programs, compile-time programming (meta programming), and pipeable functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the compiler synthesizes a function based on the number
    of arguments passed. The compiler understands that `add` is a variadic function
    and generates the code by recursively unpacking the parameters during compile
    time. Compile time recursion will stop when the compiler has processed all the
    parameters. The base case version is a hint to the compiler to stop recursion.
    The next program shows how variadic templates and perfect forwarding can be used
    to write a function that takes an arbitrary number of parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The three variants of `EmitConsole` print the argument to the console. We have
    functions for printing `int`, `double`, and `string`. Using these functions as
    a base case, we will write a function that uses universal references and perfect
    forwarding to write functions that take arbitrary values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Rvalue references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have been programming in C++ for a long time, you might be familiar
    with the fact that C++ references help you to alias a variable and you can do
    assignment to the references to reflect the mutation in the variable aliased.
    The kinds of reference supported by C++ were called lvalue references (as they
    were references to variables that can come in the left side of the assignment).
    The following code snippets show the use of lvalue references:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`int&` is an instance of lvalue references. In Modern C++, there is the notion
    of rvalue references. rvalue is defined as anything that is not an lvalue, the
    kind of stuff that can appear on the right side of the assignment. In classic
    C++, there was no notion of an rvalue references. Modern C++ introduced it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Rvalue references are indicted by two `&&`. The following program will clearly
    demonstrate the use of rvalue references while invoking functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The real power of rvalue references is visible in the case of memory management.
    The C++ programming language has got the notion of Copy constructor and Assignment
    operators. They mostly copy the source object contents. With the help of rvalue references,
    one can avoid expensive copying by swapping pointers, as rvalue references are
    temporaries or intermediate expressions. The following section demonstrates this.
  prefs: []
  type: TYPE_NORMAL
- en: Move semantics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The C++ programming language implicitly warrants a Copy Constructor, Assignment
    Operator, and a Destructor (some times virtual) with every class designed by us.
    This is meant to do resource management while cloning an object or while assigning
    to an existing object. Sometimes it is very expensive to copy an object and the
    movement of ownership (through pointers) helps in writing fast code. Modern C++
    has got a facility to provide a Move Constructor and a Move assignment operator
    to help developers avoid copying large objects, during the creation of a new object
    or assignment to a new object. Rvalue references can act as a hint to the compiler
    that, when temporary objects are involved, a move version of a constructor or
    a move version of assignment is better suited for the context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `std::move` function can be used to indicate (while passing parameters)
    that the candidate object is movable and the compiler will invoke appropriate
    methods (move assignment or move constructor ) to optimize the cost associated
    with memory management. Basically, `std::move` is a `static_cast` to an rvalue
    reference.
  prefs: []
  type: TYPE_NORMAL
- en: Smart pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Managing object lifetimes has been a problematic area for the C++ programming
    language. If the developer is not careful, the program can leak memory and will
    slow down performance. Smart pointers are wrapper classes around a raw pointer
    where operators such as dereferencing (*) and referencing (->) are overloaded.
    Smart pointers can do object lifetime management, act as a limited form of garbage
    collection, free memory, and so on. The Modern C++ language has:'
  prefs: []
  type: TYPE_NORMAL
- en: '`unique_ptr<T>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shared_ptr<T>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`weak_ptr<T>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A `unique_ptr<T>` is a wrapper for a raw pointer where there is exclusive ownership
    with the wrapper. The following code snippet will demonstrate the use of `<unique_ptr>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`std::shared_ptr` is a smart pointer that uses reference counting to keep track
    of references made to a particular instance of an object. The underlying object
    is destroyed when the last remaining `shared_ptr` pointing to it is destroyed
    or reset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`std:weak_ptr` is a container for a raw pointer. It is created as a copy of
    a `shared_ptr`. The existence or destruction of `weak_ptr` copies of a `shared_ptr`
    have no effect on the `shared_ptr` or its other copies. After all copies of a
    `shared_ptr` have been destroyed, all `weak_ptr` copies become empty. The following
    program demonstrates a mechanism that helps us to detect defunct pointers using
    `weak_ptr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Classic C++ had a smart pointer type called `auto_ptr` and it has been removed
    from the language standard. One needs to use `unique_ptr` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the major additions to the C++ language is Lambda functions and Lambda
    expressions. They are anonymous functions that the programmer can define at the
    call site to perform some logic. This simplifies the logic and code readability
    also increases in a remarkable manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than defining what a Lambda function is, let us write a piece of code
    that helps us count the number of positive numbers in a `vector<int>`. In this
    case, we need to filter out the negative values and count the rest. We will use
    an STL `count_if` to write the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, the variable filter is assigned an anonymous
    function and we are using the filter in the `count_if STL` function. Now, let
    us write a simple Lambda function that we will specify at the function call site.
    We will be using STL accumulate to aggregate the values inside a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Functors and Lambdas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In classic C++, while using STL, we extensively use Function Objects or Functors
    by overloading Function Operators to write transformation filters and perform
    reduction on STL containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following program clearly demonstrates the usage of Lambda by writing a
    toy sort program. We will show how we can use Function Objects and Lambdas to
    write equivalent code. The code is written in a generic manner, but it makes an
    assumption that numbers are expected (`double`, `float`, `integer`, or a user
    defined equivalent):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`Cmp` and `Swap` are generic functions that will be used to compare adjacent
    elements and swap elements, respectively, while performing the sort operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Armed with Cmp and Swap, writing a bubble sort is a simple affair. We need
    to have a nested loop where we will compare two elements and if Cmp returns true,
    we will invoke Swap to exchange values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding routine, we define the comparison and swap function as Lambdas.
    The Lambda function is  a mechanism to specify a piece of code or expression inline,
    often called anonymous functions. The definition can be given in a syntax specified
    by the C++ language, and can  be assigned to a variable, passed as a parameter
    , or returned from a function.  In the preceding function, the variables `CmpLambda`
    and `SwapLambda` are examples of anonymous functions specified in Lambda syntax.
    The body of the Lambda functions is not much different from the preceding function
    version. To learn more about Lambda functions and expression, you can consult
    the page at [http://en.cppreference.com/w/cpp/language/lambda](http://en.cppreference.com/w/cpp/language/lambda).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Print` routine just cycles through the elements in the container and prints
    the contents to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Composition, currying, and partial function application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One advantage of Lambdas is you can compose two functions together to create
    a composition of functions as you do in mathematics (read about function composition
    in the context of mathematics and functional programming  using favorite search
    engine). The following program demonstrates the idea. This is a toy implementation
    and writing a general-purpose implementation is beyond the scope of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`Compose` is a variadic template function and the compiler generates code by
    recursively expanding the `Compose` arguments until all the arguments are processed.
    In the preceding code, we have used `[=]` to indicate to the compiler that we
    should capture all variables referenced in the body of the Lambda by value. You
    can study more about Closure and Variable Capture in the context of functional
    programming. The C++ language gives flexibility to `Capture` variables by value
    (as well as using `[&]`) or by specifying variables to be captured explicitly
    (such as `[&var]`).'
  prefs: []
  type: TYPE_NORMAL
- en: The functional programming paradigm is based on a mathematical formalism called
    Lambda calculus invented by Alonzo Church, an American mathematician. The Lambda
    calculus supports only unary functions and currying is a technique that breaks
    a multiple argument function into a series of function evaluations that take one
    argument at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Lambdas and writing functions in a specific manner, we can simulate currying
    in C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The partial function application involves the conversion of functions with multiple
    arguments into a fixed number of arguments. If the fixed number of arguments is
    less than the arity (parameter count) of the function, a new function will be
    returned that expects the rest of the parameters. When all parameters are received,
    the function will be invoked. We can treat the partial application as some form
    of memorization where parameters are cached until we receive all of them to invoke
    them.
  prefs: []
  type: TYPE_NORMAL
- en: In the following code snippets, we have used  constructs like template parameter
    pack and variadic templates. A template parameter pack is a template parameter
    that accepts zero or more template arguments (non-types, types, or templates).
    A function parameter pack is a function parameter that accepts zero or more function
    arguments. A template with at least one parameter pack is called a variadic template.
    A good idea about parameter pack and variadic templates is necessary for understanding
    `sizeof...`  constructs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Function wrappers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Function wrappers are classes that can wrap any functions, function objects,
    or Lambdas into a copiable object. The type of the wrapper depends upon the function
    prototype of the class. `std::function(<prototype>)` from the `<functional>` header
    represents a function wrapper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We will be using `std::function` in our code extensively in the coming sections,
    as it helps to drag function calls as data.
  prefs: []
  type: TYPE_NORMAL
- en: Composing functions together with the pipe operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Unix operating system''s command line shell allows the standard output
    of one function to be piped into the another to form a filter chain. Later, this
    feature became part of every command line shell offered as part of most operating
    systems. While writing functional style code, when we combine methods through
    functional composition, the code becomes hard to read because of deep nesting.
    Now, with Modern C++ we can overload the pipe (`|`) operator to allow chaining
    several functions together, like we do commands in a Unix shell or Windows PowerShell
    console. That is why someone re-christened the LISP language as Lots of Irritating
    and Silly Parentheses. The RxCpp library uses the `|` operator extensively to
    compose functions together. The following code helps us understand how one can
    create pipeable functions. We will take a look at how this can be implemented
    in principle. The code given here is only good for expository purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code creates a set of Callable classes and it will be used as
    part of a compositional chain of functions. Now, we need to create a mechanism
    to convert an arbitrary function to a closure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can create an instance of `PipableClosure` with a unary function as
    a parameter and chain (or compose) together a series of invocations to the closure.
    The preceding code snippet should print three on the console. We have also created
    a `PipableBinaryClosure` instance to string together both unary and binary functions.
  prefs: []
  type: TYPE_NORMAL
- en: Miscellaneous features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have covered the most important semantic changes to the language
    beginning with the C++ 11 standard. The purpose of this chapter is to highlight
    key changes that might be useful in writing idiomatic Modern C++ programs. The
    C++ 17 standard added some more stuff into the language. We will be highlighting
    a few more features of the language to wrap up this discussion.
  prefs: []
  type: TYPE_NORMAL
- en: Fold expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The C++ 17 standard added support for fold expressions to ease the generation
    of variadic functions. The Compiler does pattern matching and generates the code
    by inferring the intent of the programmer. The following code snippet demonstrates
    the idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The expected output on the console is as follows
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Variant type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A geeky definition of variant would be "type safe union". We can give a list
    of types as a template argument while defining variants. At any given time, the
    object will hold only one type of data out of the template argument list. `std::bad_variant_access`
    will be thrown if we try to access an index that does not hold the current value.
    The following code does not handle this exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Other important topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern C++ supports features such as language-level concurrency, memory guarantees,
    and asynchronous executions, which are covered in the next two chapters. The language
    offers support for optional data types and the `std::any` type. One of the most
    important feature is parallel versions of most of the STL algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Range-based for loops and observables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will implement range-based for loops on a custom type written
    by us to help you understand how all the things mentioned earlier in this chapter
    can be put together to write programs that support modern idioms. We will  implement
    a class that returns a series of numbers within a bound and will implement infrastructure
    support for the iteration of the values based on range-based for loops. First,
    we write the  "Iterable/Iterator" (aka "Enumerable/Enumerable") version by leveraging
    the range-based for loops.  After some tweaks, the implementation will be transformed
    to Observable/Observer (the key interface of Reactive Programming) patterns: The
    implementation of Observable/Observer pattern here is just for elucidation purpose
    and  should not be considered as an Industrial strength implementation of these
    patterns.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `iterable` class is a nested class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code implements an inner class derived from `std::iterator` to
    take care of the requirements for a type to be enumerable through range-based
    for loops. We will now write two public methods, (`begin()` and `end()`), so consumers
    of the class can use range-based for loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can write code to consume the preceding class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous chapter, we defined the `IEnumerable<T>` interface. The idea
    was to stick with the documentation of Reactive eXtensions. The iterable class
    is very similar to the `IEnumerable<T>` implementation in the previous chapter.
    As outlined in the previous chapter, the preceding class can be made push based,
    if we tweak the code a bit. Let us write an `OBSERVER` class that contains three
    methods. We will be using Function Wrappers available with standard library to
    define the methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ObservableRange` class given here contains a `vector<T>` that stores the
    list of subscribers. When a new number is generated, the event will be notified
    to all subscribers. If we dispatch the notification call from an asynchronous
    method, the consumer is decoupled from the producer of the range stream. We have
    not implemented the `IObserver/IObserver<T>` interface for the following class,
    but we can subscribe to notifications through subscribe methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We will store the list of subscribers in an `std::vector` as an `std::pair`.
    The first value in the `std::pair` is the reference to the `OBSERVER` and the
    second value in the `std::pair` is an integer that uniquely identifies the subscriber. 
    Consumers are supposed to unsubscribe by using the ID returned by the subscribe
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about programming language features that a C++ programmer
    should be comfortable with while writing Reactive programs, or for that matter
    any kind of programs. We talked about type inference, Variadic templates, rvalue
    references and move semantics, Lambda functions, elementary Functional programming,
    pipeable operators, and implementation of Iterators and observers. In the next
    chapter, we will  learn about concurrent programming support provided by the C++
    programming language.
  prefs: []
  type: TYPE_NORMAL
