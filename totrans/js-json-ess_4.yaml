- en: Chapter 4. AJAX Calls with JSON Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSON is considered today to be the most popular data interchange format. In
    the previous chapter we saw an example using a JSON feed as a data store. In this
    chapter let's make the data a little more dynamic. HTML, client-side JavaScript,
    and CSS provide the structural, behavioral, and presentational aspects respectively.
    Dynamic web development is all about data transfer between two parties, the client
    and the server. We use programs such as a web server, a database, and a server-side
    programming language to fetch and store dynamic data. Let's take a look at the
    process behind the scenes that facilitates successful operations on the data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: When a user opens up a web browser and types `http://www.packtpub.com/`, the
    browser makes a request to the **Internet Service Provider** (**ISP**) to perform
    a reverse lookup of the IP address by providing the domain name. Once the IP address
    is retrieved, the request is then forwarded to the machine that owns the IP address.
    At that point, there is a web server that is waiting to consume the request; the
    web server could be one of the top web servers, such as Apache, IIS, Tomcat, and
    Nginx. The web server receives the request and looks at the headers that are part
    of the HTTP request; those headers pass the information about the request that
    was made to the web server. Once the web server parses those headers, it routes
    the request over to a server-side programming application that is responsible
    for handling this request. The application could be written in PHP, C#/ASP.NET,
    Java/JSP, and so on. This responsible server-side language takes the request,
    understands it, and performs the necessary business logic to complete the request.
    A few examples of such HTTP requests are loading a web page and clicking the **Contact
    us** link on a website. There can be complex HTTP requests too, where the data
    has to be validated, cleansed, and/or retrieved from a data storage application
    such as a database, a file server, or a caching server.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: These HTTP requests can be made in two ways—synchronously and asynchronously.
    A synchronous request is a blocking request, where everything has to be done in
    an orderly fashion, one step after another, and where the following step has to
    wait until the previous one has completed execution. Let's assume that there are
    four independent components on a web page when the page is loaded; if one component
    takes a long time during execution, the rest of the page is going to wait for
    it until its execution is complete. If execution fails, the page load fails too.
    One other example is when there is a poll and a ratings component on the web page;
    if the user chooses to answer the poll and give a rating to fulfill these requests,
    two requests have to be sent out one after the other if we go with a synchronous
    requesting mechanism.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: To tackle the issue of synchronous requests, the development community has gradually
    made progress in the field of asynchronous HTTP requests. The first product to
    come out that allowed asynchronous requests were the IFrame tags, introduced by
    Microsoft; they used IFrames via Internet Explorer to load content asynchronously.
    After IFrame, next in line to revolutionize the Internet was the XML HTTP ActiveX
    control. In later years, all the browsers adopted this control under the new name
    XMLHTTPRequest JavaScript object, which is part of the XMLHTTPRequest API. The
    XMLHTTPRequest API is used to make an HTTP (or HTTPS) call to a web server. It
    can be used to make both synchronous and asynchronous calls. Asynchronous requests
    allow developers to divide web pages into multiple components independent of each
    other, thereby saving a lot of memory by sending data on demand.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '*Jesse James Garrett* named this phenomenon "AJAX". In **AJAX** (**Asynchronous
    JavaScript and XML**), web requests are made via JavaScript and the data interchange
    originally happened in XML. The "X" in AJAX was originally considered to be XML,
    but today it can be any data interchange format, such as XML, JSON, text file,
    or even HTML. The data format being used for the data transfer has to be mentioned
    in the MIME type headers. In [Chapter 2](ch02.xhtml "Chapter 2. Getting Started
    with JSON"), *Getting Started with JSON*, we have already highlighted why JSON
    is the preferred data interchange format. Let us take a quick look at what we
    would need to make our first AJAX call with JSON data.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, web developers can use the principles of AJAX to fetch data on
    demand to make websites more responsive and interactive; it is very important
    to understand what generates that demand. The trigger for such a demand for data
    is commonly an event that occurs on the web page. An **event** can be described
    as a reaction to an action that was performed, for example, ringing a bell produces
    a vibration inside the bell that generates the sound. Here, ringing a bell is
    the event, while the sound that is produced is the reaction to the event. There
    can be multiple events on a web page; a few such events are clicking a button,
    submitting a form, hovering over a link, and choosing an option from a drop-down,
    all of which are very common events. We have to come up with a way in which they
    are programmatically handled when these events occur.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Requirements for AJAX
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AJAX is an asynchronous two-way communication between the browser that is considered
    to be the client, and a live web server via HTTP (or HTTPS). We can run a live
    server locally, such as Apache or IIS on Windows or Apache on Linux and Mac OS.
    I will take us through setting up the Apache web server in a Linux environment
    and simultaneously also explain how to use the Microsoft Visual Studio development
    environment to build web applications. For this AJAX course, let us pick PHP and
    MySQL to be our main server-side language and database.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I will take you through two setups; the first will be setting
    up Apache and PHP to develop server-side programs on a Linux machine, while the
    second one will be running a .NET-powered web application on Windows. Microsoft's
    .NET Framework requires the libraries in the .NET Framework and Visual Studio
    IDE to be installed. I will assume that you have performed both the steps; we
    will now set up a web application in ASP.NET, powered by C#.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Linux is an open source operating system and has been the chosen OS by the development
    fraternity for non-Microsoft programming and scripting languages, such as PHP,
    Python, Java, and Ruby. The development environment when using PHP, Perl, or Python
    on a Linux operating system is often referred to as a LAMP environment. **LAMP**
    stands for **Linux**, **Apache**, **MySQL**, and **PHP** (or **Python** or **Perl**).
    The `tasksel` package allows us to install Apache, MySQL, and PHP in a single
    shot. Let's take a quick look at the necessary steps for installing the LAMP stack.
    On your Linux operating system, open up the terminal and type `sudo apt-get install
    tasksel`. The operating system, based on your user privileges, might prompt you
    for a password; after entering the password, hit *Enter*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '![Requirements for AJAX](img/6034OS_04_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
- en: 'As we are installing a package on the operating system, the OS will display
    the package and dependency information for the package it is installing and will
    prompt the user to check whether this is the targeted package. Hit the *Y* key
    on your keyboard to say "yes"; the operating system will then go to the repositories
    and fetch the package to be installed. Upon installation, we can use `tasksel`
    to install the LAMP server. To do this, we will have to invoke the `tasksel` program
    from the terminal by using the command `sudo tasksel`, as shown in the screenshot
    that follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '![Requirements for AJAX](img/6034OS_04_02.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`sudo` is required to perform installation operations as normal users might
    not have the required privileges.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Upon invoking `tasksel` we will get a list of installable packages, such as
    the LAMP server, Tomcat server, and DNS server; we will be choosing the LAMP server.
    To navigate within the `tasksel` shell, we will use our arrows keys to move up
    and down, and the Space bar to select the program that has to be installed.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![Requirements for AJAX](img/6034OS_04_03.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
- en: After selecting **LAMP server**, go ahead and press *Enter* to confirm the installation.
    Once the installation is complete, we are all set to write our first server-side
    program to generate and host a live JSON feed. To do this, we will navigate to
    the document root folder, which will be the only folder available to Apache. The
    document root folder is a folder where the files pertaining to a website or a
    web application are placed. Only web servers such as Apache, Tomcat, IIS, and
    Nginx are given access to these folders as unverified and anonymous users could
    get access to these files via the website. The default document root folder for
    Apache in Linux is the `/var/www` folder. To navigate to `/var/www`, we will use
    the `cd` command, which refers to change directory.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '![Requirements for AJAX](img/6034OS_04_04.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
- en: Once we are in the `www` folder, we can start creating our server-side scripts.
    Apache already provides us with a test HTML page (in that folder) to test if Apache
    is up and running; it is named as the `index.html`. To perform this activity,
    we should open up a browser in the Linux operating system and access `http://localhost/index.html`;
    we should then get a success message.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '![Requirements for AJAX](img/6034OS_04_05.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
- en: Once we receive this message we are assured that our Apache web server is up
    and running. Now let's set up a similar architecture using a Windows operating
    system and C# or ASP.NET.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '![Requirements for AJAX](img/6034OS_04_20.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: Microsoft Visual Studio is the chosen environment to develop server-side programs
    or web applications using ASP.NET and C#. Navigate to **File** | **New** | **Web
    Site**. Visual Studio comes along with its own development server for running
    a website during development.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '![Requirements for AJAX](img/6034OS_04_21.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: Once we click on the **New Web Site** option, we will have to choose what type
    of a website we are building; since this is just a dummy website, let us keep
    it simple by choosing **ASP.NET Web Site** and then clicking on **OK**. This is
    shown in the preceding screenshot.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '![Requirements for AJAX](img/6034OS_04_22.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
- en: The default ASP.NET website comes with some basic HTML that can be used for
    testing; go ahead and click on the green button beside **Debug**. This is used
    to run the website; keep in mind that C# or ASP.NET programs have to be compiled
    before they can be run, unlike PHP or Python, which are interpreted languages.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '![Requirements for AJAX](img/6034OS_04_23.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
- en: And here is our Hello World website application that is powered by C#/ASP.NET.
    Web applications can be built in any language, and JSON can be used as the data
    interchange language between web applications powered by any server-side stack.
    Let's take this knowledge of server-side programming and move forward on our journey
    so that we can implement this in powerful web applications.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Hosting JSON
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will be creating a PHP script that will allow us to send
    a JSON feedback to the user upon a successful request. Let''s take a look at the
    `index.php` file, which accomplishes this task:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '![Hosting JSON](img/6034OS_04_06.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: In this PHP script, we have created a basic `students` array and are generating
    the JSON feed for that array. The `students` array contains basic student information,
    such as the first name, last name, student ID, and the classes that the student
    has enrolled.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'This file has to be placed in the `www` folder, and it should be on the same
    level as the default `index.html` file that comes with the LAMP installation.
    Refer to the folder structure in the following screenshot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '![Hosting JSON](img/6034OS_04_08.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
- en: Now that our `index.php` is in the document root folder, we can load this file
    using our web server. To access this file via our Apache web server, navigate
    to `http://localhost/index.php`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![Hosting JSON](img/6034OS_04_07.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding screenshot, when the file is run using the Apache
    web server, the server takes the request, parses the PHP code, and outputs the
    JSON feed that delivers the student data.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Making your first AJAX call
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have an active JSON data feed, it is about time to make our first
    AJAX call. We will look at two approaches of making an AJAX call; these approaches
    come from different periods in time. The first approach will use basic JavaScript
    so that we understand what happens behind the scenes when an AJAX call is made.
    Once we understand the concept of AJAX, we will use a popular JavaScript library
    to make the same AJAX call but with simpler code. Let''s take a look at our first
    approach using basic JavaScript:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '![Making your first AJAX call](img/6034OS_04_09.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
- en: We will begin with our basic `index.html` file that loads an external JavaScript
    file. This JavaScript file performs the AJAX call to fetch the `students` JSON
    feed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take a look at `index.js`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '![Making your first AJAX call](img/6034OS_04_10.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
- en: 'This is the original way in which an AJAX call is made to a live web server;
    let''s break this script into pieces and investigate it piece by piece:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '![Making your first AJAX call](img/6034OS_04_11.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding snippet we are creating an instance of the `XMLHttpRequest`
    object. The `XMLHttpRequest` object lets us make asynchronous calls to the server,
    thus allowing us to treat sections in the page as separate components. It comes
    with powerful properties such as `readystate`, `response`, `responseText`, and
    methods such as `open`, `onuploadprogress`, `onreadystatechange`, and `send`.
    Let''s look at how we can use the `request` object that we have created to open
    an AJAX request:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '![Making your first AJAX call](img/6034OS_04_12.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
- en: '`XMLHttpRequest`, by default, opens up an asynchronous request; here we will
    specify the method in which the live feed has to be contacted. As we will not
    be passing any data, we choose the HTTP `GET` method to send the data over to
    our live web server. While working on an asynchronous request, we should never
    have a blocking script; we can deal with this by setting up callbacks. A **callback**
    is a set of scripts that will be waiting for a response and will be fired on receiving
    that response. This behavior facilitates non-blocking code.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'We are setting up a callback and are assigning the callback to a method called
    `onreadystatechange`, as shown in the following screenshot:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '![Making your first AJAX call](img/6034OS_04_13.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
- en: 'The placeholder method, `onreadystatechange`, looks for a property in the request
    object called `readyState`; whenever the value of `readyState` changes, the `onreadystatechange`
    event is fired. The `readyState` property keeps track of the progress of the `XMLHttpRequest`
    that is made. In the preceding screenshot, we can see the callback has a conditional
    statement that is verifying that the value of `readyState` is `4`, meaning that
    the server has received the `XMLHttpRequest` that was made by the client and a
    response is ready. Let''s take a quick look at the available values for `readyState`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '| `readyState` | Description |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
- en: '| `0` | The request hasn''t been initialized |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
- en: '| `1` | Server connection established |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
- en: '| `2` | The server has received the request |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
- en: '| `3` | The server is processing the request |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
- en: '| `4` | The request has been processed and the response is ready |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
- en: In the earlier screenshot, we are also looking for another property called the
    `status`; this is the HTTP status code that is coming back from the server. Status
    code `200` represents a successful transaction, while status code `400` is a bad
    request and `404` means Page Not Found. Other common status codes are `401`, which
    means the user has requested a page that is available only for authorized users,
    and `500`, which is an Internal Server Error.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'We have created the `XMLHttpRequest` object and opened the connection; we have
    also added a callback to perform an event when the request is successful. One
    thing to keep in mind is that the request hasn''t yet been made; we are only laying
    the foundation work for the request. We will use the `send()` method to send the
    request over to the server, as shown:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '![Making your first AJAX call](img/6034OS_04_14.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
- en: 'In our `onreadystateChange` callback, we are logging the response that is sent
    by the web server to the console window. Let''s take a quick look at what the
    response looks like:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '![Making your first AJAX call](img/6034OS_04_15.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
- en: One way to confirm that this is an AJAX request is by looking at the first request
    in the console, where an asynchronous call is made to the `index.php` file and
    the response comes back with an HTTP status code of `200 OK`. Since the HTTP `status`
    value is `200`, the execution of the callback will be successful and it will output
    the `students` JSON feed onto the console window.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: With the advent of powerful JavaScript libraries such as jQuery, Scriptaculous,
    Dojo, and ExtJS, we have moved away from the archaic process of making an AJAX
    request. One thing to keep in mind is, that, though we do not use this process,
    the libraries will still be using this process under the hood; so having an idea
    of how the `XMLHttpRequest` object works is very important. jQuery is a very popular
    JavaScript library; it has a growing community with a lot of developers. As the
    jQuery library is distributed under the MIT License, it allows users to utilize
    this library free of cost.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'jQuery is a very simple, powerful library with fantastic documentation and
    a strong user community that makes a developer''s life very easy. Let''s take
    a quick detour and write our customary Hello World program in jQuery:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '![Making your first AJAX call](img/6034OS_04_16.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, we are importing the jQuery library into our HTML
    file, and in the second set of script tags, we are using the special character
    `$` or jQuery. Similar to the concept of the namespace in object-oriented programming,
    the `jQuery` functionality is namespaced to the special character `$` by default.
    jQuery has been a champion of unobtrusive JavaScript. After `$`, we call the `document`
    object and check whether the it has loaded onto the page; then we assign a callback
    function that will be triggered on a complete load of the document. "`document`"
    here the `document` object that holds the HTML element structure. The output for
    this program is going be the `Hello World!` string that will be outputted to our
    console window.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Parsing JSON data
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析JSON数据
- en: '[PRE0]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When the button is clicked on, we are using the method `getJSON` to make an
    AJAX call to the live web server to retrieve the JSON data. Since we are getting
    an array of students, we will pass the retrieved data into jQuerys' `each` iterator
    to retrieve one element at a time. Inside the iterator, we are building a string,
    which is appended as a list item to the `"feedContainerList"` unordered list element.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当按钮被点击时，我们使用`getJSON`方法向实时网络服务器发出AJAX调用，以检索JSON数据。由于我们得到了一个学生数组，我们将传入检索到的数据到jQuery的`each`迭代器中，以便逐个检索元素。在迭代器内部，我们正在构建一个字符串，该字符串作为列表项附加到`"feedContainerList"`无序列表元素上。
- en: '![Parsing JSON data](img/6034OS_04_18.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![解析JSON数据](img/6034OS_04_18.jpg)'
- en: On loading of the document, as we are only binding our events to the HTML elements,
    there will not be any behavioral changes unless we click on the button. Once we
    click on the button, the unordered list will be populated.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在文档加载时，由于我们只将事件绑定到HTML元素，除非我们点击按钮，否则不会有任何行为变化。一旦我们点击按钮，无序列表将被填充。
- en: '![Parsing JSON data](img/6034OS_04_19.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![解析JSON数据](img/6034OS_04_19.jpg)'
- en: Summary
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Since the rise in popularity of the `XMLHttpRequest` object, it has become a
    boon to web developers. In this chapter we began with the basics, such as what
    we need to make an AJAX request. Once we analyzed the basic stack of software
    that we need for AJAX, we moved ahead and understood the basic concept of how
    an `XMLHttpRequest` object is responsible for making an asynchronous request.
    Then we took a leap into one of the most powerful JavaScript Libraries, jQuery,
    to perform AJAX operations using jQuery. This is just the beginning of our journey
    into AJAX; in the next chapter we will be looking at more complex cases where
    AJAX is used, the cases where cross-domain asynchronous requests fail, and how
    JSON savesthe day by allowing us to make cross-domain asynchronous calls.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 自`XMLHttpRequest`对象的流行以来，它已成为Web开发人员的福音。在本章中，我们从基础知识开始，比如我们需要进行AJAX请求。一旦我们分析了AJAX所需的基本软件堆栈，我们就会继续了解`XMLHttpRequest`对象如何负责发出异步请求的基本概念。然后，我们跨入了最强大的JavaScript库之一，jQuery，使用jQuery执行AJAX操作。这只是我们进入AJAX之旅的开始；在下一章中，我们将看到更复杂的情况，其中使用AJAX的情况，跨域异步请求失败的情况，以及JSON通过允许我们进行跨域异步调用来挽救一天。
