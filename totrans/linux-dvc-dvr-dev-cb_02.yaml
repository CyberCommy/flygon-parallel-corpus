- en: A Peek Inside the Kernel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Simple operating systems (such as MS-DOS) always execute in a single CPU mode,
    but Unix-like operating systems use dual modes to effectively implement timesharing
    and resource allocation and protection. At any time in Linux, the CPU is either
    operating in a trusted **kernel mode** (where we can do everything we wish) or
    in a restricted **user mode** (where some operations are not allowed). All user
    processes execute in user mode, whereas the core kernel itself and most device
    drivers (except ones implemented in user space) run in kernel mode so that they
    have unrestricted access to the entire processor instruction set and to the full
    memory and I/O space.
  prefs: []
  type: TYPE_NORMAL
- en: When a user mode process needs to get access to peripherals, it cannot do it
    by itself, but it has to channel requests through device drivers or other kernel
    mode code via **system calls**, which play a major role in controlling process
    activities and managing data exchange. In this chapter, we will not see system
    calls yet (they will be introduced in [Chapter 3](1625d420-d3d6-4655-9f08-050a8bb99c90.xhtml),
    *Working with Char Drivers*), but we will start programming into the kernel by
    directly adding new code into its sources or by using kernel modules, which is
    another, more versatile, manner to add code to the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Once we get started writing kernel code, we must not forget that, while in user
    mode, every resource allocation (the CPU, RAM, and so on) is automatically managed
    by the kernel (which can properly release them when a process dies), in kernel
    mode, we are allowed to monopolize the processor until either we voluntarily relinquish
    the CPU or an interrupt or exception occurs; moreover, every requested resource
    (as the RAM, for instance) is lost if not properly released. That's why it's really
    important to correctly manage the CPU usage and to free whatever resource we request!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to do a first jump into the kernel, so in this chapter, we
    will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding custom code to the sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using kernel messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with kernel modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using module parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During this chapter, we need kernel sources we already downloaded in the *Configuring
    and building the kernel* recipe in [Chapter 1](2739e129-3c1a-4c98-ba9a-9c17ae4c09db.xhtml), *Installing
    the Development System*, and, of course, we also need our cross-compiler installed,
    as seen in the *Setting up the host machine* recipe in [Chapter 1](2739e129-3c1a-4c98-ba9a-9c17ae4c09db.xhtml),
    *Installing the Development System*. The code and other files used in this chapter
    can be downloaded from GitHub at [https://github.com/giometti/linux_device_driver_development_cookbook/tree/master/chapter_02](https://github.com/giometti/linux_device_driver_development_cookbook/tree/master/chapter_02).
  prefs: []
  type: TYPE_NORMAL
- en: Adding custom code to the sources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a first step, let's see how we can add some simple code to our kernel sources.
    In this recipe, we'll simply add silly code just to demonstrate how easy it is,
    but further into this book, we're going to add even more complex code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we need to add our code to the Linux sources, let''s go into the directory
    where all sources are located. On my system, I use the `Projects/ldddc/linux/`
    path located in my home directory. Here is what the kernel sources look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to set the environment variables, `ARCH` and `CROSS_COMPILE`,
    as follows in order to be able to cross-compile code for the ESPRESSObin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'So, if we try to execute a `make` command as follows, the system should start
    compiling the kernel as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you may avoid exporting preceding variables by just specifying them
    on the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- \`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Image dtbs modules`'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, kernel sources and the compiling environment are ready.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how to do it by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this book talks about device drivers, let''s start by adding our code
    under the `drivers` directory of the Linux sources, and specifically in `drivers/misc`,
    where miscellaneous drivers lie. We should place a file named `dummy-code.c` in `drivers/misc`
    with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Our new file, `drivers/misc/dummy-code.c`, will have no effect if we don''t
    properly insert it into the kernel configuration and building system. In order
    to do so, we have to modify the `drivers/misc/Kconfig` and `drivers/misc/Makefile`
    files as follows. The former file must be changed, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The modifications for the latter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you can easily add the preceding code and whatever is needed to compile
    it by just using the `patch` command, as follows, in your main directory of Linux
    sources:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`$ patch -p1 < add_custom_code.patch`**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, if we now use the `make menuconfig` command and we navigate through Device
    Drivers to the bottom of the Misc devices menu entries, we should get something
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/01c65282-ef07-458f-bc60-be630fb3a9e1.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, I've already selected the Dummy code entry so that
    we can see what the final settings should look like.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the Dummy code entry must be selected as built-in ( the `*` character)
    and not as module (the `M` character).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note also that, if we do not execute the `make menuconfig` command and we execute
    directly the `make Image` command to compile the kernel, then the building system
    will ask us what to do with the `DUMMY_CODE` setting, as shown in the following.
    Obviously, we have to answer yes by using the `y` character:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`$ make Image`**'
  prefs: []
  type: TYPE_NORMAL
- en: '`scripts/kconfig/conf --syncconfig Kconfig`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*`'
  prefs: []
  type: TYPE_NORMAL
- en: '`* Restart config...`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*`'
  prefs: []
  type: TYPE_NORMAL
- en: '`* Misc devices`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Analog Devices Digital Potentiometers (AD525X_DPOT) [N/m/y/?] n`'
  prefs: []
  type: TYPE_NORMAL
- en: '`...`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Dummy code (DUMMY_CODE) [N/m/y/?] (NEW) y`'
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything is correctly in place, then we execute the `make Image` command
    to recompile the kernel. We should see that our new file is compiled and then
    added to the kernel `Image` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: OK, now what we have to do is just replace the `Image` file on the microSD with
    the one that has just been rebuilt and then restart the system (see the *How to
    add the kernel* recipe in [Chapter 1](2739e129-3c1a-4c98-ba9a-9c17ae4c09db.xhtml),
    *Installing the Development System*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, it's time to see how all of the previous steps work. In future sections,
    we're going to explain better what this code really does. However, at the moment,
    we should just notice the following.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 1*, notice the calls to `module_init()` and `module_exit()`, kernel-provided
    C macros, which are used to tell the kernel that, during the boot or shutdown
    of the system, it must call the functions we provided, named `dummy_code_init()`
    and `dummy_code_exit()`, which, in turn, just print some information messages.
  prefs: []
  type: TYPE_NORMAL
- en: Later on in this chapter, we're going to see in detail what `printk()` does
    and what the `KERN_INFO` macro means but, for now, we should take into account
    only that they are used to print a message during the boot (or shutdown). For
    instance, the preceding code instructs the kernel to print out the message dummy-code
    loaded at some time during the boot stage.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2*, in the `Makefile`, we are simply telling the kernel that if `CONFIG_DUMMY_CODE`
    has been enabled (that is `CONFIG_DUMMY_CODE=y`), then `dummy-code.c` must be
    compiled and inserted into the kernel binary (linked), while with the `Kconfig`
    file, we just add our new module into the kernel configuration system.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 3*, we enable the compilation of our code by using the `make menuconfig`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 4*, finally, we recompiled the kernel in order to add our code within
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *step 5*, during the boot, we should see the following kernel message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information regarding how kernel configuration and its building systems
    work, we can take a look into the kernel documentation file within kernel sources
    in the following file: `linux/Documentation/kbuild/kconfig-macro-language.txt`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using kernel messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As already stated, the serial console is very helpful if we need to set up a
    system from scratch, but it's also very useful if we wish to see kernel messages
    as soon as they are generated. In order to generate kernel messages, we can use
    several functions and, in this recipe, we will take a look at them and how to
    display messages on the serial console or over an SSH connection.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our ESPRESSObin is the system that generates kernel messages, so we need a
    connection to it. Through the serial console, these messages are automatically
    displayed as soon as they arrive, but if we are using an SSH connection, we can
    still display them by reading specific files, as with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the serial console deserves a special note: in fact, in our example,
    the kernel messages will be automatically displayed on the serial console, if,
    and only if, the leftmost number, among the ones found inside the `/proc/sys/kernel/printk`
    file, happens to be greater than seven, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'These magic numbers have a well-defined meaning; in particular, the first one
    represents the error message level that the kernel must show on the serial console.
    These levels are defined in the `linux/include/linux/kern_levels.h` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if the contents of the preceding file were 4, as reported in the
    following, only messages having the `KERN_EMERG`, `KERN_ALERT`, `KERN_CRIT`, and
    `KERN_ERR` levels will be automatically displayed on the serial console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to allow all messages, a subset of them, or none to be displayed,
    we have to modify the leftmost number of the `/proc/sys/kernel/printk` file by
    using the `echo` command, as in the following example in which we act in such
    a way to completely disable the printing of all kernel messages. This is because
    no message can have a priority level greater than 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Kernel message priorities start from 0 (the highest) and go up to 7 (the lowest)!
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to display kernel messages, we can try to perform some
    modifications to our kernel code in order to do some experimentation with kernel
    messages.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous example, we saw that we can use the `printk()` function to
    generate kernel messages, but there are other functions that we can use in place
    of `printk()` in order to have more efficient messages and compact and readable
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following macros (as defined in the `include/linux/printk.h` file),
    which are listed in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to generate a kernel message, we can do the following: looking at these
    definitions, we can rewrite our `dummy_code_init()` and `dummy_code_exit()` functions
    from the previous example into the `dummy-code.c` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we look carefully at the preceding printing functions (`pr_info()` and similar
    functions), we notice that they also depend on the `pr_fmt(fmt)` parameter, which
    can be used to add other useful information into our message. For instance, the
    following definition alters all messages generated by `pr_info()` by adding the
    current module and calling function names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `pr_fmt()` macro definition must appear at the start of the file,
    even before the includes, to have any effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we add this line to our `dummy-code.c`, as shown in the following code block,
    the kernel messages will change as described:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, when the `pr_info()` function is executed the output message, telling
    us that the module has been inserted turns in the following form, where we can
    see the module name and the calling function name followed by the loading message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: There is another set of printing functions but, before starting to talk about
    them, we need some information that is located in [Chapter 3](5f22a69e-e8b7-402e-8e67-72938d00c914.xhtml),
    *Using the Device Tree*, so, for the moment, we'll continue using these functions
    only.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: here are many kernel activities, many of them really complex, and frequently,
    a kernel developer has to work with several messages and not all of them interesting;
    so, we need to find some ways to filter out interesting messages.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering kernel messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Suppose we wish to know which serial ports have been detected during boot.
    We know we can use the `tail` command, but by using it, we can see only the latest
    messages; on the other hand, we could use the `cat` command to recall all kernel
    messages since boot, but that''s a lot of information! Alternatively, we can use
    these steps to filter the kernel messages:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we use the `grep` command as follows to filter out lines within the `uart`
    (or `UART`) string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding output can also be obtained by using the `dmesg` command as follows,
    which is a tool designed for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note that, while `cat` displays everything in the log file, even very old messages
    from previous OS executions, `dmesg` displays current OS execution messages only.
    This is because `dmesg` takes kernel messages directly from the current running
    system via its ring buffer (that is, the buffer where all messages are stored).
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, if we want to gather information regarding early boot activities,
    we can still use the `dmesg` command with the `head` command in order to display
    the first 10 lines of `dmesg` output only:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, if we are interested in the last 10 lines, we can use the
    `tail` command. In fact, we already saw that, to monitor kernel activities, we
    can use it as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'So, to see the last 10 lines, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The same can be done with `dmesg`, too, by adding the `-w` option argument,
    as shown in the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `dmesg` command can also filter out kernel messages according to their
    level by using the `-l` (or `--level`) option argument, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command shows kernel messages having the `KERN_ERR` level, while
    the following is the command to show messages having the `KERN_WARNING` level
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also combine levels in order to have both `KERN_ERR` and `KERN_WARNING`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the end, in the event of a lot of noisy messages, we can ask the system
    to clean the kernel ring buffer (where all kernel messages are stored) by using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we use `dmesg` again, we will see newly generated kernel messages only.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information regarding kernel messages management, a good starting point
    is the `dmesg` man pages, which we can display by executing the `man dmesg` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with kernel modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Knowing how to add custom code to the kernel is useful but, when we have to
    write a new driver, it can be more useful writing our code as a **kernel module**.
    In fact, by using a module, we can easily modify kernel code and then test it
    without rebooting the system every time! We simply have to remove and then reinsert
    the module (after the necessary modifications) in order to test the new version
    of our code.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll take a look at how kernel modules can get compiled even
    on a directory outside the kernel tree.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To turn our `dummy-code.c` file into a kernel module, we only have to change
    our kernel settings, allowing the compilation of our example module (by replacing
    the `*` character with `M` in the kernel configuration menu). However, under some
    circumstances, it could be more useful having our driver released into a dedicated
    archive completely separated from kernel sources. Even in this case, no changes
    are to be done to the existing code, and we will be able to compile `dummy-code.c` inside
    the kernel source tree, or even outside it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To build up our first kernel module as external code, we can safely take the
    preceding `dummy-code.c` file and then put it into a dedicated directory with
    the following `Makefile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the preceding code, we see that the `KERNEL_DIR` variable must be
    supplied on the command line pointing to the path to ESPRESSObin's previously
    compiled kernel sources, while the `ARCH` and `CROSS_COMPILE` variables are not
    mandatory since `Makefile` specifies them (however, supplying them on the command
    line will take precedence).
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we should verify that the `insmod` and `rmmod` commands are available
    in our ESPRESSObin, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If they are not present, then they can be installed by adding the `kmod` package
    with the usual `apt install kmod` command.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how to do it by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'After placing the `dummy-code.c` and `Makefile` files in our current working
    directory on the host PC, it should look like the following when using the `ls`
    command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can compile our module by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, now we have several files in the current working directory, and
    one of them is named `dummy-code.ko`; this is our kernel module ready to be transferred
    to the ESPRESSObin!
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the module has been moved into the target system (for example, by using
    the `scp` command), we can load it by using the `insmod` utility, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, by using the `lsmod` command, we can ask the system to display all loaded
    modules. On my ESPRESSObin, I only have the `dummy-code.ko` module, so my output
    is as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `.ko` postfix has been removed by the kernel module name, as the
    `-` character is replaced by `_`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can remove our module from the kernel by using the `rmmod` command,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In case you get the following error, please verify you're running the correct
    `Image` file we got in[Chapter 1](2739e129-3c1a-4c98-ba9a-9c17ae4c09db.xhtml), *Installing
    the Development System*
  prefs: []
  type: TYPE_NORMAL
- en: '`rmmod: ERROR: ../libkmod/libkmod.c:514 lookup_builtin_file() could not open
    builtin file ''/lib/modules/4.18.0-dirty/modules.builtin.bin''`'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `insmod` command just takes our module and inserts it into the kernel; after
    that, it executes the `module_init()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'During module insertion, if we''re over an SSH connection, we''ll see nothing
    on the Terminal and we have to use `dmesg` to see kernel messages (or `tail` on
    the `/var/log/kern.log` file, as discussed previously); otherwise, on the serial
    console, after inserting the module, we should see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note that the message, loading out-of-tree module taints kernel, is just a warning
    and can be safely ignored for our purposes. See [https://www.kernel.org/doc/html/v4.15/admin-guide/tainted-kernels.html](https://www.kernel.org/doc/html/v4.15/admin-guide/tainted-kernels.html)
    for further information about tainted kernels.
  prefs: []
  type: TYPE_NORMAL
- en: The `rmmod` command does the inverse steps of `insmod`, that is, it executes
    the `module_exit()` function and then removes the module from the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information regarding the modutils, their man pages are a good starting
    point (the commands are: `man insmod`, `man rmmod`, and `man modinfo`); also,
    we can take a look at the `modprobe` command by reading its man pages (`man modprobe`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using module parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During kernel module development, it can be very useful having some way to dynamically
    set some variables during module insertion and not only at compile time. In Linux,
    this can be done by using the kernel module's parameters, which allow arguments
    to be passed to a module by specifying them on the command line of the `insmod`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to show an example, let's consider a situation where we have a new
    module information file, `module_par.c` (this file is also in our GitHub repository).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how to do it by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s define our module parameters, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can use the following `init` and `exit` functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, at the end, we can add module description macros as usual:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once compiled as before, a new file, `module_par.ko`, should be ready to be
    loaded into our ESPRESSObin. However, before doing it, let''s use the `modinfo`
    utility on it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `modinfo` command is also included in the `kmod` package as `insmod`.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in the last three lines (all prefixed by the `parm:` string),
    we have a list of module's parameters defined in the code by the `module_param()`
    and `module_param_array()` macros and described with `MODULE_PARM_DESC()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we simply insert the module as before, we get default values, as shown
    in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'But if we use the next command line, we force new values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to remove the `module_par` module by using the `rmmod module_par`
    command before trying to reload it with new values!
  prefs: []
  type: TYPE_NORMAL
- en: 'As a final note, let me suggest taking a closer look at the following module
    parameter definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: First, we have the declaration of the variable that represents the parameter,
    then we have the real module parameter definition (where we specify the type and
    the file access permissions), and then we have the description.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `modinfo` command is able to display all of the preceding information,
    except the file access permissions, which refer to the file related to this parameter
    within the sysfs filesystem! In fact, if we take a look at the `/sys/module/module_par/parameters/`
    directory, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now, it should be clear what parameters `S_IRUSR` and `S_IWUSR` means; they
    allow the module user (that is, the root user) to write into these files and then
    read from them the corresponding parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Defines `S_IRUSR` and related function are defined in the following file: `linux/include/uapi/linux/stat.h`.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regarding kernel modules in general and about how to export kernel symbols,
    you can take a look at *The Linux Kernel Module Programming Guide,* available
    online at [https://www.tldp.org/LDP/lkmpg/2.6/html/index.html](https://www.tldp.org/LDP/lkmpg/2.6/html/index.html)[.](https://www.tldp.org/LDP/lkmpg/2.6/html/index.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
