- en: Pod and Container Lifecycles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Kubernetes being a declarative system, the lifecycle and hooks that are
    offered for Pods and Containers are the points where your code can take actions.
    Pods have a lifecycle, as do containers, and Kubernetes offers a number of places
    where you can provide explicit feedback to the system to have it operate as you’d
    like. In this chapter, we will dig into the expected lifecycle, hooks available
    to use, and examples of how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics will include:'
  prefs: []
  type: TYPE_NORMAL
- en: Pod lifecycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container lifecycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Probes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Container hook: post-start and pre-stop'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialization containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to handle a graceful shutdown
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pod lifecycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The lifecycle of a Pod is an aggregate of several components, as a Pod has a
    number of moving parts that can be in a variety of states as it operates. The
    representation of the lifecycle is how Kubernetes manages running your code for
    you, in conjunction with the control and feedback loops that work from the various
    controllers.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ab64835b-8b77-4df5-8e09-b3f564cea9c8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The states of a Pod''s lifecycle are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pending**: The Pod has been created through the API, and is in the process
    of being scheduled, loaded, and run on one of the Nodes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Running**: The Pod is fully operational and the software is running within
    the cluster'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Succeeded (or) Failed**: The Pod has finished operation (normally or crashed)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**There is a fourth state**: Unknown, which is a fairly rare occurrence and
    is typically only seen when there’s a problem internal to Kubernetes where it
    doesn’t know the current state of containers, or is unable to communicate with
    its underlying systems to determine that state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are working with long-running code in Containers, then most of the time
    will be spent in running. If you are making use of shorter, batch-oriented code
    within Kubernetes using Job or CronJob, then the final status (Succeeded or Failed)
    may be what you are interested in.
  prefs: []
  type: TYPE_NORMAL
- en: Container lifecycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Containers also have a state that is managed individually for them, since each
    Pod can have one or more Containers. The Container states are simpler and quite
    direct:'
  prefs: []
  type: TYPE_NORMAL
- en: Waiting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terminated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](assets/f141ab2e-01ec-4e6e-be7c-7e5b0fa7c4e5.png)'
  prefs: []
  type: TYPE_IMG
- en: The container states will all have a timestamp associated with them, indicating
    when the cluster recorded the container in that state. If more than one state
    has been processed through, there will also be a last state field. As containers
    are fairly ephemeral, it is fairly common to see a previous state of Terminated,
    which includes information about when the container started, when it finished,
    its exit code, and a string entry about why it terminated called Reason.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of the container states after your Pod has been
    processing a while (and in this example, after it had been updated a couple of
    times):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/99c93667-9d8e-47fa-928a-84350ce562d6.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see the additional details in a human-readable format within the output
    of the `kubectl describe pod` command, which is often most convenient for quickly
    understanding what's happening within the Pod.
  prefs: []
  type: TYPE_NORMAL
- en: The states all have additional information within them to provide detail on
    what's happening. There is a formal PodStatus object available via the API. Each
    state has additional details that are available, and more generally the status
    object includes a list of conditions that are commonly exposed and visible in
    the output of describe or the raw YAML.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `kubectl get pod ... -o yaml` command, you can see the data in a
    machine-parsable form, and see that there''s an additional detail that isn''t
    also exposed in the `describe` command. In the following screenshot, you can see
    the output related to the Pod and container states, including the conditions,
    container states, and related timestamps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4c10fb77-c0ba-475e-8df0-c79784239f98.png)'
  prefs: []
  type: TYPE_IMG
- en: Conditions are added to the state of a Kubernetes object as the object goes
    through its lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/487c3b4c-5af2-4f94-88bf-2a6846f910fa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Within the Pod state pending, there are two conditions that are commonly added:
    `Initialized` and `PodScheduled`. If the cluster is unable to run the requested
    Pod, then you may see the condition `Unschedulable` instead of `PodScheduled`. When
    the Pod is in the state of Running, there is also the condition **Ready** that
    is relevant and affects Kubernetes’ management of your code.'
  prefs: []
  type: TYPE_NORMAL
- en: Deployments, ReplicaSets, and Pods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pods are not the only Kubernetes resources that takes advantage of, and expose, conditions.
    Deployments also use conditions to represent detail such as to the progress of
    a rollout of a code update, and the overall availability of the deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two conditions you will see when using Deployments are:'
  prefs: []
  type: TYPE_NORMAL
- en: Progressing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Available will be true when the minimum number of replicas of the underlying
    Pods is available (the default is 1). Progressing will be set when the ReplicaSets
    and their related Pods are created and as they come available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kubernetes uses a consistent pattern in how its internal resources are related
    to each other. As we discussed in an earlier chapter, Deployments will have associated
    ReplicaSets, and ReplicaSets will have associated Pods. You can visualize this
    like a chain of objects, with the higher level being responsible for watching
    and maintaining the state of the next level down:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9306c080-96f0-4c5c-b045-89e063278d7d.png)'
  prefs: []
  type: TYPE_IMG
- en: We have been focusing on Pod states and their lifecycle because that is where
    the code is represented and actually running. In most cases, you will be creating
    a deployment that will, in turn, have its own state and conditions. That will,
    in turn, create a ReplicaSet, and the ReplicaSet will create the Pod or Pods.
  prefs: []
  type: TYPE_NORMAL
- en: When a Pod is being created, the system will attempt to first create the API
    resource itself, and then it will attempt to find a place to run it within the
    cluster. When the resource has been created, the Initialized condition is added
    to the status. When the cluster has identified where to run the Pod, the PodScheduled
    condition will be added. If the cluster can’t find a location to run the Pod as
    you’ve described, then the `Unschedulable` condition is added to the status.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a snapshot of the current state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can see the current snapshot of what Kubernetes knows about the state of
    your code using the `kubectl describe` or `kubectl get` command. If you are just
    trying to see the state for yourself interactively, then the `kubectl describe`
    command is the most valuable. Remember that Kubernetes manages a chain of objects
    related to running your code, so if you want to see a full snapshot, you will
    want to look at the status of each of the objects: deployment, ReplicaSet, and
    Pods. In practice, looking at the state of deployment and then jumping down to
    Pods will often provide you with any detail you want.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see these details of what Kubernetes is doing with your code by looking
    at the raw data for your Pod using `kubectl get pod`, or by using the `describe`
    command. You want to look for `Status` and `Conditions`.  For example, when we
    earlier created a `nodejs` application deployment, the chain of objects created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the snapshot of its current state using the `kubectl describe`
    command to look at the deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will present information that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9891c670-bf4d-4b81-99f7-816736917932.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And you can use `kubectl describe` to get additional details by looking at
    the ReplicaSet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/28406acd-c028-4c76-9b45-af93951aec4e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And finally, use it one more time to look at the Pods created by the Deployment
    and ReplicaSet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/fc6e5004-3a19-4852-b6b1-58dd10ec74cf.png)'
  prefs: []
  type: TYPE_IMG
- en: The events that are listed at the bottom of the output from `kubectl describe`
    will show you the sequence of what happened related to the Pod.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to use the status in a script, or otherwise use a program to parse
    the output, then you can use the `kubectl get` command, specifying a data format
    for the output such as YAML. For example, the same Pod output in YAML might be
    retrieved using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The lower portion of the output under the key status will hold the state-snapshot
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/aac29ffc-2486-405a-b053-6fbdb449f2f2.png)'
  prefs: []
  type: TYPE_IMG
- en: While not shown in the output from `kubectl describe`, each condition is tracked
    with a last updated time, a time when it last changed, a type, and a status. In
    addition, each container is listed with its own state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of Pod conditions that you could see could grow with future versions
    of Kubernetes, and today includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**PodScheduled**: Transitioned to true when the Pod has been scheduled on a
    Node and the process to start loading it onto the node has begun.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Initialized**: Initialized will be marked true when all containers for the
    Pod have been loaded, and after any initialization containers defined have run
    to completion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ready**: The Pod has been loaded and started per the specification. This
    value won’t be marked as true until the readiness probe and the liveness probe
    have completed successfully (if either or both are defined).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unschedulable**: This condition will only be listed and asserted when the
    Kubernetes cluster is unable to match available resources to the Pod’s needs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes the states (such as `Succeeded` or `Failed`) will also include a `Reason`,
    which includes some text output intended to make it easier to understand what
    happened. And as you can see from the preceding output, timestamps are included
    for all the state changes. Since this is a snapshot in time, the timestamps can
    provide breadcrumb clues to understand the order of what happened, and how long
    ago it happened.
  prefs: []
  type: TYPE_NORMAL
- en: As a final note, the events associated with the Pod will often provide useful
    descriptive notes of what has happened (or failed to happen) while your Pod was
    starting. Utilizing all the details provided from describe, Pod status, conditions,
    and events, provides the best status updates external to the Pod’s logs themselves.
  prefs: []
  type: TYPE_NORMAL
- en: The lifecycle of Pods also includes hooks or feedback mechanisms that you can
    specify to allow your application to provide feedback on how it is doing. One
    of these mechanisms, the condition `Ready`, you have seen previously. Kubernetes
    lets your application provide specific feedback on if it is ready to accept traffic,
    and if it is healthy. These feedback mechanisms are called **probes**, and can
    be optionally defined in your Pod specification.
  prefs: []
  type: TYPE_NORMAL
- en: Probes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The two probes enabled in Kubernetes are the liveness probe and readiness Probe.
    They are complimentary, but different in intent and usage, and can be defined
    for each container within a Pod. In both cases, they provide a means for your
    code to influence how Kubernetes manages the containers.
  prefs: []
  type: TYPE_NORMAL
- en: Liveness probe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most basic probe is the Liveness probe. If defined, it provides a command
    or URL that Kubernetes can use to determine whether a Pod is still operational.
    If the call succeeds, Kubernetes will assume the container is healthy; if it fails
    to respond, then the Pod can be handled as the `restartPolicy` is defined. The
    result is binary: either the probe succeeds, and Kubernetes believes your Pod
    is running, or it fails, so Kubernetes believes your Pod is no longer functional.
    In the latter case, it will check with the defined RestartPolicy to choose what
    to do.'
  prefs: []
  type: TYPE_NORMAL
- en: The default value for `restartPolicy` is `Always`, meaning if a container within
    the Pod fails, Kubernetes will always attempt to restart it. Other values that
    you can define include `OnFailure` and `Never`. When a container is restarted,
    Kubernetes will track how often that occurs and will slow down the frequency of
    restarts if they are happening in quick succession, capped at a maximum of five
    minutes between restart attempts. The number of restarts is tracked and visible
    as `restartcount` in the output of `kubectl describe`, and the key `restartCount`
    in the data output from `kubectl get.`
  prefs: []
  type: TYPE_NORMAL
- en: If a liveness probe isn't explicitly defined, the probe is assumed to succeed
    and the container is automatically set to live. If the container itself were to
    crash or exit, Kubernetes would react and restart it as per the `restartPolicy`,
    but no other active checks are taking place. This allows you to handle a scenario
    where your code has frozen or deadlocked and is no longer responding, even though
    the process continues to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'A liveness probe can be defined to check the health of the Pod through one
    of three methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ExecAction`: This invokes a command within the Pod to get a response, and
    the result of the exit code of that command invocation is what’s used in the liveness
    check. A result of anything other than `0` represents a failure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TCPSocketAction`: This attempts to open a socket, but doesn’t manipulate or
    interact with the socket beyond attempting to open it. If the socket opens, the
    probe is successful, and if it fails or fails after a timeout, then the probe
    fails.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTPGetAction`: Similar to the socket option, this makes an HTTP connection
    to your Pod as a URI specified, and the response code of the HTTP request is what
    is used to determine the success/failure of the liveness probe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are a number of variables that can configure the specifics of this probe
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '`activeDeadlineSeconds` (not set by default): This value is most commonly used
    with Jobs rather than long-running Pods to put a maximum cap on how long the job
    will be allowed to operate. This number will include any time taken by initialization
    containers, which will be discussed further later in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initialDelaySeconds` (not set by default): This allows you to specify the
    number of seconds before starting probe checks. This is not set by default, so
    effectively defaults to 0 seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timeoutSeconds` (defaults to 1): This provides a timeout in case the command
    or URL request takes a significant period of time to return. If the timeout expires
    before the command returns, it is presumed to have failed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`periodSeconds` (defaults to 10): This defines the frequency of how often Kubernetes
    will run the probe - either invoking the command, checking the socket availability,
    or making the URL request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`successThreshold` (defaults to 1): This is the number of times that the probe
    needs to return success in order to set the state of the container to `active`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`failureThreshold` (defaults to 3): This is the minimum number of consecutive
    failures of the probe that will trigger marking the container as unhealthy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you define a URL to request and leave everything else to defaults, the normal
    pattern will require three failure responses—a timeout or non-200 response code—before
    it will consider the container `dead` and apply the `restartPolicy`. Each check
    by default is 10 seconds apart, so your container could be dead for up to 30 seconds
    with these defaults before the system applies the `restartPolicy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using an HTTP-based probe, you have a number of additional variables
    that can be defined while making the HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: '`host`: Defaults to the Pod IP address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scheme`: HTTP or https. Kubernetes 1.8 defaults to HTTP'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path`: Path of the URI request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HttpHeaders`: Any custom headers to be included in the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`port`: Port on which to make the HTTP request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Readiness probe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second probe available is the readiness probe, most often used in parallel
    with the liveness probe. The readiness probe is expected to respond positively
    only when your application is ready and able to service normal requests. For example,
    if you want to wait until your database is fully operational, or pre-load some
    caches that can take a few seconds, you probably don’t want to return a positive
    response for a readiness probe until those operations have completed.
  prefs: []
  type: TYPE_NORMAL
- en: Like the liveness probe, if it is not defined, the system assumes that as soon
    as your code is running that it is also ready to accept requests. If you have
    code that takes a few seconds to get fully operational, then it is very worthwhile
    to define and utilize a readiness probe, as this will work with any Services to
    automatically update Endpoints so that traffic isn’t routed to an instance when
    it is unable to service traffic.
  prefs: []
  type: TYPE_NORMAL
- en: The same options are available for configuring a readiness probe, one of `ExecAction`,
    `TCPSocketAction`, or `HTTPGetAction`. As with the liveness probe, the same variables
    can be used to tune the frequency of probe requests, timeouts, and a number of
    successes and/or failures to trigger a state change. If you modified the values
    in your liveness probe, then you probably do not want to set your readiness probe
    to be any more frequent than your liveness probe.
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder, when a readiness probe fails, a container isn’t automatically
    restarted. If you want that functionality, you should be using the liveness probe.
    The readiness probe is specifically set up to allow a Pod to indicate that it
    can’t yet process traffic, but it expects it will be able to shortly. As the probe
    updates, the Pod status will be updated to set Ready to be positive or negative,
    and the related Ready condition will also be updated. As this happens, any services
    that are using this pod will get notified of those updates and will change to
    send traffic (or not) based on the readiness value.
  prefs: []
  type: TYPE_NORMAL
- en: You can view the readiness probe as an implementation of the circuit breaker
    pattern, and a means of load shedding. While running with multiple copies of a
    Pod, if one instance gets overloaded or has some temporary condition, it can respond
    negatively to the readiness probe and the service mechanism within Kubernetes
    will direct any further requests to the other Pods.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a probe to our Python example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like previous examples, the code is available in GitHub in the [https://github.com/kubernetes-for-developers/kfd-flask](https://github.com/kubernetes-for-developers/kfd-flask) project. [I
    won''t show all the changes, but you can check out the code from branch `0.3.0`
    using this command: `git checkout 0.3.0`. The Docker images built from this code
    are likewise available under the `0.3.0` tag from the `quay.io` repository.](https://github.com/kubernetes-for-developers/kfd-flask)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this update, the project includes a secondary deployment of Redis to match
    some of the concepts from the previous chapter. The specification for the deployment
    has also been updated to specifically add a liveness probe and a readiness probe.
    The updated deployment specification now reads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The probes are in bold. Both probes are using the same port as the rest of the
    application (`5000`), and their own respective endpoints. The liveness probe is
    set to delay one second before starting to check, and the readiness probe is set
    to delay five seconds before starting to check, and both are set to a slightly
    tighter frequency of five seconds.
  prefs: []
  type: TYPE_NORMAL
- en: The Python code has also been updated, primarily to implement the methods that
    respond to `/alive` and `/ready` for the liveness and readiness probes, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The liveness probe is the simplest, replying with a static response that just
    preserves the validation that the underlying flask code is responding to HTTP
    requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The readiness probe extends on this pattern, but verifies that an underlying
    service (Redis in this case) is available and responding before replying positively.
    This code doesn't actually rely on Redis, but in your own code you may rely on
    a remote service being available and have some method that will indicate if that
    service is both available and responsive. As mentioned earlier, this is effectively
    an implementation of the circuit breaker pattern, and along with the service construct,
    allows Kubernetes to help direct load to instances that can respond.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we take advantage of the `redis ping()` capability, exposed in
    the Python library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The other updates in the code initialize the `redis_store` variable in the code,
    and add the DNS entry to the matching service into a `configMap` so the application
    code can use it.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Python probes example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you check out the `0.3.0` branch, you can investigate this code and run
    it locally in your own instance of Minikube or another Kubernetes cluster. To
    check out the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The final command will create the service and deployment `redis-master`, and
    the service, `configmap`, and deployment for the Python/flask code. If you then
    use the `kubectl describe` command, you can see the probes defined and their values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/4c11e8f7-0b0f-4fb9-b60c-0aa2f9aa67a0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also look at the logs for the single flask Pod that''s operational
    and see the requests being processed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Adding a probe to our Node.js example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding example probes to the Node.js/express-based application follows exactly
    the same pattern as the Python application. And like the Python example, the code
    and specifications for this are available at GitHub under the [https://github.com/kubernetes-for-developers/kfd-nodejs](https://github.com/kubernetes-for-developers/kfd-nodejs) project,
    associated with branch `0.3.0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The probes add nearly the same specification to the Node.js deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the probes are requesting against the same HTTP responses that
    the application provides, and the same port. The URI paths are longer, taking
    advantage of the application's structure, which uses a single bit of code for
    routes under a specific URI, so we are able to bundle the readiness and liveness
    probes into a single new `probes.js` router.
  prefs: []
  type: TYPE_NORMAL
- en: The main application is updated to create a probes router and bind it in on
    application start, and then the code within the router itself provides the responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for `probes.js` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Like the preceding Python example, the liveness probe returns a static response,
    and is just used to validate that `express` is still responding to HTTP requests.
    The readiness probe is more involved, wrapping `db.ping()` in an asynchronous
    wait/catch and checking the value. If it's negative, or an error occurs, then
    we return a `500` response. If it's positive, then we return a static positive
    result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `kubectl describe deployment nodejs` will show the configuration with
    the probes operational, very much like the Python example, and `kubectl log nodejs-65498dfb6f-5v7nc`
    will show the requests from the probes being responded to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test the operation of the readiness probe by terminating the Redis service.
    If we invoke the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Fairly shortly, the results of `kubectl get pods` will show the Pod alive,
    but not `ready`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'While the `redis-master` deployment is shut down, you can get some interesting
    details from the Node.js deployment. Use `kubectl describe` to show the deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/da7a3247-b66b-4996-95b3-e1e6d441ec52.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And use `kubectl describe` to look at the related Pods as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/60099d6b-f9f7-45fd-a898-93493110249a.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that `Condition Ready` is now `false`, and the status of the Node.js container
    has a state of `Running, but Ready of False`.
  prefs: []
  type: TYPE_NORMAL
- en: If the Redis deployment is recreated or restored, then the services will all
    come back online as you would expect.
  prefs: []
  type: TYPE_NORMAL
- en: Container lifecycle hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes also provides some hooks within the lifecycle of each container that
    can be used at setup and teardown time for containers. These are called container
    lifecycle hooks, and are defined for each container, rather than for the Pod overall.
    When you want to configure some additional functionality specific to the container
    when you have multiple containers per Pod, these can be extremely useful.
  prefs: []
  type: TYPE_NORMAL
- en: The two hooks you can define for each container are post-start and pre-stop.
    The post-start and pre-stop hooks are intended to be invoked at least once, but
    Kubernetes does not make any guarantees that these hooks will be invoked only
    once. This means while it is likely rare, the post-start or pre-stop hooks may
    be invoked more than once.
  prefs: []
  type: TYPE_NORMAL
- en: Neither of these hooks accept parameters, and are defined in the same fashion
    as a container’s run command. When used, they are expected to be self-contained,
    relatively short running commands that always return. When these hooks are being
    invoked, Kubernetes suspends management of the container until the hook completes
    and returns. Because of this, it is critical that executables invoked for these
    hooks don’t hang or run indefinitely, as Kubernetes doesn’t have a means of watching
    for this scenario and responding to a failure to complete or return a value.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of post-start, the container state won’t be moved to the Running
    state until the post-start hook. The post-start hook is also not guaranteed to
    be invoked either before or after the main command for the container is invoked.
    In the case of pre-stop, the container won’t be terminated until the pre-stop
    hook completes and is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'These two hooks can be invoked using one of two handlers: Exec and HTTP. Exec
    runs a specific command inside the container and in the same process space as
    the container, much like using a `kubectl exec` invocation. The HTTP handler sets
    up for an HTTP request against the container. In either case, if the hook returns
    a failure code the container is killed.'
  prefs: []
  type: TYPE_NORMAL
- en: The logs from these hooks are not exposed in Pod events or logging. If the handler
    fails, it broadcasts an event that can be seen with the `kubectl describe` command.
    These two events are `FailedPostStartHook` and `FailedPreStopHook`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The pre-stop hook can be very useful when you want an external command to be
    invoked to cleanly shut down a running process, such as invoking `nginx -s quit`.
    This can be especially useful if you're using someone else's code, especially
    if it has a more complex shutdown process than responding correctly to the SIGTERM
    signal. We will discuss how to gracefully shut down Kubernetes a bit later in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The post-start hook is often useful when you want to create a semaphore file
    within the container, or invoke an HTTP request call whenever the container starts.
    More often, the need is for initialization or pre-condition validation before
    your main code starts, and there is another option to use for that functionality:
    initialization containers.'
  prefs: []
  type: TYPE_NORMAL
- en: Initialization containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Initialization containers are containers that can be defined on your Pod, and
    will be invoked in the specific sequence that they are defined prior to your main
    container (or containers) being started. Initialization containers became a normal
    part of Pod specification in Kubernetes version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: These containers can use the same container image and simply have alternate
    commands, but they can also use entirely different images, leveraging the Kubernetes
    Pod guarantees of shared network and filesystem mounts to do initialization and
    setup work prior to the main container operating. These containers also use namespaces,
    so they can be given specific access that the main container doesn't have; consequently,
    they can be given access to Kubernetes Secrets that the main container cannot
    access.
  prefs: []
  type: TYPE_NORMAL
- en: Initialization containers are expected to have code that runs to completion
    and exits with a success response. As mentioned previously, these containers are
    also invoked in sequence, and will not run in parallel; each one has to complete
    before the next one will be started. When the containers have all completed, Kubernetes
    initializes the Pod and runs the defined container (or containers). If an initialization container
    fails, then the Pod is presumed to have failed and the whole kit is terminated
    (or more specifically, handled per the `restartPolicy`).
  prefs: []
  type: TYPE_NORMAL
- en: Initialization containers allow you to do all kinds of setup prior to your main
    process being run. Some examples of what you might do include writing configuration
    files that the main Pod container needs to have, verifying that a service is available
    and active prior to starting the main container, retrieving and initializing content
    such as pulling data from a Git repository or file service, for the main container
    to use, or even just enforcing a delay prior to starting the main container or
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: While the initialization containers are running, the Pod status will show `Init:`
    followed by some initialization container-specific state. If everything is going
    well and as expected, it will report the number of initialization containers that
    are listed and how many have been run to completion. If an initialization container
    fails, then `Init:` will be followed by `Error` or `CrashLoopBackOff`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialization containers are specified in the Pod specification at the same
    level as the main container or containers and as a list, each with its own name,
    image, and command to invoke. For example, we could add an `init` container to
    our Python flask specification that will only return when Redis is up and available.
    An example of that might be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the initialization container code is just a loop written in the
    shell that checks to see if there is a response to the DNS entry `redis-master`,
    and it runs indefinitely until that succeeds. If you were to look at the Pod prior
    to the `redis-master` service being established and having a relevant DNS entry,
    you would see the status of that Pod listed with `Init:0/1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, `kubectl get pods`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/7e5adb95-c678-498b-924e-112aba2a69f3.png)'
  prefs: []
  type: TYPE_IMG
- en: You may notice that this output doesn't match the previous example; the command
    in the preceding output is looking for a DNS response to `redis`, where we named
    the service `redis-service`.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the initialization container will never complete and the Pod will
    remain in `pending` status indefinitely. In this case, you will need to manually
    delete the deployment, or if you make a modification that allows it to work, you
    will need to manually delete the Pods that are stuck initializing, as they won't
    otherwise be cleaned up.
  prefs: []
  type: TYPE_NORMAL
- en: Once the initialization container has completed successfully, you can see the
    results in the `kubectl describe` output from the Pod, or again via the data exposed
    with the `kubectl get` command.
  prefs: []
  type: TYPE_NORMAL
- en: The following is an extended example of the output that you will see from `kubectl
    describe`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3fd0907c-1d4c-4f56-a14c-20fee8b8ef12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The output of `describe` extends beyond a single Terminal page; you should
    continue to scroll down to see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/248aa190-9878-410a-a140-baba10022671.png)'
  prefs: []
  type: TYPE_IMG
- en: Quick interactive testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are trying to make a quick one-liner initialization container, it's often
    useful to try out a command interactively, especially if you're using a very minimal
    container such as `busybox`. The commands you want may not be available, so it's
    best to try it out quickly to verify it can work as you expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run a `busybox` container interactively, and delete it all when it''s complete,
    you can use a command such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And then try out this command within the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ac15c96e-7170-4b62-bd3d-fe9562463fef.png)'
  prefs: []
  type: TYPE_IMG
- en: Handling a graceful shutdown
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the lifecycle hooks, we mentioned the pre-stop hook that can be defined
    and enabled, but if you're writing your own code, then you may find it just as
    easy to respect the SIGTERM signal that Kubernetes uses to tell containers to
    shut down.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you aren''t familiar with SIGTERM, it is one of the functions that Linux
    supports from the kernel—a means of sending an interrupt to a running process.
    The process can listen for these signals, and you can choose how they respond
    when they are received. There are two signals that you can''t `ignore` and the
    operating system will enforce, regardless of what you implement: SIGKILL and SIGSTOP.
    The signal that Kubernetes uses when it wants to shut down a container is SIGTERM.'
  prefs: []
  type: TYPE_NORMAL
- en: The kind of events where you will receive this signal aren't just on error or
    user-invoked deletion, but also when you roll out a code update leveraging the
    rolling update mechanism that deployment uses. It can also happen if you take
    advantage of any of the autoscaling features, which can dynamically increase (and
    decrease) the number of replicas within a `replicaSet`.
  prefs: []
  type: TYPE_NORMAL
- en: When you respond to the signal, you will generally want to save any needed state,
    close any connections, and then terminate your application.
  prefs: []
  type: TYPE_NORMAL
- en: If you are creating a service that others will use through Kubernetes as well,
    then one of the first things you might want to do is change an internal variable
    that will trigger any readiness probe to respond with `false`, sleep for a few
    seconds, and then do any finalization and termination. That will allow the service
    construct within Kubernetes to redirect any further connections, and all active
    connections can be completed, drained, and shut down politely.
  prefs: []
  type: TYPE_NORMAL
- en: Once Kubernetes sends the signal, it starts a timer. The default value of that
    timer is 30 seconds, and it can be defined on your Pod specification with the
    value `terminateGracePeriodSeconds` if you need or want a longer value. If the
    container hasn't exited by the time that timer expires, Kubernetes will attempt
    to force it using the SIGKILL signal.
  prefs: []
  type: TYPE_NORMAL
- en: If you have invoked `kubectl delete deploy nodejs`, for example, and then seen
    the Pods remaining for a while with the status `Terminating`, that is what was
    happening.
  prefs: []
  type: TYPE_NORMAL
- en: SIGTERM in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As an example, if you want to handle SIGTERM in Python, then you can import
    the signal module and reference a handler to do whatever you want. For example,
    a simple shut down immediately and exit bit of code might be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The signal handler logic can be as complex, or as simple, as your code requires.
  prefs: []
  type: TYPE_NORMAL
- en: SIGTERM in Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As an example, if you want to handle SIGTERM in Node.js, then you can use the
    process module that is implicitly created in every Node.js process to handle the
    signals and to exit the application. To match the preceding Python example, a
    simple shut down immediately and exit bit of code might be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started with looking at the Pod lifecycle and status details
    in depth, expanding to show multiple ways of revealing relevant details, and describing
    what Kubernetes does beneath the covers while running your software. We then looked
    at the feedback loops that your program can provide with liveness and readiness
    probes, and reviewed examples of enabling those in both Python and Node.js. Following
    on from the probes and how your code can interact with Kubernetes cleanly, we
    looked at the common cases for startup and initialization, and graceful shutdown.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we look at how to use Kubernetes and open source to provide
    basic observability for your applications, specifically monitoring and logging.
  prefs: []
  type: TYPE_NORMAL
