- en: Building Better Containers - Functional Data Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 12](0d82d215-9bfc-436b-b09d-8ed2e2ebd441.xhtml), *Implementing
    Design Patterns - The Functional Way*, we have gone over many ways of using functions
    to achieve different results, and in this chapter, we will go more deeply into
    data types from a functional point of view. We''ll be considering ways of actually
    implementing our own data types, with several features to help composing operations
    or ensuring purity, so your FP coding will become actually simpler and shorter.
    We''ll be touching on several themes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data types** from a functional point of view, because even though JavaScript
    is not a typed language, a better understanding of types and functions are needed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Containers**, including *functors* and the mystifying *monads*, to better
    structure data flow'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functions as structures**, in which we''ll see yet another way of using functions
    to represent data types, with immutability thrown in as an extra'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Even though JavaScript is a dynamic language, without static or explicit typing
    declarations and controls, it doesn''t mean that you can simply ignore types.
    Even if the language doesn''t allow you to specify the types of your variables
    or functions, you still work --even if only in your head-- with types. Let''s
    now get into the theme of seeing how we can specify types, for that we will have
    at least some advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Even if you don't have runtime data type checking, there are several tools,
    such as Facebook's *flow* static type checker or Microsoft's *TypeScript* language,
    which let you deal with it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will help if you plan to move on from JavaScript to a more functional language
    such as *Elm*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It serves as documentation, to let future developers understand what type of
    arguments they have to pass to the function, and what type it will return. As
    an example of this, all the functions in the Ramda library are documented in this
    way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will also help with the functional data structures later in this section,
    where we will examine a way of dealing with structures, similar in some aspects
    to what you do in fully functional languages such as Haskell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to learn more about the tools that I cited, visit [https://flow.org/](https://flow.org/)
    for flow, [https://www.typescriptlang.org/](https://www.typescriptlang.org/) for
    TypeScript, and [http://elm-lang.org/](http://elm-lang.org/) for Elm. If you directly
    want to know about type checks, the corresponding web pages are [https://flow.org/en/docs/types/functions/](https://flow.org/en/docs/types/functions/),
    [https://www.typescriptlang.org/docs/handbook/functions.html](https://www.typescriptlang.org/docs/handbook/functions.html),
    and [https://flow.org/en/docs/types/functions/](https://flow.org/en/docs/types/functions/)
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you read or work with a function, you will have to reason about types,
    think about the possible operations on this or that variable or attribute, and
    so on. Having type declarations will help, so we shall now begin considering how
    we can define, most importantly, the types of functions and their parameters and
    result.
  prefs: []
  type: TYPE_NORMAL
- en: Signatures for functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The specification of a function''s arguments and result, is given by a *signature*.
    Type signatures are based on a *type system* called Hindley-Milner, which influenced
    several (preferably functional) languages, including Haskell, though the notation
    has changed from that of the original paper. This system can even deduce types
    that are not directly given; tools such as TypeScript or Flow also do that kind
    of figuring out, so the developer need not specify *all* types. Instead of going
    for a dry, formal, explanation about the rules for writing correct signatures,
    let''s work by examples. We need to only know that:'
  prefs: []
  type: TYPE_NORMAL
- en: We will be writing the type declaration as a comment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The function name is written first, and then `::` that can be read as *is of
    type* or *has type.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optional constraints may follow, with a double (*fat*) arrow `⇒` (or `=>` in
    basic ASCII fashion, if you cannot key in the arrow) afterwards.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The input type of the function follows, with a `→` (or `->` depending on your
    keyboard).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The result type of the function comes last.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that instead of this vanilla JS style, Flow and TypeScript have their own
    syntax for specifying type signatures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can begin with some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: These are simple cases -- and mind the signatures; we are not interested in
    the actual functions here. The first function receives a string as an argument
    and returns a new string. The second one receives no arguments (the empty parentheses
    show this is so) and returns a floating point number. The arrows denote functions.
    So, we can read the first signature as `firstToUpper` *is a function of the type
    that receives a string and returns a string* and we can speak similarly about
    the maligned (impurity-wise) `Math.random()` function, with the only difference
    that it doesn't receive arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'We saw functions with zero or one parameter: what about functions with more
    than one? There are two answers to this. If we are working in strict functional
    style, we would always be doing currying (as we saw in [Chapter 7](44b5eafa-dc7f-45e4-8b9e-9bb5bb9b02ec.xhtml),
    *Transforming Functions - Currying and Partial Application*), so all functions
    would be unary. The other solution is enclosing a list of argument types in parentheses.
    We can see the following both ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The first signature can also be read as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is correct when you remember the idea of currying. After you provide the
    first argument to the function, you are left with a new function, that also expects
    an argument, and returns a third function, which, when given an argument, will
    produce the final result. We won't be using parentheses because we'll always assume
    this grouping from right to left.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, what about higher-order functions, which receive functions as arguments?
    The `map()` function poses a problem: it works with arrays, but of any type. Also,
    the mapping function can produce any type of result. For these cases, we can specify
    *generic types*, identified by lower case letters: these generic types can stand
    for any possible type. For arrays themselves, we use brackets. So, we would have
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s perfectly valid to have *a* and *b* represent the same type, as in a
    mapping applied to an array of numbers, which produces another array of numbers.
    The point is that, in principle, *a* and *b* may stand for different types, and
    that''s what''s described previously. Also notice that if we weren''t currying,
    the signature would have been `([a], (a → b)) → [b]` showing a function that receives
    two arguments (an array of elements of type *a* and a function that maps from
    type *a* to type *b*) and produces an array of elements of type *b* as the result.
    Given this, we can write in a similar fashion the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And, the big one: how''s the signature for `reduce()`? Be sure to read it carefully,
    and see if you can work out why it''s written that way. You may prefer thinking
    about the second part of the signature as if it were `((b, a) → b)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if you are defining a method instead of a function, you use a squiggly
    arrow such as `~>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Other type options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What else are we missing? Let''s see some other options that you might use.
    *Union types* are defined as a list of possible values. For example, our `getField()`
    function from [Chapter 6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml), *Producing
    Functions - Higher-Order Functions*, either returns the value of an attribute,
    or it returns undefined. We can then write the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We could also define a type (union or otherwise) and later use it in further
    definitions. For instance, the data types that can be directly compared and sorted
    are numbers, strings, and booleans, so we could write the following definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Afterwards, we could specify that a comparison function could be defined in
    terms of the Sortable type... but be careful: there''s a hidden problem here!'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Actually, this definition isn't quite precise, because you actually can compare
    any types, even if it doesn't make much sense. However, bear with me for the sake
    of the example! And if you want to refresh your memory about sorting and comparison
    functions, see [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/sort](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/sort).
  prefs: []
  type: TYPE_NORMAL
- en: 'The last definition would allow writing a function that received, say, a Number
    and a Boolean: it doesn''t say that both types should be the same. However, there''s
    a way out. If you have constraints for some data types, you can express them before
    the actual signature, using a *fat* arrow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the definition is correct because all occurrences of the same type (denoted
    by the same letter, in this case, *a*) must be exactly the same. An alternative,
    but requiring much more typing, would have been writing all the possibilities
    with a union:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we have been using the standard type definitions. But, when we work
    with JavaScript, we have to consider some other possibilities, such as functions
    with optional parameters, or even with an undetermined number of parameters. We
    can use `...` to stand for any number of arguments, and an added `?` to represent
    an optional type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `unary()` higher-order function that we defined in the same chapter cited
    previously, took as a parameter any function, and returned a unary function as
    its result: we can show that the original function could receive any number of
    arguments, but the result used only the first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The standard `parseInt()` function provides an example of optional arguments:
    though it''s highly recommended not to omit the second parameter (the base radix)
    you can, in fact, skip it.'
  prefs: []
  type: TYPE_NORMAL
- en: Check out [https://github.com/fantasyland/fantasy-land/](https://github.com/fantasyland/fantasy-land/)
    and [https://sanctuary.js.org/#types](https://sanctuary.js.org/#types) for a more
    formal definition and description of types, as applied to JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'From now on, throughout this chapter, we will often be adding signatures to
    methods and functions. This will not only be so you can get accustomed to them,
    but because when we start delving into more complex containers, it will help to
    understand what we are dealing with: some cases can be hard to understand!'
  prefs: []
  type: TYPE_NORMAL
- en: Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back in [Chapter 5](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml), *Programming
    Declaratively - A Better Style*, and later in [Chapter 8](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml),
    *Connecting Functions - Pipelining and Composition*, we saw that the ability of
    being able to apply a mapping to all the elements of an array, and, even better,
    being able to chain a sequence of similar operations, was a good way to produce
    better, more understandable code.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is a problem: the `.map()` method (or the equivalent, *demethodized*
    one, as in [Chapter 6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml), *Producing
    Functions - Higher-Order Functions*), is available only for arrays, and we might
    want to be able to apply mappings and chaining to other data types. So, what can
    we do?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider different ways of doing this, which will give us several new
    tools for better functional coding. Basically, there are only two possible ways
    of solving this: we can either add new methods to existing types (though that
    will be limited because we can apply that only to basic JS types) or we can wrap
    types in some type of container, which will allow mapping and chaining.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's start first by extending current types, and then move on to using wrappers,
    which will lead us into deep functional territory, with entities such as functors
    and monads.
  prefs: []
  type: TYPE_NORMAL
- en: Extending current data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we want to add mapping to basic JS data types, let''s start by considering
    our options:'
  prefs: []
  type: TYPE_NORMAL
- en: With `null`, `undefined`, and `Symbol`, applying maps doesn't sound too interesting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the `Boolean`, `Number`, and `String` data types, we have some interesting
    possibilities, so we can examine some of those
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Applying mapping to an object would be trivial: you just have to add a `.map()`
    method, which must return a new object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, despite not being basic data types, we could also consider special
    cases, such as dates or functions, to which we could also add `.map()` methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As in the rest of the book, we are sticking to plain JS, but you should look
    into libraries such as LoDash, Underscore, or Ramda, which already provide functionalities
    such as we are developing here.
  prefs: []
  type: TYPE_NORMAL
- en: 'A key point, in all these mapping operations, should be that the returned value
    is of exactly the same type as the original one: when we use `Array.map()`, the
    result is also an array, and similar considerations must apply to any other `.map()`
    implementations (you could observe that the resulting array may have different
    element types as the original one, but it still is an array).'
  prefs: []
  type: TYPE_NORMAL
- en: 'What could we do with a boolean? First, let''s accept that booleans are not
    containers, so they do not really behave in the same way as an array: trivially,
    a boolean can only have a boolean value, while an array may contain any type of
    elements. However, accepting that difference, we can extend the `Boolean.prototype`
    (though, as I''ve already mentioned, that''s not usually recommended) by adding
    a new `.map()` method to it, and make sure that whatever the mapping function
    returns is turned into a new boolean value. And, for the latter, the solution
    will be similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `!!` operator forces the result to be a boolean: `Boolean(fn(this))` could
    also have been used. This kind of solution can also be applied to numbers and
    strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As with boolean values, we are forcing the results of the mapping operations
    to the correct data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, if we wanted to apply mappings to a function, what would that mean?
    Mapping a function should produce a function. The logical interpretation for `f.map(g)`
    would be first applying `f()`, and then applying `g()` to the result. So, `f.map(g)`
    should be the same as writing `x => g(f(x))` or equivalently, `pipe(f,g)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Verifying that this works, is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: With this, we are done as to what we can do with basic JS types -- but we need
    a more general solution if we want to apply this to other data types. We'd like
    to be able to apply mapping to any kind of values, and for that, we'll need to
    create some container; let's do this.
  prefs: []
  type: TYPE_NORMAL
- en: Containers and functors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What we did in the previous section does work, and can be used with no problems.
    However, we would like to consider a more general solution, which we could apply
    to any data type. Since not all things in JS provide the desired `.map()` method,
    we will have to either extend the type (as we did in the previous section) or
    apply a design pattern that we considered in [Chapter 11](24b391f7-abaf-439e-9bfc-a71d989cfd48.xhtml),
    *Implementing Design Patterns - The Functional Way*: wrapping our data types,
    with a wrapper that will provide the required `map()` operations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Wrapping a value: a basic container'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s pause a bit, and consider what we do need from this wrapper. There are
    two basic requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: We must have a `.map()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need a simple way to wrap a value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create a basic container to get started with -- but we''ll require some
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Some basic considerations:'
  prefs: []
  type: TYPE_NORMAL
- en: We want to be able to store some value in a container, so the constructor takes
    care of that
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using a `Symbol` helps to *hide* the field: the property key won''t show up
    in `Object.keys()` or in `for...in` or `for...of` loops, making them more *meddle-proof*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to be able to `.map()`, so a method is provided for that
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our basic barebones container is ready, but we can, however, add some other
    methods for convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: In order to get the value of a container, we could do `.map(x => x)`, but that
    won't work with more complex containers, so let's add a `.valueOf()` method to
    get the contained value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Being able to list a container can certainly help with debugging: a `.toString()`
    method will come in handy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because we need not write `new Container()` all the time, we can add a static
    `.of()` method to do the equivalent job
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Working with classes to represent containers (and later functors and monads)
    when living in a functional programming world may seem like heresy or sin... but
    remember we do not want to be dogmatic, and `class` and `extends` simplify our
    coding. Similarly, it could be argued that you must never take a value out of
    the container -- but using `.valueOf()` is sometimes too handy, so it won''t be
    that restrictive.Our Container becomes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can use this container to store a value, and we can use `.map()` to
    apply any function to that value... but this isn't very different to what we could
    do with a variable! Let's enhance this a bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enhancing our container: functors'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We wanted to have wrapped values, so what exactly should return the `map()`
    method? If we want to be able to chain operations, then the only logical answer
    is that it should return a new wrapped object. In true functional style, when
    we apply a mapping to a wrapped value, the result will be another wrapped value,
    with which we can keep on working.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of `.map()`, this operation is sometimes called `fmap()` standing for
    functorial map. The rationale for the name change was to avoid expanding the meaning
    of `.map()`. But, since we are working in a language that supports reusing the
    name, we can keep it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can extend our `Container` class to implement this change. The `.of()` method
    will require a small change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'With these properties, we have just defined what''s called a *Functor* in Category
    Theory! (Or, if you want to get really technical, a *Pointed Functor* because
    of the `.of()` method - but let''s keep it simple). We won''t go into the theoretical
    details, but roughly speaking, a functor is just some kind of container that allows
    applying `.map()` to its contents, producing a new container of the same type...
    and if this sounds familiar, it''s because you already know a functor: arrays!
    When you apply `.map()` to an array, the result is a new array, containing transformed
    (mapped) values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are more requirements for functors. First, the contained values may be
    polymorphic (of any types) as it happens with arrays. Second, there must exist
    a function, whose mapping produces the same contained value -- and `x => x` does
    this job. Finally, applying two consecutive mappings must produce the same result
    as applying their composition: `container.map(f).map(g)` must be the same as `container.map(compose(g,f))`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s pause a moment to consider the signature for our function and methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The first function, `of()`, is the simplest: given a value of any type, it
    produces a functor of that type. The next two are also rather simple to understand:
    given a functor, `toString()` always returns a string (no surprise there!) and
    if the functor contained value is of some given type, `valueOf()` produces a result
    of that same type. The third one, `map()`, is more interesting. Given a function
    that takes an argument of type *a* and produces a result of type *b*, applying
    it to a functor that contains a value of type *a*, produces a functor containing
    a value of type *b* -- this is exactly what we described above.'
  prefs: []
  type: TYPE_NORMAL
- en: As is, functors are not allowed or expected to produce side effects, throw exceptions,
    or any other behavior outside from producing a containered result. Their main
    usage is to provide a way to manipulate a value, apply operations to it, compose
    results, and so on, without changing the original -- in this last sense we are
    once again coming back to immutability.
  prefs: []
  type: TYPE_NORMAL
- en: You could also compare functors to promises, at least in one aspect. In functor,
    instead of acting on its value directly, you have to apply a function with `.map()`
    -- and in promises, you do exactly the same, but using `.then()` instead! In fact,
    there are more analogies, as we'll be seeing soon.
  prefs: []
  type: TYPE_NORMAL
- en: However, you could well say that this isn't enough, since in normal programming
    it's quite usual having to deal with exceptions, undefined or null values, and
    so on. So, let's start seeing more examples of functors, and after a while, we'll
    be entering into the realms of monads, for even more sophisticated kinds of processing.
    So, let's now experiment a bit!
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with missing values with Maybe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common problem in programming is dealing with missing values. There are many
    possible causes for this situation: a web service Ajax call may have returned
    an empty result, or a dataset could be empty, or an optional attribute might be
    missing from an object, and so on. Dealing with this kind of situation, in normal
    imperative fashion, requires adding `if` statements or ternary operators everywhere,
    to catch the possible missing value, avoiding a certain runtime error. We can
    do a bit better by implementing a `Maybe` functor, to represent a value that may
    be (or may *not* be) present! We will use two classes, `Just` (as in *just some
    value*) and `Nothing`, one for each functor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can quickly verify that this works, by trying to apply an operation to either
    a valid value or a missing one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We just applied `plus1()` several times to a `Maybe.of(null)` value, and there
    was no error whatsoever. A `MayBe` functor can deal with mapping a missing value,
    by just skipping the operation, and returning a wrapped `null` value instead.
    This means that this functor is basically including an abstracted check, which
    won't let an error happen. Let's give a more realistic example of its usage.
  prefs: []
  type: TYPE_NORMAL
- en: Later in the chapter, we'll see that Maybe can actually be a Monad instead of
    a Functor, and we'll also examine more examples of monads.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we are writing a small server-side service in Node, and we want to
    get the alerts for a city, and produce a not very fashionable HTML `<table>` with
    them, supposedly to be part of some server-side produced web page (yes, I know
    you should try to avoid tables in your pages, but what I want here is a short
    example of HTML generation, and actual results aren''t really important). If we
    used the *Dark Sky* API (see [https://darksky.net/](https://darksky.net/) for
    more on this API, and to register for usage) to get the alarms, our code would
    be something like this; all quite normal... Do notice the callback in case of
    an error; you''ll see why in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The (heavily edited and reduced in size) output of such a call, might be something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'I got this information for Houston, TX, US, on a day when Hurricane Harvey
    was approaching the state. If you called the API on a normal day, the data would
    simply totally exclude the `alerts:[...]` part. So, we can use a `Maybe` functor
    to process the received data without any problems, with or without any alerts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, you would probably do something more interesting than just logging
    the value of the contained result of `produceAlertsTable()`! The most likely option
    would be to `.map()` again with a function that would output the table, send it
    to a client, or whatever you needed to do. In any case, the resulting output would
    match something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If we had instead called `getAlerts(-34.9, -54.60, ...)` with the coordinates
    for Montevideo, Uruguay, since there were no alerts for that city, the `getField("alerts")`
    function would have returned `undefined` -- and as that value is recognized by
    the `Maybe` functor, and even though all the following `.map()` operations would
    still be executed, no one would actually do anything, and a `null` value would
    be the final result. See figure 12.1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/289aa8c5-320c-4ef5-bf35-e6133796f238.png)Figure 12.1\. The output
    table is not much to look at, but the logic that produced it didn''t require a
    single if.'
  prefs: []
  type: TYPE_NORMAL
- en: We did take advantage of this behavior also when coding the error logic. If
    an error happens when calling the service, we would still call the original callback
    to produce a table, but providing an empty object. Even if this result is unexpected,
    we would be safe, because the same guards would avoid causing a runtime error.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a final enhancement, we can add an `.orElse()` method, to provide a default
    value when no one is present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this new method instead of `valueOf()`, if trying to get the alerts for
    someplace without them, you would just get whatever default value you wanted.
    In the case we cited before when attempting to get the alerts for Montevideo,
    instead of a `null` value, we would now get an appropriate result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Working in this fashion we can simplify our coding, and avoid many tests for
    nulls and other similar situations. However, we may want to go beyond this; for
    instance, we could want to know *why* there were no alerts: was it a service error?
    Or just a normal situation? Just getting a `null` at the end isn''t enough, and
    in order to work with these new requirements, we will need to add something to
    our functors and enter the domain of *monads*.'
  prefs: []
  type: TYPE_NORMAL
- en: Monads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Monads* have a weird fame among programmers. Well known developer Douglas
    Crockford has famously spoken of *their* "curse", maintaining that *Once you happen
    to finally understand monads, you immediately lose the ability to explain them
    to other people!* On a different note, if you decide to go to the basics and read
    a book like *Categories for the Working Mathematician* by Saunders Mac Lane (one
    of the creators of Category Theory) you may find a somewhat disconcerting explanation:
    *A monad in X is just a monoid in the category of endofunctors of X, with product*
    × *replaced by composition of endofunctors and unit set by the identity endofunctor.*
    Not too illuminating!'
  prefs: []
  type: TYPE_NORMAL
- en: The difference between monads and functors is just that the former adds some
    extra functionality. Let's start by seeing the new requirements, and afterwards
    move on to consider some common, useful monads. As with functors, we will have
    a basic monad, which you could consider to be an *abstract* version, and specific
    *monadic types*, which are *concrete* implementations, geared to solving specific
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to read a precise and careful description of functors, monads,
    and all their family (but leaning heavily to the theoretical side, with plenty
    of algebraic definitions to go around) you can try the Fantasy Land Specification
    at [https://github.com/fantasyland/fantasy-land/](https://github.com/fantasyland/fantasy-land/).
    Don''t say we didn''t warn you: the alternative name for that page is *Algebraic
    JavaScript Specification*!)'
  prefs: []
  type: TYPE_NORMAL
- en: Adding operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s consider a simple problem. Suppose you have the following pair of functions,
    working with `Maybe` functors: the first function tries to search for *something*
    (say, a client or a product, whatever) given its key, and the second attempts
    to extract *some* attribute from it (I''m being purposefully vague because the
    problem does not have anything to do with whatever objects or things we may be
    working with). Both functions produce `Maybe` results, to avoid possible errors.
    We are using a mocked search function, just to help us see the problem: for even
    keys, it returns fake data, and for odd keys, it throws an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s the problem here? The problem is that the output from `getSome()` is
    a `Maybe` value, which itself contains a `Maybe` value, so the result we want
    is double wrapped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This problem can be easily solved in this toy problem (just avoid using `Maybe.of()`
    in `getSome()`), but this kind of result can happen in many ways, in more complex
    ways. For instance, you could be building a `Maybe` out of an object, one of whose
    attributes happened to be a `Maybe`, and if you''d get the same situation when
    accessing that attribute: you would end up with some doubly wrapped value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Monads should provide the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: A constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A function that inserts a value into a monad: our `.of()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A function that allows for chaining operations: our `.map()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A function that can remove extra wrappers: we will call it `.unwrap()`, and
    it will solve our preceding multiple wrapper problems. Sometimes it''s called
    `.flatten()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will also have a function to chain calls, just to simplify our coding, and
    another function to apply functions, but we''ll get to those later. Let''s see
    what a monad looks like in actual JavaScript code. Data type specifications are
    very much like those for functors, so we won''t repeat them here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We use recursion to successively remove wrappers, until the wrapped value isn''t
    itself a container anymore. Using this method, we could avoid doubly wrapping
    easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this sort of problem could recur at different levels. For example,
    if we were doing a series of `.map()` operations, any of the intermediate results
    may end up being doubly wrapped. You could easily solve this by remembering to
    call `.unwrap()` after each `.map()` -- note that you could do it even if it is
    not actually needed, for in that case the result of `.unwrap()` would be the very
    same object (can you see why?). But we can do better! Let''s define a `.chain()`
    operation, which will do both things for us (sometimes `.chain()` is called `.flatMap()`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: There's only one operation left. Suppose you have a curried function, with two
    parameters; nothing outlandish! What would happen if you were to provide that
    function to a `.map()` operation?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'What would something be? Given that we have provided only one argument to add,
    the result of that application will be a function... not just any function, but
    a *wrapped* one! (Since functions are first-class objects, there''s no logical
    obstacle to wrapping a function in a Monad, is there?) What would we want to do
    with such a function? In order to be able to apply this wrapped function to a
    value, we''ll need a new method: `.ap()`. What could the value be? In this case,
    it could either be a plain number, or a number wrapped in a monad as a result
    of other operations. Since we can always `Map.of()` a plain number into a wrapped
    one, let''s have `.ap()` work with a monad as its parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, you could then do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can use monads to hold either values or functions, and to interact
    with other monads and chaining operations as you may wish. So, as you can see,
    there's no big trick to monads, which are just functors with some extra methods.
    Let's see now how we can apply them to our original problem, and handle errors
    in a better way.
  prefs: []
  type: TYPE_NORMAL
- en: Handling alternatives - the Either monad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Knowing that a value was missing may be enough in some cases, but in others,
    you''ll want to be able to provide an explanation. We can get such explanation
    if we use a different functor, which will take one of two possible values, one
    associated with a problem, error, or failure, and another associated with normal
    execution, or success:'
  prefs: []
  type: TYPE_NORMAL
- en: A *left* value, which should be null, but if present it represents some kind
    of special value (for example, an error message or a thrown exception), which
    cannot be mapped over
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *right* value, which represents the *normal* value of the functor, and can
    be mapped over
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can construct this monad in a similar way than what we did for `Maybe` (actually,
    the added operations make it better for `Maybe` to extend `Monad` as well). The
    constructor will receive a left and a right value: if the left value is present,
    it will become the value of the `Either` monad; otherwise, the right value will
    be used. Since we have been providing `.of()` methods for all our functors, we
    need one for `Either` too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `.map()` method is key. If this functor has got a *left* value, it won''t
    be processed any further; in other cases, the mapping will be applied to the *right*
    value, and the result will be wrapped. Now, how can we enhance our code with this?
    The key idea is for every involved method to return an `Either` monad; `.chain()`
    will be used to execute operations one after another. Getting the alerts would
    be the first step -- we invoke the callback either with a `AJAX FAILURE` message
    or with the result from the API call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the general process would become as follows. We use an Either again:
    if there are no alerts, instead of an array, we return a `NO ALERTS` message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we used `.chain()`, so multiple wrappers would be no problem. We
    can now test multiple situations, and get appropriate results -- or at least,
    for the current weather situation around the world!
  prefs: []
  type: TYPE_NORMAL
- en: For Houston, TX, we still get an HTML table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Montevideo, UY, we get a text saying there were no alerts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a point with wrong coordinates, we learn that the AJAX call failed: nice!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We are not done with the Either monad. It's likely that much of your code will
    involve calling functions. Let's look for a better way of achieving this, through
    a variant of this monad.
  prefs: []
  type: TYPE_NORMAL
- en: Calling a function - the Try monad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we are calling functions that may throw exceptions, and we want to do it
    in a functional way, we could use the *Try* monad, to encapsulate the function
    result or the exception. The idea is basically the same as the Either monad: the
    only difference is in the constructor, which receives a function, and calls it:'
  prefs: []
  type: TYPE_NORMAL
- en: If there are no problems, the returned value becomes the right value for the
    monad
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there's an exception, it will become the left value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can invoke any function, catching exceptions in a good way. For example,
    the `getField()` function that we have been using, would crash if called with
    a null argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We can rewrite it using the Try monad, so it will *play nice* with other composed
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: There are many more monads, and of course, you can even define your own, so
    we couldn't possibly go over all of them. However, let's do visit just one more,
    which you have been using, without being aware of its *monad-ness*!
  prefs: []
  type: TYPE_NORMAL
- en: Unexpected Monads - Promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s finish this section on monads, by mentioning yet another one that you
    may have used, though under a different name: *Promises*! We already commented,
    earlier in this chapter, that functors (and remember, monads are functors) had
    at least something in common with promises: using a method in order to access
    the value. However, the analogy is greater than that!'
  prefs: []
  type: TYPE_NORMAL
- en: '`Promise.resolve()` corresponds with `Monad.of()` -- if you pass a value to
    `.resolve()`, you''ll get a promise resolved to that value, and if you provide
    a promise, you will get a new promise, whose value will be that of the original
    one (see [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve)
    for more on this). This is an *unwrapping* behavior!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Promise.then()` stands for `Monad.map()` and also `Monad.chain()`, given the
    mentioned unwrapping.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And we don''t have a direct match to `Monad.ap()`, but we could add something
    like the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Even if you opt for the modern `async` and `await` features, internally they
    are based on promises. Furthermore, in some situations you may still need `Promise.race()`
    and `Promise.all()`, so it's likely you will keep using promises, even if you
    opt for full ES8 coding.
  prefs: []
  type: TYPE_NORMAL
- en: This is an appropriate ending for this section. Earlier, you found out that
    common arrays were in fact functors. And now, in the same way, that Monsieur Jourdain
    (a character in Molière's play *Le Bourgeois Gentilhomme*, *The Burgeois Gentleman*)
    discovered that all his life he had been speaking in prose, you now know you had
    already been using monads, even without knowing it!
  prefs: []
  type: TYPE_NORMAL
- en: Functions as data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen how to use functions to work with or transform, other functions,
    to process data structures, or to create data types. Let's then finish this chapter
    by showing how a function can actually implement a data type by itself, becoming
    a sort of container of its own. In fact, this is a basic theoretical point of
    the lambda calculus (and if you want to learn more, look up *Church Encoding*
    and *Scott Encoding*), so we might very well say that we have come around to the
    point where we began this book, at the origins of Functional Programming!
  prefs: []
  type: TYPE_NORMAL
- en: Binary trees in Haskell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider a binary tree. Such a tree may either be empty, or consist of a node
    (the tree *root*) with two sons: a left binary tree, and a right one.'
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](0f9ddfc4-d3d9-40a9-941b-edbec62cc890.xhtml), *Designing Functions
    - Recursion*, we worked with more general tree structures, such as a filesystem
    or the browser DOM itself, which allow a node to have any number of sons. In the
    particular case of the trees we are working with in this section, each node always
    has two sons, although each of them may be empty. The difference may seem minor,
    but allowing for empty subtrees is what lets you define that all nodes are binary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make a digression with the Haskell language. In it, we might write something
    like the following; *a* would be the type of whatever value we hold in the nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In that language, pattern matching is often used for coding. For example, we
    could define an `empty` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The logic is simple: if the tree is `Nil` (the first possibility in the definition
    of the type) then the tree is certainly empty; otherwise, the tree isn''t empty.
    The last line would probably be written `empty _ = False` because you don''t actually
    care for the components of the tree; the mere fact that it''s not `Nil` suffices.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Searching for a value in a binary search tree (in which the root is greater
    than all the values of its left subtree, and less than all the values of its right
    subtree) would be similarly written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: An empty tree doesn't contain the searched value. For other trees, if the root
    matches the searched value, we are done. If the root is greater than the searched
    value, the answer is found searching in the left subtree; otherwise, search in
    the right subtree.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s an important point to be remembered: for this data type, a union of
    two possible types, we have to provide two conditions, and pattern matching will
    be used to decide which one is to be applied. Keep this in mind!'
  prefs: []
  type: TYPE_NORMAL
- en: Functions as binary trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Can we do something similar with functions? The answer is yes: we will represent
    a tree (or any other structure) with a function itself -- and mind: not with a
    data structure that is processed by a set of functions, and not either with an
    object with some methods, but by just a function. Furthermore, we will get a functional
    data structure, 100% immutable, which if updated produces a new copy of itself.
    And, we will do all this without using objects; rather, closures will provide
    the desired results.'
  prefs: []
  type: TYPE_NORMAL
- en: How can this work? We shall be applying similar concepts as those we saw earlier
    in the chapter, so the function will act as a container, and it will produce,
    as its result, a mapping of its contained values. Let's walk backwards, and start
    by showing how we'll use the new data type, and then go to the implementation
    details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a tree will be done by using two functions: `EmptyTree()` and `Tree(value,
    leftTree, rightTree)`. For example, creating a tree as shown in figure 12.2, would
    be done by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/09f3f6b2-11cb-4c02-b8b1-07b63c60d964.jpg)Figure 12.2\. A binary
    search tree, created by the following code.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'How do you work with this structure? According to the data type description,
    whenever you work with a tree, you must consider two cases: a non-empty tree,
    or an empty one. In the preceding code, `myTree()` is actually a function that
    receives two functions as arguments, one for each of the two data type cases.
    The first function will be called with the node value and left and right trees
    as arguments, and the second function will receive none. So, to get the root we
    could write something as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: If we were dealing with a non-empty tree, we expect the first function to be
    called and produce the value of the root as the result. With an empty tree, the
    second function should be called, and then a `null` value would be returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, if we wanted to count how many nodes are there in a tree, we would
    write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: For non-empty trees, the first function would return 1 (for the root) plus the
    node count from both the root's subtrees. For empty trees, the count is simply
    zero. Get the idea?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now show the `Tree()` and `EmptyTree()` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The `destructure()` function is what you will pass as an argument (the name
    comes from the destructuring statement in JS, which lets you separate an object
    attribute into distinct variables). You will have to provide two versions of this
    function. If the tree is non-empty, the first function will be executed; for an
    empty tree, the second one will be run (this mimics the *case* selection in the
    Haskell code, except we are placing the non-empty tree case first, and the empty
    tree last). The `__` variable is used just as a placeholder, to stand for an otherwise
    ignored argument, but showing that two arguments are assumed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be hard to understand, so let''s see some more examples. If we need
    to access specific elements of a tree, we have the following three functions,
    one of which (`treeRoot()`) we already saw -- let''s repeat it here for completeness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Functions that access the component values of structures (or *constructions*,
    to use another term) are called *projector functions*. We won't be using this
    term, but you might find it elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we decide if a tree is empty? See if you can see why this short line
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s just go over a few more samples of this. For example, we can build an
    object out of a tree, and that would help with debugging. I added logic to avoid
    including left or right empty subtrees, so the produced object would be shorter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the usage of recursion, as in the *Traversing a Tree Structure* section
    of [Chapter 9](0f9ddfc4-d3d9-40a9-941b-edbec62cc890.xhtml), *Designing Functions
    - Recursion*, in order to produce the object equivalents of the left and right
    subtrees. An example of this function is as follows; I edited the output to make
    it more clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Can we search for a node? Of course, and the logic follows closely the definition
    we saw in the previous section (we could have shortened the code a bit, but I
    did want to parallel the Haskell version):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'And, to round out this section, let''s also include how to add new nodes to
    a tree. Study the code carefully, and you''ll notice how the current tree isn''t
    modified, and a new one is produced instead. Of course, given that we are using
    functions to represent our tree data type, it should be obvious that we wouldn''t
    have been able to just modify the old structure: it''s immutable by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: When trying to insert a new key, if it's less or equal to the root of the tree,
    we produce a new tree that has the current root as its own root, maintains the
    old right subtree, but changes its left subtree to incorporate the new value (which
    will be done in a recursive way). If the key was greater than the root, the changes
    would not have been symmetrical, but analogous. And if we try to insert a new
    key, and we find ourselves an empty tree, we just replace that empty structure
    with a new tree, with just the new value as its root, and empty left and right
    subtrees.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test out this logic easily -- but the simplest way is to verify that
    the binary tree is shown earlier (Figure 12.2) is generated by the following sequence
    of operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We could make this insertion function even more general, by providing the comparator
    function that would be used to compare values. In this fashion, we could easily
    adapt a binary tree to represent a generic map. The value of a node would actually
    be an object such as `{key:... , data:...}` and the provided function would compare
    `newValue.key` and `value.key` to decide where to add the new node. Of course,
    if the two keys were equal, we would change the root of the current tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'What else do we need? Of course, we may program diverse functions: deleting
    a node, counting nodes, determining a tree''s height, comparing two trees, and
    so on. But, in order to gain more usability, we should really turn the structure
    into a functor, by implementing a `map()` function. Fortunately, using recursion,
    this proves to be easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We could go on with more examples, but that won''t change the important conclusions
    we can derive from this work:'
  prefs: []
  type: TYPE_NORMAL
- en: We are handling a data structure (a recursive one, at that) representing it
    with a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are not using any external variables or objects for the data: closures are
    used instead'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data structure itself satisfies all the requirements we analyzed in Chapter
    10, *Ensuring Purity - Immutability*, insofar it is immutable and all changes
    always produce new structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And, finally, the tree is a functor, providing all the corresponding advantages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, we have seen even one more application of functional programming -- and
    we've seen how a function can actually become a structure by itself, which isn't
    what one is usually accustomed to!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 12.1\. **Maybe tasks?** In the questions section of [Chapter 8](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml),
    *Connecting Functions - Pipelining and Composition*, a question had to do with
    getting the pending tasks for a person, but taking into account errors or border
    situations, such as the possibility that the selected person might not even exist.
    Redo that exercise, but using Maybe or Either monads to simplify that coding.
  prefs: []
  type: TYPE_NORMAL
- en: '12.2\. **Extending your trees**. In order to get a more complete implementation
    of our functional binary search trees, implement the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Calculate the tree's height -- or, equivalently, the maximum distance from the
    root to any other node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List all the tree's keys, in ascending order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete a key from a tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '12.3\. **Functional lists**. In the same spirit of the binary trees, implement
    functional lists. Since a list is defined to be either empty or a node (head)
    followed by another list (tail), you might want to start with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some easy one-liner operations to get you started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'You could consider having these operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Transforming a list into an array, and vice-versa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reversing a list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Append one list to the end of another list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concatenating two lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't forget a `listMap()` function! Also, `listReduce()` and `listFilter()`
    functions would come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: 12.4\. **Code shortening**. We mentioned that the `treeSearch()` function could
    be shortened -- can you do that? Yes, this is more of a JavaScript problem than
    a functional one, and I'm not saying that shorter code is necessarily better,
    but many programmers act as if it were, so it's good to be aware of such style
    if only because you're likely to find it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we turned a bit closer to theory and seeing how to use and
    implement data types from a functional point of view. We started with ways of
    defining function signatures, to help understand the transformations implied by
    the multiple operations we later met; then, we went on to define several containers,
    including functors and monads, and see how they could be used to enhance function
    composition, and finally we saw how functions could be directly used by themselves,
    with no extra baggage, to implement functional data structures.
  prefs: []
  type: TYPE_NORMAL
- en: As of now, in this book we have seen several features of functional programming
    for JavaScript. We started out with some definitions, a practical example, and
    then moved on to important considerations such as pure functions, side effects
    avoidance, immutability, testability, building new functions out of other ones,
    and implementing data flow based upon function connections and data containers.
    We have seen a lot of concepts, but I'm confident that you'll be able to put them
    in practice, and start writing even higher quality code - give it a try!
  prefs: []
  type: TYPE_NORMAL
