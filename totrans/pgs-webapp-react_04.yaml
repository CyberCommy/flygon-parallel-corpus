- en: Easy Backend Setup With Firebase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application looks pretty, but it doesn't do that much. We have a login form
    that doesn't let users actually log in.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll get started on the backend of our application. In our
    case, that means setting up a database to save users and their messages. In one
    chapter, we will cover everything we need to let our users create accounts and
    log in. We''ll also dive deeper into React and component state. We''ll learn the
    following things:'
  prefs: []
  type: TYPE_NORMAL
- en: What Firebase is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gotchas and problems to look out for
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to deploy our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User authentication (signup and login)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React life cycle methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get to it!
  prefs: []
  type: TYPE_NORMAL
- en: What is Firebase?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a progressive web app is, for the most part, a frontend process. PWAs
    care little for how they consume data from a backend API (unless it impedes performance,
    of course). We want to keep the backend setup for our application minimal; for
    that, we turn to Firebase.
  prefs: []
  type: TYPE_NORMAL
- en: '**Firebase** is a project by Google designed to help developers build apps
    without worrying about backend infrastructure. It operates on the freemium model,
    based on the amount of requests your backend has to respond to as well as the
    amount of storage you need. For our purposes, it is the perfect fit for quickly
    developing a small prototype. When our app scales, the Chatastrophe executive
    board assures us, "money won''t be an issue."'
  prefs: []
  type: TYPE_NORMAL
- en: What does Firebase provide? Of interest to us is a database, a hosting solution,
    and built-in authentication. Beyond that, it also offers something called **Cloud
    Functions**, which are snippets of code automatically run in response to certain
    events. We'll be working with Cloud Functions once we add push notifications to
    our application. For now, we want to add some authentication to our login form
    so that users can sign up and log in to Chatastrophe.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a Google account (via Google Plus or Gmail, for example) you can
    log in to Firebase with those credentials, or create a new account; that's all
    we need to get started.
  prefs: []
  type: TYPE_NORMAL
- en: Firebase gotchas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Firebase is a useful tool, but it does have some caveats.
  prefs: []
  type: TYPE_NORMAL
- en: One of the big selling points (for us especially) is its real-time database.
    This means that changes to the data by one user are automatically pushed to all
    users. We don't have to check whether a new chat message has been created; each
    instance of the application will be instantly informed.
  prefs: []
  type: TYPE_NORMAL
- en: The database also has offline persistence, which means our users can read their
    messages even when they're offline (which, if you remember, fulfills one of the
    user stories we outlined earlier). Firebase uses local caching to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: So, what's the downside? The Firebase database is a NoSQL database, and has
    a specific syntax that may seem strange to developers more used to SQL databases.
    The process is similar to a SQL database (with the major **CRUD** actions--**Create**,
    **Read**, **Update**, and **Delete**-- applying to data), but it may not be as
    intuitive.
  prefs: []
  type: TYPE_NORMAL
- en: The other gotcha with Firebase is that it is not (at the time of writing) optimized
    for **Single-Page Applications** (**SPAs**) like those built with React. We'll
    have to do a couple of workarounds to get everything running smoothly with our
    React application.
  prefs: []
  type: TYPE_NORMAL
- en: All that said, however, Firebase will save us a lot of time in comparison to
    setting up our own backend server/hosting solution, and it's a pleasure to use
    for personal projects; this is definitely something worth learning.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s how we''ll get going with Firebase:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll go to the Firebase console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From there, we'll create a project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll name our lovely little project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll get the code necessary to integrate it into our app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll add that code to `index.html`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll make Firebase available as a global variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you''re ready to get started, let''s do it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve created or logged in to your Google account, head over to [https://firebase.google.com/](https://firebase.google.com/).
    In the top-right corner of your screen, you should see a button titled GO TO CONSOLE:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'From the Firebase console, we want to Add Project. Click on the icon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: For Project Name, choose `chatastrophe` (all lowercase), and then select your
    Country/Region.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Firebase should take you directly to the project page once that''s done. From
    there, click on the link that says Add Firebase to your web app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Copy and paste the code it gives you into your `public/index.html`, before
    the closing `</body>` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we need to make our Firebase application available to the rest of our
    app. At the bottom of the script tag, just before the `firebase.initializeApp(config)`
    line, add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This code stores our Firebase setup on the `window` object, so we can access
    it in the rest of our JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: If you're not using source control (GitHub or Bitbucket, for example) or are
    using a private repository to store your code, you can skip to the next section.
    For the rest of us, we need to do some work to ensure that we don't display our
    `config.apiKey` to the entire world (a recipe for malicious use).
  prefs: []
  type: TYPE_NORMAL
- en: Hiding our API key
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to move our API key and `messagingSenderId` to a separate file, and
    then ensure that the file is not checked into Git:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, create a file in `public/` called `secrets.js`. In that file, place
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Again, we're taking advantage of the globally accessible window object to store
    the key. For those of you new to JavaScript, note that it is not good practice
    to abuse the window object; only use it when absolutely necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this key in `index.html`, we can add the following above all the other
    script tags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in our Firebase initialization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As the last step, we need to tell Git to ignore the `secrets.js` file. You
    can do so by modifying our `.gitignore` file in the project base, adding the following
    line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: All done! We can now commit and push up freely.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Firebase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As I mentioned earlier, Firebase comes with a baked-in deployment solution.
    Let''s get our app up and working on the real live web! Here''s how to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we''ll first need to install the Firebase command-line tools:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Donâ€™t forget the `-g`. This flag installs the tools globally on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to log in to our Firebase tools:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To complete our Firebase tools setup, we can now initialize our app as a Firebase
    project, similar to what we did with `npm`. Ensure that you run this from the
    root of the project folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the first question it then prompts you for, use the arrow keys and the *Spacebar*
    to select both Functions and Hosting. We will use Firebase's Cloud Functions later
    on. Don't select Database, that's for configuring database rules locally; we'll
    rely on the Firebase console instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your selections should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When it asks for a default Firebase project, select `chatastrophe`(or whatever
    you named this project in the Firebase console).
  prefs: []
  type: TYPE_NORMAL
- en: For the question Do you want to install dependencies with npm now?, enter y.
  prefs: []
  type: TYPE_NORMAL
- en: Next, it'll ask you what folder you want to use as your public directory. Enter
    `build`, not `public`. Firebase is asking what folder to use to deploy your project;
    we want our final compiled build, including our transpiled JavaScript and therefore,
    we want the `build` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move to the next question now! Do we want to configure our app as a single-page
    application? Heck yes. Decline overwriting `index.html` though (however, no worries
    if you say yes; we regenerate our `build/index.html` every time we run our `build`
    command).
  prefs: []
  type: TYPE_NORMAL
- en: Okay, we're all set up to deploy. Let's make an `npm` script to make our lives
    easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every time we deploy, we''ll want to rerun our `build` command to ensure that
    we have the freshest build of our project. Our `npm` script will thus combine
    both, added into our `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script with `yarn deploy`, and then check out the URL it displays in
    the Terminal. If all goes well, your app should look exactly like it does in development.
    Open up the console and check for warnings; if you see any, skim the Webpack chapter
    and see whether you missed any of the settings for our `webpack.config.prod.js`
    (you can take a peek at the final file in the branch here: [https://github.com/scottdomes/chatastrophe/tree/chapter4](https://github.com/scottdomes/chatastrophe/tree/chapter4)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Awesome! We have a deployed app ready to share with our friends. The only problem
    is what we discussed at the end of the last chapter; it doesn't actually do much
    yet.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started with using Firebase by adding an authentication process.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication with Firebase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To allow users to log in/sign up for our app, we need to do three things:'
  prefs: []
  type: TYPE_NORMAL
- en: Turn on email authentication on the Firebase console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Submit the email and password in our form to Firebase when the user clicks on
    the button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Either sign up or log in the user based on the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Letâ€™s open up our Firebase console ([https://console.firebase.google.com](https://console.firebase.google.com))
    and get to work on task #1:'
  prefs: []
  type: TYPE_NORMAL
- en: From our Chatastrophe project page, click on Authentication.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the SIGN-IN METHOD tab, you can see all the options that Firebase provides.
    These authentication solutions are huge boons to developers, as configuring authentication
    can be tricky (especially when working with third-party APIs, such as Twitter
    or Facebook). There's a lot of infrastructure to create to provide the proper
    security. Firebase takes care of that for us, so all we have to worry about is
    tapping into their system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Email/Password and then on Enable and Save. Our app can now use email
    and password combinations to sign up and log in. If you're looking to spice up
    our app a bit down the line, try implementing a Facebook or GitHub sign-in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Get back to the app, and hop on over to `LoginContainer.js`. At the moment,
    when the user submits our form, we just prevent the default submission and log
    out our state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: For our process, we will combine the signup and login processes into one. First,
    we'll check whether the email and password fields are filled in. If so, we'll
    try logging the user in, and if Firebase tells us that no user exists with that
    email, we'll create the user and sign them in automatically.
  prefs: []
  type: TYPE_NORMAL
- en: However, if the user does exist and we get a wrong password error, we'll alert
    the user by implementing a bit more state in our component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the plan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Firstly, check whether the fields are filled in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Right away, we need a way to display an error to the user to tell them that
    they missed a field. Let''s add an error string to our state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll reset that error to an empty string every time they submit the form,
    but if they missed a field, we''ll display the following text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, to display the error, we''ll add a `<p>` tag above our button, with
    the `className` of the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, try submitting our form without a field filled in. You can do so by either
    running the app locally (with your Dev server) or redeploying your changes. You
    should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It's looking good so far. The next step is to try to log the user in. At this
    point, our app has no users, so Firebase should return an error. Let's call Firebase
    with our email and password, and then console log the result.
  prefs: []
  type: TYPE_NORMAL
- en: The method we want to use is `firebase.auth().signInWithEmailAndPassword(email,
    password)`. This function returns a JavaScript promise. For those familiar with
    promises, you can skip to the next section, but itâ€™s worth brushing up on if you're
    unsure.
  prefs: []
  type: TYPE_NORMAL
- en: What is a promise?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The problem with JavaScript is that it often deals with asynchronous operations.
    These are steps that the code must complete which don't follow a linear flow in
    time. Normally, code runs line by line, one after the other, but what happens
    when we need to call an API that takes a random number of seconds to respond?
    We can't just stop our code and wait, and we will still have certain lines of
    code to execute once that call is complete, whenever that is.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution used to be **callbacks**. If we were using `firebase.auth().signInWithEmailAndPassword`
    in this manner, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We would pass it a callback that is called when the operation is complete.
    This approach works fine, but can lead to some ugly code: specifically, something
    called the **pyramid of doom**, or **callback hell**, where nested callbacks lead
    to sloping code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To make working with asynchronous functions easier and cleaner, the people
    behind JavaScript implemented promises. **Promises** have a simple syntax: pass
    one function to a `.then` statement to be called when the operation is a success,
    and another to a `.catch` statement when the operation is a failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, our code is nice and readable, and we know exactly what code will be run
    when the operation is complete.
  prefs: []
  type: TYPE_NORMAL
- en: Back to authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we expect an error to be returned (since we haven''t signed up with any
    email and password combination), we can leave our `then` statement blank, but
    add a console log to our `catch` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Submit your form, and you should be returned the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! This is exactly the error we wanted. This is the code we''ll check for,
    before initiating the signup process. For now, we''ll assume that all the other
    errors are due to an incorrect password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Code cleanup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our `handleSubmit` function is getting a little long and difficult to follow.
    Let's do some reorganization before we move on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by moving everything after the initial `if` statement inside a
    separate function, called `login()`, for simplicity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, our `handleSubmit` becomes much smaller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: It's much easier to read and follow now.
  prefs: []
  type: TYPE_NORMAL
- en: Signing up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get that signup process going. Again, it''s a rather simple function
    name--`firebase.auth().createUserWithEmailAndPassword(email, password)`. Again,
    it returns a promise. Let''s add `then` and `catch`, but leave the `then` as a
    console log for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Try logging in to our app, and you should see a complicated user object show
    up in the console. Success! We created our first user account. If you try logging
    in again with the same account, you should see the same user object logged to
    the console.
  prefs: []
  type: TYPE_NORMAL
- en: You can try again with a different email and password combination (it doesn't
    matter if it's a real email, for our purposes), and it should work smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: Saving our user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `user` object we received in response to our `firebase.auth().signIn` seems
    like it'll be useful down the line. There may be numerous times we want access
    to the email of the currently signed-in user. Let's go ahead and save that in
    the state of our `App` component so that we can then pass it down to any `Container`
    component (once we make more containers).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two possible approaches: we can pass up the user object from `LoginContainer`
    to `App` via a callback through props, and `App` will pass a `handleLogin` function
    to `LoginContainer` as a prop, which will be called when the user logs in and
    sets the state of `App` appropriately.'
  prefs: []
  type: TYPE_NORMAL
- en: Firebase gives us another option, however. As we discussed earlier, the Firebase
    database is real-time, which means changes to the data are automatically pushed
    to the frontend. All we need to do is set up the appropriate listener functions
    to wait for that change and act on it.
  prefs: []
  type: TYPE_NORMAL
- en: Event listeners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Event listeners** in JavaScript essentially work like so: we define an event
    and a callback we want to run when that event occurs. We can thus declare a function
    early on in our code, and only have it triggered later, whenever the specified
    event occurs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of listening for a resize of the browser window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Firebase provides us with a function called `firebase.auth().onAuthStateChanged`.
    This function takes a callback as an argument, which is then called with the user
    object; it's perfect for our purposes!
  prefs: []
  type: TYPE_NORMAL
- en: 'The challenge, however, is when to declare this function in our `App` component.
    We want it to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this leads to a couple of restrictions:'
  prefs: []
  type: TYPE_NORMAL
- en: We only want to register the listener once, so we can't put it in the `render`
    method (which can be called multiple times as React updates the DOM)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need the `App` component to be fully loaded before registering the listener,
    because React complains if you try to `setState` on a non-existent component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In other words, we need to declare `onAuthStateChanged` at a particular time,
    that is, as soon as possible after `App` has appeared on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Lifecycle methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fortunately, situations like this one are common in React, so the library provides
    us with a solution: a suite of functions called **lifecycle methods**. These methods
    come standard with all (class-based) React components, and are called at certain
    points as the component appears, updates, and disappears.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The lifecycle of a React component is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The application has started, and the component's `render` method is about to
    be called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The component has rendered and has now appeared on the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The component is about to receive new props
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The component has received new props, and is about to call render again to update
    in response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The component has updated in response to new props or a state change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The component is about to disappear from the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that all of these don't necessarily occur with every component, but they
    are all quite common as our UI updates and changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The corresponding lifecycle methods are as listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`componentWillMount`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`componentDidMount`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`componentWillReceiveProps`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`componentWillUpdate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`componentDidUpdate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`componentWillUnmount`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on the preceding description, take a moment and try to figure out which
    lifecycle method we want to use to register our `onAuthStateChanged`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, the point of time we''re looking for is right after the component is
    first rendered. This makes `componentDidMount` the perfect choice; let''s add
    it to our `App` component. We also need to initialize our state with the `user`
    key, which we''ll work with in a second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If you're unclear on lifecycle methods, try adding all six of them to your app
    with console logs in each one (as well as a `console.log` in the `render` method),
    and watch the lifecycle of your React component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, we can add `onAuthStateChanged` next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Confused about the `this.setState({ user })`? That''s called the `ES6` property
    shorthand. Basically, when you''re assigned a key to a variable, and the key and
    the variable should have the same name, you can save time instead of typing `this.setState({
    user: user })`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note the `if` statement. `onAuthStateChanged` is also called when the user logs
    out, in which case the user argument will be null. We can set `this.state.user`
    to null, but let's keep it simple and let the user persist in state until the
    next user comes along.
  prefs: []
  type: TYPE_NORMAL
- en: Another bonus to Firebase authentication is that it takes care of persistent
    login for us. This means that a user won't have to log in every time they come
    to our app; Firebase will load their logged-in state automatically, until they
    click on sign out (which we'll add in the future). In accordance with this, `onAuthStateChanged`
    will be called every time that a user visits our app, whether they physically
    log in or are already logged in. Therefore, we can rely on our user object always
    being saved in state if the user is logged in.
  prefs: []
  type: TYPE_NORMAL
- en: You can try it by logging out the user in the callback of `onAuthStateChanged`
    with `firebase.auth().signOut();`. Try logging in again, and then refreshing the
    page; you should see the user object appear no matter how many times you refresh,
    as you are automatically logged in.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'That does it for authentication! Now, our users can log in to our app. The
    next step is to give them something to do once they sign in. For that, we need
    more pages, which leads us to our next topic: routing with React. How do we navigate
    between React components? How do we change the content of our app in accordance
    with the URL? All that and more is coming up next!'
  prefs: []
  type: TYPE_NORMAL
