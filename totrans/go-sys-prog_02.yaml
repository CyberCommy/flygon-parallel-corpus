- en: Writing Programs in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will talk about many essential, interesting, and handy Go topics
    that will help you be more productive. I think it would be a good idea to start
    this chapter by compiling and running the Go code of the `hw.go` program from
    the previous chapter. Then, you will learn how to deal with the environment variables
    that can be used by Go, how to process the command-line arguments of a Go program,
    and how to print the output on the screen and get input from the user. Finally,
    you will see how to define functions in Go, learn about the extremely important
    `defer` keyword, look at the data structures that come with Go, and learn what
    Go interfaces are before checking out code that generates random numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, in this chapter, you will become familiar with many Go concepts,
    including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Compiling your Go programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go environment variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the command-line arguments given to a Go program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting user input and printing the output on your screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go functions and the `defer` keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go data structures and interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating random numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling Go code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go does not care about the name of the source file of an autonomous program
    as long as the package name is `main` and there is a `main()` function in it.
    This is because the `main()` function is where the program execution begins. This
    also means that you cannot have multiple `main()` functions in the files of a
    single project.
  prefs: []
  type: TYPE_NORMAL
- en: 'There exist two ways to run a Go program:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one, `go run`, just executes the Go code without generating any new
    files, only some temporary ones that are deleted afterward
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second way, `go build`, compiles the code, generates an executable file,
    and waits for you to run the executable file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This book is written on an Apple Mac OS Sierra system using the Homebrew ([https://brew.sh/](https://brew.sh/))
    version of Go. However, you should have no difficulties compiling and running
    the presented Go code on most Linux and FreeBSD systems, provided that you have
    a relatively recent version of Go.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the first way is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The aforementioned way allows Go to be used as a scripting language. The following
    is the second way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The generated executable file is named after the name of the Go source file,
    which is much better than `a.out`, which is the default filename of the executable
    files generated by the C compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'If there is an error in your code, such as a misspelled Go package name when
    calling a Go function, you will get the following kind of error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you accidentally misspell the `main()` function, you will get the following
    error message because the execution of an autonomous Go program begins from the
    `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, I want to show you an error message that will give you a good idea
    about a formatting rule of Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The previous error message shows us that Go prefers putting curly braces in
    a certain way, which is not the case with most programming languages such as Perl,
    C, and C++. This might look frustrating at first, but it saves you from one extra
    line of code and makes your programs more readable. Note that the preceding code
    uses the *Allman formatting style*, which Go does not accept.
  prefs: []
  type: TYPE_NORMAL
- en: The official explanation for this error is that Go requires the use of semicolons
    as statement terminators in many contexts, and the compiler automatically inserts
    the required semicolons when it thinks they are necessary, which in this case
    is at the end of a non-blank line. Therefore, putting the opening brace (`{`)
    on its own line will make the Go compiler to put a semicolon at the end of the
    previous line, which produces the error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you think that the `gofmt` tool can save you from similar errors, you will
    be disappointed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The Go compiler has another rule, as you can see in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This means that you should not import packages without actually using them in
    your programs. Although this could have been a harmless warning message, your
    Go program will not get compiled. Bear in mind that similar warnings and error
    messages are a good indication that you are missing something, and you should
    try to correct them. You will create a higher quality of code if you treat warnings
    and errors the same.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the size of the executable file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, after successfully compiling `hw.go`, you might want to check the size
    of the generated executable file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling the same Go program on a Linux machine will create the following
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To get a better sense of how big the Go executable is, consider that the executable
    for the same program written in C is about 8432 bytes!
  prefs: []
  type: TYPE_NORMAL
- en: 'So, you might ask why such a huge executable file for such a small program?
    The main reason is that Go executable files are statically build, which means
    that they require no external libraries to run. The use of the `strip(1)` command
    can make the generated executable files a little smaller, but do not expect miracles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous process has nothing to do with Go itself because `strip(1)` is
    a Unix command that removes or modifies the symbol table of files and therefore
    reduces their size. Go can perform the work of the `strip(1)` command on its own
    and create smaller executable files, but this method does not always work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding output is from a Linux machine; when the same compilation command
    is used on a macOS machine, it will make no difference to the size of the executable
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Go environment variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `go tool` can use many Unix shell environment variables dedicated to Go,
    including `GOROOT`, `GOHOME`, `GOBIN`, and `GOPATH`. The most important Go environment
    variable is `GOPATH`, which specifies the location of your workspace. Usually,
    this is the only environment variable that you will need to define when developing
    Go code; it is to do with the way the files of a project will be organized. This
    means that each project will be organized into three main directories, named `src`,
    `pkg`, and `bin`. However, many people, including me, prefer not to use `GOPATH`
    and manually organize their project files.
  prefs: []
  type: TYPE_NORMAL
- en: So, if you are a big fan of shell variables, you can put all these kinds of
    definitions in either `.bashrc` or `.profile`, which means that these environment
    variables will be active every time you log in to your Unix machine. If you are
    not using the Bash shell, which is the default Linux and macOS shell, then you
    might need to use another start up file. Check out the documentation of your favorite
    Unix shell to find out which file to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The upcoming screenshot shows part of the output of the following command,
    which displays all the environment variables used by Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/87508a77-cb59-4e6f-ac23-d4a412f73ebc.png)'
  prefs: []
  type: TYPE_IMG
- en: The output of the "go help environment" command
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find additional information about a particular environment variable
    by executing the next command and replacing `NAME` with the environment variable
    that interests you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: All these environment variables have nothing to do with the actual Go code or
    the execution of the program, but they might affect the development environment;
    therefore, if you happen to see any strange behavior while trying to compile a
    Go program, check the environment variables you are using.
  prefs: []
  type: TYPE_NORMAL
- en: Using command-line arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Command-line arguments allow your programs to get input, such as the names of
    the files you want to process, without having to write a different version of
    the program. Hence, you cannot create any useful systems software if you're unable
    to process the command-line arguments passed to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'So here is a naive Go program, named `cla.go`, that prints all its command-line
    arguments, including the name of the executable file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, Go needs an extra package named `os` in order to read the command-line
    arguments of a program that are stored in the `os.Args` array. In case you do
    not like having multiple import statements, you can rewrite the two import statements
    as follows, which I find much easier to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `gofmt` utility puts package names in alphabetical order when you are importing
    all your packages using a single import block.
  prefs: []
  type: TYPE_NORMAL
- en: The Go code of `cla.go` is simple as it stores all the command-line arguments
    in an array and uses a `for` loop for printing them. As you will see in forthcoming
    chapters, the `os` package can do many more things. If you are familiar with C,
    you should know that in C, command-line arguments are automatically passed to
    programs, and you do not need to include any extra header files in order to read
    them. Go uses a different approach that gives you more control but requires slightly
    more code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `cla.go` after building it first will create the following kind of
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Finding the sum of the command-line arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let us try something different and tricky: you are going to try to find
    the summary of the command-line arguments given to your Go program. Therefore,
    you are going to consider the command-line arguments as numbers. Although the
    main idea remains the same, the implementation is totally different because you
    will have to convert your command-line arguments into numbers. The name of the
    Go program will be `addCLA.go`, and it can be split into two parts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part is the preamble of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You need the `fmt` package for printing your output and the `os` package for
    reading the command-line arguments. As command-line arguments are stored as strings,
    you will also need the `srtconv` package for converting them into integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part is the implementation of the `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `strconv.Atoi()` function returns two values: the first one is an integer
    number, provided that the conversion was successful, and the second one is an
    error variable.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that most Go functions return an error variable, which should always be
    examined, especially on production software.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do not use the `strconv.Atoi()` function, then you will have two problems:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one is that the program will try to perform additions, which are mathematical
    operations, using strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second one is that you will not be able to tell whether a command-line argument
    is a valid integer number or not, which can be done by examining the return value
    of `strconv.Atoi()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, `strconv.Atoi()` not only does the desired job, but it also tells us whether
    a given argument is a valid integer or not, which is equally important because
    it allows us to process inappropriate arguments differently.
  prefs: []
  type: TYPE_NORMAL
- en: The other crucial Go code found in `addCLA.go` is the one that ignores the value
    of the error variable from the `strconv.Atoi()` function using pattern matching.
    The `_` character means "match everything" in Go pattern matching terms, but do
    not save it in any variable.
  prefs: []
  type: TYPE_NORMAL
- en: Go has support for four different sizes of signed and unsigned integers, named
    int8, int16, int32, int64, uint8, uint16, uint32, and uint64, respectively. However,
    Go also has `int` and `uint`, which are the most efficient signed and unsigned
    integers for your current platform. Therefore, when in doubt, use either `int`
    or `uint`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `addCLA.go` with the right kind of command-line arguments creates
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The good thing is that `addCLA.go` does not crash if it gets no arguments,
    without you taking care of it. Nevertheless, it would be more interesting to see
    how the program handles erroneous input because you can never assume that you
    are going to get the right type of input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, if the program gets the wrong type of input, it does not crash
    and does not include the erroneous input in its calculations. What is a major
    issue here is that `addCLA.go` does not print any warning message to let the user
    know that some of their input was ignored. This kind of dangerous code creates
    unstable executables that might generate security issues when given the wrong
    kind of input. So, the general advice here is that you should never expect or
    rely on the Go compiler, or any other compiler or program, to take care of such
    things because this is your job.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 3](96c36f62-d505-408c-add5-af84cf25454a.xhtml), *Advanced Go Features*,
    will talk about error handling in Go in more detail and will present a better
    and safer version of the previous program. For now, we should all be happy that
    we can prove that our program does not crash with any kind of input.'
  prefs: []
  type: TYPE_NORMAL
- en: Although this is not a perfect situation, it is not that bad if you know that
    your program does not work as expected for some given kinds of input. The bad
    thing is when the developer has no idea that there exist certain kinds of input
    that can make a program fail, because you cannot correct what you do not believe
    or recognize is wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Although processing command-line arguments looks easy, it might get pretty complex
    if your command-line utility supports a large number of options and parameters.
    [Chapter 5](543026ff-1c69-45b5-ae56-68b1fe41bc83.xhtml), *Files and Directories*,
    will talk more about processing command-line options, arguments, and parameters
    using the `flag` standard Go package.
  prefs: []
  type: TYPE_NORMAL
- en: User input and output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to the Unix philosophy, when a program finishes its job successfully,
    it generates no output. However, for a number of reasons, not all programs finish
    successfully and they need to inform the user about their issues by printing appropriate
    messages. Additionally, some system tools need to get input from the user in order
    to decide how to handle a situation that might come up.
  prefs: []
  type: TYPE_NORMAL
- en: The hero of Go user input and output is the `fmt` package, and this section
    is going to show you how to perform these two tasks by starting with the simplest
    one.
  prefs: []
  type: TYPE_NORMAL
- en: The best place to learn more about the `fmt` package is its documentation page,
    which can be found at [https://golang.org/pkg/fmt/](https://golang.org/pkg/fmt/).
  prefs: []
  type: TYPE_NORMAL
- en: Getting user input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apart from using command-line arguments to get user input, which is the preferred
    approach in systems programming, there exist ways to ask the user for input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two such examples are the `rm(1)` and `mv(1)` commands when used with the `-i`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: So, this section will show you how to mimic the previous behavior in your Go
    code by making your program understand the `-i` parameter without actually implementing
    the functionality of either `rm(1)` or `mv(1)`.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest function for getting user input is called `fmt.Scanln()` and reads
    an entire line. Other functions for getting user input include `fmt.Scan()`, `fmt.Scanf()`,
    `fmt.Sscanf()`, `fmt.Sscanln()`, and `fmt.Sscan()`.
  prefs: []
  type: TYPE_NORMAL
- en: However, there exists a more advanced way to get input from the user in Go;
    it involves the use of the `bufio` package. Nevertheless, using the `bufio` package
    to get a simple response from a user is a bit of an overkill.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Go code of `parameter.go` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The presented code is not particularly clever. It just visits all command-line
    arguments using a `for` loop and checks whether the current argument is equal
    to the `-i` string. Once it finds a match with the help of the `strings.Compare()`
    function, it changes the value of the `minusI` variable from false to true. Then,
    as it does not need to look any further, it exits the `for` loop using a `break`
    statement. In case the `-i` parameter is given, the block with the `if` statement
    asks the user to enter `y` or `n` using the `fmt.Scanln()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `fmt.Scanln()` function uses a pointer to the `answer` variable.
    Since Go passes its variables by value, we have to use a pointer reference here
    in order to save the user input to the `answer` variable. Generally speaking,
    functions that read data from the user tend to work this way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `parameter.go` creates the following kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Printing output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest way to print something in Go is using the `fmt.Println()` and `fmt.Printf()`
    functions. The `fmt.Printf()` function has many similarities with the C `printf(3)`
    function. You can also use the `fmt.Print()` function instead of `fmt.Println()`.
  prefs: []
  type: TYPE_NORMAL
- en: The main difference between `fmt.Print()` and `fmt.Println()` is that the latter
    automatically prints a newline character each time you call it. The biggest difference
    between `fmt.Println()` and `fmt.Printf()` is that the latter requires a format
    specifier for everything it will print, just like the C `printf(3)` function.
    This means that you have better control over what you are doing, but you have
    to write more code. Go calls these specifiers **verbs**, and you can find out
    more about supported verbs at [https://golang.org/pkg/fmt/](https://golang.org/pkg/fmt/).
  prefs: []
  type: TYPE_NORMAL
- en: Go functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions are an important element of every programming language because they
    allow you to break big programs into smaller and more manageable parts, but they
    must be as independent of each other as possible and must do one job and only
    one job. So, if you find yourself writing functions that do multiple things, you
    may want to consider writing multiple functions instead. However, Go will not
    refuse to compile functions that are long, complicated, or do multiple things.
  prefs: []
  type: TYPE_NORMAL
- en: A safe indication that you need to create a new function is when you find yourself
    using the same Go code multiple times in your program. Similarly, a safe indication
    that you need to put some of your functions in a module is when you find yourself
    using the same functions all the time in most of your programs.
  prefs: []
  type: TYPE_NORMAL
- en: The single most popular Go function is `main()`, which can be found in every
    autonomous Go program. If you look at the definition of the `main()` function,
    you'll soon realize that function declarations in Go start with the `func` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, you must try to write functions that are less than 20-30
    lines of Go code. A good side effect of having smaller functions is that they
    can be optimized more easily because you can clearly find out where the bottleneck
    is.
  prefs: []
  type: TYPE_NORMAL
- en: Naming the return values of a Go function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike C, Go allows you to name the return values of a Go function. Additionally,
    when such a function has a return statement without any arguments, the function
    automatically returns the current value of each named return value. Note that
    such functions return their values in the order they were declared in the definition
    of the function.
  prefs: []
  type: TYPE_NORMAL
- en: Naming return values is a very handy Go feature that can save you from various
    types of bugs, so use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'My personal advice is this: name the return values of your functions unless
    there is a very good reason not to do so.'
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Anonymous functions can be defined in line, without the need for a name, and
    they are usually used for implementing things that require a small amount of code.
    In Go, a function can return an anonymous function or take an anonymous function
    as one of its arguments. Additionally, anonymous functions can be attached to
    Go variables.
  prefs: []
  type: TYPE_NORMAL
- en: It is considered a good practice for anonymous functions to have a small implementation
    and local usage. If an anonymous function does not have local utilization, then
    you might need to consider making it a regular function.
  prefs: []
  type: TYPE_NORMAL
- en: When an anonymous function is suitable for a job, then it is extremely convenient
    and makes your life easier; just do not use too many anonymous functions in your
    programs without a good reason.
  prefs: []
  type: TYPE_NORMAL
- en: Illustrating Go functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This subsection will present examples of the previous types of functions using
    the Go code of the `functions.go` program. The first part of the program contains
    the expected preamble and the implementation of the `unnamedMinMax()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `unnamedMinMax()` function is a regular function that gets two integer numbers
    as input, named `x` and `y`, respectively. It returns two integer numbers as output
    using a `return` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next part of `functions.go` defines another function but this time with
    named returned values, which are called `min` and `max`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The next function is an improved version of `minMax()` because you do not have
    to explicitly define the return variables of the return statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: However, you can easily discover which values will be returned by looking at
    the definition of the `namedMinMax()` function. The `namedMinMax()` function will
    return the current values of `min` and `max`, in that order.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next function shows how to sort two integers without having to use a temporary
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The previous code also shows how handy it is that Go functions can return more
    than one value. The last part of `functions.go` contains the `main()` function;
    this could be explained in two parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part is to do with anonymous functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you define two anonymous functions: the first one calculates the square
    of the given integer whereas the second doubles the given integer number. What
    is important here is that both of them are assigned to the same variable, which
    is a totally wrong and is a dangerous practice. Therefore, improper use of anonymous
    functions can create nasty bugs, so take extra care and do not assign the same
    variable to different anonymous functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that even if a function is assigned to a variable, it is still considered
    an anonymous function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of `main()` uses some of the defined functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: What is interesting here is that you can get the two returned values of the
    `namedMinMax()` function using two variables, all in one statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `functions.go` generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The next section shows more examples of anonymous functions combined with the
    `defer` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: The defer keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `defer` keyword defers the execution of a function until the surrounding
    function returns, and is widely used in file I/O operations. This is because it
    saves you from having to remember when to close an open file.
  prefs: []
  type: TYPE_NORMAL
- en: The file with the Go code that illustrates the use of `defer` is called `defer.go`
    and has four main parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part is the expected preamble as well as the definition of the `a1()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, the `defer` keyword is used with a simple `fmt.Print()`
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part is the definition of the `a2()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: After the `defer` keyword, there is an anonymous function that is not attached
    to a variable, which means that after the termination of the `for` loop, the anonymous
    function will automatically disappear. The presented anonymous function takes
    no arguments but uses the `i` local variable in the `fmt.Print()` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next part defines the `a3()` function and has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This time, the anonymous function requires an integer parameter that is named
    `n` and takes its value from the `i` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `defer.go` is the implementation of the `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing `defer.go` will print the following, which might surprise you at
    first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: So, now it is time to explain the output of `defer.go` by examining the way
    `a1()`, `a2()`, and `a3()` execute their code. The first line of output verifies
    that deferred functions are executed in **Last In First Out** (**LIFO**) order
    after the return of the surrounding function. The `for` loop in `a1()` defers
    a single function call that uses the current value of the `i` variable. As a result,
    all numbers are printed in reverse order because the last used value of `i` is
    `2`. The `a2()` function is a tricky one because due to `defer`, the function
    body is evaluated after the `for` loop ends while it is still referencing the
    local `i` variable, which at that time was equal to `3` for all evaluations of
    the body. As a result, `a2()` prints the number `3` three times. Put simply, you
    have three function calls that use the last value of a variable because this is
    what is passed to the function. However, this is not the case with the `a3()`
    function because the current value of `i` is passed as an argument to the deferred
    function, due to the `(i)` code at the end of the `a3()` function definition.
    So, each time the deferred function is executed, it has a different `i` value
    to process.
  prefs: []
  type: TYPE_NORMAL
- en: As using `defer` can be complicated, you should write your own examples and
    try to guess their output before executing the actual Go code to make sure that
    your program behaves as expected. Try to be able to tell when the function arguments
    are evaluated and when the function body is actually executed.
  prefs: []
  type: TYPE_NORMAL
- en: You will see the `defer` keyword in action again in [Chapter 6](7debeee1-e431-4d30-a868-6cc59c73adb8.xhtml),
    *File Input and Output*.
  prefs: []
  type: TYPE_NORMAL
- en: Using pointer variables in functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Pointers** are memory addresses that offer improved speed in exchange for
    difficult-to-debug code and nasty bugs. C programmers know more about this. The
    use of pointer variables in Go functions is illustrated inside the `pointers.go`
    file, which can be divided into two main parts. The first part contains the definition
    of two functions and one new structure named `complex`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part illustrates the use of the previous definitions in the `main()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As the `withPointer()` function uses a pointer variable, you do not need to
    return any values because any changes to the variable you pass to the function
    are automatically stored in the passed variable. Note that you need to put `&`
    in front of the variable name to pass it as a pointer instead of as a value. The
    `complex` structure has two members, named `x` and `y`, which are both integer
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the `newComplex()` function returns a pointer to a `complex`
    structure, previously defined in `pointers.go`, which needs to be stored in a
    variable. In order to print the contents of a complex variable returned by the
    `newComplex()` function, you will need to put a `*` character in front of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `pointers.go` generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: I do not recommend the use of pointers to amateur programmers outside of what
    is required by the libraries you use because they might cause problems. However,
    as you get more experienced, you might want to experiment with pointers and decide
    whether you want to use them or not depending on the problem you are trying to
    solve.
  prefs: []
  type: TYPE_NORMAL
- en: Go data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go comes with many handy **data structures** that can help you store your own
    data, including arrays, slices, and maps. The most important task that you should
    be able to perform on any data structure is accessing all of its elements in some
    way. The second important task is having direct access to a specific element once
    you know its index or key. The last two equally important tasks are inserting
    elements and deleting elements from data structures. Once you know how to perform
    these four tasks, you will have complete control over the data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Arrays are the most popular data structure due to their speed and are supported
    by almost all programming languages. You can declare an array in Go as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Should you wish to declare an array with two or three dimensions, you can use
    the following notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The index of the first element of each dimension of an array is 0, the index
    of the second element of each dimension is 1, and so on. Accessing, assigning,
    or printing a single element from one of the previous three arrays can also be
    done easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The most common way to access all the elements of an array is by finding its
    size using the `len()` function and then using a `for` loop. However, there exist
    cooler ways to visit all the elements of an array that involve the use of the
    `range` keyword inside a `for` loop and allow you to bypass the use of the `len()`
    function, which is pretty handy when you have to deal with arrays with two or
    more dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the code in this subsection is saved as `arrays.go`, and you should
    watch it on your own. Running `arrays.go` creates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s try to break things by trying to access some strange array elements,
    such as an element with an index number that does not exist or an element with
    a negative index number, using the following Go program that is named `breakMe.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing `breakMe.go` will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Go considers compiler issues that can be detected as compiler errors because
    this helps the development workflow, which is the reason for printing all the
    out of bounds array access errors of `breakMe.go`.
  prefs: []
  type: TYPE_NORMAL
- en: Trying to break things is an extremely educational process that you should attempt
    all the time. Put simply, knowing when something does not work is equally useful
    to knowing when it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite their simplicity, Go arrays have many and severe shortcomings:'
  prefs: []
  type: TYPE_NORMAL
- en: First, once you define an array, you cannot change its size, which means that
    Go arrays are not dynamic. Put simply, if you want to include an additional element
    to an existing array that has no space, you will need to create a bigger array
    and copy all the elements from the old array to the new one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, when you pass an array to a function, you actually pass a copy of the
    array, which means that any changes you make to an array inside a function will
    be lost after the function finishes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Last, passing a large array to a function can be pretty slow, mostly because
    Go has to create a second copy of the array. The solution to all these problems
    is to use slices instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You'll not find the concept of **slice** in many programming languages, despite
    the fact that it is both smart and handy. A slice has many similarities with an
    array, and it allows you to overcome the shortcomings of an array.
  prefs: []
  type: TYPE_NORMAL
- en: Slices have a capacity and length property, which are not always the same. The
    length of a slice is the same as the length of an array with the same number of
    elements and can be found using the `len()` function. The capacity of a slice
    is the current room that has been allocated for this particular slice and can
    be found with the `cap()` function. As slices are dynamic in size, if a slice
    runs out of room, Go automatically doubles its current length to make room for
    more elements.
  prefs: []
  type: TYPE_NORMAL
- en: As slices are passed by reference to functions, any modifications you make to
    a slice inside a function will not be lost after the function ends. Additionally,
    passing a big slice to a function is significantly faster than passing the same
    array because Go will not have to make a copy of the slice; it will just pass
    the memory address of the slice variable.
  prefs: []
  type: TYPE_NORMAL
- en: The code of this subsection is saved in `slices.go`, and it can be separated
    into three main parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part is the preamble as well as the definition of two functions that
    get `slice` as input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note that when you use `range` over a slice, you get a pair of values in its
    iteration. The first one is the index number and the second one is the value of
    the element. When you are only interested in the stored element, you can ignore
    the index number as it happens with the `printSlice()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `change()` function just changes the fourth element of the input slice,
    whereas `printSlice()` is a utility function that prints the contents of its slice
    input variable. Here, you can also see the use of the `fmt.Printf()` function
    for printing an integer number.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part creates a new slice named `aSlice` and makes a change to it
    with the help of the `change()` function you saw in the first part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Although the way you define a populated slice has some similarities with the
    way you define an array, the biggest difference is that you do not have to declare
    the number of elements your slice will have.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part illustrates the capacity property of a Go slice as well as the
    `make()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `make()` function automatically initializes the elements of a slice to the
    zero value for that type, which can be verified by the output of the `printSlice`
    (`anotherSlice`) statement. Note that you need to specify the number of elements
    of a slice when you create it with the `make()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `slices.go` generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the third line of the output, the capacity and the length
    of a slice were the same at the time of its definition. However, after adding
    a new element to the slice using `append()`, its length goes from `6` to `7` but
    its capacity doubles and goes from `6` to `12`. The main advantage you get from
    doubling the capacity of a slice is better performance because Go will not have
    to allocate memory space all the time.
  prefs: []
  type: TYPE_NORMAL
- en: You can create a slice from the elements of an existing array, and you can copy
    an existing slice to another one using the `copy()` function. Both operations
    have some tricky points, and you should experiment with them.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 6](7debeee1-e431-4d30-a868-6cc59c73adb8.xhtml), *File Input and Output*,
    will talk about a special type of slice, named byte slice, that can be used in
    file I/O operations.'
  prefs: []
  type: TYPE_NORMAL
- en: Maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Map data type in Go is equivalent to the well-known hash table found in
    other programming languages. The main advantage of maps is that they can use almost
    any data type as their index, which in this case is called a **key**. For a data
    type to be used as a key, it must be comparable.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s take a look at an example Go program, named `maps.go`, which we
    will use for illustrative purposes. The first part of `maps.go` contains the preamble
    Go code you would expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can define a new empty map that has strings as its keys and integer
    numbers as values, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Post this, you can add new key and value pairs to the `aMap` map, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can get the value of an existing key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the single most important operation you can perform on an existing
    `map` is illustrated in the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: What the aforementioned Go code does is use the error-handling capabilities
    of Go in order to verify that a key of a map already exists before you try to
    get its value. This is the proper and safe way of trying to get the value of a
    `map` key because asking for a value for which there is no `key` will result in
    returning zero. This gives you no way of determining whether the result was zero
    because the `key` you requested was not there or because the element with the
    corresponding key actually had the zero value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Go code shows how you can iterate over all the keys of an existing
    map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have no interest in visiting the keys and the values of a map and you
    just want to count its pairs, then you can use the next, much simpler variation
    of the previous `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The last part of the `main()` function contains the following Go code that
    illustrates an alternative way of defining and initializing a map at the same
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'However, apart from the different initialization, all the other `map` operations
    work exactly the same. Executing `maps.go` generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Maps are a very handy data structure, and there is a big chance that you are
    going to need them when developing systems software.
  prefs: []
  type: TYPE_NORMAL
- en: Converting an array into a map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This subsection will perform a practical operation, which is converting an
    array into a map without knowing the size of `array` in advance. The Go code of
    `array2map.go` can be divided into three main parts. The first part is the standard
    Go code that includes the required packages and the beginning of the `main()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part, which implements the core functionality, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: You first define the `array` variable and the `map` variable you will use. The
    `for` loop is used for visiting all the array elements and adding them to `map`.
    The `strconv.Itoa()` function converts the index number of `array` into a string.
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind that if you know that all the keys of a map will be consecutive
    positive integer numbers, you might consider using an array or a slice instead
    of a map. In fact, even if the keys are not consecutive, arrays and slices are
    cheaper data structures than maps, so you might end up with a sparse matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part, which is just for printing the contents of the generated map,
    uses the expected range form of the `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: As you can easily guess, developing the inverse operation is not always possible
    because `map` is a richer data structure than `array`. However, the price you
    pay for a more powerful data structure is time because array operations are usually
    faster.
  prefs: []
  type: TYPE_NORMAL
- en: Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although arrays, slices, and maps are all very useful, they cannot hold multiple
    values in the same place. When you need to group various types of variables and
    create a new handy type, you can use a structure--the various elements of a structure
    are called fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code of this subsection is saved as `dataStructures.go` and can be divided
    into three parts. The first part contains the preamble and the definition of a
    new structure named `message`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The message structure has three fields, named `X`, `Y`, and `Label`. Note that
    structures are usually defined at the beginning of a program and outside the `main()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part uses the message structure to define two new message variables,
    named `p1` and `p2`. Then, it uses reflection to get information about the `p1`
    and `p2` variables of the message structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The last part shows how to print all the fields of a structure without knowing
    their names using a `for` loop and the `Type()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `dataStructures.go` will generate the following kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'If the name of a field of a `struct` definition begins with a lowercase letter
    (`x` instead of `X`), the previous program will fail with the following error
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This happens because lowercase fields do not get exported; therefore, they cannot
    be used by the `reflect.Value.Interface()` method. You will learn more about `reflection`
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interfaces are an advanced Go feature, which means that you might not want to
    use them in your programs if you are not feeling very comfortable with Go. However,
    interfaces can be very practical when developing big Go programs, which is the
    main reason for talking about interfaces in this book.
  prefs: []
  type: TYPE_NORMAL
- en: But first, I will talk about methods, which are functions with a special receiver
    argument. You declare methods as ordinary functions with an additional parameter
    that appears just before the function name. This particular parameter connects
    the function to the type of that extra parameter. As a result, that parameter
    is called the receiver of the method. You will see such functions in a while.
  prefs: []
  type: TYPE_NORMAL
- en: Put simply, interfaces are abstract types that define a set of functions that
    need to be implemented so that a type can be considered an instance of the interface.
    When this happens, we say that the type satisfies this interface. So, an interface
    is two things--a set of methods and a type--and it is used for defining the behavior
    of a type.
  prefs: []
  type: TYPE_NORMAL
- en: Let's describe the main advantage of interfaces with an example. Imagine that
    you have a type named ATYPE and an interface for the ATYPE type. Any function
    that accepts an ATYPE variable can accept any other variable that implements the
    interface of ATYPE.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Go code of `interfaces.go` can be divided into three parts. The first part
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: In this part, you define an interface called coordinates and a new structure
    called `point2D`. The interface has two functions, named `xaxis()` and `yaxis()`.
    The definition of the coordinates interface says that if you want to convert to
    the coordinates interface, you will have to implement these two functions.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to notice that the interface does not state any other specific
    types apart from the interface itself. On the other hand, the two functions of
    the interface should state the types of their return values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: In the second part, you first implement the two functions of the coordinates
    interface for the `point2D` type. Then you develop a function named `findCoordinates()`
    that accepts a variable that implements the coordinates interface. The `findCoordinates()`
    function just prints the two coordinates of a point using a simple `fmt.Println()`
    function call. Then, you define a new type named coordinate that is used for points
    that belong to the *x*-axis. Last, you implement the coordinates interface for
    the coordinate type.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing the code for `interfaces.go`, I believed that the `coordinates`
    and `coordinate` names were fine. After writing the previous paragraph, I realized
    that the `coordinate` type could have been renamed to `xpoint` for better readability.
    I left the names `coordinates` and `coordinate` to point out that everybody makes
    mistakes and that the variable and type names you are using must be chosen wisely.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: In this part, you first create a `point2D` variable and print its coordinates
    using the `findCoordinates()` function, then you create a coordinate variable
    named `y` that holds a single coordinate value. Lastly, you print the `y` variable
    using the same `findCoordinates()` function used for printing a `point2D` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Although Go is not an object-oriented programming language, I will use some
    object-oriented terminology here. So, in object-oriented terminology, this means
    that both `point2D` and `coordinate` types are coordinate objects. However, none
    of them are *only* a `coordinate` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `interfaces.go` creates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: I believe that Go interfaces are not necessary when developing systems software,
    but they are a handy Go feature that can make the development of a systems application
    more readable and simpler, so do not hesitate to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Creating random numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a practical programming example, this section will talk about creating random
    numbers in Go. Random numbers have many uses, including the generation of good
    passwords as well as the creation of files with random data that can be used for
    testing other applications. However, bear in mind that usually programming languages
    generate pseudorandom numbers that approximate the properties of a true random
    number generator.
  prefs: []
  type: TYPE_NORMAL
- en: Go uses the `math/rand` package for generating random numbers and needs a seed
    to start producing random numbers. The seed is used for initializing the entire
    process and is extremely important because if you always start with the same seed,
    you will always get the same sequence of random numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `random.go` program has three main parts. The first part is the preamble
    of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part is the definition of the `random()` function that returns a
    random number each time it is called, using the `rand.Intn()` Go function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The two parameters of the `random()` function define the lower and upper limits
    of the generated random number. The last part of `random.go` is the implementation
    of the `main()` function that is mainly used for calling the `random()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: A big part of the `main()` function involves dealing with the reading of command-line
    arguments as integer numbers and printing a descriptive error message in case
    you did not get the correct number of command-line arguments. This is the standard
    practice that we will follow in this book. The `random.go` program uses the Unix
    epoch time as the seed for the random number generator by calling the `time.Now().Unix()`
    function. The important thing to remember is that you do not have to call `rand.Seed()`
    multiple times. Lastly, `random.go` does not examine the error variable returned
    by `strconv.Atoi()` to save book space, not because it is not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `random.go` generates the following kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Should you wish to generate more secure random numbers in Go, you should use
    the `crypto/rand` package, which implements a cryptographically secure pseudorandom
    number generator. You can find more information about the `crypto/rand` package
    by visiting its documentation page at [https://golang.org/pkg/crypto/rand/](https://golang.org/pkg/crypto/rand/).
  prefs: []
  type: TYPE_NORMAL
- en: If you are really into random numbers, then the definitive reference to the
    theory of random numbers is the second volume of *The Art of Computer Programming*
    by Donald Knuth.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Browse the Go documentation site: [https://golang.org/doc/](https://golang.org/doc/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a Go program that keeps reading integers until you give the number 0 as
    input, then it prints the minimum and maximum integer in the input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the same Go program as before, but this time, you will get your input
    using command-line arguments. Which version do you think is better? Why?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a Go program that supports two command-line options (`-i` and `-k`) in
    random order using if statements. Now change your program to support three command-line
    arguments. As you will see, the complexity of the latter program is just too much
    to handle using if statements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the indices of a map were natural numbers, are there any cases that it would
    be wise and efficient to use a map instead of an array?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to put the functionality of `array2map.go` into a separate function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to develop your own random number generator in Go that will still use the
    current time as a seed but not the `math/rand` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Learn how to create a slice from an existing array. What happens when you make
    changes to the slice?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `copy()` function to make a copy of an existing slice. What happens
    when the destination slice is smaller than the source slice? What happens when
    the destination slice is bigger than the source slice?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to write an interface for supporting points in 3D space. Then, use this
    interface to support points that reside on the x-axis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You learned many things in this chapter, including getting user input and processing
    command-line arguments. You familiarized yourself with the basic Go structures
    and you created a Go program that generates random numbers. Try to do the offered
    exercises and do not get discouraged if you fail in some of them.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will talk about many advanced Go features, including error
    handling, pattern matching, regular expressions, reflection, unsafe code, calling
    C code from Go, and the `strace(1)` command-line utility. I will compare Go with
    other programming languages and give you practical advice in order to avoid some
    common Go pitfalls.
  prefs: []
  type: TYPE_NORMAL
