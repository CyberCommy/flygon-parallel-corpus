- en: Appendix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1\. Fundamentals of Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Activity 1.01: Building a Sudoku Solver'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Solution**'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define the `Solver` class to store its input puzzle in its `cells`
    attribute, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The helper method that prints out the puzzle in a nice format can loop through
    the individual cells in the puzzle while inserting the separating characters `''-''`
    and `''|''` at the appropriate places:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `get_presence()` method can maintain three separate lists of Boolean variables
    for the presence of numbers between 1 and 9 in individual rows, columns, and quadrants.
    These Boolean variables should all be initialized as `False` at the beginning,
    but we can loop through all the cells in the input and change their values to
    `True` as appropriate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It can be tricky to index the quadrants. The preceding code uses the formula
    `row_id // 3 * 3 + col_id // 3`, which effectively results in the count where
    the top-left quadrant is indexed at `0`, the top-center `1`, the top-right `2`,
    the middle-left `3`, ..., the bottom-center `7`, and the bottom-right `8`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `get_possible_values()` method can call `get_presence()` and generate the
    corresponding lists of possible values for the remaining empty cells:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `simple_update()` method can be implemented in a fairly straightforward
    manner, in which we can have a flag variable (called `update_again` here) to indicate
    whether we would need to call the method again before returning:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `recur_solve()` method contains multiple instructional components, but
    the logical flow is simple to implement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we place all of these methods inside the `solve()` method, which calls
    `recur_solve()` on `self.cells`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Print out the returned solution as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'A section of the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code and the final output for this specific section, please
    refer to [https://packt.live/3dWRsnE.](https://packt.live/3dWRsnE )
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2BBKreC.](https://packt.live/2BBKreC
    )
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Python's Main Tools for Statistics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Activity 2.01: Analyzing the Communities and Crime Dataset'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Solution**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the dataset has been downloaded, the libraries can be imported, and pandas
    can be used to read in the dataset in a new Jupyter notebook, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We are also printing out the first five rows of the dataset, which should be
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.21: The first five rows of the dataset'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_02_211.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.21: The first five rows of the dataset'
  prefs: []
  type: TYPE_NORMAL
- en: 'To print out the column names, we can simply iterate through `df.columns` in
    a `for` loop, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The total number of columns in the dataset can be computed using the `len()`
    function in Python:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To replace the special character `''?''` with `np.nan` objects, we can use
    the `replace()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To print out the list of columns in our dataset and their respective numbers
    of missing values, we use a combination of the `isnull().sum()` methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code should produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The numbers of missing values of the two specified columns can be accessed
    and displayed as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You should obtain `0` and `1872` as the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compute and visualize the counts of unique values in `''state''` using a
    bar plot (as well as to adjust the size of the figure), the following code can
    be used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This should produce the following graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.22: Bar graph for state counts'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_02_221.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.22: Bar graph for state counts'
  prefs: []
  type: TYPE_NORMAL
- en: 'To compute and visualize the same information using a pie chart, the following
    code can be used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following visualization will be generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.23: Pie chart for state counts'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_02_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.23: Pie chart for state counts'
  prefs: []
  type: TYPE_NORMAL
- en: 'To compute and visualize the population distribution using a histogram, the
    following code can be used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This should produce the following graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.24: Histogram for population distribution'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_02_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.24: Histogram for population distribution'
  prefs: []
  type: TYPE_NORMAL
- en: 'To compute and visualize the household size distribution using a histogram,
    the following code can be used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This should produce the following graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.25: Histogram for household size distribution'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_02_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.25: Histogram for household size distribution'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2BB5BJT.](https://packt.live/2BB5BJT
    )
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/38nbma9.](https://packt.live/38nbma9
    )
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Python's Statistical Toolbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Activity 3.01: Revisiting the Communities and Crimes Dataset'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Solution**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The libraries can be imported, and pandas can be used to read in the dataset
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Your output should be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.29: The first five rows of the dataset'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_03_29.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.29: The first five rows of the dataset'
  prefs: []
  type: TYPE_NORMAL
- en: 'To replace the special character with the `np.nan` object, we can use the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To compute the actual count for the different age groups, we can simply use
    the expression `df[''population''] * df[''agePct...'']`, which computes the count
    in a vectorized way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we are rounding the final answers to integers using `astype(int)`.
    The first five rows of these newly created columns should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.30: Actual count of different age groups'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_03_30.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.30: Actual count of different age groups'
  prefs: []
  type: TYPE_NORMAL
- en: 'The expression `df.groupby(''state'')` gives us a `GroupBy` object that aggregates
    our dataset into different groups, each corresponding to a unique value in the
    `''state''` column. Then we can call `sum()` on the object and inspect the columns
    in question:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This should print out the count of the different age groups in each state.
    The first five columns of this output should be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.31: Count of different age groups in each state'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_03_31.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.31: Count of different age groups in each state'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `df.describe()` method, you can obtain the following output:![Figure
    3.32: Description of the dataset'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15968_03_32.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.32: Description of the dataset'
  prefs: []
  type: TYPE_NORMAL
- en: 'The boxplots visualizing the count of various crimes can be generated as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This should produce the following graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.33: Boxplots of various crime counts'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_03_33.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.33: Boxplots of various crime counts'
  prefs: []
  type: TYPE_NORMAL
- en: From the graph, we see that non-violent crime is the most common out of the
    five, while arson is the least common.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A heatmap for the correlation matrix that corresponds to the given columns
    can be used to visualize the information that was asked for:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This should produce the following heatmap:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.34: Heatmap for various population features'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_03_34.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.34: Heatmap for various population features'
  prefs: []
  type: TYPE_NORMAL
- en: From the graph, we see that the percentage of the population under the poverty
    level and the percentage of unemployed are highly correlated (`0.77` being the
    correlation coefficient). This is an understandable yet telling insight into how
    various crime-related factors are connected to each other.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3f8taZn.](https://packt.live/3f8taZn
    )
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/3ikxjeF.](https://packt.live/3ikxjeF
    )
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Functions and Algebra with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Activity 4.01: Multi-Variable Break-Even Analysis'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Solution**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let *x* be the number of burgers that the restaurant produces each month and
    *y* be the price of each burger. Then, the monthly revenue will be *xy*, the cost
    will be *6.56x + 1312.13*, and finally, the total profit will be the difference
    between the two: *xy - 6.56x - 1312.13*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To break even, the number of burgers produced, *x*, must be equal to the demand,
    which gives us the equation: *x = 4000/y*. Furthermore, the total profit should
    be zero, which leads to *xy - 6.56x = 1312.13*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Overall, we have the following system of equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.48: System of equations'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_48.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.48: System of equations'
  prefs: []
  type: TYPE_NORMAL
- en: From the first equation, we can solve for *x = 409.73628*. Plugging this into
    the second equation, we can solve for *y = 9.76237691*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To solve this system in Python, we first declare our variables and constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can call the `solve()` function from SymPy on the corresponding list
    of functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This code should produce the following output, which corresponds to the actual
    solution of the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The most challenging point about this function is that if the number of burgers
    produced by the restaurant, *x*, exceeds the demand, *4000/y*, their revenue remains
    at *4000*. However, if the number of burgers is low, then the revenue is *xy*.
    Our function therefore needs to have a condition to check for this logic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code generates the specified lists and the corresponding plot
    when the price of each burger is $9.76:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.49: Break-even graph for a price of $9.76'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_49.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.49: Break-even graph for a price of $9.76'
  prefs: []
  type: TYPE_NORMAL
- en: The intersection of the upside-down V-shaped profit curve and the horizontal
    line at `0` denotes the break-even point in the analysis where the price of each
    burger is fixed at $9.76\. The *x* coordinate of this intersection is somewhat
    above `400`, which roughly corresponds to the break-even solution in *step 3*,
    when *x* is approximately `410` and *y* is approximately 9.76.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code generates the specified lists and the corresponding plot
    when the price of each burger is $9.99:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.50: Break-even graph for a price of $9.99'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_50.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.50: Break-even graph for a price of $9.99'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the two intersections of the profit curve and the horizontal line
    at `0` denote the break-even points in the analysis where the price of each burger
    is fixed at $9.99.
  prefs: []
  type: TYPE_NORMAL
- en: We see that as the number of burgers produced increases, the profit of the restaurant
    grows linearly. However, after this number meets demand and the profit curve peaks,
    the curve starts to decrease linearly. This is when the restaurant over-produces
    and increasing the number of products is no longer beneficial.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code generates the specified lists:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`profits` is a two-dimensional list that is rather large in size, but the first
    few elements in that list should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.51: Two-dimensional list of profits'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_51.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.51: Two-dimensional list of profits'
  prefs: []
  type: TYPE_NORMAL
- en: 'The specified heatmap can then be generated using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.52: Heatmap of profit as a function of production and price'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_52.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.52: Heatmap of profit as a function of production and price'
  prefs: []
  type: TYPE_NORMAL
- en: From the plot, we see that there are specific combinations of *x* and *y* that
    control the behavior of the profit of the restaurant.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when the price of each burger is low (the left region of the map),
    the total profit is significantly lower than 0\. As we move to the right of the
    plot, the brightest region represents the combinations of the two variables that
    will result in the highest profit.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2C6dKWz.](https://packt.live/2C6dKWz
    )
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2NTfEwG.](https://packt.live/2NTfEwG
    )
  prefs: []
  type: TYPE_NORMAL
- en: 5\. More Mathematics with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Activity 5.01: Calculating Your Retirement Plan Using Series'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Solution**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to identify the input variables and note that the problem boils
    down to calculating the *n*-term of a geometric sequence with a common ratio (1
    + interest) and scale factor for the annual salary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`annual_salary` and the percentage, *contrib*, of it is what we contribute
    toward our plan. `current_balance` is the money that we have at year 0 and should
    be added to the total amount. `annual_cap` is the maximum percentage that we can
    contribute; any input value beyond that should be equal to `contrib_cap`. `annual_salary_increase`
    tells us how much we expect our salary to increase by per year. `employer_match`
    gives us the percentage amount the employer contributes to the plan (typically,
    this is between 0.5 and 1). Lastly, the current age, the duration of the plan
    in years, the life expectancy in years, and any other fees that the plan might
    incur are input variables. The `per_month` Boolean variable determines whether
    the output will be printed as a per-year or per-month amount of the return.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the first function, `retirement_n`, to calculate the *n*th term of our
    sequence, which returns the contribution and employer''s match as a comma-separated
    tuple:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The input, as shown here, is the current balance and the annual salary in absolute
    values. We also define the contribution, the contribution cap (that is, the maximum
    value allowed), the increase of the annual salary, the employer match, and the
    rate of the return as relative values (floats between 0 and 1). The annual cap
    is meant to be read as an absolute value too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the function that will sum up the individual amounts for each year and
    calculate the total value of our plan. This shall divide this number by the number
    of years over which the plan is to be used (payback duration) so that the per-year
    return of the plan is returned by the function. As inputs, it should read the
    current age, the duration of the plan, and the life expectancy (the duration of
    the payback is found by subtracting `current_age + plan_years` from `life_expectancy`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The main operation of the preceding function is to set a loop (`while` iteration)
    where the previous function is called and the value of the plan is found at each
    year, *n* (we call it *cn* here for brevity). The result is the sum of the values
    of all the years and is stored in the `result` variable. We slice *cn (cn[0],
    cn[1], cn[2])* since the `retirement_n` function returns a tuple of three quantities.
    We also store the values of the contribution (employee), match (employee), and
    total in three individual lists. These will be returned from this function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, subtract any fees that might need to be included and return the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Check our function and the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Plot your findings. It is always good practice to plot what has been calculated
    since it helps you digest the main message. Also, the functions can be checked
    for potential errors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The plot will be displayed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.26: Retirement plan evolution plot'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_05_26.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.26: Retirement plan evolution plot'
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have created a Python program that calculates the per-month or
    per-year return of a retirement plan based on the current contributions and a
    set of other parameters. We have seen how our knowledge of sequences and series
    can be applied to a real-life scenario to yield results regarding financial and
    social interest.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2YVgQWE.](https://packt.live/2YVgQWE
    )
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/38rOHts.](https://packt.live/38rOHts
    )
  prefs: []
  type: TYPE_NORMAL
- en: 6\. Matrices and Markov Chains with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Activity 6.01: Building a Text Predictor Using a Markov Chain'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Solution**:'
  prefs: []
  type: TYPE_NORMAL
- en: There are a few ways to approach this problem, and it is worth mentioning that
    the approach we will be taking is perhaps the easiest way in which text prediction
    is used. In actual practice, text predictions are far more complicated and have
    many other factors that affect them, which we will briefly cover at the end of
    the activity.
  prefs: []
  type: TYPE_NORMAL
- en: We will be using the transcript of the speech given by Winston Churchill at
    the House of Commons after the soldiers of the Allied forces were rescued from
    Dunkirk during World War II. The speech by itself is worth a read and can be easily
    found online if you are interested.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can download the transcript from [https://packt.live/38rZy6v](https://packt.live/38rZy6v
    ) .
  prefs: []
  type: TYPE_NORMAL
- en: 'This list is stored in a text file named `churchill.txt`. Read through that
    text file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We save this in a string object called `churchill` and then use the `split()`
    function in string to tokenize the text we have and store it in a list called
    `keywords`. The output of this will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we iterate through the list and append the elements to a new list, which
    will store the keyword and the word following it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The list here is already initialized and is a list of tuples that can be converted
    to a list if you so desire, but it is not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, initialize a dictionary, `word_dict`. Once we have the dictionary,
    we iterate through the preceding `keylist` array and add words to the left in
    the preceding tuple as keys in the dictionary, and words on the right as values
    in that dictionary. If the word on the left is already added to the dictionary,
    we simply append the word on the right to the respective value in the dictionary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Having done this, we are now ready to build our predictor. First, we define
    a NumPy string, which takes a random word as a selection from the preceding set
    of keywords, and this will be our first word:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The second part of the preceding code is designed to make sure that we begin
    our sentence with a word that is capitalized. Without understanding in too much
    depth how natural language processing works, it is simple enough if we understand
    that the capitalized word used in the original transcript will pave the way to
    build a more comprehensive statement. We can also specify a specific word here
    instead of choosing it randomly as long as it is present in the corpus of keywords
    that we use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this word to a new list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The first word here is generated randomly from the corpus of words present in
    the text file that we use, using the `random` function.
  prefs: []
  type: TYPE_NORMAL
- en: We will then append other words based on the dictionary we established previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, we will be looking at the word we have freshly appended to `word_chain`,
    beginning with the first word in the list. Use this as the key in the dictionary
    we have created and follow it randomly with the list of values for that particular
    key from the dictionary we created previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of the static variable, `WORDCOUNT`, that we have initialized,
    which specifies how long we want our sentence to be. If you are not in the habit
    of using nested Python functions extensively, simply start solving from the innermost
    function and use the value for the `outer` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will define a string variable called `sentence`, which will be
    our output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Since both the first words chosen here and the values in the dictionary are
    chosen randomly, we will get a different output every time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some of the outputs that we will generate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3gr5uQ5.](https://packt.live/3gr5uQ5
    )
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/31JeD2b.](https://packt.live/31JeD2b
    )
  prefs: []
  type: TYPE_NORMAL
- en: 7\. Doing Basic Statistics with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Activity 7.01: Finding Out Highly Rated Strategy Games'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Solution**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Load the `numpy` and `pandas` libraries as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Load the strategy games dataset (in the `dataset` folder of the chapter):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can download the dataset from the GitHub repository at [https://packt.live/2O1hv2B](https://packt.live/2O1hv2B).
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform all the transformations we did in the first section of the chapter.
    Change the names of the variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the `''id''` column as `index`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Drop the `''url`'' and `''icon_url''` columns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Change `''original_release_date''` and `''current_version_release_date''` to
    `datetime`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Eliminate the rows where `''average_user_rating''` is null from the DataFrame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Keep in the DataFrame only the rows where `''user_rating_count''` is equal
    or greater than `30`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the dimensions of the dataset. You must have a DataFrame with `4311`
    rows and `15` columns. You should get the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Impute the missing values in the `languages` column with the string `EN` to
    indicate that those games are available only in English:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a variable called `free_game` that has the value of `free` if the game
    has a price of zero and `paid` if the price is above zero:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a variable called `multilingual` that has the values of `monolingual`
    if the `language` column has only one language string, and `multilingual` if the
    `language` column has at least two language strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Create one variable that contains the four combinations from the two variables
    created in the previous step (`free-monolingual`, `free-multilingual`, `paid-monolingual`,
    and `paid-multilingual`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Calculate how many observations we have of each type in the `price_language`
    variable. You should get the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `groupby` method on the `games` DataFrame, group by the newly created
    variable, then select the `average_user_rating` variables and calculate the descriptive
    statistics:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.35: Summary statistics grouped by the price_language categories'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_07_35.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.35: Summary statistics grouped by the price_language categories'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2VBGtJZ.](https://packt.live/2VBGtJZ
    )
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2BwtJNK.](https://packt.live/2BwtJNK
    )
  prefs: []
  type: TYPE_NORMAL
- en: 8\. Foundational Probability Concepts and Their Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Activity 8.01: Using the Normal Distribution in Finance'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Solution**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using pandas, read the CSV file named `MSFT.csv` from the `data` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Optionally, rename the columns so they are easy to work with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Transform the `date` column into a proper `datetime` column:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the `date` column as the index of the DataFrame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'In finance, the daily returns of a stock are defined as the percentage change
    of the daily closing price. Create the `returns` column in the MSFT DataFrame
    by calculating the percent change of the `adj close` column. Use the `pct_change`
    series pandas method to do so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Restrict the analysis period to the dates between `2014-01-01` and `2018-12-31`
    (inclusive):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Use a histogram to visualize the distribution of the returns column. Use 40
    bins to do so. Does it look like a normal distribution?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.24: Histogram of returns of the MSFT stock'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_08_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.24: Histogram of returns of the MSFT stock'
  prefs: []
  type: TYPE_NORMAL
- en: 'Calculate the descriptive statistics of the `returns` column:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a random variable named `R_rv` that will represent *The daily returns
    of the MSFT stock*. Use the mean and standard deviation of the return column as
    the parameters for this distribution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Plot the distribution of `R_rv` and the histogram of the actual data. Use the
    `plt.hist()` function with the `density=True` parameter so both the real data
    and the theoretical distribution appear in the same scale:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.25: Histogram of returns of the MSFT stock'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_08_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.25: Histogram of returns of the MSFT stock'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2Zw18Ah](https://packt.live/2Zw18Ah).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/31EmOg9.](https://packt.live/31EmOg9
    )
  prefs: []
  type: TYPE_NORMAL
- en: After looking at the preceding plot, would you say that the normal distribution
    provides an accurate model for the daily returns of Microsoft stock?
  prefs: []
  type: TYPE_NORMAL
- en: '*No. The normal distribution does not provide a very accurate approximation
    regarding the distribution of stocks because the theoretical distribution does
    not completely follow the general shape of the histogram. Although the histogram
    is symmetric with respect to the center and "bell-shaped," we can clearly observe
    that the frequency of the values around zero is much higher than we would expect
    in a normal distribution, which is why we can observe that the bars are well above
    the red curve in the center of the plot. Also, we can observe many extreme values
    (little bars on the left- and right-hand sides) that are unlikely to be present
    in a normal distribution.*'
  prefs: []
  type: TYPE_NORMAL
- en: 9\. Intermediate Statistics with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Activity 9.01: Standardized Test Performance'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Solution**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use the t-confidence interval function that we created earlier
    to calculate a 95% confidence interval. I have recreated it here for completeness:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for this code should be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: It looks like we can say with 95% confidence that the mean score in math for
    a country is between `448.3` and `473.7`, between `449.2` and `472.8` for reading,
    and between `453.9` and `477.0` for science.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to divide the dataset into two different datasets; one where there
    are more than `50` internet users per `100` people, and another where there are
    `50` or fewer internet users per `100` people:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the two datasets, `data1` and `data0`. Notice how `data1` has all
    the countries where we have more than 50 internet users per 100 people, and `data0`
    has 50 or fewer internet users per 100 people:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we are going to compare two samples with likely different variances,
    we are going to use the 2-sample t-test function from the `scipy.stats` package.
    Our significance level is going to be 5%. Since we want to test to see whether
    the internet users'' majority mean is higher, this will be an upper-tailed test.
    This means that we will have to divide our p-value by 2 and only accept the results
    as significant if the test statistic is positive. The following code will run
    our test (note—this is a truncated version of the code; the complete code can
    be found in the GitHub repository):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: For math, reading, and science, the p-value (the second number) is less than
    0.05, and the test statistic (the first number) is positive. This means that for
    all three tests, there is a significant increase in test scores between the majority
    internet users' group over the minority internet users' group.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Results like this always bring up a famous saying in statistics—correlation
    does not imply causation. What this means is that just because we found a significant
    increase in the mean score of the internet majority group, that does not mean
    that the internet caused the increase in the scores. There could be some third
    unknown variable that could be causing the difference, known as a **lurking variable**.
    For example, wealth could be behind the increased scores and internet usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our final task, we will build a linear regression model that describes
    mathematics scores in terms of reading and science scores. First, let''s extract
    the scores from our DataFrame and put the mathematics scores in their own DataFrame
    separate from the reading and science scores. We will use the `LinearRegression`
    function from `sklearn.linear_model` and assign it to its own variable. Then,
    we will fit the model using the smaller DataFrames. Finally, we will print the
    intercept and the coefficients of the regression equation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The coefficients are listed in order, so science is first and then reading.
    That would make your equation as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.23: Formula for mathematics scores in terms of reading and science
    scores'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_09_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.23: Formula for mathematics scores in terms of reading and science
    scores'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will graph the points and the regression and notice that the linear
    model fits the data well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.24: The linear equation seems to fit our data well'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_09_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.24: The linear equation seems to fit our data well'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3is2GE8.](https://packt.live/3is2GE8
    )
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/3dWmz2o.](https://packt.live/3dWmz2o
    )
  prefs: []
  type: TYPE_NORMAL
- en: 10\. Foundational Calculus with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Activity 10.01: Maximum Circle-to-Cone Volume'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Solution**:'
  prefs: []
  type: TYPE_NORMAL
- en: To find the volume of the resulting cone, you need the height of the cone and
    the radius of the base, as in the figure on the right of *Figure 10.33*. First,
    we find the circumference of the base, which is equal to the arc length AB in
    the cut circle on the left. You can set *R* to `1` since all we're interested
    in is the angle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Radian measurements make finding arc lengths easy. It''s just the angle left
    over from the cut, which is *2π - θ* times the radius *R*, which we''re setting
    to `1`. So *θ* is also the circumference of the base of the cone. We can set up
    an equation and solve *r*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.34: Formula to calculate the radius'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_34.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.34: Formula to calculate the radius'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll code that into our program. We''ll need to import a few things from
    Python''s `math` module and define the `r` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The height of the cone can be found using the Pythagorean theorem, since the
    hypotenuse, the slant height of the cone, is the radius of the original circle,
    which we set to `1`:![Figure 10.35: Formula for calculating the hypotenuse'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15968_10_35.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.35: Formula for calculating the hypotenuse'
  prefs: []
  type: TYPE_NORMAL
- en: 'The volume of a cone is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.36: Formula for calculating the volume of a cone'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_10_36.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.36: Formula for calculating the volume of a cone'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we''ll add that to our function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Not so hard, is it? This is all we have to do when using Python. If we were
    doing calculus the old-fashioned way, we'd need an expression for the volume *V*
    in terms of only one variable, *θ*, the angle we cut out. But we have an expression
    for *r* in terms of *θ*, an expression of *h* in terms of *r*, and an expression
    for volume in terms of *h* and *r*. Our program will calculate the volume nearly
    instantaneously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can run that through our `find_max_mins` function. Theta is measured
    in radians, so we''ll check from `0` to `6.28` and print out the degrees version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: So, the optimal angle to cut out of the original circle is 1.15 radians, which
    is around 66 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3iqx6Xj.](https://packt.live/3iqx6Xj
    )
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2VJHIqB.](https://packt.live/2VJHIqB
    )
  prefs: []
  type: TYPE_NORMAL
- en: 11\. More Calculus with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Activity 11.01: Finding the Minimum of a Surface'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Solution**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to import the `random` module to use its `uniform` function, which
    chooses a random decimal value in a given range:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a function that will provide us with partial derivative of `f` with
    respect to `u` at (`v,w`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll need a function for the surface, a range for *x*, a range for
    *y*, and a step size:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll call the `uniform` function of the `random` module to generate an `x`
    and a `y` value for the starting point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'We might as well print out the starting point for testing purposes. If we simply
    say `print(x,y,f(x,y))`, we''d get unnecessarily long decimals, so we''ll round
    everything off to *two* decimal places when we print:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '10,000 steps will probably be enough. We could also make it an infinite loop
    with `while True`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Calculate the partial derivatives at (x,y):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'If the partial derivatives are both really close to 0, that means we''ve descended
    to a minimum value for *z*. It might be a local minimum, but taking more steps
    won''t get us anywhere for this random starting point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a tiny step in the *x* direction, opposite to the value of the partial
    derivative. That way, we''re always stepping down in the *z* value. Do the same
    for *y*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'If *x* or *y* goes outside the range of values we gave them, print `Out of
    Bounds` and break out of the loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, print out the value of the location we ended up at, as well as its
    *z* value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s test this on a surface that we know the minimum value of: a paraboloid
    (a 3D parabola), whose minimum value is 0, at the point (0,0). We''ll test it
    for values between -5 and 5\. Here''s the equation for the surface:![Figure 11.48:
    Equation for the surface of 3D parabola'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15968_11_48.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.48: Equation for the surface of 3D parabola'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, it will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what the surface looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.49: The graph of a paraboloid'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_49.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.49: The graph of a paraboloid'
  prefs: []
  type: TYPE_NORMAL
- en: 'We chose this one because, similar to its 2D equivalent, the minimum point
    is at (0,0) and the minimum *z* value is 0\. Let''s run the `min_of_surface` function
    on the paraboloid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: The random point that was chosen was (-1.55, 2.63), which produced a z-value
    of 9.29\. After its walk, it found *the minimum point at (0,0) with a z-value
    of 0*. If you rerun the code, it'll start at a different random point but will
    end up at (0,0).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''re confident the `min_of_surface` function works, let''s try another
    surface:![Figure 11.50: Equation of another surface'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15968_11_50.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.50: Equation of another surface'
  prefs: []
  type: TYPE_NORMAL
- en: We'll use *-1 < x < 5* and *-1 < y < 5*.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we redefine the surface function and then run the `min_of_surface` function
    for the range specified:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: It looks like the minimum point found from this random point is at (1.1,3.14)
    and that the minimum *z* value is `-1.13`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we rerun the code to make sure everything is correct, sometimes, we get
    an `Out of Bounds` message and sometimes, we get the same result, but significantly
    often, we end up at this point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s put the `min_of_surface` into a loop so we can run a number of trials:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Every time the program produced a `Minimum`, it was one of the two points we''ve
    already seen. What''s going on? Let''s take a look at a graph of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.51: A graph of f(x,y) = 3cos(x) + 5x cos(x) * cos(y)'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_51.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.51: A graph of ![1](image/B15968_11_InlineEquation81.png)'
  prefs: []
  type: TYPE_NORMAL
- en: What the graph shows is that there's more than one minimum. There's a global
    minimum, where the function goes deep into the negative numbers, and a local minimum,
    where any point in that *valley* will simply descend to the point (1.1, 3.14)
    and not be able to get out.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2ApkzCc.](https://packt.live/2ApkzCc
    )
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2Avxt1K.](https://packt.live/2Avxt1K
    )
  prefs: []
  type: TYPE_NORMAL
- en: 12\. Intermediate Calculus with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Activity 12.01: Finding the Velocity and Location of a Particle'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Solution**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the first part, we only have to find where ![2](image/B15968_12_InlineEquation3.png).
    Let''s write functions for *dx/dt* and *dy/dt*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can loop from 0 to 1.5 and see where *dy/dt* goes from positive to
    negative or vice versa:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the important part of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: We can see *dy/dt* is zero somewhere between 1.1 and 1.15 and, again, between
    1.25 and 3 since that's where the output changes its sign.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use binary search to narrow down those ranges. This is identical to
    the previous `bin_search` function except for the `guess =` line. We''re simply
    plugging the average into the `f` function to get our guess:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: The answer is `t = 1.145`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the other range, you have to change `if guess < target` to `if guess >
    target` and call the function this way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: The answer is `t = 1.253`. But that was too easy. The challenge is to find the
    exact *x-y* location of the particle at those times.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need a `position` function that will take tiny steps, like in our ball problem:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we set up our increment variable and set a variable called `elapsed`
    to `0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Our initial values of `vx` and `vy` will be the derivatives at 0, and `x` and
    `y` will also start off at 0:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we start the loop and run it until the elapsed time reaches the desired
    `t`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'We calculate the horizontal and vertical velocity, then increment `x` and `y`
    and the loop counter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll put the times we found into the `position` function to get the
    position of the particle at the times we know the derivative is 0:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'The output gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Those are the positions where the vertical velocity is 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the second part, where we need to find the speed of the particle at *t
    = 1*, the speed will be the hypotenuse of the right triangle formed by the vertical
    speed and the horizontal speed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: The speed of the particle is 4.85 units per second.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3dQjSzy.](https://packt.live/3dQjSzy
    )
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/3f0IBCE](https://packt.live/3f0IBCE).
  prefs: []
  type: TYPE_NORMAL
