- en: Chapter 5. Integrate Less in Your Own Projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it's time to integrate *Less* in your workflow and projects. In this chapter,
    you will learn to migrate your current projects or start a new project from scratch
    using *Less*. The techniques and tools to convert your CSS code to *Less* code
    will be discussed, and finally, you will learn to build and use responsive grids
    with *Less*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Importing CSS into *Less*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Migrating your projects to *Less*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting a project from scratch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Media queries and responsive design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using grids in your projects and designs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While working with *Less* and seeing how it addresses the problems of duplicate
    code and the inability to reuse your CSS, you should have wondered when to start
    using *Less* for your projects. Although this may be the most important question
    of this book, the answer is quite simple. You will have to start *now*! The problems
    with CSS can be some defects in your **design process**. There will never be an
    excuse to not solve the defects as soon as they are detected. If you don't start
    now, you probably never will, and you will end up spending too much time debugging
    your CSS code instead of working on your real design tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Importing CSS into Less
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you already know now, valid CSS is also valid *Less* code. CSS code can be
    imported into *Less*. There are different ways to do this. After importing your
    CSS, you can run the result through the compiler. This offers you an easy way
    to start using *Less* in your current project.
  prefs: []
  type: TYPE_NORMAL
- en: Consider creating a **style guide** before starting to import your CSS code.
    Style guides help you test your code, as described in [Chapter 4](ch04.html "Chapter 4. Avoid
    Reinventing the Wheel"), *Avoid Reinventing the Wheel*. Also, remember that *Less*
    is a **CSS preprocessor**. This means you have to compile your *Less* code into
    CSS before taking it into production. Client-side compiling with `less.js` should
    only be used for test purposes! Only importing your CSS and compiling it back
    into CSS again makes no sense. After importing, you should start improving your
    code. Importing CSS also offers the opportunity to combine the pre-existing CSS
    with newly written *Less* code and allows you to do the conversion to *Less* iteratively
    and gradually.
  prefs: []
  type: TYPE_NORMAL
- en: Using the @import rule
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier, you saw that the `@import` rule in *Less* is used to import *Less*
    files into your project. This rule in *Less* is an extended version of the same
    rule in CSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the examples in the preceding chapters, the `@import` rule was only used
    to import *Less* files. By default, each file is imported once. The complete syntax
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'There are six keywords that can be used with this rule: `reference`, `inline`,
    `less`, `css`, `once`, and `multiple`. The `reference` keyword, for example, `@import
    (reference) "file.less"`, will make mixins and classes from `file.less` available,
    without compiling them into the resulting CSS.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This can easily be shown with an example. You can download all the example
    code of all the chapters of this book from the Packt website ([www.packtpub.com](http://www.packtpub.com)).
    The example layout from the preceding chapters will be used here again. Please
    remember that the main file of this project, `styles.less`, imports the other
    project files. Now you can use this to reuse the navbar. Start by creating a new
    file and write the following code into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'These two lines will compile into the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Please also notice that the preceding result contains the values as defined
    in `variables.less` from the original project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `inline` keyword is used to import code that is not compatible with *Less*.
    Although *Less* accepts standard CSS, comments and hacks won''t get compiled sometimes.
    Use the `inline` keyword to import the CSS as it is into the output. As shown
    in the following code, the `inline` keyword differs quite a bit from the `css`
    keyword. The `less` keyword forces the imported code to be compiled. When using
    `@import (less) "styles.css"`, all code will be compiled as usual. In the meantime,
    the `css` keyword forces `@import` to act as a normal CSS import. The following
    code shows the difference between `inline` and `css`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Imported style sheets (with `@import`) in your compiled CSS code are declared
    before all the other rules. These style sheets can play a role in the **CSS precedence**,
    which is discussed in [Chapter 1](ch01.html "Chapter 1. Improving Web Development
    with Less"), *Improving Web Development with Less*. For this reason, you cannot
    apply advanced techniques such as namespacing, and you should import files that
    are not created using *Less* at the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: 'CSS 2.1 user agents must ignore any `@import` rule that is present inside a
    block or after any nonignored statement, other than `@charset` or `@import` ([http://www.w3.org/TR/CSS21/syndata.html#at-rules](http://www.w3.org/TR/CSS21/syndata.html#at-rules)).
    If you import a file with the same name twice, only one will be compiled by default.
    The same will happen if you use the `once` keyword; on the other hand, if you
    use the `multiple` keyword, the file will be compiled in the output twice. The
    following code will give you an example of multiple output when using the `multiple`
    keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `styles.less` file contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And your *Less* code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will output the following CSS code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Migrating your project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the different import rules, you can start using Less in your project without
    having to change your code. After importing your CSS, you can start defining variables
    and using mixins step by step. Always check the output of your new code before
    you start using it for production.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please remember that style guides can help you manage the migration of your
    project, and also don't forget that you have to compile your *Less* on the server
    side into CSS code before using it in production.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing your files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Try to organize your files in the same way as in the preceding examples. Create
    separate files for your project''s variables and mixins. If your project defined
    a style sheet in `project.css` earlier, your main *Less* file can look, for instance,
    like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You will import your original `project.css` in the preceding code; alternatively,
    you can rename it as `project.less`. Also notice that you will finally compile
    a new CSS file, which will be used in your project. It's possible to use the same
    name for this file; make sure that you do not overwrite your original CSS file.
    Although your new CSS files should apply the same styles, these files are better
    organized and *Less* grantees they contain only valid CSS. The compiler will also
    compress the CSS file.
  prefs: []
  type: TYPE_NORMAL
- en: Converting CSS code to Less code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the process of **migration**, you may prefer to not have to convert your
    code step by step. There are some tools available that can convert CSS code to
    *Less* code. These tools should be used with care. **Lessify** helps you organize
    your CSS code into *Less* code. Lessify puts rules for the same element or class
    together. You can use Lessify by visiting [http://leafo.net/lessphp/lessify/](http://leafo.net/lessphp/lessify/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following CSS code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'After using Lessify, the preceding CSS code compiles into the following *Less*
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You can find another tool called CSS2Less at [http://css2less.cc/](http://css2less.cc/).
    Also, this tool only groups class and element rules. Lessify and Css2Less can
    help you a little when organizing your styles. Neither tool works with **media
    queries**.
  prefs: []
  type: TYPE_NORMAL
- en: From all that you have learned so far, it seems like a good practice to start
    your project by developing your *Less* code. So, start your project by building
    a style guide using *Less*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `project.less` file can look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Integrate the `project.less` file with the client side `less.js` compiler into
    your style guide. After this, start adding your design elements or alternatively,
    add comments in your code.
  prefs: []
  type: TYPE_NORMAL
- en: When you are done with your style guide, you can start building your final HTML
    code. If you have to build a responsive website, you should first determine which
    **screen sizes** you will need. For instance, mobile, tablet, and desktop can
    be a good choice.
  prefs: []
  type: TYPE_NORMAL
- en: To better understand how you can use *Less* in this stage of your process, the
    following two sections describe the role of **CSS media queries** in responsive
    design and teach you how to use **grids**.
  prefs: []
  type: TYPE_NORMAL
- en: Media queries and responsive design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Media queries is a CSS3 module and is a W3C candidate recommendation since June
    2012\. Media queries add the possibility of applying a style sheet to CSS only
    when a media query evaluates as true. A media query evaluates the device's type
    and device's features. The device's types are screen, speech, and print, among
    others, and the features are width, **device-width**, and resolution, among others.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, the screen type and device's width play an important role in responsive
    web design. With the use of media queries, someone can restrict CSS rules to a
    specified screen width and thus change the representation of a website with varying
    screen resolutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical media query will look like the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance, the following media query sets the font color to black when the
    viewport''s width is larger than 767 pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we can see that all the style rules between the accolades
    are only applied if the screen width is 768 pixels or larger. These style rules
    will follow the normal **cascading rules**.
  prefs: []
  type: TYPE_NORMAL
- en: Making your layout fluid
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Until now, your layout has had a fixed width defined by `@basic-width`. A fluid
    design defines its widths as a percentage of the viewport or browser window.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make your layout fluid, define `@basic-width: 900px;` in `less/responsive/project.less`.
    This set value will not define the width of your design any more but will only
    set the `max-width` variable after your changes.'
  prefs: []
  type: TYPE_NORMAL
- en: After this, open `less/responsive/mixinsresponsive.less` in the `.center-content()`
    mixin and change `width:@basic-width;` to `max-width:@basic-width;`.
  prefs: []
  type: TYPE_NORMAL
- en: The header is now fluid, without any further changes. The footer columns are
    also based on `@basic-width`, so you will have to change them too.
  prefs: []
  type: TYPE_NORMAL
- en: 'The width of the footer columns is set by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Please change the width of the footer columns in `less/responsive/footer.less`
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Browser support for the `calc()` function can be checked by visiting [http://caniuse.com/#feat=calc](http://caniuse.com/#feat=calc).
    Also remember the note on `calc()` and the use of **string interpolation** from
    [Chapter 1](ch01.html "Chapter 1. Improving Web Development with Less"), *Improving
    Web Development with Less*. *Less* code is stateless, so these width calculations
    should be done by CSS in the browser. The browser has the real width in pixels
    the moment the CSS has been loaded, so the browser can calculate the column width
    in pixels and render it.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you will have to change `less/contentresponsive.less` and add the media
    queries to it. If the screen width is smaller than 500 pixels, the navigation
    and content should stack in your layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, make `#content` and `#sidebar` fluid by setting their width to `width:
    2 / 3 * 100%;` and `width: 1/ 3 * 100%;`, respectively. Now, the width is fluid
    and you can add the media queries. For `#content`, you should change the code
    into the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code sets the width of `#content` to `100%` if the screen width
    is less than 500 pixels. It also removes the float of the element. You should
    do the same for `#sidebar`.
  prefs: []
  type: TYPE_NORMAL
- en: After these changes for a screen width of 500 pixels, the navigation stacks
    below the content.
  prefs: []
  type: TYPE_NORMAL
- en: 'How to interchange the position of the navigation and content for a screen
    with a screen width less than 500 pixels can be seen at `http://localhost/indexresponsivechange.html`.
    You can accomplish this in two steps. First, interchange the content of `#content`
    and `#sidebar` inside your HTML document. Open `http://localhost/indexresponsivechange.html`
    and compare the source code with `http://localhost/indexresponsive.html`. After
    these changes, the sidebar will show on the left-hand side of the screen. To move
    the sidebar to the right, you should set its float to `right` instead of `left`,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'On a small screen, the layout will now look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making your layout fluid](img/1465OS_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An example of how your layout could look on a mobile phone
  prefs: []
  type: TYPE_NORMAL
- en: Testing your layouts on a mobile phone
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will surely check your responsive layout on your mobile phone too. Make
    sure that you add the following additional line of code in the head of your HTML
    document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code forces the mobile browser to load your website in a viewport
    that is equal to the screen width of your device. By default, mobile browsers
    load websites in a viewport that is larger than the screen size. Doing this lets
    nonmobile websites load as intended on a big screen. After loading the website,
    it's up to the user to scroll and zoom into the results. If your optimized mobile
    layout loads in a viewport with a width larger than 500 pixels, the media queries
    won't work, forcing the viewport to the device's screen dimensions, preventing
    the media query from not being applied. Note that this also means you will have
    to test this example with a mobile phone for which the screen is not wider than
    500 pixels. You can also test your designs on websites such as [http://www.responsinator.com/](http://www.responsinator.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Coding first for mobile
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Nowadays, it''s common to write the styles for mobile devices first and then
    use media queries to alter them to fit bigger screens. Examples of the mobile-first
    principle of coding can be found in `header.less` and `content.less` from the
    files of your example layout. Also open `less/responsive/footer.less` and see
    how the media query adds the float:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This example shows a **mobile first** way of coding. Elements stack by default
    and become horizontal when the screen size grows. Notice that older browsers such
    as Internet Explorer 8 do not support media queries and will always show you the
    stacked version.
  prefs: []
  type: TYPE_NORMAL
- en: Using grids in your designs and work flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preceding media query example did not use a grid. You may be wondering what
    a grid is and why you should use it. **Grid-based layouts** divide your design
    into a collection of equal-sized columns and rows. Content and graphical elements
    can be organized according to this layout. Grids help in creating a logical and
    formal structure for designs. It prevents inconsistencies between the original
    design and the final implementation in HTML as designers and developers work with
    the same grid.
  prefs: []
  type: TYPE_NORMAL
- en: Grids are also helpful in responsive design, because the grid's columns can
    easily be rearranged to fit different screen widths.
  prefs: []
  type: TYPE_NORMAL
- en: In the preliminary chapters of this book you already read about CSS modules
    that defined layout structures. Flex boxes and columns can be used to define CSS
    layouts and grids. Although these layouts are responsive by default or can easily
    be defined as responsive, they are not the common way to define your CSS layouts
    yet. As mentioned earlier, most modern browsers are not ready to support these
    modules. Luckily, there are alternative ways to define a grid with CSS.
  prefs: []
  type: TYPE_NORMAL
- en: The width of the columns of your grid can be defined as a percentage of the
    grid or a fixed width. Fluid grids define their widths as a percentage of the
    viewport. In fluid grids, the column widths vary with the screen width. Fluid
    layouts can rearrange the content to occupy the available screen width, so the
    user has to scroll less. On the other hand, designers have less control over the
    exact representation of the design. For this reason, the majority of responsive
    grids are a hybrid of fluid and fixed grids.
  prefs: []
  type: TYPE_NORMAL
- en: The role of CSS float in grids
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The CSS `float` property is a position property in CSS; the float pushes the
    elements to the left (or right) side of the screen and allows other elements to
    wrap around it. For this reason, CSS `float` plays an important role in most **CSS
    grids**.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example will help you understand how this works. You will create a grid
    with two columns. Start writing the *Less* code for a fixed grid. The example
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the compiled CSS of the preceding code with the following HTML
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You can inspect the result of the preceding code by visiting `http://localhost/grid.html`
    from the downloadable example code of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you have an example of a fixed grid. This grid can be made fluid by changing
    the fixed width using the following *Less* code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this grid, the `.container` class holds the grid. This container contains
    rows (defined) with the `.row` class. You have to define only two extra classes
    because this grid has two columns. The first class, `.col`, defines a single column
    and the second class, `.col2`, defines a double column.
  prefs: []
  type: TYPE_NORMAL
- en: Making your grid responsive
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To make grids responsive, you have to define one or more break points. Break
    points define the screen widths at which a website responds to provide a suitable
    layout; below or above the break point the grid can provide a different layout.
    In the example grid, you can describe two situations. In the first situation,
    below the break point (for instance 768 px), the screens are small. On small screens
    (keep a mobile phone screen in mind), the columns of the grid should stack. Above
    the break point, for tablet and desktop screens, the grid should become horizontal
    and the columns of the grid rows will float next to each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Less*, you can write the first situation for small screens using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: All columns get a width of `100%` of the viewport and none of them float. Starting
    your code with the smallest screens first will generate a "mobile-first" grid.
    Mobile first designs start with a basic design for small screens (and mobile browsers,
    which, not always, have full CSS and JavaScript capabilities) and rearrange and
    add content when the screen size is bigger. You already saw that the grid became
    horizontal for larger screens. Other examples can be the navigation, which has
    got another representation, or an image slider, which is only visible for desktop
    users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a go at making your grid responsive now by adding a media query and defining
    a break point in *Less*, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code compiled into CSS code will look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: It's easy to see that now the `.row` classes only float on screens wider than
    768 pixels. Width columns will stack if the screen size is less than 786 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: The role of the clearfix
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the preceding example, columns became horizontal by applying `float:left`
    to them. The `clearfix()` mixin clears the float of an element after it has been
    rendered without additional markup, so it can be used for the `.row` classes of
    the grid. Using these clearfixes guarantees that your elements only float in their
    own row.
  prefs: []
  type: TYPE_NORMAL
- en: Using a more semantic strategy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, you built a grid using `div` elements and CSS classes.
    Many CSS frameworks, such as **Twitter's Bootstrap** and **ZURB Foundation**,
    construct their grids this way. Critics of the approach claim that it breaks the
    semantic nature of HTML5\. For this reason, they sometimes even compare it with
    the old-school way of defining layouts with HTML tables. HTML5 introduces semantic
    tags, which not only describe the structure but also the meaning of a document.
    For instance, the `header` tag is semantic; everyone knows what a header is and
    browsers know how to display them.
  prefs: []
  type: TYPE_NORMAL
- en: Using mixins instead of classes could help you make your grids more semantic.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of such a mixin is the following *Less* code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code can be compiled using the following *Less* code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The HTML for the preceding CSS code will look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Please note that in the preceding code, `@number` sets the total width to `@number`
    times the width of a column, and the total number of columns in the preceding
    grid will be fixed to `12`.
  prefs: []
  type: TYPE_NORMAL
- en: Building your layouts with grid classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `.make-columns()` mixin can also be used to create your grid classes, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will compile into the following CSS code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the mixins to build the grid classes are called recursively.
    Please recall [Chapter 3](ch03.html "Chapter 3. Nested Rules, Operations, and
    Built-in Functions"), *Nested Rules, Operations, and Built-in Functions*, in which
    you have already seen how to use guards and recursion to construct a loop.
  prefs: []
  type: TYPE_NORMAL
- en: Building nested grids
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you set `@grid-container-width` to `100%` and make your grid fluid, the `.make-columns()`
    mixin can also be used to build nested grids.
  prefs: []
  type: TYPE_NORMAL
- en: Visit `http://localhost/nestedgrid.html` for an example of such a nested grid.
  prefs: []
  type: TYPE_NORMAL
- en: 'In HTML, you could write the following code to create a page with a header,
    content part, sidebar, and footer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The content part will be divided into three equal-sized columns. To archive
    the preceding code, you could write the following code in *Less*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `.make-columns(4);` statement for `div.content-column` will create
    a width of `33.3%` (*4 / 12 * 100%*). The 33.3 percent will be calculated of the
    direct parent. The direct parent of `div.content-column` is `section#content`
    in this example. The `section#content` HTML element itself gets a width of 66.6
    percent (*8 / 12 *100%*) of the viewport.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that if you should use the preceding grid in your project, you should
    separate your code into different files. If you create different files for your
    variables and mixins, your code will be clear and clean.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative grids
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding example, you have seen the grid defined with columns that
    become horizontal when the screen size increases. These grids use CSS float to
    align the columns next to each other. In some situations, mostly for older browsers,
    this may cause some problems in pixel calculation. This problem is sometimes described
    as the "subpixel rounding" problem. Although `box-sizing: border-box;` will fix
    related issues, as described in [Chapter 1](ch01.html "Chapter 1. Improving Web
    Development with Less"), *Improving Web Development with Less*, one can choose
    to use a different grid definition.'
  prefs: []
  type: TYPE_NORMAL
- en: 'CSS isolation provides a solution. CSS isolation is not easy to understand.
    Susy ([http://susydocs.oddbird.net/](http://susydocs.oddbird.net/)) describes
    it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Every float is positioned relative to its container, rather than the float before
    it. It's a bit of a hack, and removes content from the flow, so I don't recommend
    building your entire layout on isolated floats, but it can be very useful as a
    spot-check when rounding errors are really causing you a headache.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: CSS isolation is originally a part of Zen Grids ([http://zengrids.com/](http://zengrids.com/)).
    Zen Grid implementation has been written in SCSS/SASS. It will be relatively easy
    to rewrite this to *Less*; you could try this as an exercise. If you want to try
    this grid system, you can also download some example *Less* code from [https://github.com/bassjobsen/LESS-Zen-Grid](https://github.com/bassjobsen/LESS-Zen-Grid).
  prefs: []
  type: TYPE_NORMAL
- en: Building your project with a responsive grid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding examples, only the grid columns were defined. This should give
    you a good and realistic impression of how grids work and how to use them. A complete
    grid code also defines responsive containers and row classes. Most grids will
    also have so-called gutters between their columns. A gutter (mostly fixed) is
    a space that separates columns. This also means that a width spanning two columns
    include one gutter.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](ch04.html "Chapter 4. Avoid Reinventing the Wheel"), *Avoid Reinventing
    the Wheel*, you have learned to reuse *Less* and prebuilt mixins; you can do the
    same for grids. It won't be necessary to write the complete code yourself. Frameworks
    such as Twitter's Bootstrap, the Golden Grid System ([http://goldengridsystem.com/](http://goldengridsystem.com/)),
    or Less Framework 4 ([http://lessframework.com/](http://lessframework.com/)) will
    provide you with all the *Less* code and mixins you need. Some of these frameworks
    will be discussed in further detail in [Chapter 6](ch06.html "Chapter 6. Bootstrap
    3, WordPress, and Other Applications"), *Bootstrap3, WordPress, and Other Applications*.
  prefs: []
  type: TYPE_NORMAL
- en: The following examples will use Preboot's grid mixins to build your project's
    grid. Finally, you will rebuild the layout example you used earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Using Preboot's grid system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Preboot's grid system enables you to build mobile-first grid layouts with a
    few variables and mixins. As you have seen earlier, you can use Preboot's mixins
    to create a semantic grid or define more general grid classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Preboot defines the grid''s variables, which are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, `@grid-column-padding` defines the width of the
    gutter, as mentioned earlier. The grid columns are coded with the mobile-first
    approach. This means that by default, they stack vertically and float horizontally
    when the viewport's width is equal to or is wider than `@grid-float-breakpoint`.
    Let's not forget, of course, that `@grid-columns` sets the number of grid columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Preboot doesn''t provide a container that holds the rows of the grid. You could
    define this variable yourself to define a maximum width for your grid, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three available mixins for each part of a standard grid system, which
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.make-row()`: This provides a wrapper for the columns to align their content
    via a negative margin and clear the floats'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`grid.make-column(n)`: This is used to generate `n` number of columns as a
    percentage of the available grid columns (set via a variable to `12` by default)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.make-column-offset(n)`: This pushes a column to the right by `n` columns
    via the margin'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now you can use preceding variables and mixins with Preboot to make a visible
    representation of the grid. To begin with, define some grid rows in HTML as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The grid used here contains 12 columns and you can see the number of columns
    in each row should sum up to 12 too.
  prefs: []
  type: TYPE_NORMAL
- en: Now you can write the *Less* code for the preceding grid, which makes use of
    Preboot's mixins and variables. Again, you can split up your code into separated
    files to keep things clear.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `project.less` file contains the following *Less* code which imports all
    required files into the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `variables.less` file contains the following *Less* code that defines the
    project''s variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mixins.less` file contains the mixins for the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note the usage of the `#preboot > .make-column(@number);` namespace here. The
    loop construct should now look familiar to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'And the `grid.less` file contains the *Less* code, which defines the grid''s
    classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will create the CSS classes for your grid. Note that the
    `.container` class will be used to set the maximum width for the grid. It also
    sets a padding, which is needed to correct the gutter around the grid. Each row
    has a padding of half the size of `@grid-column-padding`. Between two rows, the
    `.containter` class makes the gutter equal to `@grid-column-padding`, but now,
    the left- and right-hand side of the grid only has a padding that is half the
    size of `@grid-column-padding`. The `.row` class corrects this by adding a negative
    margin of half the size of `@grid-column-padding`. Finally, the padding of the
    container prevents this negative margin from putting the grid off the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Please also notice the ampersand in the `& { .make-grid-classes(12); }` statement.
    This ampersand (reference) guarantees that the inherited `.make-row` mixin will
    be visible when you need it. The namespaced mixin is not visible in the global
    scope. This problem may be fixed in later versions of *Less*.
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally the `styles.less` file contains the *Less* code which defines the
    styles to make the grid columns visible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiled CSS from `styles.less` will only be used to make the grid columns
    visible. As mentioned in [Chapter 1](ch01.html "Chapter 1. Improving Web Development
    with Less"), *Improving Web Development with Less*, `[class^="col-"]` is a **CSS
    selector** that selects your grid''s columns which have a class starting with
    `col-`, your grid''s columns. Each column gets a height (`height`), background
    color (`background-color`), and border (`border)`. Also, here, the `box-sizing:
    border-box;` statement guarantees that the border width does not influence the
    width of the columns.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the final result by visiting `http://localhost/prebootgridclasses.html`
    on your browser. The result will look like the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Preboot''s grid system](img/1465OS-05-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Representation of Preboot's grid with 12 columns
  prefs: []
  type: TYPE_NORMAL
- en: 'When you see the preceding representation of the grid, you may wonder where
    to find the gutters. As mentioned earlier, the gutter will be constructed with
    a padding of the columns. You can make this visible by adding some content in
    the columns. So, try adding the following code into your HTML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding the preceding code into your HTML file, the result will look like
    the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Preboot''s grid system](img/1465OS-05-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Preboot's grid with 12 columns; the content makes the gutters visible
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding image you will see the gutters of the grid. Please also notice
    that the `.col-6` class only has gutters on each side, so the total content width
    of a `.col-6` will be 6 columns, including five gutters.
  prefs: []
  type: TYPE_NORMAL
- en: Using the grid mixins to build a semantic layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding section, you used Preboot's grid mixins to build grid classes.
    In the final section of this chapter, you will use these mixins to build a semantic
    layout.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the same example used earlier. Before you start, you should undo
    the changes made in the examples with media queries. You don't need these media
    queries here because the grid is responsive by default.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can watch the result by visiting `http://localhost/semanticgrid.html`, and
    you will find the Less files of this example in the `/less/semanticgrid/` folder.
  prefs: []
  type: TYPE_NORMAL
- en: In the current example layout, the container styles are applied to the body
    element. Nowadays, there seems to be no reason to add an extra `div` container
    (wrapper). All modern browsers handle the body as a normal block level element.
    If you prefer to add an extra wrapper for some reason, please do so. A plausible
    reason to do so would be, for instance, adding copyrights under your layout; of
    course, the body doesn't allow you to add something after it. In both cases, this
    container holds the grids' rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `/less/semanticgrid/project.less` and write the following *Less* code
    for the container mentioned into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Please notice that `@basic-width` in `/less/semanticgrid/variables.less` is
    set to 900 pixels to make it clear that the grid is responsive with a break point
    at 768 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this semantic example, you will use a grid with only three columns, defined
    in `/less/semanticgrid/variables.less`, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In `/less/semanticgrid/project.less`, you can see that this example doesn''t
    use a namespace for Preboot. The latest version of *Less*, when this book was
    written, doesn''t support using namespace''s variables in the global scope. In
    further releases, you can expect #`namespace > @variable` to work, but it doesn''t
    work as of now. Using a namespace will make the setting of, for instance, `@grid-columns`
    inside the namespace from the global scope complex or impossible.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, open `/less/semanticgrid/header.less`. In this file, you can remove the
    old `.centercontent` class.
  prefs: []
  type: TYPE_NORMAL
- en: Use the `.make-row()` mixin of Preboot to make the `header` tag act like a row
    and use the `.make-column(3)` mixin call for `h1` inside this header. The `h1`
    element will have a width of three columns now.
  prefs: []
  type: TYPE_NORMAL
- en: Do the same for `/less/semanticgrid/content.less` but use `.make-column(2)`
    for the content and `.make-column(1)` for the sidebar here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, you will see that in the mobile version, the navigation is under the
    content as explained earlier. You can fix this using the same trick you have seen
    earlier in the media queries example. In [Chapter 6](ch06.html "Chapter 6. Bootstrap
    3, WordPress, and Other Applications"), *Bootstrap3, WordPress, and Other Applications*,
    you will learn other ways to solve problems like this. For now, reverse the sidebar
    and the content in your HTML code so that the sidebar is before the content. After
    this, you should give the sidebar a `float: right` call, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Finally, you have to change the footer. Please use `.make-row()` again for the
    `footer` tag. The `div` elements inside the footer, which form the columns, will
    be styled with `.make-column(1)`. After doing this, you will see that the footer's
    columns are shown next to each other without any white space between them. Remember
    that the gutter of the grid is between the content of the columns and not between
    the columns itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix the problem mentioned earlier, apply `background-color`, `border-radius`,
    and `box-shadow` on the `p` element inside the `div` element, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will make the gutter visible, as seen earlier. The gutter
    of the grid adds some white space between the columns. There will also be a gutter
    on the left-hand side of the left column and on the right-hand side of the right
    column. This will make the total visible width of the footer columns smaller than
    the header. You can remove this gutter by setting the padding of `div` to `0`
    on these sides. Change the padding on the middle column to give the three columns
    the same width again. This can be done using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Visit `http://localhost/semanticgrid.html` to see the final result of the preceding
    code. Resize your browser window to see that it is indeed responsive.
  prefs: []
  type: TYPE_NORMAL
- en: Extending your grids
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding examples, you used one grid with one break point. Below the
    break point, your rows simply stack. This seems to work in many cases, but sometimes,
    it will be useful to have a grid for small screens as well. Imagine that you build
    a photo gallery. On large screens, there will be four photos in a row. For smaller
    screens, the photos shouldn't stack but show up with two instead of four in a
    row.
  prefs: []
  type: TYPE_NORMAL
- en: Again, you can solve this situation using grid classes or mixins for a more
    semantic solution.
  prefs: []
  type: TYPE_NORMAL
- en: In both situations, you should also make your photos responsive. You can do
    this by adding styles for your images. Setting `max-width` to `100%` and `height`
    to `auto` does the trick in most cases. The `max-width` variable prevents images
    from being displayed wider than their original size and ensures that they get
    100 percent of their parent's width in other situations. On small screens, these
    images will get 100 percent width of the viewport.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make your images responsive by default, you can add the following code to
    your project''s *Less* code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If you prefer to make your image explicitly responsive by adding a class to
    each image in your source, you can you use the following *Less* code to make such
    a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Adding grid classes for the small grid
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using grid classes, you have to change the original `.make-column` mixin
    from Preboot. This `.make-columns()` mixin sets the styles for a column and add
    a media query. The media query in the `.make-columns()` mixin lets the columns
    float horizontally for wider viewports. For the new small grid, you don't need
    a media query, because the columns shouldn't be stacked at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accomplish this, you can split the mixin into two new mixins, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: After writing the preceding mixins, you should also create two mixins which
    do a loop to make your grid classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first mixin should look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding mixins will be called from `grid.less` using the `.make-grid-columns(12);`
    statement. These mixins will be compiled into the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'After doing this, you can easily see that the preceding code can be optimized
    to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The second mixin will look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding mixins will be called from `grid.less` using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will create two sets of grid classes. The large grid classes
    will only be applied when the media query is true. You will perhaps wonder why
    you can't create these grid classes in one single loop. This is because of the
    *last declaration wins* rule; you should define all your large grid classes after
    the small grid classes. If, for instance, `col-large-2` is defined before `col-small-3`,
    you can't use `<div class="col-small-3 col-large-2">` because `col-small-3` overrules
    the styles of `col-large-2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating your mixins as described earlier, you can write your HTML code
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will show four columns on your screen. These columns are
    wider than 768 pixels. The code will also show two columns on smaller screens.
    You can see an example of this by visiting: `http://localhost/prebootgridclassesextend.html`.'
  prefs: []
  type: TYPE_NORMAL
- en: Applying the small grid on your semantic code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have chosen the semantic way to build your grids, the following example
    will help you to add a small grid to the footer of the layout you built earlier.
    You can use the files from `/less/semanticgrid/content.less` again in this example.
  prefs: []
  type: TYPE_NORMAL
- en: The layout has a break point at 768 pixels. Below this break point, on a small
    screen, the footer should have three columns, and on big screens, the footer columns
    should stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can reuse the Preboot mixins you used earlier in this chapter to build
    a responsive grid, to create the footer columns as described previously. First,
    split the mixin into two new mixins: one mixin for floating and one for styling
    the columns, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating these mixins, you can use them together with media queries as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unfortunately, you have arrived at the end of this chapter. Hopefully, you feel
    that you are already able to start your own project with *Less*. In this chapter,
    you learned how to use *Less* for your projects. You also learned how to use media
    queries and grids to build responsive websites. You are ready to start using *Less*
    in your projects now. Finally, you will have more time for your real design tasks.
    In the next chapter, you will be introduced to other projects and frameworks using
    *Less*. You will also learn how you can use these for your projects.
  prefs: []
  type: TYPE_NORMAL
