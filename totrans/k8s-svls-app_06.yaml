- en: Installing Kubernetes in the Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have been running Kubernetes on our local machines. This does have
    some drawbacks, one of which is processing power. We are going to start looking
    at some more complex and powerful frameworks, so we need some additional power.
    Because of this, we are going to look at installing Kubernetes on a few different
    public clouds, each time using a different tool:'
  prefs: []
  type: TYPE_NORMAL
- en: Launching Kubernetes in DigitalOcean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launching Kubernetes in AWS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launching Kubernetes in Microsoft Azure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launching Kubernetes on the Google Cloud Platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will then take a look at the differences between public cloud providers and
    look at installing Kubeless on one of the platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Launching Kubernetes in DigitalOcean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first public cloud platform we are going to look at is DigitalOcean. DigitalOcean
    is a little different from the big three we are going to be looking at in the
    following sections as it has fewer features. For example, on the product page
    DigitalOcean has eight features listed, whereas the AWS product page has eighteen
    main areas listed and each of these areas is split into six or more features and
    services.
  prefs: []
  type: TYPE_NORMAL
- en: Don't let this fool you into thinking that DigitalOcean is any less of a service
    than the other public cloud providers we are going to be looking at this in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: DigitalOcean's strong point is that it is an extremely simple-to-use hosting
    platform. With its straightforward API and command-line tools, its supporting
    services, and excellent management interface it is easy to bring up powerful yet
    very competitively priced virtual machines in less than a minute.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Droplets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Droplets are DigitalOcean's term for its compute resource. For our Kubernetes,
    we are going to be launching three Ubuntu 17.04 Droplets, each with 1 GB of RAM,
    1 CPU, and 30 GB of SSD storage.
  prefs: []
  type: TYPE_NORMAL
- en: This three Droplet cluster, at the time of writing, will cost approximately
    $30 per month to keep online. If you are planning on keeping it online while you
    need it then it will cost $0.045 per hour for the three Droplets.
  prefs: []
  type: TYPE_NORMAL
- en: Before you can create any Droplets you will need an account; you can sign up
    for DigitalOcean at [https://cloud.digitalocean.com/registrations/new](https://cloud.digitalocean.com/registrations/new).
    Once you have signed up, and before you do anything else, I recommend that you
    immediately enable two-factor authentication on your account. You can enable this
    on the account security page at [https://cloud.digitalocean.com/settings/security/](https://cloud.digitalocean.com/settings/security/).
  prefs: []
  type: TYPE_NORMAL
- en: Enabling two-factor authentication will give you an additional level of security
    and help protect your account from any unauthorized access and also unexpected
    cost. After all, you don't want someone logging in and using your account to create
    25 of the most expensive Droplets available for them to use as they please with
    you footing the bill.
  prefs: []
  type: TYPE_NORMAL
- en: Two-factor authentication works by introducing a second level of authentication
    to your account; typically this is a four- or six-digit code which is either generated
    by an application, such as Google Authenticator, on your mobile device or a text
    message sent by the service you are attempting to log in to. This means that even
    if your password is compromised an attacker still needs access to your mobile
    device or number.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we need to generate an SSH key and upload it to DigitalOcean. If you
    already have an account with an SSH key uploaded, you can skip this task. If you
    don't have a key, then follow the given instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using macOS High Sierra or Ubuntu 17.04 then you can run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will ask you for a location to store your newly generated private and
    public key, and also a passphrase. The passphrase is optional, but it does add
    another layer of security should the private portion of your SSH key fall into
    the wrong hands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b197999c-a3db-4b61-80f7-8a9967e43614.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have generated your key, you will need to make a note of the public
    portion of your key. To do this, run the following command, making sure to update
    the path of the key to match your own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6c023c80-d5db-42dd-b09b-82601af14d8e.png)Please make sure you do
    not share or publish the private portion of your SSH key (the file that does not
    contain `.pub` in the filename). This is used to authenticate you against the
    public portion of the key. If this falls into the wrong hands they will be able
    to access your server/services.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For Windows 10 Professional users'' odds are that you are using PuTTY as your
    SSH client. If you don''t have PuTTY you can install it using Chocolatey by running
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once PuTTY is installed you can open the PuTTYgen program by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once open, click on Generate and follow the prompt to move your cursor around
    the blank area. After a second you should have a key generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e9c36baa-2ebd-4faf-8f9b-ce54da273c49.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the preceding screenshot, you have the option of adding
    a passphrase, which will be used to unlock the private portion of your key; again,
    this is optional.
  prefs: []
  type: TYPE_NORMAL
- en: Click on Save public key and also Save private key, and make a note of the contents
    of the public key.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your public key we need to let DigitalOcean have a copy. To
    do this, go to the security page, which you can find at  [https://cloud.digitalocean.com/settings/security/](https://cloud.digitalocean.com/settings/security/)
    and click on Add SSH Key. This will pop up a dialog box where you are asked to
    provide the content of your public key and name it. Fill in the two form fields
    and then click on the Add SSH Key button.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an SSH key assigned to your account you can use it to create
    your Droplets and have passwordless access to them. To create your Droplets, click
    on the Create button in the top right-hand corner of the screen and select Droplets
    from the drop-down menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several options on the Droplet creation page:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose an image: Select the Ubuntu 16.04 image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Choose a size: Select the $10/mo option, which has 1 GB, 1 CPU, and 30 GB SSD'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add block storage: Leave as-is'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Choose a datacenter region: Select the region closest to you; I selected London
    as I am based in the UK'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Select additional options: Select Private networking'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add your SSH keys: Choose your SSH key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finalize and create: Increase the number of Droplets to `3` and for now leave
    the hostname as-is'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you have filled out the preceding sections, click on the Create button
    at the bottom of the page. This will launch your three Droplets and give you feedback
    on how far through the creation process they are. Once they have launched, you
    should see something similar to the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bef96a2d-ae01-4683-946b-4bf519107cbb.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, I have three Droplets, their IP addresses, and a nice little
    motivational message. Now we can start deploying our Kubernetes cluster using
    `kubeadm`.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Kubernetes using kubeadm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First of all, we need to log in to one of our three Droplets; the first machine
    we log into will be our Kubernetes master:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once logged in, the following two commands check for any updates to the packages
    and apply them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we are up-to-date we can install the prerequisite packages. To do
    this run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You may notice that we are using the version of Docker that is distributed as
    part of the core Ubuntu 16.04 package repositories rather than the official Docker
    release. This is because `kubeadm` doesn't have official support for newer versions
    of Docker and the recommended version is 1.12\. At present, the version of Docker
    supported by Ubuntu 16.04 is 1.12.6.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the prerequisites installed we can add the Kubernetes repository
    by running the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `curl` command adds the GPG key for the repository and the `cat` command
    creates the repository file. Now that the repository is in place we need to update
    our package list and install `kubeadm`, `kubelet`, and `kubectl` by running the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, you can check the version of `kubeadm` that was installed by
    running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have everything we need installed we can bootstrap our Kubernetes
    master node by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This will take a few minutes to run and you will get some quite verbose output
    letting you know what tasks `kubeadm` has completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ce95dd39-8086-4fca-97fb-f99503f2083e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once complete you should see the following message, but with your tokens and
    so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/936836b4-047f-4bb9-8d89-1bb205a6dbd2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Make a note of the `kubeadm join` command at the bottom, we will look at that
    shortly. We should run the commands mentioned in the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to enable pod networking. There are several options you can choose
    from, all of which provide multihost container networking for your Kubernetes
    cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Calico**: [https://www.projectcalico.org/](https://www.projectcalico.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Canal**: [https://github.com/projectcalico/canal](https://github.com/projectcalico/canal)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**flannel**: [https://coreos.com/flannel/docs/latest/](https://coreos.com/flannel/docs/latest/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kube-router**: [https://github.com/cloudnativelabs/kube-router/](https://github.com/cloudnativelabs/kube-router/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Romana**: [https://github.com/romana/romana/](https://github.com/romana/romana/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Weave Net**: [https://www.weave.works/oss/net/](https://www.weave.works/oss/net/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For our installation we are going to be using Weave Net. To install this simply
    run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/858ea84d-5030-443e-826d-d4bfbc749475.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, this used the `kubectl` command to deploy the pod networking.
    This means that we have our basic Kubernetes cluster up-and-running, albeit on
    a single node.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prepare the other two cluster nodes, open an SSH session for both and run
    the following commands on them both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, these are the exact set of commands we executed on the master
    node to get us to the point where we can execute the `kubeadm` command. As you
    may have already guessed, rather than running `kubeadm init` we are going to be
    running the `kubeadm join` command we received when we initialized our master
    node. For me that command was as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You will need to run the command you received, as the tokens will be tied to
    your master node. Run the command on both nodes and you should see something like
    the following Terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2b0ecfd2-6df2-4b0f-9870-f26c3e4199c1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have run the command on both of your remaining nodes, return to your
    master node and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This should return a list of the nodes within your Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/87ad7e15-3fad-4c30-9a97-d80053b3b240.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we have a cluster made up of our three Droplets. The only downside
    is that at present we have to log in to our master node to interact with our cluster.
    Luckily this is easy to resolve, we just need to download a copy of the cluster
    `admin.conf` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this on macOS High Sierra or Ubuntu 17.04 run the following command,
    making sure to replace the IP address with that of your master node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using Windows 10 Professional you will need to use a program such
    as WinSCP. To install this run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Once installed, launch it by typing `WINSCP.exe` and then follow the on-screen
    prompts to connect to your master node and download the `admin.conf` file, which
    can be found in `/etc/kubernetes/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have a copy of the `admin.conf` file you will be able to run the following
    command locally to see your three-node Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have confirmed that we can connect using our local copy of `kubectl`
    we should put the configuration file in place, so we don''t have to use the `--kubeconfig`
    flag each time. To do this run the following commands (macOS and Ubuntu only):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This should show your three Droplets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a370c935-481e-482d-9067-0c81b33b6239.png)'
  prefs: []
  type: TYPE_IMG
- en: Removing the cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To remove the cluster, simply log in to your DigitalOcean control panel and
    click on the Destroy link, which can be found in the More drop-down menu to the
    right of each Droplet. Follow the on-screen instructions from there. Make sure
    you destroy all three Droplets as they will be incurring cost while they are online.
  prefs: []
  type: TYPE_NORMAL
- en: This has been a manual deployment of Kubernetes on low-spec servers. In the
    next few sections, we are going to look at how to deploy Kubernetes in other public
    clouds, starting with AWS.
  prefs: []
  type: TYPE_NORMAL
- en: Launching Kubernetes in AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several tools we can use to launch a Kubernetes cluster on AWS; we
    are going to be covering one called `kube-aws`. Unfortunately, `kube-aws` does
    not support Windows-based machines so the following instructions will only apply
    to macOS High Sierra and Ubuntu 17.04.
  prefs: []
  type: TYPE_NORMAL
- en: '`kube-aws` is a command-line tool that is used to generate an AWS CloudFormation
    template, which is then used to launch and manage a CoreOS cluster. Kubernetes
    is then deployed to the cluster of CoreOS instances.'
  prefs: []
  type: TYPE_NORMAL
- en: AWS CloudFormation is Amazon's native scripting tool and allows you to programmatically
    launch AWS services; it covers pretty much all of the AWS API. CoreOS is an operating
    system that is focused on one thing, running containers. It has an extremely small
    footprint and is designed to be clustered and configured on cloud providers out-of-the-box.
  prefs: []
  type: TYPE_NORMAL
- en: Getting set up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 1](37d92482-56fd-4329-8b81-01acc97e9c0c.xhtml), *The Serverless
    Landscape*, we looked at creating a Lambda function. To configure this we installed
    the AWS CLI. I am going to assume that you still have this configured and the
    IAM user you have configured has administrator privileges. You can test this by
    running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This should return something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4a459583-2e01-466f-b259-998be9d081cb.png)'
  prefs: []
  type: TYPE_IMG
- en: We need to import our SSH key in to AWS. To do this, open the AWS Console ([https://console.aws.amazon.com/](https://console.aws.amazon.com/)).
    Once logged in, select EC2 from the Service menu at the top of the page. Once
    you are on the EC2 page, make sure you have the correct region selected by using
    the region drop-down menu in the top-right corner of the page. I am going to be
    using EU (Ireland), which is also known as eu-west-1.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are in the correct region click on the Key Pairs option, which can
    be found under the NETWORK & SECURITY section in the left-hand menu. Once the
    page loads, click on the Import Key Pair button and then, like DigitalOcean, enter
    the name of your key pair and enter the contents of your `id_rsa.pub` file in
    there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, we need an AWS KMS store. To create this, run the following command,
    making sure to update your region as required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return several pieces of information, including an **Amazon Resource
    Name** (**ARN**). Make a note of this and also the `KeyId`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fe0b72a4-0a71-4b9b-b749-5b8f6c8f4231.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next up, we need an Amazon S3 bucket. To create one using the AWS CLI run the
    following command, making sure to update the region, and also make the bucket
    name unique to you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/597991ee-ed09-4578-9ecf-fa5e501e515b.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have our public SSH key imported, a KMS ARN, and an S3 bucket, we
    just need to decide on a DNS name for our cluster.
  prefs: []
  type: TYPE_NORMAL
- en: I am going to be using `kube.mckendrick.io` for mine as I have `mckendrick.io`
    already hosted on the Amazon Route 53 DNS service. You should choose a domain
    or subdomain you can configure a CNAME on, or one that is hosted on Route 53.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the basics covered we need to install the `kube-aws` binary.
    To do this, if you are running macOS High Sierra you simply need to run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are running Ubuntu Linux 17.04 you should run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, run the following command to confirm that everything is OK:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'At the time of writing the current version is 0.9.8\. You can check for newer
    versions on the release page at: [https://github.com/kubernetes-incubator/kube-aws/releases/](https://github.com/kubernetes-incubator/kube-aws/releases/).'
  prefs: []
  type: TYPE_NORMAL
- en: Launching the cluster using kube-aws
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start to create the cluster configuration, we need to create a working
    directory, as there are going to be a few artifacts created. Let''s create a folder
    called `kube-aws-cluster` and change to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are in our working directory we can create our cluster configuration
    file. To do this run the following command, making sure to replace the values
    with the information you gathered in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: If you are not using a Route 53-hosted domain, remove the `--hosted-zone-id`
    flag.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a file called `cluster.yaml`, which will be the base of our
    configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ab65345d-4e0d-470c-ac19-a7c47f1bf46d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we need to create the certificates that will be used by our Kubernetes
    cluster. To do this run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/a44dd8df-779c-4e89-8153-51d7e1464682.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next up, we need to generate the AWS CloudFormation templates. To do this run
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create the templates in a folder called `stack-templates`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/40ead830-2614-469f-a53d-119bf97b05fa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Running `ls` in your working directory should show you that several files and
    folders have been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/24c33f41-0a38-4dca-ae0f-8ec08b844605.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, we can run the following command to validate and upload the files
    to our S3 bucket, remembering to update the bucket name with your own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can launch our cluster. To do this simply run the following command,
    again making sure you update the bucket name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This will start to launch our cluster using the AWS CloudFormation tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/316018ed-2bd7-4db0-87c5-d1b4f760b448.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This process will take several minutes; you can view its progress on the command
    line within the AWS Console. To view it in the Console go to the Services menu
    and select CloudFormation. Once open, you should see a few stacks listed; select
    one of them and then click on the Events tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a43c7b15-c7a5-4922-99c2-9dad09494263.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see from the Events and also Resources tabs, there is a lot going
    on in the background. There are: IAM roles, VPCs and networking, EC2 instances,
    Load Balancers, DNS updates, auto scaling groups, and more being created.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once it has finished, you should see three CloudFormation stacks, one main
    one called `kube-aws-cluster` and two nested stacks, one called `kube-aws-cluster-Controlplane`
    and the other `kube-aws-cluster-Nodepool1`. Both of the nested stacks will have
    a unique ID appended to their name. You will receive confirmation that your cluster
    has launched on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/98e7b4a3-7a9b-417a-a464-994ae2edf13e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Running the following command in our working directory will list the nodes
    within our AWS Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/0eb190c5-9323-4914-97d9-1574311e8040.png)'
  prefs: []
  type: TYPE_IMG
- en: The Sock Shop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test our deployment we can launch the Sock Shop. This is a demo microservice
    application written by Weave. You can find its project page at: [https://microservices-demo.github.io/](https://microservices-demo.github.io/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To launch the shop, we need to run the following commands from within our working
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'It will take a few minutes to launch; you can check the progress by running
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for each pod to gain a status of running, as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/19341b3e-32db-423a-bdac-fc55e4c1d07f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we should be able to access our application. To do this we will need
    to expose it to the internet. As we have our cluster in AWS we can use the following
    command to launch an Elastic Load Balancer and have it point to our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To get information on our Load Balancer we can run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/7613f52d-97c2-4551-8899-571b25b58e6d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the application is being exposed on port `8079`, but we cannot
    quite see the Elastic Load Balancer URL. To get this we can run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/a2ccd721-20a5-43ad-bba0-6165121ce8d2.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we know the URL of the Elastic Load Balancer we can enter it, along
    with the port, into our browser. For me, the full URL was `http://a47ecf69fc71411e7974802a5d74b8ec-130999546.eu-west-1.elb.amazonaws.com:8079/`
    (this URL is no longer active).
  prefs: []
  type: TYPE_NORMAL
- en: 'Entering your URL should show you the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/13595402-f23d-478e-b25f-39e2acbc7f9c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To remove the Sock Shop application simply run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This will remove all of the pods, services, and the Elastic Load Balancer we
    created.
  prefs: []
  type: TYPE_NORMAL
- en: Removing the cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s not forget that while the cluster is up-and-running it is costing us
    money. To remove the cluster and all of the services created by the CloudFormation
    scripts run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: You will receive confirmation that the CloudFormation stacks are being removed,
    and that it will take several minutes. I recommend that you double-check in the
    AWS console on the CloudFormation page to ensure that there have not been any
    errors during the removal of the stacks, as any resources that are left running
    may incur costs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to remove the S3 bucket we created and also the KMS; to do this
    run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You can find the `--key-id` from the note you made when we first created the
    KMS earlier in this section.
  prefs: []
  type: TYPE_NORMAL
- en: While we didn't have to manually configure our cluster, or in fact to log in
    to any servers this time, the process of launching our cluster was still very
    manual. For our next public cloud provider, Microsoft Azure, we are going to be
    looking at a more native deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Launching Kubernetes in Microsoft Azure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](37d92482-56fd-4329-8b81-01acc97e9c0c.xhtml), *The Serverless
    Landscape*, we looked at Microsoft Azure Functions; however, we did not progress
    much further than the Azure web interface to launch our Function. To use the **Azure
    Container Service** (**AKS**) we will need to install the Azure command-line client.
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth pointing out at this time that the AKS does not currently support
    the Windows 10 PowerShell Azure tools. However, if you are using Windows do not
    worry, as the Linux version of the command-line client is available through the
    Azure web interface.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the Azure command-line tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Azure command-line tools are available through Homebrew on macOS High Sierra,
    which makes installing as easy as running the following two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Ubuntu 17.04 users can run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed you need to log in to your account. To do this run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: When you run the command you will be given a URL, which is [https://aka.ms/devicelogin](https://aka.ms/devicelogin),
    [and also a code to enter. Open the URL in your browser and enter the code:](https://aka.ms/devicelogin)
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/62006a27-067a-4a96-9e0c-6092f9bc0294.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once logged in, close your browser window and return to the command line, where
    after a few seconds you will receive confirmation that you are logged in as the
    user you logged into the browser with. You can double-check this by running the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned, Windows users can access their own bash shell using the Azure
    web interface. To do this, log in and click on the >_ icon in the top menu bar,
    select bash shell, and then follow the on-screen prompts. At the end of the setup
    you should see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dc2439b3-2e32-4cd6-8a0e-c800d832a281.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we have the command-line tools up, installed, and connected to our account
    we can launch our Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Launching the AKS cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First of all, we need to register for the AKS service. To do this run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'It will take a few minutes for the registration to complete. You can check
    on the status of the registration by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you see a `registrationState` of `Registered` you are good to go. To launch
    the cluster, we need to first create a resource group and then create the cluster.
    At present, AKS is available in either `ukwest` or `westus2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Once your cluster has launched you can run the following command to configure
    your local copy of `kubectl` to authenticate against the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can now run the following to start interacting with your cluster
    as you would any other Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/2f217bab-7462-4f5e-8f09-6db19ed0e273.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You will notice that we only have a single node; we can add two more nodes
    by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/de2de76c-c091-4475-a503-ea5295fbbf4d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You should be able to see all of the resources that have been launched in the
    Azure web interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c2ea31e2-e863-431b-b43f-5833a66b4bff.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have three nodes in our cluster, let's launch the *Sock Shop demo*
    app.
  prefs: []
  type: TYPE_NORMAL
- en: The Sock Shop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The commands are slightly different to the ones we ran before, as we do not
    have to supply a configuration file for `kubectl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, you can check the status of the pods by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Once all of the pods are running you can expose the application by running
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/7b2c4723-430f-431e-9215-7c0b36174e3e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This should give you a port and IP address. As you can see from the preceding
    output, this gave me a URL of `http://51.141.28.140:8079/`, putting this into
    my browser displayed the Sock Shop application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/917aa4e5-b3b1-464b-b915-f3dc80e22132.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To remove the application I just needed to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Removing the cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As per the other cloud services, while your AKS nodes are online you will be
    charged by the hour. Once you have finished with the cluster you simply need to
    remove the resource group; this will delete all of the associated services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Once deleted, go to the Azure web interface and manually delete any other remaining
    resources/services. The next and final public cloud we are going to look at is
    Google Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Launching Kubernetes on the Google Cloud Platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you would expect, Kubernetes is supported natively on Google Cloud. Before
    progressing, you will need an account, which you can sign up for at [http://cloud.google.com/](http://cloud.google.com/).
    Once you have your account set up, similar to the other public cloud platforms
    we have been looking at in this chapter, we need to configure the command-line
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the command-line tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are installers for all three operating systems. If you are using macOS
    High Sierra then you can use Homebrew and Cask to install the Google Cloud SDK
    by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Windows 10 Professional users can use Chocolatey and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, Ubuntu 17.04 users will need to run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, you need to sign into your account by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This will open your browser and ask you to sign into your Google Cloud account.
    Once signed in, you will be asked to grant the Google Cloud SDK permission to
    access your account. Follow the on-screen prompts to grant permissions and you
    should receive a message confirming you are authenticated with the Google Cloud
    SDK.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to your terminal, you should now have a prompt asking you to create
    a project. For testing purposes answer yes (`y`) to this question and enter a
    project name. This project name must be unique to you so it may take a few attempts.
    If you fail at first you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, my project is called `russ-kubernetes-cluster`. You should
    make references to your own project name in the commands. The final steps are
    to set our new project as the default as well as the region. I used the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the command-line tools installed, we can move on to launching
    our cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Launching the Google container cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can launch the cluster with a single command. The following command will
    launch a cluster named `kube-cluster`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'When you first run the command you may run into an error that states that the
    Google container API is not enabled for your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f1515c08-216b-461e-ae0b-d1e0679ccfca.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can rectify this error by following the link given in the error and following
    the on-screen instructions to enable the API. You may also find you get an error
    if your project does not have any billing associated with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/42f35b43-439d-4017-ac62-5dab26e669ee.png)'
  prefs: []
  type: TYPE_IMG
- en: To resolve this, log in to the Google Cloud web interface at [https://console.cloud.google.com/](https://console.cloud.google.com/)
    and select your project from the drop-down list next to where it says Google Cloud
    Platform. Once you have your project selected, click on the Billing link in the
    left-hand side menu and follow the on-screen prompts to link your project to your
    billing account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the API enabled and your project linked to a billing account
    you should be able to rerun the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'It will take several minutes, but once complete you should see something like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/614a5108-804c-4c22-ba01-e9872ec4b62c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the configuration for `kubectl` has been updated automatically,
    meaning that we can run the following command to check that we can communicate
    with our new cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c046a9de-762a-45a4-82e8-90b049fbef67.png)Before running this command
    please ensure that your local machine has a direct route to the internet and that
    you are not running through a proxy server or connection which is heavily firewalled,
    you may not be able to run into difficulties with the `kubectl proxy` command
    if you are.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should also be able to see your cluster in the Container Engine section
    of the Google Cloud web interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/068d1e13-23dc-49b1-8143-3fd4d78e8ca9.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have our cluster up-and-running, let's launch the Sock Shop application
    again.
  prefs: []
  type: TYPE_NORMAL
- en: The Sock Shop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we did with Azure, there is no need to provide a configuration file this
    time, so we simply need to run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the following screenshot, the IP and port give me a URL
    of `http://104.155.191.39:8079`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1d404220-cacb-44e1-8f3c-79ba92727fa0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, in the Google Cloud web interface, clicking on Discovery & load balancing
    should also show you the Load Balancer we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f6bbf0fd-2dd9-409e-ab55-2ec961b3ff16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking on the link in the interface, or pasting your URL into a browser should
    show you the now familiar shop front:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1a0bebbd-c957-4589-8a79-71d9b9d0f0e5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Running the following command should remove the Sock Shop application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Running Kubeless
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we remove our Google Cloud, three-node Kubernetes cluster, let''s quickly
    revisit Kubeless. To deploy Kubeless, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Once deployed, you can check the status by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also check Workloads and Discovery & load balancing in the Google Container
    Engine section of the Google Cloud web interface. Once Kubeless has been deployed,
    return to the `/Chapter04/hello-world` folder in the repository that accompanies
    this book and run the following command to deploy the test function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Once deployed, you can then view the function by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'You can call the function by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/8cd0fe2d-b02c-482f-8089-1428bf316f17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, you can expose the function using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the Load Balancer has been created you can run the following to confirm
    the IP address and port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you know the IP address and port you can open the function in your browser
    or use curl or HTTPie to view the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b5eb2e7f-f765-436a-9fa6-620c8d8581eb.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have tested our cluster with the Sock Shop application and deployed
    a Kubeless function we should look at terminating our cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Removing the cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To remove the cluster just run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: It will ask you if you are sure, answer yes and, after a minute or two, your
    cluster will be deleted. Again, you should double-check in the Google Cloud web
    interface that your cluster has been correctly deleted so you do not incur any
    unexpected costs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at four cloud providers. The first two, DigitalOcean
    and AWS, at present do not natively support Kubernetes so we used `kubeadm` and
    `kube-aws` to launch and configure our clusters. With Microsoft Azure and Google
    Cloud we used their command-line tools to launch their natively supported Kubernetes
    services. I am sure you will agree that at the time of writing both of these services
    are a lot friendlier to use than the first two we looked at.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the clusters were up-and-running, interacting with Kubernetes was a pretty
    consistent experience. We didn''t really have to make allowances for where our
    cluster was running when issuing commands such as `kubectl expose`: Kubernetes
    was aware of where it was running and used the provider''s native services to
    launch a Load Balancer without us have to intervene with any special settings
    or considerations.'
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why we didn't launch the Sock Shop application on DigitalOcean.
    As the spec of the machines was quite low, the application was really slow to
    run, and DigitalOcean is the only provider out of the four we looked at where
    the provider's native Load Balancing service is not currently supported by Kubernetes.
    I am sure this will be rectified over the coming months.
  prefs: []
  type: TYPE_NORMAL
- en: Also, you might be surprised that there is no native Kubernetes experience on
    AWS. At the time of writing this is the case; however, there are rumors that since,
    AWS has joined the Cloud Native Foundation, they are working on developing a native
    Kubernetes service.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to take look at Apache OpenWhisk, which is
    an open source serverless cloud platform originally developed by IBM.
  prefs: []
  type: TYPE_NORMAL
