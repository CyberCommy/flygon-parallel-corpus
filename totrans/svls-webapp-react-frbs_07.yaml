- en: Using Firebase Cloud Messaging and Cloud Functions with React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapters, we explored some of the Firebase products, such as
    Realtime Database, Authentication, Cloud Firestore, and Cloud Storage. However,
    we haven''t seen some of the advanced features yet, such as Realtime messaging
    and serverless app development. Now we are ready to explore them, so let''s discuss
    two more products from Firebase platform: Firebase Cloud Messaging and Cloud Functions.
    Firebase Cloud Messaging is a messaging platform to send free messages across
    different platforms: Android, iOS, and web. Cloud Functions allow you to have
    serverless apps, meaning that you can run your custom application logic without
    a server.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a list of topics that we''ll focus on in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Key features of **Firebase Cloud Messaging** (**FCM**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setup of Firebase for Javascript Web App
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client app setup to receive notifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server setup to send the notifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key features of Cloud Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setup of Firebase SDK for Cloud Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Life cycle of a Cloud Function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Triggering functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment and execution of a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Termination of a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's first start with FCM, and then we will go through the Cloud Functions.
  prefs: []
  type: TYPE_NORMAL
- en: Firebase Cloud Messaging (FCM)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'FCM provides a platform that helps you send the messages and notifications
    to the app user in real-time using service workers. You can send hundreds of billions
    of messages per day for free across different platforms: Android, iOS, and web
    (Javascript). You can also schedule the message delivery, immediately or in future.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main components in  FCM implementation: a trusted environment
    that includes an app server or a Cloud function to send the messages, and an iOS,
    Android, or web (JavaScript) client app that receives the messages.'
  prefs: []
  type: TYPE_NORMAL
- en: If you know about the **Google Cloud Messaging** (**GCM**), you might have a
    question of how FCM is different from GCM. The answer to this question is that
    FCM is the latest and improved version of GCM. It inherits all the infrastructure
    of GCM and carries improvements for the simplified client development. Just note
    that GCM is not deprecated and Google is still supporting it. However, the new
    client-side features will only come to FCM and hence as per Google recommendation,
    you should upgrade from GCM to FCM.
  prefs: []
  type: TYPE_NORMAL
- en: Though it supports different platforms, Android, iOS, and Web, we will mainly
    talk about web (Javascript) in this chapter. Let's now look at the key features
    of FCM.
  prefs: []
  type: TYPE_NORMAL
- en: Key features of FCM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The key features of GCM include Downstream messages, Upstream Messages, and
    Versatile messaging. Let's see what these feature are in brief in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Sending downstream messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The downstream messages are sent to users from the server on behalf of a client
    app. FCM messages can be divided into two categories: Notification Messages and
    Data Messages.  The notification messages are directly displayed to user. Some
    examples of the notification messages are alert messages, chat messages, or messages
    to notify client app to start some processing; let''s message backups. The data
    messages need to be handled in your client app code. Some examples are chat messages
    or any messages specific to your app. We will talk more about these message types
    in the next section of FCM Messages.'
  prefs: []
  type: TYPE_NORMAL
- en: Sending upstream messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The upstream messages are sent back from devices to the server via an FCM channel.
    You can send acknowledgments, chat messages, and other messages from devices back
    to your server over a reliable FCM channel.
  prefs: []
  type: TYPE_NORMAL
- en: Versatile message targeting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: FCM is quite flexible and allows you to send the messages to the target audience
    on a single device, a group of devices, or to all the subscribers who listen to
    a topic.
  prefs: []
  type: TYPE_NORMAL
- en: FCM messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using FCM, you can send two types of messages to the clients: Notification
    Messages and Data Messages. The maximum payload size for both kinds of messages
    is 4 KB when using Firebase SDK. However, when you send messages from the Firebase
    console, it enforces a 1024 character limit.'
  prefs: []
  type: TYPE_NORMAL
- en: The notification messages are handled by FCM SDK automatically, since they are
    just display messages. You can use notification messages when you want FCM to
    display a notification on your client app's behalf. Notification messages contain
    a predefined set of keys and can also contain an optional data payload.
  prefs: []
  type: TYPE_NORMAL
- en: 'The notification message object looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The data messages are handled by a client app and contain the user-defined
    keys. They look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We will see what a token is in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Setup of Firebase for Javascript web app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'FCM allows you to receive notification messages in your web application running
    in different browsers with the support of service worker. The service worker is
    a browser script that runs in the background and provides features such as offline
    data capability, background data syncing, push notifications, and more. The service
    worker support is available in the following browsers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chrome: 50+'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Firefox: 44+'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Opera Mobile: 37+'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using service workers, people can carry out some malicious activities, such
    as filtering the responses or hijacking connections. To avoid that, service workers
    can only be used on pages served over HTTPS. Hence, you will need a valid SSL
    certificate on your server if you want to use FCM. Note that in the local environment,
    you don't need SSL; it works at localhost without any issues.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Firebase and Firebase CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are starting with a new React project, the easiest way to get started
    is with the React Starter Kit. You can create a React project using the following command and
    then install **firebase** and **firebase-tools**. If it is an existing React and
    Firebase project, you can skip the installation steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can install Firebase using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You will also need to install the Firebase CLI to run your project on a server.
    It can be installed using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will extend the Helpdesk application with FCM implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the browser to receive messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First of all, you will need to add a web app manifest from [https://developers.google.com/web/fundamentals/web-app-manifest/file](https://developers.google.com/web/fundamentals/web-app-manifest/file)
    in our project and add the following to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It tells the browser that FCM is allowed to send the messages to this App. The
    `103953800507` value is hard-coded and must be the same in any of your App. The
    web app manifest is a simple JSON file and will contain the configuration metadata
    related to your project, such as the start URL of your App and App icon details.
  prefs: []
  type: TYPE_NORMAL
- en: We have created a `manifest.json` file in the root folder of the code and added
    the preceding content to it.
  prefs: []
  type: TYPE_NORMAL
- en: Client app setup to receive notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To allow your app to receive notifications in your browser, it will have to
    get permissions from the user. To do so, we will add a piece of code that will
    show a consent dialog to let the user grant your app permission to receive notifications
    in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add the `componentWillMount()` method to our `index.jsx` file present
    under the home directory, since we want to show the dialog once the user is successfully
    logged in to the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you will need to import the `firebase` object using the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you add the preceding code, restart your server and log in to the app.
    It should show the following dialog box to the users of your app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/1bf6efe5-7577-4d8e-83b2-968da0b20687.png)'
  prefs: []
  type: TYPE_IMG
- en: Once user gives permissions then only your browser will receive the notifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s write a function to get the registration token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function will retrieve the current access token that will need
    to be sent to the server to subscribe for the notifications. You can implement
    logic to send this token to the server in the `sendTokenToServer()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The registration token may change when your web app deletes the registration
    token or a user clears browser data. In case of the latter, will need to call
    `getToken()` to retrieve the new token. Since there are chances that the registration
    token might get changed, you should also monitor refresh token to get the new
    token. FCM fires a callback whenever a token is generated so that you can get
    a new token. The `onTokenRefresh()` callback fires whenever a new token is generated,
    so calling the `getToken()` method in its context ensures that you are having
    a current registration token. You can write a function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Once you get the token, you can send it to your app server by implementing a
    method like `sendTokenToServer(refreshedToken)` to store it and if you are using
    React and Firebase Realtime Database, you can directly store it in the database.
  prefs: []
  type: TYPE_NORMAL
- en: All these functions will be added to the `index.jsx` file. We will call the `getToken()`
    function from the `componentWillMount()` method, whereas `refreshToken()` will
    be called from constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Now, after all this setup, we will add the actual functionality of receiving
    the messages in our client app.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the page status, whether it is running in the background or in
    the foreground (it has focus) or it is closed or hidden behind tabs, the behavior of
    messages differs.
  prefs: []
  type: TYPE_NORMAL
- en: In order to receive messages, a page must handle the `onMessage()` callback,
    and to handle `onMessage()`, there must be a Firebase messaging service worker
    defined in your app.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a file called `firebase-messaging-sw.js` under the root directory
    of the project and write the following code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you can specify an existing service worker with `useServiceWorker`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you will need to update the message `senderId` value, which you can
    get from the Firebase console for your project.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to show a notification message when your web page is in the background,
    you need to set `setBackgroundMessageHandler` to handle the messages. You can
    also customize the message, such as setting a custom title and icon. You can check
    it in the preceding code snippet. The messages received while the app is in the
    background trigger a display notification in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can handle the `OnMessage()` event on your web page. We will add a
    constructor in our `index.js` file so that it registers the callback on page load:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now our client is ready to receive the notification messages. Let's configure
    our backend to send the notifications.
  prefs: []
  type: TYPE_NORMAL
- en: Server setup to send the notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step is to enable FCM API for your project. You can go to [https://console.developers.google.com/apis/api/fcm.googleapis.com/overview?project=<project-id>](https://console.developers.google.com/apis/api/fcm.googleapis.com/overview?project=%3Cproject-id%3E)
    and enable it.
  prefs: []
  type: TYPE_NORMAL
- en: To send the notification from a trusted environment, we will need an Oauth2
    access token and the client registration token that we get in the client app.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the Oauth2 access token, we will need the private keys from your service
    account. Once you generate the private key, save the JSON file containing your
    private key at some secure place. We will use Google API Client Library at [https://developers.google.com/api-client-library/](https://developers.google.com/api-client-library/) to
    retrieve the access token, so install the `npm` module for `googleapis` using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function needs to be added to our `main.js` file to get the access
    token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: It will show you an access token in your browser when you hit the `http://localhost:3000/getAccessToken`
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see something like this in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/1215aa7b-ea9b-43a1-8680-4368f5efdda8.png)'
  prefs: []
  type: TYPE_IMG
- en: Obviously, in a real application, you won't show this token in browser or print
    it in browser console for security reasons, and you will use it internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'This access token will be passed in the `Authorization` header of the request,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: So now you have the access token. Also, if you remember, we talked about the `sendTokenToServer(currentToken)`
    method when setting up the client app, which sends the token to the server. You
    must have stored it in your database or cache, which can now be used.
  prefs: []
  type: TYPE_NORMAL
- en: Now we are ready to send our first notification message. To send the message,
    we will be using the latest HTTP v1 `send` requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our request will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You will replace all tokens and update the URL with your project ID, and then
    you should be able to send your first message.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ve used a rest client to send the message and, since my browser is running
    in background, it shows the notification message in a system tray. You can see
    that in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/4af8d08c-b8c1-4528-9d2c-b842921e4e5a.png)Postman chrome tool extension;
    the purpose is just to show the request and response of sending the FCM notification
    message'
  prefs: []
  type: TYPE_NORMAL
- en: 'The request body looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/51c64a73-50bf-428d-86c1-fc39315717ad.png)Postman chrome tool extension;
    the purpose of the image is just to show the body of the request that we sent
    earlier'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the important things to note about the message request:'
  prefs: []
  type: TYPE_NORMAL
- en: URL: `https://fcm.googleapis.com/v1/projects/<projectid>/messages:send`
  prefs: []
  type: TYPE_NORMAL
- en: 'Header: contains two key-value pairs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content-Type`: `application/json`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Authorization`: `Bearer` <access token>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Request body: Contains the message object with the following key values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`token`: <registration token for the client app to send the message to>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`notification`: It contains the configuration for your notiification message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yeah, so now we have FCM integrated in our app to send the notification message
    to a single device where an app is running in the background. However, you would
    want to send the notifications to a group of devices or may want to send the messages
    to a topic to which clients have subscribed. The basic concept will remain the
    same, but there will be changes in the configuration. You can refer to those topics
    in the firebase documentation at [https://firebase.google.com/docs/cloud-messaging](https://firebase.google.com/docs/cloud-messaging).
  prefs: []
  type: TYPE_NORMAL
- en: We will see Cloud Functions in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generally, any software application has some kind of backend logic that gets
    deployed on the server to be accessible through the internet. In case of big enterprise-level
    applications such as Banking or Finance, it may be worth to manage a server or
    cluster of servers. However, in case of small applications or the application
    where you want to execute certain logic depending on some user events, such as
    data changes in database or on API requests from mobile app or a web application,
    managing a server may be an overhead in terms of efforts as well as cost. However,
    when you use the Firebase platform, you don't need to worry about it as it provides
    **Cloud Functions **that lets you run code based on events emitted by specific
    Firebase products without managing servers.
  prefs: []
  type: TYPE_NORMAL
- en: Key features of Cloud Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cloud Functions come with a lot features, including easy integration with other
    Firebase Products and third-party APIs, and powerful security and privacy.
  prefs: []
  type: TYPE_NORMAL
- en: The key features of the Cloud Functions are discussed in the following subtopics.
  prefs: []
  type: TYPE_NORMAL
- en: Seamless integration with other Firebase Products and third-party APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cloud Functions can be seamlessly integrated with other Firebase Products and
    third-party APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your custom functions can be executed on specific events, which can be emitted
    by the listed Firebase products:'
  prefs: []
  type: TYPE_NORMAL
- en: Cloud Firestore Triggers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Realtime Database Triggers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firebase Authentication Triggers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google Analytics for Firebase Triggers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud Storage Triggers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud Pub/Sub Triggers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP Triggers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use Firebase Admin SDK for seamless integration of across different
    Firebase products. It is very useful in some of the most common application requirements.
    Let's say that you want to generate database indexes or audit logs when something
    changes in your real-time database; you can write a cloud function that is executed
    based on Realtime database triggers. The other way around, you can do some database
    operation based on specific user behavior. Similarly, you can integrate Cloud
    Functions with **Firebase Cloud Messaging** (**FCM**) to notify users when specific
    events occur in your database.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud Functions integration is not limited to only Firebase products; you can
    also integrate Cloud Functions with some third-party API services—by writing webhooks.
    Let's say you are part of a development team and want to update your Slack channel
    when somebody commits the code to Git. You can use the Git Webhook API, which
    will trigger your Cloud Function that executes logic to send the message to the
    Slack Channel. Similarly, you may use third-party Auth provider APIs, such as
    LinkedIn, to allow user login.
  prefs: []
  type: TYPE_NORMAL
- en: No server to maintain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cloud Functions run your code without requiring you to purchase or maintain
    any servers. You can write a Javascript or Typescript function and deploy it with
    a single command on the cloud. You don't need to worry about server maintenance or
    scaling. Firebase platform will automatically manage it for you. The scaling of
    the server instances happens precisely, depending on the workload.
  prefs: []
  type: TYPE_NORMAL
- en: Private and secure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The application business logic should be hidden from client side and must be
    secure enough to prevent any manipulation or reverse engineering of the code. Cloud
    Functions is fully secured, so it always remains private and will always do what
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: Life cycle of a function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Life cycle of a Cloud function can be roughly divided into five stages, which
    are these:'
  prefs: []
  type: TYPE_NORMAL
- en: You write code for a new function and define the conditions when the function
    should get executed. The function definition or code also contains the details
    of the event provider, such as Realtime database or FCM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You deploy the function using the Firebase CLI, and Firebase connects it to
    the event provider defined in the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the event provider generates the event that matches the conditions defined
    in the function, it gets executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Google automatically scales the number of instances based on the workload.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Whenever you update the code of a function or delete a function, Google will
    automatically update or clean up the instances, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's now create a simple Cloud function with Realtime database provider and
    deploy it.
  prefs: []
  type: TYPE_NORMAL
- en: Setup of Firebase SDK for Cloud Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is necessary to have Firebase CLI installed to proceed further to initialize
    the Cloud Functions. You can install the Firebase CLI, as given in the next section,
    if not done already.
  prefs: []
  type: TYPE_NORMAL
- en: Firebase CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already seen in [*Chapter 5*](5697f854-7bc1-4ffb-86a2-8304d0fc73e7.xhtml), *User
    Profile and Access Management,* how to install it but here''s the command, just
    for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the Firebase CLI installed, we will log in to the firebase console
    using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This command will open up a browser URL and will ask you to log in. After a
    successful login, you can go to the next step—initialization of the Firebase project.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the Firebase Cloud project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create an empty project directory called cloud-functions. We will run
    the following command from the newly created cloud -functions directory to initialize
    the Cloud Functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will walk you through a wizard with different steps and will create
    the necessary files for your projects. It will ask for your preferred language:
    Javascript or TypeScript. We will go with the Typescript for this sample. It will
    also ask you whether you want to associate any existing firebase projects or want
    to create a new project to associate with it. We will select an existing project.
    It also asks you if you want it to install the required node dependencies. We
    will say yes so that it installs all the necessary node packages. If you want
    to manage the dependencies yourself, you can say no to it. The following screenshot
    shows how the wizard looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/e455db7d-42ab-45ad-895e-b49c8e8aea67.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The final structure will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a16ae49d-f10b-44ef-bc87-e8075278941f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s understand some of these files specific to Cloud function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`firebase.json`: It includes properties of your project. It contains a property
    called "source", which points to the `functions` folder for your Cloud function
    code. If you want to point to some other folder, you change it here. It also includes
    a property called "predeploy", which essentially contains the command to build
    and run your code.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`.firebaserc`: It contains projects that are associated with this directory.
    It helps you quickly switch between projects.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`functions/src/index.ts`: This is the main source file where all your Cloud
    function code will go. By default, a function called `helloworld` will already
    be there in this file. However, it is commented out by default.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`functions/package.json`: Contains NPM dependencies of this project.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are a  Windows user, you may have to change the value of the property
    "predeploy" in your `firebase.json` file from "`npm` --prefix  `$RESOURCE_DIR`
    run build" to "`npm` --prefix `%RESOURCE_DIR%` run build", as it sometimes gives
    an error when you try to deploy your function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the setup is complete, we are good to go with the deployment of our first
    cloud function. For this sample, we will write a simple function call `greetUser`,
    which accepts the name of user in the `request` parameter and show a greeting
    message in response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: First of all, we need to import f*irebase-functions *to make our functions work.
    Also, note that the Cloud Function is implemented by calling `functions.https`,
    which essentially means that we are using an HTTP trigger.
  prefs: []
  type: TYPE_NORMAL
- en: The `greetUser()` Cloud function is an HTTP endpoint. If you know ExpressJS
    programming, you must have noted that the syntax resembles ExpressJS endpoint,
    which executes a function with request and response objects when a user hits the
    endpoint. Actually, the event handler for an HTTP function listens for the `onRequest()`
    event, which supports routers and apps managed by the Express web framework. The
    response object is used to send response back to the user, in our case, a text
    message, which the user will see in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment and execution of Cloud Function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to use the following command to deploy our `helloworld` Cloud function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will deploy our function, and you should see the following response
    in your Command Prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/11742558-0610-45d0-9c6e-ea55e5cf23a2.png)'
  prefs: []
  type: TYPE_IMG
- en: If the deployment has been completed successfully, you will see the function
    URL, such as `https://us-central1-seat-booking.cloudfunctions.net/greetUser`,
    which can now be used to trigger the execution of the Cloud Function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function URL includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`us-central1`: This is the region in which your function is deployed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`seat-booking`: This is the Firebase project ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cloudfunction.net`: This is the default domain'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`greetUser`: This is the name of the function deployed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to append pass name property as a request parameter to see that name
    in the greeting message.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see the following output when you hit that URL from your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/06c84a54-7799-4579-ac0d-8ded26f83360.png)'
  prefs: []
  type: TYPE_IMG
- en: So we have successfully created a Cloud function, yay!
  prefs: []
  type: TYPE_NORMAL
- en: 'Most developers would want to unit test their functions before deploying them
    on production or test environments. You can deploy and test your functions locally
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'It will start a local server and show a URL that you can hit to test your function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7f9cb413-d1ac-413e-a1e9-02cf5f0856a9.png)'
  prefs: []
  type: TYPE_IMG
- en: In this example, we saw how we can trigger a function through an HTTP request
    using `functions.https`. Let's explore all Triggering Functions now.
  prefs: []
  type: TYPE_NORMAL
- en: Triggering Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cloud Functions can be executed in response to the events generated by other
    Firebase products, which are essentially triggers for the Cloud Functions. We
    have seen the list of all triggers in the Key Features section. We will talk about
    Realtime Database Triggers, Authentication Triggers, Cloud storage Triggers, and
    Cloud Firestore Triggers, which are most relevant to this book. The rest three
    can be explored in the Firebase documentation at [https://firebase.google.com/docs/functions/](https://firebase.google.com/docs/functions/).
  prefs: []
  type: TYPE_NORMAL
- en: Realtime Database Triggers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can create Cloud Functions, which can respond to Realtime database changes
    to execute certain tasks. We can create a new function for Realtime Database events
    with `functions.database`*. *To specify when the function gets executed, we need
    to use one of the event handlers that are available to handle different database
    events. We also need to specify the database path to which the function will listen
    for events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given here are the events that are supported by Cloud Functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onWrite()` : It triggers when data is created, destroyed, or changed in the
    Realtime Database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onCreate()`: It triggers when new data is created in the Realtime Database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'onUpdate(): It triggers when data is updated in the Realtime Database'
  prefs: []
  type: TYPE_NORMAL
- en: 'onDelete(): It triggers when data is deleted from the Realtime Database'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the sample Realtime database function, which listens to users path
    in the database, and, whenever there is any change in the data of any user, it
    converts the name to uppercase and sets it as a sibling of the user''s database.
    Here, we are using a wildcard `{userId}`, which essentially means any `userId`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, `event.data` is a DeltaSnapshot. iT has a property called 'previous' that
    lets you check what was saved to the database before the event. The previous property
    returns a new DeltaSnapshot where all methods refer to the previous value.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication triggers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Authentication triggers, we can execute function code in response to the
    creation and deletion of a user via Firebase Authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a Cloud function that is executed if a new user is created, we can
    use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'According to the Firebase documentation, user creation events for Cloud Functions
    occur in the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: The developer creates an account using the Firebase Admin SDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A user creates an email account and password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A user signs in for the first time using a federated identity provider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A user signs in to a new anonymous auth session for the first time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Cloud Functions event is *not* triggered when a user signs in for the first
    time using a custom token. If you would like to access attributes of a newly created
    user, you can do so using the `event.data`object.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can get the user''s email and name as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Apart from user creation, if you want to trigger a function on user deletion,
    you can do it using the `onDelete()` event handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Cloud Storage Triggers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With Cloud Storage Triggers, you can execute a Firebase Cloud Function in response
    to create, update, or delete operation of files and folders in Cloud Storage.
    We can create a new function for Cloud Storage events with *functions.storage.*
    Depending on the requirement, you can have a function that listens for all changes
    on the default storage bucket, or you can restrict it to a specific bucket by
    specifying the bucket name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, we can write a function that compresses the uploaded files to
    reduce the size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The *change* event gets triggered whenever an object is created, modified, or
    deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following attributes are exposed by Cloud Storage functions, which can
    be used to do the further processing of files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`event.data`: Represents the storage object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event.data.bucket`: The storage bucket inside which the file is stored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event.data.name`: The file path in the bucket.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event.data.contentType`: The file content type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event.data.resourceState`: Two possible values: `exists` or `not_exists`.
    The `not_exists` value is set if the file / folder has been deleted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event.data.metageneration`: Number of times the metadata of the file has been
    generated; for new objects, the initial value is `1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A most common use case for a Firebase Cloud Function is to further process a
    file, for example, compress the file or generate thumbnails of an image file.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Triggers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen an example of HTTP endpoint called `greetUser()`, which
    covers most of the essential parts of HTTP endpoints. There's just one important
    point to note, that we should always terminate our functions properly; else, they
    might continue to run, and the system will forcibly terminate it. We can end our
    function with `send()`, `redirect()`, or `end()`*.*
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Also, if you are using Firebase hosting and want to connect your HTTP endpoint
    with some custom domain, you can do that as well.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud Firestore Triggers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Cloud Firestore Triggers, your Cloud function can listen to the events
    emitted by Cloud Firestore whenever there is a change in the data on the specified
    path your function listens to.
  prefs: []
  type: TYPE_NORMAL
- en: At a high level, it works similarly to the Realtime database triggers. You can
    use the `functions.firestore` object to listen to the specific events.
  prefs: []
  type: TYPE_NORMAL
- en: 'It supports four events: create, update, delete, and write, as listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onWrite()`: It triggers when any document is created, updated, or deleted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onCreate()`: It triggers when a new document is created'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onUpdate()`: It triggers when any value in an existing document is changed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onDelete()`: It triggers when a document is deleted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you want to execute a function whenever a specific document gets changed,
    you can write a function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We will now talk about Cloud function termination.
  prefs: []
  type: TYPE_NORMAL
- en: Function termination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The advantage of the Cloud Functions is that you don't need to procure any servers
    on your own, so you just need to pay charges for the duration that your Cloud
    Function runs. This also gives you a responsibility that you terminate your function
    properly and don't keep your function running in an infinite loop, otherwise it
    will incur extra charges in your bill.
  prefs: []
  type: TYPE_NORMAL
- en: 'To terminate your function and manage its life cycle properly, you can follow
    these recommended approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: Resolve asynchronous processing functions by returning a JavaScript promise
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: End HTTP functions with `res.redirect()`, `res.send()`, or `res.end()`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: End a synchronous function with a `return;` statement
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we talked about two advanced features of Firebase: Firebase
    Cloud Messaging and Firebase Cloud Functions. Using these two features, you can
    develop a highly interactive serverless app.
  prefs: []
  type: TYPE_NORMAL
- en: FCM is a messaging platform for reliable message delivery of downstream and
    upstream messages. We also discussed different message types and saw when to use
    one over another. To have practical experience on FCM, we enhanced our Helpdesk
    application to send and receive notifications.
  prefs: []
  type: TYPE_NORMAL
- en: We also spoke about Firebase Cloud Functions and saw how it helps to have a
    serverless app. We covered how to develop a cloud function and deploy it on the
    server. We also explored the different types of triggers, such as Realtime database
    triggers, HTTP triggers, Cloud Firestore triggers, Cloud Storage Triggers, and
    Auth triggers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover other advanced and interesting features,
    such as Firebase Cloud Storage and integration of Firebase application with Google
    Cloud.
  prefs: []
  type: TYPE_NORMAL
