- en: Chapter 7. 360-Degree Gallery
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。360度画廊
- en: 360-degree photos and videos are a different approach to virtual reality. Rather
    than rendering 3D geometry in real time with OpenGL, you're letting users look
    around a prerendered or photographed scene. 360-degree viewers are a great way
    to introduce consumers to VR because they give a very natural experience and are
    easy to produce. It is much easier to take a photo than to render a photorealistic
    scene of objects in real time. Images are easy to record with a new generation
    of 360-degree cameras, or the photosphere feature in the Google Camera app. Viewing
    prerecorded images requires much less computer power than rendering full 3D scenes,
    and this works well on mobile Cardboard viewers. Battery power should also be
    less of an issue.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 360度全景照片和视频是虚拟现实的一种不同方法。与使用OpenGL实时渲染3D几何图形不同，您让用户四处查看一个预先渲染或拍摄的场景。360度查看器是向消费者介绍VR的绝佳方式，因为它们提供了非常自然的体验，并且易于制作。拍摄照片比实时渲染物体的逼真场景要容易得多。使用新一代360度摄像机或Google相机应用程序中的全景图像功能很容易记录图像。查看预先录制的图像需要比渲染完整的3D场景需要更少的计算机功率，并且在移动Cardboard查看器上运行良好。电池电量也不应该是一个问题。
- en: Non-VR 360-degree media has become fairly common. For example, for many years
    real-estate listing sites have provided panoramic walkthroughs with a web-based
    player that lets you interactively view the space. Similarly, YouTube supports
    the uploading and playback of 360-degree videos and provides a player with interactive
    controls to look around during playback. Google Maps lets you upload 360-degree
    still photosphere images, much like their Street View tool, that you can create
    with an Android or iOS app (for more information, visit [https://www.google.com/maps/about/contribute/photosphere/](https://www.google.com/maps/about/contribute/photosphere/))
    or a consumer 360 camera. The Internet is teeming with 360-degree media!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 非VR 360度媒体已经相当普遍。例如，多年来，房地产列表网站提供了带有基于网络的播放器的全景漫游，让您可以交互地查看空间。同样，YouTube支持上传和播放360度视频，并提供一个带有交互式控件的播放器，可以在播放期间四处查看。Google地图允许您上传360度静态全景图像，就像他们的街景工具一样，您可以使用Android或iOS应用程序（有关更多信息，请访问[https://www.google.com/maps/about/contribute/photosphere/](https://www.google.com/maps/about/contribute/photosphere/)）或消费者360摄像机创建。互联网上充斥着360度媒体！
- en: Viewing 360-degree media in VR is surprisingly immersive, even for still photos
    (and even without a pair of stereoscopic images). You're standing at the center
    of a sphere with an image projected onto the inside surface, but you feel like
    you're really there in the captured scene. Simply turn your head to look around.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在VR中查看360度媒体令人惊讶地沉浸，即使是静态照片（甚至没有成对的立体图像）。你站在一个球体的中心，图像投影在内表面上，但你感觉自己真的在被捕捉的场景中。只需转动头部来四处看。
- en: 'In this project, we''ll build a photo gallery that lets you browse photos on
    your phone. Regular flat pictures and panoramas will appear projected on a large
    screen to your left. But 360-degree photospheres will fully immerse you inside
    the spherical projection. We will accomplish this project by performing the following
    steps:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将构建一个照片库，让您可以在手机上浏览照片。常规的平面图片和全景照片将显示在您左侧的大屏幕上。但是360度全景照片将完全沉浸您在球形投影中。我们将通过以下步骤完成这个项目：
- en: Setting up the new project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置新项目
- en: Viewing a 360-degree photosphere
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看360度全景照片
- en: Viewing a regular photo on a large virtual projection screen
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大型虚拟投影屏幕上查看常规照片
- en: Adding a frame border to the photos
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为照片添加边框
- en: Loading and displaying a photo image from your device's camera folder
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从设备的相机文件夹加载和显示照片图像
- en: Adjusting a photo's orientation and aspect ratio
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整照片的方向和长宽比
- en: Creating a user interface with a grid of thumbnail images for selecting the
    photo to be viewed with scrolling
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个用户界面，其中包含一个缩略图图像网格，用于选择要滚动查看的照片
- en: Ensuring a good, responsive VR experience with thread-safe operations
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保良好的、响应迅速的VR体验，具有线程安全的操作
- en: Launching an Android image view intent app
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动Android图像查看意图应用程序
- en: The source code for this project can be found on the Packt Publishing website,
    and on GitHub at [https://github.com/cardbookvr/gallery360](https://github.com/cardbookvr/gallery360)
    (with each topic a separate commit).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目的源代码可以在Packt Publishing网站上找到，并且在GitHub上也可以找到[https://github.com/cardbookvr/gallery360](https://github.com/cardbookvr/gallery360)（每个主题都是单独的提交）。
- en: Setting up the new project
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置新项目
- en: 'To build this project, we''re going to use our `RenderBox` library created
    in [Chapter 5](ch05.html "Chapter 5. RenderBox Engine"), *RenderBox Engine*. You
    can use yours, or grab a copy from the download files provided with this book
    or our GitHub repo (use the commit tagged `after-ch6`—[https://github.com/cardbookvr/renderboxlib/releases/tag/after-ch6](https://github.com/cardbookvr/renderboxlib/releases/tag/after-ch6)).
    For a more detailed description of how to import the `RenderBox` library, refer
    to the final section, *Using RenderBox in future projects*, in [Chapter 5](ch05.html
    "Chapter 5. RenderBox Engine"), *RenderBox Engine*. To do this, perform the following
    steps:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建这个项目，我们将使用我们在[第5章](ch05.html "第5章。RenderBox Engine")中创建的`RenderBox`库，*RenderBox
    Engine*。您可以使用您自己的库，或者从本书提供的下载文件或我们的GitHub存储库中获取一份副本（使用标记为`after-ch6`的提交——[https://github.com/cardbookvr/renderboxlib/releases/tag/after-ch6](https://github.com/cardbookvr/renderboxlib/releases/tag/after-ch6)）。有关如何导入`RenderBox`库的更详细描述，请参阅[第5章](ch05.html
    "第5章。RenderBox Engine")中的最后一节，*在未来项目中使用RenderBox*。要做到这一点，请执行以下步骤：
- en: With Android Studio opened, create a new project. Let's name it `Gallery360`
    and target **Android 4.4 KitKat (API 19)** with an **Empty Activity**.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Android Studio，创建一个新项目。让我们将其命名为`Gallery360`，并针对**Android 4.4 KitKat（API 19）**使用**空活动**。
- en: Create new modules for the `renderbox`, `common`, and `core` packages, using
    **File** | **New Module** | **Import .JAR/.AAR Package**.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`renderbox`，`common`和`core`包创建新模块，使用**文件** | **新模块** | **导入.JAR/.AAR包**。
- en: Set the modules as dependencies for the app, using **File** | **Project Structure**.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将模块设置为应用程序的依赖项，使用**文件** | **项目结构**。
- en: Edit the `build.gradle` file as explained in [Chapter 2](ch02.html "Chapter 2. The
    Skeleton Cardboard Project"), *The Skeleton Cardboard Project*, to compile against
    SDK 22.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update `/res/layout/activity_main.xml` and `AndroidManifest.xml`, as explained
    in the previous chapters.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit `MainActivity` as `class MainActivity extends CardboardActivity implements
    IRenderBox`, and implement the interface method stubs (*Ctrl* + *I*).
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can go ahead and define the `onCreate` method in `MainActivity`. The class
    now has the following code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'While we implement this project, we will be creating new classes that could
    be good extensions to `RenderBoxLib`. We''ll make them regular classes in this
    project at first. Then, at the end of the chapter, we''ll help you move them into
    the `RenderBoxLib` project and rebuild the library. Perform the following steps:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `gallery360` folder (`com.cardbookvr.gallery360`) and go
    to **New** | **Package**, and name the package `RenderBoxExt`.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within `RenderBoxExt`, create package subfolders named `components` and `materials`.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's no real technical need to make it a separate package but this helps
    organize our files, because the ones in `RenderBoxExt` will be moved into our
    reusable library at the end of this chapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add a cube to the scene, temporarily, to help ensure that everything
    is set up properly. Add it to the `setup` method as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you remember, a cube is a component that's added to a transform. The cube
    defines its geometry (for example, vertices). The transform defines its position,
    rotation, and scale in 3D space.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: You should be able to click on **Run 'app'** with no compile errors, and see
    the cube and Cardboard split screen view on your Android device.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Viewing a 360-degree photo
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ever since it was discovered that the Earth is round, cartographers and mariners
    have struggled with how to project the spherical globe onto a two-dimensional
    chart. The result is an inevitable distortion of some areas of the globe.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn more about map projections and spherical distortions, visit [http://en.wikipedia.org/wiki/Map_projection](http://en.wikipedia.org/wiki/Map_projection).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'For 360-degree media, we typically use an equirectangular (or a meridian) projection
    where the sphere is unraveled into a cylindrical projection, stretching the texture
    as you progress toward the North and South poles while keeping the meridians as
    equidistant vertical straight lines. To illustrate this, consider Tissot''s Indicatrix
    (visit [http://en.wikipedia.org/wiki/Tissot%27s_indicatrix](http://en.wikipedia.org/wiki/Tissot%27s_indicatrix)
    for more information) that shows a globe with strategically arranged identical
    circles (an illustration by Stefan Kühn):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing a 360-degree photo](img/B05144_07_01.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: 'The following image shows the globe unwrapped with an equirectangular projection
    ([https://en.wikipedia.org/wiki/Equirectangular_projection](https://en.wikipedia.org/wiki/Equirectangular_projection)):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing a 360-degree photo](img/B05144_07_02.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
- en: We will use an equirectangular mesh for our photospheres and an appropriately
    projected (warped) image for its texture map. To view, we place the camera viewpoint
    at the center of the sphere and render the image onto the inside surface.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that our Earth and other planet textures had the same sort
    of distortion on them. It's a pretty common way to map spherical images to flat
    ones, and in fact, we've been "doing the math" on this problem ever since we created
    the UVs for our sphere in [Chapter 6](ch06.html "Chapter 6. Solar System"), *Solar
    System*! You'll have to get clever with UV offsets to keep them from appearing
    stretched, but you should also be able to display panoramic photos on a sphere
    in the same way.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Viewing a sample photosphere
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may choose any 360-degree equirectangular image for this topic. We''ve
    included the following beach photo with this book, named `sample360.jpg`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing a sample photosphere](img/B05144_07_03.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![查看示例全景照片](img/B05144_07_03.jpg)'
- en: Add it to your project.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 将其添加到您的项目中。
- en: 'Copy the image you want to view into the project''s `res/drawable/` folder.
    Now add the following code to the `MainActivity.java` file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 将要查看的图像复制到项目的`res/drawable/`文件夹中。现在将以下代码添加到`MainActivity.java`文件中：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that multiplying the scale by 0.99 avoids unwanted clipping of the background
    image due to floating point precision errors on some phones. Using a negative
    scale *y* axis compensates for inverted rendering by the texture shader (alternatively
    you could modify the shader code).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，将比例乘以0.99可以避免由于某些手机上的浮点精度错误而导致背景图像的不必要剪裁。使用负比例*y*轴可以补偿纹理着色器的反向渲染（或者您可以修改着色器代码）。
- en: You can replace the drawable filename, `R.drawable.sample360`, with yours, as
    defined in the `DEFAULT_BACKGROUND` variable. This variable must be final, as
    required by the Android resource system.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以用您的文件名替换可绘制的文件名`R.drawable.sample360`，如`DEFAULT_BACKGROUND`变量中所定义的那样。这个变量必须是final的，根据Android资源系统的要求。
- en: In the `setup` method, we create a `Sphere` component as we have been doing
    all along. Start with a new transform, scale it, then add a new `Sphere` component
    with our resource ID to the transform. We're naming the object `background` because
    later on, this object will be the default background for the app.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setup`方法中，我们像一直以来一样创建一个`Sphere`组件。从一个新的变换开始，缩放它，然后向变换添加一个新的`Sphere`组件，带有我们的资源ID。我们将对象命名为`background`，因为以后，这个对象将成为应用程序的默认背景。
- en: Run the app, and insert your phone into a Cardboard viewer. Voila! You're in
    Margaritaville!! If that seemed really easy, you're right; it was! Really, the
    hard work was done for us by the photosphere app or whatever transformed the image
    into an equirectangular projection. The rest of it is the standard UV projection
    math we've been doing all along!
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，并将手机插入Cardboard查看器中。哇！你来到了Margaritaville！如果这看起来很容易，那么你是对的；它确实很容易！实际上，艰苦的工作是由全景应用程序或其他将图像转换为等距投影的应用程序完成的。其余的工作就是我们一直在做的标准UV投影数学！
- en: '![Viewing a sample photosphere](img/B05144_07_04.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![查看示例全景照片](img/B05144_07_04.jpg)'
- en: Using the background image
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用背景图像
- en: We're going to make a gallery that lets the user pick from a number of images.
    It would be nice if the user saw something more neutral when they first started
    the app. A more appropriate background image is included with the downloadable
    files for this book. It is named `bg.png` and contains a regular grid. Copy it
    to your `res/drawable/` folder. Then, change `DEFAULT_BACKGROUND` to `R.drawable.bg`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将制作一个画廊，让用户从多张图片中选择。当用户第一次启动应用程序时，如果用户看到一些更中性的东西会很好。这本书的可下载文件中包含了一个更合适的背景图像。它的名称是`bg.png`，包含一个常规的网格。将其复制到您的`res/drawable/`文件夹中。然后，将`DEFAULT_BACKGROUND`更改为`R.drawable.bg`。
- en: '![Using the background image](img/B05144_07_05.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![使用背景图像](img/B05144_07_05.jpg)'
- en: 'Rerun the app, and it should look like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行应用程序，应该看起来像这样：
- en: '![Using the background image](img/B05144_07_06.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![使用背景图像](img/B05144_07_06.jpg)'
- en: Viewing a regular photo
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看常规照片
- en: Now that we got that done, let's prepare our app to also be able to view regular
    flat photos. We'll do this by rendering them onto a plane. So first we need to
    define a `Plane` component.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了这个，让我们准备我们的应用程序也能够查看常规的平面照片。我们将通过将它们渲染到一个平面上来实现这一点。所以首先我们需要定义一个`Plane`组件。
- en: Defining the Plane component and allocating buffers
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义Plane组件并分配缓冲区
- en: The `Plane` component rightfully belongs to the `RenderBox` library, but for
    the time being, we'll add it directly to the app.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Plane`组件理所当然地属于`RenderBox`库，但目前，我们将直接将其添加到应用程序中。'
- en: 'Create a new Java class file in the `RenderBoxExt/components/` folder, and
    name it `Plane`. Define it as `extends RenderObject`, as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RenderBoxExt/components/`文件夹中创建一个新的Java类文件，并将其命名为`Plane`。将其定义为`extends RenderObject`，如下所示：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As with other geometry in the `RenderBox` library, we''ll define the plane
    with triangles. Simply two adjacent triangles are required, a total of six indices.
    The following data arrays define our default plane''s 3D coordinates, UV texture
    coordinates, vertex colors (middle gray), normal vectors, and corresponding indices.
    Add the following code at the top of the class:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与`RenderBox`库中的其他几何图形一样，我们将用三角形定义平面。只需要两个相邻的三角形，总共六个索引。以下数据数组定义了我们默认平面的3D坐标、UV纹理坐标、顶点颜色（中灰色）、法线向量和相应的索引。在类的顶部添加以下代码：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we can define the `Plane` constructor that calls an `allocateBuffers`
    helper method that allocates buffers for vertices, normals, textures, and indexes.
    Let''s declare variables for these at the top of the class, and write the methods:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以定义`Plane`构造函数，调用`allocateBuffers`辅助方法为顶点、法线、纹理和索引分配缓冲区。让我们在类的顶部声明这些变量，并编写方法：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Again, we ensure that `allocateBuffers` is run only once by checking whether
    `vertexBuffer` is null. (Note that we've decided to declare the buffers `public`
    to afford future flexibility to create arbitrary texture materials for objects.)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们通过检查`vertexBuffer`是否为空来确保`allocateBuffers`只运行一次。（请注意，我们决定将缓冲区声明为`public`，以便将来可以为对象创建任意纹理材料。）
- en: Adding materials to the Plane component
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向Plane组件添加材质
- en: 'Next, we can add an appropriate material to the `Plane`, one that uses a texture
    image. Using a constructor API pattern that is consistent with the built-in `Sphere`
    component in [Chapter 6](ch06.html "Chapter 6. Solar System"), *Solar System*,
    we''ll add the ability to call a new `Plane` with an image texture ID and an optional
    lighting Boolean flag. Then, we''ll add helper methods to allocate the corresponding
    `Material` objects and set their buffers:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以向`Plane`添加一个适当的材质，使用纹理图像。使用与内置`Sphere`组件在[第6章](ch06.html "第6章 太阳系")*太阳系*中一致的构造函数API模式，我们将添加调用一个新的`Plane`的能力，带有图像纹理ID和可选的光照布尔标志。然后，我们将添加帮助方法来分配相应的`Material`对象并设置它们的缓冲区：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Adding an image screen to the scene
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向场景添加图像屏幕
- en: We can now add an image to the scene in `MainActivity`. Soon we will take a
    look at the phone's photos folder for pictures, but at this point, you can just
    use the same (photosphere) one that we used earlier (or drop another in your `res/drawable`
    folder). Note that you might have issues displaying an image that is too large
    for a phone's GPU. We will take a look at this issue later, so try to keep it
    less than 4,096 pixels in either dimension.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Name the object `screen` because later on, we'll use it to project whichever
    photo the user selects from a gallery.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'In `MainActivity.java`, update the `setup` function to add the image to the
    scene, as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The screen is scaled to 4 units (in X and Y) and placed 5 units in front of
    the camera. That's like sitting 5 meters (15 feet) from an 8 meter wide movie
    screen!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, note that we rotate the plane 180 degrees on the *z* axis; otherwise,
    the image will appear upside down. Our world coordinate system has the up-direction
    along the positive *y* axis. However, UV space (for rendering textures) typically
    has the origin in the upper-left corner and positive is downward. (If you remember,
    in the previous chapter, this is why we also had to flip the Earth). Later in
    this chapter, when we implement an `Image` class, we''ll read the actual orientation
    from the image file and set the rotation accordingly. Here''s our screen plane
    with the image (viewed from an angle):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding an image screen to the scene](img/B05144_07_07.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
- en: 'It will be convenient to separate the screen plane (with its image texture)
    from the placement and size of the screen. We will see why this is important later,
    but it has to do with scaling and rotating based on image parameters. Let''s refactor
    the code so that the screen is parented by a `screenRoot` transform as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Putting a border frame on the image
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pictures look best in a frame. Let's add one now. There are a number of ways
    to accomplish this, but we are going to use shaders. The frame will also be used
    for the thumbnail images and will enable us to change colors to highlight when
    the user selects an image. Furthermore, it helps define a region of contrast,
    which ensures that you can see the edge of any image on any background.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Border shaders
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can start by writing the shader programs which, among other things, define
    the variables they will need from the `Material` object that uses it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: If necessary, create a resource directory for the shaders, `res/raw/`. Then,
    create the `border_vertex.shader` and `border_fragment.shader` files. Define them
    as follows.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: The `border_vertex` shader is identical to the `unlit_tex_vertex` shader that
    we were using.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'File: `res/raw/border_vertex.shader`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For the `border_fragement` shader, we add variables for a border color (`u_Color`)
    and width (`u_Width`). Then, add a bit of logic to decide whether the current
    coordinate being rendered is on the border or in the texture image:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'File: `res/raw/border_fragment.shader`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Note that this technique cuts off the edges of the image. We found this to
    be acceptable, but if you really want to see the entire image, you can offset
    the UV coordinates within the `texture2D` sampler call. It would look something
    like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Finally, observant readers might notice that when the plane is scaled non-uniformly
    (to make it a rectangle), the border will be scaled so that the vertical borders
    might be thicker or thinner than the horizontal borders. There are a number of
    ways to fix this, but this is left as an exercise for the (over-achieving) reader.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: The border material
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we define the material for the border shader. Create a new Java class
    in `RenderBoxExt/materials/` named `BorderMaterial` and define it as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add material variables for the texture ID, border width, and color. Then, add
    variables for the shader program references and buffers, as shown in the following
    code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we can add a constructor. As we''ve seen earlier, it calls a `setupProgram`
    helper method that creates the shader program and obtains references to its parameters:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以添加一个构造函数。正如我们之前所见，它调用一个`setupProgram`辅助方法，该方法创建着色器程序并获取对其参数的引用：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Likewise, we add a `setBuffers` method to be called by the `RenderObject` component
    (`Plane`):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们添加一个`setBuffers`方法，该方法将由`RenderObject`组件（`Plane`）调用：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Provide a setter method for the texture ID:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为纹理ID提供一个setter方法：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the draw code, which will be called from the `Camera` component, to render
    the geometry prepared in the buffers (via `setBuffer`). The draw method looks
    like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 添加绘制代码，该代码将从`Camera`组件调用，以渲染通过`setBuffer`准备的几何图形。绘制方法如下：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'One more thing; let''s provide a method to destroy an existing material:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事；让我们提供一个销毁现有材质的方法：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Using the border material
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用边框材质
- en: 'To use the `BorderMaterial` class instead of the default `UnlitTexMaterial`
    class, we wrote in the `Plane` class previously, we can add it to the `Plane`
    Java class, as follows. We plan to create the material outside the `Plane` class
    (in `MainActivity`), so we just need to set it up. In `Plane.java`, add the following
    code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`BorderMaterial`类而不是先前在`Plane`类中编写的默认`UnlitTexMaterial`类，我们可以将其添加到`Plane`Java类中，如下所示。我们计划在`Plane`类之外（在`MainActivity`中）创建材质，因此我们只需要设置它。在`Plane.java`中，添加以下代码：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In `MainActivity`, modify the `setupScreen` method to use this material instead
    of the default one, as follows. We first create the material and set the texture
    to our sample image. We don’t need to set the color, which will default to black.
    Then we create the screen plane and set its material. And then create the transform
    and add the screen component:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity`中，修改`setupScreen`方法以使用此材质而不是默认材质，如下所示。我们首先创建材质并将纹理设置为我们的示例图像。我们不需要设置颜色，默认为黑色。然后我们创建屏幕平面并设置其材质。然后创建变换并添加屏幕组件：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When you run it now, it should look something like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行它，它应该看起来像这样：
- en: '![Using the border material](img/B05144_07_08.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![使用边框材质](img/B05144_07_08.jpg)'
- en: Loading and displaying a photo image
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载和显示照片图像
- en: So far, we've used images in the project's `drawable` resource folder. The next
    step is to read photo images from the phone and display one on our virtual screen.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在项目的`drawable`资源文件夹中使用图像。下一步是从手机中读取照片图像并在虚拟屏幕上显示其中一个。
- en: Defining the image class
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义图像类
- en: 'Let''s make a placeholder `Image` class. Later on, we''ll build the attributes
    and methods. Define it as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们制作一个占位符`Image`类。稍后，我们将构建属性和方法。定义如下：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We define a constructor that takes the image's full path. We also provide a
    validation method that checks whether the path is actually for an image, based
    on the filename extension. We don't want to load and bind the image data on construction
    because we don't want to load all the images at once; as you'll see, we will manage
    these intelligently using a worker thread.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义一个构造函数，该构造函数接受图像的完整路径。我们还提供一个验证方法，该方法检查路径是否实际上是图像，基于文件名扩展名。我们不想在构造时加载和绑定图像数据，因为我们不想一次加载所有图像；正如您将看到的，我们将使用工作线程来智能地管理这些。
- en: Reading images into the app
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将图像读入应用程序
- en: 'Now in `MainActivity`, access the photos folder on the phone and build a list
    of images in our app. The following `getImageList` helper method looks in the
    given folder path and instantiates a new `Image` object for each file found:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`MainActivity`中，访问手机上的照片文件夹，并在我们的应用程序中构建图像列表。以下`getImageList`辅助方法查找给定文件夹路径，并为找到的每个文件实例化一个新的`Image`对象：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Use this method in the `setup` method, passing in the name of the camera images
    folder path, as follows (your path may vary):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setup`方法中使用此方法，传入相机图像文件夹路径的名称，如下所示（您的路径可能有所不同）：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Also, ensure that the following line is included in your `AndroidManifest.xml`
    file, giving the app the permission to read the device''s external storage. Technically,
    you should already have this permission when using the Cardboard SDK:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 还要确保在您的`AndroidManifest.xml`文件中包含以下行，以赋予应用程序读取设备外部存储的权限。从技术上讲，使用Cardboard SDK时，您应该已经拥有此权限：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You can add a log message to the `getImageList` loop and run it to verify that
    it is finding files. If not, you may need to discover the actual path to your
    photos folder.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以向`getImageList`循环添加日志消息并运行它以验证它是否正在找到文件。如果没有，您可能需要发现您的照片文件夹的实际路径。
- en: This is the first project where we need to be really careful about permissions.
    Up until this point, the Cardboard SDK itself was the only thing which needed
    access to the filesystem, but now we need it for the app itself to function. If
    you are using a device with Andriod 6.0, and you don't make sure to compile the
    app against SDK 22, you will not be able to load the image files, and the app
    will either do nothing, or crash.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要非常小心权限的第一个项目。直到这一点，Cardboard SDK本身是唯一需要访问文件系统的东西，但现在我们需要它来使应用程序本身正常运行。如果您使用的是Andriod
    6.0的设备，并且您没有确保将应用程序编译为SDK 22，您将无法加载图像文件，应用程序要么无所作为，要么崩溃。
- en: If you are compiling against SDK 22 and you have the permission set up correctly
    in the manifest but you still get an empty file list, try looking for the correct
    path on your device with a file browser. It could very well be that the path we
    provided doesn't exist or is empty. And, of course, make sure that you have actually
    taken a picture with that device!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在针对SDK 22进行编译，并且在清单中正确设置了权限，但仍然获得空文件列表，请尝试使用文件浏览器在设备上查找正确的路径。很可能是我们提供的路径不存在或为空。当然，确保您确实使用该设备拍摄了照片！
- en: Image load texture
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图像加载纹理
- en: If you remember, in [Chapter 6](ch06.html "Chapter 6. Solar System"), *Solar
    System,* we wrote a `loadTexture` method that reads a static image from the project's
    `res/drawable` folder into a memory bitmap and binds it to the texture in OpenGL.
    Here, we're going to do something similar but source the images from the phone's
    camera path and provide methods for additional processing, such as resizing and
    rotating its orientation.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得，在[第6章](ch06.html "第6章。太阳系")*太阳系*中，我们编写了一个`loadTexture`方法，该方法从项目的`res/drawable`文件夹中读取静态图像到内存位图，并将其绑定到OpenGL中的纹理。在这里，我们将做类似的事情，但是从手机的相机路径中获取图像，并提供额外处理的方法，例如调整大小和旋转方向。
- en: 'At the top of the `Image` class, add a variable to hold the current texture
    handle:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Image`类的顶部，添加一个变量来保存当前的纹理句柄：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The image''s `loadTexture` method, given a path to an image file, will load
    an image file into a bitmap and then convert it to a texture. (This method will
    be called from `MainActivity` with the app''s `CardboardView` class.) Write it
    as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图像的`loadTexture`方法，给定图像文件的路径，将图像文件加载到位图中，然后将其转换为纹理。（此方法将从`MainActivity`中的应用程序的`CardboardView`类中调用。）编写如下：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We added a small (but important) optimization, checking whether the texture
    has already been loaded; don't do it again if not needed.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个小的（但重要的）优化，检查纹理是否已经加载；如果不需要，就不要再次加载。
- en: 'Our implementation of `bitmapToTexture` is shown in the following code. Given
    a bitmap, it binds the bitmap to an OpenGL ES texture (with some error checking).
    Add the following code to `Image`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`bitmapToTexture`的实现如下所示。给定一个位图，它将位图绑定到OpenGL ES纹理（带有一些错误检查）。将以下代码添加到`Image`中：
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Showing an image on the screen
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在屏幕上显示图像
- en: Let's show one of our camera images in the app, say, the first one.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在应用程序中显示我们的相机图像之一，比如第一个。
- en: 'To show an image on the virtual screen, we can write a `show` method that takes
    the current `CardboardView` object and the `Plane` screen. It''ll load and bind
    the image texture and pass its handle to the material. In the `Image` class, implement
    the `show` method as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟屏幕上显示图像，我们可以编写一个`show`方法，该方法接受当前的`CardboardView`对象和`Plane`屏幕。它将加载和绑定图像纹理，并将其句柄传递给材质。在`Image`类中，实现`show`方法如下：
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now let''s use this stuff! Go to `MainActivity` and write a separate `showImage`
    method to load the image texture. And, temporarily, call it from `setup` with
    the first image that we find (you will need at least one image in your camera
    folder):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用这些东西！转到`MainActivity`并编写一个单独的`showImage`方法来加载图像纹理。然后，暂时从`setup`中调用它，使用我们找到的第一个图像（您的相机文件夹中至少需要一个图像）：
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It now also makes sense to modify `setupScreen,` so it creates the screen but
    doesn't load an image texture onto it. Remove the call to `screenMaterial.setTexture`
    in there.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在修改`setupScreen`也是有意义的，因此它创建屏幕但不在其上加载图像纹理。删除其中的`screenMaterial.setTexture`调用。
- en: 'Now run the app, and you will see your own image on the screen. Here''s mine:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行应用程序，您将在屏幕上看到自己的图像。这是我的：
- en: '![Showing an image on the screen](img/B05144_07_09.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![在屏幕上显示图像](img/B05144_07_09.jpg)'
- en: Rotating to the correct orientation
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 旋转到正确的方向
- en: Some image file types keep track of their image orientation, particularly JPG
    files (`.jpg` or `.jpeg`). We can get the orientation value from the EXIF metadata
    included with the file written by the camera app. (For example, refer to [http://sylvana.net/jpegcrop/exif_orientation.html](http://sylvana.net/jpegcrop/exif_orientation.html).
    Note that some devices may not be compliant or contain different results.)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一些图像文件类型会跟踪它们的图像方向，特别是JPG文件（`.jpg`或`.jpeg`）。我们可以从文件中包含的EXIF元数据中获取方向值，该元数据由相机应用程序编写。（例如，请参阅[http://sylvana.net/jpegcrop/exif_orientation.html](http://sylvana.net/jpegcrop/exif_orientation.html)。请注意，某些设备可能不符合规定或包含不同的结果。）
- en: If the image is not JPG, we'll skip this step.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果图像不是JPG，我们将跳过此步骤。
- en: 'At the top of the `Image` class, declare a variable to hold the current image
    rotation:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Image`类的顶部，声明一个变量来保存当前图像的旋转：
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `rotation` value is stored as a `Quaternion` instance, as defined in our
    RenderBox math library. If you remember [Chapter 5](ch05.html "Chapter 5. RenderBox
    Engine"), *RenderBox Engine*, a quaternion represents a rotational orientation
    in three-dimensional space in a way that is more precise and less ambiguous than
    Euler angles. But Euler angles are more human-friendly, specifying an angle for
    each *x*, *y*, and *z* axes. So, we''ll set the quaternion using Euler angles
    based on the image orientation. Ultimately, we use a `Quaternion` here because
    it is the underlying type of `Transform.rotation`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`rotation`值存储为`Quaternion`实例，如我们的RenderBox数学库中定义的那样。如果您还记得[第5章](ch05.html "第5章。RenderBox引擎")*RenderBox引擎*，四元数表示三维空间中的旋转方向，比欧拉角更精确和更不含糊。但是欧拉角更符合人类的习惯，指定每个*x*、*y*和*z*轴的角度。因此，我们将根据图像的方向使用欧拉角设置四元数。最终，我们在这里使用`Quaternion`，因为它是`Transform.rotation`的基础类型：'
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now we set the screen''s rotation in the `show` method of the `Image` class,
    as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`Image`类的`show`方法中设置屏幕的旋转，如下所示：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Run your project again. The image should be correctly oriented. Note that it
    is possible that your original image was fine all along. It will become easier
    to check whether your rotation code works once we get the thumbnail grid going.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行您的项目。图像应该被正确定向。请注意，您的原始图像可能一直都很好。一旦我们开始使用缩略图网格，检查旋转代码是否有效将变得更容易。
- en: '![Rotating to the correct orientation](img/B05144_07_10.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![旋转到正确的方向](img/B05144_07_10.jpg)'
- en: Dimensions to correct the width and height
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纠正宽度和高度的尺寸
- en: Square images are easy. But usually, photos are rectangular. We can get the
    actual width and height of the image and scale the screen accordingly, so the
    display won't show up distorted.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 方形图像很容易。但通常，照片是矩形的。我们可以获取图像的实际宽度和高度，并相应地缩放屏幕，以便显示不会出现扭曲。
- en: 'At the top of the `Image` class, declare variables to hold the current image
    width and height:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Image`类的顶部，声明变量来保存当前图像的宽度和高度：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, set them in `loadTexture` using bitmap options in the `decodeFile` method,
    as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`decodeFile`方法中使用位图选项设置它们，如下所示：
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `decodeFile` call returns the image's width and height (among other information)
    in the options (refer to [http://developer.android.com/reference/android/graphics/BitmapFactory.Options.html](http://developer.android.com/reference/android/graphics/BitmapFactory.Options.html)).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`decodeFile`调用将返回选项中的图像宽度和高度（以及其他信息）（参考[http://developer.android.com/reference/android/graphics/BitmapFactory.Options.html](http://developer.android.com/reference/android/graphics/BitmapFactory.Options.html)）。'
- en: 'Now we can set the screen size in the `show` method of the `Image` class. We''ll
    normalize the scale so that the longer side is of size 1.0 and the shorter one
    is calculated as the image aspect ratio:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在`Image`类的`show`方法中设置屏幕大小。我们将规范化比例，使得较长的一侧为1.0，较短的一侧根据图像纵横比计算：
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If you run it now, the screen will have the correct aspect ratio for the image:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在运行它，屏幕将具有图像的正确纵横比：
- en: '![Dimensions to correct the width and height](img/B05144_07_11.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![纠正宽度和高度的尺寸](img/B05144_07_11.jpg)'
- en: Sample image down to size
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将图像缩小到指定大小
- en: The camera in your phone is probably awesome! It's probably really mega awesome!
    Many-megapixel images are important when printing or doing lots of cropping. But
    for viewing in our app, we don't need the full resolution image. In fact, you
    might already be having trouble running this project if the image size generates
    a texture that's too big for your device's hardware.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您手机上的相机可能非常棒！它可能真的非常棒！当打印或进行大量裁剪时，百万像素图像非常重要。但是在我们的应用程序中查看时，我们不需要全分辨率图像。实际上，如果图像大小生成了对设备硬件来说太大的纹理，您可能已经在运行此项目时遇到了问题。
- en: 'We can accommodate this issue by constraining the maximum size and scaling
    our bitmaps to fit within these constraints when loading the texture. We will
    ask OpenGL ES to give us its current maximum texture size. We''ll do this in `MainActivity,`
    so it''s generally available (and/or move this into the `RenderBox` class in your
    `RenderBox` library project). Add the following to `MainActivity`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当加载纹理时，我们可以通过限制最大尺寸并将位图缩放到这些约束范围内来解决此问题。我们将要求OpenGL ES告诉我们当前的最大纹理尺寸。我们将在`MainActivity`中执行此操作，因此它通常是可用的（和/或将其移动到`RenderBox`库项目中的`RenderBox`类中）。将以下内容添加到`MainActivity`：
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We call it as the first line of the `setup` method of the `MainActivity` class.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其称为`MainActivity`类的`setup`方法的第一行。
- en: As for scaling the image, unfortunately, Android's `BitmapFactory` does not
    let you directly request a new size of a sampled image. Instead, given an arbitrary
    image, you can specify the sampling rate, such as every other pixel (2), every
    fourth pixel (4), and so on. It must be a power of two.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 至于缩放图像，不幸的是，Android的`BitmapFactory`不允许您直接请求采样图像的新大小。相反，对于任意图像，您可以指定采样率，例如每隔一个像素（2），每隔四个像素（4）等。它必须是2的幂。
- en: 'Back to the `Image` class. First, we will add a `sampleSize` argument to `loadTexture`,
    which can be used as an argument to `decodeFile`, as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`Image`类。首先，我们将在`loadTexture`中添加一个`sampleSize`参数，该参数可以用作`decodeFile`的参数，如下所示：
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: To determine an appropriate sample size for images, we need to first find out
    its full dimensions and then figure out what sample size will get it closest but
    less than the maximum texture size we're going to use. The math isn't too difficult,
    but instead of going through that, we'll use a procedural method to search for
    the best size value.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定图像的适当采样大小，我们首先需要找出其完整尺寸，然后找出哪个采样大小最接近但小于我们将使用的最大纹理尺寸。数学并不太困难，但我们将使用程序方法来搜索最佳大小值，而不是进行这样的搜索。
- en: 'Fortunately, one of the input options of `decodeFile` is to only retrieve the
    image bounds, and not actually load the image. Write a new load texture method
    named `loadFullTexture`, as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`decodeFile`的一个输入选项是仅检索图像边界，而不是实际加载图像。编写一个名为`loadFullTexture`的新加载纹理方法，如下所示：
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We keep bumping up the sample size until we find one that produces a bitmap
    within the `MAX_TEXTURE_SIZE` bounds, and then call `loadTexture`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不断增加采样大小，直到找到一个在`MAX_TEXTURE_SIZE`范围内生成位图的大小，并然后调用`loadTexture`。
- en: 'Use `loadFullTexture` in the `show` method instead of the other `loadTexture`
    one:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在`show`方法中使用`loadFullTexture`而不是其他的`loadTexture`：
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Run the project. It should look the same as the earlier one. But if your camera
    is too good, maybe it's not crashing like it was before.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目。它应该看起来与之前的一样。但是如果您的相机太好，也许它不会像以前那样崩溃。
- en: This sampling will also be useful to display thumbnail versions of the images
    in the user interface. There's no point in loading the full-sized bitmap for a
    thumbnail view.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这种采样还将有助于在用户界面中显示图像的缩略图版本。对于缩略图视图，加载全尺寸的位图没有意义。
- en: Loading and displaying a photosphere image
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载和显示全景图像
- en: So far, we've been handling all the images in the same manner. But some of them
    may be 360-degree images. These should be displayed on the photosphere and not
    on the virtual screen.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直以相同的方式处理所有图像。但其中一些可能是360度图像。这些应该显示在全景照片上，而不是虚拟屏幕上。
- en: If you do not have any 360-degree photos in your device's camera folder yet,
    you can create them using the Google Camera app.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的设备相机文件夹中还没有360度照片，可以使用Google相机应用程序创建它们。
- en: Note
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the default camera app on your phone does not include a **Photosphere** mode,
    you may need to download the Google Camera app from the Play Store. Third-party
    cameras might use a different name. For example, Samsung calls their photosphere
    feature **Surround Shot**.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您手机上的默认相机应用程序不包括**全景**模式，则可能需要从Play商店下载Google相机应用程序。第三方相机可能使用不同的名称。例如，三星将其全景功能称为**环绕拍摄**。
- en: Some images include the XMP metadata that will include information of whether
    the image is distorted for an equirectangular projection. This can be useful to
    distinguish spherical images from flat ones. However, the Android API doesn't
    include an XMP interface, so integrating XMP header parsing is beyond the scope
    of this book.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, we''ll just check whether the filename is prefixed with `PANO_`. Add
    the following variable to the `Image` class and set it in the constructor method:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We can now build the `MainActivity` show method to handle regular photos (displayed
    on the virtual screen) versus photospheres (displayed on the background sphere).
    Furthermore, it should handle switching between a flat image displayed on the
    virtual screen and rendering the photosphere and vice versa.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to remember the texture handle ID of the background photosphere texture.
    Add a `bgTextureHandle` handle at the top of the `MainActivity` class:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, set it in `setupBackground` by calling `getTexture`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now we can update the `showImage` method, as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: When the image is a photosphere, we set the background photosphere texture to
    the image and hide the screen plane. When the image is a regular photo, we set
    the background texture back to the default one and show the image on the virtual
    screen.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Until we implement the user interface (next) to test this, you will need to
    know which image in the images list is a photosphere. If you make a new photosphere
    now, it''ll be the last one in the list, and you can change the `setup` method
    to call `showImage` on it. For example, run the following code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Run the project again and be happy!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: The image gallery user interface
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we go ahead and implement a user interface for this project, let's talk
    about how we want it to work.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this project is to allow the user to select a photo from their
    phone's storage and view it in VR. The phone's photo collection will be presented
    in a scrollable grid of thumbnail images. If a photo is a normal 2D one, it'll
    be displayed on the virtual screen plane we just made. If it's a photosphere,
    we'll view it as a fully immersive 360-degree spherical projection.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: A sketch of our proposed scene layout is shown in the following diagram. The
    user camera is centered at the origin, and the photosphere is represented by the
    gray circle, which surrounds the user. In front of the user (determined by the
    calibration at launch), there will be a 5 x 3 grid of thumbnail images from the
    phone's photo gallery. This will be a scrollable list. To the left of the user,
    there is the image projection screen.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '![The image gallery user interface](img/B05144_07_12.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
- en: 'Specifically, the UI will implement the following features:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Displays up to 15 thumbnail images in a 5 x 3 grid.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows the user to select one of the thumbnail images by looking at it and then
    clicking on the Cardboard trigger. Thumbnails will be highlighted when in the
    sightline.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting a regular photo will display it on the virtual projection screen in
    the scene (and clear the photosphere to the background image).
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting a photosphere will hide the virtual projection screen and load the
    image into the photosphere projection.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows the user to scroll through thumbnail images by selecting the up/down
    arrows.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of our UI considerations are unique to virtual reality. Most importantly,
    all of the user interface elements and controls are in world coordinate space,
    That is, they're integrated into the scene as geometric objects with a position,
    rotation, and scale like any other component. This is in contrast with most mobile
    games where the UI is implemented as a screen space overlay.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Why? Because in VR, in order to create the stereoscopic effect, each eye has
    a separate viewpoint, offset by the interpupillary distance. This can be simulated
    in screen space by horizontally offsetting the position of screen space objects,
    so they appear to have a parallax (a technique we used in [Chapter 4](ch04.html
    "Chapter 4. Launcher Lobby"), *Launcher Lobby*). But when mixed with 3D geometry,
    camera, lighting, and rendering, that technique proves inadequate. A world space
    UI is required for an effective user experience and immersion.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Another feature that's unique to VR is gaze-based selection. In this case, where
    you look will highlight an image thumbnail, and then you click on the Cardboard
    trigger to open the image.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, as mentioned earlier, since we're working in world space and making
    selections based on where we're looking, the layout of our 3D space is an important
    consideration. Remember that we're in VR and not constrained by rectangular edges
    of a phone screen. Objects in the scene can be placed all around you. On the other
    hand, you don't want users twisting and turning all the time (unless that's an
    intended part of the experience). We'll pay attention to comfort zones to place
    our UI controls and image screen.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, Google and researchers elsewhere have begun to develop best practices
    for the user interface design, including the optimal distance for menus and UI
    controls from the camera, approximately 5 to 15 feet (1.5 to 5 meters). This distance
    is close enough to enjoy a 3D parallax effect but not so close to make you look
    cross-eyed to focus on the objects.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Okay, let's begin with the UI implementation.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Positioning the photo screen on the left
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Firstly, let''s move the screen from in front to the side, that is, rotate
    it 90 degrees to the left. Our transform math does the position after the rotation,
    so we now offset it along the *x* axis. Modify the `setupScreen` method of the
    `MainActivity` class, as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Displaying thumbnails in a grid
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A thumbnail is a mini version of the full image. Therefore, we don't need to
    load a full-sized texture bitmap. For the sake of simplicity, let's just always
    sample it down by 4 (to 1/16th the original size).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: The thumbnail image
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `Image` class, the `show` method loads the full texture. Let''s write
    a similar `showThumbnail` method that uses a smaller sampling. In the `Image`
    class, add the following code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The Thumbnail class
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new `Thumbnail` class for the project that will contain a small `Plane`
    object and an `Image` object to show on it. It also gets the current `cardboardView`
    instance, which `Image` will require:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Define a `setImage` method that loads the image texture and shows it as a thumbnail:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Lastly, make a quick toggle for the thumbnail visibility:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The thumbnail grid
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The plan is to display the phone photos in a 5 x 3 grid of thumbnail images.
    At the top of the `MainActivity` class, declare a `thumbnails` variable to hold
    the list of thumbnails:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Build the list in a new method named `setupThumbnailGrid`. The first thumbnail
    is positioned in the upper-left corner of the page (-4, 3, -5) and each thumb
    spaced 2.1 units in *x* and 3 units in *y*, as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now we need to add image textures to the planes. We''ll write another method,
    `updateThumbnails`, as follows. It will show the first 15 images in the grid (or
    less if you don''t have that many):'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Add these new methods to `setup`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'When you run the project, it should look something like this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '![The thumbnail grid](img/B05144_07_13.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
- en: Note that the thumbnails' sizes are adjusted to match the image aspect ratio,
    and are properly oriented, because we implemented those features in the `Image`
    class earlier.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you don''t have more than 15 photos already in your phone, add a loop to
    `loadImageList` to load duplicates. For example, run the following code:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Gaze to load
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to detect when the user looks at a thumbnail and highlight the image
    by changing its border color. If users move their gaze away from the thumbnail,
    it will unhighlight. When the user clicks on the Cardboard trigger, that image
    is loaded.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Gaze-based highlights
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fortunately, we implemented the `isLooking` detection in the `RenderBox` library
    at the end of [Chapter 5](ch05.html "Chapter 5. RenderBox Engine"), *RenderBox
    Engine*. If you remember, the technique determines whether the user is looking
    at the plane by checking whether the vector between the camera and the plane position
    is the same as the camera's view direction, within a threshold of tolerance.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this in `MainActivity`. We''ll write a `selectObject` helper method
    that checks whether any of the objects in the scene are selected and highlights
    them. First, let''s declare some variables at the top of the `MainActivity` class.
    The `selectedThumbnail` object holds the currently selected thumbnail index. We
    define border colors for normal and selected states:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now the `selectObject` method goes through each thumbnail, checks whether it''s
    `isLooking`, and highlights (or unhighlights) it accordingly:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`RenderBox` provides hooks, including `postDraw` where we''ll check for selected
    objects. We want to use `postDraw` because we need to wait until `draw` is called
    on all of `RenderObjects` before we know which one the user is looking at. In
    `MainActivity`, add a call to the `selectObject` method as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Run the project. As you gaze at a thumbnail image, it should get highlighted!
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Selecting and showing photos
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Well, now that we can pick an image from the thumbnail grid, we need a way to
    click on it and show that image. That'll happen in `MainActivity` using the Cardboard
    SDK hook, `onCardboardTrigger`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'With all the work we''ve done so far, it''s not going to take much more to
    implement this:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Try and run it. Now highlight an image and pull the trigger. If you're lucky,
    it'll work…mine crashes.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Queue events
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What's going on? We're running into thread-safe issues. So far, we've been executing
    all of our code from the render thread, which is started by the `GLSurfaceView`/`CardboardView`
    class via the Cardboard SDK. This thread owns the access to the GPU and to the
    particular surface we're rendering on. The call to `onCardboardTrigger` originates
    from a thread that is not the render thread. This means that we can't make any
    OpenGL calls from here. Luckily, `GLSurfaceView` provides a nifty way to execute
    arbitrary code on the render thread through a method called `queueEvent`. The
    `queueEvent` method takes a single `Runnable` argument, which is a Java class
    meant to create one-off procedures such as these (refer to [http://developer.android.com/reference/android/opengl/GLSurfaceView.html#queueEvent(java.lang.Runnable](http://developer.android.com/reference/android/opengl/GLSurfaceView.html#queueEvent(java.lang.Runnable)).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify `showImage` to wrap it inside a `Runnable` argument, as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note that any data passed to the anonymous class, such as our image, must be
    declared `final` to be accessible from the new procedure.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Try to run the project again. It should work. You can gaze at a thumbnail, click
    on the trigger, and that image will be shown, either on the virtual screen or
    in the background photosphere.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Using a vibrator
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No worries, we're keeping it clean. We want to provide some haptic feedback
    to the user when an image has been selected, using the phone's vibrator. And fortunately,
    in Android, that's straightforward.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'First, make sure that your `AndroidManifest.xml` file includes the following
    line of code:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'At the top of the `MainActivity` class, declare a `vibrator` variable:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then, in `onCreate`, add the following code to initialize it:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Then, use it in `onCardboardTrigger`, as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Run it again. Click on it and you'll feel it. *Ahhh!* But don't get carried
    away, it's not that kind of vibrator.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Enable scrolling
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our thumbnail grid has 15 images. If your phone has more than 15 photos, you'll
    need to scroll through the list. For this project, we'll implement a simple mechanic
    to scroll the list up and down, using triangular scroll buttons.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Triangle component
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like other `RenderObjects` in our `RenderBox`, the `Triangle` component defines
    coordinates, normals, indices, and other data that describes a triangle. We create
    a constructor method that allocates buffers. Like the `Plane` component, we want
    to use the `BorderMaterial` class so that it can be highlighted when selected.
    And like the `Plane` component, it will determine when the user is looking at
    it. Without further ado, here's the code.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Java class file, `Triangle.java`, in the `RenderBoxExt/components`
    folder. We begin by declaring it `extends RenderObject` and by declaring the following
    variables:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In case it's not clear as to why we need this 2-triangle triangle, it has to
    do with how the UVs work. You can't get a full border with just one triangle,
    at least not the way we've written the border shader.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a constructor, along with an `allocateBuffers` helper:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We can create various materials, but we really only plan to use `BorderMaterial`,
    so let''s support this like we did with `Plane`:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Adding triangles to the UI
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In `MainActivity`, we can add the `up` and `down` triangle buttons to scroll
    the thumbnails. At the top of the `MainActivity` class, declare variables for
    the triangles and their materials:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Define a `setupScrollButtons` helper as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Then, call it from the `setup` method:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'When you run the project, you will see the arrows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding triangles to the UI](img/B05144_07_14.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
- en: Interacting with the scroll buttons
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we will detect when the user is looking at a triangle, by using `isLooking`
    in `selectObject` (which is called from the `postDraw` hook):'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Implementing the scrolling method
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To implement scrolling the thumbnail images, we''ll keep the grid planes in
    place and just scroll the textures. Use an offset variable to hold the index of
    the first image in the grid:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, modify the `updateThumbnails` method to populate the plane textures using
    the thumb offset as the starting index of the image textures:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We can perform scrolling when the up or down arrows are pressed in `onCardboardTrigger`
    by shifting the `thumbOffset` variable one row at a time (`GRID_X`):'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'As with `showImage`, the `updateThumbnails` method needs to run on the render
    thread:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Run the project. You can now click on the up and down arrows to scroll through
    your photos.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Stay responsive and use threads
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few problems with our loading and scrolling code, all related to
    the fact that loading images and converting bitmaps is compute-intensive. Attempting
    to do this for 15 images all at once causes the app to appear frozen. You may
    have also noticed that the app takes significantly longer to start up since we
    added the thumbnail grid.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: In conventional apps, it might be annoying but somewhat acceptable for the app
    to lock up while waiting for data to load. But in VR, the app needs to stay alive.
    The app needs to continue responding to the head movement and update the display
    for each frame with a view corresponding to the current view direction. If the
    app is locked while loading files, it will feel stuck, that is, stuck to your
    face! In a fully immersive experience, and on a desktop HMD that is strapped on,
    visual lockup is the most severe cause of nausea, or *sim sickness*.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is a worker thread. The key to successful multithreaded support
    is providing the ability for the procedures to signal each other with semaphores
    (Boolean flags). We''ll use the following:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '`Image.loadLock`: This is true when waiting for the GPU to generate a texture'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MainActivity.cancelUpdate`: This is true when the thread should stop due to
    a user event'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MainActivity gridUpdateLock`: This is true when the grid is updating; ignore
    other user events'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s declare these. At the top of the `Image` class, add the following code:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'At the top of the `MainActivity` class, add the following:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: First, let's identify the compute-intensive part of our code. Feel free to do
    your own investigation, but let's assume that `BitmapFactory.decodeFile` is the
    culprit. Ideally, any code that wasn't directly related to rendering should be
    done on a worker thread, but beware of pre-optimization. We're doing this work
    because we've noticed an issue, so we should be able to identify the new code
    which is causing it. An educated guess points to this business of loading arbitrary
    images into textures.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Where do we do this operation? Well, the actual call to `BitmapFactory.decodeFile`
    comes from `Image.loadTexture`, but more generally, all of this is kicked off
    in `MainActivity.updateGridTextures` and `MainActivity.showImage`. Let's update
    these last two functions now.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'Lucky for us, `showImage` has already been wrapped in `Runnable` for the purpose
    of redirecting its execution to the render thread. Now we want to actually ensure
    that it always happens off the render thread. We''ll be using `queueEvent` in
    a different place to avoid the error that we encountered earlier. We replace the
    previous `Runnable` code with `Thread`. For example, `showImage` now looks like
    this:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Do the same to `updateThumbnails`. While we''re here, add the `gridUpdateLock`
    flag that remains set while it''s running, and handle the `cancelUpdate` flag,
    so the loops can be interrupted:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Focusing on the `Image` class''s `loadTexture` method, we need to redirect
    the GPU calls back to the render thread with `queueEvent`. If you try to run the
    app now, it will crash right out of the gate. This is because `showImage` is now
    always run in its own thread, and when we eventually make the OpenGL calls to
    generate the texture, we''ll get the invalid operation error that we got earlier
    when we added the trigger input. To fix this, modify `loadTexture` as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We changed it so that `bitmapToTexture` is now called on the GPU thread. We
    use the `loadLock` flag to indicate that the loading is busy. When it's done,
    the flag is reset. Meanwhile, `loadTexture` waits for it to finish before returning
    because we need this `textureHandle` value for later. But since we're always calling
    this from a worker thread, the app isn't hung waiting. This change will also improve
    the start-up time.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we do the same thing in the `Thumbnail` class; its `setImage` method
    also loads the image texture. Modify it so that it looks like this:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'You might have noticed a subtler issue in all of this. If we try to close the
    app in the middle of one of these worker thread operations, it will crash. The
    underlying issue is that the thread persists, but the graphics context has been
    destroyed, even if you are just switching apps. Trying to generate textures with
    an invalid graphics context results in a crash, and the user gets little notification.
    Bad news. What we want to do is stop the worker thread when the app closes. This
    is where `cancelUpdate` comes into play. In `MainActivity`, we''ll set its value
    in the `onCreate` method, and add the methods to the `onStart`, `onResume`, and
    `onPause` hook methods, as follows:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'If you try to click on something while the grid is updating, it shouldn''t
    let you to do so. Add the following code to the top of `onCardboardTrigger`:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This new `long[]{0,50,30,50}` business is a way of programming a sequence into
    the vibrator. In this case, two short (50 milliseconds) pulses in a row are used
    to indicate the nuh-uh reaction.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'We can even go one beautiful step further and highlight selectable objects
    in `selectObject` with a disabled color during `gridUpdateLock` like this:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Your project should run as before. But now it's more responsive, better behaved,
    and doesn't get stuck waiting for images to load.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: An explanation of threading and virtual reality
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenGL is not thread-safe. This sounds like a design flaw. In reality, it's
    more like a design requirement. You want your graphics API to draw frames as quickly
    and frequently as possible. As you may know, or will soon learn, waiting is something
    that threads end up doing a lot of the time. If you introduce multithreaded access
    to your graphics hardware, you introduce periods where the hardware might be waiting
    on the CPU simply to figure out its thread scheduling and who needs access at
    the time. It's much simpler and faster to say "only one thread may access the
    GPU." Technically speaking, as graphics APIs become more advanced (DirectX 12
    and Vulkan), this is not strictly true, but we will not be getting into multithreaded
    rendering in this book.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: Let's first take a step back and ask the question, "Why do we need to use threads?"
    To some of you who are more experienced application developers, the answer should
    be obvious. But not all programmers need to use threads, and, even worse, many
    programmers use threads inappropriately, or when they aren't needed in the first
    place. For those of you still in the dark, a thread is a fancy term for "a way
    to run two procedures at the same time." On a practical level, the operating system
    takes control of scheduling threads to run one after another, or on different
    CPU cores, but as programmers, we assume that all threads are running "simultaneously."
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Incidentally, while we are only allowed one CPU thread to control the GPU, the
    whole point of a GPU is that it is massively multithreaded. Mobile GPUs are still
    getting there, but high-end Tegra chips have hundreds of cores (currently, the
    X1 is at 256 cores), lagging behind their desktop equivalents with thousands of
    cores (Titan Black @ 2880 cores). A GPU is set up to process each pixel (or other
    similar small datum) on a separate thread, and there is some hardware magic going
    on that schedules all of them automatically with zero overhead. Think of your
    render thread as a slow taskmaster instructing a tiny army of CPUs to do your
    bidding and report back with the results, or in most cases, just draw them right
    to the screen. This means that the CPU is already doing a fair amount of waiting
    on behalf of the GPU, freeing your other worker threads to do their tasks and
    then wait when there is more CPU render work to be done.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Threads are generally useful when you want to run a process which will take
    a while, and you want to avoid blocking the program's execution, or main, thread.
    The most common place where this comes up is starting a background process and
    allowing the UI to continue to update. If you're creating a media encoder program,
    you don't want it to be unresponsive for 30 minutes while it decodes a video.
    Instead, you'd like the program to run as normal, allowing the user to click on
    buttons and see progress updates from the background work. In this scenario, you
    have to let the UI and background threads take a break now and then to send and
    check messages passed between the two. Adjusting the length of the break, or sleep
    time, and thread priority values allows you to avoid one thread hogging too much
    CPU time.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Back to OpenGL and graphics programming. It is common in a game engine to split
    the work into a few, distinct threads (render, physics, audio, input, and so on).
    However, the render thread is always a kind of *orchestrator* because rendering
    still tends to be the most time-sensitive job and must happen at least 30 times
    per second. In VR, this constraint is even more important. We're not worried about
    physics and audio, perhaps, but we still need to make sure that our renderer can
    draw things as quickly as possible, or the feeling of presence is lost. Furthermore,
    we can never stop rendering, as long as the person is looking at the screen. We
    need threads to avoid "hiccups" or unacceptably long periods between render frames.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Head tracking is essential to a VR experience. A person who is moving their
    head, looking only at a fixed image, will start to experience nausea, or *simsickness*.
    Even some text on a black background, if it is not compensated by some sort of
    fixed horizon, will eventually cause discomfort. Sometimes, we do have to block
    the render thread for significant periods of time, and the best option is to first
    fade the image to a solid color, or void. This can be comfortable for a short
    period of time. The worst thing that can happen in VR is periodic hiccups or frame
    rate drops due to extensive work being done on the render thread. If you don't
    maintain a constant, smooth, frame rate, your VR experience is worthless.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we need to decode a series of rather large bitmaps and load them
    into GPU textures. Unfortunately, the decode step takes a few hundred milliseconds
    and causes those hiccups we were just talking about. However, since this isn't
    GPU work, it doesn't have to happen on the render thread! If we want to avoid
    any heavy lifting in our `setup()`, `preDraw()`, and `postDraw()` functions, we
    should create a thread any time that we want to decode a bitmap. In the case of
    updating our grid of previews, we should probably just create a single thread,
    which can run the whole update process, waiting in between each bitmap. In the
    CPU land, the OS needs to use some resources to schedule threads and allocate
    their resources. It's much more efficient to just create a single thread to run
    through the entire job, rather than spinning up and taking down a thread for each
    bitmap.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we're going to need to make use of our old friend `queueEvent` in
    order to do any graphics work, in this case generating and loading the texture.
    As it turns out, updating the display of the image is not graphics work, since
    it just involves changing a value on our material. We do, however, need to wait
    on the graphics work in order to get this new value. As a result of these optimizations
    and constraints, we need a locking system in order to allow one thread to wait
    on the others to finish its work, and to prevent the user from interrupting or
    restarting this procedure before it has completed. This is what we just implemented
    in the previous topic.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Launch with an intent
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wouldn't it be cool if you could launch this app any time you go to view an
    image on your phone, especially 360-degree photospheres?
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: One of the more powerful features of the Android operating system is the ability
    to communicate between apps with intents. An **intent** is a message that any
    app can send to the Android system, which declares its intent to use another app
    for a certain purpose. The intent object contains a number of members to describe
    what type of action needs to be done, and, if any, the data on which it needs
    to be done. As a user, you may be familiar with the default action picker, which
    displays a number of app icons, and the choices, **Just Once**, or **Always**.
    What you're seeing is the result of the app you were just using broadcasting a
    new intent to the system. When you choose an app, and Android launches a new activity
    from that app, which has been registered to respond to intents of that type.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `AndroidManifest.xml` file, add an intent filter to the activity block.
    Let Android know that the app can be used as an image viewer. Add the following
    XML code:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'We just need to handle the situation so an intent image is the default image
    loaded when the app starts. In `MainActivity`, we''ll write a new function that
    shows an image given its URI, as follows. The method gets the URI path and translates
    it into a file pathname, calls the new `Image` object on that path, and then the
    `showImage` method. (For reference, visit [http://developer.android.com/guide/topics/providers/content-provider-basics.html](http://developer.android.com/guide/topics/providers/content-provider-basics.html)):'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Then, add a call to `showUriImage` from `setup`, as follows:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: We've also added a call to `BorderMaterial.destroy()` since the intent launches
    a second instance of the activity. If we don't destroy the materials, the new
    activity instance, which has its own graphics context, will throw errors when
    it tries to use shaders compiled on the first activity's graphics context.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: Now with the project built and installed on the phone, when you choose an image
    file, for example, from a file folder browser app such as **My Files** (Samsung),
    you're given a choice of apps with an intent to view images. Your Gallery360 app
    (or whatever you have actually named it) will be one of the choices, as shown
    in the following screenshot. Pick it and it will launch with that image file view
    as the default.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '![Launch with an intent](img/B05144_07_15.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
- en: Showing/hiding the grid with tilt-up gestures
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back in the early days of Cardboard, you had one button. That was all. The one
    button and head tracking were the only ways for the user to interact with the
    app. And because the button was a nifty magnet thing, you couldn't even press
    and hold the one button. With Cardboard 2.0, the screen turned into the button,
    and we also realized that we could briefly take the box off of our face, tilt
    the phone up, put it back on, and interpret that as a gesture. Thus, a second
    input was born! At the time of writing, the sample Cardboard apps use this as
    a back gesture.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: We will be using tilt-up to show and hide the grid and arrows so that you can
    fully immerse yourself in the selected photosphere. Since it's less work, we'll
    also let the user do this anytime, and not just while looking at photospheres.
    As with the vibration feedback, this is actually a pretty painless feature to
    add. Most of the hard work is done by an `OrientationEventListener` class.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the `MainActivity` class, add a variable for the state of the
    grid, the orientation event listener, and ones for a tilt detection timer, as
    follows:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'First, we can write a method that toggles the thumbnail grid menu on/off. Check
    whether there are less images than planes since empty ones are already disabled
    in `updateThumbnails`:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Next, write a `setupOrientationListener` helper method, which provides a callback
    function when the device orientation changes. If the orientation gets close to
    vertical after being in landscape mode, we can call our toggle function, and once
    the device returns to landscape and goes vertical again, we toggle again:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Then, add it to `onCreate`:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The `setupComplete` flag prevents the grid from being toggled while it is still
    being created. Let''s reset the complete flag after `updateThumbnails`:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'It''s prudent to destroy it in `onDestroy`:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The `onOrientationChanged` callback will fire whenever the phone changes orientation.
    We'll only be interested in the times when it changes from landscape to portrait,
    and we also want to make sure that it doesn't happen too often, hence the **tilt
    damper** feature. You might want to tweak the value (currently 250 milliseconds)
    to your liking. Too short, and you might falsely register two changes in a row.
    Too long, and the user might try to tiltup twice within the cutoff time.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: Spherical thumbnails
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spherical 360-degree images deserve better than a plain ol' paint-chip thumbnail
    images, don't you think? I suggest that we display them as small balls. Maybe
    we should call them thumb-tips or thumb-marbles. Anyway, let's do a little hacking
    to make this happen.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: Add a sphere to the Thumbnail class
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `Thumbnail` class, add a `sphere` variable:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Modify `setImage` to recognize a photosphere image:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'We must also change `setVisible` to handle both the `plane` and `sphere` variables,
    as follows:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Next, in the `MainActivity` class''s `setupThumbnailGrid`, initialize a `Sphere`
    object in addition to a `Plane` object (inside the `GRID_Y` and `GRID_X` loops):'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Now the thumbnails have both a plane and a sphere that we can populate depending
    on the image type.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we just need to modify the `selectObject` method to see how we highlight
    a sphere thumbnail. We highlight the rectangular ones by changing the border color.
    Our spheres don't have a border; in lieu of that we'll change their size.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of `MainActivity`, add variables to the normal and selected scales:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Now, change `selectObject` to behave differently when the image is a photosphere:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Whoo hoo! We even have the sphere spinning, so you can see its 360-ness in all
    its glory! This is so much fun, it should be illegal.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '![Add a sphere to the Thumbnail class](img/B05144_07_16.jpg)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
- en: There you have it! A beautiful photo viewer app that supports both regular camera
    images as well as 360-degree photospheres.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: Updating the RenderBox library
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the Gallery360 project implemented and our code stabilized, you might realize
    that we've built some code that is not necessarily specific to this application
    that can be reused in other projects, and ought to make its way back to the `RenderBox`
    library.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'We did this at the end of the previous project in [Chapter 6](ch06.html "Chapter 6. Solar
    System"), *Solar System*. You can refer to that topic for details. Follow these
    steps to update the `RenderBoxLib` project:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: Move the `Plane` and `Triangle` components from `RenderBoxExt/components`.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the `BorderMaterial` component from `RenderBoxExt/materials`.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the border shader files from `res/raw`.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refactor any invalid references to correct the package names.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rebuild the library by clicking **Build** | **Make Project**.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further possible enhancements
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whew, that was a lot of work! This thing is certainly done, isn''t it? *Never!*
    Here are a few improvements just begging to be implemented:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: 'Better detection of phone images:'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not everyone keeps all of their images in a specific path. In fact, some camera
    software uses completely different paths! Introduce a proper file browser.
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Better detection of photosphere images:'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is a `Projection Type` attribute in the XMP header, another piece of
    metadata in some JPG files. Unfortunately, the Android API doesn''t have a specific
    class to read this data, and integrating a third-party library is beyond the scope
    of this project. Feel free to try the following links:'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/dragon66/pixymeta-android](https://github.com/dragon66/pixymeta-android)'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/drewnoakes/metadata-extractor](https://github.com/drewnoakes/metadata-extractor)'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: Don't use the pano technique because it picks up regular panoramas. Allow users
    to flag or fix photosphere or rotation metadata on images that are displayed incorrectly.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: Animate UI actions—scale/translate on select, smooth grid scrolling.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A nifty technique to keep grid tiles from showing up behind the up/down arrows
    is known as **depth masking**. You can also just introduce a maximum and minimum
    Y value in the world space beyond which tiles would not be able to draw. But depth
    masks are cooler.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Respond to the `GALLERY` intent to override the grid with a selection of images
    from another app.
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accept image URLs from the web in `VIEW` intents.
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to first download the image, and then load it from the download path.
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope you're as excited as I am with what we accomplished here! We built a
    truly practical Cardboard VR app to view a gallery of regular photos and 360-degree
    photospheres. The project uses the `RenderBox` library, as discussed in [Chapter
    5](ch05.html "Chapter 5. RenderBox Engine"), *RenderBox Engine*.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, we illustrated how photospheres work and viewed one on Cardboard
    using the `RenderBox` library without any custom changes. Then, to view a regular
    photo, we created a `Plane` component to be used as a virtual projection screen.
    We wrote new materials and shaders to render images with a frame border.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: Next, we defined a new `Image` class and loaded images from the phone's camera
    folder into a list, and wrote a method to show the image on the screen `Plane`,
    correcting its orientation and aspect ratio. Then, we built a user interface that
    shows a grid of thumbnail images and lets you select one by gazing at it and clicking
    on the Cardboard trigger to display the image. The grid is scrollable, which required
    us to add threading, so the app would not appear to lock up when files are loading.
    Lastly, we added a couple of bells and whistles to launch the app with the image
    view intent, toggle the menu grid by tilting the phone vertically, and spherical
    thumbanils for photospheres.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll build another kind of viewer; this time to view full
    3D models in OBJ files.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
