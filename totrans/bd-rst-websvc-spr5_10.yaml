- en: Building a REST Client and Error Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we covered the server side of RESTful web services including
    CRUD operations. Here, we can check how to consume those APIs in the code itself.
    The REST client will help us to achieve this goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: RestTemplate in Spring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic setup for building a RESTful service client with Spring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling a RESTful service in the client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the error handler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the error handler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a REST client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have created a REST API and consumed it in third-party tools such
    as SoapUI, Postman, or JUnit testing. There might be situations where you will
    have to consume a REST API using the regular method (service or another controller
    method) itself like payment API call in service API. It will be useful when you
    call a third-party API such as PayPal or a weather API in your code. In such situations,
    having a REST client will be helpful for getting the job done.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will talk about how to build a REST client to consume another REST
    API in our method. Before moving onto that, we will talk a little bit about `RestTemplate`
    in Spring.
  prefs: []
  type: TYPE_NORMAL
- en: RestTemplate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`RestTemplate` is a Spring class that is used to consume the REST API from
    the client side through HTTP. By using `RestTemplate`, we can keep the REST API
    consumer in the same application as well, so we don''t need a third-party application
    or another application to consume our API. `RestTemplate` can be used use to call
    `GET`, `POST`, `PUT`, `DELETE`, and other advanced HTTP methods (`OPTIONS`, `HEAD`).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the `RestTemplate` class relies on JDK to establish HTTP connections.
    You can switch to using a different HTTP library such as Apache HttpComponents
    and Netty.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will add a `RestTemplate` bean configuration in the `AppConfig` class.
    In the following code, we will see how the `RestTemplate` bean can be configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have mentioned this class with `@Configuration` annotation
    to configure all the beans inside the class. We have also introduced the `RestTemplate`
    bean in this class. By configuring the bean in the `AppConfig` class, we tell
    the application that the mentioned bean can be used in any place in the application.
    When the application starts, it is automatically initializing the bean and is
    ready to use the template wherever needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can use `RestTemplate` by simply using the `@Autowire` annotation in
    any class. For a better understanding, we have created a new class called `ClientController`
    and added a simple method in the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we used `RestTemplate` and called the `getForObject`
    method to consume the API. By default, we used `String.class` to keep our code
    simple to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you call this API `http://localhost:8080/client/test/`, you will get the
    following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding process, we have used `RestTemplate` inside another REST API.
    In a real-time scenario, you might use the same method that you used to call the
    third-party REST API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get a single user API inside another method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: By calling the preceding API, you will get the single user as a result. In order
    to call this API, our `User` class should be serialized, otherwise you might get
    an unserialized object error. Let's make our `User` class serialized by implementing
    `Serializable` and adding a serial version ID.
  prefs: []
  type: TYPE_NORMAL
- en: You can create a serial version ID in Eclipse by right-clicking on the class
    name and generating a serial number.
  prefs: []
  type: TYPE_NORMAL
- en: 'After serializing the `User` class, it will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can call the `http://localhost:8080/client/test/user` client API
    in the browser and get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We have used only the `GET` method for ease of understanding. However, we can
    use the `POST` method and `add` parameters in the REST consumer.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in our application, we haven't defined any specific error handler to
    catch the error and convey it to the right format. Usually when we deal with an
    unexpected situation in REST APIs, it will automatically throw an HTTP error such
    as `404`. Errors such as `404` will show explicitly in the browser. This is fine
    normally; however, we might need a JSON format result regardless of whether things
    go right or wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Converting the error into JSON format would be a nice idea in such cases. By
    providing the JSON format, we can keep our application clean and standardized.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will discuss how to manage errors and display them in JSON format
    when things go wrong. Let''s create a common error handler class to manage all
    of our errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding class will act as a common error handler in our application. In
    the `ErrorHandler` class, we have created a single method called `handleException`
    with the `@ExceptionHandler` annotation. This annotation will make the method
    receive all exceptions in the application. Once we get exceptions, we can manage
    what to do based on the type of exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our code, we have used only two situations to manage our exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: Missing parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: General error (everything else other than missing parameter)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we miss a parameter when calling any REST API, it will go to the first situation,
    `Parameter Missing`, or else it will go to the `Generic Error` default error.
    We have simplified the process to make it understandable for new users. However,
    we can add more cases in this method to manage more exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have finished the error handler, we will have to use it in our application.
    Applying the error handler can be done in many ways. Extending the error handler
    is the simplest way to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we just extended `ErrorHandler` in the `HomeController`
    class. By doing so, we are binding all error scenarios to `ErrorHandler` to receive
    and handle properly. Also, we have created a test method called `testError` to
    check our error handler.
  prefs: []
  type: TYPE_NORMAL
- en: In order to call this API, we need to pass `item` as a parameter; otherwise
    it will throw an error in the application. As we have already defined the `ErrorController`
    class and extended the `HomeController` class, missing the parameter will take
    you to the first scenario mentioned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just try the following URL in your browser or any REST client (Postman/SoapUI):
    `http://localhost:8080/test/error`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try the preceding endpoint, you will get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As we have defined the JSON format in our error handler, if any REST API throws
    an exception, we will get the error in JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: Customized exception
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have only explored application-thrown errors. However, we can define
    our own errors and throw them if needed. The following code will show you how
    to create a customized error and throw it in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we created a custom exception by using `RuntimeException`.
    This is just test code to show you how a customized exception works in error handling.
    We will apply this customized exception in our application in upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you call the `http://localhost:8080/test/error/1` API, you will get an error
    like the one that follows, which is caused by our condition match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned to build a RESTful web service client using `RestTemplate`.
    Also, we covered error handlers and centralized error handlers to handle all error-prone
    scenarios. In upcoming chapters, we will discuss scaling our Spring application
    and talk a little bit about microservices as those topics are growing rapidly.
  prefs: []
  type: TYPE_NORMAL
