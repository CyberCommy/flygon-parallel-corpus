- en: Chapter 9. Tagging, Sharing, and Liking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 8](part0054.xhtml#aid-1JFUC1 "Chapter 8. Creating Pages and Events"),
    *Creating Pages and Events*, was about creating pages and attaching events to
    them. We also made the posting of comments possible. In this part of the book,
    we will add three new features. Almost every social network contains some way
    to like a post. It is a nice way to rank the posts that you are interested in.
    Sharing is another popular process that comprises of posting an already existing
    post. Sometimes, we want to refer a post to some of our friends. In these cases,
    we **tag** people. These three functionalities will be implemented in this chapter.
    Here are the sections that will guide us through the development process:'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting friends and sending their IDs to the backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing the tagged users and displaying them in the user's feed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing a post
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Liking posts and counting the number of likes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing the number of likes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting friends and sending their IDs to the backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start with the tagging of not only random users but also the friends
    of the current user. The functionality that we want to build will be placed on
    the home page. The form that creates a new post will contain a list of checkboxes.
    The very first step will be to fetch the friends from the API. In [Chapter 6](part0046.xhtml#aid-1BRPS2
    "Chapter 6. Adding Friendship Capabilities"), *Adding Friendship Capabilities*,
    we already did that. We have a `models/Friends.js` file that queries the Node.js
    server and returns a list of users. So, let''s use it. At the top of `controllers/Home.js`,
    we will add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Later, in the `onrender` handler, we will use the required module. The result
    of the API will be set as a value to a local `friends` variable in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The controller has the user''s friends in its data structure, and we may update
    the template. We will make a loop through the records and display a checkbox for
    every user in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The Ractive.js framework nicely handles groups of checkboxes. In our case, the
    JavaScript component will receive a variable called `taggedFriends`. It will be
    an array of the selected users or an empty array if the user does not tick anything.
    The expected output is a list of the user's friends in the form of checkboxes
    and labels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Gulp compiles the new version of the template and we hit the refresh button
    of the browser, we will see our friends on the screen. We will select some of
    them, fill the content of the post, and press the **Post** button. The application
    sends a request to the API but without the tagged friends. One more change is
    needed to fix that. In the `controllers/Home.js` file, we have to use the value
    of the `taggedFriends` variable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The FormData API accepts only Blob, file, or string values. We cannot send an
    array of strings. So, we will serialize `taggedFriends` to a string using `JSON.stringify`.
    In the next section, we will use `JSON.parse` to convert the string to an object.
    The `JSON` interface is available in both the browser and Node.js environments.
  prefs: []
  type: TYPE_NORMAL
- en: Storing the tagged users and displaying them in the user's feed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Along with the text and files, we now send a list of user IDs—users that should
    be tagged in the post. As mentioned before, they come to the server in the form
    of a string. We need to use `JSON.parse` to convert them into a regular array.
    The following lines are part of the `backend/api/content.js` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `content.js` module is the place where `formidable` provides the data sent
    by the frontend. At the end of this code snippet, we reconstructed the array from
    the previously serialized string.
  prefs: []
  type: TYPE_NORMAL
- en: We can easily go with only that change and store the `data` object. Indeed,
    in the client side, we will receive the post containing the `taggedFriends` property.
    However, we are interested in showing the names of the friends and not their IDs.
    If the frontend controller has IDs and needs names, then it should perform another
    HTTP request to the API. This will probably lead to a large number of API queries,
    especially if we have many messages displayed. To prevent such a situation, we
    will fetch the names of the tagged people during the fetching of the post in the
    backend. This approach has its own disadvantages, but it is still better compared
    to the variant mentioned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a function that wraps the needed logic and use it before saving
    the information in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We prepared the IDs of the users for the MongoDB query. In this case, the `$in`
    operator is needed because we want to fetch the records of the IDs that match
    any of the items in the `ids` array. When the MongoDB driver returns the data,
    we create another array that contains the names of the friends. `GetFriendsProfiles`
    will be used in the next few pages, where we will update the posts' feed fetching.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual storing of the data is still the same. The only difference is that
    the `data` object now contains the `taggedFriends` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If we create a new post and check the record in the database, we will see something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s update the fetching of the database records. We have the IDs of
    our friends, but we need their names. So, in the same `content.js` file, we will
    place the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We have the items from the database in the `results` array. The looping through
    the posts is still the same but doesn't send the response after the `forEach`
    call. For every post in the list, we need to send a request to the MongoDB database
    and get the name of the friends. So, we will initialize the `numberOfPosts` variable,
    and every time the request for the friend's name is finished, we will decrease
    the value. Once it gets to 0, we know that the last post is processed. After this,
    we will send the response to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a small update of the `frontend/tpl/home.html` file that will make
    the `taggedFriends` array visible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Along with the owner, the text, and the picture (if any), we check whether
    there are any tagged people. If there are any tagged people, then we join all
    the elements of the `taggedFriends` array with the given separator. The result
    looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Storing the tagged users and displaying them in the user''s feed](img/image00182.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Sharing a post
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sharing function of our application will give an option to the current
    user to republish an already created post. We should make sure that the user does
    not share his/her own records. So, let''s start from there. The API returns the
    posts and knows who created them. It also knows which user is making the request.
    The following code creates a new property called `ownPost`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is the logic that prepares the posts and sends them to the browser. The
    `getCurrentUser` property returns the user that is currently making the requests.
    The `user._id` variable is exactly what we need. This ID is actually assigned
    to the `userId` property for every post. So, we will simply compare them and determine
    whether the sharing is allowed or not. If the `ownPost` variable is equal to `true`,
    then the user should not be able to share the post.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, we added a new markup to display the tagged friends.
    The space below them seems like a good place to place a **Share** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, the new `ownPost` property comes into use. If the post is not made by
    the current user, then we will show the button that dispatches the `share` event.
    Ractive.js gives us an opportunity to send data along with the event. In our case,
    this is the ID of the post.
  prefs: []
  type: TYPE_NORMAL
- en: 'The controller of the home page should listen to this event. A quick update
    of `controllers/Home.js` adds the listener, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `model` object is an instance of the `ContentModel` class. The sharing
    is a new feature. So, we need to send queries to a different API endpoint. The
    new `sharePost` method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We used some code that is similar to the preceding one many times in the previous
    chapter. It sends a `POST` request to the backend at a specific URL. Here, the
    URL is `/api/content/share`. It is also important to mention that `formData` contains
    the ID of the post that we want to share.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue and make the necessary changes in the API. We already defined
    the URL that will host this functionality—`/api/content/share`. A new route in
    `backend/API.js` is needed, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step involves the creation of the `content-share` controller. Like
    every other controller, we will start with requiring the helpers. We will skip
    this part and jump directly to the processing of the `POST` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding method expects a `postId` variable. If there is no such variable,
    then we will respond with an error. The rest of the code again involves the usage
    of the `formidable` module and the defining of a `done` function to send a response
    for a successful operation. Here is the more interesting part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After finding the post that should be shared, we will prepare an object that
    will be saved as a new record. We need to perform a few operations on the original
    post:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We surely do not need the `_id` property. MongoDB will create a new one. The
    third line defines a `via` property. We will talk about this in a minute, but
    in short, it is used to display the original author of the post. The lines after
    `via` set the owner of the new record. The date is also changed, and since this
    is a new post, we clear the `taggedFriends` array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The shared post is now in the database and it is displayed in the users'' feeds.
    Let''s use the `via` property and show the original creator of the post in the
    following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We will check whether the variable is available and if it is, then we will
    add a small text below the text of the post. The result will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sharing a post](img/image00183.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Liking posts and counting the number of likes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The users of our social network should be able to see a **Like** button. By
    clicking on it, they will send a request to the API and our task is to count these
    clicks. Of course, only one click per user is allowed. As in the previous section,
    we will start by updating the user interface. Let''s add another button next to
    the **Share** one in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The new button dispatches a `like` event, and we will again pass the ID of
    the post. It is actually similar to the `share` event. Also, the liking action
    will use the same type of communication with the backend. So, it makes sense to
    refactor our code and use only one function for both the features. In the previous
    section, we added the `sharePost` method to the `models/Content.js` file. Let''s
    change it to `usePost` in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the only one thing that differs is the URL, we define it as a parameter.
    The `formData` interface still contains the ID of the post. Here is the updated
    code of our controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We skipped the definition of one more method and made the implementation of
    the model a bit more flexible. We may need to add a new operation and the last
    tweak will come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the changes in the API, we followed the same workflow. A new route
    responding to `/api/content/like` is needed, which can be created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `content-like` controller still does not exist. We will create a new `backend/api/content-like.js`
    file that will host the logic related to the liking. The usual things like protecting
    the method from unauthorized users and fetching the `POST` data with `formidable`
    are present. This time, we are not going to use the `insert` method of the collection.
    Instead, we will use `update`. We will construct a slightly more complex MongoDB
    query and update a new property called `likes`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `update` method accepts four parameters. The first one is the criteria.
    The records that match our criteria will be updated. The second one contains instructions
    with regards to what we want to update. The third parameter contains additional
    options and the last one is a callback that is invoked once the operation ends.
    Here is how our query looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is indeed a bit long but it does its job. Let''s go through it line
    by line. The first parameter, our criteria, makes sure that we are going to update
    the right post. Because we use the `$and` operator, the second object in the array
    should also be valid. You may notice that a few lines below `$and`, the `$push`
    operator adds a new object to an array called `likes`. Every object has a `name`
    property containing the name of the user that hits the **Like** button. So, in
    our `"likes.user": { $nin: [userName] }` criteria, it means that the record will
    be updated only if `userName` is not in some of the elements of the `likes` array.
    This might look a little complex, but it is really a powerful combination of operators.
    Without this, we would probably end up making several queries to the database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `{w: 1}` option always changes its value if a callback is passed.'
  prefs: []
  type: TYPE_NORMAL
- en: Once the record is updated, we will simply call the `done` method and send a
    response to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the changes in the API, we successfully finished this feature. Here is
    how a post looks in the browser now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Liking posts and counting the number of likes](img/image00184.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Showing the number of likes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We keep the likes in an array. It is easy to count the elements there and find
    out how many times a post is liked. We will make two small changes that will make
    this possible. The first one is in the API, which is the place where we prepare
    the post objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'A new `numberOfLikes` property is attached. The records did not have a `likes`
    property in the beginning. So, we have to check whether it exists before we use
    it. If we have `numberOfLikes` variable, we can update the label of the **Like**
    button in the frontend to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Once created, every post has zero likes. So, the label of the button is **Like
    (0)**, but after the first click, it changes to **Like (1)**. The following screenshot
    demonstrates how this looks in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Showing the number of likes](img/image00185.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was about some of the most used features in social networks nowadays—tagging,
    sharing, and liking. We updated both sides of our application and validated our
    knowledge from the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will be about real-time communication. We will build a chat
    window for our users, and they will be able to send real-time messages to others.
  prefs: []
  type: TYPE_NORMAL
