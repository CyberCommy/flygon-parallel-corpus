- en: 6\. Securing your application with HTTPS and Azure AD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTTPS has become a necessity for any public-facing website. Not only does it
    improve the security of your website, but it is also becoming a requirement for
    new browser functionalities. HTTPS is a secure version of the HTTP protocol. HTTPS
    makes use of **Transport Layer Security** (**TLS**) certificates to encrypt traffic
    between an end user and a server, or between two servers. TLS is the successor
    to the **Secure Sockets Layer** (**SSL**). The terms *TLS* and *SSL* are often
    used interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: In the past, you needed to buy certificates from a **certificate authority**
    (**CA**), then set them up on your web server, and then renew them periodically.
    While that is still possible today, the **Let's Encrypt** service and helpers
    in Kubernetes make it very easy to set verified TLS certificates in your cluster.
    Let's Encrypt is a non-profit organization run by the Internet Security Research
    Group and backed by multiple companies. It is a free service that offers verified
    TLS certificates in an automated manner. Automation is a key benefit of the Let's
    Encrypt service.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of Kubernetes helpers, we will introduce a new object called an **Ingress**,
    and we will use a Kubernetes add-on called **cert-manager**. An Ingress is an
    object within Kubernetes that manages external access to services. Ingresses are
    commonly used for HTTP services. An Ingress adds additional functionality on top
    of the service object we explained in *Chapter 3, Application deployment on AKS.*
    An Ingress can be configured to handle HTTPS traffic. It can also be configured
    to route traffic to different back-end services based on the host name, which
    is assigned by the **Domain Name System** (**DNS**) that is used to connect.
  prefs: []
  type: TYPE_NORMAL
- en: '`cert-manager` is a Kubernetes add-on that helps in automating the creation
    of TLS certificates. It also helps in the rotation of certificates when they are
    close to expiring. `cert-manager` can interface with Let''s Encrypt to request
    certificates automatically.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will see how to set up the Ingress and `cert-manager` to
    interface with Let's Encrypt.
  prefs: []
  type: TYPE_NORMAL
- en: Also in this chapter, we will explore different approaches to authentication
    for the guestbook app. We will look at the `oauth2_proxy` reverse proxy to add
    authentication to the sample guest app using Azure **Active Directory** (**AD**).
    The `oauth2_proxy` is a reverse proxy that will forward authentication requests
    to a configuration authentication platform. You will learn how to easily secure
    apps that have no built-in authentication. The authentication scheme can be extended
    to use GitHub, Google, GitLab, LinkedIn, or Facebook.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an Ingress in front of a service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding TLS support to an Ingress
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication and common authentication providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication versus authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying the `oauth2_proxy` sidecar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with setting up the Ingress.
  prefs: []
  type: TYPE_NORMAL
- en: HTTPS support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Obtaining TLS certificates traditionally has been an expensive and manual business.
    If you wanted to do it cheaply, you could self-sign your certificates, but browsers
    would complain when opening up your site and identify it as not trusted. The Let's
    Encrypt service changes all that. Let's Encrypt is a free, automated, and open
    CA, run for the public's benefit. It gives people the digital certificates they
    need in order to enable HTTPS (SSL/TLS) for websites, for free, in the most user-friendly
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although this section focuses on using an automated service such as Let's Encrypt,
    you can still pursue the traditional path of buying a certificate from an existing
    CA and importing it into Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Installing an Ingress controller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the Ingress object, Kubernetes provides a clean way of securely exposing
    your services. It provides an SSL endpoint and name-based routing, meaning different
    DNS names can be routed to different back-end services.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to create an Ingress object in your cluster, you first need to set
    up an **Ingress controller**. The Ingress controller will manage the state of
    the Ingresses you have deployed in your cluster. There are multiple options when
    selecting an Ingress controller. For a full list of options, please refer to [https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/](https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/).
    When running AKS, the two most common options are either using an NGINX-based
    Ingress controller, or an Ingress controller based on the Azure application gateway.
    For our example, we'll use the NGINX version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and install the NGINX version of the Ingress controller by
    performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: To follow along, run this sample in the Bash version of Cloud Shell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type in the following command to begin installation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will set up the Ingress controller for our cluster. This will additionally
    create a public IP that we will use to access the Ingress controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s connect to the Ingress controller. To get the exposed IP of the `ingress-controller`
    service, enter this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see an entry for the Ingress controller as shown in *Figure 6.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Your output screen will show you three entries. Out of these three entries,
    the ingress controller will show an external  IP.](image/Figure_6.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: Getting the IP of the Ingress controller'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can browse to the web page by entering `http://<EXTERNAL-IP>` in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Your output screen will show you three entries. Out of these three entries,
    the ingress controller will show an external  IP.](image/Figure_6.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: An Ingress showing its default back end'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This shows you two things:'
  prefs: []
  type: TYPE_NORMAL
- en: There is no back-end application, just a default application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The website is served over HTTP, not HTTPS (hence the **Not secure** warning).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next two sections, we'll solve both of these issues. We'll first create
    an Ingress rule for our guestbook application, and then we'll add HTTPS support
    via Let's Encrypt.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an Ingress rule for the guestbook application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s start by relaunching our guestbook application. To launch the guestbook
    application, type in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create our trusted guestbook application. You should see the objects
    being created as shown in *Figure 6.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Upon executing the kubectl create -f guestbook-all-in-one.yaml command, your
    output screen will show that all the objects will be created.](image/Figure_6.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: Creating the guestbook application'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We can then use the following YAML file to expose the front-end service via
    the Ingress. This is provided as `simple-frontend-ingress.yaml` in the source
    code for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s have a look at what we define in this YAML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Line 2**: Here, we define the fact that we are creating an Ingress object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 5-12**: These lines define the configuration of the Ingress. Pay specific
    attention to:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 9**: Here, we define the path this Ingress is listening on. In our case,
    this is the top-level path. In more advanced cases, you can have different paths
    pointing to different services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 10-12**: These lines define the actual service this traffic should
    be pointed to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use the following command to create this Ingress:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you now go to `https://<EXTERNAL-IP>/`, you should get an output as shown
    in *Figure 6.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![When you enter the public IP address to your browser, it will display a white
    screen with Guestbook written on it. This indicates that the guestbook application
    is available via the Ingress.](image/Figure_6.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: Accessing the guestbook application via the Ingress'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Please pay attention to the following: we didn''t have to publicly expose the
    front-end service as we have done in the preceding chapters. We have added the
    Ingress as the exposed service, and the front-end service remains private to the
    cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The user can have access to the Ingress, whereas the service and the frontend
    pods remain private.](image/Figure_6.5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: Flowchart displaying publicly accessible Ingress'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can verify this by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This should only show you one public service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Upon running the kubectl get svc command, you will see a total of six services
    and that only the ingress controller provides an External-IP.](image/Figure_6.6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.6: Output displaying only the Ingress having a public IP'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this section, you have launched an instance of the guestbook application.
    You exposed it publicly by creating an Ingress. Only the Ingress was publicly
    accessible. In the next section, we'll see how to get a certification from Let's
    Encrypt.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a certificate from Let's Encrypt
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we will add HTTPS support to our application. To do this,
    we need a TLS certificate. We will be using the `cert-manager` Kubernetes add-on
    to request a certificate from Let''s Encrypt. There are a couple of steps involved.
    The process of adding HTTPS to our application involves the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Install `cert-manager`, which interfaces with the Let's Encrypt API to request
    a certificate for the domain name you specify.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Map the **Azure Fully Qualified Domain Name** (**FQDN**) to the NGINX Ingress
    public IP. An FQDN is the complete DNS name of a service, sometimes referred to
    as the DNS record, such as `www.google.com`. A TLS certificate is issued for an
    FQDN, which is why we need to map an FQDN for our Ingress.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the certificate issuer, which will get the certificate from Let's Encrypt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an SSL certificate for a given FQDN.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Secure the front-end service section by creating an Ingress to the service with
    the certificate created in *step 4*. In our example, we will not be executing
    this step. We will, however, reconfigure our Ingress to automatically pick up
    the certificate created in *step 4*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's start with the first step; installing `cert-manager` in our cluster.
  prefs: []
  type: TYPE_NORMAL
- en: '**Installing cert-manager**'
  prefs: []
  type: TYPE_NORMAL
- en: The first step in getting a TLS certificate is to install `cert-manager` in
    your cluster. `cert-manager` ([https://github.com/jetstack/cert-manager](https://github.com/jetstack/cert-manager))
    automates the management and issuance of TLS certificates from various issuing
    sources. It is an open-source solution managed by the company **Jetstack**. Renewing
    certificates and ensuring that they are updated periodically is all managed by
    `cert-manager`, which is a Kubernetes add-on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands install `cert-manager` in your cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'These commands do a couple of things in your cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new **namespace**. Namespaces are used within Kubernetes to isolate
    workloads from each other.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new repository to Helm to grab charts from.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the `cert-manager` Helm chart.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that you have installed `cert-manager`, we can move on to the next step:
    mapping an FQDN to the Ingress.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mapping the Azure FQDN to the NGINX Ingress public IP**'
  prefs: []
  type: TYPE_NORMAL
- en: The next step in the process of getting a TLS certificate is adding an FQDN
    to your IP address. Let's Encrypt requires a publicly available DNS entry to verify
    ownership of the DNS entry *before* it issues a certificate. This ensures that
    you cannot hijack someone else's site. We have to map the public domain name given
    to us by Azure to the external IP we get from Azure Load Balancer in order to
    prove ownership.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help us link a DNS entry to our public IP:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and link a DNS name to our public IP address. First, make sure
    you get your IP address from your Ingress service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Note down the IP of the Ingress service. In the Azure Search bar, now look
    for `public ip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Type public ip in your search bar on the Azure search bar and select "Public
    IP addresses"](image/Figure_6.7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.7: Searching for public ip in the Azure search bar'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Once there, you should see a number of public IP addresses. To find our public
    IP address, you can show an extra column here that would show you the actual IP
    address. Hit the **Edit columns** button to add the extra column:![When you find
    your public IP from the default directory page on the Azure portal, click on the
    Edit columns button located on top of the page. This will open the column selector.](image/Figure_6.8.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.8: Clicking on Edit columns to add an extra column'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the column selector, pick **IP address** and hit the arrow pointing right,
    as shown in *Figure 6.9*:![To add the IP address to the selected columns, click
    on the IP address tab in the Available columns navigation pane. Next, click on
    the arrow facing right located at the center of the page.](image/Figure_6.9.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.9: Adding the IP address to the selected columns'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Hit **Apply** to show the actual IP addresses. When you see yours, click on
    it. In the blade for your IP address, enter the **Configuration** view. Then,
    enter a *unique* DNS name and hit **Save**:![Open your IP address. Click on the
    Configurations tab in the Navigation pane. Enter the unique name of the DNS, and
    then click on the Save button alongside the search bar.](image/Figure_6.10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.10: Adding a unique DNS name label and saving the configuration'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You now have a DNS record linked to your public IP address. Next, you will install
    the certificate issuer in your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: '**Installing the certificate issuer**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will install the Let''s Encrypt staging certificate issuer.
    A certificate can be issued by multiple issuers. `letsencrypt-staging`, for example,
    is for testing purposes. As we are building tests, we''ll use the staging server.
    The code for the certificate issuer has been provided in the source code for this
    chapter in the `certificate-issuer.yaml` file. As usual, use `kubectl create -f
    certificate-issuer.yaml`, which has the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s look at what we have defined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lines 1-2**: Here, we have used the **CustomResourceDefinition** (**CRD**)
    that we installed earlier. A CRD is a way to extend the Kubernetes API server
    to create custom resources, like a certificate issuer. In this case specifically,
    we point to the `cert-manager` API CRD we injected into the Kubernetes API and
    create an `Issuer` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 6-10**: We have provided the configuration for Let''s Encrypt in these
    lines and pointed to the staging server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 11-14**: This is additional configuration for the ACME client to certify
    domain ownership.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With the certificate issuer installed, we can now move to the next step: creating
    the TLS certificate.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating the TLS certificate and securing our service**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will create a TLS certificate. There are two ways you can
    configure `cert-manager` to create certificates. You can either manually create
    a certificate and link it to the Ingress controller, or you can configure your
    Ingress controller so `cert-manager` automatically creates the certificate. In
    this example, we''ll show you the second way, by editing our Ingress to look like
    the following YAML code. This file is present in the source code on GitHub as
    `ingress-with-tls.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We have made the following changes to the original Ingress:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Line 6**: We have added an annotation to our Ingress that points to a certificate
    issuer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 10 and 13**: The domain name for our Ingress has been added here. This
    is required because Let''s Encrypt only issues certificates for domains.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 11**: This is the name of the secret that will be created to store our
    certificate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can update the Ingress we created earlier with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It takes `cert-manager` about a minute to request a certificate and configure
    our Ingress to use that certificate. While we are waiting for that, let's have
    a look at the intermediate resources that `cert-manager` created on our behalf.
  prefs: []
  type: TYPE_NORMAL
- en: 'First off, `cert-manager` created a `certificate` object for us. We can look
    at the status of that object using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will generate an output as shown in *Figure 6.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![When the kubectl get certificate command is executed, you should see the
    status of the object is False. This indicates that the certificate is not ready
    yet.](image/Figure_6.11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.11: Output displaying the status of the certificate'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As you can see, our certificate isn''t ready yet. There is another object that
    `cert-manager` created to actually get the certificate. This object is `certificaterequest`.
    We can get its status by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate the output shown in *Figure 6.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Next, when the kubectl get certificaterequest command is executed, this too
    shows the status of the object is False. This indicates that the certificaterequest
    object isn''t ready yet.](image/Figure_6.12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.12: Output displaying the status of the certificaterequest object
    as False'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We can also get more details about the request by issuing a `describe` command
    against the `certificaterequest` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'While we''re waiting for our certificate to be issued, the status will look
    similar to *Figure 6.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the kubectl describe certificaterequestcommand, you can obtain more
    details on the certificaterequest object that will indicate that the status is
    False. It shows a message saying"Created Order resource default/frontend-tls-<random
    ID>".](image/Figure_6.13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.13: Output providing more details on the certificaterequest object'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If we give this a couple of additional seconds, the `describe` command should
    return a successful certificate creation message, as shown in *Figure 6.14*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![After a couple of seconds, you will see that the details have been updated
    and the status changes to True. There is a message saying "Certificate fetched
    from issuer successfully," which means that the certificate is now issued.](image/Figure_6.14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.14: Output displaying the issued certificate'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This should now enable our front-end Ingress to be served over HTTPS. Let''s
    try this out in a browser by browsing to the DNS name you created in the section
    mapping an FQDN. This will indicate an error in the browser, showing you that
    the certificate isn''t valid as shown in *Figure 6.15*. This is to be expected
    since we are using the Let''s Encrypt staging service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The screen will displaya message saying that your connection isn''t private.](image/Figure_6.15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.15: Using the Let''s Encrypt staging server, our certificate isn''t
    trusted by default'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can browse to your application by clicking **Advanced** and selecting **Continue**.
  prefs: []
  type: TYPE_NORMAL
- en: Since we were able to complete our test with the staging certificate, we can
    now move on to production.
  prefs: []
  type: TYPE_NORMAL
- en: '**Switching from staging to production**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will switch from a staging certificate to a production-level
    certificate. To do this, you can redo the previous exercise by creating a new
    issuer in your cluster, like the following (provided in `certificate-issuer-prod.yaml`).
    Don''t forget to change your email address in the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And then replace the reference to the issuer in the `ingress-with-tls.yaml`
    file to `letsencrypt-prod`, like this (provided in the `ingress-with-tls-prod.yaml`
    file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To apply these changes, execute the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'It will again take about a minute for the certificate to become active. Once
    the new certificate is issued, you can browse to your DNS name again, and shouldn''t
    see any more warnings regarding invalid certificates. If you click the padlock
    item in the browser, you should see that your connection is secure and uses a
    valid certificate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Clicking the padlock icon on the browser''s address bar will tell you that
    your connection is secure. This pop-up window will also let you know that the
    certificate is valid.](image/Figure_6.16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.16: The web page displaying a valid certificate'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In this section, we have introduced two new concepts: first, we added an Ingress
    to our guestbook application. We did this by first setting up an Ingress controller
    on our cluster and then setting up the Ingress for our guestbook application.
    An Ingress allows advanced routing and HTTPS offloading for applications on top
    of Kubernetes. After that, we added HTTPS to our guestbook application. We didn''t
    have to change the source code of the application itself; we were able to add
    HTTPS support by configuring our Ingress.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll add yet another security layer. We will add authentication
    to our application. Before diving into this, let's first discuss a common misunderstanding
    about authentication and authorization.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication versus authorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Authentication** (**AuthN**) is very often mixed up with **authorization**
    (**AuthZ**). Authentication deals with identity (who are you?) and, in general,
    requires a trusted identity provider. Multiple providers exist, such as Azure
    AD, Okta, or GitHub, and even social media platforms such as Facebook, Google,
    or Twitter can be used as a provider. Authorization deals with permissions (what
    are you trying to do?) and is very implementation-specific in terms of what application
    resources need to be protected.'
  prefs: []
  type: TYPE_NORMAL
- en: It generally takes multiple attempts to understand the difference, and even
    then you can still get confused between the two. The source of confusion is that
    in some cases, the authentication provider and the authorization provider are
    the same. For instance, in our WordPress example, WordPress provides the authentication
    (it has the username and password) and authorization (it stores the users under
    admin or user roles, for example).
  prefs: []
  type: TYPE_NORMAL
- en: However, in most cases, the authentication system and the authorization system
    are different. We'll use a practical example of this in *Chapter 10*, *Securing
    your AKS cluster*. In that chapter, we will use Azure AD as an authentication
    source, while using Kubernetes RBAC as the authorization source.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and common authN providers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our guestbook application is open to all and lets anyone with a public IP access
    the service. The image by itself has no authentication. A common problem is wanting
    to apply additional functionality separately from the application implementation.
    This can be done by introducing a proxy that will serve the authentication traffic,
    rather than introducing the authentication logic in the main application.
  prefs: []
  type: TYPE_NORMAL
- en: 'With recent hacks, it has proven to be difficult to set up and maintain a secure
    authentication system by yourself. To help their customers build secure applications,
    many companies allow you to use their authentication service to verify a user''s
    identity. Authentication is provided as a service by those providers with support
    for OAuth. Here are some of the well-known providers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Azure** ([https://github.com/pusher/oauth2_proxy#azure-auth-provider](https://github.com/pusher/oauth2_proxy#azure-auth-provider))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Facebook** ([https://github.com/pusher/oauth2_proxy#facebook-auth-provider](https://github.com/pusher/oauth2_proxy#facebook-auth-provider))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GitHub** (https://github.com/pusher/oauth2_proxy#github-auth-provider)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GitLab** (https://github.com/pusher/oauth2_proxy#gitlab-auth-provider)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google** (https://github.com/pusher/oauth2_proxy#google-auth-provider)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LinkedIn** ([https://github.com/pusher/oauth2_proxy#linkedin-auth-provider](https://github.com/pusher/oauth2_proxy#linkedin-auth-provider))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we will use a proxy implementation, `oauth2_proxy`,
    to implement authentication for our guestbook example.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the oauth2_proxy proxy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s start with cleaning up the previously deployed Ingress. We''ll keep
    the certificate issuer deployed in the cluster. We can clean up the Ingress using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We are going to implement `oauth2_proxy` from Pusher ([https://github.com/pusher/oauth2_proxy](https://github.com/pusher/oauth2_proxy)).
    Implement the following steps to configure `oauth2_proxy` to use Azure AD as an
    authentication system.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, register an app with Azure AD. Open the Azure AD blade in the portal
    by searching for `azure active directory` in the search bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Type azure active directory in the search bar.](image/Figure_6.17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.17: Searching for Azure Active Directory in the Azure search bar'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Then, go to **App registrations** and click **New registration**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Click on App registrations in the Navigation pane in Azure Active Directory.
    Next, click on the New registration tab alongside the search bar. A new application
    registration will be created.](image/Figure_6.18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.18: Creating a new application registration'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Then, provide a name for the application and hit **Create**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Type a name for the newly created application and save it.](image/Figure_6.19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.19: Providing a name for the application'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Next, create a client ID secret by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **Certificates & secrets** and go to **New client secret**. Give the
    secret a description and hit **Add**:![Once you open your application, click on
    the Certificates & secrets tab in the navigation pane on the leftside of the screen.
    Click on New client secret button. Set oauth2_proxy as the description for this
    application. Set the expiry duration to 1 year and click on the Add button.](image/Figure_6.20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.20: Creating a new client secret'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Click on the copy icon and save the secret in a safe place:![To copy and save
    the secret in a safe place, click on the copy icon alongside the value of the
    client secret.](image/Figure_6.21.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.21: Copying the client secret'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Next, we will need to configure a redirect URL. This is the URL that Azure AD
    will call back once the user has been authenticated. To configure this, head over
    to **Authentication** in the Azure AD blade, click on **Add a platform**, and
    select **Web**, as shown in *Figure 6.22*:![Click on the Authentication tab in
    the navigation pane on the leftside of the screen. Next, click on the Add Platform
    button in the Platform Configurations section in the center of the screen. This
    will open a new page to help you configure platforms. Select the Web option in
    the Web applications section.](image/Figure_6.22.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.22: Providing a redirect URL'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Once there, you can enter the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://<your dns prefix>.<your azure region>.cloudapp.azure.com/oauth2/callback`
    and hit **Configure**.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, go back to the **Overview** blade and save the **Application** and the
    **Directory ID**:![Copy the Application ID and the Directory ID and save it in
    the Overview blade on the leftside of the screen.](image/Figure_6.23.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.23: Copying the Application ID and the Directory ID'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'After creating the client ID secret, setting the redirect URL, and copying
    the application and directory IDs, we need to create the following three objects
    in Kubernetes to get `oauth2_proxy` working on our cluster and perform a final
    step to link OAuth to our existing Ingress:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to create a deployment for `oauth2_proxy`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we need to expose this as a service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, we will create a new Ingress for `oauth2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And finally, we will reconfigure our current Ingress to send unauthenticated
    requests to `oauth2_proxy`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will execute all three steps while showing the YAML files as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the first item – creating the deployment. The deployment
    can be found in the source as the `oauth2_deployment.yaml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This deployment has a couple of interesting lines to discuss. We discussed
    the other lines in previous examples in *Chapter 3*, *Application deployment on
    AKS*. We''ll focus on the following lines here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lines 17-18**: These lines tell the `oauth2` proxy to redirect to Azure AD.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lines 19-32**: This is the `oauth2` configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Line 33**: This line points to the correct container image. This is the first
    time we have used an image that is not hosted on Docker Hub. **Quay** is an alternative
    container repository, hosted by RedHat.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the deployment using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, `oauth2` needs to be exposed as a service so that the Ingress can talk
    to it by creating the following service (`oauth2_service.yaml`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Create this service using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will create an Ingress so that any URL that goes to `handsonaks-ingress-<yourname>.<your
    azure region>.cloudapp.azure.com/oauth` will be redirected to the `oauth2-proxy`
    service. The same Let''s Encrypt certiﬁcate issuer is used here (the `oauth2_ingress.yaml`
    file in the source code for this chapter):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: There is one interesting line to point out in this Ingress. **Line 17** introduced
    a new path to our Ingress. As mentioned earlier in this chapter, the same Ingress
    can have multiple paths being directed to different back-end services. This is
    what we are configuring here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create this Ingress by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we will link the `oauth2` proxy to the front-end service by creating
    an Ingress that configures `nginx` so that authentication is checked using the
    paths in `auth-url` and `auth-signin`. If the request is not authenticated, traffic
    is sent to the `oauth2_proxy`. If it is successfully authenticated, the traffic
    is redirected to the back-end service (in our case, it is the front-end service).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code performs the redirection once authentication is successful
    (`frontend-oauth2-ingress.yaml` in the GitHub repository):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a couple of interesting things to point in this Ingress configuration.
    The other lines are common with the other Ingresses we have created throughout
    this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Line 5:** As mentioned previously, the Ingress object can be backed by multiple
    technologies (such as NGINX or Application Gateway). The Ingress object has a
    syntax to configure basic tasks, such as `hosts` and `paths`, but it doesn''t
    have a configuration for authentication redirects, for example. Annotations are
    used by multiple Ingress providers to pass detailed configuration data to the
    Ingress provider in the back end.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lines 7-8:** This configures our Ingress to send non-authenticated requests
    to these URLs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create this Ingress using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We are now done with configuration. You can now log in with your existing Microsoft
    account to the service at `https://handsonaks-ingress-<yourname>.<your azure region>.cloudapp.azure.net/`.
    To make sure you get the authentication redirect, please make sure to use a new
    browser window or a private window. You should get automatically redirected to
    Azure AD's sign in page.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`oauth2-proxy` supports multiple authentication providers, such as GitHub and
    Google. Only the `oauth2-proxy` deployment''s YAML has to be changed with the
    right service to change the authentication provider. Please see the relevant details
    at https://github.com/pusher/oauth2_proxy#oauth- provider-configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that everything has been deployed, let''s clean up the resources we created
    in our cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we have added Azure AD authentication to your application.
    We did this by adding the `oauth2_proxy` to our cluster, and we then reconfigured
    the existing Ingress to redirect unauthenticated requests to `oauth2_proxy`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we added HTTPS security and identity control to our guestbook
    application without actually changing the source code. We started by getting the
    Kubernetes Ingress objects set up in our cluster. Then, we installed a certificate
    manager that interfaces with the Let's Encrypt API to request a certificate for
    the domain name we subsequently specified. We leveraged a certificate issuer to
    get the certificate from Let's Encrypt. We then reconfigured our Ingress to request
    a certificate from this issuer in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we jumped into authentication and authorization and showed you how to
    leverage Azure AD as an authentication provider for the guestbook application.
    You learned how to secure your applications on an enterprise scale. By integrating
    with Azure AD, you can enable any application to link to an organization's AD.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to monitor your deployments and set
    up alerts. You will also learn how to quickly identify root causes when errors
    do occur, and you will learn how to debug applications running on AKS. At the
    same time, you'll learn how to perform the correct fixes once you have identified
    the root causes.
  prefs: []
  type: TYPE_NORMAL
