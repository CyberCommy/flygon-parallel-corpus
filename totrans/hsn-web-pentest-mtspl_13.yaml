- en: Pentesting CMSes - Drupal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we explained how to perform penetration testing on
    Joomla websites. There's quite a difference between WordPress, Joomla, and Drupal,
    especially in terms of security and architecture. In this chapter, we will be
    learning about Drupal, its architecture, and how we can test a Drupal-based website.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Drupal and its architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drupal reconnaissance and enumeration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drupal vulnerability scanning using droopescan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploiting Drupal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Some knowledge of PHP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An understanding of the basics of the Metasploit Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knowledge of basic Linux commands, such as `grep` and `ag`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An understanding of the basics of Burp Suite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Drupal and its architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Drupal is a free and open source **Content Management System** (**CMS**) written
    in PHP. It was originally written by **Dries Buytaert** as a message board, but
    became an open source project in 2001\. Although Drupal is considered a bit tricky
    to use when compared with other CMSes, it does provide a built-in API to facilitate
    the development of custom modules.
  prefs: []
  type: TYPE_NORMAL
- en: Drupal's architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A general way to describe Drupal''s architecture would be to divide it into
    four major parts, as is the case in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d71d78c6-8415-43a1-96b9-6626a2d3383a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To understand the architecture, let''s first learn about the components of
    Drupal. Drupal''s components are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Themes:** Themes are collections of files that define the user interface
    of a Drupal website. The files contain code written in PHP, HTML, and JavaScript.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modules:** Modules are event-driven code files that can be used to extend
    Drupal''s functionality. Some modules are known core modules that are maintained
    by the Drupal development team as they are an essential part of Drupal''s operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Core APIs:** At Drupal''s core are the APIs that are used to communicate
    with content and other modules. These APIs include the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database API**: This allows a developer to easily update/modify data in the
    database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Caching API**: This API stores page responses so that the browser doesn''t
    have to render pages every time a request is made.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Session Handling API**: This keeps track of different users and their activity
    on the website.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database**: This is where all the data is stored. Drupal supports different
    types of databases, such as MySQL, Postgres, and SQLite.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have a basic understanding of Drupal's architecture, let's look
    at the directory structure next.
  prefs: []
  type: TYPE_NORMAL
- en: Directory structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Drupal has the following directory structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Core**: This consists of files used by the default Drupal installation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modules**: All the custom-created modules that are installed in Drupal are
    stored here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Profiles**: This folder stores the installation profile. The installation
    profile contains information about pre-installed modules, themes, and the configuration
    of the given Drupal site.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sites**: This contains site-specific modules in the event that Drupal is
    used with more than one site.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Themes**: The base theme and all other custom themes are stored in this directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vendors**: This directory contains backend libraries used by Drupal, such
    as Symfony.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The directory structure of a default Drupal installation is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1bf7a31-cca4-4596-b2a0-156a89a49364.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have an idea of the basics of Drupal and its directory structure,
    let''s move on to the next topic: Drupal reconnaissance and enumeration.'
  prefs: []
  type: TYPE_NORMAL
- en: Drupal reconnaissance and enumeration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we talked about in earlier chapters, reconnaissance and enumeration is a
    crucial step in any kind of penetration testing. In this section, we will look
    at some of the methods that can be used to identify a Drupal installation and
    the installed version.
  prefs: []
  type: TYPE_NORMAL
- en: Detection via README.txt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the easiest and the most basic technique. All we have to do is visit
    the `README.txt` page and we will see a line that reads `"Protect files and directories
    from prying eyes"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1abf36c4-7030-48a4-8185-c8ea7708e7cf.png)'
  prefs: []
  type: TYPE_IMG
- en: This will indicate that the instance is indeed a Drupal instance.
  prefs: []
  type: TYPE_NORMAL
- en: Detection via meta tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The meta tag with a `name` attribute of `"Generator"` identifies the software
    that is being used to generate a document/web page. The version number is disclosed
    in the `content` attribute of the meta tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49ec88ea-884d-491e-bee6-457eafafb59c.png)'
  prefs: []
  type: TYPE_IMG
- en: Drupal-based websites often have this tag in their source code.
  prefs: []
  type: TYPE_NORMAL
- en: Detection via server headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Drupal can also be recognized if one of the following headers exists in the
    server response:'
  prefs: []
  type: TYPE_NORMAL
- en: '**X-Generator HTTP header**: This identifies a Drupal website.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**X-Drupal-Cache header**: This header is used by Drupal''s cache. If the header
    value is **X-Drupal-Cache: MISS**, this means that the pages are not served from
    the cached display, and if you see **X-Drupal-Cache: HIT**, this means that the
    pages are served from the cache.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**X-Drupal-Dynamic-Cache header**: The dynamic cache is used by the site to
    load dynamic content (cached pages), with the exception of personalized parts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Expires: Sun, 19 Nov 1978**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows these headers in a server response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7fdeff02-29d4-4706-8798-5a9a6dcc56e3.png)'
  prefs: []
  type: TYPE_IMG
- en: The dynamic cache header `X-Drupal-Dynamic-Cache` was introduced in Drupal version
    8+ and is not available for Drupal version 7 or earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Detection via CHANGELOG.txt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, the `CHANGELOG.txt` file also discloses the version number. This
    file can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can browse `/CHANGELOG.txt` or `/core/CHANGELOG.txt` to identify the Drupal
    version that''s installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99bfdd0d-92f0-4fe8-a16b-0a58bee864d6.png)'
  prefs: []
  type: TYPE_IMG
- en: In some cases, we may not find the `CHANGELOG.txt` file. In that case, we can
    try the other detection techniques mentioned in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Detection via install.php
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although it''s recommended that the `install.php` file is removed after installation,
    developers often leave it on the server. It can be used to find the version number
    of a Drupal installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/432fa7c9-6292-4c5a-834b-ab42cc1158fc.png)'
  prefs: []
  type: TYPE_IMG
- en: This method can only be used for Drupal version 8.x.
  prefs: []
  type: TYPE_NORMAL
- en: These detection techniques will only identify whether a site has Drupal installed
    and the version being used if it is installed. It will not find plugins, themes,
    and modules installed in Drupal. To identify plugins, themes, and modules, we
    need to enumerate them. We need to enumerate plugins, themes, and modules because
    these are entry points that can be used by an attacker to take control of a Drupal
    site. As a penetration tester, we need to find vulnerable plugins, themes, and
    modules (with installed versions) and report them.
  prefs: []
  type: TYPE_NORMAL
- en: Plugin, theme, and module enumeration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There''s a very common technique that is used by almost all the open source
    tools available online right now to enumerate Drupal plugins, themes, and modules.
    For enumeration, we just have to look for the following files in the `themes/`,
    `plugins/`, and `modules/` directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `README.txt` file provides plugin, theme, and module versions. It even discloses
    the Drupal version number as well. The `LICENSE.txt` file includes the GNU **General
    Public License** (**GPL**) license. If any of the `plugins/`, `themes/`, or `modules/`
    directories have this file, this means that the specific plugin, theme, or module
    is installed. The `CHANGELOG.txt` file discloses the version number of the installed
    plugin, theme, or module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The module name can be found either from the `README.txt` file or from the
    URL itself, as can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f08b6880-a5dc-459e-810f-8966663d79d9.png)'
  prefs: []
  type: TYPE_IMG
- en: For enumeration, we can either write our own Metasploit wrapper module or we
    can use a third-party, open source tool – droopescan. To code our own wrapper,
    we can follow what we did in the previous chapter, [Chapter 8](e13c4d6e-8576-4fc0-aa78-aa4d54536bca.xhtml),
    *Pentesting CMSes – WordPress*. We will now be proceeding with vulnerability scanning
    using droopescan.
  prefs: []
  type: TYPE_NORMAL
- en: Drupal vulnerability scanning using droopescan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There''s no Metasploit module that can perform a vulnerability scan on Drupal.
    As such, we need to use a third-party tool, such as droopescan, to help us find
    vulnerabilities in Drupal. droopescan can be downloaded from [https://github.com/droope/droopescan](https://github.com/droope/droopescan):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s clone the Git repository of droopescan for installation using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11fd5fe7-a373-405b-ac8c-eb972a52afe8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Before running droopescan, we still need to install the necessary Python modules,
    which can be done using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once all the packages are installed on the system, we can test the installation
    by executing droopescan using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If there''s an error while executing droopescan, we can execute it using the
    following command as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Following the installation of droopescan, we can execute the following command
    to run a vulnerability scan on Drupal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f166934c-7acd-40ff-9eea-7305462df76c.png)'
  prefs: []
  type: TYPE_IMG
- en: droopescan is a plugin-based scanner that identifies vulnerabilities in several
    CMSes, but mainly Drupal. droopescan uses a pre-built word list, and the detection
    of modules, themes, and plugins is done by brute force. So, this all depends on
    how good our word list is. We can find other Drupal-based vulnerability scanners
    as well, which can be used to identify vulnerabilities in Drupal. The only difference
    is the language they are written in (for efficiency) and the word list they use.
  prefs: []
  type: TYPE_NORMAL
- en: When we have found vulnerabilities in the Drupal CMS, we can move on to finding
    public exploits for them. One of the most famous vulnerabilities is Drupalgeddon.
    In the next section, we will cover the Drupalgeddon2 vulnerability and learn how
    it is exploited.
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting Drupal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When exploiting Drupal, the following are the attack vectors that we need to
    keep in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating Drupal users for brute-force attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploiting Drupal via broken authentication (guessable passwords)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploiting plugins, themes, or modules for arbitrary file disclosures and uploads,
    persistent **Cross-Site Scripting** (**XSS**), and more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploiting Drupal core components for SQL injection and **Remote Code Execution**
    (**RCE**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For different versions of Drupal, there are different public exploits that can
    be used. Sometimes, we can get access to a Drupal site using public exploits,
    and other times we have to change the exploits to make them work. It is always
    good practice to understand an exploit first and execute it later. Let's focus
    on the public exploits for Drupalgeddon2 for now.
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting Drupal using Drupalgeddon2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On March 28, 2018, Drupal issued an advisory that highlighted an RCE vulnerability
    in various versions of Drupal. This was later renamed Drupalgeddon2\. Drupal version
    6 was introduced with the Form API, which was used to alter data during form rendering,
    and, in Drupal 7, this was generalized as **renderable arrays**. Renderable arrays
    contain metadata in a key-value structure and are used in the rendering process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let's now learn about this forms-based vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Drupalgeddon vulnerability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Drupalgeddon vulnerability is to do with a particular registration form.
    This form is available in all Drupal installations and can be accessed without
    any authentication. In this form, the email field allows unsanitized input from
    the user, which allows attackers to inject an array into the form array structure
    (as the value of the `email` field). The following properties can be used to exploit
    this vulnerability:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#post_render`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#lazy_builder`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#pre_render`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#access_callback`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Metasploit''s exploit module uses the `#post_render` property to inject the
    payload into the `mail` array, which looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Upon rendering, the `exec()` function will be called, which will execute the
    `whoami` command and return the output. Let's now move forward and see this exploit
    in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code can be found in `/core/lib/Drupal/Core/Render/Renderer.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be660a7c-1d53-487f-853c-d05648a9997d.png)'
  prefs: []
  type: TYPE_IMG
- en: '`/core/modules/file/src/Element/ManagedFile.php` is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5a0017f-828c-48f1-ac59-72b9ddabcd1b.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the form values are broken down using slashes and then used
    to fetch values using the `NestedArray::getValue()` function. Based on the data returned, the
    result is rendered. In this case, `$form["user_picture"]["widget"][0]` becomes
    `user_picture/widget/0`. We can input our own path to the desired element. In
    the account registration form, there are the `mail` and `name` parameters. The
    `name` parameter filters user data, but the `email` parameter does not. We can
    convert this parameter into an array and submit a line beginning with `#` as a
    key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to `/core/lib/Drupal/Core/Render/Renderer.php`, we see that the
    `#post_render` property takes the `#children` element and then passes it to the `call_user_func()`
    function, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ce011fc-841b-4398-995c-ef246f48e348.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is from PHP''s manual:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/677cb687-a188-4d27-83ef-8ce9b2514175.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we pass `call_user_func(system,id)`, it will be executed as `system(id)`.
    So, we need `#post_render` to be defined as `exec()`, and `#children` to be defined
    as the value we want to pass into `exec()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Another method is to use the `#markup` element, which is used by other exploits
    available on the internet.
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting Drupalgeddon2 using Metasploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Metasploit module is also available to exploit the Drupalgeddon2 vulnerability,
    and we can use it by executing this command in msfconsole:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, perform the following steps to exploit the vulnerability:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the options, we run `show options`, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dd93cd7f-20c2-4ae7-8caa-036106f54951.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we set the options of `rhosts` and `rport`, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4a43b16c-906d-41e6-be30-5d7a22b4bf6d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the exploit is run, it first performs fingerprinting by looking for the
    Drupal version in the response header or meta tag by making a request to `/`,
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1140cab0-4235-4607-bb13-fdc91999c4ed.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, it performs a patch-level check by calling `CHANGELOG.txt` and looking
    for the `SA-CORE-2018-002` patch, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e744cbc6-c914-498d-ae85-65c49566d635.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the previous two steps are complete, the exploit then confirms the existence
    of RCE by simply calling the `printf` function to print a value in response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/973be9fe-dbff-4f6c-a5c4-efc109b40f0f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding screenshot, we used the `testing123` string. If the server
    responds with `testing123`, the server has the Drupalgeddon2 vulnerability:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06e70d9a-93fd-4c93-8e8b-4655ae043bdc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Confirm the RCE using the `passthru()` function of PHP to execute the `id`,
    `whoami`, and `uname -a` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5090a9af-6328-4612-9102-01a5a2b2fc59.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The server returns the response to the commands executed, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1c624e12-a14a-42fd-90d2-ae84db657c13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The final step is to send the PHP meterpreter payload, which is injected and
    executed in the memory as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/53499d94-19c2-4618-b0dc-9d398321ebd9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Upon successful execution, we will have a meterpreter session open in our terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7ad41191-f982-420a-8449-4710ee434b3a.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's look at another example of a Drupal exploit and try to understand
    how it works.
  prefs: []
  type: TYPE_NORMAL
- en: The RESTful Web Services exploit – unserialize()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In February 2019, CVE-2019-6340 was released, which disclosed a bug in the
    RESTful web services module of Drupal. This bug can be exploited to perform RCE.
    RCE is only possible if the Drupal installation has all the web services installed
    (**HAL**, **Serialization**, **RESTful Web Services**, and **HTTP Basic Authentication**,
    shown in the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/28e062fc-3526-4c96-ac10-737f7e4bee1c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The RESTful Web Services module communicates with Drupal using REST APIs, which
    can perform operations such as update, read, and write on website resources. It
    depends on the serialization module for the serialization of data that is sent
    to and from the API. Drupal 8 Core uses the **Hypertext Application Language**
    (**HAL**) module, which serializes entities using HAL when enabled. We can check
    whether a Drupal server has these web services enabled by requesting a node using
    the `GET` method with the `_format=hal_json` parameter, as can be seen in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e721e86a-a4ee-4f2f-85b4-df93db8c2299.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If the modules are installed, then we''ll get a JSON-based response, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1d2ac192-34b1-4eca-bdfb-97413a18184c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If the server does not have the web service modules, we''ll get a `406` (`Not
    Acceptable`) HTTP code error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a9fa8b6-f200-4f68-8191-8c3265b97bdb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This vulnerability exists because the `LinkItem` class takes unsanitized user
    input and passes it to the `unserialize()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8d2ce64-296d-4e26-a1f5-3a7b359837e5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see in the following screenshot, according to the PHP manual for
    the `unserialize()` function, when using `unserialize()`, we should not let untrusted
    user input be passed to this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9d74ccb-6fff-40b8-907d-f2654f0b8e97.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to exploit this vulnerability, **three** conditions should be satisfied:'
  prefs: []
  type: TYPE_NORMAL
- en: The application should have an `unserialize()` function that can be controlled
    by us.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application must have a class that implements a PHP magic method (`destruct()`
    or `wakeup()`) that carries out dangerous statements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There needs to be a serialized payload that uses the classes loaded in the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From the previous screenshot, we can confirm that we have control over the `$value[''options'']`
    form entity. To check for the magic methods, let''s search for the `destruct()`
    function within the source code using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/08e86e24-974d-4070-98be-bfe6d28f49aa.png) **Note**: You have to install
    the `ag` package before executing the preceding command.'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, we grepped out `guzzlehttp` because Guzzle is used
    by Drupal 8 as a PHP HTTP client and framework for building RESTful web service
    clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'From looking at the `FnStream.php` file (refer to the preceding screenshot),
    we can see that the `__destruct()` magic method is calling the `call_user_func()`
    function, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5387edda-be4c-4204-98f4-5b18a8a9e62a.png)'
  prefs: []
  type: TYPE_IMG
- en: '`call_user_func()` is quite a dangerous function to use, especially when more
    than one argument is passed. We can use this function to perform a function injection attack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d881b08a-7212-47d7-b563-931509ee6ddb.png)'
  prefs: []
  type: TYPE_IMG
- en: According to OWASP, a function injection attack consists of the insertion or
    **injection **of a function name from the client into an application. A successful
    function injection exploit can execute any built-in or user-defined function.
    Function injection attacks are a type of injection attack in which arbitrary function
    names, sometimes with parameters, are injected into an application and executed.
    If parameters are passed to the injected function, this leads to RCE.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the Drupal API documentation, the `LinkItem` class is used to
    implement the `link` field type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13a4dcde-1e0f-4148-a7ad-be1fc1c8d976.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We know that the `LinkItem` class passes unsanitized user input to the `unserialize()`
    function, but to invoke this class, we need to invoke an entity first. An entity
    would be one instance of a particular entity type, such as a comment, a taxonomy
    term, or a user profile, or a bundle of instances, such as a blog post, article,
    or product. We need to find an entity that is used by `LinkItem` for navigation.
    Let''s search for an entity in the source code using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7bccca3c-e951-4a7d-bb8f-50780360ece6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see from the preceding screenshot, `LinkItem` is used to navigate
    to the `MenuLinkContent.php` and `Shortcut.php` entities and, as we can see from
    the `Shortcut.php` file, the shortcut entity is creating a `link` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90eb533f-940f-4f5d-8317-2f814f4095d0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To trigger the `unserialize()` function, we need to align together all the
    elements that we have explained so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have met two out of the three conditions, the only thing left to
    do is to create our serialized payload. There are various ways to create a serialized
    payload, but we will use a library known as **PHP Generic Gadget Chains** (**PHPGGC**)
    to create a serialized payload for Guzzle. To generate a serialized payload using
    `phpggc`, we use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f1b16264-0f54-4cdb-8b9c-e8acf296f33b.png)'
  prefs: []
  type: TYPE_IMG
- en: The JSON serialized payload generated in the preceding screenshot will call
    the `system()` function and run the `id` command. We will submit the entire payload
    with a `GET/POST/PUT` method in the following URL format: `localhost/node/1?_format=hal_json`
  prefs: []
  type: TYPE_NORMAL
- en: 'The server will execute the `id` command and return us the output shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e99611e3-3515-4e8a-87c2-7e3d72f64152.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have successfully achieved the RCE, but the question still remains: why
    did the serialized payload work? To answer this question, we need to understand
    what general serialized data looks like and learn about serialized formats.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding serialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For a basic understanding of the `serialize()` function, let''s take a look
    at the following PHP code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6bc0db63-b4d7-453f-b13a-f8437195ddf1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding code, we initialized an array named `my_array` with the following
    elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`my_array[0] = "Harpreet"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`my_array[1] = "Himanshu"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We then used the `serialize()` function to generate serialized data for the
    array. As you can see in the following screenshot, the serialized data stream
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f514979-d1e7-4650-a6e2-feae11be981f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The other PHP serialized formats that are commonly used are these:'
  prefs: []
  type: TYPE_NORMAL
- en: '`a`: Array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`b`: Boolean'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i`: Integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d`: Double'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`O`: Common object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r`: Object reference'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s`: String'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`C`: Custom object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Metasploit also has a built-in exploit for this vulnerability. Taking a look
    at the source code of the exploit, we notice that it uses almost the same payload
    as that generated by PHPGCC:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5dfc91eb-4d83-46d3-b7fb-145af8c686a3.png)'
  prefs: []
  type: TYPE_IMG
- en: The only difference is that the command and its length are set dynamically as
    per the input given by us via the exploit options.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see in the following screenshot (where we are calling the `__destruct()`
    function), to perform function injection in `call_user_func()`, we have to control
    the `_fn_close` method so that dangerous functions, such as `system()`, `passthru()`,
    and `eval()`, are easily passed to `call_user_func()` as the first argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea3ce84e-d2e6-4f59-831b-6b207d8dc051.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To control the `_fn_close` method, we have to look at the constructor ( `__construct()`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dccd4d87-9547-458a-8991-9e695d07cffa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As can be seen from the preceding screenshot, the `$methods` array is passed
    as an argument to the constructor. The `__construct()` function will create functions
    by looping through the `$methods` array and then prepending the `_fn_` string.
    If the `$methods` array has a `close` string in it, the string will be prepended
    with `_fn_`, making the `_fn_close `method. Now, let''s see the elements inside
    the `$methods` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0298697-61c6-426b-b948-32420e3352f7.png)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding screenshot, it's clear that the `$methods` array has an element
    with the value `close` in it. Now that we know how to control the `_fn_close`
    method, next, we have to find a way to pass the dangerous function and the command
    to be executed to `_fn_close`. For this, we have to create a **POP chain**.
  prefs: []
  type: TYPE_NORMAL
- en: What is a POP chain?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In memory corruption vulnerabilities such as buffer overflows and format strings,
    if memory defenses such as **Data Execution Prevention** (**DEP**) and **Address
    Space Layout Randomization** (**ASLR**) are in place, code reuse techniques such
    as **Return-to-libc** (**ret2libc**) and **Return-Oriented Programming** (**ROP**)
    can be used to bypass those defenses. Code reuse techniques are also viable in
    the case of PHP-based web applications, which use the concept of objects. One
    code reuse technique that can utilize the properties of the object for exploitation
    is **Property-Oriented Programming (POP)**.
  prefs: []
  type: TYPE_NORMAL
- en: A POP chain is an exploitation approach for object injection vulnerabilities
    in web applications that exploit the ability to arbitrarily modify the properties
    of an object that is injected into a given web application. The data and control
    flow of the victim application can then be manipulated accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a POP chain, the serialized payload uses the `HandlerStack` class
    of `GuzzleHttp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b863d5af-a05a-4373-9aee-26ab0e7d1bfc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ll pass our command to the `handler` method, and the dangerous function
    to the `stack[]` method, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2cd4c36-ebe9-4e5b-a78d-75dfe3b18823.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the destructor is called (the calling is done automatically at the time
    of object destruction), the properties of the `_fn_close` method are passed to
    `call_user_func()`, and `system(id)` is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/130a43e7-9a43-42bf-8dcd-d80855746173.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, we will deserialize the payload.
  prefs: []
  type: TYPE_NORMAL
- en: Deserializing the payload
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To understand the payload more clearly, we can deserialize it and use `var_dump`
    on it. According to the PHP manual, `var_dump` displays structured information
    (including the type and value) about one or more expressions. Arrays and objects
    are explored recursively by `var_dump`, and values are indented to show structure.
    We could also use the `print_r()` function to perform the same operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e4e11bb-a571-4201-ad87-ca29d6df17ec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Since we used the payload based on the `GuzzleHttp` client, we need to have
    Guzzle installed. We can unserialize it using the following PHP code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the code will give us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This, when executed, causes the `system()` function to be executed with the
    command passed as an argument to this function, and the output is returned to
    us.
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting RESTful Web Services RCE via unserialize() using Metasploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we understand the concept of serialization and how a payload is serialized,
    let''s use the Metasploit `exploit` module to exploit this vulnerability. Let''s
    execute the following command to use the `exploit` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53af4093-02c2-4f7e-a999-34476b2a707d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We then set the options and run the exploit. Upon running the Metasploit module,
    we will observe that it first performs a patch-level check by asking `CHANGELOG.txt`
    to look for the **SA-CORE-2019-003** patch. The `id` command is executed to confirm
    the RCE on the Drupal installation as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a8a4bfbc-a4ce-4363-8680-084c41f9b7b3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Upon successful exploitation, the server will return the output of the `id`
    command as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1623bd94-efad-4951-90f7-103f4d0f8ddd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, the PHP meterpreter code is serialized and sent to the server and a meterpreter
    session opens in our Metasploit, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2339fefb-69b9-4c2e-9ab8-47141bf4dcce.png)'
  prefs: []
  type: TYPE_IMG
- en: We have achieved access to the Drupal server by exploiting the RESTful Web Services
    module.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter by discussing the architecture of Drupal, as well as
    the directory structure. Then, we learned how to perform reconnaissance of Drupal
    both manually and automatically. After that, we looked at examples of two exploits
    and did a step-by-step walkthrough of the entire exploitation process.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at the enumeration and exploitation of JBoss
    servers.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Can the same vulnerability be used to exploit different versions of Drupal?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do we need to install Drupal locally to exploit a remote Drupal site?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The RESTful API Web Services exploit isn't working – what can we do about this?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have access to the Drupal administrator account – how can we achieve RCE
    on the server?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We found a `.swp`file on a Drupal site – can this be used for exploitation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The architecture of Drupal 8: [https://www.drupal.org/docs/8/modules/entity-browser/architecture](https://www.drupal.org/docs/8/modules/entity-browser/architecture)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An in-depth look at Drupal 8 RCE: [https://www.ambionics.io/blog/drupal8-rce](https://www.ambionics.io/blog/drupal8-rce)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
