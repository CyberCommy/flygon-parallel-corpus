- en: Chapter 5. Behavioral Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter we looked at structural patterns that describe ways in which
    objects can be constructed to ease interaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we''ll take a look at the final, and largest, grouping of GoF
    patterns: behavioral patterns. These patterns are ones that provide guidance on
    how objects share data or, from a different perspective, how data flows between
    objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The patterns we''ll look at are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Chain of responsibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpreter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mediator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memento
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strategy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visitor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once again there are a number of more recently identified patterns that could
    well be classified as behavioral patterns. We'll defer looking at those until
    a later chapter, instead keeping to the GoF patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Chain of responsibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can think of a function call on an object as sending that object a message.
    Indeed this message passing mentality is one that dates back to the days of Smalltalk.
    The chain of responsibility pattern describes an approach in which a message tickles
    down from one class to another. A class can either act on the message or allow
    it to be passed on to the next member of the chain. Depending on the implementation
    there are a few different rules that can be applied to the message passing. In
    some situations only the first matching link in the chain is permitted to act.
    In others, every matching link acts on the message. Sometimes the links are permitted
    to stop processing or even to mutate the message as it continues down the chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chain of responsibility](img/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s see if we can find a good example of this pattern in our go-to example:
    the land of Westeros.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is very little in the way of a legal system in Westeros. Certainly there
    are laws and even city guards who enforce them but the judicial system is scant.
    The law of the land is really decided by the king and his advisors. Those with
    the time and money can petition for an audience with the king who will listen
    to their complaint and pass a ruling. This ruling is law. Of course any king who
    spent his entire day listening to the complaints of peasants would go mad. For
    this reason many of the cases are caught and solved by his advisors before they
    reach his ears.
  prefs: []
  type: TYPE_NORMAL
- en: 'To represent this in code we''ll need to start by thinking about how the chain
    of responsibility would work. A complaint comes in and it starts with the lowest
    possible person who can solve it. If that person cannot or will not solve the
    problem it tickles up to a more senior member of the ruling class. Eventually
    the problem reaches the king who is the final arbiter of disputes. We can think
    of him as the default dispute solver who is called upon when all else fails. The
    chain of responsibility is visible in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](img/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ll start with an interface to describe those who might listen to complaints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The interface requires two methods. The first is a simple check to see if the
    class is able to resolve a given complaint. The second listens to and resolves
    the complaint. Next we''ll need to describe what constitutes a complaint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we need a couple of different classes which implement `ComplaintListener`
    and are able to solve complaints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Each one of these classes implements a different approach to solving the complaint.
    We need to chain them together making sure that the king is in the default position.
    This can be seen in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will work its way through each of the listeners until it finds one
    that is interested in hearing the complaint. In this version the result is returned
    immediately, halting any further processing. There are variations of this pattern
    in which multiple listeners could fire, even allowing the listeners to mutate
    the parameters for the next listener. The following diagram shows multiple listeners
    configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](img/00056.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Chain of responsibility is a highly useful pattern in JavaScript. In browser-based
    JavaScript the events that fire fall through a chain of responsibility. For instance
    you can attach multiple listeners to the click event on a link and each of them
    will fire and then, finally, the default navigation listener. It is likely that
    you're using chain of responsibility in much of your code without even knowing
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The command pattern is a method of encapsulating both the parameters to a method,
    as well as the current object state, and which method is to be called. In effect
    the command pattern packs up everything needed to call a method at a later date
    into a nice little package. Using this approach one can issue a command and wait
    until a later date to decide which piece of code will execute the command. This
    package can then be queued or even serialized for later execution. Having a single
    point of command execution also allows for easily adding functionality such as
    undo or command logging.
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern can be a bit difficult to imagine so let''s break it down into
    its components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Command](img/00057.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Command message
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first component of the command pattern is, predictably, the command itself.
    As I mentioned, the command encapsulates everything needed to invoke a method.
    This includes the method name, the parameters, and any global state. As you can
    imagine keeping track of global state in each command is very difficult. What
    happens if the global state changes after the command has been created? This dilemma
    is yet another reason why using a global state is problematic and should be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of options for setting up commands. At the simple end of
    the scale all that is needed is to track a function and a set of parameters. Because
    functions are first class objects in JavaScript, they can easily be saved into
    an object. We can also save the parameters to the function into a simple array.
    Let's build a command using this very simple approach.
  prefs: []
  type: TYPE_NORMAL
- en: The deferred nature of commands suggests an obvious metaphor in the land of
    Westeros. There are no methods of communicating quickly in Westeros. The best
    method is to attach small messages to birds and release them. The birds have a
    tendency to want to return to their homes, so each lord raises a number of birds
    in their home and, when they come of age, sends them to other lords who might
    wish to communicate with them. The lords keep an aviary of birds and retain records
    of which bird will travel to which other lord. The king of Westeros sends many
    of his commands to his loyal lords through this method.
  prefs: []
  type: TYPE_NORMAL
- en: The commands sent by the king contain all necessary instructions for the lords.
    The command may be something like bring your troops and the arguments to that
    command may be a number of troops, a location, and a date by which the command
    must be carried out.
  prefs: []
  type: TYPE_NORMAL
- en: 'In JavaScript the simplest way of representing this is through an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This array can be passed around and invoked at will. To invoke it, a generic
    function can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this function only works for commands with three arguments.
    You can, of course, expand this to any number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The additional parameters are undefined, but the function doesn't use them so
    there are no ill effects. Of course, this is not at all an elegant solution.
  prefs: []
  type: TYPE_NORMAL
- en: It is desirable to build a class for each sort of command. This allows you to
    ensure the correct arguments have been supplied and easily distinguish the different
    sorts of commands in a collection. Typically, commands are named using the imperative,
    as they are instructions. Examples of this are BringTroops, Surrender, SendSupplies,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s transform our ugly simple command into a proper class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We may wish to implement some logic to ensure that the parameters passed into
    the constructor are correct. This will ensure that the command fails on creation
    instead of on execution. It is easier to debug the issue during creation rather
    than during execution as execution could be delayed, even for days. The validation
    won't be perfect, but even if it catches only a small portion of the errors it
    is helpful.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned these commands can be saved for later use in memory or even written
    to disk.
  prefs: []
  type: TYPE_NORMAL
- en: Invoker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The invoker is the part of the command pattern which instructs the command
    to execute its instructions. The invoker can really be anything: a timed event,
    a user interaction, or just the next step in the process may all trigger invocation.
    When we executed the `simpleCommand` command in the preceding section, we were
    playing at being the invoker. In a more rigorous command the invoker might look
    something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, invoking a command is very easy. Commands may be invoked at
    once or at some later date. One popular approach is to defer the execution of
    the command to the end of the event loop. This can be done in a node with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The function `process.nextTick` defers the execution of a command to the end
    of the event loop such that, if it is executed next time the process has nothing
    to do.
  prefs: []
  type: TYPE_NORMAL
- en: Receiver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final component in the command pattern is the receiver. This is the target
    of the command execution. In our example we created a receiver called `LordInstructions`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The receiver knows how to perform the action that the command has deferred.
    There need not be anything special about the receiver, in fact it may be any class
    at all.
  prefs: []
  type: TYPE_NORMAL
- en: Together these components make up the command pattern. A client will generate
    a command, pass it off to an invoker that may delay the command or execute it
    at once, and the command will act upon a receiver.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of building an undo stack, the commands are special, in that they
    have both an `Execute` and an `Undo` method. One takes the application state forward
    and the other takes it backwards. To perform an undo, simply pop the command off
    the undo stack, execute the `Undo` function, and push it onto a redo stack. For
    redo, pop from redo, execute `Execute`, and push to the undo stack. Simple as
    that, although one must make sure all state mutations are performed through commands.
  prefs: []
  type: TYPE_NORMAL
- en: The GoF book outlines a slightly more complicated set of players for the command
    pattern. This is largely due to the reliance on interfaces that we've avoided
    in JavaScript. The pattern becomes much simpler thanks to the prototype inheritance
    model in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The command pattern is a very useful one for deferring the execution of some
    piece of code. We'll actually explore the command pattern and some useful companion
    patterns in [Chapter 10](part0154_split_000.html#4IRMK1-015e68c68a464f18a9559f448be84435
    "Chapter 10. Messaging Patterns"), *Messaging Patterns*.
  prefs: []
  type: TYPE_NORMAL
- en: Interpreter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The interpreter pattern is an interesting pattern as it allows for the creation
    of your own language. This might sound like something of a crazy idea, we're already
    writing JavaScript, why would we want to create a new language? Since the publication
    of the GoF book **Domain specific languages** (**DSLs**) have had something of
    a renaissance. There are situations where it is quite useful to create a language
    that is specific to one requirement. For instance the **Structured Query** **Language**
    (**SQL**) is very good at describing the querying of relational databases. Equally,
    regular expressions have proven themselves to be highly effective for the parsing
    and manipulation of text.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many scenarios in which being able to create a simple language is
    useful. That''s really the key: a simple language. Once the language gets more
    complicated, the advantages are quickly lost to the difficulty of creating what
    is, in effect, a compiler.'
  prefs: []
  type: TYPE_NORMAL
- en: This pattern is different from those we've seen to this point as there is no
    real class structure that is defined by the pattern. You can design your language
    interpreter however you wish.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For our example let us define a language which can be used to describe historical
    battles in the land of Westeros. The language must be simple for clerics to write
    and easy to read. We''ll start by creating a simple grammar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that we''re just writing out a rather nice syntax that will
    let people describe battles. A battle between Robert Baratheon and RhaegarTargaryen
    at the river Trident would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Using this grammar we would like to build some code which is able to query a
    list of battles for answers. In order to do this we're going to rely on regular
    expressions. For most languages this wouldn't be a good approach as the grammar
    is too complicated. In those cases one might wish to create a lexor and a parser
    and build up syntax trees, however, by that point you may wish to re-examine if
    creating a DSL is really a good idea. For our language the syntax is very simple
    so we can get away with regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we establish is a JavaScript data model for the battle like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we need a parser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'It is likely best that you don''t think too much about that regular expression.
    However, the class does take in a list of battles (one per line) and using `next
    Battle`, allows one to parse them. To use the class we simply need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This data structure can now be queried like one would for any other structure
    in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned earlier there is no fixed way to implement this pattern, so the
    implementation done in the preceding code is provided simply as an example. Your
    implementation will very likely look very different and that is just fine.
  prefs: []
  type: TYPE_NORMAL
- en: Interpreter can be a useful pattern in JavaScript. It is, however, a pretty
    infrequently used pattern in most situations. The best example of a language interpreted
    in JavaScript is the less language that is compiled, by JavaScript, to CSS.
  prefs: []
  type: TYPE_NORMAL
- en: Iterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traversing collections of objects is an amazingly common problem. So much so
    that many languages provide for special constructs just for moving through collections.
    For example C# has a `foreach` loop and Python has `for x in`. These looping constructs
    are frequently built on top of an iterator. An iterator is a pattern that provides
    a simple method for selecting, sequentially, the next item in a collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interface for an iterator looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the land of Westeros there is a well-known sequence of people in line for
    the throne in the very unlikely event that the king was to die. We can set up
    a handy iterator over the top of this collection and simply call `next` on it
    should the ruler die:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This is primed with an array and then we can call it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'An interesting application of iterators is to not iterate over a fixed collection.
    For instance an iterator can be used to generate sequential members of an infinite
    set like the fibonacci sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This is used like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Iterators are handy constructs allowing for exploring not just arrays but any
    collection or even any generated list. There are a ton of places where this can
    be used to great effect.
  prefs: []
  type: TYPE_NORMAL
- en: ECMAScript 2015 iterators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Iterators are so useful that they are actually part of the next generation
    of JavaScript. The iterator pattern used in ECMAScript 2015 is a single method
    that returns an object that contains `done` and `value`. `done` is `true` when
    the iterator is at the end of the collection. What is nice about the ECMAScript
    2015 iterators is that the array collection in JavaScript will support the iterator.
    This opens up a new syntax which can largely replace the `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Iterators are a syntactic nicety that has long been missing from JavaScript.
    Another great feature of ECMAScript-2015 are generators. This is, in effect, a
    built in iterator factory. Our fibonacci sequence could be rewritten like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This is used like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Mediator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing many-to-many relationships in classes can be a complicated prospect.
    Let's consider a form that contains a number of controls, each of which wants
    to know if other controls on the page are valid before performing their action.
    Unfortunately, having each control know about each other control creates a maintenance
    nightmare. Each time a new control is added, each other control needs to be modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'A mediator will sit between the various components and act as a single place
    in which message routing changes can be made. By doing so the mediator simplifies
    the otherwise complex work needed to maintain the code. In the case of controls
    on a form, the mediator is likely to be the form itself. The mediator acts much
    like a real life mediator would, clarifying and routing information exchange between
    a number of parties:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mediator](img/00058.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the land of Westeros there are many times when a mediator is needed. Frequently
    the mediator ends up deceased, but I'm sure that won't be the case with our example.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of great families in Westeros who own large castles and vast
    tracts of land. Lesser lords swear themselves to the great houses forming an alliance,
    frequently supported through marriage.
  prefs: []
  type: TYPE_NORMAL
- en: When coordinating the various houses sworn to them, the great lord will act
    as a mediator, communicating information back and forth between the lesser lords
    and resolving any disputes they may have amongst themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example we''ll greatly simplify the communication between the houses
    and say that all messages pass through the great lord. In this case we''ll use
    the house of Stark as our great lord. They have a number of other houses which
    talk with them. Each of the houses looks roughly like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'They have two functions, one of which receives messages from a third party
    and one of which sends messages out to their great lord, which is set upon instantiation.
    The `HouseStark` class looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: By passing all messages through the `HouseStark` class the various other houses
    do not need to concern themselves with how their messages are routed. This responsibility
    is handed off to `HouseStark` which acts as the mediator.
  prefs: []
  type: TYPE_NORMAL
- en: Mediators are best used when the communication is both complex and well defined.
    If the communication is not complex then the mediator adds extra complexity. If
    the communication is ill defined then it becomes difficult to codify the communication
    rules in a single place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Simplifying communication between many-to-many objects is certainly useful
    in JavaScript. I would actually argue that in many ways jQuery acts as a mediator.
    When acting on a set of items on the page, it serves to simplify communication
    by abstracting away code''s need to know exactly which objects on the page are
    being changed. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Is jQuery shorthand for toggling the visibility of all the elements on the page
    which have the `error` class?
  prefs: []
  type: TYPE_NORMAL
- en: Memento
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the section on the command pattern we talked briefly about the ability to
    undo operations. Creating reversible commands is not always possible. For many
    operations there is no apparent reversing operation which can restore the original
    state. For instance, imagine code which squares a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Giving this code -9 will result in 81 but giving it 9 will also result in 81\.
    There is no way to reverse this command without additional information.
  prefs: []
  type: TYPE_NORMAL
- en: The memento pattern provides an approach to restore the state of objects to
    a previous state. The memento keeps a record of the previous values of a variable
    and provides the functionality to restore them. Keeping a memento around for each
    command allows for easy restoration of non-reversible commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to an undo-stack there are many instances where having the ability
    to roll back the state of an object is useful. For instance doing what-if analysis
    requires that you make some hypothetical changes to state and then observe how
    things change. The changes are generally not permanent so they could be rolled
    back using the memento pattern or, if the projects are desirable, left in place.
    A diagram of the memento pattern can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Memento](img/00059.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'A typical memento implementation involves three players:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Originator**: The originator holds some form of state and provides an interface
    for generating new mementos.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Caretaker**: This is the client of the pattern, it is what requests that
    new mementos be taken and governs when they are to be restored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memento**: This is a representation of the saved state of the originator.
    This is what can be persisted to storage to allow for rolling back.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can help to think of the members of the memento pattern as a boss and a secretary
    taking notes. The boss (caretaker) dictates some memo to the secretary (originator)
    who writes notes in a notepad (memento). From time to time the boss may request
    that the secretary cross out what he has just written.
  prefs: []
  type: TYPE_NORMAL
- en: The involvement of the caretaker can be varied slightly with the memento pattern.
    In some implementation the originator will generate a new memento each time a
    change is made to its state. This is commonly known as copy on write, as a new
    copy of the state is created and the change applied to it. The old version can
    be saved to a memento.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the land of Westeros there are a number of soothsayers, foretellers of the
    future. They work by using magic to peer into the future and examine how certain
    changes in the present will play out in the future. Often there is need for numerous
    foretelling with slightly different starting conditions. When setting their starting
    conditions, a memento pattern is invaluable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start off with a world state which gives information on the state of the
    world for a certain starting point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This `WorldState` class is responsible for tracking all the conditions that
    make up the world. It is what is altered by the application every time a change
    to the starting conditions is made. Because this world state encompasses all the
    states for the application, it can be used as a memento. We can serialize this
    object and save it to disk or send it back to some history server somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing we need is a class which provides the same state as the memento
    and allows for the creation and restoration of mementos. In our example we''ve
    called this as `WorldStateProvider`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally we need a client for the foretelling, which we''ll call `Soothsayer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This class provides a number of convenience methods which alter the state of
    the world and then run a foretelling. Each of these methods pushes the previous
    state into the history array, `startingPoints`. There is also a method, `tryADifferentChange`,
    which undoes the previous state change ready to run another foretelling. The undo
    is performed by loading back the memento which is stored in an array.
  prefs: []
  type: TYPE_NORMAL
- en: Despite a great pedigree it is very rare that client side JavaScript applications
    provide an undo function. I'm sure there are various reasons for this, but for
    the most part it is likely that people do not expect such functionality. However
    in most desktop applications, having an undo function is expected. I imagine that,
    as client side applications continue to grow in their capabilities, undo functionality
    will become more important. When it does, the memento pattern is a fantastic way
    of implementing the undo stack.
  prefs: []
  type: TYPE_NORMAL
- en: Observer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The observer pattern is perhaps the most used pattern in the JavaScript world.
    The pattern is used especially with modern single pages applications; it is a
    big part of the various libraries that provide **Model View View-Model** (**MVVM**)
    functionality. We'll explore those patterns in some detail in [Chapter 7](part0134_split_000.html#3VPBC1-015e68c68a464f18a9559f448be84435
    "Chapter 7. Reactive Programming"), *Reactive Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is frequently useful to know when the value on an object has changed. In
    order to do so you could wrap up the property of interest with a getter and setter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The setter function can now be augmented with a call to some other object which
    is interested in knowing that a value has changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This setter will now notify the listener that a property change has occurred.
    In this case both the old and new value have been included. This is not necessary
    as the listener can be tasked with keeping track of the previous value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The observer pattern generalizes and codifies this idea. Instead of having
    a single call to the listener, the observer pattern allows interested parties
    to subscribe to change notifications. Multiple subscribers can be seen in the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Observer](img/00060.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The court of Westeros is a place of great intrigue and trickery. Controlling
    who is on the throne and what moves they make is a complex game. Many of the players
    in the game of thrones employ numerous spies to discover what moves others are
    making. Frequently these spies are employed by more than one player and must report
    what they have found to all of the players.
  prefs: []
  type: TYPE_NORMAL
- en: The spy is a perfect place to employ the observer pattern. In our particular
    example, the spy being employed is the official doctor to the king and the players
    are very interested in how much painkiller is being prescribed to the ailing king.
    Knowing this can give a player advanced knowledge of when the king might die –
    a most useful piece of information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The spy looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In other languages, the subscriber usually has to comply with a certain interface
    and the observer will call only the interface method. This encumbrance doesn''t
    exist with JavaScript and, in fact, we just give the `Spy` class a function. This
    means that there is no strict interface required for the subscriber. This is an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be used like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This provides a very simple and highly effective way of building observers.
    Having subscribers decouples the subscriber from the observable object.
  prefs: []
  type: TYPE_NORMAL
- en: The observer pattern can also be applied to methods as well as properties. In
    so doing you can provide hooks for additional behavior to happen. This is a common
    method of providing a plugin infrastructure for JavaScript libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'In browsers all the event listeners on various items in the DOM are implemented
    using the observer pattern. For instance, using the popular jQuery library, one
    can subscribe to all the `click` events on buttons on a page by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Even in vanilla JavaScript the same pattern applies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Clearly the observer pattern is very useful when dealing with JavaScript. There
    is no need to change the pattern in any significant fashion.
  prefs: []
  type: TYPE_NORMAL
- en: State
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'State machines are an amazingly useful device in computer programming. Unfortunately
    they are not used very frequently by most programmers. I''m sure that at least
    some of the objection to state machines is that many people implement them as
    a giant `if` statement like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This is just a sample of what could be much longer. The `if` statements of this
    length are painful to debug and highly error prone. Simply flipping a greater
    than sign is enough to drastically change how the `if` statement works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using a single giant `if` statement block we can make use of the
    state pattern. The state pattern is characterized by having a state manager which
    abstracts away the internal state and proxies a message through to the appropriate
    state which is implemented as a class. All the logic within states and governing
    state transitions is governed by the individual state classes. The state manager
    pattern can be seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![State](img/00061.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Splitting state into a class per state allows for much smaller blocks of code
    to debug and makes testing much easier.
  prefs: []
  type: TYPE_NORMAL
- en: The interface for the state manager is fairly simple and usually just provides
    the methods needed to communicate with the individual states. The manager may
    also contain some shared state variables.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As alluded to in the `if` statement example, Westeros has a banking system.
    Much of it is centered on the island of Braavos. Banking there runs in much the
    same way as banking here, with accounts, deposits, and withdrawals. Managing the
    state of a bank account involves keeping an eye on all of the transactions and
    changing the state of the bank account in accordance with the transactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at some of the code which is needed to manage a bank account
    at the Iron Bank of Braavos. First is the state manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `BankAccountManager` class provides a state for the current balance and
    also the current state. To protect the balance, it provides an accessory for reading
    the balance and another for adding to the balance. In a real banking application,
    I would rather expect the function that sets the balance, have more protection
    than this. In this version of `BankManager`, the ability to manipulate the current
    state is accessible to the states. They have the responsibility to change states.
    This functionality can be centralized in the manager but that increases the complexity
    of adding new states.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve identified three simple states for the bank account: `Overdrawn`, `OnHold`,
    and `GoodStanding`. Each one is responsible for dealing with withdrawals and deposits
    when in that state. The `GoodStandingstate` class looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OverdrawnState` class looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `OnHold` state looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we've managed to reproduce all the logic of the confusing `if`
    statement in a number of simple classes. The amount of code here looks to be far
    more than the `if` statement but, in the long run, encapsulating the code into
    individual classes will pay off.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is plenty of opportunity to make use of this pattern within JavaScript.
    Keeping track of state is a typical problem in most applications. When the transitions
    between the states are complex, then wrapping it up in a state pattern is one
    method of simplifying things. It is also possible to build up a simple workflow
    by registering events as sequential. A nice interface for this might be a fluent
    one so that you could register states like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It has been said that there is more than one way to skin a cat. I have, wisely,
    never looked into how many ways there are. The same is frequently true for algorithms
    in computer programming. Frequently there are numerous versions of an algorithm
    that trades off memory usage for CPU usage. Sometimes there are different approaches
    that provide different levels of fidelity. For example, performing a geo-location
    on a smart phone typically uses one of three different sources of data:'
  prefs: []
  type: TYPE_NORMAL
- en: GPS chip
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cell phone triangulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nearby WiFi points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the GPS chip provides the highest level of fidelity however it is also
    the slowest and requires the most battery. Looking at the nearby WiFi points requires
    very little energy and is very quick, however it provides poor fidelity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The strategy pattern provides a method of swapping these strategies out in
    a transparent fashion. In a traditional inheritance model each strategy would
    implement the same interface which would allow for any of the strategies to be
    swapped in. The following diagram shows multiple strategies that could be swapped
    in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Strategy](img/00062.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Selecting the correct strategy to use can be done in a number of different ways.
    The simplest method is to select the strategy statically. This can be done through
    a configuration variable or even hard coded. This approach is best for times when
    the strategy changes infrequently or is specific to a single customer or user.
  prefs: []
  type: TYPE_NORMAL
- en: Alternately an analysis can be run on the dataset on which the strategy is to
    be run and then a proper strategy selected. If it is known that strategy A works
    better than strategy B when the data passed in is clustered around a mean, then
    a fast algorithm for analyzing spread could be run first and then the appropriate
    strategy selected.
  prefs: []
  type: TYPE_NORMAL
- en: If a particular algorithm fails on data of a certain type, this too can be taken
    into consideration when choosing a strategy. In a web application this can be
    used to call a different API depending on the shape of data. It can also be used
    to provide a fallback mechanism should one of the API endpoints be down.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting approach is to use progressive enhancement. The fastest
    and least accurate algorithm is run first to provide rapid user feedback. At the
    same time a slower algorithm is also run and, when it is finished, the superior
    results are used to replace the existing results. This approach is frequently
    used in the GPS situation outlined above. You may notice when using a map on a
    mobile device your location is updated a moment after the map loads; this is an
    example of progressive enhancement.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the strategy can be chosen completely at random. It sounds like a strange
    approach but can be useful when comparing the performance of two different strategies.
    In this case, statistics would be gathered about how well each approach works
    and an analysis run to select the best strategy. The strategy pattern can be the
    foundation for A/B testing.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting which strategy to use can be an excellent place to apply the factory
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the land of Westeros there are no planes, trains, or automobiles but there
    is still a wide variety of different ways to travel. One can walk, ride a horse,
    sail on a seagoing vessel, or even take a boat down the river. Each one has different
    advantages and drawbacks but in the end they still take a person from point A
    to point B. The interface might look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The travel result communicates back to the caller some information about the
    method of travel. In our case we track how long the trip will take, what the risks
    are, and how much it will cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In this scenario we might like to have an additional method which predicts some
    of the risks to allow for automating selection of a strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing the strategies is as simple as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In a traditional implementation of the strategy pattern the method signature
    for each strategy should be the same. In JavaScript there is a bit more flexibility
    as excess parameters to a function are ignored and missing parameters can be given
    default values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, the actual calculations around risk, cost, and duration would not
    be hard coded in an actual implementation. To make use of these one needs only
    to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To improve the level of abstraction for this strategy we might replace the
    specific strategies with more generally named ones that describe what it is we''re
    optimizing for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Strategy is a very useful pattern in JavaScript. We''re also able to make the
    approach much simpler than in a language which doesn''t use prototype inheritance:
    there is no need for an interface. We don''t need to return the same shaped object
    from each of the different strategies. So long as the caller is somewhat aware
    that the returned object may have additional fields, this is a perfectly reasonable,
    if difficult to maintain, approach.'
  prefs: []
  type: TYPE_NORMAL
- en: Template method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The strategy pattern allows for replacing an entire algorithm with a complimentary
    one. Frequently, replacing the entire algorithm is overkill: the vast majority
    of the algorithm remains the same in every strategy with only minor variations
    in specific sections.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The template method pattern is an approach which allows for some sections of
    an algorithm to be shared and other sections implemented using different approaches.
    These farmed out sections can be implemented by any one of a family of methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Template method](img/00063.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The template class implements parts of the algorithm and leaves other parts
    as abstract to later be overridden by classes which extend it. The inheritance
    hierarchy can be several layers deep, with each level implementing more and more
    of the template class.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An abstract class is one that contains abstract methods. Abstract methods are
    simply methods that have no body to them. The abstract class cannot be used directly
    and must, instead, be extended by another class that implements the abstract methods.
    An abstract class may extend another abstract class so that not all methods need
    to be implemented by the extending class.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach applies the principles of progressive enhancement to an algorithm.
    We move closer and closer to a fully implemented algorithm and, at the same time,
    build up an interesting inheritance tree. The template method helps keep identical
    code to a single location while still allowing for some deviation. A chain of
    partial implementations can be seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Template method](img/00064.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Overriding methods left as abstract is a quintessential part of object oriented
    programming. It is likely that this pattern is one which you've used frequently
    without even being aware that it had a name.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I have been told, by those in the know, that there are many different ways to
    produce beer. These beers differ in their choice of ingredients and in their method
    of production. In fact beer does not even need to contain hops – it can be made
    from any number of grains. However there are similarities between all beers. They
    are all created through the fermentation process and all proper beers contain
    some alcohol content.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Westeros there are a great number of craftsmen who pride themselves on creating
    top notch beers. We would like to describe their processes as a set of classes,
    each one describing a different beer making methodology. We start with a simplified
    implementation of creating a beer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'As there is no concept of abstract in JavaScript we''ve added exceptions to
    the various methods which must be overridden. The remaining methods can be changed
    but do not require it. An implementation of this for a raspberry beer would look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Additional sub-classing may be performed at this stage for more specific raspberry
    beers.
  prefs: []
  type: TYPE_NORMAL
- en: The template method remains a fairly useful pattern in JavaScript. There is
    some added syntactic sugar around creating classes, but it isn't anything we haven't
    already seen in a previous chapter. The only warning I would give is that the
    template method uses inheritance and thus strongly couples the inherited classes
    with the parent class. This is generally not a desirable state of affairs.
  prefs: []
  type: TYPE_NORMAL
- en: Visitor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final pattern in this section is the visitor pattern. The visitor provides
    a method of decoupling an algorithm from the object structure on which it operates.
    If we wanted to perform some action over a collection of objects which differ
    in type and we want to perform a different action depending on the object type,
    we would typically need to make use of a large `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get right into an example of this in Westeros. An army is made up of
    a few different classes of fighting person (it is important that we be politically
    correct as there are many notable female fighters in Westeros). However, each
    member of the army implements a hypothetical interface called `IMemberOfArmy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'A simple implementation of this might be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have a collection of these different types, we can use an `if` statement
    to only call the `printName` function on the knights:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Except, if you run this code, you''ll actually find that all we get is the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This is because, despite an object being a knight, it is still an object and
    `typeof` will return object in all cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative approach is to use `instanceof` instead of `typeof`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The instance of approach works great until we run into somebody who makes use
    of the `Object.create` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Despite being a knight this will return `false` when asked if it is an instance
    of `Knight`.
  prefs: []
  type: TYPE_NORMAL
- en: This poses something of a problem for us. The problem is exacerbated by the
    visitor pattern as it requires that the language supports method overloading.
    JavaScript does not really support this. There are various hacks which can be
    used to make JavaScript somewhat aware of overloaded methods but the usual advice
    is to simply not bother and create methods with different names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s not abandon this pattern just yet, though; it is a useful pattern. What
    we need is a way to reliably distinguish one type from another. The simplest approach
    is to just define a variable on the class which denotes its type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Given the new `_type` variable we can now fake having real method overrides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Given this approach we can now implement a visitor. The first step is to expand
    our various members of the army to have a generic method on them which takes a
    visitor and applies it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to build a visitor. This code approximates the `if` statements
    we had in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'This visitor would be used as such:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see we''ve pushed the decisions about the type of the item in the
    collection down to the visitor. This decouples the items themselves from the visitor
    as can be seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Visitor](img/00065.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If we allow the visitor to make decisions about what methods are called on the
    visited objects there is a fair bit of trickery required. If we can provide a
    constant interface for the visited objects then all the visitor needs do is call
    the interface method. This does, however, move logic from the visitor into the
    objects that are visited, which is contrary to the idea that the objects shouldn't
    know they are part of a visitor.
  prefs: []
  type: TYPE_NORMAL
- en: Whether suffering through the trickery is worthwhile is really an exercise for
    you. Personally I would tend to avoid using the visitor pattern in JavaScript
    as the requirements to get it working are complicated and non-obvious.
  prefs: []
  type: TYPE_NORMAL
- en: Hints and tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a couple of brief tips to keep in mind about some of the patterns
    we''ve seen in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: When implementing the interpreter pattern you may be tempted to use JavaScript
    proper as your DSL and then use the `eval` function to execute the code. This
    is actually a very dangerous idea as `eval` opens up an entire world of security
    issues. It is generally considered to be very bad form to use `eval` in JavaScript.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you find yourself in the position to audit the changes to data in your project,
    then the memento pattern can easily be modified to suit. Instead of keeping track
    of just the state changes, you can also track when the change was made and who
    changed it. Saving these mementos to disk somewhere allows you to go back and
    rapidly build an audit log pointing to precisely what happened to change the object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The observer pattern is notorious for causing memory leaks when listeners aren't
    properly unregistered. This can happen even in a memory managed environment such
    as JavaScript. Be wary of failing to unhook observers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we've looked at a bunch of behavioral patterns. Some of these
    patterns such as observer and iterator will be ones you'll use almost every day,
    while others such as interpreter you might use no more than a handful of times
    in your entire career. Learning about these patterns should help you identify
    well-defined solutions to common problems.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the patterns are directly applicable to JavaScript and some of them,
    such as the strategy pattern, become more powerful in a dynamic language. The
    only pattern we found that has some limitations is the visitor pattern. The lack
    of static classes and polymorphism makes this pattern difficult to implement without
    breaking proper separation of concerns.
  prefs: []
  type: TYPE_NORMAL
- en: These aren't, by any means, all of the behavioral patterns in existence. The
    programming community has spent the past two decades building on the ideas of
    the GoF book and identifying new patterns. The remainder of this module is dedicated
    to these newly identified patterns. The solutions may be very old ones but not
    generally recognized as common solutions until more recently. As far as I'm concerned
    this is the point where the module starts to get very interesting as we start
    looking at less well known and more JavaScript-specific patterns.
  prefs: []
  type: TYPE_NORMAL
