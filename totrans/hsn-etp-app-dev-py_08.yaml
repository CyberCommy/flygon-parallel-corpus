- en: Writing Testable Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this chapter, we have entered part two of our book, which covers the development
    of enterprise-grade applications using Python. While part one of this book focused
    on how to build an enterprise-grade application with scalability and performance
    in mind, part two of this book focuses on the internal development aspects of
    the application, such as how we can make sure our application is secure, how well
    it is performing, and how to ship an application with the higher quality checks
    in place so as to minimize the occurrence of unexpected behaviors during the production
    phase.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we would like to bring your focus to a very important aspect
    of the enterprise application development or, for that sake, an ...
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code listings in this book can be found under `chapter08` directory at [https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python](https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python).
  prefs: []
  type: TYPE_NORMAL
- en: The code samples related to the unit testing and functional testing for the
    bugzot application developed in [chapter 6](68cb369b-628d-4950-91fd-b165b961c660.xhtml),
    *Example â€“ Building BugZot,* can be found under the `chapter06` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code samples can be cloned by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This includes the instructions regarding how to run the code. In addition to
    that, this chapter requires the installation of a Python library, which allows
    us to simplify the writing of our test code. The library and all the related dependencies
    can be installed by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The importance of testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As developers, we usually aim at working on challenging problems, trying to
    navigate through the complex connections, and coming up with a solution. But how
    many times do we care to look at all the possible ways through which our code
    can fail to provide the expected outcome? As much as it is hard to try to break
    something that we as developers have written ourselves, it forms one of the most
    important aspects of the development cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the time when testing becomes an important aspect of the development
    life cycle. The aim of application testing can be summed up by answering the following
    questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Are the individual components in the code performing as per the expectations?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the flow of the code from ...
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The different kinds of testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the focus is on shipping a quality application, whether it be for general
    customers or for an enterprise, there are multiple kinds of testing that need
    to be performed. These testing techniques may start at different points in the
    development life cycle of the application, and hence are categorized accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, instead of focusing on some testing methodologies that can
    be grouped as black-box testing and white-box testing, we will rather focus our
    effort on understanding the terminology associated with the developers. So, let's
    take a look.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we start to build our application, we have the application divided into
    a number of submodules. These submodules contain a number of classes or methods
    that interact together to achieve a certain output.
  prefs: []
  type: TYPE_NORMAL
- en: For the correct output to be generated, all the individual classes and methods
    need to work correctly, otherwise the results will differ.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when our target is to check the correctness of the individual components
    of a code base, we usually write tests that target these individual components
    independently from the other components of the application. This kind of testing,
    where an individual component is tested independently of the other components,
    is known as **unit testing**.
  prefs: []
  type: TYPE_NORMAL
- en: To state this briefly, the following are some ...
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An application is not merely complete once all of its individual components
    have been written. To produce any meaningful output, these individual components
    need to interact with each other in different possible ways based upon the type
    of input that has been provided. To have a complete check of the application code
    base, the components that make up the application not only need to be tested in
    isolation, but also when they are interacting with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing starts once the application is out of the unit testing phase.
    Inside integration testing, individual components are made to interact with each
    other through the use of interfaces, and this interaction is then tested to see
    if the results being produced are according to the expectations or not.
  prefs: []
  type: TYPE_NORMAL
- en: During the integration testing phase, not only the interaction between the components
    of the application is tested, but also the interaction between the components
    and any other external service, such as third-party APIs and databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'In brief, here are some of the features of integration testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Focus on testing the interfaces:** Since the different components of an application
    interact with each other through the use of interfaces exposed by the components,
    the role of integration testing is to validate that these interfaces are working
    as expected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Usually starts after unit testing:** Once the components have passed the
    unit tests, they are then integrated together to connect with each other and integration
    testing is then performed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code flow testing:** In contrast to unit testing, where the individual components
    are tested in isolation and any dependency on any other component is usually mocked,
    the integration tests usually focus on the flow of data from one component to
    another, and hence also check the outcome of the code flow'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we can see, integration testing forms an important part of the application
    testing process, where the aim is to validate if the different components of an
    application are able to interact with each other properly or not.
  prefs: []
  type: TYPE_NORMAL
- en: Once integration testing is complete, the next phase in the testing process
    is to move to system testing, followed by the final stage of acceptance testing.
    The following image shows the flow of testing from the Unit testing stage to the
    acceptance testing stage and the different kinds of testing that may happen during
    the development of the application.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/41db4532-20e4-4094-9b2e-70b3b66500e8.png)'
  prefs: []
  type: TYPE_IMG
- en: To keep the length of this book in check, we will skip over the explanation
    of these two testing techniques and instead focus the rest of this chapter on
    implementing some hands-on unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: For the rest of this chapter, we will keep our focus on the unit testing practices
    and how we can implement them in our demo application.
  prefs: []
  type: TYPE_NORMAL
- en: Building an application with testing in mind
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, we now know that testing is important and we've also got to know about the
    different kinds of testing. But are there any important things that we need to
    do while building our application so that we are able to test it properly?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer to this question is a bit complicated. Although we can easily write
    the code in any particular manner we desire, and subject the code to testing through
    a number of procedures, for example, unit testing, it is still better to follow
    a general set of guidelines so that the code can be tested easily and efficiently.
    So, let''s go ahead and take a look at the guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Every component should have one responsibility:** For testing to be efficient
    and to cover ...'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test-driven development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test-driven development is a software development process where the process
    of software development involves the writing of tests for the individual requirements
    first, and then building or improving methods that will pass those tests. This
    kind of process usually benefits in terms of producing an application with a smaller
    number of defects than it would have if the tests would have been written once
    the components were developed.
  prefs: []
  type: TYPE_NORMAL
- en: 'During test-driven development, the following steps are followed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Add a test:** Once the requirements are specified, the developers start by
    writing a new test for a new component of improvement in the previous component.
    This test sets the expected outcome from the particular component.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Run the tests to see if the new test fails:** When the new test has been
    added, the tests are run against the code to see if the new test fails for the
    expected reasons. This assures us that the test works as expected and does not
    pass in unfavorable conditions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Write/modify the component:** Once the tests have been run and an expected
    result can be seen, we move on to either writing the new component or modifying
    the existing component so that the newly added test case passes.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Run tests:** Once the required modification has been made for the test to
    pass, the test suite is made to run again to see if the previously failing test
    now passes or not. This assures that the modifications are working as expected.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Refactor:** As we progress in the development life cycle of the application
    following the TDD process, there will be times when there will be tests that will
    be duplicated or components that might be playing the same responsibility. To
    remove these issues, constant refactoring is required so as to reduce the duplication.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we have quite an understanding about how much the testing plays an important
    role in the development of any successful application, and also about how to write
    code that can be tested easily. Now, it's time for us to get our hands dirty and
    start writing some tests for the application that we built in [chapter 6](68cb369b-628d-4950-91fd-b165b961c660.xhtml),
    *Example â€“ Building BugZot*.
  prefs: []
  type: TYPE_NORMAL
- en: Writing unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, it's time to start writing our unit tests. The Python library provides us
    with a lot of options to write tests and that too, quiet easily. We are usually
    spoilt for choice. The library in itself provides a unit testing module which
    can be used to write unit tests, and then there is no shortage of the frameworks
    that we can use to make our life easier while writing unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's first take a look at writing some simple unit tests with the Python
    `unittest` module, and then we will move on to writing unit tests for our application
    using one of the renowned Python testing frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Writing unit tests with Python unittest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python 3 provides a really nice and quite a featured library that allows us
    to write unit tests for our applications. This library, known as `unittest`, is
    used for writing unit tests that may range from the complexity of very simple
    tests to very complex tests involving a proper setup before a unit test is made
    to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the features that we see supported in the Python `unittest` library
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Object-oriented:** The library facilitates the writing of unit tests in an
    object-oriented manner. What this means is that, the objects are written in an
    object-oriented form through the use of classes and methods. This in no sense
    means that only object-oriented code can be tested with the library. The library
    does support testing object-oriented and non-object-oriented code alike.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ability for test fixtures:** Some of the tests may require the environment
    to be set up in a certain way before the test is run and then cleaned up properly
    once the test completes execution. This is known as test fixture and is fully
    supported by the Python `unittest` library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ability to write test suites:** The library provides the functionality for
    writing fully featured test suites that are composed of multiple test cases. The
    results of a test suite are aggregated and displayed at once.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Built-in test runner:** A test runner is used to orchestrate the tests and
    compile the results of the executed tests to generate a report. The library provides
    a built-in test runner to achieve this functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at following code, which we will use to write our unit
    tests on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we have defined some functions that aim to help us with the generation
    of the password hash that can than be safely stored inside the database.
  prefs: []
  type: TYPE_NORMAL
- en: Now, our aim is to utilize the Python `unittest` library to write some unit
    tests for the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code aims to implement a small set of unit tests for the passwords
    helper module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We created a simple file for running our unit tests. Now, let's take a look
    at what this file does.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we import the functions that we want to test from their required module.
    For this example, we have these functions defined inside a file named `helpers.py`
    from which we are going to import them. The next import gets us the Python unittest
    library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the required things imported, the next step is to start writing
    the unit tests. To do this, we start with defining a class named `TestPasswordHelpers`
    that inherits from the `unittest.TestCase` class. The class is used to define
    a set of test cases that we may want to execute, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the class definition, we then move on to defining individual test cases
    for the methods that we want to test. The methods that define a test case must
    start with the word `test` so as to signify that this particular method is a test
    and needs to be executed by the test runner. For example, the method that is responsible
    for testing our `strip_password` method is named as `test_strip_password()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the method definition, we are using assertions to validate if the output
    of a particular method is what we expected or not. For example, the `assertEqual`
    method is used to assert whether the parameter 1 matches with the parameter 2
    or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once these tests have been defined, the next thing to do is define an entry
    point for our test file when it is run through the Terminal. This is done by calling
    the `unittest.main()` method from the entry point. Once the call is made, the
    test cases mentioned in the file are run and an output is displayed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is as easy as it can get when you want to write unit tests with Python.
    Now, it's time for us to move on to something that is more important. Let's write
    some unit tests for our demo application.
  prefs: []
  type: TYPE_NORMAL
- en: Writing unit tests with pytest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed, writing unit tests in Python can be done with a number of options
    at our disposal. For example, in the previous section, we utilized Python's `unittest`
    library to write our unit tests. In this section, we will move on to writing unit
    tests with `pytest`, which is a framework for writing unit tests for applications.
  prefs: []
  type: TYPE_NORMAL
- en: But what benefits does `pytest` provide that mean we should move toward it?
    Why can't we just stick with the `unittest` library that comes bundled with Python?
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the `unittest` library provides us with a lot of flexibility coupled
    with the ease of use, there are still a number of improvements that `pytest` brings
    to the table, so let''s take a look at what these improvements are:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's set up pytest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `pytest` framework is a standalone framework that comes as a separate library
    outside of standardized Python distribution. Before we can start writing tests
    using the `pytest`, we need to install `pytest`. Getting `pytest` installed is
    not a big task, and can be done easily by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, before we start writing tests for our application, let''s first create
    a new directory named *tests* under our application directory and at the same
    level as where our `run.py` resides, to store these test cases by running the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, it's time to write our first test with `pytest`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing our first test with pytest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our demo application, we defined a number of models that will be used to
    store the data in the database. As our first test, let's target writing a test
    case for our models.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows a simple test case for our `User` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Writing functional tests with pytest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `pytest` framework, along with its unique fixtures and the power of `flask`,
    allows us to write functional tests easily for our application. This allows us
    to test the API endpoints we have built with quite some ease.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at one of the sample tests for our index API endpoint, and
    then we will deep dive into how we wrote the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following piece of code shows a sample test case written using `pytest`
    to test the index API endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This was a very simple functional test that we wrote for testing our index
    API route to see if it was working properly or not. Now, let''s take a look at
    what we did here to get this functional test working:'
  prefs: []
  type: TYPE_NORMAL
- en: The first few lines of code are more or less general, where we import some of
    the libraries that we will be requiring to build our tests.
  prefs: []
  type: TYPE_NORMAL
- en: The interesting work starts from the `test_client()` fixture we have built.
    The fixture is used to get us a flask-based test client that we can use to test
    our application endpoints to see if they are working correctly or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since our application is a database-oriented application that will require
    a database to function correctly, the first thing we need to do is set up a database
    configuration for our application. For the purpose of testing, we can settle with
    an SQLite3 database that can be created quite easily in most of the operating
    systems. The following call provides us with the database we will be using for
    our testing purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The call returns a file descriptor to the database and a URI that we will store
    in the application config.
  prefs: []
  type: TYPE_NORMAL
- en: Once the database has been created, the next thing is to tell our application
    that it is running in a testing environment so that the error handling inside
    the application is disabled to improve the output of the tests. This is done easily
    by setting the `TESTING` flag inside the application configuration to `True`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flask provides us with a simple test client that we can use to run our application
    tests. This client can be obtained by making a call to the application `test_client()`
    method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Once the test client is obtained, we need to set up the application context,
    which is done through calling the `app_context()` method of the Flask application.
  prefs: []
  type: TYPE_NORMAL
- en: With the application context established, we create our database by calling
    the `db.create_all()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once our application context is set up and a database has been created, the
    next thing we do is start the testing. This is achieved by yielding the test client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this is done, the tests now execute and control transfers to the `test_index_route()`
    method where we simply try to load the index route by calling the `get` method
    of the `test_client`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this is done, we check whether the API provided a valid response or not
    by checking the HTTP status code of the response and validating that it was a
    `200`, SUCCESS or not, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the test finishes executing, the control transfers back to the fixture
    and we perform our cleanup by closing the database file descriptor and removing
    the database file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Quite simple, wasn't it? That's how we can write a simple functional test with
    `pytest` and `Flask`. We can even write tests that handle the user authentication
    and database modifications this way, but we will leave this as an exercise for
    you as the reader.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a look at how testing forms an important aspect of
    the application development project and why it is necessary. Here, we took a look
    at the different types of testing that are usually employed during the development
    life cycle and what the uses of different techniques are. We then moved on to
    taking a look at how we can craft our code in a way that makes testing an easy
    and effective process. Moving on, we started digging deeper into the Python language
    to see what facilities it provides for writing up tests. Here, we discovered how
    to use the Python `unittest` library to write unit tests, and how to run them.
    Moving on, we took a look at how we can utilize testing frameworks like `pytest`
    to write test cases ...
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the differences between unit tests and functional tests?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we write unit test suites using Python `unittest`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the role of fixtures in `pytest`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are scopes in `pytest` while writing fixtures?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
