- en: '*Chapter 11*: Let''s Build – Stopwatch App'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we built the beginning of our cool Stopwatch app by
    creating an onboarding screen. Now, it's time to finish our app by building the
    other features our users are going to use.
  prefs: []
  type: TYPE_NORMAL
- en: We'll learn lots of new things so that by the end of this chapter, we'll have
    a pretty cool app that I hope is going to inspire you to create more helpful applications
    for the rest of the world. The stuff we've learned so far and will continue to
    learn should give you all the necessary tools to create simple small applications,
    without the need for another tutorial. Even so, you'll sometimes find yourself
    looking all over the internet for solutions to your problems, and that's OK. We
    all do that, so be happy whenever you find a solution and you can make it work.
  prefs: []
  type: TYPE_NORMAL
- en: To build this React Native mobile app, we're going to start by linking our onboarding
    screen to our actual app by using the React Navigation library. This will help
    us build the navigation of our screens with little to no effort.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we'll start working on the Stopwatch part of our app. Creating the
    Stopwatch functionality is pretty straightforward but not as intuitive as you
    might think.
  prefs: []
  type: TYPE_NORMAL
- en: Once we've created our Stopwatch screen, we will start working on the other
    part of our app, which is the Timer screen. This will teach us how to play sounds
    and how to use what we've already learned by creating the Stopwatch app but with
    a small spin.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we'll learn about local storage and how to use it to make sure our
    onboarding screen is not going to show up every time we open the app since it
    kind of defeats the purpose of having an onboarding screen. So, let's get ready
    and have some fun coding!
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Linking to React Navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Stopwatch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Timer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finalizing our app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can check out this chapter's code by going to GitHub at [https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio](https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio).
    You'll find a folder called `Chapter 11` that contains all the code we've written
    in this chapter. To use that project, please follow the instructions in the `README.md`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Linking to React Navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll begin this challenge by using the same project we used previously in [*Chapter
    10*](B17074_10_epub_Final_SB.xhtml#_idTextAnchor128), *Building an Onboarding
    Screen*. Why, you ask? Well, that's because the purpose of creating an onboarding
    screen was exactly this – to have some sort of introduction to our main app.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, open the folder and get ready to code. We''ll start by importing all the
    necessary packages we''ll need to connect our onboarding screen to any new screen
    we''ll be creating moving forward. Let''s open our terminal and move to our project
    folder. There, we''ll begin by writing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will install the basis of our navigation system. We''ll also need to install
    all the dependencies this package needs, which we can do via the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now that all our dependencies have been installed, let's talk about the **React
    Navigation** library.
  prefs: []
  type: TYPE_NORMAL
- en: There are several options for people trying to create a navigation system with
    React Native, but the most commonly used one is React Navigation. You might be
    wondering why that is, and my answer for you would be that this is the most maintained
    and packed features library of them all. I strongly recommend diving into their
    documentation, which you can find at [https://reactnavigation.org/](https://reactnavigation.org/).
  prefs: []
  type: TYPE_NORMAL
- en: On top of being such a good navigation library for React Native, it also has
    a really easy and straightforward way of setting up your routes, which we'll look
    at later in this chapter. So, on top of being easy to use, it's completely customizable
    and has native support for iOS and Android. What more could you ask for from a
    navigation library?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on with our app and think about what everything should look like.
    I was thinking that once the user is finished with our onboarding screen and they
    hit the **Next** button for the last time, our user will be transported to another
    screen, straight to the **Stopwatch** screen. This screen will have two tabs:
    one for the Stopwatch, which is the main use case of our app, and another for
    the **Timer** screen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For that to work, we''d need two new components from `@react-navigation`: `stack`
    and `bottom-tabs`. Let''s import them with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time for us to install the next package we''ll be using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now that everything has been installed, it's time for us to restructure our
    project so that we have better control over where our files go.
  prefs: []
  type: TYPE_NORMAL
- en: We'll create a new folder inside the root directory of our project called `screens`.
    Next, we must copy and paste our `Onboarding.js` file from the `components` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Once you've moved that file into the proper directory, it's time to check our
    files to make sure they all link to this new path we have for our onboarding screen.
    We also need to see if there are any imports inside `Onboarding.js` that need
    to be modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our imports from inside `Onboarding.js` that need to be changed are for the
    components we''re using inside this screen: `OnboardingItem` and `Paginator`.
    Because those components are not in the same folder anymore, we''ll have to make
    sure they''re imported with the correct path. In our case, the path changes to
    `"../components/OnboardingItem"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Our new imports for the onboarding screen'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_11.1_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.1 – Our new imports for the onboarding screen
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we''re already here, just go to the `scrollTo()` function. Instead
    of the `console.log()` line that we have inside the `else` statement, write the
    following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This is telling `Button` that once it gets to the end of the onboarding screen,
    the next step is to navigate to the next screen, called `''Tab Navigator''`. We''ll
    introduce this screen when we create our routing system. Because we''re using
    a variable called `navigation`, we should also let our component know where to
    get it. Directly above where we''re defining our `Onboarding` function and between
    the parentheses, we''ll allow our function to receive this prop, called `navigation`,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we want to have a working app, we'll have to go to `App.js` and change
    the import for the onboarding screen to the correct path as well. Once we've finalized
    the changes with the correct imports, we can save and run the app. Nothing should
    have changed; all we did was add a new directory so that we have a better folder
    structure. Some text editors or IDEs will automatically change the imports for
    you, so make sure you always read whatever messages might pop up.
  prefs: []
  type: TYPE_NORMAL
- en: Tip of the day
  prefs: []
  type: TYPE_NORMAL
- en: I often refresh my app and check for changes or error messages, especially when
    all the changes inside the app shouldn't change anything visually. This way, I
    can make sure I'm always up to date with whatever happens inside the app when
    it rerenders.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a new folder structure, we can start working on creating the
    routes needed for our app to work. But first, we need to have some placeholders
    for the screen we''re going to work with. So, let''s create two new files in our
    `screens` folder: `Stopwatch.js` and `Timer.js`.'
  prefs: []
  type: TYPE_NORMAL
- en: For both, we'll have the same code, besides the name of our functions, which
    will be written inside the `<Text />` component. We'll need those files to test
    if our routes are working correctly before we start diving into the functionality
    of our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what that placeholder screen looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Placeholder screen for testing out routes'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_11.2_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.2 – Placeholder screen for testing out routes
  prefs: []
  type: TYPE_NORMAL
- en: This example was specifically created for the `Stopwatch.js` file. You'll have
    to create a second one for `Timer.js` as well. As I've already specified, the
    difference between this one and the Timer one is going to be in the name of the
    function and whatever's written inside the `<Text />` component. The rest of it
    should be the same as we're only using these files to test out our routes.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these two new files inside our `screens` folder, we can go
    ahead and create a new file in our root directory called `routes.js`. This is
    where we're going to create the routing system for our cool little app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve created the new file, we can open it and start coding. We''ll
    begin by importing all the necessary packages and files that we''re going to need
    for this routing system. You can see what packages I''m importing by looking at
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Imports for routes.js'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_11.3_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.3 – Imports for routes.js
  prefs: []
  type: TYPE_NORMAL
- en: Now, as you can see, we've been importing all the main packages from `@react-navigation`.
    We started by importing React as we need it to create this component-based routing
    system. Next in line is the `NavigationContainer` component, which was imported
    from `@react-navigation/native`. This component deals with managing the app's
    navigation state and creating the connection between your top-level navigator
    and the app environment.
  prefs: []
  type: TYPE_NORMAL
- en: After this, we imported `createStackNavigator` and `createBottomTabNavigator`.
    To understand how the **Stack Navigator** works, we'd have to start thinking of
    our screens as cards in a deck of cards. You're always placing a new card on top
    of an old card so that you can create a stack of cards. That's basically how React
    Navigation works, always placing a new screen on top of another screen.
  prefs: []
  type: TYPE_NORMAL
- en: The **Bottom Tab Navigator** creates the common bottom bar you usually come
    across whenever an app wants you to have easier access to the main functionality.
    This way, we can let our user quickly switch between the Timer and Stopwatch,
    with each screen having easy access from the bottom bar.
  prefs: []
  type: TYPE_NORMAL
- en: Once we've imported the necessary dependencies to create a routing system for
    our app, it's time to import the screen we'll be using in this system. Of course,
    the onboarding screen is really important as this must be the first screen our
    users see, after which we need the Stopwatch and Timer screens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''re done with the imports, it''s time to see how we can use React
    Navigation to create our routing system. We''ll use `createStackNavigator` and
    `createBottomTabNavigator` to create the variables that we''re going to use as
    components for defining our screens and navigators, so let''s do that now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Creating variables out of our navigation functions'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_11.4_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.4 – Creating variables out of our navigation functions
  prefs: []
  type: TYPE_NORMAL
- en: Having these variables enables us to create easy-to-read routing systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by writing the function for our main screens; that is, Stopwatch
    and Timer. This should be a normal React function that returns the system for
    a Bottom Tab Navigator. So, we''d use the `Tab` variable for this. Let''s see
    what our function looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5 – Main screen routing for the Stopwatch and Timer screens'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_11.5_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.5 – Main screen routing for the Stopwatch and Timer screens
  prefs: []
  type: TYPE_NORMAL
- en: This looks pretty easy to understand, right? We have a `<Tab.Navigator />` component
    that has two screens using the `<Tab.Screen />` component as children. The `Navigator`
    component acts like the glue that lets React Native know that those two screens
    need to be part of the Bottom Tab Navigator.
  prefs: []
  type: TYPE_NORMAL
- en: For every routing system like this, we need a `Navigator` component and then
    some `Screen` components that let `Navigator` know which screens are part of it.
  prefs: []
  type: TYPE_NORMAL
- en: I feel like this is pretty straightforward to use in that anybody could just
    go ahead and start creating routing systems for their apps. I encourage you to
    use routing inside your apps as much as possible, just to see how many options
    and things you can change. React Navigation is extremely customizable, so I'm
    pretty sure you'll be amazed by the possibilities of using this library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the next step is to set up our main stack of screens. We''ll do that the
    same way we''ve set up our `AppTabs()` function component but this time, we''ll
    also use the `<NavigationContainer />` component as this will be our main routing
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6 – Main routing system for our app'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_11.6_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.6 – Main routing system for our app
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at this code of our main function for our routing system might make
    you ask yourself what''s going on here. Fear not – this is not that hard to understand.
    Because this is going to be our main routing system, we''ve used the `<NavigationContainer
    />` component. Inside of it, we have a `<Stack.Navigator />` component creating
    a set of screens that can be applied one on top of each other, just like a deck
    of cards. Here, we have two screens: the `Onboarding` screen and the `AppTabs`
    screen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we saw earlier, we''ve defined the `AppTabs` screen component as a Bottom
    Tab Navigator screen containing our two main screens: `Stopwatch` and `Timer`.'
  prefs: []
  type: TYPE_NORMAL
- en: We also have a `prop` called `options` applied on both of our `<Stack.Screen
    />` components. This prop allows us to apply custom characteristics to our screens.
    Because React Native enables a header bar on each screen in a stack by default,
    we had to get rid of it, so we've given it a value of `false`. If we didn't specify
    this, every time you go to this screen, you'd see the default platform header
    at the top of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have exported this function, we can go inside our `App.js` file
    and apply our routing system. But this file is filled with tons of stuff we don't
    need, so let's clean it up. Delete everything in `App.js` so that we can start
    rewriting it in the best way possible for our use case.
  prefs: []
  type: TYPE_NORMAL
- en: 'After removing everything from inside the file, we can start by importing React.
    After that, import the `AppStack` component we defined earlier in the `routes.js`
    file. Now, all we have to do is create a function called `App()` that returns
    our `<AppStack />` component, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7 – The App.js file after making all the necessary modifications'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_11.7_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.7 – The App.js file after making all the necessary modifications
  prefs: []
  type: TYPE_NORMAL
- en: Now, our `App.js` file looks a lot cleaner, and we've successfully connected
    our routing system to our React Native app. You should test your app! Save everything,
    start the Expo server, and open your preferred simulator or physical device.
  prefs: []
  type: TYPE_NORMAL
- en: Because we've already linked the onboarding screen to the Tab Navigator screen
    in the `scrollTo()` function via the `navigation.navigate()` function, we now
    have a fully functional routing system.
  prefs: []
  type: TYPE_NORMAL
- en: You should now be able to see the onboarding screen first. Hit the **Next**
    button until you get to the last screen. Once you are there, hit **Next** one
    more time, and boom! You're now in the `AppTabs()` Tab Navigator. That's the component
    we've been defining in our `routes.js` file. You can click the **Bottom Tab Navigator**
    button to quickly switch between the Stopwatch and Timer apps.
  prefs: []
  type: TYPE_NORMAL
- en: Our React Navigation implementation was a success! Now, it's time for us to
    start coding the functionality of our Stopwatch screen.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Stopwatch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of you that have already worked a bit with JavaScript might think that
    creating a Stopwatch is as easy as just calling the `setInterval()` function and
    subtracting a number at every iteration. Well, not really, but fear not – we'll
    make this as easy as possible for everyone, regardless of your experience with
    JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's begin by opening our `Stopwatch.js` file, which we can find inside
    the `screens` folder. Right now, there's only some text with the word Stopwatch
    inside of it that is centered because we styled the main `<View />` component.
  prefs: []
  type: TYPE_NORMAL
- en: I'd honestly just start by removing everything from this file and starting fresh
    with the imports. We'll begin by importing `React`, `useState`, and `useEffect`
    from `'react'`. After that, we'll import `StyleSheet` and `SafeAreaView` from
    `'react-native'`. Finally, we will import the `Text`, `Block`, and `Button` components
    from '`galio-framework'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After importing the components that we''re going to use to create this screen,
    it''s time to build a static screen for us to serve as a starting point. Let''s
    take a look at the following code and try to explain it as this is going to be
    our main layout skeleton:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.8 – Basic layout of our Stopwatch component'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_11.8_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.8 – Basic layout of our Stopwatch component
  prefs: []
  type: TYPE_NORMAL
- en: Well, this is a big chunk of code, so let's dive right in and explain it. So,
    after importing everything that we need, we will begin writing our `Stopwatch()`
    functional component. Inside of it, we can see that there's a big `<Block/>` component
    and then a `<SafeAreaView />` component. These are here just to take everything
    in and make sure there won't be any problems if we encounter a phone with a notch.
  prefs: []
  type: TYPE_NORMAL
- en: Up until now, everything has been really easy, so what happens next? We must
    split the screen into two `<Block />` elements, one with a `flex` property of
    `0.32` and the other with a `flex` property of `0.68`. This is so we can make
    sure we'll have an upper side of the screen containing all the buttons and functionality,
    and then a lower part of the screen where all the laps will appear.
  prefs: []
  type: TYPE_NORMAL
- en: On the upper side of the screen, we can see that we have a `<Text />` element
    with a big font size. This will be our time, which is going to be changed when
    we add all the functionality. After that, we have another `<Block />` element
    with the row prop enabled. This has two buttons inside it. We'll use those buttons
    to start/stop the Stopwatch and also create laps whenever someone has finished
    a lap.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we have another `<Block />` element, whose purpose is to make our
    layout a bit more intuitive to the users. It will point out that the laps will
    show up underneath that line. We've created some styling for those lines that
    you can find in the styles object under `divideLine`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows what this will look like on our devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.9 – Basic layout of our Stopwatch screen'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_11.9_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.9 – Basic layout of our Stopwatch screen
  prefs: []
  type: TYPE_NORMAL
- en: Nice! Now that we have the basic layout coded out, it's time to start working
    on the functionality of our screen. We should start by defining some state variables
    that we're going to use all over this screen. But before that, let's go back to
    the beginning for a second and think about why I said that we can't increment
    the time with the `setInterval()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Using setInterval
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So, `setInterval` is a function that does exactly what you''d expect it to
    do. You set a time interval such as 1,000 milliseconds, which is one second, and
    for every second, a function that you''re going to define is going to be called.
    You might think that in theory, we can have something like the following for our
    Stopwatch screen''s functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.10 – setInterval used in a basic example'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_11.10_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.10 – setInterval used in a basic example
  prefs: []
  type: TYPE_NORMAL
- en: This would work pretty well. Here, every 10ms, we're firing the function that
    increments our variable with 10\. In theory, this works great as we'd now have
    a basic Stopwatch built in five lines of code. But the thing is, `setInterval()`
    is not that reliable.
  prefs: []
  type: TYPE_NORMAL
- en: Why am I saying this? Well, if you look at the preceding function, we can see
    that we've specified 10ms as the timing parameter, so our function should fire
    up every 10ms. However, it will not execute the code at the specified time. Instead,
    it will wait *at least* 10ms before it executes. Because of that, we can't say
    our time function will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: I tried a different workaround and I figured out that the best way we can handle
    the time is by using `Date` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve figured this out, let''s write our state variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.11 – State variables used inside the Stopwatch component'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_11.11_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.11 – State variables used inside the Stopwatch component
  prefs: []
  type: TYPE_NORMAL
- en: I've explained each of them but basically, we'll have five controls state variables
    called `startTime`, `laps`, `started`, `elapsed`, and `intervalId`. Then, we have
    the time state variables, which we're going to use to see the time change on the
    screen. These are called `minute`, `seconds`, and `ms`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s use the time state variables and make them visible on the screen.
    Let''s see what that `<Text />` component looks like now, after applying the time
    state variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Because we might have single-digit numbers at one point in time, by writing
    our variables like this, we can make sure that if they're single-digit numbers,
    we'll add one `0` at the beginning. We will do this for both the `minutes` and
    `seconds` variables.
  prefs: []
  type: TYPE_NORMAL
- en: Saving the file and refreshing the screen should show you no changes at all.
    This is good as it means we've implemented the time state variables inside our
    `Stopwatch` component correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that those variables are in place, let''s build a function that will be
    called once we press the **Start** button on the screen. This button needs to
    do several things; first of all, it needs to function as a **Start** and a **Stop**
    button. Secondly, it needs to initialize the `startTime` control state variable
    we''ve just defined with a new `Date` object. Let''s take a look at this function
    now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.12 – The startAndStop() function'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_11.12_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.12 – The startAndStop() function
  prefs: []
  type: TYPE_NORMAL
- en: So, this function can do two things. First, if our `started` state variable
    is `false`, we'll set it to `true` to announce the start of the Stopwatch and
    then set the `startTime` variable to a `new Date()` object. By having a date set
    at the beginning, we can use it later to calculate how much time has passed between
    each iteration, allowing us to have a more accurate time displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, once the started variable has been changed, we need to start the `setInterval()`
    function. Let''s take a look at the following function and talk about how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.13 – The useEffect() implementation for starting the setInterval()
    function'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_11.13_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.13 – The useEffect() implementation for starting the setInterval()
    function
  prefs: []
  type: TYPE_NORMAL
- en: We've implemented this `useEffect()` function because React gave us this cool
    little function that is called every time the component rerenders. The coolest
    thing about it is that we can condition it to work only when the state variable
    in the second parameter is changed. Every time the `started` variable is changed,
    this function is getting called.
  prefs: []
  type: TYPE_NORMAL
- en: The function, which is called once the `started` variable is changed, will be
    the core of our Stopwatch functionality. This functionality will be inside the
    `setInterval()` function. Inside that function, we're setting our elapsed variable
    to a `new Date()` *every 10ms*. After that, we're grabbing our `setInterval()`
    function and applying it to the `intervalId` state variable.
  prefs: []
  type: TYPE_NORMAL
- en: The `return` function inside the `useEffect()` function cleans up after a side
    effect. This means that this function will be called every time the `started`
    variable changes, just to clean up after the previous render. It also gets called
    when the component unmounts. Because we're working with `setInterval()`, I wanted
    to make extra sure that our interval is going to be cleared every time our `started`
    variable is set to `false` (the Stopwatch stops) so that it won't weigh heavily
    on a user's CPU.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, clearing an interval is as easy as calling the `clearInterval()`
    function and passing it the interval we want to clear.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the latest time in our elapsed variable, all we have to do
    is check out the difference between the `elapsed` time and `startTime`. We can
    do this with `useEffect()`. Every time the `elapsed` state variable is changed,
    another `useEffect()` function will trigger. Then, we can do all the math there.
    Let''s take a look at how I''ve done this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.14 – The second useEffect() function, which depends on elapsed'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_11.14_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.14 – The second useEffect() function, which depends on elapsed
  prefs: []
  type: TYPE_NORMAL
- en: 'So, this `useEffect()` function is called every time `elapsed` changes, which
    is every 10ms. What we''re doing here is checking if `elapsed` exists (is not
    undefined) and that `started` is `true`. If both these conditions are true, we
    can use `elapsed`, which contains the latest `Date` value, to work out the difference
    and have it in milliseconds. Moving forward, we do the math for the minutes and
    seconds. Once we have all these values, we can set them to the time state variables
    we defined earlier: `minute`, `seconds`, and `ms`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Wait… are we done? Kind of, but not really. Let''s go to our **Start** button
    and change it a little bit so that it can be used. We''ll change it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This way, we can have different colors and our button will display a different
    text based on whatever it can do at that moment. This is all based on our `started`
    state variable, which tells us if the Stopwatch has started or not. I've picked
    these colors because we've used them in the onboarding screen as well and I thought
    they fit, but you can use whatever colors you want.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can save and reload our JavaScript and check out what we've been creating.
    By pressing the **Start** button, you'll see it change its text into the **Stop**
    button's text, and that its color is now gray. The time started going up and our
    Stopwatch works correctly, but what type of Stopwatch is this if we can't even
    register any laps?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the function that''ll be busy registering the laps. We also need
    a way to display those laps, which we''ll do once we''re done with the function.
    I was thinking that we can use this function just like we used the `startAndStop()`
    function, in that we should be able to register laps and clear all the laps with
    the same button. So, let''s take a look at how I did this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.15 – setLap function used to register and clear all the laps'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_11.15_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.15 – setLap function used to register and clear all the laps
  prefs: []
  type: TYPE_NORMAL
- en: This is a straightforward function; our function can do two different things
    based on what our started state variable value is. If the Stopwatch is started,
    it's OK for us to register new laps but if the Stopwatch is not working anymore,
    we should be able to clear all the laps and get ready for a new session.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have this function, let''s link it to our **Lap** button, just
    like we did with the **Start** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s work on displaying the laps on the screen. We''re going to do that
    by importing `FlatList` from `''react-native''`, so just scroll up to the imports
    part of our file and add `FlatList`. Our new import should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Displaying laps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We should use the `FlatList` component in the `<Block flex={0.68} />` component
    instead of the `<Text />` component currently living there. So, delete the `<Text
    />` component and look at my implementation of `<FlatList />`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.16 – FlatList implemented instead of our Text component'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_11.16_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.16 – FlatList implemented instead of our Text component
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s nothing new here. We''ve already used a `FlatList` component to build
    the onboarding screen, and you''ve probably noticed that we have a new component
    there called `<LapItem />`. I''ve defined this component under our main Stopwatch
    component. You could always move it and create a separate file for it under the
    `components` folder, but I felt like having it close to the main component was
    easier for me to always check out. Let''s check out this component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.17 – The LapItem component being used in FlatList'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_11.17_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.17 – The LapItem component being used in FlatList
  prefs: []
  type: TYPE_NORMAL
- en: This component takes a `prop` called `item`, which is an array containing the
    information needed to display the laps.
  prefs: []
  type: TYPE_NORMAL
- en: 'And with that, we''ve finished this beautiful screen. Save and reload the JavaScript
    and try it out. The following screenshot shows what our app should look like right
    now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.18 – Completed Stopwatch component'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_11.18_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.18 – Completed Stopwatch component
  prefs: []
  type: TYPE_NORMAL
- en: It's working! It looks cool and we've had a great time building this. Now, let's
    start working on the Timer screen.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Timer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we're done with the Stopwatch screen, it's time to open the `Timer.js`
    file and work on our Timer screen. We should dive right in, remove everything,
    and start importing everything we need for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we all know that at the end of a Timer cycle, there''s always
    a sound playing, letting you know that it has stopped. For that, we need a new
    package called `expo-av`. This is an Expo package for dealing with audio. It is
    quite easy to use, so let''s begin by installing it into our project by using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have installed this, we can start importing everything we'll need
    to build this component. We'll need a timer component that is quite similar to
    the Stopwatch. We'll also need to use intervals and date objects to calculate
    everything, so `useEffect` and `useState` will be imperative for our screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference is that we''ll need to let the user input exactly how much time
    they want the Timer to work for. We can do this with a `<TextInput />` component
    from `''react-native''`. Because we''re using an input, we''ll also need a `<KeyboardAvoidingView
    />` component that helps us reorganize the layout so that our inputs will never
    be hidden by the opening of the keyboard. Let''s take a look at our imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.19 – Imports for the Timer screen'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_11.19_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.19 – Imports for the Timer screen
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `import` statements are quite similar to the Stopwatch screen.
    This is because these screens are similar. However, by having them doing the same
    thing, we can learn to always inspire ourselves by looking at what we did in the
    past. All the code you've written will help you with other problems you might
    encounter. Because we've created the Stopwatch screen, we now know of the inaccuracy
    of `setInterval()`and how to combat that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s start creating the basic functionality for our Timer screen with
    a layout that we can work with. For the layout, we''ll start everything the same
    way we''ve started the Stopwatch screen; that is, with a `<Block />` component
    with `styles.container` attached to it. After that, we''ll use `<SafeAreaView
    />` and then a `<KeyboardAvoidingView />` with a `flex: 1` style applied to it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside of that `<KeyboardAvoidingView />` component, we''ll have two `<Block
    />` elements. The first one is going to have a `<TextInput />` component as a
    child that is going to be the title of the Timer. We''re using `<TextInput />`
    here because you may wish to change the title of the timer; this is just a cool
    little feature. The second one is going to have two `<TextInput />` elements –
    one for minutes and one for seconds. This way, the user can input whatever number
    they need for the timer. The second `<Block />` element will also contain the
    **Start/Stop** button of the timer. Let''s see what that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.20 – Layout created for the Timer screen'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_11.20_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.20 – Layout created for the Timer screen
  prefs: []
  type: TYPE_NORMAL
- en: As we explained earlier, this is not that complicated, but what you'll notice
    here is that I've already filled in the value props for our `<TextInput />` components.
    I've also made sure that a state variable is in place for our **Start/Stop** button.
    This is only because we've already been through the Stopwatch screen, which means
    we've already experienced the fact that we'll need certain state variables so
    that we can change the text inside the buttons.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we also used the `editable` prop on our `<TextInput />` components
    since we only want those values to be **editable** when the timer is not working.
    We can also see another new prop, called `returnKeyType`. This prop allows us
    to tell the device which kind of key we want available for our users. I've opted
    for the `done` key because once they add the number they want, they could just
    press that key and move forward.
  prefs: []
  type: TYPE_NORMAL
- en: We also know from the previous chapters that `<TextInput />` is a controlled
    component, which means it needs a state variable for the `value` prop while also
    a way of changing that state via the `onChangeText` prop. Knowing all this, I'd
    suggest reading over that code a couple of times to see if you can understand
    it. We won't make any changes to it anymore as this is enough for us to be able
    to jump right into the Timer's functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the state variables we''ve defined for this Timer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.21 – State variables created for the Timer screen'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_11.21_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.21 – State variables created for the Timer screen
  prefs: []
  type: TYPE_NORMAL
- en: So, at the beginning of our functional component for the Timer screen, we'd
    be writing all these state variables. Just like before, we have some time state
    variables and some controls' state variables. We've already seen `intervalId`
    and `startTimer` (we called it `started` in the Stopwatch screen).
  prefs: []
  type: TYPE_NORMAL
- en: Let's briefly explain the other state variables that we're using. The `countdownMinutes`
    and `countdownSeconds` variables are strictly used to display the minutes and
    seconds of our timer. The `final` variable is there because we'll know how much
    time we want our Timer to last based on the user's input. We'll use it to calculate
    the amount of time once we start the timer.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we also have the `timer` and `timeDisplay` variables. The `timer`
    variable acts just like the `elapsed` variable acted when we were working with
    the Stopwatch screen. The `timeDisplay` variable is here for us to always have
    the value of our timer in seconds. This way, we can make sure to stop it whenever
    it hits `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Our `title` variable is there for the title of the screen, which the user will
    be able to change whenever they want. The sound variable is there because we need
    to know whenever the sound has been loaded on the screen. This will help us use
    another `useEffect()` function so that we can clean up after ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Great! I like how much faster we can move now that we''re done with the Stopwatch
    screen. This means that we''re learning, and experience is the best teacher out
    there! Let''s take a look at the `start()` function, which we''re going to call
    whenever we press the **Start** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.22 – The start() function used to start or stop the timer'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_11.22_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.22 – The start() function used to start or stop the timer
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, we're following the same pattern we used for the Stopwatch screen.
    This enables us to use this function as a start or stop function for our button.
    So, if the `startTimer` state variable is `false`, then we will initialize a new
    variable with a `Date` object. Then, we'll set that date with the minutes and
    seconds we've grabbed from our two `<TextInput />` components from the screen,
    adding those to the current date's minutes and seconds. This means that we've
    taken the current date and added the time our user has inputted. This is the final
    date we're trying to reach, so the next step is setting our `final` state variable
    with the date we've just calculated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we must set the `startTimer` variable to true, which will notify our
    component that the timer has started. At this point, we''ll also load the sound.
    Let''s define the `loadSound()` function for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.23 – The loadSound() function with a new keyword called async'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_11.23_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.23 – The loadSound() function with a new keyword called async
  prefs: []
  type: TYPE_NORMAL
- en: As you might have figured out by now, this function has a new keyword called
    `async`. Worry not – this is here to make sure our function will not stop the
    whole application while we're trying to load that sound. If you don't have a sound
    that you can use, you can find the sound that I've created in this project's files
    on GitHub. You can also create your own sounds or even use something online that
    isn't copyrighted. I followed the `'expo-av'` documentation to load the sounds.
    That's why I'm always stressing the fact that your first step, whenever there's
    something you don't understand, should be to look at the documentation of that
    specific package/library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve loaded the sounds and started our timer, we should be able
    to see where all the logic behind our screen exists. Just like we did previously,
    we''re using `useEffect()` functions to make sure they''re only triggered when
    a certain state variable changes. The first `useEffect()` function we''re going
    to use is going to depend on the `final` state variable. That''s because this
    variable is needed for all the math, so, naturally, we''re going to check for
    it before we do anything else:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.24 – The first useEffect() function depending on the final variable'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_11.24_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.24 – The first useEffect() function depending on the final variable
  prefs: []
  type: TYPE_NORMAL
- en: 'So, this is exactly like what we did previously. Here, we have a `setInterval()`
    function being called – this time, every 250ms – but only if the final variable
    has been initialized. By this, we mean if the user has pressed the **Start**/**Stop**
    button. There''s nothing weird going on down here, so I think we should be able
    to move on and check out the following `useEffect()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.25 – The second useEffect() function depending on the timer variable'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_11.25_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.25 – The second useEffect() function depending on the timer variable
  prefs: []
  type: TYPE_NORMAL
- en: Because we're setting the `timer` state variable in the first `useEffect()`
    function, it will act as a trigger for the second `useEffect()` function so that
    it's called. This is the function where we're doing all the math necessary for
    our timer to work. We're calculating the difference in seconds between the final
    date and the new date we've received from the `timer` variable.
  prefs: []
  type: TYPE_NORMAL
- en: After calculating the difference in seconds, the next step is to check if the
    `timeDisplay` variable is different than the newly calculated difference. If it's
    different, we'll set `timeDisplay` to this new value. We're doing this to make
    sure we're always calculating everything with a new value.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we just do the usual math for calculating the minutes and seconds.
    Next, we must set our `<TextInput />` components via the `countdownMinutes` and
    `countdownSeconds` variables to our newly calculated values. The reason we've
    used `toString()` here is because a `<TextInput />` component only accepts strings
    as values, so with this function, we're transforming the value from a number into
    a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s check out the following `useEffect()` function, which depends on
    the `timeDisplay` state variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.26 – The third useEffect() function depending on the timeDisplay
    variable'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_11.26_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.26 – The third useEffect() function depending on the timeDisplay variable
  prefs: []
  type: TYPE_NORMAL
- en: This one will only work if `timeDisplay` is `0` or less. Once we hit `0`, we
    should stop and reset all the variables we've been using until now. This is where
    we're making sure our interval will be cleared, our `timeDisplay` variable goes
    back to `0`, and that the countdown variables go back to 0\. This should also
    be where we play our sound, so we must check if that sound has been loaded and
    then use the `playAsync()` function to start it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we''ve been loading the sound when our timer application starts, we
    should also unload it when the screen unmounts. Practically speaking, there is
    no reason for us to keep a sound in the memory of our device if we''re not using
    it. We will do this by using a cleanup function inside another `useEffect()` function.
    Let''s check out what that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.27 – The fourth useEffect() function being used only for the cleanup
    function'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_11.27_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.27 – The fourth useEffect() function being used only for the cleanup
    function
  prefs: []
  type: TYPE_NORMAL
- en: So, yet again, this is directly inspired by their documentation. Once the component
    unmounts, we must call this function, which checks if the sound has been loaded.
    If it has, then we must call the `unloadAsync()` function on our `sound` state
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Congratulations! We''re done with the Timer screen! Let''s check out how it
    looks and if it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.28 – Completed Timer screen'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_11.28_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.28 – Completed Timer screen
  prefs: []
  type: TYPE_NORMAL
- en: It looks great! Here, we can change the title; we can also change the timer's
    values and that it works once we hit start. Upon waiting for 30 seconds, a cool
    little sound will play!
  prefs: []
  type: TYPE_NORMAL
- en: With that, we're done with this app! Wait… not really – the Bottom Tab Navigator
    looks kind of empty, so we should add some icons. There are also some small things
    we can still do to enhance the user experience. Let's move on and start adding
    all these little enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: Finalizing our app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we need to add some icons to the Bottom Tab Navigator.. But how
    should we do this? Luckily for us, React Navigation has a pretty straightforward
    way of modifying its default components.
  prefs: []
  type: TYPE_NORMAL
- en: And because we're already here, we should also change the focus color of whatever
    tab we're using at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s go back to our `routes.js` file. Because we want to add icons to
    our tabs, we should import the `Icon` component from `''galio-framework''`. After
    all the imports, we should write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve imported the component that we''ll use to display icons, let''s
    see how we should do that. Search your `AppTabs()` function and find the `<Tab.Navigator
    />` component. Here, we''ll add two new props called `screenOptions` and `tabBarOptions`.
    Let''s quickly check them out and see how exactly we''re using them to implement
    an icon inside our Bottom Tab Navigator:'
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: As of August 14, 2021, React Navigation has been updated to v6 and `tabBarOptions`
    was deprecated in favor of the `options` prop, which works on a per-screen basis.
    For more information regarding versioning and the React Navigation library, I'd
    suggest reading the documentation, which can be found at [https://reactnavigation.org/](https://reactnavigation.org/).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.29 – Our fresh AppTabs() functional component with Icon implemented'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_11.29_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.29 – Our fresh AppTabs() functional component with Icon implemented
  prefs: []
  type: TYPE_NORMAL
- en: So, as we can see, the `screenOptions` prop works with a function that accepts
    the `navigation` and `route` props for each screen. Right now, we're using `route`
    as we want to check which screen is equal to each route. This way, we can have
    a case for every screen in our Bottom Tab Navigator. That function returns an
    object with a key called `tabBarIcon`, which has its value set to a function that's
    gathering a lot of information about the screen our user is currently focusing
    on.
  prefs: []
  type: TYPE_NORMAL
- en: This is where we check if the user is focused on a specific screen. Depending
    on that, we can render different types of icons. So, if the user is focusing on
    the Stopwatch screen, then we'll display a filled-in icon, while if they're not
    focusing, we'll only display the outline of that icon. This is a small detail
    that helps the user know when they're on the screen that they think they're on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, setting the colors for our icons is a lot easier. For this, we''ll use
    the `tabBarOptions` prop. We''ll pass it an object containing two keys: `activeTintColor`
    for when the user is currently focused on that specific screen and `inactiveTintColor`
    for when the user is *not* currently focused on that specific screen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s save this and check out our app! I think we can both agree that it looks
    10x better now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.30 – Final app layout after adding icons to the Bottom Tab Navigator'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_11.30_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.30 – Final app layout after adding icons to the Bottom Tab Navigator
  prefs: []
  type: TYPE_NORMAL
- en: Don't close the `routes.js` file yet! We still have one more thing to do. As
    we discussed in [*Chapter 10*](B17074_10_epub_Final_SB.xhtml#_idTextAnchor128),
    *Building an Onboarding Screen*, the onboarding screen should only appear the
    first time you open the app. There is no reason to always see that onboarding
    screen. A lot of your users will be like, *OK, we get it, it's a Stopwatch app,
    just let me get to the Stopwatch part!*
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we do that, though? This is where `AsyncStorage` comes in handy! For
    us to be able to use this package, we need to install it. Let''s open our terminal
    again and write the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve installed this cool little package, let''s import it inside
    our `routes.js` file. Do that right after our `Icon` import, just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can use this `Icon` import inside our `AppStack()` function. Once you
    have found that function, we should create a state variable called `viewedOnboarding`.
    This variable will help us know if the user has already seen the onboarding screen
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: After defining that variable, we'd need to run a function right at the beginning
    of our mobile app. Do you remember the way we're supposed to that? That's right
    – another `useEffect()` function. I bet you're getting tired of these functions,
    but they're so great!
  prefs: []
  type: TYPE_NORMAL
- en: 'This `useEffect()` function should call another function called `checkOnboarding()`,
    whose purpose is to check if the user has seen the onboarding screen or not. Depending
    on that, we''ll be setting our state variable, `viewedOnboarding`, to either `true`
    or `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.31 – Logic written for our AppStack() function'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_11.31_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.31 – Logic written for our AppStack() function
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need another `async` function. But we can only use this package with
    an `async` function. We'll try to see if the local storage has that item stored
    and if it does, then we'll set the `viewedOnboarding` state variable to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering when exactly we will add that item to our local storage.
    Well, we should do that when our user presses **Next** for the last time inside
    the onboarding screen. So, let's move on to the `Onboarding.js` file and make
    that happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''re in the `Onboarding.js` file, we should begin by importing the
    `AsyncStorage` package again. After this, we should jump straight to the `scrollTo()`
    function. First, we''ll make this function `async`. After that, we have an `if-else`
    statement. We''ll change the *else* part, where we''ve had a `console.log()` living
    for no real reason and have the `navigation.navigate()` function instead. Let''s
    see how we''ll change that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.32 – Our modified scrollTo() function'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_11.32_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.32 – Our modified scrollTo() function
  prefs: []
  type: TYPE_NORMAL
- en: Here, again, we'll try using a try-catch. As you can see, we're using `setItem`
    to set that item to `true` in the local storage. This is how this library knows
    that this item has been set to true in the storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s go back to the `routes.js` file. We''re all set, but we need to
    make sure that we only display that route if our users have not seen the onboarding
    screen yet. We''ll do that with **conditional rendering**, which is a technique
    we''ve been using since the beginning of this chapter. Let''s see what that looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.33 – Conditional rendering applied to our <Stack.Screen /> onboarding
    component'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_11.33_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.33 – Conditional rendering applied to our <Stack.Screen /> onboarding
    component
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we're checking for our state variable, `viewedOnboarding`. If
    this has been set to `false`, that means our user has not seen the onboarding
    screen yet, so our route should be displayed. If this is set to `true`, that means
    we're not going to display any route, practically making the onboarding non-existent.
  prefs: []
  type: TYPE_NORMAL
- en: And with that, we're done with this app! Save all your files, reload your JavaScript,
    and take a look at your app. At first, you'll see the onboarding screen. Tap next
    until it disappears and play around with the Stopwatch and Timer screens. After
    that, open the app again and you'll see something amazing – the onboarding screen
    is not displayed anymore! Instead, you'll be transported straight to the Stopwatch
    screen – more exactly, the Tab Navigator screen.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You now have a pretty cool and functional app at your disposal.
    Go ahead and brag about it to your friends and family; let them see how much you've
    progressed!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has been a long journey for both of us. Fear not! The greater the
    challenge, the better the reward. You have reached the end of a pretty long and
    interesting journey. You now have a fully functional app that you can show to
    your friends. These are the first stepping stones of your journey toward becoming
    a great React Native developer.
  prefs: []
  type: TYPE_NORMAL
- en: We've started this chapter by looking at React Navigation. Creating routes and
    linking them to the onboarding screen was one of the coolest things we've ever
    done. This was also incredibly easy, which proves once again how great the React
    Native community is.
  prefs: []
  type: TYPE_NORMAL
- en: After linking our app to the React Navigation library, we started working on
    the Stopwatch screen. We learned that the `setInterval()` function is not that
    accurate, due to which we started working with date objects, which proved to be
    a lot more efficient for keeping time.
  prefs: []
  type: TYPE_NORMAL
- en: Finishing the Stopwatch screen felt like a big win, so because of that, creating
    our Timer screen went a lot smoother. But yet again, we learned something new
    and that was how to play a sound after the timer finished running. I hope doing
    this opened a lot of doors of creativity for you.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, we focused on the user experience and made sure
    that the user will see some icons whenever they're looking at the Bottom Tab Navigator.
    On top of that, we worked with a library called `AsyncStorage` so that we could
    keep the onboarding screen away from an already experienced user.
  prefs: []
  type: TYPE_NORMAL
- en: Learning so many things was a breath of fresh air. Yes, this was a lot of information,
    but I hope you realize how important it is to tackle as many challenges as possible.
    Just like in real life, they help us build experience, which helps us become great
    programmers.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's get ready for the next chapter, where we're going to discuss what
    other paths you can take as a React Native developer to become a great programmer.
  prefs: []
  type: TYPE_NORMAL
