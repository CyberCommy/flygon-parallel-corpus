- en: '6: Images'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter we’ll dive into Docker images. The aim of the game is to give
    you a **solid understanding** of what Docker images are, and how to perform basic
    operations. In a later chapter we’ll see how to build new images with our own
    applications inside of them (containerizing an app).
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll split this chapter into the usual three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The TLDR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The deep dive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s go and learn about images!
  prefs: []
  type: TYPE_NORMAL
- en: Docker images - The TLDR
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’re a former VM admin you can think of Docker images as being like VM
    templates. A VM template is like a stopped VM — a Docker image is like a stopped
    container. If you’re a developer you can think of them as being similar to *classes*.
  prefs: []
  type: TYPE_NORMAL
- en: You start by *pulling* images from an image registry. The most popular registry
    is [Docker Hub](https://hub.docker.com), but others do exist. The *pull* operation
    downloads the image to your local Docker host where you can use it to start one
    or more Docker containers.
  prefs: []
  type: TYPE_NORMAL
- en: Images are made up of multiple layers that get stacked on top of each other
    and represented as a single object. Inside of the image is a cut-down operating
    system (OS) and all of the files and dependencies required to run an application.
    Because containers are intended to be fast and lightweight, images tend to be
    small.
  prefs: []
  type: TYPE_NORMAL
- en: Congrats! You’ve now got half a clue what a Docker image is :-D Now it’s time
    to blow your mind!
  prefs: []
  type: TYPE_NORMAL
- en: Docker images - The deep dive
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve mentioned a couple of times already that **images** are like stopped containers
    (or **classes** if you’re a developer). In fact, you can stop a container and
    create a new image from it. With this in mind, images are considered *build-time*
    constructs, whereas containers are *run-time* constructs.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1](images/figure6-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1
  prefs: []
  type: TYPE_NORMAL
- en: Images and containers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Figure 6.1 shows high-level view of the relationship between images and containers.
    We use the `docker container run` and `docker service create` commands to start
    one or more containers from a single image. However, once you’ve started a container
    from an image, the two constructs become dependent on each other and you cannot
    delete the image until the last container using it has been stopped and destroyed.
    Attempting to delete an image without stopping and destroying all containers using
    it will result in the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`#### Images are usually small'
  prefs: []
  type: TYPE_NORMAL
- en: The whole purpose of a container is to run an application or service. This means
    that the image a container is created from must contain all OS and application
    files required to run the app/service. However, containers are all about being
    fast and lightweight. This means that the images they’re built from are usually
    small and stripped of all non-essential parts.
  prefs: []
  type: TYPE_NORMAL
- en: For example, Docker images do not ship with 6 different shells for you to choose
    from — they usually ship with a single minimalist shell, or no shell at all. They
    also don’t contain a kernel — all containers running on a Docker host share access
    to the host’s kernel. For these reasons, we sometimes say images contain *just
    enough operating system* (usually just OS-related files and filesystem objects).
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** Hyper-V containers run inside of a dedicated lightweight VM and leverage
    the kernel of the OS running inside the VM.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The official *Alpine Linux* Docker image is about 4MB in size and is an extreme
    example of how small Docker images can be. That’s not a typo! It really is about
    4 megabytes! However, a more typical example might be something like the official
    Ubuntu Docker image which is currently about 110MB. These are clearly stripped
    of most non-essential parts!
  prefs: []
  type: TYPE_NORMAL
- en: Windows-based images tend to be bigger than Linux-based images because of the
    way that the Windows OS works. For example, the latest Microsoft .NET image (`microsoft/dotnet:latest`)
    is over 1.7GB when pulled an uncompressed. The Windows Server 2016 Nano Server
    image (`microsoft/nanoserver:latest`) is slightly over 1GB when pulled and uncompressed.
  prefs: []
  type: TYPE_NORMAL
- en: Pulling images
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A cleanly installed Docker host has no images in its local repository.
  prefs: []
  type: TYPE_NORMAL
- en: The local image repository on a Linux-based Docker host is usually located at
    `/var/lib/docker/<storage-driver>`. On Windows-based Docker hosts this is `C:\
    ProgramData\docker\windowsfilter`.
  prefs: []
  type: TYPE_NORMAL
- en: You can check if your Docker host has any images in its local repository with
    the following command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`The process of getting images onto a Docker host is called *pulling*. So,
    if you want the latest Ubuntu image on your Docker host, you’d have to *pull*
    it. Use the following commands to *pull* some images and then check their sizes.'
  prefs: []
  type: TYPE_NORMAL
- en: If you are following along on Linux and haven’t added your user account to the
    local `docker` Unix group, you may need to add `sudo` to the beginning of all
    the following commands.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Linux example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`Windows example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`As you can see, the images just pulled are now present in the Docker host’s
    local repository. You can also see that the Windows images are a lot larger and
    comprise a lot more layers.'
  prefs: []
  type: TYPE_NORMAL
- en: Image naming
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As part of each command, we had to specify which image to pull. So let’s take
    a minute to look at image naming. To do that we need a bit of background on how
    we store images.
  prefs: []
  type: TYPE_NORMAL
- en: Image registries
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Docker images are stored in *image registries*. The most common registry is
    Docker Hub (https://hub.docker.com). Other registries exist, including 3rd party
    registries and secure on-premises registries. However, the Docker client is opinionated
    and defaults to using Docker Hub. We’ll be using Docker Hub for the rest of the
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Image registries contain multiple *image repositories*. In turn, image repositories
    can contain multiple images. That might be a bit confusing, so Figure 6.2 shows
    a picture of an image registry containing 3 repositories, and each repository
    contains one or more images.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2](images/figure6-2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2
  prefs: []
  type: TYPE_NORMAL
- en: Official and unofficial repositories
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Docker Hub also has the concept of *official repositories* and *unofficial repositories*.
  prefs: []
  type: TYPE_NORMAL
- en: As the name suggests, *official repositories* contain images that have been
    vetted by Docker, Inc. This means they should contain up-to-date, high-quality
    code, that is secure, well-documented, and in-line with best practices (please
    can I have an award for using five hyphens in a single sentence).
  prefs: []
  type: TYPE_NORMAL
- en: '*Unofficial repositories* can be like the wild-west — you should not *expect*
    them to be safe, well-documented or built according to best practices. That’s
    not saying everything in *unofficial repositories* is bad! There’s some **brilliant**
    stuff in *unofficial repositories*. You just need to be very careful before trusting
    code from them. To be honest, you should always be careful when getting software
    from the internet — even images from *official repositories!*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the popular operating systems and applications have their own *official
    repositories* on Docker Hub. They’re easy to spot because they live at the top
    level of the Docker Hub namespace. The following list contains a few of the *official
    repositories*, and shows their URLs that exist at the top-level of the Docker
    Hub namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '**nginx:** https://hub.docker.com/_/nginx/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**busybox:** https://hub.docker.com/_/busybox/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**redis:** https://hub.docker.com/_/redis/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**mongo:** https://hub.docker.com/_/mongo/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the other hand, my own personal images live in the wild west of *unofficial
    repositories* and should **not** be trusted! Here are some examples of images
    in my repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: nigelpoulton/tu-demo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: https://hub.docker.com/r/nigelpoulton/tu-demo/
  prefs: []
  type: TYPE_NORMAL
- en: nigelpoulton/pluralsight-docker-ci
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: https://hub.docker.com/r/nigelpoulton/pluralsight-docker-ci/
  prefs: []
  type: TYPE_NORMAL
- en: Not only are images in my repositories **not** vetted, **not** kept up-to-date,
    **not** secure, and **not** well documented… you should also notice that they
    don’t live at the top-level of the Docker Hub namespace. My repositories all live
    within a second-level namespace called `nigelpoulton`.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll probably notice that the Microsoft images we’ve used do not exist at
    the top-level of the Docker Hub namespace. At the time of writing, they exist
    under the `microsoft` second-level namespace.
  prefs: []
  type: TYPE_NORMAL
- en: After all of that, we can finally look at how we address images on the Docker
    command line.
  prefs: []
  type: TYPE_NORMAL
- en: Image naming and tagging
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Addressing images from official repositories is as simple as giving the repository
    name and tag separated by a colon (`:`). The format for `docker image pull`, when
    working with an image from an official repository is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker image pull <repository>:<tag>`'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Linux examples from earlier, we pulled an Alpine and an Ubuntu images
    with the following two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker image pull alpine:latest` and `docker image pull ubuntu:latest`'
  prefs: []
  type: TYPE_NORMAL
- en: These two commands pull the images tagged as “latest” from the “alpine” and
    “ubuntu” repositories.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following examples show how to pull various different images from *official
    repositories*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]`3`.3.11[PRE5]mongo[PRE6]latest[PRE7]redis[PRE8]latest[PRE9]alpine[PRE10]'
  prefs: []
  type: TYPE_NORMAL
- en: '`A couple of points about those commands.'
  prefs: []
  type: TYPE_NORMAL
- en: First, if you **do not** specify an image tag after the repository name, Docker
    will assume you are referring to the image tagged as `latest`.
  prefs: []
  type: TYPE_NORMAL
- en: Second, the `latest` tag doesn’t have any magical powers! Just because an image
    is tagged as `latest` does not guarantee it is the most recent image in a repository!
    For example, the most recent image in the `alpine` repository is usually tagged
    as `edge`. Moral of the story — take care when using the `latest` tag!
  prefs: []
  type: TYPE_NORMAL
- en: Pulling images from an *unofficial repository* is essentially the same — you
    just need to prepend the repository name with a Docker Hub username or organization
    name. The following example shows how to pull the `v2` image from the `tu-demo`
    repository owned by a not-to-be-trusted person whose Docker Hub account name is
    `nigelpoulton`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]v2[PRE12]tu-demo[PRE13]'
  prefs: []
  type: TYPE_NORMAL
- en: '`In our earlier Windows examples, we pulled a PowerShell and a .NET image with
    the following two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`> docker image pull microsoft/powershell:nanoserver`'
  prefs: []
  type: TYPE_NORMAL
- en: '`> docker image pull microsoft/dotnet:latest`'
  prefs: []
  type: TYPE_NORMAL
- en: The first command pulls the image tagged as `nanoserver` from the `microsoft/powershell`
    repository. The second command pulls the image tagged as `latest` from the `microsoft/dotnet`
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to pull images from 3rd party registries (not Docker Hub), you need
    to prepend the repository name with the DNS name of the registry. For example,
    if the image in the example above was in the Google Container Registry (GCR) you’d
    need to add `gcr.io` before the repository name as follows — `docker pull gcr.io/nigelpoulton/tu-demo:v2`
    (no such repository and image exists).
  prefs: []
  type: TYPE_NORMAL
- en: You may need to have an account on 3rd party registries and be logged into them
    before you can pull images from them.
  prefs: []
  type: TYPE_NORMAL
- en: Images with multiple tags
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One final word about image tags… A single image can have as many tags as you
    want. This is because tags are arbitrary alpha-numeric values that are stored
    as metadata alongside the image. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: Pull all of the images in a repository by adding the `-a` flag to them `docker
    image pull` command. Then run `docker image ls` to look at the images pulled.
    If you are following along with Windows you can pull from the `microsoft/nanoserver`
    repository instead of `nigelpoulton/tu-demo`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** If the repository you are pulling from contains images for multiple
    architectures and platforms, such as Linux **and** Windows, the command is likely
    to fail.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`A couple of things about what just happened:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First. the command pulled three images from the `nigelpoulton/tu-demo` repository:
    `latest`, `v1`, and `v2`.'
  prefs: []
  type: TYPE_NORMAL
- en: Second. Look closely at the `IMAGE ID` column in the output of the `docker image
    ls` command. You’ll see that there are only two unique image IDs. This is because
    only two images were actually downloaded. This is because two of the tags refer
    to the same image. Put another way… one of the images has two tags. If you look
    closely you’ll see that the `v1` and `latest` tags have the same `IMAGE ID`. This
    means they’re two tags of the **same image**.
  prefs: []
  type: TYPE_NORMAL
- en: This is a perfect example of the warning issued earlier about the `latest` tag.
    In this example, the `latest` tag refers to the same image as the `v1` tag. This
    means it’s pointing to the older of the two images — not the newest! `latest`
    is an arbitrary tag and is not guaranteed to point to the newest image in a repository!
  prefs: []
  type: TYPE_NORMAL
- en: Filtering the output of `docker image ls`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Docker provides the `--filter` flag to filter the list of images returned by
    `docker image ls`.
  prefs: []
  type: TYPE_NORMAL
- en: The following example will only return dangling images.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`A dangling image is an image that is no longer tagged, and appears in listings
    as `<none>:<none>`. A common way they occur is when building a new image and tagging
    it with an existing tag. When this happens, Docker will build the new image, notice
    that an existing image has a matching tag, remove the tag from the existing image,
    give the tag to the new image. For example, you build a new image based on `alpine:3.4`
    and tag it as `dodge:challenger`. Then you update the Dockerfile to replace `alpine:3.4`
    with `alpine:3.5` and run the exact same `docker image build` command. The build
    will create a new image tagged as `dodge:challenger` and remove the tags from
    the older image. The old image will become a dangling image.'
  prefs: []
  type: TYPE_NORMAL
- en: You can delete all dangling images on a system with the `docker image prune`
    command. If you add the `-a` flag, Docker will also remove all unused images (those
    not in use by any containers).
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker currently supports the following filters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dangling:` Accepts `true` or `false`, and returns only dangling images (true),
    or non-dangling images (false).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`before:` Requires an image name or ID as argument, and returns all images
    created before it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`since:` Same as above, but returns images created after the specified image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`label:` Filters images based on the presence of a label or label and value.
    The `docker image ls` command does not display labels in its output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For all other filtering you can use `reference`.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an example using `reference` to display only images tagged as “latest”.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`You can also use the `--format` flag to format output using Go templates.
    For example, the following command will only return the size property of images
    on a Docker host.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`Use the following command to return all images, but only display repo, tag
    and size.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`If you need more powerful filtering, you can always use the tools provided
    by your OS and shell such as `grep` and `awk`.'
  prefs: []
  type: TYPE_NORMAL
- en: Searching Docker Hub from the CLI
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `docker search` command lets you search Docker Hub from the CLI. You can
    pattern match against strings in the “NAME” field, and filter output based on
    any of the returned columns.
  prefs: []
  type: TYPE_NORMAL
- en: In its simplest form, it searches for all repos containing a certain string
    in the “NAME” field. For example, the following command searches for all repos
    with “nigelpoulton” in the “NAME” field.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`The “NAME” field is the repository name, and includes the Docker ID, or organization
    name, for unofficial repositories. For example, the following command will list
    all repositories that include the string “alpine” in the name.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`Notice how some of the repositories returned are official and some are unofficial.
    You can use `--filter "is-official=true"` so that only official repos are displayed.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`You can do the same again, but this time only show repos with automated builds.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`One last thing about `docker search`. By default, Docker will only display
    25 lines of results. However, you can use the `--limit` flag to increase that
    to a maximum of 100.'
  prefs: []
  type: TYPE_NORMAL
- en: Images and layers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A Docker image is just a bunch of loosely-connected read-only layers. This is
    shown in Figure 6.3.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3](images/figure6-3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3
  prefs: []
  type: TYPE_NORMAL
- en: Docker takes care of stacking these layers and representing them as a single
    unified object.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few ways to see and inspect the layers that make up an image, and
    we’ve already seen one of them. Let’s take a second look at the output of the
    `docker image pull ubuntu:latest` command from earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`Each line in the output above that ends with “Pull complete” represents a
    layer in the image that was pulled. As we can see, this image has 5 layers. Figure
    6.4 shows this in picture form, displaying layer IDs.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4](images/figure6-4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4
  prefs: []
  type: TYPE_NORMAL
- en: Another way to see the layers of an image is to inspect the image with the `docker
    image inspect` command. The following example inspects the same `ubuntu:latest`
    image.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`The trimmed output shows 5 layers again. Only this time they’re shown using
    their SHA256 hashes. However, both commands show that the image has 5 layers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** The `docker history` command shows the build history of an image
    and is **not** a strict list of layers in the image. For example, some Dockerfile
    instructions used to build an image do not result in layers being created. These
    include; “ENV”, “EXPOSE”, “CMD”, and “ENTRYPOINT”. Instead of these creating new
    layers, they add metadata to the image.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: All Docker images start with a base layer, and as changes are made and new content
    is added, new layers are added on top.
  prefs: []
  type: TYPE_NORMAL
- en: As an over-simplified example, you might create a new image based off Ubuntu
    Linux 16.04\. This would be your image’s first layer. If you later add the Python
    package, this would be added as a second layer on top of the base layer. If you
    then added a security patch, this would be added as a third layer at the top.
    Your image would now have three layers as shown in Figure 6.5 (remember this is
    an over-simplified example for demonstration purposes).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5](images/figure6-5.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to understand that as additional layers are added, the *image*
    is always the combination of all layers. Take a simple example of two layers as
    shown in Figure 6.6\. Each *layer* has 3 files, but the overall *image* has 6
    files as it is the combination of both layers.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6](images/figure6-6.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** We’ve shown the image layers in Figure 6.6 in a slightly different
    way to previous figures. This is just to make showing the files easier.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the slightly more complex example of the three-layered image in Figure 6.7,
    the overall image only presents 6 files in the unified view. This is because file
    7 in the top layer is an updated version of file 5 directly below (inline). In
    this situation, the file in the higher layer obscures the file directly below
    it. This allows updated versions of files to be added as new layers to the image.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7](images/figure6-7.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7
  prefs: []
  type: TYPE_NORMAL
- en: Docker employs a storage driver (snapshotter in newer versions) that is responsible
    for stacking layers and presenting them as a single unified filesystem. Examples
    of storage drivers on Linux include `AUFS`, `overlay2`, `devicemapper`, `btrfs`
    and `zfs`. As their names suggest, each one is based on a Linux filesystem or
    block-device technology, and each has its own unique performance characteristics.
    The only driver supported by Docker on Windows is `windowsfilter`, which implements
    layering and CoW on top of NTFS.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.8 shows the same 3-layer image as it will appear to the system. I.e.
    all three layers stacked and merged, giving a single unified view.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8](images/figure6-8.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8
  prefs: []
  type: TYPE_NORMAL
- en: Sharing image layers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Multiple images can, and do, share layers. This leads to efficiencies in space
    and performance.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a second look at the `docker image pull` command with the `-a` flag
    that we ran previously to pull all tagged images in the `nigelpoulton/tu-demo`
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`Notice the lines ending in `Already exists`.'
  prefs: []
  type: TYPE_NORMAL
- en: These lines tell us that Docker is smart enough recognize when it’s being asked
    to pull an image layer that it already has a copy of. In this example, Docker
    pulled the image tagged as `latest` first. Then, when it pulled the `v1` and `v2`
    images, it noticed that it already had some of the layers that make up those images.
    This happens because the three images in this repository are almost identical,
    and therefore share many layers.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, Docker on Linux supports many storage drivers (snapshotters).
    Each is free to implement image layering, layer sharing, and copy-on-write (CoW)
    behaviour in its own way. However, the overall result and user experience is essentially
    the same. Although Windows only supports a single storage driver, that driver
    provides the same experience as Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Pulling images by digest
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far, we’ve shown you how to pull images by tag, and this is by far the most
    common way. But it has a problem — tags are mutable! This means it’s possible
    to accidentally tag an image with the wrong tag. Sometimes it’s even possible
    to tag an image with the same tag as an existing, but different, image. This can
    cause problems!
  prefs: []
  type: TYPE_NORMAL
- en: As an example, imagine that you’ve got an image called `golftrack:1.5` and it
    has a known bug. You pull the image, apply a fix, and push the updated image back
    to its repository using the **same tag**.
  prefs: []
  type: TYPE_NORMAL
- en: Take a second to understand what just happened there… You have an image called
    `golftrack:1.5` that has a bug. That image is being used in your production environment.
    You create a new version of the image that includes a fix. Then comes the mistake…
    you build and push the fixed image back to its repository with the **same tag
    as the vulnerable image!**. This overwrites the original image and leaves without
    a great way of knowing which of your production containers are running from the
    vulnerable image and which are running from the fixed image? Both images have
    the same tag!
  prefs: []
  type: TYPE_NORMAL
- en: This is where *image digests* come to the rescue.
  prefs: []
  type: TYPE_NORMAL
- en: Docker 1.10 introduced a new content addressable storage model. As part of this
    new model, all images now get a cryptographic content hash. For the purposes of
    this discussion, we’ll refer to this hash as the *digest*. Because the digest
    is a hash of the contents of the image, it is not possible to change the contents
    of the image without the digest also changing. This means digests are immutable.
    This helps avoid the problem we just talked about.
  prefs: []
  type: TYPE_NORMAL
- en: Every time you pull an image, the `docker image pull` command will include the
    image’s digest as part of the return code. You can also view the digests of images
    in your Docker host’s local repository by adding the `--digests` flag to the `docker
    image ls` command. These are both shown in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`The snipped output above shows the digest for the `alpine` image as -'
  prefs: []
  type: TYPE_NORMAL
- en: '`sha256:3dcdb92d7432d56604d...6d99b889d0626de158f73a`'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the digest of the image, we can use it when pulling the image
    again. This will ensure that we get **exactly the image we expect!**
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, there is no native Docker command that will retrieve
    the digest of an image from a remote registry such as Docker Hub. This means the
    only way to determine the digest of an image is to pull it by tag and then make
    a note of its digest. This will no doubt change in the future.
  prefs: []
  type: TYPE_NORMAL
- en: The following example deletes the `alpine:latest` image from your Docker host
    and then shows how to pull it again using its digest instead of its tag.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`#### A little bit more about image hashes (digests)'
  prefs: []
  type: TYPE_NORMAL
- en: Since Docker version 1.10, an image is a very loose collection of independent
    layers.
  prefs: []
  type: TYPE_NORMAL
- en: The *image* itself is really just a configuration object that lists the layers
    and some metadata.
  prefs: []
  type: TYPE_NORMAL
- en: The *layers* are where the data lives (files etc.). Each one is fully independent,
    and has no concept of being part of a collective image.
  prefs: []
  type: TYPE_NORMAL
- en: Each image is identified by a crypto ID that is a hash of the config object.
    Each layer is identified by a crypto ID that is a hash of the content it contains.
  prefs: []
  type: TYPE_NORMAL
- en: This means that changing the contents of the image, or any of its layers, will
    cause the associated crypto hashes to change. As a result, images and layers are
    immutable, and we can easily identify any changes made to either.
  prefs: []
  type: TYPE_NORMAL
- en: We call these hashes **content hashes**.
  prefs: []
  type: TYPE_NORMAL
- en: So far, things are pretty simple. But they’re about to get a bit more complicated.
  prefs: []
  type: TYPE_NORMAL
- en: When we push and pull images, we compress their layers to save bandwidth, as
    well as space in the Registry’s blob store.
  prefs: []
  type: TYPE_NORMAL
- en: Cool, but compressing a layer changes its content! This means that its content
    hash will no longer match after the push or pull operation! This is obviously
    a problem.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when you push an image layer to Docker Hub, Docker Hub will attempt
    to verify that the image arrived without being tampered with en-route. To do this,
    it runs a hash against the layer and checks to see if it matches the hash that
    was sent. Because the layer was compressed (changed) the hash verification will
    fail.
  prefs: []
  type: TYPE_NORMAL
- en: To get around this, each layer also gets something called a *distribution hash*.
    This is a hash of the compressed version of the layer. When a layer is pushed
    and pulled from the registry, its distribution hash is included, and this is what
    is used to verify that the layer arrived without being tampered with.
  prefs: []
  type: TYPE_NORMAL
- en: This content-addressable storage model vastly improves security by giving us
    a way to verify image and layer data after push and pull operations. It also avoids
    ID collisions that could occur if image and layer IDs were randomly generated.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-architecture images
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the best things about Docker is how simple it is to use. For example,
    running an application is as simple as pulling the image and running a container.
    No need to worry about setup, dependencies, or config. It just works.
  prefs: []
  type: TYPE_NORMAL
- en: However, as Docker grew, things started getting complex — especially when new
    platforms and architectures, such as Windows, ARM, and s390x were added. All of
    a sudden we have to think about whether the image we’re pulling is built for the
    architecture we’re running on. This breaks the smooth experience.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-architecture images to the rescue!
  prefs: []
  type: TYPE_NORMAL
- en: Docker (image and registry specs) now supports multi-architecture images. This
    means a single image (`repository:tag`) *can* have an image for Linux on x64,
    Linux on PowerPC, Windows x64, ARM etc. Let me be clear, we’re talking about a
    single image tag supporting multiple platforms and architectures. We’ll see it
    in action in a second.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this happen, the Registry API supports two important constructs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**manifest lists** (new)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**manifests**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **manifest list** is exactly what it sounds like: a list of architectures
    supported by a particular image tag. Each supported architecture then has its
    own **manifest* detailing the layers it’s composed from.'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.9 uses the official `golang` image as an example. On the left is the
    **manifest list** with entries for each architecture the image supports. The arrows
    show that each entry in the **manifest list** points to a **manifest** containing
    image config and layer data.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9](images/figure6-9.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the theory before seeing it in action.
  prefs: []
  type: TYPE_NORMAL
- en: Assume you are running Docker on a Raspberry Pi (Linux running on ARM architecture).
    When you pull an image, your Docker client makes the relevant calls to the Docker
    Registry API running on Docker Hub. If a **manifest list** exists for the image,
    it will be parsed to see if an entry exists for Linux on ARM. If an ARM entry
    exists, the **manifest** for that image is retrieved and parsed for the crypto
    ID’s of the layers that make up the image. Each layer is then pulled from Docker
    Hub’s blob store.
  prefs: []
  type: TYPE_NORMAL
- en: The following examples show how this works by pulling the official `golang`
    image (which supports multiple architectures) and running a simple command to
    show the version of Go along with the CPU architecture of the host. The thing
    to note, is that both examples use the exact same `docker container run` command.
    We do not have to tell Docker that we need the Linux x64 or Windows x64 versions
    of the image. We just run normal commands and let Docker take care of getting
    the right image for the platform and architecture we are running!
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux on x64 example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`Windows on x64 example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`The previous operations pull the `golang` image from Docker Hub, start a container
    from it, execute the `go version` command, and output the version of Go and the
    OS/CPU architecture of the host system. The last line of each example shows the
    output of each `go version` command. See that both examples used exactly the same
    command, but the Linux example pulled the `linux/amd64` image, and the Windows
    example pulled the `windows/amd64` image.'
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, all *official images* have manifest lists. However,
    support for all architectures is an ongoing process.
  prefs: []
  type: TYPE_NORMAL
- en: Creating images that run on multiple architectures requires additional effort
    from the image publisher. Also, some software is not cross-platform. With this
    in mind, **manifest lists** are optional — if one doesn’t exist for an image,
    the Registry will return the normal **manifest**.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting Images
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you no longer need an image, you can delete it from your Docker host with
    the `docker image rm` command. `rm` is short for remove.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting an image will remove the image and all of its layers from your Docker
    host. This means it will no longer show up in `docker image ls` commands, and
    all directories on the Docker host containing the layer data will be deleted.
    However, if an image layer is shared by more than one image, that layer will not
    be deleted until all images that reference it have been deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Delete the images pulled in the previous steps with the `docker image rm` command.
    The following example deletes an image by its ID, this might be different on your
    system.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`If the image you are trying to delete is in use by a running container you
    will not be able to delete it. Stop and delete any containers before trying the
    delete operation again.'
  prefs: []
  type: TYPE_NORMAL
- en: A handy shortcut for **deleting all images** on a Docker host is to run the
    `docker image rm` command and pass it a list of all image IDs on the system by
    calling `docker image ls` with the `-q` flag. This is shown next.
  prefs: []
  type: TYPE_NORMAL
- en: If you are performing the following command on a Windows system, it will only
    work in a PowerShell terminal. It will not work on a CMD prompt.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`To understand how this works, download a couple of images and then run `docker
    image ls -q`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`See how `docker image ls -q` returns a list containing just the image IDs
    of all images pulled locally on the system. Passing this list to `docker image
    rm` will delete all images on the system as shown next.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`Let’s remind ourselves of the major commands we use to work with Docker images.'
  prefs: []
  type: TYPE_NORMAL
- en: Images - The commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`docker image pull` is the command to download images. We pull images from
    repositories inside of remote registries. By default, images will be pulled from
    repositories on Docker Hub. This command will pull the image tagged as `latest`
    from the `alpine` repository on Docker Hub `docker image pull alpine:latest`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker image ls` lists all of the images stored in your Docker host’s local
    cache. To see the SHA256 digests of images add the `--digests` flag.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker image inspect` is a thing of beauty! It gives you all of the glorious
    details of an image — layer data and metadata.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker image rm` is the command to delete images. This command shows how to
    delete the `alpine:latest` image — `docker image rm alpine:latest`. You cannot
    delete an image that is associated with a container in the running (Up) or stopped
    (Exited) states.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we learned about Docker images. We learned that they are like
    virtual machine templates and are used to start containers. Under the hood they
    are made up one or more read-only layers, that when stacked together, make up
    the overall image.
  prefs: []
  type: TYPE_NORMAL
- en: We used the `docker image pull` command to pull some images into our Docker
    host’s local registry.
  prefs: []
  type: TYPE_NORMAL
- en: We covered image naming, official and unofficial repos, layering, sharing, and
    crypto IDs.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at how Docker supports multi-architecture and multi-platform images,
    and we finished off by looking at some of the most common commands used to work
    with images.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we’ll take a similar tour of containers — the runtime cousin
    of images.[PRE34]`
  prefs: []
  type: TYPE_NORMAL
