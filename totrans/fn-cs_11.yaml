- en: Chapter 11. Coding Best Practice and Testing the Functional Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We developed a functional application in the previous chapter. To create better
    code in the functional approach, we have to follow the best practice rules and
    implement them in our code. In this chapter, we are going to discuss the concept
    of the functional approach, which is a pure function and makes our function similar
    to a mathematical function. The topics that will be covered in this chapter are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Preventing dishonest signatures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating immutable classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding `Temporal Coupling`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with the side-effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separating the code into a `Domain Logic` and the `Mutable Shell`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the functional code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding best practices in functional C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The functional approach has the concept of a pure function. This means that
    the function will produce the same result as long as we pass the exact same input.
    Now, let's start our discussion to create the better functional code by following
    the coding best practices outlined here.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing dishonest signatures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we discussed in [Chapter 1](text00016.html#ch01 "Chapter 1. Tasting Functional
    Style in C#") , *Tasting Functional Style in C#* , we use the mathematical approach
    to constructing our code in functional programming. In other words, functional
    programming is programming with mathematical functions. There are two requirements
    that mathematical functions must fit, they are:'
  prefs: []
  type: TYPE_NORMAL
- en: A mathematical function should always return the same result whenever we supply
    the same arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The signature of the mathematical function should deliver all the information
    for the possible accepted input values and the possible produced output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now let''s take a look at the following code snippet, which we can find in
    the `HonestSignature.csproj` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'By examining the preceding `SumUp()` function, we can say that we will retrieve
    the same output every time we pass the same inputs. Now let''s examine the following
    `GenerateRandom()` function, which we can also find in the `HonestSignature.csproj`
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, we can see that we will retrieve different output
    although we pass the same input continually. Suppose we have the following `RunGenerateRandom()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding `RunGenerateRandom()` function, we will get the following
    output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preventing dishonest signatures](img/Image00114.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding code snippet, we invoke the `GenerateRandom()` function 10
    times by passing the exact same argument, that is, 100\. As you can see in the
    preceding figure, the function returns a different output for each of the 10 invocations.
    So, we have to avoid functions such as the `GenerateRandom()` function in order
    to create a pure function since it is not a mathematical function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s take a look at the following `Divide()` function, which will divide
    the first argument by the second argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Divide()` function looks similar to the `SumUp()` function since the signature
    of the `Divide()` function accepts any two integers and returns another integer.
    So if we pass the exact same argument, it will return the same output. However,
    how about if we pass 1 and 0 as input parameters? The `Divide()` function will
    throw a `DivideByZeroException` error instead of returning an integer value. In
    this case, we can conclude that the signature of the function does not deliver
    enough information about the result of the operation. It looks like the function
    can handle any two parameters of the integer type, but it actually cannot. To
    solve this problem, we can refactor the preceding `Divide()` function to the following
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding `Divide()` function, we add the `nullable` type
    by adding a question mark after `int` so that the return of the function can be
    null. We also add an `if` statement to make sure that `DivideByZeroException`
    error will never be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring a mutable class into an immutable one
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Immutability is very important in functional programming, since a mutable operation
    will make our code dishonest. As we discussed previously, we need to prevent dishonest
    operations in order to create our pure function approach. Immutability is applied
    to a data structure - for instance, a class means that the objects of this class
    cannot be changed during their lifetime. In other words, we can say that a class
    is mutable if the instances of the class can be changed in some way, while it
    is immutable if we cannot modify the instance of that class once we create it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the following code, which can be found in the `Immutability.csproj`
    project to continue our discussion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, we have a simple composition. The `UserMembership`
    class consists of the `_user` and `_memberSince` properties. We can also see that
    the `User` class is immutable since all the properties are defined as read-only.
    Because of immutability, the only way for the `UserMembership` method to update
    the `_user` field is to create a new `User` instance and replace the old one with
    it. Note that the `Use` r class itself doesn't contain the state here, whereas
    the `UserMembership` class does. We can say that the `UpdateUser` method leaves
    a side-effect by changing the object's state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s refactor the `UpdateUser` method and make it immutable. The following
    code is the result of refactoring the `UpdateUser` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `UpdateUser()` method no longer updates the structure of
    the `UserMembership` class. Instead, it creates a new `UserMembership` instance
    and returns it as a result of the operation. By refactoring the `UpdateUser` method,
    we have eliminated the side-effect from the method. Now it's clear what the actual
    output of the operation is. The usage of immutable data makes the code more readable
    and also helps to provide a good understanding of what is going on right away
    without too much effort.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding mutability and temporal coupling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, the use of the methods with side-effects will damage readability.
    The invocation of one method is coupled with the other''s method invocation. To
    make things clear, let''s take a look at the following code, which we can find
    in the `TemporalCoupling.csproj` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding code, you can see that we have a `MembershipDatabase` class,
    which processes a new member. It retrieves input parameters named `memberName`
    and `addressString` and uses them to insert a new member in the database. The
    `Process()` method in the `MembershipDatabase` class invokes the `CreateAddress`
    method first, which will create the address and then save it to the private field.
    The `CreateMember()` method then retrieves the address and uses it to instantiate
    a new `Member` parameter, which is saved in another private field named `member`
    . The last method, the `SaveMember()` method, saves the member to the database
    (in this example, we use `list` ). There is a problem here. The invocations in
    the `Process()` method are coupled with temporal coupling. We have to always invoke
    these three methods in the right order for this code to work properly.
  prefs: []
  type: TYPE_NORMAL
- en: If we don't place the method in the right order - for instance, if we put the
    `CreateAddress()` method invocation, after the `CreateMember()` method invocation
    the resulting member instance will be invalid since the member will not retrieve
    the required dependency address. Likewise, if we put the `SaveMember()` method
    invocation above others, it will throw `NullReferenceException` because, when
    it tries to save a member, the member instance would still be null.
  prefs: []
  type: TYPE_NORMAL
- en: Temporal coupling is a consequence of the method's signature dishonesty. The
    `CreateAddress()` method has an output, creating an `address` instance, but this
    output is hidden under a side-effect because we mutate the `Address` field in
    the `MembershipDatabase` class. The `CreateMember()` method hides the result of
    the operation as well. It saves `member` to the private field, but it also hides
    some of its input. From the signature of the `CreateMember()` method, we might
    think that it needs only the name parameter in order to create `member` while
    it actually refers to a global state, the `address` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'This happens to the `SaveMember()` method as well. To remove the temporal coupling,
    we have to specify all of the input and output in the method''s signatures explicitly
    or, in other words, move all side-effects and dependencies to the signature level.
    Now, let''s refactor the preceding side-effect - containing code to the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: From the highlighted code, we can see that we have refactored the `CreateAddress()`
    , `CreateMember()` , `SaveMember()` , and `Process()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: The `CreateAddress()` method now returns `Address` instead of saving it to the
    private field. In the `CreateMember()` method, we add a new parameter, `address`
    , and also change the returning type. For the `SaveMember()` method, instead of
    referring to the customer private field, we now specify it as a dependency in
    the method's signature. In the `Process()` method, we can now remove the fields,
    and we have successfully removed the temporal coupling with this change.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's impossible for us to put the `CreateAddress()` invocation method after
    the `CreateMember()` invocation method because the code will not be compiled.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with the side-effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although we need to create a pure function in functional programming, we cannot
    avoid the side-effects completely. As you can see in the preceding `MembershipDatabase`
    class, we have the `SaveMember()` method, which will save the member field into
    the database. The following code snippet will explain this clearly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: To deal with the side-effects, we can use the **command-query separation** (
    **CQS** ) principle to separate methods that generate side-effects and methods
    that don't. We can call commands for methods that incur side-effects and queries
    for methods that don't. If the method alters a piece of state, it should be the
    void type method. Otherwise, it should return something. Using this CQS principle,
    we can identify the purpose of a method by just looking at its signature. If the
    method returns a value, it will be a query and it won't mutate anything. If the
    method returns nothing, it must be a command and will leave some side-effects
    in the system.
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding `MembershipDatabase` class, we now can identify that the
    `Process()` and `SaveMember()` methods are commands types and will leave some
    side-effects since they return nothing. In contrast, the `CreateAddress()` and
    `CreateMember()` methods are queries and won't mutate anything since they return
    something.
  prefs: []
  type: TYPE_NORMAL
- en: Separating the code from domain logic and mutable shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, when our code processes a business transaction, it mutates some data
    several times. In the world of object-oriented programming languages, this is
    quite a common pattern. We can then separate our code into domain logic and the
    mutable shell. In domain logic, we simplify the code and write the business logic
    in a functional way using mathematical functions. As a result, this domain logic
    will become easy to test. In the mutable shell, we place a mutable expression;
    we will do this after we finish with the business logic.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the code containing side-effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s examine the following code, which contains many side-effects that
    we are going to refactor, and we can find it in the `DomainLogicAndMutatingState.csproj`
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code, it is written in a straightforward way.
    We are going to separate its responsibilities into two parts: an immutable core
    that contains all the domain logic and a mutable shell that contains all the mutable
    expression.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Librarianship` class will keep track of all the borrowers in a library
    and takes note of the book-returning date. The class uses a log file to store
    the borrower''s name, the title of the borrowed book, and the returning date.
    The pattern of the log file content is the index number, a semicolon, the borrower
    name and then the semicolon again, the book title and then the semicolon, and
    lastly, the returning date. The following is a sample of the log file content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The class must be able to add a new line in the log file, such as what we can
    see in the `AddRecord()` method. But before we invoke the method, we have to specify
    the value for the `_maxEntriesPerFile` field when we construct the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The value of the `_maxEntriesPerFile` field will be used when we invoke the
    `AddRecord()` method. If `_maxEntriesPerFile` is greater than the current total
    lines of the log file, it will insert the visitor identity into the log file using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, if the current total number of lines of the log file has reached
    `_maxEntriesPerFile` , then `AddRecord()` method creates a new log file, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code snippet, we find the `GetNewFileName()` method to generate
    a new log file name based on the current log file name. The implementation of
    the `GetNewFileName()` method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding `GetNewFileName()` method's implementation, we can see that
    the pattern of the log file name is `LibraryLog _0001.txt` , `LibraryLog _0002.txt`
    , and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AddRecord(` ) method will also create a new log file if the specified
    log file name is not found. The implementation of this task is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The class also has the `RemoveRecord()` method to remove the visitor identity
    from the log file. The implementation of the method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `RemoveRecord()` method''s implementation, you can see that it removes
    the selected visitor from the available log file in the selected directory, as
    shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If `linesToKee` p contains no data, we can securely delete the file using the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, we just need to remove the visitor identity from the log file using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s time to try our `Librarianship` class. First, we will prepare a data
    list that contains the author and the title of the books, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And we have the `Book` structure as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We will invoke the following `LibrarianshipInvocation()` method to consume
    the `Librarianship` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding `LibrarianshipInvocation()` method, we call
    the `GetLastLogFile()` method to find the last available log file. The implementation
    of the method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: When we call the `GetLastLogFile()` method, it will look for all files that
    have the `LibraryLog_????.txt` pattern in the directory we specified. It will
    then return the last member of the string array. If the string array contains
    no data, it will return `LibraryLog_0001.txt` as the default log file name.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the `LibrarianshipInvocation()` method, we will see nothing, but
    we will get a new `LibraryLog_0001.txt` file containing the following text:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Examining the code containing side-effects](img/Image00115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding output file log, we can see that we have successfully created
    the `Librarianship` class as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the AddRecord() method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now it''s time to refactor the `Librarianship` class for it to become immutable.
    First, we will make the `AddRecord()` method a mathematical function. To do that,
    we have to make sure that it doesn''t access the disk directly, which we do when
    we use the `File.Exists()` , `File.ReadAllLines()` , `File.AppendAllLines()` ,
    and `File.WriteAllLines()` methods. We will refactor the `AddRecord()` method
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code, we modify the `AddRecord()` method signature
    so that it doesn''t pass any filenames now and passes a `FileContent` data type
    instead, which is structured with the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `FileContent` structure will now handle the filename and
    its content. And the `AddRecord()` method also returns the `FileAction` data type
    now. The implementation of the `FileAction` data type is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'And the `ActionType` enumeration is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have a new data type, which is `DataEntry` . The implementation of
    the `DataEntry` structure is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `DataEntry` structure will handle all the data that we want to write in
    the log file. And if we examine the `AddRecord()` method again, we don't find
    the procedure to make sure the log file exists since that will be done in a separate
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'We notice that the `AddRecord()` method invokes two new methods: the `Parse()`
    and `Serialize()` methods. The `Parse()` method is used to parse all the lines
    in the log file content and then form the list of `DataEntry` based on the content
    of the log file. The implementation of the method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, the `Serialize()` method is used to serialize the `DataEntry`
    list into the string array. The implementation of the method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Refactoring the RemoveRecord() method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we go back to our `Librarianship` class and refactor the `RemoveRecord()`
    method. The implementation will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `RemoveRecord()` method now has a new signature. It passes an array of
    `FileContent` instead of the directory name only. It also returns a read-only
    list of `FileAction` . The `RemoveRecord()` method also needs an additional `RemoveRecordIn()`
    method, which is used to get the specified filename and file content to target
    the record that will be removed. The implementation of the `RemoveRecordIn()`
    method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: And now, we have the domain logic code, which is totally immutable and can run
    this domain logic in a unit testing environment.
  prefs: []
  type: TYPE_NORMAL
- en: Running domain logic in unit testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Domain logic is an immutable source that is a pure function, so we can run the
    unit testing over and over again without having to change the testing rules. Here,
    we are going to test the `AddRecord()` and `RemoveRecord()` methods in the `LibrarianshipImmutable`
    class. We will have five tests for these two methods. For the `AddRecord()` method,
    we will test if the file is overflow. For the `RemoveRecord()` method, we will
    test whether the selected record that we want to remove is available. Then, the
    file becomes empty if the selected record is empty or if the selected record is
    not available.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the AddRecord() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let''s take a look at the following `AddRecord_LinesIsLowerThanMaxEntriesPerFileTest()`
    test method, which will add a record to the existing log file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `AddRecord_LinesIsLowerThanMaxEntriesPerFileTest()` test method, first,
    we create a `LibraryLog_0001.txt` file containing `1;Arthur Jackson;Responsive
    Web Design;9/26/2016` and then we add a new record, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: From now on, we have to ensure that `action.The type` has to be `ActionType.Update`
    , `action.FileName` has to be `LibraryLog_0001.txt` , and the `action.Content`
    has to be two lines, with the first line as `1;Arthur Jackson;Responsive Web Design;9/26/2016`
    and the second line as `2;Maddox Webb;AngularJS by Example;9/27/2016` .
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Assert.AreEqual()` method is used to verify that the specified values are
    equal. Unfortunately, the use of this method will not override the array data.
    To compare the array, we need to use the `CollectionAssert.AreEqual()` method,
    which will verify that two specified collections are equal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another unit testing is the `AddRecord_LinesHasReachMaxEntriesPerFileTest()`
    testing method. The implementation of this testing is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In this testing method, we want to ensure that a new log file is created if
    the current log file lines have reached `maxEntriesPerFile` . First, we instantiate
    `LibrarianshipImmutable` and fill the `maxEntriesPerFile` field with `3` and then
    we fill the log file with the three visitors, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we add a new record using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have to ensure that `action.Type` is `ActionType.Update` , and it creates
    a new log file named `LibraryLog_0002.txt` . Also, the content of the new log
    file is `1;Haiden Brown;Practical Data Science;9/29/2016` .
  prefs: []
  type: TYPE_NORMAL
- en: Testing the RemoveRecord() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we discussed earlier, we have three tests for the `RemoveRecord()` method.
    First, we are going to test removing a record from the files in the directory.
    The code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In this `RemoveRecord_FilesIsAvailableInDirectoryTest()` test method, we first
    create a `LibraryLog_0001.txt` file containing three records. We then remove the
    first record and make sure that `LibraryLog_0001.txt` will contain only two remaining
    logs with the proper order number.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other test is `RemoveRecord_FileBecomeEmptyTest()` with the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `RemoveRecord_FileBecomeEmptyTest()` testing method will make sure that
    the log file is deleted if it is empty after the record is removed. First, we
    create a new log file with one record, and then we remove it using the `RemoveRecord()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last test for the `RemoveRecord()` method is `RemoveRecord_SelectedRecordIsUnavailableTest()`
    , which will remove nothing if the selected record is unavailable. The implementation
    of the testing method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we create the log file containing Sofia Hamilton as the visitor
    name, but we try to remove the visitor named Arthur Jackson. In this case, the
    `RemoveRecord()` method will remove nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Executing the test
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, it''s time to run the unit testing for all five testing methods. And here
    is what we will get after we run the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Executing the test](img/Image00116.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding the mutable shell into code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have successfully created the immutable core and covered unit tests.
    For now, we are ready to a implement the mutable shell for the rest of the code
    that is accessing the disk. We will create two classes, `FileProcessor` and `AppService`
    . The `FileProcessor` class will do all the disk interaction. The `AppService`
    class will be a bridge between the `LibrarianshipImmutable` class and the `FileProcessor`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the following `FileProcessor` class implementation,
    which we can find in the `FileProcessor.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: There are four methods in the preceding `FileProcessor` class; they are `ReadFile()`
    , `ReadDirectory()` , and two `ApplyChanges()` methods with different signatures.
    The `ReadFile()` method is used to read the selected file and form it into the
    `FileContent` data type. The `ReadDirectory()` method is used to read all the
    files in the selected directory and form them into the `FileContent` data array.
    The `ApplyChanges()` method is used to make an execution to the selected file.
    If the action is `Create` or `Update` , then the `File.WriteAllLines()` method
    will be called. If the action is `Delete` , then the `File.Delete()` method will
    be invoked. Otherwise, the `InvalidOperationException` exception will be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we finish with the `FileProcessor` class, it''s time to create the `AppService`
    class. The implementation of the class is as follows, and we can find it in the
    `AppService.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As we discussed previously, the AppService class is used as the bridge between
    the `LibrarianshipImmutable` class and the `FileProcessor` class. We have the
    two methods in this AppService class that have completely the same signature with
    methods in the `LibrarianshipImmutable` class; they are the `AddRecord()` and
    `RemoveRecord()` methods. And as a bridge, we can see that in the class constructor,
    the `LibrarianshipImmutable` and `FileProcessor` class constructors are invoked
    to create a new instance. By calling the `AddRecord(` ) method in the `AppService`
    class, we actually invoke the `AddRecord()` method in the `LibrarianshipImmutable`
    class and then we call the `ApplyChange()` method in the `FileProcessor` class.
    Likewise, the invocation of the `RemoveRecord()` method in the `AppService` class
    will invoke the `RemoveRecord()` method in the `LibrarianshipImmutable` class
    and then the `ApplyChange()` method in the `FileProcessor` class.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The honest signature is important not only in functional approach but also every
    time we code, since, basically, the signature has to deliver all the information
    about the possible accepted input values and possible produced output. By implementing
    honest signature, we will be aware of the value we pass into the method parameter.
    We have to ensure that we have an immutable class as well in order to get functional
    because mutable operations will make our code dishonest.
  prefs: []
  type: TYPE_NORMAL
- en: Although we have to avoid side-effects in our pure function, it's nearly impossible
    to really avoid side-effects in our code. What we can do then is deal with it.
    We can use the **command-query separation** ( **CQS** ) principle to separate
    methods that generate side-effects and methods that don't. If the method returns
    a value, it will be a query and doesn't mutate anything. If the method returns
    nothing, it must be a command and will leave some side-effects in the system.
  prefs: []
  type: TYPE_NORMAL
- en: We can also separate our code into domain logic and the mutable shell in order
    to deal with the side-effects. The domain logic will be our core program, and
    it must be immutable. All mutable processing will be stored in the mutable shell.
    By creating the domain logic, we can easily run unit testing on it. We don't need
    to modify the test scenario or run the mock test for domain logic since it is
    a pure function.
  prefs: []
  type: TYPE_NORMAL
