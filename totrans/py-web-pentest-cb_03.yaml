- en: Chapter 3. Vulnerability Identification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Automated URL-based Directory Traversal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated Cross-site scripting (parameter and URL)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated parameter-based Cross-site scripting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated fuzzing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: jQuery checking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Header-based Cross-site scripting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shellshock checking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focuses on identifying traditional web app vulnerabilities from
    the Top 10 **Open Web Application Security Project** (**OWASP**). This would include
    **Cross-site scripting** (**XSS**), Directory Traversal, and those other vulnerabilities
    that are simple enough to check for not to warrant their own chapter. This chapter
    provides a parameter-based and URL-based version of each script to allow for either
    eventuality and cut down on individual script complexity. Most of these tools
    have fully crafted alternatives, such as Burp Intruder. The benefit of seeing
    each tool in its simplistic Python is that it allows you to understand how to
    build and craft your own versions.
  prefs: []
  type: TYPE_NORMAL
- en: Automated URL-based Directory Traversal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Occasionally, websites call files using unrestricted functions; this can allow
    the fabled Directory Traversal or **Direct Object Reference** (**DOR**). In this
    attack, a user can call arbitrary files within the context of the website by using
    a vulnerable parameter. There are two ways this can be manipulated: firstly, by
    providing an absolute link such as `/etc/passwd`, which states from the `root`
    directory browse to the `etc` directory and open the `passwd` file, and secondly,
    relative links that travel up directories in order to reach the `root` directory
    and travel to the intended file.'
  prefs: []
  type: TYPE_NORMAL
- en: We will be creating a script that attempts to open a file that is always present
    on a Linux machine, the aforementioned `/etc/passwd` file by gradually increasing
    the number of up directories to a parameter in a URL. It will identify when it
    has succeeded by the detection of the phrase root that indicates that file has
    been opened.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Identify the URL parameter that you wish to test. This script has been configured
    to work with most devices: `etc/passwd` should work with OSX and Linux installations
    and `boot.ini` should work with Windows installations. See the end of this example
    for a PHP web page that can be used against to test the validity of the scripts.'
  prefs: []
  type: TYPE_NORMAL
- en: We will be using the requests library that can be installed through `pip`. In
    the author's opinion, it's better than `urllib` in terms of functionality and
    usability.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you''ve identified your parameter to attack, pass it to the script as
    a command line argument. Your script should be the same as the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of the output produced when using this script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We import the libraries we require for this script, as with every other script
    we''ve done in the book so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We then take our input in the form of a URL. As we are using the `requests`
    library, we should ensure that our URL matches the form requests is expecting,
    which is `http(s)://url`. Requests will remind you of this if you get it wrong:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We establish the payloads which we are going to send in each attack in a dictionary.
    The first value in each pair is the file that we wish to attempt to load and the
    second is a value that will definitely be within that file. The more specific
    that second value is, the fewer false positives that will occur; however, this
    may increase the chances of false negatives. Feel free to include your own files
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We provide the up directory shortcut `../` and assign it to the up variable
    and we set the counter for our loop to `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Iteritems` method allows us to go through the dictionary and take each
    key and value, and assign them to variables. We assign the first value as payload
    and the second value as string. We then cap our loop to stop it repeating forever
    in the event of a failure. I have set this to `7` though this can be set to any
    value that you please. Bear in mind the likelihood of a directory structure for
    a web app being any higher than `7`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We craft our request by taking our root URL and appending the current number
    of up directories according to the loop and the payload. This is then sent in
    a post request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We check to see whether we have achieved our goal by looking for our intended
    string in the response. If the string is present, we halt the loop and print out
    the attack string, along with the response to the successful attack. This allows
    us to manually verify whether the attack was successful or whether the code needs
    to be refactored, or the web app isn''t vulnerable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the counter is added to each loop until it reaches the preset max.
    Once the max is reached, it is set to zero for the next attack string.
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe can be adapted to work with parameters through the application of
    the principles shown elsewhere in the book. However, due to the rarity of pages
    being called through parameters and intentional brevity, this has not been provided.
  prefs: []
  type: TYPE_NORMAL
- en: This can be extended, as earlier mentioned, by adding additional files and their
    commonly occurring strings. It could also be extended to grabbing all interesting
    files once the ability to directory traverse and the depth required to reach root
    has been established.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a PHP web page that will allow you to test this script on
    your own build. Just put it in your `var/www` directory or whichever solution
    you use. Do not leave this active on an unknown network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Automated URL-based Cross-site scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reflected Cross-site scripting commonly occurs through URL based parameters.
    You should know what Cross-site scripting is, and if you don't, I'm embarrassed
    for you. For real? I have to explain this? Okay. Cross-site scripting is injecting
    JavaScript into a page. It is hacking 101 and the first attack most people encounter
    or hear about. Inefficient methods of blocking Cross-site scripting focus around
    targeting script tags, and with script tags not being necessary to use JavaScript
    in a page, there are numerous ways around this.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a script that takes a variety of standard evasion techniques
    and applies them to an automated submittal by using the `Requests` library. We
    will know whether the script has succeeded because either the script or an earlier
    version of it will be present on the page following the submittal.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The script we will be using is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of the output produced when using this script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This script is similar to the earlier Directory Traversal script. We create
    a list of payloads rather than a dictionary this time as the check string and
    payload are the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We then use a similar loop as before to go through those values and submit
    them one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Each payload is appended to the end of our URL to be sent in an unended parameter
    such as `127.0.0.1/xss/xss.php?comment=`. The payload will be added onto the end
    of that string in order to make a valid statement. We then check to see if that
    string is present in the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Cross-site scripting is so simple and very easy to automate and detect as the
    attack string is usually the same as the outcome. The difficulties with Directory
    Traversal or SQLi, as we will encounter later, is that the outcome is not always
    predictable. In the event of a successful Cross-site scripting attack, it is.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This attack can be extended by providing more attack strings. Many examples
    can be found in the Mozilla FuzzDB, which we will be using later in the *Automated
    fuzzing* section script. Also, various forms of encoding can be applied using
    the original `urllib` library, which is shown throughout this book in various
    different examples.
  prefs: []
  type: TYPE_NORMAL
- en: Automated parameter-based Cross-site scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I've already stated that Cross-site scripting is absurdly easy. Amusingly, it
    is slightly harder to perform stored Cross-site scripting in a scripted fashion.
    I should probably take back my earlier words at this point, but whatever. The
    difficulty here is that systems often take an input structure from one page, submit
    to another page, and return a third page. The following script is designed to
    handle that most complex of structures.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a script that takes three input values, reads, and submits to
    all three correctly and checks for success. It shares code with the earlier URL-based
    Cross-site scripting but differs fundamentally in its execution.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following script is the functioning test. It is a script that is designed
    to be manually edited in a framework similar to sublime text or an IDE, as stored
    XSS is likely to require fiddling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of the output produced when using this script with
    two successful strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We import our libraries as time and time before and establish the URLs we are
    going to attack. Here, `url` is the page with the parameters to attack, `url2`
    is the page that the content is going to be submitted to, and `url3` is the final
    page to be read in order to detect whether the attack was successful. Some of
    these URLs may be shared. They are set in this form because it is very difficult
    to make a point and click script for stored Cross-site scripting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We then establish a list of payloads. As with the URL-based XSS script, the
    payload, and check value is the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We then create an empty dictionary to pair the payload with each identified
    input box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We are aiming to attack every input parameter in a page, so next, we read our
    target page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We then create a loop for each value that we put in our payloads list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We then process the page with `BeautifulSoup`, which is a library that allows
    us to carve pages by their tags and defining characteristics. We use this to identify
    each input field of which we select the name so we can send it content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Due to the nature of input boxes in the majority of web pages, any fields named
    `submit` are not to be targeted for Cross-site scripting and instead need to be
    given `submit` as a value in order for our attack to be successful. We create
    an `if` function to detect whether this is the case, using the`.lower()` function
    to easily account for the potential upper case values that may be used. If the
    field isn''t used to verify submittal, we fill it with the current payload in
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We send our now assigned values to the targeted page in a post request by using
    the `requests` library, as we have done earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We then load the page that would render our content and prepare it for being
    used in the check result function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the scripts before, we check if our string was successful by searching
    for it on the page and print the result out if it. We then reset the dictionary
    for the next payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As before, you can alter this script to include many results or read from a
    file that contains multiple values. Mozilla's FuzzDB, as shown in the following
    recipe, contains a vast number of these values.
  prefs: []
  type: TYPE_NORMAL
- en: The following is a setup than can be used to test the script provided in the
    preceding sections. They need to be saved as the filenames provided to work and
    in conjunction with a MySQL database to store the comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the first interface page named `guestbook.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following script is `addguestbook.php`, which places your comment in the
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The final script is `viewguestbook.php`, which draws the comments from the
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Automated fuzzing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fuzzing is the smash and grab of the hacking community. It focuses around sending
    a large amount of invalid content to a page and recording the results. It is the
    reprobates version of SQL Injection and arguably the base form of penetration
    testing (though you LOIC users out there are probably the base form of life form).
  prefs: []
  type: TYPE_NORMAL
- en: We will create a script that will take values from the FuzzDB meta-characters
    file and send them to every parameter available and record all the results. This
    is most definitely a brute-force attempt to identify vulnerabilities and requires
    a sensible human being to go through the results.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this, you will require the FuzzDB from Mozilla. At the time of printing,
    this is available from [https://code.google.com/p/fuzzdb/](https://code.google.com/p/fuzzdb/).
    The file you specifically want for this script is `/fuzzdb-1.09/attack-payloads/all-attacks/interesting-metacharacters.txt`
    within the `fuzzdb` TAR file. I'm reusing the test PHP scripts from the XSS script
    for proof of concept, but you can use this against whatever you like. The aim
    is to trigger an error.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of the output produced when using this script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We import our libraries. As this is a testing script again, we establish our
    URLs in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We then open two files. The first will be the FuzzDB meta-characters file.
    I''ve included my path, though it is acceptable to make a copy of the file in
    your working directory. The second file will be the file you write to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We create an empty dictionary to be populated by our parameters and attack
    strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'As the script writes its output to a file, we need to provide some text to
    show that the script is working, so we write a nice and simple message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We read the original page that accepts input and assign to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We split out the page with `BeautifilSoup` and identify the only fields we
    want, being the input fields and the name fields from there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to check again that any fields named submit are provided with `submit`
    as data, otherwise we apply our attack string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We submit first a `POST` request sending out dictionary of attack strings mapped
    to input fields and then we request a `GET` request from the page that shows output
    (some errors may occur before the third page so you should consider restricting
    accordingly):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the output will be long and messy, we write the output to the file
    that we opened initially, so that it may be easily reviewed by a human being:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We reset the dictionary for the next attack string and then provide the user
    with an end of script output for clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can just keep adding stuff to this recipe. It's designed to be open for
    multiple types of input and attack. FuzzDB contains lots of different attack strings,
    so all of these can be applied. I encourage you to explore.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can test this against the stored XSS PHP pages as I have done.
  prefs: []
  type: TYPE_NORMAL
- en: jQuery checking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the lesser checked but more serious OWASP Top 10 vulnerabilities is the
    use of libraries or modules with known vulnerabilities. This can often mean versions
    of web frameworks that are out of date, but it also includes JavaScript libraries
    that perform specific functions. In this circumstance, we are checking jQuery;
    I have checked other libraries with this script but for the purposes of an example,
    but I will stick to jQuery.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a script that identifies whether a site uses jQuery, retrieve
    it's version number, and then compare that against the latest version number to
    determine whether it is up to date.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of the output produced when using this script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As ever, we import our libraries and create an empty library to house our future
    identified scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'For this script, we have created a simple usage guide that detects whether
    a URL has been provided. It reads the number of `sys.argv`, and if it is not equal
    to `2`, including the script itself, then it prints out a guide:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We take our target URL from the `sys.argv` list and open it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'As with before, we use beautiful soup to take the page apart; however, this
    time we are identifying scripts and pulling their `src` values in order to obtain
    the URLs of the `js` libraries being that are used. This collects together all
    the potential libraries that could be jQuery. Bear in mind that if you extend
    the usage to include different types of library, this list of URLs can be very
    useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'For each identified script, we then check to see if there is any mention of
    `jquery.min`, which would indicate the core jQuery file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We then use regex to identify the version number. In jQuery files, this will
    be the first thing mentioned that fits the given regex. The regex looks for `0-9`
    or `a-z` followed by a period that is repeated infinite amount of times. This
    is the format that the majority of version numbers take and jQuery is no different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `re.findall` method finds all strings that match this regex; however, as
    mentioned, we only want the first one. We identify it with comments`[0]`. We check
    to see whether this is equal to the hardcoded values of the current jQuery version,
    at time of writing. These will need to be updated manually. If the value is equal
    to either of the current versions, the script will state that it is up to date,
    alternatively if it is not equal it will print the detected version along with
    an out of date message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is obviously extendable and can be applied to any JavaScript library
    by simply adding to the detection strings and versions.
  prefs: []
  type: TYPE_NORMAL
- en: If the string was to be extended to include other libraries, such as insecure
    Django or flask libraries, the script would have to be altered to handle the alternate
    way that they are stated, as they are obviously not declared as JavaScript libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Header-based Cross-site scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have focused on sending payloads through URLs and parameters,
    the two obvious methods of performing attacks. However, there are numerous rich
    and fertile sources of vulnerabilities that often lay untouched. One of these
    will be covered in depth in [Chapter 6](ch06.html "Chapter 6. Image Analysis and
    Manipulation"), *Image Analysis and Manipulation*, for which we can give an intro
    now. Logs are often kept of specific headers of users that are accessing web pages.
    It can be a worthwhile activity performing checks against these logs by performing
    XSS attacks in headers.
  prefs: []
  type: TYPE_NORMAL
- en: We will be creating a script that submits XSS attack strings to all available
    headers and cycles through several possible XSS attacks. We will provide a short
    list of payloads, grab all the headers, and submit them sequentially.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Identify the URL that you wish to test. See the end of this example for a PHP
    web page that the script can be used against in order to test the validity of
    the scripts.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you''ve identified your target web page, pass it to the script as a command
    line argument. Your script should be the same as shown in the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The script won''t provide any output as it targets the admin side of functionality.
    However, you could set it to provide an output on each loop easily with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This would return the following every time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We import the libraries that we require for this script and take input in the
    form of a `sys.argv` function. You should be fairly en fait with this at this
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, we can declare our payloads as a list, rather than a dictionary,
    as we are going to pair them with values provided by the web page. We also create
    an empty dictionary to house our future attack pairings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We then make a `HEAD` request to web page to return only the headers from the
    page we are attacking. It''s possible, though unlikely, that `HEAD` requests may
    be disabled; however, if it is, we can replace this with a standard `GET` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We loop through the payloads that we set up earlier and the headers we pulled
    from the preceding `HEAD` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'For each payload and header, we add them to the empty dictionary that we set
    up earlier, as pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'For each iteration of the payloads, we then submit all the headers with that
    payload as we obviously can''t submit multiple of each header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Because the active part of the attack occurs on the client side of the admin,
    either an admin account needs to be utilized to check manually or an admin needs
    to be contacted to see if the attack is activated anywhere in the logging chain.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following is a setup than can be used to test the preceding script. This
    is very similar to the earlier script for XSS checking. The difference here is
    that the conventional XSS methods will fail due to the `strip_tags` function.
    It demonstrates the situations where unconventional methods are required to perform
    attacks. Obviously, returning the user-agent in a comment is contrived, though
    this is something that is frequent in the wild. They need to be saved as the filenames
    provided to work and in conjunction with a MySQL database to store the comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the first interface page named `guestbook.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The following script is `addguestbook.php`, which places your comment in the
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The final script is `viewguestbook.php`, which draws the comments from the
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Shellshock checking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Moving away from the standard style of attacks against web servers, we're going
    to quickly look at Shellshock, a vulnerability that allowed attackers to make
    shell commands through specific headers. This vulnerability reared its head in
    2014 and gained momentum quickly as one of the biggest vulnerabilities of the
    year. While it has now been mostly fixed, it's a good example of how web servers
    can be manipulated to perform more complex attacks and are likely to be a frequent
    target in **common transfer files** (**CTFs**) for years to come.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a script that pulls down the headers of a page, identifies whether
    the vulnerable headers are present, and submits an example payload to that header.
    This script relies on external infrastructure supporting this attack to collect
    compromised device call-outs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Identify the URL you wish to test. Once you''ve identified your target web
    page, pass it to the script as a `sys.argv`:'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Your script should be the same as the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The script won''t provide output as it targets the admin side of functionality.
    However, you could set it to provide an output on each loop easily with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This would return the following every time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We import the libraries that we require for this script and take input in the
    form of a `sys.argv` function. This is getting a bit repetitive, but it gets the
    job done.
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare our payload as a singular entity. If you have multiple actions that
    you wish to perform upon the server, you can make this a payload, similar to the
    preceding. We also create an empty dictionary for our header-payload combinations
    and make a `HEAD` request to the target URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The payload set here will ping whichever server you set at the `<url/ip>` space.
    It will send a message in that ping, which is `pwnt`. This allows you to identify
    that the server has actually been compromised and it's not just a random server.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then go through each header we pulled in the initial `HEAD` request and
    check to see if any are the `referrer` or `User-Agent` headers, which are the
    headers vulnerable to the Shellshock attack. If those headers are present, we
    send our attack string against that header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve established if our headers are present and having set the attack
    string against them, we launch our request. If successful, the message should
    appear in our logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
