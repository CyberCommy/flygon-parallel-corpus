- en: '*Chapter 3*: The Correct Mindset'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I think I'm right in saying that we've learned quite a lot together, and I hope
    you're excited to keep up the learning process. In the previous chapter, we learned
    more about how a React Native project works and what role each file or folder
    has. After that, we started learning about **JavaScript XML** (**JSX**) and how
    to use it, and we've actually imported our first component. Learning about the
    core components you're going to use every time a new project is created set us
    on the path of understanding and creating our own component.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will focus mostly on the React architecture and how it makes us
    think in a certain way after we spend some time with the framework. For starters,
    we'll begin with the main idea about how people start a React application—or,
    in our case, a React Native application, and we'll easily transition into the
    more advanced concepts of React, such as props.
  prefs: []
  type: TYPE_NORMAL
- en: By grasping the concept of props, we'll be able to add the next level of complexity
    to our applications. This will allow us to create even cooler components, unlocking
    more powers of React. You'll find yourself using props in almost every component
    you create.
  prefs: []
  type: TYPE_NORMAL
- en: After that, it's time to learn about rendering lists and how to use those to
    change the information inside our components. This sounds pretty neat, right?
    We'll be able to have different information shown based on whatever calculations
    we want to do inside the component or however many items we need to showcase.
  prefs: []
  type: TYPE_NORMAL
- en: Completing this chapter will teach you great ways of thinking as a React developer.
    This will serve as a good time saver for when you first start any project, and
    it's really important to understand how to correctly structure our files and code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll realize how programmers are reusing their code in such a way that you''ll
    keep repeating to your family: "Write once, use everywhere!"'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Thinking in React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always build the static version first
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Props and how to use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can check out this chapter's code by going to GitHub at [https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio](https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio).
    You'll find a folder called `Chapter 03` that contains all the code we've written
    inside this chapter. In order to use that project, please follow the instructions
    found in the `README.md` file.
  prefs: []
  type: TYPE_NORMAL
- en: Thinking in React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's not forget the fact that Facebook created React for their own projects
    and it's actually used in almost any type of website (or mobile app with React
    Native), so it has big scalability features. If Facebook can use it in their platform,
    we can surely use it inside our apps.
  prefs: []
  type: TYPE_NORMAL
- en: For us to take full advantage of this framework, we need to start thinking in
    React. When I first started my programming journey, the idea of a framework seemed
    kind of alien to me. I didn't understand the fact that it's called a framework
    because it comes packed with a specific workflow. Well, that's not the only reason
    why it's called a framework—it's also because it comes packed with tons of features
    and methods to make our work easier.
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine we're working with our friends on an app idea that we're going
    to call *PiggyBank* just for fun. The idea is that we need to always keep track
    of all the transactions we're making with our credit card. So, this basically
    means we'll have a card keeping track of all our transactions somewhere in our
    app.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ve designed the following card in Adobe XD, which I think will help us visualize
    things better:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Card component displaying our transactions'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_3.01_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – Card component displaying our transactions
  prefs: []
  type: TYPE_NORMAL
- en: So, our friend came up with this cool card design and he's asking us to implement
    it in the mobile app. Easy, right? We've seen how everything can be coded from
    top to bottom just by using JSX code; on top of that, there's so much text on
    this card that it makes things even easier for us. You might even think we don't
    need any custom components or we might only need one.
  prefs: []
  type: TYPE_NORMAL
- en: Well, that's not entirely true. This is the moment where our React knowledge
    shines through and it helps us divide everything into components for much easier
    and cleaner code. But the question remains… how do you know where to draw the
    rectangles, and how do we delimitate the components? One technique that React
    recommends is the **single-responsibility principle** (**SRP**).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The SRP is a programming principle that dictates the fact that every class in
    a program we're writing should have responsibility over a single part of that
    program's functionality. This is part of **SOLID**, which is an acronym for five
    design principles for software engineers to create more maintainable, flexible,
    and understandable code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this principle, we should now be able to divide the card into components.
    Let''s take this card and draw rectangles on it for each and every component we
    encounter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Rectangles drawn to divide components'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_3.02_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – Rectangles drawn to divide components
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we''ve extracted the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TransactionCard` (*red*)—Contains the full card and all of its elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TransactionCardHeader` (*green*)—Represents the upper part of the card, the
    part with the name and total money spent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TransactionCardList` (*yellow*)—Contains a list of items'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TransactionItem` (*pink*)—A single item displaying the transaction and the
    price'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, we've successfully divided this card into four different components
    that will have to somehow talk to each other and at the end have this one purpose
    of showing information regarding our transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Each of them has only one single purpose, so that checks the SRP we've been
    talking about. Let's code it, without styling yet—we'll do that in the following
    chapter. Always build the static version first.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we need to understand that the easiest way we can start working
    on an application is by building static pages and then separating everything and
    building the logic. For that, we'll have to basically copy everything we see in
    the image, even the text—that's why we call it a static version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a new project by opening up the terminal, moving to
    our project''s folder, and writing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: I've picked `TransactionCard` as my project name, but don't forget that you
    can name it whatever you want. Next, we'll be choosing the blank managed workflow
    template and will wait for it to start initializing our project. Once that's done,
    let's open up our **integrated development environment** (**IDE**)/text editor
    of choice and look over the project.
  prefs: []
  type: TYPE_NORMAL
- en: I'll open up `App.js` and delete the `StatusBar` import (not really important
    for this exercise) and everything from the inside of our `View` component in our
    `App` function.
  prefs: []
  type: TYPE_NORMAL
- en: Let's decide what types of components we need. It's pretty easy to see that
    this card only needs a `View` component and a `Text` component. Luckily for us,
    we already have those imported in the file, so let's use them to build our static
    version of the card.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by looking at our design and try to divide everything into containers.
    As we can see, this card has two parts: the upper part is the header with general
    information, and the lower part is full of all of our recent transactions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s write the code for those parts, but first, we''ll focus on the upper
    side of our card, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Upper side of our card'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_3.03_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – Upper side of our card
  prefs: []
  type: TYPE_NORMAL
- en: We see a lot of `View` components here, but why is that? As we discussed in
    the last chapter, the `View` component is usually used for layout design and grouping
    elements together. So, we've grouped the two parts inside of it and then wrote
    code for the header. If we save and open our simulators, we should be able to
    see the text we've just written.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget that if you use the Android simulator, you first need to open up
    Android Studio and then go to the **Android Virtual Device** (**AVD**) Manager.
    Run your simulator and afterward start the app from the Expo dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: Let's think about our transactions now. We have two pieces of text—to the left
    is the name of the company from which we bought whatever we bought, and to the
    right, we can see the price of the transaction. How can we do that? As far as
    we have seen until now, the elements we've printed out to the screen were always
    aligned in a columnar style from top to bottom.
  prefs: []
  type: TYPE_NORMAL
- en: Well, we need to style it for that to work, but the important point here is
    that we need to understand the fact that those two components are somehow connected,
    so we'd have to put those elements in the same `View` component.
  prefs: []
  type: TYPE_NORMAL
- en: Let's do that now and get our components ready for writing all these transactions.
    First, try to do it on your own and then see if you got the same code as I did.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ll start by creating a different `View` component for each line and then
    add the text inside it, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – The rest of the static code'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_3.04_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – The rest of the static code
  prefs: []
  type: TYPE_NORMAL
- en: Let's open up our app and take a peek at how everything looks. Right now, it's
    just a bunch of text in the form of a column displaying all the information we
    have in our design. It doesn't look like a card, though, but we can definitely
    see a resemblance to our design in terms of having the same information in the
    same order. So, we've now created the most basic version of our card.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to finally break down this big tree into smaller components.
    By doing this, we'll make the code easier to read and understand and also more
    modulated, which basically means we could use the same component in a different
    card or whatever we need it for at that moment.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking down our code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, remember we''ve been dividing the design into four different components?
    Let''s create a `components` folder and create four different files for each component,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Our folder with all the files created'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_3.05_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – Our folder with all the files created
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to start coding each one. So, we know that the big card—or the
    first component—should be able to be split into two parts, the `List` and the
    `Header` components. Let's copy all of our code from `App.js` into `TransactionCard`,
    as this one is the main component. By all the code, I mean only what's inside
    the first `View` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating our function, we paste all the code inside it. Let''s export
    the component and take a look at it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – TransactionCard component written as an arrow function'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_3.06_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6 – TransactionCard component written as an arrow function
  prefs: []
  type: TYPE_NORMAL
- en: We've written this component as an arrow function because it's easier to write—at
    least, in my opinion—but honestly, you can write it even as a class if you want.
    As a rule of thumb, you usually use `class` only if there's state involved, but
    state is something we need to go into in more depth in the later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: So, we have all the code here and we've exported our function. All good—now,
    the next step is to go even deeper with our division. Let's take the header side
    of our component and move it to its specific file.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we''ve finished copying the code into our `TransactionCardHeader` component,
    let''s import the component into our `TransactionCard` component and use it instead
    of our copied code. We should do the same thing with the second part of our card,
    and that is the `TransactionCardList` component. Let''s do it and see what everything
    looks like. Here''s the result:'
  prefs: []
  type: TYPE_NORMAL
- en: s
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Our newly created TransactionCard component'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_3.07_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.7 – Our newly created TransactionCard component
  prefs: []
  type: TYPE_NORMAL
- en: OK—so, this looks much, much cleaner. If we import this component into our `App.js`
    file, everything should look identical to how it used to look before we started
    making all these changes to our code.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget that we always need to run `import React from 'react';` so that
    we can use all of our components. For a component to run, it needs to know it's
    a component and not just random writing in a file. That import helps our code
    identify which objects are React objects and how to render everything.
  prefs: []
  type: TYPE_NORMAL
- en: Everything works, right? If you've encountered any issues, stop for 2 seconds
    before moving further and check everything we've been doing until now; maybe you
    got something misspelled or you forgot some exports somewhere in your files.
  prefs: []
  type: TYPE_NORMAL
- en: If everything's fine, let's get inside our `TransactionItem` component. Well,
    as the name suggests, this is one single item, so what does that mean? As we can
    see in our `TransactionCardList` component, we do have several different items.
    Are we going to create a different component for each one of them?
  prefs: []
  type: TYPE_NORMAL
- en: Not really—we're actually going to create a single component that changes the
    information displayed based on whatever information it receives as input. This
    sounds pretty cool, right? Well, that input is called a prop, and each component
    gets a set of props when it renders by default, but it can also receive custom
    props created by us. Let's dive into props and learn how to use them in the context
    of our card.
  prefs: []
  type: TYPE_NORMAL
- en: Props and how to use them
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, what exactly are props? Up to now, we've only used normal tags to identify
    our components such as `TransactionCardHeader`. However, as we saw earlier when
    we presented different components, these ones could also have **props** that are
    used to pass down information from the bigger component (**parent**) to a smaller
    component (**children**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go into `TransactionCardList` and look at our code. As far as we can
    see, there''s a lot of code repeating itself in terms of components being used.
    So, we can see this pattern emerging from inside our main `<View />` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – TransactionCardList component ready to be divided into smaller
    components'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_3.08_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.8 – TransactionCardList component ready to be divided into smaller
    components
  prefs: []
  type: TYPE_NORMAL
- en: The pattern is pretty easy to see—we have four identically written pieces of
    code but with different information written inside of it. We basically have four
    instances of `View` components with two `Text` components inside of them. Seeing
    how this repeats, we can clearly realize that we could write an external component
    for this specific case.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin by writing a static component inside our `TransactionItem` component
    and see how we can implement it inside our list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just go ahead and write one of these pieces of pattern; we only need one—otherwise,
    we''ll kind of defeat the purpose of a singular item. This is what the code should
    look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Static version of TransactionItem'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_3.09_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.9 – Static version of TransactionItem
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's use this component instead of all our pieces of pattern we've used
    inside our list. After importing the file and replacing everything with four or
    five instances of `TransactionItem`, we can see that the data is now `Starbucks`
    and `$ 10.12` everywhere. Repeating itself like crazy is not really how a great
    mobile app is designed, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, how can we change that? How can we have different pieces of information
    displayed by our component? By using props. Let me change the `TransactionItem`
    component and see how props need to be implemented. This is what the code should
    look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Implementing props into our component'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_3.10_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.10 – Implementing props into our component
  prefs: []
  type: TYPE_NORMAL
- en: Right now, your `TransactionCardList` component contains multiple instances
    of `TransactionItem`. If you save right now there's nothing showing up for these
    components besides the `$` sign. Why is that?
  prefs: []
  type: TYPE_NORMAL
- en: This all happens because our component has nothing stored in those variables.
    For us to actually get something displayed on the screen, we'd have to send some
    information over to our `TransactionItem` component from `TransactionCardList`.
    Let's move inside of it and use our newly updated components to display the correct
    information on our phone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `TransactionCardList` component, find our components and add the
    following props to each component, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: After we've added props to all of our components, the next step is to save.
    We'll see how our simulator refreshes automatically—and congratulations! We've
    successfully sent information from one **parent** component to our **child** component.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: All the information being sent from one component to another will formally be
    inside curly braces, as we've seen by writing the number for the price prop. Even
    though strings could still be placed inside curly braces, they're not mandatory
    for sending information, so you could even write `name="Mircea"`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's try to understand our code a little bit. So, what's going on, really,
    inside our app?
  prefs: []
  type: TYPE_NORMAL
- en: When the app first runs, it goes straight to `App.js` and starts rendering all
    the components first written there. For that, that'll be our `TransactionCard`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: React sees that our component actually has two different components inside it
    and begins rendering the next components. Now, one of these components is actually
    our `TransactionCardList` component, which contains all our `TransactionItem`
    components.
  prefs: []
  type: TYPE_NORMAL
- en: Because the first component contains another component, we call the first one
    a **parent** and the second one a **child** to the first one. So, if `TransactionItem`
    is a **child** to `TransactionCardList`, try to figure out what `TransactionCard`
    is to `TransactionCardHeader`. Ready? `TransactionCard` is the **parent** of `TransactionCardHeader`
    because it contains the other component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when React reaches `TransactionCardList`, it''ll send some information
    to each `TransactionItem` component via the **props**. The information being sent
    is a JavaScript object that looks like this: `{name: ''Starbucks'', price=10.12}`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s why we can use props as an argument for our function in `TransactionItem`
    and then access the keys of our object with a dot, like this: `props.name`. You
    must be wondering how React knows how to handle all these processes because a
    more complex app might have hundreds of components nested into each other while
    sending props to one another at the first render.'
  prefs: []
  type: TYPE_NORMAL
- en: The thing is, React first renders everything that's at the surface, and when
    all the information is being sent from one parent component to a child, then it
    renders that information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, just to make our component even more usable and reusable, we''d have to
    make the number of items in our list a little more variable. For a bigger app,
    we''d have to ask ourselves questions such as these: "What if the number of transactions
    a user makes is bigger or smaller than five?"; "What if I''ll need more cards
    for future screens but with the same design? How can I reuse this card component?"'
  prefs: []
  type: TYPE_NORMAL
- en: Using the map function to dynamically change the number of components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Well, let''s first see how we can output as many `TransactionItem` components
    as we can. We''ll go inside our `TransactionCardList` component and create a constant
    array of objects, outside of our function, called `transactions`. This variable
    will contain all the information needed for our items. Let''s see what this looks
    like, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – transactions variable'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_3.11_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.11 – transactions variable
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have this variable with all the information that we need, we could
    **map** our array and output a different component for each item. This might sound
    a bit confusing if you''re not really comfortable with JavaScript, but trust me,
    it''s really easy. Let''s delete everything from inside the `<View />` component
    and replace it with the `map` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – map function used inside TransactionCardList component'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_3.12_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.12 – map function used inside TransactionCardList component
  prefs: []
  type: TYPE_NORMAL
- en: OK—so, this might look a bit strange. Don't worry—it's actually really easy.
    So, we've used the `map` function on our `transactions` array. This `map` function
    goes over each element of our array and uses the function inside its argument
    to output *something*. That something is where you come in and make use of this
    cool function.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: All external code used inside JSX **must** be put between curly braces so that
    React can understand that we're doing an operation that could result in other
    elements being outputted for rendering.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, because of the `map` function, we''re taking the first item of our
    array— `{name: "Starbucks", price: 10.12}`—outputting a `TransactionItem` component,
    and passing as props the values we''ve had in our array. But we also see the **key
    prop** and we both know we haven''t used the key prop inside our component. Every
    list needs a key for each child so that React can keep track of them and avoid
    excessive re-rendering. This is one of React''s rules that we need to understand
    whenever we''re using lists such as these.'
  prefs: []
  type: TYPE_NORMAL
- en: But we've said we'd go even further, right? We need to use this card component
    multiple times if we need to. Seeing how `transactions` is just a random variable
    sitting in our `TransactionCardList` component, maybe we could send that as a
    **prop**?
  prefs: []
  type: TYPE_NORMAL
- en: Let's add the `props` keyword inside our function's argument and change from
    `transactions.map` to `props.transactions.map`. If we save now, we get an error—our
    component expects a prop called `transactions` to come in but there's nothing
    sending it.
  prefs: []
  type: TYPE_NORMAL
- en: We'd have to send this from our parent component—namely, `TransactionCard`.
    But nonetheless, this doesn't really change the fact that we still can't use the
    card properly, so maybe we need to add this prop to even our `TransactionCard`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s copy our `transactions` variable and move it inside our `App.js` file.
    After that, let''s add the `transactions` prop to our `TransactionCard` component,
    like this: `<TransactionCard transactions={transactions} />.`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll have to go to our `TransactionCard` component and enable it to
    take this prop and send it even further to our `TransactionCardList` component.
    Our component now needs to look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – Our newly created version of the TransactionCard component'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_3.13_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.13 – Our newly created version of the TransactionCard component
  prefs: []
  type: TYPE_NORMAL
- en: So, we've been sending this information from the `App.js` file all the way to
    our `TransactionItem` component where we finally display the information. How
    did this help us? Well, right now, we can have multiple instances of this card
    with different transactions, or we can even add or lower the number of transactions
    based on the constant that we now have declared inside our `App.js` file. We can
    use different variables altogether; we can have a different array called `biggerTransactions`
    and pass it to another component. Maybe this one will display the biggest transactions
    you've done.
  prefs: []
  type: TYPE_NORMAL
- en: The important thing here is the fact that we now don't have to touch our card
    component at all and we can still use it while displaying different information.
    This is much easier than creating different files for each piece of information
    we need, or maybe at one point you need to change specific information and you
    start browsing every file looking for that specific thing. You now don't have
    to do that—just go into your main file and change all the information from there.
  prefs: []
  type: TYPE_NORMAL
- en: Let's do some homework. You'll find the answer in our GitHub repository, in
    the `Chapter 03` folder. Having the same name all the time on our card could become
    boring. Make this easier by allowing yourself to use multiple instances of the
    same card component but for different users. After finishing this, go check out
    the code and compare it to mine. See if you did the same thing!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've gone even deeper with React Native. We've learned so
    much about new concepts such as props and the SRP. We should be able to start
    thinking using the React methodology based on props for now, and, later, even
    state. But understanding all this is a great step toward you becoming a real React
    Native developer.
  prefs: []
  type: TYPE_NORMAL
- en: You should feel even more comfortable regarding the way props are handled and
    how we can use this special feature of React called components for our benefit,
    for reusability and cleaner code. There's no such thing as your code being too
    clean, but at the same time, keep in mind the fact that sometimes there's no need
    for multiple layers of props. Maybe your component needs only one layer or no
    props at all. Only use this feature when you feel it might make your work easier.
  prefs: []
  type: TYPE_NORMAL
- en: We've also created a list for the first time and learned that each item of a
    list needs a key, a key that could sometimes be even our array's index, but there's
    always a unique key being sent to each of our items.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, we finished with a little bit of homework and a
    lot of hope for the next chapter, where we'll finally create our first small application
    to show our friends.
  prefs: []
  type: TYPE_NORMAL
