- en: Using MySQL (Advanced)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common table expressions (CTE)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generated columns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Window functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn about the newly introduced features of MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: Using JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you have seen in the previous chapter, to store data in MySQL, you have to
    define the database and table structure (schema), which is a major limitation.
    To cope with that, from MySQL 5.7, MySQL supports the **JavaScript Object Notation** (**JSON**)
    datatype. Earlier there was no separate datatype and it was stored as a string.
    The new JSON datatype provides automatic validation of JSON documents and optimized
    storage format.
  prefs: []
  type: TYPE_NORMAL
- en: 'JSON documents are stored in binary format, which enables the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Quick-read access to document elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No need for the value to be parsed from a text representation when the server
    reads the JSON again
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking up subobjects or nested values directly by key or array index without
    reading all values before or after them in the document
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Suppose you want to store more details about your employees; you can save them
    using JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Insert JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Retrieve JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can retrieve the fields of the JSON column using the `->` and `->>` operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To retrieve data without quotes, use the `->>` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: JSON functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL provides many functions to deal with JSON data. Let's look into the most
    used ones.
  prefs: []
  type: TYPE_NORMAL
- en: Pretty view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To display JSON values in pretty format, use the `JSON_PRETTY()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Without pretty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Searching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can reference a JSON column using the `col->>path` operator in the `WHERE` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the `JSON_CONTAINS` function to search for data. It returns
    `1` if the data is found and `0` otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'How to search for a key? Suppose you want to check whether `address.line1`
    exists or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `one` indicates at least one key should exists. Suppose you want to check
    whether `address.line1` or `address.line2` exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to check whether both `address.line1` and `address.line5` exist,
    you can use `and` instead of `one`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Modifying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can modify the data using three different functions: `JSON_SET()`, `JSON_INSERT()`,
    `JSON_REPLACE()`. Before MySQL 8, we needed a full update of the entire column,
    which is not the optimal way:'
  prefs: []
  type: TYPE_NORMAL
- en: '`JSON_SET`: Replaces existing values and adds non-existing values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Suppose you want to replace the pin code of the employee and also add details
    of a nickname:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`JSON_INSERT()`: Inserts values without replacing existing values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Suppose you want to add a new column without updating the existing values;
    you can use `JSON_INSERT()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `pin` won't be updated; only a new `address.line4` field will
    be added.
  prefs: []
  type: TYPE_NORMAL
- en: '`JSON_REPLACE()`: Replaces *only* existing values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Suppose you want to just replace the fields without adding new fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `line5` won't be added. Only `pin` will be updated.
  prefs: []
  type: TYPE_NORMAL
- en: Removing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`JSON_REMOVE` removes data from a JSON document.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you no longer need `line5` in the address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Other functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some of the other functions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`JSON_KEYS()`: Gets all the keys in a JSON document:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '` JSON_LENGTH()`: Gives the number of elements in a JSON document:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can check out the complete list of functions at [https://dev.mysql.com/doc/refman/8.0/en/json-function-reference.html](https://dev.mysql.com/doc/refman/8.0/en/json-function-reference.html).
  prefs: []
  type: TYPE_NORMAL
- en: Common table expressions (CTE)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL 8 supports common table expressions, both non-recursive and recursive.
  prefs: []
  type: TYPE_NORMAL
- en: Common table expressions enable the use of named temporary result sets, implemented
    by permitting a `WITH` clause preceding `SELECT` statements and certain other
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why do you need CTEs?** It is not possible to refer to a derived table twice
    in the same query. So the derived tables are evaluated twice or as many times
    as referred, which indicates a serious performance problem. Using CTE, the subquery
    is evaluated only once.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recursive and non-recursive CTE will be looked into in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Non-recursive CTE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**A Common table expression** (**CTE**) is just like a derived table, but its
    declaration is put before the query block instead of in `FROM` clause.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Derived Table**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**CTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'A CTE may precede `SELECT`/`UPDATE`/`DELETE`, including subqueries `WITH` derived
    `AS` (subquery), for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose you want to find out the percentage increase in the salary of each
    year with respect to the previous year. Without CTE, you need to write two subqueries,
    and they are essentially the same. MySQL is not smart enough to detect that and
    the subqueries are executed twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'With non-recursive CTE, the derived query is executed only once and reused:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You may notice that with CTE, the results are the same and query time improves
    by 50%; the readability is good and can be referenced multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Derived queries cannot refer to other derived queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'CTEs can refer to other CTEs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Recursive CTE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A recursive CTE is a CTE with a subquery that refers to its own name. The `WITH`
    clause must begin with `WITH RECURSIVE`. The recursive CTE subquery has two parts,
    seed query and recursive query, separated by `UNION [ALL]` or `UNION DISTINCT`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Seed `SELECT` is executed once to create the initial data subset; recursive
    `SELECT` is repeatedly executed to return subsets of data until the complete result
    set is obtained. Recursion stops when an iteration does not generate any new rows.
    This is useful to dig into hierarchies (parent/child or part/subpart):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose you want to print all numbers from `1` to `5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: At each iteration, `SELECT` produces a row with a new value one more than the
    value of `n` from the previous row set. The first iteration operates on the initial
    row set (1) and produces *1+1=2*; the second iteration operates on the first iteration's
    row set (2) and produces *2+1=3*; and so on and so forth. This continues until
    the recursion ends, when `n` is no longer less than `5`.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you want to do hierarchical data traversal to produce an organizational
    chart with the management chain for each employee (that is, the path from CEO
    to employee). Use a recursive CTE!
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a test table with `manager_id`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Insert sample data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the recursive CTE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'It produces the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`WITH RECURSIVE employee_paths (id, name, path) AS` is the name of the CTE
    and the columns are (`id`, `name`, `path`).'
  prefs: []
  type: TYPE_NORMAL
- en: '`SELECT id, name, CAST(id AS CHAR(200)) FROM employees_mgr WHERE manager_id
    IS NULL` is the seed query where the CEO is selected (CEO does not have a manager).'
  prefs: []
  type: TYPE_NORMAL
- en: '`SELECT e.id, e.name, CONCAT(ep.path, '','', e.id) FROM employee_paths AS ep
    JOIN employees_mgr AS e ON ep.id = e.manager_id` is the recursive query.'
  prefs: []
  type: TYPE_NORMAL
- en: Each row produced by the recursive query finds all employees who report directly
    to an employee produced by a previous row. For every such employee, the row includes
    the employee ID, name, and employee management chain. The chain is the manager's
    chain with the employee ID added at the end.
  prefs: []
  type: TYPE_NORMAL
- en: Generated columns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The generated columns are also known as virtual or computed columns. The values
    of a generated column are computed from an expression included in the column definition.
    There are two types of generated columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Virtual**: The column will be calculated on the fly when a record is read
    from a table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stored**: The column will be calculated when a new record is written in the
    table and will be stored in the table as a regular column'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Virtual generated columns are more useful than stored generated columns because
    a virtual column does not take any storage space. You can simulate the behavior
    of stored generated columns using triggers.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Suppose your application is using `full_name` as `concat(''first_name'', ''
    '', ''last_name'')` while retrieving the data from the `employees` table; instead
    of using the expression, you can use a virtual column, which calculates `full_name`
    on the fly. You can add another column followed by the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you should modify the insert statement according to the virtual column.
    You have an option to use the full insert like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to include `full_name` in the `INSERT` statement, you can specify
    it as `DEFAULT` only. All other values throw an `ERROR 3105 (HY000):` error. The
    value specified for the generated column, `full_name`, in the `employees` table is
    not allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You can directly select `full_name` from the `employees` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If you have already created the table and wish to add new generated column,
    execute the ALTER TABLE statement which will be covered in detail in *Chapter
    10 -* *Table Maintenance*
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Refer to [https://dev.mysql.com/doc/refman/8.0/en/create-table-generated-columns.html](https://dev.mysql.com/doc/refman/8.0/en/create-table-generated-columns.html)
    to know more about generated columns. You will understand the other uses of virtual
    columns in [Chapter 13](part0432.html#CRVJ00-faa69fe6f4c04957afca3568dcd9cd83), *Performance
    Tuning*, in the *Adding indexes* and *Index for JSON using generated columns*
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Window functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By using window functions, for each row from a query, you can perform a calculation
    using rows related to that row. This is accomplished by using the `OVER` and `WINDOW`
    clauses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the list of calculations that you can do:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CUME_DIST()`: Cumulative distribution value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DENSE_RANK()`: Rank of the current row within its partition, without gaps'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FIRST_VALUE()`: The value of the argument from the first row of the window
    frame'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LAG()`: The argument value from the row lagging the current row within partition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LAST_VALUE()`: Value of argument from the first row of window frame'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LEAD()`: Value of argument from row leading current row within partition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NTH_VALUE()`: Argument value from *n*-th row of window frame'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NTILE()`: Bucket number of the current row within its partition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PERCENT_RANK()`: Percentage rank value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RANK()`: Rank of the current row within its partition, with gaps'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ROW_NUMBER()`: Number of the current row within its partition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Window functions can be used in various ways. Let's get to grips with each one
    of them in the following sections. For these examples to work, you need to add
    hire_date_year virtual column
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Row number
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can get the row number for each row to rank the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Partition results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can partition the results in the `OVER` clause. Suppose you want to find
    out the salary rank for each year; it can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You can notice that the rank changed for the years `1986` and `1987` but the
    ranking for `1985` continued.
  prefs: []
  type: TYPE_NORMAL
- en: Named windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can name a window and use it as many times as you need rather than redefining
    it every time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: First, last, and nth values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can select the first, last, and *n*th values in the window results. If the
    row does not exist, a `NULL` value is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you want to find the first, last, and third values from the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: To know more about the other use cases of window functions, refer to [https://mysqlserverteam.com/mysql-8-0-2-introducing-window-functions](https://mysqlserverteam.com/mysql-8-0-2-introducing-window-functions)
    and [https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_row-number](https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_row-number).
  prefs: []
  type: TYPE_NORMAL
