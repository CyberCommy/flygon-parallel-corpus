- en: Advanced Char Driver Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we learned several useful things that can be handy in
    device driver development; however, a final step is needed. We must see how to
    add advanced functionalities to our character device and fully understand how
    we can synchronize user space processes with the peripheral I/O activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll see how to implement system calls for the `lseek()`,
    `ioctl()`, and `mmap()` functions, and we''ll also get to know several techniques
    to put a process to sleep, just in case our peripheral does not yet have data
    to return to it; therefore, in this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Going up and down within a file with lseek()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ioctl() for custom commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing I/O memory with mmap()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locking with the process context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locking (and syncing) with the interrupt context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting for I/O operations with poll() and select()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing asynchronous notifications with fasync()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Please check the appendix section of this chapter for more information.
  prefs: []
  type: TYPE_NORMAL
- en: The code and other files used in this chapter can be downloaded from GitHub
    at [https://github.com/giometti/linux_device_driver_development_cookbook/tree/master/chapter_07](https://github.com/giometti/linux_device_driver_development_cookbook/tree/master/chapter_07).
  prefs: []
  type: TYPE_NORMAL
- en: Going up and down within a file with lseek()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we're going to take a better look at how we can manipulate the `ppos` pointer (described
    in the *Exchanging data with a char driver* recipe in [Chapter 3](1625d420-d3d6-4655-9f08-050a8bb99c90.xhtml), *W**orking
    with Char Drivers*), which is related to the `read()` and `write()` system call
    implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To provide a simple example about `lseek()` implementation, we can reuse our
    `chrdev` driver in [Chapter 4](5f22a69e-e8b7-402e-8e67-72938d00c914.xhtml), *Using
    the Device Tree* in the `chapter_04/chrdev `directory (we need both of the  `chrdev.c`
    and `chrdev-req.c` files of GitHub repository), where we can simply add our custom
    `llseek()` method according to our device memory layout.
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity, I just copied these files in the `chapter_07/chrdev/` directory,
    and reworked them.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to modify the ESPRESSObin's DTS file as we did in chapter 4 with
    the  `chapter_04/chrdev/add_chrdev_devices.dts.patch `file in order to enable
    the chrdev device, and then, finally, we can reuse the  `chrdev_test.c` program created
    in [Chapter 3](1625d420-d3d6-4655-9f08-050a8bb99c90.xhtml), *Working with Char
    Drivers* within the `chapter_03/chrdev_test.c` file as a base program for our `lseek()` implementation
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding the ESPRESSObin''s DTS file, we can patch it by going in the kernel
    sources and then executing the `patch` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Then, we have to recompile the kernel and reinstall it with the preceding DTS
    as we did in [Chapter 1](2739e129-3c1a-4c98-ba9a-9c17ae4c09db.xhtml), I*nstalling
    the Development System*, and, finally, reboot the system.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how to do it by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we can simply redefine `struct file_operations` by adding our  `chrdev_llseek` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define the method''s body by using a big switch, where the `SEEK_SET`, `SEEK_CUR`,
    and `SEEK_END` possible values are managed, according to the memory layout of
    the driver:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to verify that `newppos` is still between 0 and `BUF_LEN`
    and, in a positive case, we have to update `filp->f_pos` with the `newppos` value
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that the new version of the `chrdev.c` driver can be retrieved from GitHub
    sources within the `chapter_07/` directory related to this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *step 2*, we should remember that we have a memory buffer of `BUF_LEN` bytes
    per device, so we can compute the new `newppos` position within the device by
    simply executing some simple operations.
  prefs: []
  type: TYPE_NORMAL
- en: So, for `SEEK_SET`, which sets `ppos` to `offset`, we can simply perform an
    assignment; for `SEEK_CUR`, which moves `ppos` from its current location (which
    is `filp->f_pos`) plus `offset` bytes, we execute a sum; and, finally, for `SEEK_END`,
    which set `ppos` to the end of the file plus `offset` bytes, we still perform
    a sum with the  `BUF_LEN` buffer size since we are expecting a negative value
    or zero from the userspace.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you wish to test the `lseek()` system call now, we can modify the `chrdev_test.c`
    program as reported previously, and then try to execute it on our new driver version.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s modify chrdev_test.c using the `modify_lseek_to_chrdev_test.patch` file,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have to recompile it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that this command can be executed in the ESPRESSObin by simply removing
    the `CC=aarch64-linux-gnu-gcc` setting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we have to move both the new `chrdev_test` executable and the `chrdev.ko`
    (the one with `lseek()` support) and `chrdev-req.ko` kernel modules on the ESPRESSObin,
    and then insert them into the kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This output is from a serial console, so we also get kernel messages. If you
    execute these commands over an SSH connection, you'll get no output and you will
    have to use the `dmesg` command to get an output in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can execute the `chrdev_test` program on one chrdev device, as
    shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the `lseek()` system call invokes the driver''s `chrdev_llseek()` method, which
    does what we expect. The kernel messages related to the preceding command are
    reported as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: So, `ppos` moved from byte 0 to byte 11 when the first `write()` system call
    is executed, then it moves back to 0 thanks to `lseek()`, and, finally, it moves
    again to 11 due to the execution of the `read()` system call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we can also invoke the `lseek()` method using the `dd` command, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we open the device, then we move `ppos` 11 bytes forward from the beginning,
    and then we do three 1-byte length reads for each.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following kernel messages, we can verify that the  `dd` program behaves
    exactly as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For further information about the `lseek()` system call, a good starting point
    is its man page, which can be obtained by using the `man 2 lseek` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ioctl() for custom commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will see how to add custom commands to configure or manage
    our peripheral in a very customized manner.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, in order to present a simple example about how we can implement an `ioctl()`
    system call within our driver, we can still use the chrdev driver presented earlier,
    where we add the `unlocked_ioctl()` method, as explained later.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how to do it by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we have to add the `unlocked_ioctl()` method within the  `chrdev_fops`
    structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add the method''s body where, at the beginning, we did some assignments
    and checks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can implement a big switch to execute the requested command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'For the last step, we have to define the `chrdev_ioctl.h` include file to be
    shared with the user space, holding the `ioctl()` commands defined in the preceding
    code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *step 2*, the `info`, `uarg`, and `iuarg` variables will be used, while the
    usage of the  `_IOC_TYPE()` macro is to verify that the `cmd` command was effective
    for our driver by checking the command's type against the  `CHRDEV_IOCTL_BASE` definition.
  prefs: []
  type: TYPE_NORMAL
- en: A careful reader should note that this check is not fault-proof due to the fact
    that a command's type is just a random number; however, it can be enough for our
    purposes here.
  prefs: []
  type: TYPE_NORMAL
- en: Also, by using `_IOC_NR()`, `_IOC_SIZE()`, and `_IOC_DIR()`, we can extract other
    information from the command, which can be useful for further checks.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 3*, as we can see for each command, according to the fact it's a reading
    or writing (or both) command, we have to get, or put, user data from the user
    space by utilizing the proper access functions, as explained in [Chapter 3](1625d420-d3d6-4655-9f08-050a8bb99c90.xhtml), *W**orking
    with Char Drivers,* in order to avoid memory corruption!
  prefs: []
  type: TYPE_NORMAL
- en: Now it should be also clear how the `info`, `uarg`, and `iuarg` variables are
    used. The first is used to locally store `struct chrdev_info` data, while the
    others are used to have properly typed data to be used with the `copy_to_user()` or `get_user()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To test the code and see how it behaves, we need to realize a proper tool that
    executes our new `ioctl()` commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example is provided in the `chrdev_ioctl.c` file, and in the following snippet,
    where the `ioctl()` calls are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s compile the `chrdev_ioctl.c` program by using the next command
    line on our host PC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note that this command can also be executed in the ESPRESSObin by simply removing
    the  `CC=aarch64-linux-gnu-gcc` setting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we try to execute the command on a chrdev device, we should get the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Of course, for this to work, we'll have already loaded this new chrdev driver's
    version containing the `ioctl()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'While on the kernel messages we should get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, after the device opening, two `ioctl()` commands are executed
    as expected.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For further information about the `ioctl()` system call, a good starting point
    is its man page, which can be obtained by using the `man 2 ioctl` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing I/O memory with mmap()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will see how to map an I/O memory region within the process
    memory space to gain access to our peripheral's internal by simply using a pointer
    in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's see how we can implement a custom `mmap()` system call for our chrdev
    driver.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have a virtual device totally mapped into memory, we may suppose that
    the `buf` buffer within `struct chrdev_device` represents the memory areas to
    be mapped. Also, we need to dynamically allocate it for it to be remapped; this
    is due to the fact that kernel virtual memory addresses cannot be remapped using
    the `remap_pfn_range()` function.
  prefs: []
  type: TYPE_NORMAL
- en: This is the only limitation of `remap_pfn_range()`, which is unable to remap
    the kernel virtual memory addresses that are not dynamically allocated. These
    addresses can be remapped too, but by using another technique not covered in this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prepare our driver, we must make the following modifications to `struct
    chrdev_device`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note that we also modified the buffer size to be at least a `PAGE_SIZE` long
    due to the fact we cannot remap memory areas shorter than the `PAGE_SIZE` bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, to dynamically allocate the memory buffer, we have to make the modifications
    listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the continuation of the preceding `diff` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: However, apart from this little note, we can proceed as we did previously, that
    is, by modifying our chrdev driver and adding the new method.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how to do it by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, as in previous sections, the first step is adding our new `mmap()` method
    to the driver''s `struct file_operations`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add the `chrdev_mmap()` implementation, as explained in the previous
    section and reported in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we must get the physical address of the `buf` buffer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note that this step won't be needed if we simply wanted to remap the physical
    address on which our peripheral is mapped.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can do the remap:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *step 2*, the function begins with some sanity checks in which we must verify
    that the memory region requested is compatible with the system and peripheral
    requirements. In our example, we must verify that the size of the memory region
    and the offset within it, and where the map starts from, are within the `buf` size,
    which is `BUF_LEN` bytes.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test our new `mmap()` implementation, we can use the  `chrdev_mmap.c` program introduced
    earlier. where we talked about `textfile.txt`. To compile it, we can use the following
    command on the host PC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note that this command can be executed in the ESPRESSObin by simply removing
    the `CC=aarch64-linux-gnu-gcc` setting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s start by writing something in the driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The kernel messages are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, as expected, within our memory buffer we have the `textfile.txt` contents;
    in fact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can try to execute the `chrdev_mmap`  program on our device to verify
    whether everything works well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we must be sure not to specify a size a value bigger than the device''s
    buffer size, which is 4,096 in our example. In fact, if we do the following, we
    get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`./chrdev_mmap /dev/cdev-eeprom\@2 4097`**'
  prefs: []
  type: TYPE_NORMAL
- en: '`file /dev/cdev-eeprom@2 opened`'
  prefs: []
  type: TYPE_NORMAL
- en: '`mmap: Invalid argument`'
  prefs: []
  type: TYPE_NORMAL
- en: This means we got it! Note that the  `chrdev_mmap` program (as `cp` and `cat`)
    works exactly the same on both usual files and on our char device.
  prefs: []
  type: TYPE_NORMAL
- en: 'The kernel messages related to the `mmap()` execution are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note that, after the remap, the program doesn't execute any system calls to
    gain access to the data. This leads to the possibility of better performances
    in obtaining access to the device's data rather than the case where we needed
    to use the `read()` or `write()` system calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also modify the buffer content by adding the optional argument, `0`,
    to the `chrdev_mmap` program, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, when we read the buffer again using the `read()` system call with, `cat`
    command, we can see that the first character within the file has changed to 0 as
    expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For further information regarding `mmap()`, a good starting point is its man
    page (`man 2 mmap`); then, looking at [https://linux-kernel-labs.github.io/master/labs/memory_mapping.html](https://linux-kernel-labs.github.io/master/labs/memory_mapping.html) would be
    even better.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locking with the process context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will see how to protect data against the concurrent access
    of two or more processes to avoid race conditions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To present a simple example about how to add a mutex to the chrdev driver, we
    can make a few modifications to it, as reported in the following.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have to add the `mux` mutex to the driver''s main structure in the `chrdev.h` header
    file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'All modifications presented here can be applied to the chrdev code using the
    `patch` command in the  `add_mutex_to_chrdev.patch` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`$ patch -p3 < add_mutex_to_chrdev.patch`**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the `chrdev_device_register()` function, we have to initialize the
    mutex by using the `mutex_init()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can modify the `read()` and `write()` methods to protect them. The
    `read()` methods should then look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `write()` method is reported as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to protect the `ioctl()` method too, since the driver''s  `read_only` property
    may change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This is really a silly example, but you should consider the case where even
    the `ioctl()` method may change the data buffer or other shared data of the driver.
  prefs: []
  type: TYPE_NORMAL
- en: This time, we removed all the `return` statements in favor of `goto`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's really hard to show how the code works by simply executing it, due to the
    intrinsic difficulties in reproducing a race condition, so it's better to discuss
    what we may expect from it.
  prefs: []
  type: TYPE_NORMAL
- en: However, you are encouraged to test the code anyway, maybe by trying to write
    a more complex driver where the concurrency may be a real problem if not correctly
    managed by the use of mutexes.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 1, *we added a mutex for each chrdev device we may have in the system.
    Then, after its initialization in *step 2*, we can effectively use it, as reported
    in *step 3* and *step 4.*
  prefs: []
  type: TYPE_NORMAL
- en: By using the `mutex_lock()` function we are, in fact, telling the kernel that
    no other process may go concurrently beyond this point to ensure that just one
    process can manage the driver's shared data. If some other process should effectively
    try to acquire the mutex while it was already held by the first process, a new
    process will be put to sleep on a waiting queue at the exact moment it tries to
    acquire the already locked mutex.
  prefs: []
  type: TYPE_NORMAL
- en: When finished, by using `mutex_unlock()`, we instead inform the kernel that
    the `mux` mutex has been released, and so, any awaiting (that is, sleeping) processes
    will be awakened; then, once finally rescheduled to run again, it could proceed
    and try, in turn, to grab the lock.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that in *step 3*, in both functions, we grab the mutex when it's
    really useful to avoid race conditions and not at their beginning; in fact, we
    should try to keep the locking as small as possible in order to protect the shared
    data (in our example, the `ppos` pointer and the  `buf` data buffer). By doing
    this, we are restricting the usage of our chosen mutual exclusion mechanism to
    the smallest possible section of code (the critical section), which accesses the
    shared data we want to protect from possible corruption introduced by a race condition
    happening under the previously specified conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that we must be careful not to return before releasing the lock,
    otherwise new accessing processes will hang! That's why we removed all the `return` statements
    but the last one and we used the `goto` statement to skip to the `unlock` label.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For further information regarding the mutexes and locking a good document, see
    the kernel documentation directory at `linux/Documentation/locking/mutex-design.txt`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locking (and syncing) with the interrupt context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's see how we can avoid race conditions between the process context
    and the interrupt context. However, this time we must pay more attention than
    before because, this time, we must implement a locking mechanism to protect shared
    data between the process context and the interrupt context. However, we must also
    provide a syncing mechanism between the reading process and the driver too, to
    allow the reading process to proceed in its action if some data to be read is
    present within the driver's queues.
  prefs: []
  type: TYPE_NORMAL
- en: To explain this problem, it is better to do a practical example. Let's suppose
    we have a peripheral that generates data for reading processes. To signal that
    new data has arrived, the peripheral sends an interrupt to the CPU, so we can
    imagine implementing our driver by using a circular buffer where the interrupt
    handler will save data from the peripheral into, and where any reading processes
    may get data from.
  prefs: []
  type: TYPE_NORMAL
- en: Circular buffers (also known as ring buffers) are fixed-size buffers that work
    as if the memory is contiguous and all memory locations are handled in a circular
    manner. As the information is generated and consumed from the buffer, it does
    not need to be reshuffled; we simply adjust the head and tail pointers. When data
    is added, the head pointer advances, and while data is consumed, the tail pointer
    advances. If we reach the end of the buffer, then each pointer simply wraps around
    to pointing back to the beginning of the ring.
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, we must protect the circular buffer against race conditions
    from both process and interrupt contexts since both get access to it, but we must also provide
    a syncing mechanism to put to sleep any reading process when no data is available
    for reading!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](https://cdp.packtpub.com/linux_device_driver_development_cookbook/wp-admin/post.php?post=30&action=edit#post_28), *Managing
    Interrupts and Concurrency*, we presented spinlocks, which can be used to place
    a locking mechanism between the process and interrupt context; we also presented
    waitqueues, which can be used to sync the reading processes with the interrupt
    handler.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This time, we have to use a modified version of our chrdev driver. In the `chapter_07/chrdev/` directory of
    the GitHub repository, we can find the  `chrdev_irq.c` and `chrdev_irq.h` files, which
    implement our modified driver.
  prefs: []
  type: TYPE_NORMAL
- en: We can still use `chrdev-req.ko` to generate the chrdev devices within the system,
    but now the kernel module will be used `chrdev_irq.ko` instead of `chrdev.ko`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, since we have a real peripheral, we can simulate the IRQ using a kernel
    timer (see [Chapter 5](https://cdp.packtpub.com/linux_device_driver_development_cookbook/wp-admin/post.php?post=30&action=edit#post_28), *Managing
    Interrupts and Concurrency*), which also triggers data generation using the following  `get_new_char()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This function simply generates a new character from A to Z each time it's called,
    restarting from character A after the generation of Z.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to focus our attention to the locking and syncing mechanisms of our driver,
    we present here, some useful functions to manage the circular buffer, which is
    self-explanatory. Here are two functions to check the buffer is empty or full:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, there are two functions to check how much data or how many spaces are
    available until the end of the buffer''s memory area. They are useful for when
    we have to use functions such as `memmove()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can use function to properly move forward the head or tail pointer
    in such a way that it can restart from the beginning, whenever the end of the
    buffer is reached:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how to do it by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to rewrite our driver''s main structure by adding the `mux` mutex
    (as before), the  `lock` spinlock, the kernel `timer`, and the waitqueue `queue`
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have to initialize them during device allocation in the `chrdev_device_register()`
    function, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, a possible implementation of the `read()` method is shown in the next
    snippet. We start by grabbing the mutex to do the first lock against other processes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Now we are sure that no other process may go beyond this point, but some core
    running in the interrupt context can still do it!
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s why we need the following step to ensure that they are synced with
    the interrupt context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'When we''ve grabbed the lock, we can be sure that we are the only reading process
    here and that we are protected from the interrupt context, too; therefore, we
    can safely proceed to read data from the circular buffer, and then release the
    lock as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Note that we must copy data from the circular buffer to a local buffer and not
    directly into the user space buffer, `buf`, with the `copy_to_user()` function;
    this is because this function may go to sleep, and holding a spinlock while we
    are sleeping is evil!
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the spinlock has been released, we can safely call `copy_to_user()` to
    send data to the user space:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, before releasing the mutex, we must update the circular buffer''s
    `tail` pointer as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Note that since there are only readers in the process context, which are the
    only ones that move the `tail` pointer (or the interrupt handler does it—see the
    following snippet), we can be sure that everything will work well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the end, the interrupt handler (in our case, it''s simulated by a kernel
    timer handler) looks like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The handler''s body is simple: it grabs the lock and then it adds a single
    character to the circular buffer.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that, here, we simply drop data, due to the fact we have a real peripheral;
    in real cases, the driver developer may do whatever is needed to prevent data
    loss, for instance by stopping the peripheral and then signaling this error condition,
    in some way, to the user space!
  prefs: []
  type: TYPE_NORMAL
- en: Also, before exiting, it uses the  `wake_up_interruptible()` function to awake
    possible sleeping processes on the waitqueue.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps are quite self-explanatory. However, in *step 4*, we perform two
    important steps: the first one is to suspend the process if the circular buffer
    is empty and, if not, to grab the lock with the interrupt context since we''re
    going to get access to the circular buffer.'
  prefs: []
  type: TYPE_NORMAL
- en: The check against the `O_NONBLOCK` flag is just to respect the `read()` behavior,
    which says that if the `O_NONBLOCK` flag is used, then it should go ahead, and
    then returns the `EAGAIN` error if no data is available.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the lock can be safely obtained before checking for buffer emptiness,
    due to the fact that if we decide that the buffer is empty, but some new data
    arrive in the meantime and `O_NONBLOCK` is active, we simply return `EAGAIN` (signaling
    to the reading process to redo the operation). If it is not, we go to sleep on
    the waitqueue and then we will be woken by the interrupt handler (see the following
    information). In both cases, our operations are correct.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you wish to test the code, compile the code and insert it in the ESPRESSObin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now our peripheral is enabled (the kernel timer has been enabled in *step 2* in
    the `chrdev_device_register()` function) and some data should already be available
    to be read; in fact, if we do a `read()` on the driver by using the `cat` command
    we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Here, we should notice that since we have defined two devices in the system
    (see the `chapter_04/chrdev/add_chrdev_devices.dts.patch` DTS file used at the
    beginning of this chapter) the  `get_new_char()` function is executed twice per
    second, and that's why we get the sequence `ACE...` instead of `ABC...`.
  prefs: []
  type: TYPE_NORMAL
- en: A good exercise here would be to modify the driver to start the kernel timer
    when the driver is opened the first time, and then stop it when it is released
    the last time. Also, you may try to provide a per device `get_new_char()` function
    to generate the right sequence (ABC...) for each device within the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The corresponding kernel messages are reported as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Here, thanks to *step 3* to *step 7*, the `read()` system call puts to sleep
    the calling process and then returns the new data as soon as it arrives.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, if we wait a while, we see that we get a new character each second
    with the following kernel messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: I left the timings to get an idea about the time when each message is generated.
  prefs: []
  type: TYPE_NORMAL
- en: This behavior is due to *step 8*, where the kernel timer generates new data.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For further information regarding spinlocks and locking a good document, see
    the kernel documentation directory at `linux/Documentation/locking/spinlocks.txt`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting for I/O operations with poll() and select()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will find out how to ask to the kernel to check for us when
    our driver has new data to be read (or it's willing to accept new data to be written),
    and then to wake up the reading (or writing) process without the risk of being
    blocked on the I/O operation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To test our implementation, we can still use the `chrdev_irq.c` driver as before;
    this is because we can use the *new data* event simulated by the kernel timer.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how to do it by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we have to add our new `chrdev_poll()` method in the `struct
    file_operations` of our driver:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the implementation is in the following. We start by passing to the `poll_wait()`
    function, the which is waitqueue of the current device `chrdev->queue`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, before checking that the circular buffer isn''t empty and we can proceed
    to read data from it, we grab the mutex:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Note that grabbing the spinlock, too, is not necessary. This is due to the fact
    that if the buffer is empty we will be informed when new data has arrived by the
    interrupt (the kernel timer in our simulation) handler. This will, in turn, call
    the `wake_up_interruptible(&chrdev->queue)`, which acts on the waitqueue we supplied
    earlier to the `poll_wait()` function. On the other hand, if the buffer is not
    empty, it cannot become empty by the interrupt context and then we cannot have
    any race conditions at all.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As before, if we wish to test the code, we need to realize a proper tool that
    executes our new `poll()` method. When we add it within the driver, we get both
    the `poll()` and `select()` system call support; an example of the `select()`
    usage is reported in the `chrdev_select.c`  file and, in the following, there
    is a snippet in which the `select()` call is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, this program will monitor the standard input channel (named `stdin`)
    of our process and the character device by using the `select()` system call, which,
    in turn, calls our new `poll()` method implemented in *step 2* and *step 3*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s compile the `chrdev_select.c` program by using the next command
    line on our host PC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Note that this command can be executed in the ESPRESSObin by simply removing
    the  `CC=aarch64-linux-gnu-gcc` setting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we try to execute the command on a chrdev device, we should get this
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Of course, we'll have already loaded the `chrdev_irq` driver containing the `poll()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to insert some characters from the standard input, as shown in the
    following, we can see that when there is new data from the device, the process
    can safely do a read on it without blocking, while when there is new data from
    its standard input, the process can do the same, also without blocking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For further information regarding `poll()` or `select()`, a good starting point
    is their man pages (`man 2 poll` and `man 2 select`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing asynchronous notifications with fasync()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will see how we can generate asynchronous `SIGIO` signals
    whenever our driver has new data to be read (or it's willing to accept new data
    from the user space).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As done previously, we can still present our implementation using the `chrdev_irq.c` driver.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how to do it by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we have to add our new `chrdev_fasync()` method in the `struct
    file_operations` of our driver:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to add the `kill_fasync()` call into our (simulated) interrupt
    handler to signal that the signal `SIGIO` can be sent due to the fact that new
    data is ready to be read:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you wish to test the code, you need to realize a proper tool that executes
    all of the steps presented to ask the kernel to receive the `SIGIO` signal. In
    the following, a snippet of the `chrdev_fasync.c` program is reported, which does
    what''s needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This code is needed to ask the kernel to invoke the `fasync()` method implemented
    in *step 2*. Then, whenever new data arrives, thanks to *step 3*, the  `SIGIO` signal is
    sent to our process and the signal handler, `sigio_handler()`, is executed, even
    if the process is suspended, for example, on reading another file descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s compile the `chrdev_fasync.c` program by using the next command
    line on our host PC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Note that this command can be executed in the ESPRESSObin by simply removing
    the  `CC=aarch64-linux-gnu-gcc` setting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we try to execute the command on a chrdev device, we should get the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Of course, we'll have already loaded the `chrdev_irq` driver containing the `fasync()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the process is suspended on a `read()` on the stdin and whenever a signal
    arrives, the signal handler is executed and the new data is read. However, when
    we try to send some characters to the standard input, the process reads them as
    expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For further information regarding the `fasync()` method or the `fcntl()` system
    call, a good starting point is the `man 2 fcntl` man page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
