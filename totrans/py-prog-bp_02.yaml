- en: Creating a Remote-Control Application with Spotify
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spotify is a music streaming service that was developed in Stockholm, Sweden.
    The first version was released back in 2008 and today it doesn't only provide
    music, but video and podcasts as well. Growing rapidly from a startup in Sweden
    to the biggest music service in the world, Spotify has apps running on video game
    consoles and mobile phones, and has integration with many social networks.
  prefs: []
  type: TYPE_NORMAL
- en: The company really has changed how we consume music and has also enabled not
    only well-known artists but small indie artists to share their music with the
    world.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Spotify is also a great platform for developers and provides a really
    nice and well-documented REST API where it's possible to make searches by artists,
    albums, song names, and also create and share playlists.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the second application in this book, we are going to develop a terminal
    application where we can:'
  prefs: []
  type: TYPE_NORMAL
- en: Search artists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search albums
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search tracks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Play music
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from all these features, we are going to implement functions so we can
    control the Spotify application through the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: First, we are going to go through the process of creating a new application
    on Spotify; then, it will be time to develop a small framework that will wrap
    some parts of Spotify's REST API. We are also going to work on implementing different
    types of authentication supported by Spotify, in order to consume its REST API.
  prefs: []
  type: TYPE_NORMAL
- en: When all these core functionalities are in place, we are going to develop a
    terminal user interface using the `curses` package that is distributed with Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to create a `Spotify` app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use `OAuth`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object-oriented programming concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the popular package `Requests` to consume REST APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to design terminal user interfaces using curses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I don't know about you, but I really feel like writing code and listening to
    some good music, so let's get right into it!
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's go ahead and configure our development environment. The first thing we
    need to do is create a new virtual environment, so we can work and install the
    packages that we need without interfering with the global Python installation.
  prefs: []
  type: TYPE_NORMAL
- en: Our application will be called `musicterminal`, so we can create a virtual environment
    with the same name.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new virtual environment, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that you are using Python 3.6 or later, otherwise the applications
    in this book may not work properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'And to activate the virtual environment, you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Perfect! Now that we have our virtual environment set up, we can create the
    project''s directory structure. It should have the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Like the application in the first chapter, we create a project directory (called `musicterminal` here)
    and a sub-directory also named `pytify`, which will contain the framework wrapping
    Spotify's REST API.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the framework directory, we split `auth` into two modules which will
    contain implementations for two authentication flows supported by Spotify—authorization
    code and client credentials. Finally, the `core` module will contain all the methods
    to fetch data from the REST API.
  prefs: []
  type: TYPE_NORMAL
- en: The client directory will contain all the scripts related to the client application
    that we are going to build.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `templates` directory will contain some HTML files that will be
    used when we build a small Flask application to perform Spotify authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create a `requirements.txt` file inside the `musicterminal` directory
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To install the dependencies, just run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/c51878ae-cdd2-4c1c-aba5-a1fb2df3386e.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the output, other packages have been installed in our virtual
    environment. The reason for this is that the packages that our project requires
    also require other packages, so they will also be installed.
  prefs: []
  type: TYPE_NORMAL
- en: Requests were created by Kenneth Reitz [https://www.kennethreitz.org/](https://www.kennethreitz.org/),
    and it is one of the most used and beloved packages in the Python ecosystem. It
    is used by large companies such as Microsoft, Google, Mozilla, Spotify, Twitter,
    and Sony, just to name a few, and it is Pythonic and really straight-forward to
    use.
  prefs: []
  type: TYPE_NORMAL
- en: Check out other projects from Kenneth, especially the `pipenv` project, which
    is an awesome Python packaging tool.
  prefs: []
  type: TYPE_NORMAL
- en: Another module that we are going to use is curses. The curses module is simply
    a wrapper over the curses C functions and it is relatively simpler to use than
    programming in C. If you worked with the curses C library before, the curses module
    in Python should be familiar and easy to learn.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to note is that Python includes the curses module on Linux and Mac;
    however, it is not included by default on Windows. If you are running Windows,
    the curses documentation at [https://docs.python.org/3/howto/curses.html](https://docs.python.org/3/howto/curses.html)
    recommends the  UniCurses package developed by Fredrik Lundh.
  prefs: []
  type: TYPE_NORMAL
- en: Just one more thing before we start coding. You can run into problems when trying
    to import curses; the most common cause is that the `libncurses` are not installed
    in your system. Make sure that you have `libncurses` and `libncurses-dev` installed
    on your system before installing Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using Linux, you will most likely find `libncurses` on the package
    repository of our preferred distribution. In Debian/Ubuntu, you can install it
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Great! Now, we are all set to start implementing our application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Spotify app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we need to do is create a Spotify app; after that, we are going
    to get access keys so we can authenticate and consume the REST API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Head over to [https://beta.developer.spotify.com/dashboard/](https://beta.developer.spotify.com/dashboard/)
    and further down on the page you can find the Login button, and if you don''t
    have an account, you can create a new one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1557b618-e930-456a-bf79-f539bf015194.png)At the time of writing,
    Spotify started changing its developer''s site and was currently in beta, so the
    address to log in and some screenshots may be different.'
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have a Spotify account, you will have to create one first. You
    should be able to create applications if you sign up for the free account, but
    I would recommend signing up for the premium account because it is a great service
    with a great music catalog.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you log in to the Spotify developer website, you will see a page similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d051e689-8f73-40a9-b6bf-7e005dc6fd66.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At the moment, we don''t have any application created (unless you have already
    created one), so go ahead and click on the CREATE AN APP button. A dialog screen
    to create the application will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/50e3e47c-e7b5-484f-8617-203af23e550a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we have three required fields: the application''s name, description,
    and also some checkboxes where you will have to tell Spotify what you''re building.
    The name should be `pytify` and in the description, you can put anything you want,
    but let''s add something like `Application for controlling the Spotify client
    from the terminal`. The type of application we are building will be a website.'
  prefs: []
  type: TYPE_NORMAL
- en: When you are done, click on the NEXT button at the bottom of the dialog screen.
  prefs: []
  type: TYPE_NORMAL
- en: The second step in the application's creation process is to inform Spotify whether
    you are creating a commercial integration. For the purposes of this book, we are
    going to select **NO**; however, if you are going to create an application that
    will monetize, you should definitely select **YES**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next step, the following dialog will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0f932dc3-70ea-4696-91e7-7ddc19dd3cef.png)'
  prefs: []
  type: TYPE_IMG
- en: If you agree with all the conditions, just select all the checkboxes and click
    the SUBMIT button.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the application has been created successfully, you will be redirected to
    the application''s page, which is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ed9c9c57-1548-4c53-8414-9a973dc370df.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on the SHOW CLIENT SECRET link and copy the values of the Client ID and
    the Client Secret. We are going to need these keys to consume Spotify's REST API.
  prefs: []
  type: TYPE_NORMAL
- en: The application's configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make the application more flexible and easy to configure, we are going to
    create a configuration file. This way, we don't need to hardcode the URL and access
    keys; also, if we need to change these settings, changes in the source code will
    not be required.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to create a config file in the YAML format to store information
    that will be used by our application to authenticate, make requests to the Spotify
    RESP API endpoints, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a configuration file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go ahead and create a file called `config.yaml` in the `musicterminal`
    directory with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`client_id` and `client_secret` are the keys that were created for us when
    we created the Spotify application. These keys will be used to get an access token
    that we will have to acquire every time we need to send a new request to Spotify''s
    REST API. Just replace the `<your client ID>` and `<your client secret>` with
    your own keys.'
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that these keys have to be kept in a safe place. Don't share the
    keys with anyone and if you are having your project on sites like GitHub, make
    sure that you are not committing this configuration file with your secret keys.
    What I usually do is add the config file to my `.gitignore` file so it won't be
    source-controlled; otherwise, you can always commit the file as I did by presenting
    it with placeholders instead of the actual keys. That way, it will be easy to
    remember where you need to add the keys.
  prefs: []
  type: TYPE_NORMAL
- en: After the `client_id` and `client_secret` keys, we have the `access_token_url`.
    This is the URL to the API endpoint that we have to perform requests on in order
    to get the access token.
  prefs: []
  type: TYPE_NORMAL
- en: '`auth_url` is the endpoint of Spotify''s Account Service; we will use it when
    we need to acquire or refresh an authorization token.'
  prefs: []
  type: TYPE_NORMAL
- en: The `api_version`, as the name says, specifies Spotify's REST API version. This
    is appended to the URL when performing requests.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we have the `api_url`, which is the base URL for Spotify's REST API
    endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a configuration file reader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before implementing the reader, we are going to add an enumeration to represent
    both kinds of authentication flow that Spotify provides us with. Let''s go ahead
    and create a file called `auth_method.py` in the `musicterminal/pytify/auth` directory
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This will define an enumeration with the `CLIENT_CREDENTIALS` and `AUTHORIZATION_CODE` properties.
    Now. we can use these values in the configuration file. Another thing we need
    to do is create a file called `__init__.py` in the `musicterminal/pytify/auth` directory
    and import the enumeration that we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can continue and create the functions that will read the configuration
    for us. Create a file called `config.py` in the `musicterminal/pytify/core` directory,
    and let''s start by adding some import statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: First, we import the `os` module so we can have access to functions that will
    help us in building the path where the YAML configuration file is located. We
    also import the `yaml` package to read the configuration file and, last but not
    least, we are importing `namedtuple` from the collections module. We will go into
    more detail about what `namedtuple` does later.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we import is the `AuthMethod` enumeration that we just created
    in the `pytify.auth` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need a model representing the configuration file, so we create a named
    tuple called `Config`, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `namedtuple` is not a new feature in Python and has been around since version
    2.6. `namedtuple`''s are tuple-like objects with a name and with fields accessible
    by attribute lookup. It is possible to create `namedtuple` in two different ways;
    let''s start Python REPL and try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This construct gets two arguments; the first argument is the name of the `namedtuple`,
    and the second is an array of `str` elements representing every field in the `namedtuple`.
    It is also possible to specify the fields of the `namedtuple` by passing a string
    with every field name separated by a space, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `namedtuple` constructor also has two keyword-arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Verbose`, which, when set to `True`, displays the definition of the class
    that defines the `namedtuple` on the terminal. Behind the scenes, `namedtuple`''s are
    classes and the `verbose` keyword argument lets us have a sneak peek at how the
    `namedtuple` class is constructed. Let''s see this in practice on the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The other keyword argument is `rename`, which will rename every property in
    the `namedtuple` that has an incorrect naming, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the field `23445` has been automatically renamed to `_3`, which
    is the field position.
  prefs: []
  type: TYPE_NORMAL
- en: To access the `namedtuple` fields, you can use the same syntax when accessing
    properties in a class, using the `namedtuple` —`User` as shown in the preceding
    example. If we would like to access the `lastname` property, we can just write `u.lastname`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the `namedtuple` representing our configuration file, it is
    time to add the function that will perform the work of loading the YAML file and
    returning the `namedtuple`—`Config`. In the same file, let''s implement the `read_config`
    function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `read_config` function starts off by using the `os.path.abspath` function
    to get the absolute path of the current directory, and assigns it to the `current_dir`
    variable. Then, we join the path stored on the `current_dir` variable with the
    name of the file, in this case, the YAML configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: inside the `try` statement, we try to open the file as read-only and set the
    encoding to UTF-8\. In the event this fails, it will print a help message to the
    user saying that it couldn't open the file and will show help describing how the
    YAML configuration file is structured.
  prefs: []
  type: TYPE_NORMAL
- en: If the configuration file can be read successfully, we call the load function
    in the `yaml` module to load and parse the file, and assign the results to the `config` variable.
    We also include an extra item in the config called `base_url`, which is just a
    helper value that contains the concatenated values of `api_url` and `api_version`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The value of the `base_url` will look something like this: [https://api.spotify.com/v1.](https://api.spotify.com/v1)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we create an instance of `Config`. Note how we spread the values in
    the constructor; this is possible because the `namedtuple`—`Config`, has the same
    fields as the object returned by `yaml.load()`. This would be exactly  the same
    as doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The final touch here is to create a `__init__.py` file in the `pytify/core`
    directory and import the `read_config` function that we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Authenticating with Spotify's web API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have the code to load the configuration file for us, we are going
    to start coding the authentication part of our framework. Spotify currently supports
    three kinds of authentication: authorization code, client credentials, and implicitly
    grant. We are going to implement authorization code and client credentials in
    this chapter, and we will start by implementing the client credentials flow, which
    is the easiest to start with.'
  prefs: []
  type: TYPE_NORMAL
- en: The client credentials flow has some disadvantages over the authorization code
    flow because the flow does not include authorization and cannot access the user's
    private data as well as control playback. We will implement and use this flow
    for now, but we will change to authorization code when we start implementing the
    terminal player.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are going to create a file called `authorization.py` in the `musicterminal/pytify/auth`
    directory with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This is going to be the authentication model and it will contain the data we
    get after requesting an access token. In the following list, you can see a description
    of every property:'
  prefs: []
  type: TYPE_NORMAL
- en: '`access_token`: The token that has to be sent together with every request to
    the Web API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`token_type`: The type of the token, which is usually `Bearer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expires_in`: The `access_token` expiration time, which is 3600 seconds (1
    hour)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scope`: The scope is basically the permissions that Spotify''s user granted
    to our application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`refresh_token`: The token that can be used to refresh the `access_token` after
    the expiration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The last touch is to create a `__init__.py` file in the `musicterminal/pytify/auth`
    directory and import the `Authorization` , which is a `namedtuple`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the client credentials flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The client credential flow is quite simple. Let''s break down all the steps
    until we get the `access_token`:'
  prefs: []
  type: TYPE_NORMAL
- en: Our application will request the access token from the Spotify accounts service;
    remember that in our configuration file, we have the `api_access_token`. That's
    the URL we need to send the request to get hold of an access token. There are
    three things that we will need to send the request, the client id, the client
    secret, and the grant type, which in this case is `client_credentials`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Spotify account service will validate that request, check if the keys match
    with the keys of the app that we register to the developer's site, and return an
    access token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, our application has to use this access token in order to consume data from
    the REST APIs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Spotify REST API will return the data we requested.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before we start implementing the functions that will make the authentication
    and get the access token, we can add a custom exception that we will throw if
    we get a bad request (HTTP `400`) from the Spotify account service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a file named `exceptions.py` in the `musicterminal/pytify/core` directory
    with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This class doesn't do much; we simply inherit from `Exception`. We could have
    just thrown a generic exception, but it is a good practice to create your own
    custom exceptions with good names and descriptions when developing frameworks
    and libraries that other developers will make use of.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, instead of throwing an exception like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`raise Exception(''some message'')`'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can be more explicit and throw a `BadRequestError`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '`raise BadRequestError(''some message'')`'
  prefs: []
  type: TYPE_NORMAL
- en: Now, developers using this code can handle this kind of exception properly in
    their code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `__init__.py` file in the `musicterminal/pytify/core` directory and
    add the following import statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Perfect! Now, it is time to add a new file called `auth.py` in the `musicterminal/pytify/auth` directory,
    and the first thing we are going to add to this file is a few imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: I usually put all the imports from standard library modules first and function
    imports in files from my applications last. It is not a requirement, but it is
    just something I think makes the code cleaner and more organized. This way, I
    can easily see which are standard library items and which aren't.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can start adding the functions that will send the request the to the `Spotify`
    account service and return the access token. The first function that we are going
    to add is called `get_auth_key`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The client credential flow requires us to send the `client_id` and the `client_secret`,
    which has to be base 64-encoded. First, we convert the string with the `client_id:client_secret` format
    to bytes. After that, we encode it using base 64 and then decode it, returning
    the string representation of that encoded data so we can send it with the request
    payload.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other function that we are going to implement in the same file is called `_client_credentials`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This function gets an argument as the configuration and uses the `get_auth_key` function
    to pass the `client_id` and the `client_secret` to build a base 64-encoded `auth_key`.
    This will be sent to Spotify's accounts service to request an `access_token`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it is time to prepare the request. First, we set the `Authorization` in
    the request header, and the value will be the `Basic` string followed by the `auth_key.`
    The payload for this request will be `grant_type`, which in this case is `client_credentials`,
    and `json` will be set to `True`, which tells the API that we want the response
    in JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: We use the requests package to make the request to Spotify's account service,
    passing the headers and the data that we configured.
  prefs: []
  type: TYPE_NORMAL
- en: When we get a response, we first decode and load the JSON data into the variable
    content.
  prefs: []
  type: TYPE_NORMAL
- en: If the HTTP status code is `400 (BAD_REQUEST)` we raise a `BadRequestError`;
    otherwise, we get the values for `access_token`, `token_type`, `expires_in`, and
    `scope`, and finally create an `Authorization` tuple and return it.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we are setting `None` to the last parameter when creating an `Authentication`, `namedtuple`.
    The reason for this is that Spotify's account service doesn't return a `refresh_token`
    when the type of authentication is `CLIENT_CREDENTIALS`.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the functions that we have created so far are meant to be private, so the
    last function that we are going to add is the `authenticate` function. This is
    the function that developers will invoke to start the authentication process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This function is pretty straightforward; the function gets an argument as an
    instance of the `Config`, `namedtuple`, which will contain all the data that has
    been read from the configuration file. We then pass the configuration to the `_client_credentials` function,
    which will obtain the `access_token` using the client credentials flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open the `__init__.py` file in the `musicterminal/pytify/auth` directory
    and import the `authenticate` and `get_auth_key` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Nice! Let''s try this out in the Python REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Exactly what we expected! The next step is to start creating the functions that
    will consume Spotify's REST API.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the authorization code flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to implement the authorization code flow, which
    we will be using in the client. We need to use this authentication flow because
    we need to acquire special access rights from the user using our application to
    execute certain actions. For instance, our application will have to be able to
    send a request to Spotify's Web API to play a certain track on the user's active
    device. In order to do that, we need to request `user-modify-playback-state`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps involved in the authorization code flow:'
  prefs: []
  type: TYPE_NORMAL
- en: Our application will request authorization to access data, redirecting the user
    to a login page on Spotify's web page. There, the user can see all the access
    rights that the application requires.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the user approves it, the Spotify account service will send a request to
    the callback URI, sending a code and the state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we get hold of the code, we send a new request passing the `client_id`,
    `client_secret`, `grant_type`, and `code` to acquire the `access_token`. This
    time, it will be different from the client credentials flow; we are going to get
    `scope` and a `refresh_token`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we can normally send requests to the Web API and if the access token has
    expired, we can do another request to refresh the access token and continue performing
    requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With that said, open the `auth.py` file in the `musicterminal/pytify/auth`
    directory and let''s add a few more functions. First, we are going to add a function
    called `_refresh_access_token`; you can add this function after the `get_auth_key`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: It basically does the same thing as the function handling the client credentials
    flow, but this time we send the `refresh_token` and the `grant_type`. We get the
    data from the response's object and create an `Authorization`, `namedtuple`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next function that we are going to implement will make use of the `os`
    module of the standard library, so before we start with the implementation, we
    need to add the following import statement at the top of the `auth.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can go ahead and add a function called `_authorization_code`. You can
    add this function after the `get_auth_key` function with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, we try opening a file called `.pytify` in the `musicterminal` directory.
    This file will contain the `refresh_token` that we are going to use to refresh
    the `access_token` every time we open our application.
  prefs: []
  type: TYPE_NORMAL
- en: After getting the `refresh_token` from the file, we pass it to the `_refresh_access_token` function,
    together with the `auth_key`. If for some reason we are unable to open the file
    or the file does not exist in the `musicterminal` directory, an exception will
    be raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last modification we need to do now is in the `authenticate` function in
    the same file. We are going to add support for both authentication methods; it
    should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will start different authentication methods depending on what we have
    specified in the configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the authentication function has a reference to `AuthMethod`, we need
    to import it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Before we try this type of authentication out, we need to create a small web
    app that will authorize our application for us. We are going to work on that in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Authorizing our application with authorization code flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to make our Spotify terminal client work properly, we need special
    access rights to manipulate the user's playback. We do that by using the authorization
    code and we need to specifically request for the `user-modify-playback-state`
    access right.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few more access rights which would be a good idea to add from the
    beginning if you intend to add more functionalities to this application; for example,
    if you want to be able to manipulate a user's private and public playlists, you
    may want to add the `playlist-modify-private` and `playlist-modify-public` scope.
  prefs: []
  type: TYPE_NORMAL
- en: You might also want to display a list of artists that the user follows on the
    client application, so you need to include `user-follow-read` to the scope as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: It will suffice to request `user-modify-playback-state` access rights for the
    functionalities that we are going to implement in the client application.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is to authorize our application using the authorization code flow.
    We are going to create a simple web application using the framework Flask that
    will define two routes. The `/` root will just render a simple page with a link
    that will redirect us to the Spotify authentication page.
  prefs: []
  type: TYPE_NORMAL
- en: The second root will be `/callback`, which is the endpoint that Spotify will
    call after the users of our application give authorization for our application
    to access their Spotify data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how this is implemented, but first, we need to install Flask. Open
    a terminal and type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'After you have installed it you can even include it in the `requirements.txt`
    file such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The command `pip freeze` will print all the installed packages in the requirements
    format. The output will return more items because it will also contain all the
    dependencies of the packages that we already installed, which is why we grep `Flask`
    and append it to the `requirements.txt` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next time you are going to set up a virtual environment to work on this project
    you can just run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Great! Now, we can start creating the web application. Create a file called
    `spotify_auth.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we add all necessary imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We are going to use the `urlencode` function in the `urllib.parse` module to
    encode the parameters that are going to be appended to the authorize URL. We are
    also going to use the requests to send a request to get the `access_token` after
    the user authorizes our app and use the `json` package to parse the response.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will import Flask-related things, so we can create a Flask application,  `render_template`,
    so we can return a rendered HTML template to the user, and finally the request,
    so we can access the data sent back to us by Spotify's authorization service.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also import some functions that we included in the core and auth submodules
    of the `pytify` module: the `read_config` to load and read the YAML config file
    and the `_authorization_code_request`. The latter will be explained in more detail
    in a short while.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a Flask app and the root route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Great! Starting from the top, we read the configuration file so we can get our
    `client_id` and also the URL for Spotify's authorization service. We build the
    parameters dictionary with the `client_id`; the response type for the authorization
    code flow needs to be set to `code`; the `redirect_uri` is the callback URI which
    Spotify's authorization service will use to send us the authorization code back.
    And finally, since we are going to send instructions to the REST API to play a
    track in the user's active device, the application needs to have `user-modify-playback-state`
    permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we encode all the parameters and build the URL.
  prefs: []
  type: TYPE_NORMAL
- en: The return value will be a rendered HTML. Here, we will use the `render_template`
    function, passing a template as a first argument. By default, Flask will search
    this template in a directory called `templates`. The second argument to this function
    is the model. We are passing a property named `link` and setting the value of
    the variable URL. This way, we can render the link in the HTML template such as: `{{link}}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to add a function to acquire the `access_token` and the
    `refresh_token` for us after we get the authorization code back from Spotify''s
    account service. Create a function called `_authorization_code_request` with the
    following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is pretty much the same as the `_refresh_access_token` function
    that we previously implemented in the `auth.py` file. The only thing to note here
    is that in the options, we are passing the authorization code, and the `grant_type`
    is set to `authorization_code`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define the route that will be called by Spotify's authorization service
    to send back the authorization code.
  prefs: []
  type: TYPE_NORMAL
- en: We start off by reading the configuration, parsing the code from the request
    data, and calling the `_authorization_code_request`, passing the code we have
    just obtained.
  prefs: []
  type: TYPE_NORMAL
- en: This function will send another request using this code, and it will acquire
    an access token that we can use to send requests, along with a refresh token that
    will be stored in a file called `.pytify` in the `musicterminal` directory.
  prefs: []
  type: TYPE_NORMAL
- en: The access token that we obtain to make the requests to the Spotify REST API
    is valid for 3,600 seconds, or 1 hour, which means that within one hour, we can
    use the same access token to make requests. After that, we need to refresh the
    access token. We can do that by using the refresh token that is stored in the
    `.pytify` file.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we send a message to the browser with a success message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to finish our Flask application, we need to add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This tells Flask to run the server on the localhost and use port `3000`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `home` function of our Flash application will, as a response, return a
    templated HTML file called index.html. We haven''t created that file yet, so let''s
    go ahead and create a folder called `musicterminal/templates` and inside the newly
    created directory, add a file called `index.html` with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: There's not much to explain here, but note that we are referencing the link
    property that we passed to the `render_template` function in the home function
    of the Flask application. We are setting the `href` attribute of that anchor element
    to the value of the link.
  prefs: []
  type: TYPE_NORMAL
- en: Great! There is only more thing before we try this out and see if everything
    is working properly. We need to change the settings of our Spotify app; more specifically,
    we need to configure the callback function for the application, so we can receive
    the authorization code.
  prefs: []
  type: TYPE_NORMAL
- en: With that said, head to the [https://beta.developer.spotify.com/dashboard/](https://beta.developer.spotify.com/dashboard/)
    website and log in with your credentials. The dashboard will show the `pytify`
    app that we created at the beginning of this chapter. Click on the app name and
    then click on the EDIT SETTINGS button on the top right of the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scroll down until you find Redirect URIs, and in the text field, enter http://localhost:3000/callback
    and click on the ADD button. Your configuration should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bc6aecdc-cc8d-41c2-b322-0e5104dee0e5.png)'
  prefs: []
  type: TYPE_IMG
- en: Great! Scroll down to the bottom of the dialog and click the SAVE button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to run the Flask application that we just created. On the terminal,
    in the projects root folder, type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see an output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the browser of your choice and go to `http://localhost:3000`; you will
    see a simple page with the link that we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6bc6cdd8-da51-453f-a117-5ac4fe18ee67.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on the link and you will be sent to Spotify's authorization service page.
  prefs: []
  type: TYPE_NORMAL
- en: A dialog will be displayed asking to connect the `Pytify` app to our account.
    Once you authorize it, you will be redirected back to `http://localhost:3000/callback`.
    If everything goes well, you should see the All set! You can close the browser
    window and stop the server message on the page.
  prefs: []
  type: TYPE_NORMAL
- en: Now, just close the browser, and you can stop the Flask application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we now have a file named `.pytify` in the `musicterminal` directory.
    If you look at the contents, you will have an encrypted key similar to this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are ready to start coding the player.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we are going to add some functions that will perform requests to  Spotify's
    Web API to search for artists, get a list of an artist's albums and a list of
    tracks in an album, and play the selected track.
  prefs: []
  type: TYPE_NORMAL
- en: Querying Spotify's web API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have only prepared the terrain and now things start to get a bit
    more interesting. In this section, we are going to create the basic functions
    to send requests to Spotify's Web API; more specifically, we want to be able to
    search for an artist, get an artist's list of albums, get a list of tracks in
    that album, and finally we want to send a request to actually play a given track
    in Spotify's client that is currently active. It can be the browser, a mobile
    phone, Spotify's client, or even video game consoles. So, let's dive right into
    it!
  prefs: []
  type: TYPE_NORMAL
- en: 'To start off, we are going to create a file called `request_type.py` in the
    `musicterminal/pytify/core` directory with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We have gone through enumerations before, so we won't be going into so much
    detail. It suffices to say that we create an enumeration with `GET` and `PUT`
    properties. This will be used to notify the function that performs the requests
    for us that we want to do a `GET` request or a `PUT` request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can create another file named `request.py` in the same `musicterminal/pytify/core` directory,
    and we start by adding a few import statements and defining a function called
    `execute_request`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This function gets a few arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`url_template`: This is the template that will be used to build the URL to
    perform the request; it will use another argument called `params` to build the
    URL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`auth`: Is the `Authorization` object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`params`: It is a `dict` containing all the parameters that will be placed
    into the URL that we are going to perform the request on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`request`: This is the request type; it can be `GET` or `PUT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`payload`: This is the data that may be sent together with the request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we continue to implement the same function, we can add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We read the configuration and add the base URL to the params so it is replaced
    in the `url_template` string. We add `Authorization` in the request headers, together
    with the authentication access token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we check if the request type is `GET`. If so, we execute the `get` function
    from requests; otherwise, we execute the `put` function. The function calls are
    very similar; the only thing that differs here is the data argument. If the response
    returned is empty, we just return the empty string; otherwise, we parse the JSON
    data into the `result` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: After parsing the JSON result, we test whether the status of the request is
    not `200` (OK); in that case, we raise a `BadRequestError`. If it is a successful
    response, we return the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need some functions to help us prepare the parameters that we are going
    to pass to the Web API endpoints. Let''s go ahead and create a file called `parameter.py`
    in the `musicterminal/pytify/core` folder with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We have two functions here, `prepare_params` and `validate_params`. The `validate_params` function
    is used to identify whether there are parameters that are required for a certain
    operation, but they haven't been supplied. The `prepare_params` function first
    calls `validate_params` to make sure that all the parameters have been supplied
    and to also join all the parameters together so they can be easily appended to
    the URL query string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add an enumeration with the types of searches that can be performed.
    Create a file called `search_type.py` in the `musicterminal/pytify/core` directory
    with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This is just a simple enumeration with the four search options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are ready to create the function to perform the search. Create a file
    called `search.py` in the `musicterminal/pytify/core` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We start by explaining the `_search` function. This function gets three criteria
    parameters (what we want to search for), the `Authorization` object, and lastly
    the search type, which is a value in the enumeration that we just created.
  prefs: []
  type: TYPE_NORMAL
- en: The function is quite simple; we start by validating the parameters, then we
    build the URL to make the request, we set the `Authorization` head using our access
    token, and lastly,  we perform the request and return the parsed response.
  prefs: []
  type: TYPE_NORMAL
- en: The other functions `search_artist`, `search_album`, `search_playlist`, and
    `search_track` simply get the same arguments, the criteria and the `Authorization`
    object, and pass it to the `_search` function, but they pass different search
    types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we can search for an artist, we have to get a list of albums. Add
    a file called `artist.py` in the `musicterminal/pytify/core` directory with the
    following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: So, given an `artist_id`, we just define the URL template and parameters that
    we want to make the request and run the `execute_request` function which will
    take care of building the URL, getting and parsing the results for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we want to get a list of the tracks for a given album. Add a file called
    `album.py` in the `musicterminal/pytify/core` directory with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The `get_album_tracks` function is very similar to the `get_artist_albums` function
    that we just implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we want to be able to send an instruction to Spotify''s Web API, telling
    it to play a track that we selected. Add a file called `player.py` in the `musicterminal/pytify/core`
    directory, and add the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is also very similar to the previous ones (`get_artist_albums`
    and `get_album_tracks`), except that it defines a payload. A payload is a dictionary
    containing two items: `uris`, which is a list of tracks that should be added to
    the playback queue, and `offset`, which contains another dictionary with the URIs
    of tracks that should be played first. Since we are interested in only playing
    one song at a time, `uris` and `offset` will contain the same `track_uri`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The final touch here is to import the new function that we implemented. In
    the `__init__.py` file at the `musicterminal/pytify/core` directory, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try the function to search artists in the python REPL to check whether
    everything is working properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The rest of the output has been omitted because it was too long, but now we
    can see that everything is working just as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to start building the terminal player.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have everything we need to authenticate and consume the Spotify
    Rest API, we are going to create a small terminal client where we can search for
    an artist, browse his/her albums, and select a track to play in the Spotify client.
    Note that to use the client, we will have to issue an access token from a premium
    account and the authentication flow we need to use here is the `AUTHENTICATION_CODE`.
  prefs: []
  type: TYPE_NORMAL
- en: We will also need to require from the user of our application the `user-modify-playback-state` scope,
    which will allow us to control playback. With that said, let's get right into
    it!
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to create a new directory to keep all the client's related files
    in it, so go ahead and create a directory named `musicterminal/client`.
  prefs: []
  type: TYPE_NORMAL
- en: Our client will only have three views. In the first view, we are going to get
    the user input and search for an artist. When the artist search is complete, we
    are going to switch to the second view, where a list of albums for the selected
    artist will be presented. In this view, the user will be able to select an album
    on the list using the keyboard's *Up* and *Down* arrow keys and select an album
    by hitting the *Enter* key.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, when an album is selected, we are going to switch to the third and final
    view on our application, where the user will see a list of tracks for the selected
    album. Like the previous view, the user will also be able to select a track using
    the keyboard's *Up* and *Down* arrow key; hitting *Enter *will send a request
    to the Spotify API to play the selected track on the user's available devices.
  prefs: []
  type: TYPE_NORMAL
- en: One approach is to use `curses.panel`. Panels are a kind of window and they
    are very flexible, allowing us to stack, hide and show, and switch panels, go
    back to the top of the stack of panels, and so on, which is perfect for our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s create a file inside the `musicterminal/client` directory called
    `panel.py` with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: All we do here is import the modules and functions we need and create a class
    called `Panel`. We are also importing the `uuid` module so we can create a GUID
    for every new panel.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Panel''s initializer gets two arguments: `title`, which is the title of
    the window, and `dimensions`. The `dimensions` argument is a tuple and follows
    the curses convention. It is composed of `height`, `width`, and the positions `y`
    and `x`, where the panel should start to be drawn.'
  prefs: []
  type: TYPE_NORMAL
- en: We unpack the values of the `dimensions` tuple so it is easier to work with
    and then we use the `newwin` function to create a new window; it will have the
    same dimensions that we passed in the class initializer. Next, we call the box
    function to draw lines on the four sides of the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the window created, it is time to create the panel for the
    window that we just created, calling `curses.panel.new_panel` and passing the
    window. We also set the window title and create a GUID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we set the state of the panel to hidden. Continuing working on this
    class, let''s add a new method called `hide`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This method is quite simple; the only thing that it does is call the `hide`
    method in our panel.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other method that we call in the initializer is `_set_title`; let''s create
    it now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In `_set_title`, we format the title by adding some extra padding on both sides
    of the title string, and then we call the `addstr` method of the window to print
    the title in row zero, column two, and we use the constant `A_REVERSE`, which
    will invert the colors of the string, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ae53d748-1e23-4730-8538-9be17dde71de.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have a method to hide the panel; now, we need a method to show the panel.
    Let''s add the `show` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The `show` method first clears the window and draws the borders around it with
    the `box` method. Then, we set the `title` again. The `cursers.curs_set(0)` call
    will disable the cursor; we do that here because we don't want the cursor visible
    when we are selecting the items in the list. Finally, we call the `show` method
    in the panel.
  prefs: []
  type: TYPE_NORMAL
- en: 'It would also be nice to have a way to know whether the current panel is visible
    or not. So, let''s add a method called `is_visible`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can use the `hidden` method on the panel, which returns `true` if the
    panel is hidden and `false` if the panel is visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last touch in this class is to add the possibility of comparing panels.
    We can achieve this by overriding some special methods; in this case, we want
    to override the `__eq__` method, which will be invoked every time we use the `==`
    operator. Remember that we created an `id` for every panel? We can use that `id`
    now to test the equality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Perfect! Now that we have the `Panel` base class, we are ready to create a special
    implementation of the panel that will contain menus to select items.
  prefs: []
  type: TYPE_NORMAL
- en: Adding menus for albums and track selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we are going to create a file called `menu_item.py` in the `musicterminal/client/`
    directory and we will start by importing some functions that we will need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: We only need to import the `uuid1` function from the `uuid` module because,
    like the panels, we are going to create an `id (GUID)` for every menu item in
    the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding the class and the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The `MenuItem` initializer gets three arguments, the `label` item, the `data`
    which will contain the raw data returned by the Spotify REST API, and a flag stating
    whether the item is currently selected or not.
  prefs: []
  type: TYPE_NORMAL
- en: We start off by creating an id for the item, then we set the values for the
    data and label properties using the argument values that are passed in the class
    initializer.
  prefs: []
  type: TYPE_NORMAL
- en: Every item in the list will have an action that will be executed when the item
    is selected on the list, so we create a function called `return_id` that returns
    a tuple with the item id (not the same as the id that we just created). This is
    the id for the item on Spotify, and the URI is the URI for the item on Spotify.
    The latter will be useful when we select and play a song.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to implement some special methods that will be useful for
    us when performing item comparisons and printing items. The first method that
    we are going to implement is `__eq__`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This will allow us to use the index function to find a specific `MenuItem` in
    a list of `MenuItem` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other special method that we are going to implement is the `__len__` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: It returns the length of the `MenuItem` label and it will be used when measuring
    the length of the menu item labels on the list. Later, when we are building the
    menu, we are going to use the `max` function to get the menu item with the longest
    label, and based on that, we'll add extra padding to the other items so that all
    the items in the list look aligned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last method that we are going to implement is the `__str__` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This is just for convenience when printing menu items; instead of doing `print(menuitem.label)`,
    we can just do `print(menuitem)` and it will invoke `__str__`, which will return
    the value of the `MenuItem` label.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the menu panel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we are going to implement the menu panel, which will be the container class
    that will accommodate all the menu items, handle events, and perform rendering
    on the terminal screen.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start with the implementation of the menu panel, let's add an enumeration
    that will represent different item alignment options, so we can have a bit more
    flexibility on how to display the menu items inside the menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `alignment.py` in the `musicterminal/client` directory
    with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: You should be an enumeration expert if you followed the code in the first chapter.
    There's nothing as complicated here; we define a class `Alignment` inheriting
    from Enum and define two attributes, `LEFT` and `RIGHT`, both with their values
    set to `auto()`, which means that the values will be set automatically for us
    and they will be `1` and `2`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to create the menu. Let's go ahead and create a final class
    called `menu.py` in the `musicterminal/client` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add some imports and the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Menu` class inherits from the `Panel` base class that we just created,
    and the class initializer gets a few arguments: the `title`, the `dimensions`
    (tuple with `height`, `width`, `y` and `x` values) the `alignment` setting which
    is `LEFT` by default, and the `items`. The items argument is a list of `MenuItems`
    objects. This is optional and it will be set to an empty list if no value is specified.'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we do in the class initializer is invoke the `__init__` method
    in the base class. We can do that by using the `super` function. If you remember,
    the `__init__` method on the `Panel` class gets two arguments,  `title` and `dimension`,
    so we pass it to the base class initializer.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we assign the values for the properties `align` and `items`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need a method that returns the currently selected item on the list
    of menu items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This method is very straightforward; the comprehension returns a list of selected
    items, and it will return `None` if no items are selected; otherwise, it returns
    the first item on the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can implement the method that will handle item selection. Let''s add
    another method called `_select`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Here, we start getting the current item selected, and right after that we get
    the index of the item in the list of menu items using the index method from the
    array. This is possible because we implemented the `__eq__` method in the `Panel`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we get to run the function passed as the argument, `expr`, passing the
    value of the currently selected item index.
  prefs: []
  type: TYPE_NORMAL
- en: '`expr` will determine the next current item index. If the new index is less
    than `0`, it means that we reached the top of the menu item''s list, so we don''t
    take any action.'
  prefs: []
  type: TYPE_NORMAL
- en: If the new index is greater than the current index, and the new index is greater
    than or equal to the number of menu items on the list, then we have reached the
    bottom of the list, so no action is required at this point and we can continue
    selecting the same item.
  prefs: []
  type: TYPE_NORMAL
- en: However, if we haven't reached to top or the bottom of the list, we need to
    swap the selected items. To do this, we set the selected property on the current
    item to `False` and set the selected property of the next item to `True`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `_select` method is a `private` method, and it is not intended to be called
    externally, so we define two methods—`next` and `previous`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The next method will invoke the `_select` method and pass a lambda expression
    that will receive an index and add one to it, and the previous method will do
    the same thing, but instead of increasing the index by `1`, it will subtract it.
    So, in the `_select` method when we call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'We are calling either `lambda index: index + 1` or `lambda index: index + 1`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Great! Now, we are going to add a method that will be responsible for formatting
    menu items before we render them on the screen. Create a method called `_initialize_items`,
    which is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: First, we get the menu item that has the largest label; we can do that by using
    the built-in function `max` and passing the `items`, and, as the key, another
    built-in function called `len`. This will work because we implemented the special
    method `__len__` in the menu item.
  prefs: []
  type: TYPE_NORMAL
- en: After discovering the menu item with the largest label, we loop through the
    items of the list, adding padding on the `LEFT` or `RIGHT`, depending on the alignment
    options. Finally, if there's no menu item in the list with the selected flag set
    to `True`, we select the first item as selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also want to provide a method called `init` that will initialize the items
    on the list for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: We also need to handle keyboard events so we can perform a few actions when
    the user specifically presses the *Up* and *Down* arrow keys,  as well as *Enter*.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to define a few constants at the top of the file. You can add
    these constants between the imports and the class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go ahead and include a method called `handle_events`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: This method is pretty simple; it gets a `key` argument, and if the key is equal
    to `curses.KEY_UP`, then we call the `previous` method. If the key is equal to
    `curses.KEY_DOWN`, then we call the `next` method. Now, if the key is `ENTER`,
    then we get the selected item and return its action. The action is a function
    that will execute another function; in our case, we might be selecting an artist
    or song on a list or executing a function that will play a music track.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to testing whether the `key` is `curses.KEY_ENTER`, we also need
    to check whether the key is a new line `\n` or a carriage return `\r`. This is
    necessary because the code for the *Enter* key can differ depending on the configuration
    of the terminal the application is running in.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to implement the `__iter__` method, which will make our `Menu`
    class behave like an iterable object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The last method of this class is the `update` method. This method will do the
    actual work of rendering the menu items and refreshing the window screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: First, we set the `x` and `y` coordinates to `2`, so the menu on this window
    will start at line `2` and column `2`. We loop through the menu items and call
    the `addstr` method to print the item on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `addstr` method gets a `y` position, the `x` position, the string that
    will be written on the screen, in our case `item.label`, and the last argument
    is the `style`. If the item is selected, we want to show it highlighted; otherwise,
    it will display with normal colors. The following screenshot illustrates what
    the rendered list will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/270dbea3-ceb9-4922-8216-c30ab85c7688.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating the DataManager class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have implemented the base functionality to authenticate and consume data
    from the Spotify REST API, but now we need to create a class that will make use
    of this functionality so we get the information that we need to be displayed in
    the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our Spotify terminal client will perform the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Search an artist by name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List the artist's albums
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List the album's tracks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request a track to be played
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first thing we are going to add is a custom exception that we can raise,
    and no result is returned from the Spotify REST API. Create a new file called
    `empty_results_error.py` in the `musicterminal/client` directory with the following
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'To make it easier for us, let''s create a `DataManager` class that will encapsulate
    all these functionalities for us. Create a file called `data_manager.py` in the
    `musicterminal/client` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: First, we import the `MenuItem,` so we can return `MenuItem` objects with the
    request's results. After that, we import functions from the `pytify` module to
    search artists, get albums, list albums tracks, and play tracks. Also, in the
    `pytify` module, we import the `read_config` function and authenticate it.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we import the custom exception that we just created, `EmptyResultsError`.
  prefs: []
  type: TYPE_NORMAL
- en: The initializer of the `DataManager` class starts reading the configuration
    and performs the authentication. The authentication information will be stored
    in the `_auth` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, we are going to add a method to search for artists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The `_search_artist` method will get `criteria` as an argument and call the
    `search_artist` function from the `python.core` module. If no items are returned,
    it will raise an `EmptyResultsError`; otherwise, it will return the first match.
  prefs: []
  type: TYPE_NORMAL
- en: Before we continue creating the methods that will fetch the albums and the tracks,
    we need two utility methods to format the labels of the `MenuItem` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one will format the artist label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Here, the label will be the name of the item and the type, which can be an album,
    single, EP, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'And the second one formats the name of the tracks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we extract the duration of the track in milliseconds, convert is to `minutes:
    seconds`, and format the label with the name of the track and its duration between
    square brackets.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, let''s create a method to get the artist''s albums:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The `get_artist_albums` method gets two arguments, the `artist_id` and the `max_item`,
    which is the maximum number of albums that will be returned by the method. By
    default, it is set to `20`.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we do here is use the `get_artist_albums` method from the `pytify.core`
    module, passing the `artist_id` and the `authentication` objects, and we get the
    item's attribute from the results, assigning it to the variable albums. If the
    `albums` variable is empty, it will raise an `EmptyResultsError`; otherwise, it
    will create a list of `MenuItem` objects for every album.
  prefs: []
  type: TYPE_NORMAL
- en: 'And we can add another method for the tracks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The `get_album_tracklist` method gets `album_id` as an argument and the first
    thing we do is get the tracks for that album using the `get_album_tracks` function
    in the `pytify.core` module. If no result is returned, we raise an `EmptyResultsError`;
    otherwise, we build a list of `MenuItem` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last method is the one that will actually send a command to the Spotify
    REST API to play a track:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Very straightforward. Here, we just get `track_uri` as an argument and pass
    it down the `play` function in the `pytify.core` module, along with the `authentication`
    object. That will make the track start playing on the available device; it can
    be a mobile phone, Spotify's client on your computer, the Spotify web player,
    or even your games console.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, let's put together everything we have built and run the Spotify player
    terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Time to listen to music!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we have all the pieces we need to start building the terminal player. We
    have the `pytify` module, which provides a wrapper around the Spotify RESP API
    and will allow us to search for artists, albums, tracks, and even control the
    Spotify client running on a mobile phone or a computer.
  prefs: []
  type: TYPE_NORMAL
- en: The `pytify` module also provides two different types of authentication—client
    credentials and authorization code—and in the previous sections, we implemented
    all the infrastructures necessary to build an application using curses. So, let's
    glue all the parts together and listen to some good music.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the `musicterminal` directory, create a file called `app.py`; this is going
    to be the entry point for our application. We start by adding import statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: We need to import `curses` and `curses.panel` of course, and this time, we are
    also importing `wrapper`. This is used for debugging purposes. When developing
    curses applications, they are extremely hard to debug, and when something goes
    wrong and some exception is thrown, the terminal will not go back to its original
    state.
  prefs: []
  type: TYPE_NORMAL
- en: The wrapper takes a `callable` and it returns the terminal original state when
    the `callable` function returns.
  prefs: []
  type: TYPE_NORMAL
- en: The wrapper will run the callable within a try-catch block and it will restore
    the terminal in case something goes wrong. It is great for us while developing
    the application. Let's use the wrapper so we can see any kind of problem that
    may occur.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to import two new functions, `Textbox` and `rectangle`. We are
    going to use those to create a search box where the users can search for their
    favorite artist.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we import the `Menu` class and the `DataManager` that we implemented
    in the previous sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start implementing some helper functions; the first one is `show_search_screen`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: It gets an instance of the window as an argument, so we can print text and add
    our textbox on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The `curses.curs_set` function turns the cursor on and off; when set to `1`,
    the cursor will be visible on the screen. We want that in the search screen so
    the user knows where he/she can start typing the search criteria. Then, we print
    help text so the user knows that the name of the artist should be entered; then,
    to finish, they can press *Ctrl* + *G* or just *Enter* to perform the search.
  prefs: []
  type: TYPE_NORMAL
- en: To create the textbox, we create a new small window with a height that equals
    `1` and a width that equals `40`, and it starts at line `3`, column `3` of the
    terminal screen. After that, we use the `rectangle` function to draw a rectangle
    around the new window and we refresh the screen so the changes we made take effect.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we create the `Textbox` object, passing the window that we just created,
    and call the method `edit`, which will set the box to the textbox and enter edit
    mode. That will `stop` the application and let the user enter some text in the
    textbox; it will exit when the user clicks *Ctrl* + *G* or *Enter*.
  prefs: []
  type: TYPE_NORMAL
- en: When the user is done editing the text, we call the `gather` method that will
    collect the data entered by the user and assign it to the `criteria` variable,
    and finally, we return `criteria`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need a function to clean the screen easily Let''s create another function
    called `clean_screen`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! Now, we can start with the main entry point of our application, and
    create a function called main with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break this down into its constituent parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Here, we do some initialization. Usually, curses don't register the key immediately.
    When it is typed, this is called buffered mode; the user has to type something
    and then hit *Enter.* In our application, we don't want this behavior; we want
    the key to be registered right after the user types it. This is what `cbreak`
    does; it turns off the curses buffered mode.
  prefs: []
  type: TYPE_NORMAL
- en: We also use the `noecho` function to be able the read the keys and to control
    when we want to show them on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The last curses setup we do is to turn on the keypad so curses will do the job
    of reading and processing the keys accordingly, and returning constant values
    representing the key that has been pressed. This is much cleaner and easy to read
    than trying to handle it yourself and test key code numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create an instance of the `DataManager` class so we can get the data we
    need to be displayed on the menus and perform authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we create the search dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: We call the `show_search_screen` function, passing the instance of the window;
    it will render the search field on the screen and return the results to us. When
    the user is done typing, the user input will be stored in the `criteria` variable.
  prefs: []
  type: TYPE_NORMAL
- en: After we get the criteria, we call `get_artist_albums`, which will first search
    an artist and then get a list of the artist's albums and return a list of `MenuItem`
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the list of albums is returned, we can create the other panels with the
    menus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Here, we get the height and the width of the main window so we can create panels
    with the same dimensions.  `albums_panel` will display the albums and `tracks_panel`
    will display the tracks; as I mentioned before, it will have the same dimensions
    as the main window and both panels will start at row `0`, column `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we call `clear_screen` to prepare the window to render the menu
    window with the albums:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: We first set the item's properties with the results of the albums search. We
    also call `init` on the panel, which will internally run `_initialize_items`,
    format the labels and set the currently selected item. We also call the `update`
    method, which will do the actual work of printing the menu items in the window;
    lastly, we show how to set the panel to visible.
  prefs: []
  type: TYPE_NORMAL
- en: We also define the `current_panel` variable, which will hold the instance of
    the panel that is currently being displayed on the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: The `is_running` flag is set to `True` and it will be used in the application's
    main loop. We will set it to `False` when we want to stop the application's execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we enter the main loop of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'To start off, we call `doupdate` and `update_panels`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`doupdate`: Curses keeps two data structures representing the physical screen
    (the one you see on the terminal screen) and a virtual screen (the one keeping
    the next updated). `doupdate` updates the physical screen so it matches the virtual
    screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update_panels`: Updates the virtual screen after changes in the panel stack,
    changes like hiding, show panels, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After updating the screen, we wait until a key is pressed using the `getch`
    function, and assign the key pressed value to the `key` variable. The `key` variable
    is then passed to the current panel's `handle_events` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remember the implementation of `handle_events` in the `Menu` class,
    it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: It handles `KEY_DOWN`, `KEY_UP`, and `KEY_ENTER`. If the key is `KEY_UP` or
    `KEY_DOWN`, it will just update the position in the menu and set a newly selected
    item, and that will be updated on the screen on the next loop interaction. If
    the key is `KEY_ENTER`, we get the selected item and return its action function.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that, for both panels, it will return a function that, when executed,
    will return a tuple containing the item id and the item URI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on, we handle if the action is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: If the `handle_events` method of the current panel returned a callable `action`,
    we execute it and get the result. Then, we check if the active panel is the first
    panel (with the albums). In this case, we need to get a list of tracks for the
    selected album, so we call `get_album_tracklist` in the `DataManager` instance.
  prefs: []
  type: TYPE_NORMAL
- en: We hide the `current_panel,` switch the current panel to the second panel (the
    tracks panel), set the items property with the list of tracks, call the init method
    so the items are formatted properly and a first item in the list is set as selected,
    and finally we call `show` so the track's panel is visible.
  prefs: []
  type: TYPE_NORMAL
- en: In the event the current panel is the `tracks_panel`, we get the action results
    and invoke play on the `DataManager`, passing the track URI. It will request the
    selected track to be played on the device you have active on Spotify.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we want a way of returning to the search screen. We do that when the user
    hits the *F12* function `key`*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: For the `if` statement above, test if the user pressed the  *F12* function `key`;
    in this case, we want to return to the search screen so that the user can search
    for a new artist. When the *F12* key is pressed, we hide the current panel. Then,
    we call the `show_search_screen` function so the search screen is rendered and
    the textbox will enter in edit mode, waiting for the user's input.
  prefs: []
  type: TYPE_NORMAL
- en: When the user is done typing and hits *Ctrl*+ *G* or *Enter*, we search the
    artist. Then, we get the artist's albums and we show the panel with a list of
    albums.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last event that we want to handle is when the user press either the `q`
    or `Q` key, which sets the `is_running` variable to `False` and the application
    closes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we call `update` on the current panel, so we redraw the items to reflect
    the changes on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Outside the main function, we have the code snippet where we actually execute
    the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: We surround it with a `try` catch so if the user presses *Ctrl* + *C,* a `KeyboardInterrupt`
    exception will be raised and we just finish the application gracefully without
    throwing the exception on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: We are all done! Let's try it out!
  prefs: []
  type: TYPE_NORMAL
- en: Open a terminal and type the command—`python app.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first screen you will see is the search screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/526e4ad4-49d1-401d-8c0c-d58064a728fd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let me search for one of my favorite artists:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fdc3a925-18ee-43ea-b8e1-65fe12d2ae54.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After pressing *Enter* or *Ctrl* + *G,* you should see a list of albums:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/131e336d-88eb-4ca7-a629-e2670ede056f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, you can use the arrow keys (*Up* and *Down*) to navigate albums, and
    press *Enter* to select an album. Then, you will see the screen showing all the
    tracks of the selected album:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/71f792f1-dc7c-4300-a96e-3983f7576669.png)'
  prefs: []
  type: TYPE_IMG
- en: If this screen is the same, you can use the arrow keys (*Up* and *Down*) to
    select the track, and *Enter* will send a request to play the song on the device
    you have Spotify active on.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have covered a lot of ground in this chapter; we started by creating an
    application on Spotify and learning our way around its developer''s website. Then,
    we learned how to implement the two types of authentication flow that Spotify
    supports: the client credentials flow and the authorization flow.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we also implemented a whole module wrapper with some of the
    functionality available from Spotify's REST API.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we implemented a simple terminal client where users can search for artists,
    browse the artist's albums and tracks, and finally play a song in the user's active
    device, which can be a computer, mobile phone, or even a video game console.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to create a desktop application that shows
    the number of votes given through Twitter hashtags.
  prefs: []
  type: TYPE_NORMAL
