- en: '8: Containerizing an app'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docker is all about taking applications and running them in containers.
  prefs: []
  type: TYPE_NORMAL
- en: The process of taking an application and configuring it to run as a container
    is called “containerizing”. Sometimes we call it “Dockerizing”.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we’ll walk through the process of containerizing a simple Linux
    web application. If you don’t have a Linux Docker environment to follow along
    with, you can use *Play With Docker* for free. Just point your web browser to
    https://play-with-docker.com and spin up some Linux Docker nodes. It’s my favourite
    way to spin up Docker and do testing!
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll split this chapter into the usual three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The TLDR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The deep dive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s containerize an app!
  prefs: []
  type: TYPE_NORMAL
- en: Containerizing an app - The TLDR
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Containers are all about apps! In particular, they’re about making apps simple
    to **build**, **ship**, and **run**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process of containerizing an app looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with your application code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a *Dockerfile* that describes your app, its dependencies, and how to
    run it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Feed this *Dockerfile* into the `docker image build` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sit back while Docker builds your application into a Docker image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once your app is containerized (made into a Docker image), you’re ready to ship
    it and run it as a container.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 shows the process in picture form.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 - Basic flow of containerizing an app](images/figure8-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 - Basic flow of containerizing an app
  prefs: []
  type: TYPE_NORMAL
- en: Containerizing an app - The deep dive
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll break up this Deep Dive section of the chapter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Containerize a single-container app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving to Production with multi-stage builds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A few best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containerize a single-container app
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The rest of this chapter will walk you through the process of containerizing
    a simple single-container Node.js web app. The process is the same for Windows,
    and future editions of the book will include a Windows example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll complete the following high-level steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the app code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspect the Dockerfile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containerize the app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test the app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look a bit closer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Move to production with **Multi-stage Builds**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A few best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although we’ll be working with a single-container app in this chapter, we’ll
    move on to a multi-container app in the next chapter on Docker Compose. After
    that, we’ll move on to an even more complicated app in the chapter on Docker Stacks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the application code
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The application used in this example can be cloned form GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: https://github.com/nigelpoulton/psweb.git
  prefs: []
  type: TYPE_NORMAL
- en: Clone the sample app from GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`The clone operation creates a new directory called `psweb`. Change directory
    into `psweb` and list its contents.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`This directory contains all of the application source code, as well as subdirectories
    for views and unit tests. Feel free to look at the files - the app is extremely
    simple. We won’t be using the unit tests in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the app code, let’s look at its Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting the Dockerfile
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Notice that the repo has a file called **Dockerfile**. This is the file that
    describes the application and tells Docker how to build it into an image.
  prefs: []
  type: TYPE_NORMAL
- en: The directory containing the application is referred to as the *build context*.
    It’s a common practice to keep your Dockerfile in the root directory of the *build
    context*. It’s also important that **Dockerfile** starts with a capital “**D**”
    and is all one word. “dockerfile” and “Docker file” are not valid.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the contents of the Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`The Dockerfile has two main purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: To describe the application
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To tell Docker how to containerize the application (create an image with the
    app inside)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do not underestimate the impact of the Dockerfile as a from of documentation!
    It has the ability to help bridge the gap between development and operations!
    It also has the power to speed up on-boarding of new developers etc. This is because
    the file accurately describes the application and its dependencies in an easy-to-read
    format. As such, it should be treated as code, and checked into a source control
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'At a high-level, the example Dockerfile says: Start with the `alpine` image,
    add “nigelpoulton@hotmail.com” as the maintainer, install Node.js and NPM, copy
    in the application code, set the working directory, install dependencies, document
    the app’s network port, and set `app.js` as the default application to run.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at it in a bit more detail.
  prefs: []
  type: TYPE_NORMAL
- en: All Dockerfiles start with the `FROM` instruction. This will be the base layer
    of the image, and the rest of the app will be added on top as additional layers.
    This particular application is a Linux app, so it’s important that the FROM instruction
    refers to a Linux-based image. If you are containerizing a Windows application,
    you will need to specify the appropriate Windows base image - such as `microsoft/aspnetcore-build`.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the image looks like Figure 8.2 .
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2](images/figure8-2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2
  prefs: []
  type: TYPE_NORMAL
- en: Next, the Dockerfile creates a LABEL that specifies “nigelpoulton@hotmail.com”
    as the maintainer of the image. Labels are simple key-value pairs and are an excellent
    way of adding custom metadata to an image. It’s considered a best practice to
    list a maintainer of an image so that other potential users have a point of contact
    when working with it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** I will not be maintaining this image. I’m including the label to
    show you how to use labels as well as showing you a best practice.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `RUN apk add --update nodejs nodejs-npm` instruction uses the Alpine `apk`
    package manager to install `nodejs` and `nodejs-npm` into the image. The RUN instruction
    installs these packages as a new image layer on top of the `alpine` base image
    created by the `FROM alpine` instruction. The image now looks like Figure 8.3.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3](images/Figure8-3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3
  prefs: []
  type: TYPE_NORMAL
- en: The `COPY . /src` instruction copies in the app files from the *build context*.
    It copies these files into the image as a new layer. The image now has three layers
    as shown in Figure 8.4.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4](images/figure8-4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4
  prefs: []
  type: TYPE_NORMAL
- en: Next, the Dockerfile uses the `WORKDIR` instruction to set the working directory
    for the rest of the instructions in the file. This directory is relative to the
    image, and the info is added as metadata to the image config and not as a new
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: Then the `RUN npm install` instruction uses `npm` to install application dependencies
    listed in the `package.json` file in the build context. It runs within the context
    of the `WORKDIR` set in the previous instruction, and installs the dependencies
    as a new layer in the image. The image now has four layers as shown in Figure
    8.5.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5](images/figure8-5.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5
  prefs: []
  type: TYPE_NORMAL
- en: The application exposes a web service on TCP port 8080, so the Dockerfile documents
    this with the `EXPOSE 8080` instruction. This is added as image metadata and not
    an image layer.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `ENTRYPOINT` instruction is used to set the main application that
    the image (container) should run. This is also added as metadata and not an image
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: Containerize the app/build the image
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now that we understand how it works, let’s build it!
  prefs: []
  type: TYPE_NORMAL
- en: The following command will build a new image called `web:latest`. The period
    (`.`) at the end of the command tells Docker to use the shell’s current working
    directory as the *build context*.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to include the period (.) at the end of the command, and be sure to
    run the command from the `psweb` directory that contains the Dockerfile and application
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`Check that the image exists in your Docker host’s local repository.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`Congratulations, the app is containerized!'
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `docker image inspect web:latest` command to verify the configuration
    of the image. It will list all of the settings that were configured from the Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing images
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Once you’ve created an image, it’s a good idea to store it in an image registry
    to keep it safe and make it available to others. Docker Hub is the most common
    public image registry, and it’s the default push location for `docker image push`
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: In order to push an image to Docker Hub, you need to login with your Docker
    ID. You also need tag the image appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s log in to Docker Hub and push the newly created image.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example’s you will need to substitute my Docker ID with your
    own. So any time you see “nigelpoulton”, swap it out for your Docker ID.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`Before you can push an image, you need to tag it in a special way. This is
    because Docker needs all of the following information when pushing an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Registry`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Repository`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Tag`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker is opinionated, so you don’t need to specify values for `Registry` and
    `Tag`. If you don’t specify values, Docker will assume `Registry=docker.io` and
    `Tag=latest`. However, Docker does not have a default value for the Repository
    value, it gets this from the “REPOSITORY” value of the image it is pushing. This
    might be confusing, so let’s take a closer look at the one from our example.
  prefs: []
  type: TYPE_NORMAL
- en: The previous `docker image ls` output shows our image with `web` as the repository
    name. This means a `docker image push` will try and push the image to `docker.io/web:latest`.
    However, I don’t have access to the `web` repository, all of my images have to
    sit within the `nigelpoulton` second-level namespace. This means we need to re-tag
    the image to include my Docker ID.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`The format of the command is `docker image tag <current-tag> <new-tag>` and
    it adds an additional tag, it does not overwrite the original.'
  prefs: []
  type: TYPE_NORMAL
- en: Another image listing shows the image now has two tags, one of which includes
    my Docker ID.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`Now we can push it to Docker Hub.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`Figure 8.6 shows how Docker determined the push location.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6](images/figure8-6.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6
  prefs: []
  type: TYPE_NORMAL
- en: You will not be able to push images to repos in my Docker Hub namespace, you
    will have to use your own.
  prefs: []
  type: TYPE_NORMAL
- en: All of the examples in the rest of the chapter will use the shorter of the two
    tags (`web:latest`).
  prefs: []
  type: TYPE_NORMAL
- en: Run the app
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The application that we’ve containerized is a simple web server that listens
    on TCP port 8080\. You can verify this in the `app.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: The following command will start a new container called `c1` based on the `web:latest`
    image we just created. It maps port `80` on the Docker host, to port `8080` inside
    the container. This means that you will be able to point a web browser at the
    DNS name or IP address of the Docker host and access the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** If your host is already running a service on port 80, you can specify
    a different port as part of the `docker container run` command. For example, to
    map the app to port 5000 on the Docker host, use the `-p 5000:8080` flag.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`The `-d` flag runs the container in the background, and the `-p 80:8080` flag
    maps port 80 on the host to port 8080 inside the running container.'
  prefs: []
  type: TYPE_NORMAL
- en: Check that the container is running and verify the port mapping.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`The output above is snipped for readability, but shows that the app container
    is running. Note that port 80 is mapped, on all host interfaces (`0.0.0.0:80`),
    to port 8080 in the container.'
  prefs: []
  type: TYPE_NORMAL
- en: Test the app
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Open a web browser and point it to the DNS name or IP address of the host that
    the container is running on. You will see the web page shown in Figure .
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7](images/figure8-7.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7
  prefs: []
  type: TYPE_NORMAL
- en: 'If the test does not work, try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that the container is up and running with the `docker container ls`
    command. The container name is `c1` and you should see the port mapping as `0.0.0.0:80->8080/tcp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check that the firewall and other network security settings are not blocking
    traffic to port 80 on the Docker host.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Congratulations, the application is containerized and running!
  prefs: []
  type: TYPE_NORMAL
- en: Looking a bit closer
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now that the application is containerized, let’s take a closer look at how some
    of the machinery works.
  prefs: []
  type: TYPE_NORMAL
- en: Comment lines in a Dockerfile start with the `#` character.
  prefs: []
  type: TYPE_NORMAL
- en: All non-comment lines are **Instructions**. Instructions take the format `INSTRUCTION
    argument`. Instruction names are not case sensitive, but it is normal practice
    to write them in UPPERCASE. This makes reading the Dockerfile easier.
  prefs: []
  type: TYPE_NORMAL
- en: The `docker image build` command parses the Dockerfile one-line-at-a-time starting
    from the top.
  prefs: []
  type: TYPE_NORMAL
- en: Some instructions create new layers, whereas others just add metadata to the
    image.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of instructions that create new layers are `FROM`, `RUN`, and `COPY`.
    Examples of instructions that create metadata include `EXPOSE`, `WORKDIR`, `ENV`,
    and `ENTRYPOINT`. The basic premise is this - if an instruction is adding *content*
    such as files and programs to the image, it will create a new layer. If it is
    adding instructions on how to build the image and run the application, it will
    create metadata.
  prefs: []
  type: TYPE_NORMAL
- en: You can view the instructions that were used to build the image with the `docker
    image history command`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`Two things from the output above are worth noting.'
  prefs: []
  type: TYPE_NORMAL
- en: First. Each line corresponds to an instruction in the Dockerfile (starting from
    the bottom and working up). The `CREATED BY` column even lists the exact Dockerfile
    instruction that was executed.
  prefs: []
  type: TYPE_NORMAL
- en: Second. Only 4 of the lines displayed in the output create new layers (the ones
    with non-zero values in the `SIZE` column). These correspond to the `FROM`, `RUN`,
    and `COPY` instructions in the Dockerfile. Although the other instructions might
    look like they create layers, they actually create metadata instead of layers.
    The reason that the `docker image history` output makes it looks like all instructions
    create layers is an artefact of the way Docker builds and image layering used
    to work.
  prefs: []
  type: TYPE_NORMAL
- en: Use the `docker image inspect` command to confirm that only 4 layers were created.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`It is considered a good practice to use images from official repositories
    with the `FROM` instruction. This is because they tend to follow best practices
    and be relatively free from known vulnerabilities. It is also a good idea to start
    from (`FROM`) small images as this reduces potential vulnerabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can view the output of the `docker image build` command to see the general
    process for building an image. As the following snippet shows, the basic process
    is: `spin up a temporary container` > `run the Dockerfile instruction inside of
    that container` > `save the results as a new image layer` > `remove the temporary
    container`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`#### Moving to production with **Multi-stage Builds**'
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to Docker images, big is bad!
  prefs: []
  type: TYPE_NORMAL
- en: Big means slow. Big means hard to work with. And big means a more potential
    vulnerabilities and possibly a bigger attack surface!
  prefs: []
  type: TYPE_NORMAL
- en: For these reasons, Docker images should be small. The aim of the game is to
    only ship production images containing the stuff **needed** to run your app in
    production.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is… keeping images small *was* hard work.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the way you write your Dockerfiles has a huge impact on the size
    of your images. A common example is that every `RUN` instruction adds a new layer.
    As a result, it’s usually considered a best practice to include multiple commands
    as part of a single RUN instruction - all glued together with double-ampersands
    (&&) and backslash (`\`) line-breaks. While this isn’t rocket science, it requires
    time and discipline.
  prefs: []
  type: TYPE_NORMAL
- en: Another issue is that we don’t clean up after ourselves. We’ll RUN a command
    against an image that pulls some build-time tools, and we’ll leave all those tools
    in the image when we ship it to production. Not ideal!
  prefs: []
  type: TYPE_NORMAL
- en: There were ways around this - most notably the *builder pattern*. But most of
    these required discipline and added complexity.
  prefs: []
  type: TYPE_NORMAL
- en: The builder pattern required you to have at least two Dockerfiles - one for
    development and one for production. You’d write your Dockerfile.dev to start from
    a large base image, pull in any additional build tools required, and build your
    app. You’d then build an image from the Dockerfile.dev and create a container
    from it. You’d then use your Dockerfile.prod to build a new image from a smaller
    base image, and copy over just the application stuff from the container you just
    created from the build image. And everything needed to be glued together with
    a script.
  prefs: []
  type: TYPE_NORMAL
- en: This approach was doable, but at the expense of complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-stage builds to the rescue!
  prefs: []
  type: TYPE_NORMAL
- en: Multi-stage builds are all about optimizing builds without adding complexity.
    And they deliver on the promise!
  prefs: []
  type: TYPE_NORMAL
- en: Here’s the high-level…
  prefs: []
  type: TYPE_NORMAL
- en: With multi-stage builds, we have a single Dockerfile containing multiple FROM
    instructions. Each FROM instruction is a new **build stage** that can easily COPY
    artefacts from previous **stages**.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at an example!
  prefs: []
  type: TYPE_NORMAL
- en: This example app is available at https://github.com/nigelpoulton/atsea-sample-shop-app.git
    and the Dockerfile is in the `app` directory. It’s a Linux-based application so,
    will only work on a Linux Docker host.
  prefs: []
  type: TYPE_NORMAL
- en: The repo is a fork of `dockersamples/atsea-sample-shop-app` and I’ve forked
    it in case the upstream repo is removed or deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Dockerfile is shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`The first thing to note is that the Dockerfile has three `FROM` instructions.
    Each of these constitutes a distinct **build stage**. Internally they’re numbered
    form the top starting at 0\. However, we’ve also given each stage a friendly name.'
  prefs: []
  type: TYPE_NORMAL
- en: Stage 0 is called `storefront`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stage 1 is called `appserver`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stage 2 is called `production`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `storefront` stage pulls the `node:latest` image which is over 600MB in
    size. It sets the working directory, copies in some app code, and uses two RUN
    instructions to perform some `npm` magic. This adds three layers and considerable
    size. The result is an even bigger image containing lots of build stuff and not
    very much app code.
  prefs: []
  type: TYPE_NORMAL
- en: The `appserver` stage pulls the `maven:latest` image which is over 700MB in
    size. It adds four layers of content via two COPY instructions and two RUN instructions.
    This produces another very large image with lots of build tools and very little
    actual production code.
  prefs: []
  type: TYPE_NORMAL
- en: The `production` stage starts by pulling the `java:8-jdk-alpine` image. This
    image is approximately 150MB - considerably smaller than the node and maven images
    used by the previous build stages. It adds a user, sets the working directory,
    and copies in some app code from the image produced by the `storefront` stage.
    After that, it sets a different working directory and copies in the application
    code form the image produced by the `appserver` stage. Finally, it sets the main
    application for the image to run when it’s started as a container.
  prefs: []
  type: TYPE_NORMAL
- en: An important thing to note, is that `COPY --from` instructions are used to **only
    copy production-related application code** from the images built by the previous
    stages. They do not copy across build artefacts that are not needed for production.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also important to note that we only need a single Dockerfile, and no extra
    arguments are needed for the `docker image build` command!
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of which… let’s build it.
  prefs: []
  type: TYPE_NORMAL
- en: Clone the repo.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`Change directory into the `app` folder of the cloned repo and verify that
    the Dockerfile exists.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`Perform the build (this may take several minutes to complete).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`> **Note:** The `multi:stage` tag used in the example above is arbitrary.
    You can tag your images according to your own requirements and standards - there
    is no requirement to tag multi-stage builds the way we did in this example.'
  prefs: []
  type: TYPE_NORMAL
- en: Run a `docker image ls` to see the list of images pulled and created by the
    build operation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`The top line in the output above shows the `node:latest` image pulled by the
    `storefront` stage. The image below is the image produced by that stage (created
    by adding the code and running the npm install and build operations). Both are
    very large images with lots of build tools included.'
  prefs: []
  type: TYPE_NORMAL
- en: The 3rd and 4th lines are the images pulled and produced by the `appserver`
    stage. These are both large and contain lots of builds tools.
  prefs: []
  type: TYPE_NORMAL
- en: The last line is the `multi:stage` image built by the final build stage in the
    Dockerfile (stage2/production). You can see that this is significantly smaller
    than the images pulled and produced by the previous stages. This is because it’s
    based off the much smaller `java:8-jdk-alpine` image and has only added the production-related
    app files from the previous stages.
  prefs: []
  type: TYPE_NORMAL
- en: The net result is a small production image created by a single Dockerfile, a
    normal `docker image build` command, and zero additional scripting!
  prefs: []
  type: TYPE_NORMAL
- en: Multi-stage builds were new with Docker 17.05 and are an excellent feature for
    building small production-worthy images.
  prefs: []
  type: TYPE_NORMAL
- en: A few best practices
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s list a few best practices before closing out the chapter. This list is
    not intended to be exhaustive.
  prefs: []
  type: TYPE_NORMAL
- en: Leverage the build cache
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The build process used by Docker has the concept of a cache. The best way to
    see the impact of the cache is to build a new image on a clean Docker host, then
    repeat the same build immediately after. The first build will pull images and
    take time building layers. The second build will complete almost instantaneously.
    This is because artefacts form the first build, such as layers, are cached and
    leveraged by later builds.
  prefs: []
  type: TYPE_NORMAL
- en: As we know, the `docker image build` process iterates through a Dockerfile one-line-at-a-time
    starting from the top. For each instruction, Docker looks to see if it already
    has an image layer for that instruction in its cache. If it does, this is a *cache
    hit* and it uses that layer. If it doesn’t, this is a *cache miss* and it builds
    a new layer from the instruction. Getting *cache hits* can hugely speed up the
    build process.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look a little closer.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use this example Dockerfile to provide a quick walk-through:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`The first instruction tells Docker to use the `alpine:latest` image as its
    *base image*. If this image already exists on the host, the build will move on
    to the next instruction. If the image does not exist, it is pulled from Docker
    Hub (docker.io).'
  prefs: []
  type: TYPE_NORMAL
- en: The next instruction (`RUN apk...`) runs a command against the image. At this
    point, Docker checks its build cache for a layer that was built from the same
    base image, as well as using the same instruction it is currently being asked
    to execute. In this case, it’s looking for a layer that was built directly on
    top of `alpine:latest` by executing the `RUN apk add --update nodejs nodejs-npm`
    instruction.
  prefs: []
  type: TYPE_NORMAL
- en: If it finds a layer, it skips the instruction, links to that existing layer,
    and continues the build with the cache in tact. If it does **not** find a layer,
    it invalidates the cache and builds the layer. This operation of invalidating
    the cache invalidates it for the remainder of the build. This means all subsequent
    Dockerfile instructions are completed in full without attempting to reference
    the build cache.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume that Docker already had a layer for this instruction in the cache
    (a cache hit). And let’s assume the ID of that layer was `AAA`.
  prefs: []
  type: TYPE_NORMAL
- en: The next instruction copies some code into the image (`COPY . /src`). Because
    the previous instruction resulted in a cache hit, Docker now checks to see if
    it has a cached layer that was built from the `AAA` layer with the `COPY . /src`
    command. If it does, it links to the layer and proceeds to the next instruction.
    If it does not, it builds the layer and invalidates the cache for the rest of
    the build.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume that Docker already has a layer for this instruction in the cache
    (a cache hit). And let’s assume the ID of that layer is `BBB`.
  prefs: []
  type: TYPE_NORMAL
- en: This process continues for the rest of the Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to understand a few things.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, as soon as any instruction results in a cache-miss (no layer was found
    for that instruction), the cache is no longer used for the rest of the entire
    build. This has an important impact on how you write your Dockerfiles. Try and
    build them in a way that places any instructions that are likely to change towards
    the end of the file. This means that a cache-miss will not occur until later stages
    of the build - allowing the build to benefit as much as possible from the cache.
  prefs: []
  type: TYPE_NORMAL
- en: You can force the build process to ignore the entire cache by passing the `--no-cache=true`
    flag to the `docker image build` command.
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to understand that the `COPY` and `ADD` instructions include
    steps to ensure that the content being copied into the image has not changed since
    the last build. For example, it’s possible that the `COPY . /src` instruction
    in the Dockerfile has not changed since the previous, **but…** the contents of
    the directory being copied into the image **have** changed!
  prefs: []
  type: TYPE_NORMAL
- en: To protect against this, Docker performs a checksum against each file being
    copied, and compares that to a checksum of the same file in the cached layer.
    If the checksums do not match, the cache is invalidated and a new layer is built.
  prefs: []
  type: TYPE_NORMAL
- en: Squash the image
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Squashing an image isn’t really a best practice as it has pros and cons.
  prefs: []
  type: TYPE_NORMAL
- en: At a high level, Docker follows the normal process to build an image, but then
    adds an additional step that squashes everything into a single layer.
  prefs: []
  type: TYPE_NORMAL
- en: Squashing can be good in situations where images are starting to have a lot
    of layers and this isn’t ideal. And example might be when creating a new base
    image that you want to build other images from in the future - this is much better
    as a single-layer image.
  prefs: []
  type: TYPE_NORMAL
- en: On the negative side, squashed images do not share image layers. This can result
    in storage inefficiencies and larger push and pull operations.
  prefs: []
  type: TYPE_NORMAL
- en: Add the `--squash` flag to the `docker image build` command if you want to create
    a squashed image.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.8 shows some of the inefficiencies that come with squashed images.
    Both images are exactly the same except for the fact that one is squashed and
    the other is not. The squashed image shares layers with other images on the host
    (saving disk space) but the squashed image does not. The squashed image will also
    need to send every byte to Docker Hub on a `docker image push` command, whereas
    the non-squashed image only needs to send unique layers.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 - Squashed images vs non-squashed images](images/figure8-8.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 - Squashed images vs non-squashed images
  prefs: []
  type: TYPE_NORMAL
- en: Use no-install-recommends
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you are building Linux images, and using the apt package manager, you should
    use the `no-install-recommends` flag with the `apt-get install` command. This
    makes sure that `apt` only installs main dependencies (packages in the `Depends`
    field) and not recommended or suggested packages. This can greatly reduce the
    number of unwanted packages that are downloaded into your images.
  prefs: []
  type: TYPE_NORMAL
- en: Do not install from MSI packages (Windows)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you are building Windows images, you should try not to use the MSI package
    manager. It is not space efficient and results in substantially larger images
    than are required.
  prefs: []
  type: TYPE_NORMAL
- en: Containerizing an app - The commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`docker image build` is the command that reads a Dockerfile and containerizes
    an application. The `-t` flag tags the image, and the `-f` flag lets you specify
    the name and location of the Dockerfile. With the `-f` flag, it is possible to
    use a Dockerfile with an arbitrary name and in an arbitrary location. The *build
    context* is where your application files exist, and this can be a directory on
    your local Docker host or a remote Git repo.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `FROM` instruction in a Dockerfile specifies the base image for the new
    image you will build. It is usually the first instruction in a Dockerfile.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `RUN` instruction in a Dockerfile allows you to run commands inside the
    image which create new layers. Each `RUN` instruction creates a single new layer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `COPY` instruction in a Dockerfile adds files into the image as a new layer.
    It is common to use the `COPY` instruction to copy your application code into
    an image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `EXPOSE` instruction in a Dockerfile documents the network port that the
    application uses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ENTRYPOINT` instruction in a Dockerfile sets the default application to
    run when the image is started as a container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other Dockerfile instructions include `LABEL`, `ENV`, `ONBUILD`, `HEALTHCHECK`,
    `CMD` and more…
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter we learned how to containerize (Dockerize) an application.
  prefs: []
  type: TYPE_NORMAL
- en: We pulled some application code from a remote Git repo. The repo included the
    application code, as well as a Dockerfile containing instructions on how to build
    the application into an image. We learned the basics of the how Dockerfiles work,
    and fed one into a `docker image build` command to create a new image.
  prefs: []
  type: TYPE_NORMAL
- en: Once the image was created, we started a container form it and tested it worked
    with a web browser.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we saw how multi-stage builds give us a simple way to build and
    ship smaller images to our production environments.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned that the Dockerfile is a great tool for documenting an app.
    As such, it can speed-up the on-boarding of new developers and bridge the divide
    between developers and operations staff! With this in mind, treat it like code
    and check it in and out of a source control system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the example cited was a Linux-based example, the process for containerizing
    Windows apps is the same: Start with your app code, create a Dockerfile describing
    the app, build the image with `docker image build`. Job done![PRE20]`'
  prefs: []
  type: TYPE_NORMAL
