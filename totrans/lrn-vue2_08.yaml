- en: Chapter 8. Deploying – Time to Go Live!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned how to test your Vue applications. We tested
    them applying different testing techniques. In the beginning, we have performed
    classic unit testing on Vue components and on Vuex-related modules, such as actions,
    mutations, and getters. After that, we learned how to apply end-to-end testing
    techniques using Nightwatch.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will make our applications go live by deploying them to
    a server and making them available to the world. We will also guarantee continuous
    integration and continuous deployment of our applications. This means that every
    time we commit changes performed on the applications, they will automatically
    be tested and deployed.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in mind, in this chapter, we are going to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up a continuous integration process using Travis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up a continuous deployment using Heroku
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before starting to deploy our applications, let''s first try to define what
    it actually means:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Software deployment is all of the activities that make a software system
    available for use."                                         – Wikipedia: https://en.wikipedia.org/wiki/Software_deployment*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This definition means that after we perform all the necessary activities, our
    software will be accessible to the public. In our case, as we are deploying web
    applications, it means that there will be a public URL, and any person will be
    able to type this URL on their browser and access the application. How can this
    be achieved? The simplest way is to provide your own IP address to your friends
    and run the application. Thus, people inside your private network will be able
    to access the application on their browser. So, run, for example, the Pomodoro
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And then check your IP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![Software deployment](../Images/image00315.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Checking the IP address with the ifconfig command
  prefs: []
  type: TYPE_NORMAL
- en: And then share the address with your friends on the same private network. In
    my case, it would be `http://192.168.1.6:8080`.
  prefs: []
  type: TYPE_NORMAL
- en: However, only your friends who are inside your network will be able to access
    the application, and there's obviously not that much fun in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use some software that will create a publicly accessible address and
    thus transform your computer into a hosting provider, for example, **ngrok** (
    [https://ngrok.com/](https://ngrok.com/) ). Run the application and then run the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create an address that will be accessible from anywhere, just like
    a regular website:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Software deployment](../Images/image00316.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using ngrok to provide a tunnel to your localhost
  prefs: []
  type: TYPE_NORMAL
- en: In my case, it would be `http://5dcb8d46.ngrok.io` . I can share this address
    on my social networks and everybody will be able to access it and try the Pomodoro
    application! But stop ... I can leave my laptop on for the whole night, but I
    can't leave it on forever. Once I switch it off, the network connection is lost
    and there is no access to my application anymore. Also, even if I could leave
    it on forever, I don't like this website address. It's a bunch of letters and
    numbers, and I want it to be something meaningful.
  prefs: []
  type: TYPE_NORMAL
- en: There are more robust ways. I can buy, for example, a virtual instance on **AWS**
    (**Amazon Web Services**), copy my application to this instance, buy a domain
    at a domain provider such as GoDaddy, associate this domain to the bought instance's
    IP, and run the application there and it will be accessible, maintained, backed
    up, and taken care of by the Amaz(on)ing service. Amazing, but ... expensive as
    hell. Let's think of this solution when our applications reach the corresponding
    size and payback level.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, for this chapter, we want our deployment solution to be cheap (where
    cheap means free), robust, and simple. That is why we will deploy our application
    to Heroku, a cloud-application platform. In order to do that, we will first host
    our application on GitHub. Do you remember that deployment is something that makes
    our applications ready to use? I consider an application to be ready to use when
    it''s tested and when tests are not failing. That is why we will also use Travis
    to guarantee the quality of our applications before their actual deployment. So,
    our necessary activities to deploy the application will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create GitHub repositories for the applications and move the applications into
    the repositories.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up continuous integration with Travis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect applications to Heroku, and set up and configure them in order for Heroku
    to run them and to expose them to the world.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next three subsections, I will give a small introduction to GitHub, Travis,
    and Heroku.
  prefs: []
  type: TYPE_NORMAL
- en: What is GitHub?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GitHub is a hosting provider for Git-based projects.
  prefs: []
  type: TYPE_NORMAL
- en: It can be used at a small, personal scale for individual private and public
    projects. It can also be used for big corporate projects and all development-related
    activities, such as code reviews, continuous integration, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Everyone who lives in the world of open source software knows GitHub. If you
    are reading this book about Vue, which is hosted on GitHub ( [https://github.com/vuejs/](https://github.com/vuejs/)
    ), I am sure that you are skipping this subsection, so probably I can write some
    stupid jokes about you here and you will never notice them! Just kidding!
  prefs: []
  type: TYPE_NORMAL
- en: What is Travis?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Travis is a tool for GitHub that allows us to connect GitHub projects to it
    and ensure their quality. It runs tests in your projects and tells you that build
    has passed, or warns you that build has failed. Check more about Travis and how
    to use it at  [https://travis-ci.org/](https://travis-ci.org/) .
  prefs: []
  type: TYPE_NORMAL
- en: What is Heroku?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Heroku is a cloud platform for deploying your apps. It is extremely easy to
    use. You just create an application, give it a nice meaningful name, connect it
    to your GitHub project, and voilà! Each time you push to a given branch (for example,
    to the `master` branch), Heroku will just run a script provided by you as an entry
    point script of your app and redeploy it.
  prefs: []
  type: TYPE_NORMAL
- en: It is highly configurable and also provides a command-line interface so that
    you can access all your applications from your local command line without having
    to check your Heroku dashboard website. Let's then start and learn everything
    by doing it ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Moving the application to the GitHub repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start by creating the GitHub repositories for our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Please use the code from the [chapter8/pomodoro](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter8/pomodoro)
    and [chapter8/shopping-list](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter8/shopping-list)
    directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you still don''t have an account at GitHub, create it. Now log in to your
    GitHub account and create two repositories, `Pomodoro` and `ShoppingList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Moving the application to the GitHub repository](../Images/image00317.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Create a repository at GitHub
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you hit the **`Create repository`** button, a page with different instructions
    appears. We are particularly interested in the second paragraph, which says **`...or
    create a new repository on the command line`**. Copy it, paste it to the command
    line while in the Pomodoro application directory, remove the first line (because
    we already have the README file) and modify the third line to add everything inside
    the directory, and hit the *Enter* button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Refresh your GitHub project page, and you will see that all the code is there!
    In my case, it is at [https://github.com/chudaol/Pomodoro](https://github.com/chudaol/Pomodoro)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Do the same for the shopping list application. I just did it and here I am:
    [https://github.com/chudaol/ShoppingList](https://github.com/chudaol/ShoppingList)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: If you don't want to create your own repositories, you can just fork mine. Open
    source is open!
  prefs: []
  type: TYPE_NORMAL
- en: Setting continuous integration with Travis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to be able to set up continuous integration with Travis, first of
    all you have to connect your Travis account with your GitHub account. Open [https://travis-ci.org/](https://travis-ci.org/)
    and click on the **`Sign in with GitHub`** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting continuous integration with Travis](../Images/image00318.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Click on the Sign in with GitHub button
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can add repositories that will be tracked with Travis. Click on the
    plus sign (**`+`**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting continuous integration with Travis](../Images/image00319.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Click on the plus sign to add your GitHub project
  prefs: []
  type: TYPE_NORMAL
- en: 'After you click on the plus button, the whole list of your GitHub project appears.
    Choose the projects you want to track:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting continuous integration with Travis](../Images/image00320.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Choose the projects you want to track with Travis
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our projects connected to the Travis build system that listens
    to every commit and push to the `master` branch, we need to tell it somehow what
    it has to do once it detects changes. All the configuration for Travis should
    be stored in the `.travis.yml` file. Add the `.travis.yml` file to both the projects.
    We have at least to tell which node version should be used. Check the Node version
    of your system (this is the one that you are completely sure that works with our
    projects). Just run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In my case, it is `v5.11.0`. So I will add it to the `.travis.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you commit and push now, you will see that Travis automatically starts running
    tests. By default, it calls the `npm test` command on the project. Wait for a
    few minutes and observe the result. Unfortunately, it will fail while performing
    end-to-end (Selenium) tests. Why does this happen?
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, virtual images of the Travis building and testing environment do
    not have the Chrome browser installed. And our Selenium tests are trying to run
    on the Chrome browser. But fortunately for us, Travis provides a mechanism of
    performing some commands before building. It should be done in the `before_script`
    section of the YML file. Let''s invoke the necessary commands to install Chrome
    and export the `CHROME_BIN` variable. Add the following to your `.travis.yml`
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, in order to perform the installation and system update, we
    must invoke commands with `sudo`. By default, Travis does not let you execute
    `sudo` commands in order to prevent accidental damage by non-trustworthy scripts.
    But you can tell Travis explicitly that your script uses `sudo`, which means that
    you are aware of what are you doing. Just add the following lines to your `.travis.yml`
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now your whole `.travis.yml` file should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Try to commit it and check your Travis dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Oh no! It fails again. This time, it seems to be timeout issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting continuous integration with Travis](../Images/image00321.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Even after installing Chrome, tests silently fail due to the timeout
  prefs: []
  type: TYPE_NORMAL
- en: Why did it happen? Let's recall what actually happens when we run our end-to-end
    tests. Each test opens the browser and then performs clicks, inputs, and other
    things to test our UI. The keyword of the last sentence is *UI*. If we need to
    test a UI, we need a **graphical user interface** (**GUI**). Travis virtual images
    do not have graphical displays. Thus, there is no way that they can open the browser
    and display our UIs in it. Fortunately for us, there is a nice thing called *Xvfb
    - X virtual framebuffer*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Xvfb is a display server that implements the protocol used by the physical
    displays. All needed graphical operations are performed in memory; thus, there
    is no need of having physical displays. Therefore, we can run an Xvfb server that
    will provide a virtual graphical environment to our tests. And if you carefully
    read the Travis documentation, you will find that this is exactly what it suggests
    as a way of running tests that require GUI: [https://docs.travis-ci.com/user/gui-and-headless-browsers/#Using-xvfb-to-Run-Tests-That-Require-a-GUI](https://docs.travis-ci.com/user/gui-and-headless-browsers/#Using-xvfb-to-Run-Tests-That-Require-a-GUI)
    . So open the `.travis.yml` files and add the following to the `before_script`
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The whole YML file now looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Commit it and check your Travis dashboard. The Pomodoro application was built
    successfully!
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting continuous integration with Travis](../Images/image00322.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Pomodoro application built with success!
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the shopping list application''s build has failed. Note that Travis
    even changes the tab''s title color for each of the build states:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting continuous integration with Travis](../Images/image00323.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Travis changes the icon on the tab's title according to the build state
  prefs: []
  type: TYPE_NORMAL
- en: 'So what is happening with the shopping list application build? There''s a step
    in the end-to-end test that checks for the **`Groceries`** title being present
    on the page. The thing is that this title comes from our backend server that should
    be run with the `npm run server` command. Do you remember we implemented it in
    [Chapter 6](part0061.xhtml#aid-1Q5IA1 "Chapter 6. Plugins – Building Your House
    with Your Own Bricks"), *Plugins – Building Your House with Your Own Bricks*,
    using the `vue-resource` plugin? This means that before building the application,
    we need to tell Travis to run our small server. Just add the following line to
    the `.travis.yml` file of the shopping list application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Commit your changes and check Travis dashboard. The build passed! Everything
    is green and we are happy (at least I am, and I hope that successful build makes
    you happy as well). Now it would be nice if we could tell the world that our builds
    are passing. We can do it by adding the Travis button to our `README.md` files.
    This will allow us to immediately see the build status on the project's GitHub
    page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **`build passing`** button on the Travis page of your application,
    check the **`Markdown`** option from the second drop-down list, and copy the generated
    text to the `README.md` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting continuous integration with Travis](../Images/image00324.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Click on the build passing button, select option Markdown from the second drop-down,
    and copy the text to the README.md file
  prefs: []
  type: TYPE_NORMAL
- en: 'Look how nice it looks in the README file on the GitHub page of our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting continuous integration with Travis](../Images/image00325.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Travis button looks really fancy in the README file of the project on its
    GitHub page
  prefs: []
  type: TYPE_NORMAL
- en: Now that our applications are being checked on each commit and therefore we
    have for sure guaranteed their quality, we can finally deploy them to the publicly
    accessible place.
  prefs: []
  type: TYPE_NORMAL
- en: Before starting the process of deployment, please create an account at Heroku
    ( [https://signup.heroku.com/dc](https://signup.heroku.com/dc) ) and install Heroku
    Toolbelt ( [https://devcenter.heroku.com/articles/getting-started-with-nodejs#set-up](https://devcenter.heroku.com/articles/getting-started-with-nodejs#set-up)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: Now we are ready to deploy our projects.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the Pomodoro application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start by adding new application to our Heroku account. Click on the **`Create
    New App`** button on the Heroku dashboard. You can create your own name or leave
    the name input field blank, and Heroku will create a name for you. I will call
    my application *catodoro* because it is Pomodoro that has cats!
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying the Pomodoro application](../Images/image00326.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a new app with Heroku
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **`Create App`** button and you will proceed to the page, choosing
    a deployment pipeline for your application. Choose the GitHub method, and then
    from the proposed drop-down of your GitHub projects, choose the project that we
    want to deploy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying the Pomodoro application](../Images/image00327.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Choose the GitHub method of deployment and select the corresponding project
    from your GitHub projects
  prefs: []
  type: TYPE_NORMAL
- en: 'After clicking on the **`Connect`** button, two things that you might probably
    want to check are the **`Automatic deploys from master are enabled`** and **`Wait
    for CI to pass before deploy`** options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying the Pomodoro application](../Images/image00328.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Check the Wait for CI to pass before deploy checkbox and click on the Enable
    Automatic Deploys button
  prefs: []
  type: TYPE_NORMAL
- en: Everything is ready to perform a first deployment and you can even click on
    the **`Deploy Branch`** button, and Heroku will try to perform a build, but then,
    if you try to open the application in the browser, it will not work. If you wonder
    why, you should always look at the running log while performing such operations.
  prefs: []
  type: TYPE_NORMAL
- en: Checking logs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I hope you have successfully installed the Heroku CLI (or Heroku toolbelt),
    so now you can run `heroku` commands in your command line. Let''s check the logs.
    Run the `heroku logs` command in your shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see a continuously running log while Heroku tries to perform a build.
    And the error is `npm ERR! missing script: start`. We don''t have a `start` script
    in our `package.json` file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is entirely true. In order to create a start script, let''s first try
    to understand how to build and run a Vue application for production. The README
    file tells us that we need to run the `npm run build` command. Let''s run it locally
    and check what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Checking logs](../Images/image00329.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The output of the npm run build command
  prefs: []
  type: TYPE_NORMAL
- en: So we know that the result of the build command goes to the `dist` folder. And
    we also know that we have to serve the `index.html` file from this folder using
    an HTTP server. We also know that we have to create a `start` script in the `scripts`
    section of the `package.json` file, so Heroku knows how to run our application.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the application to run on Heroku
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We were able to gather a lot of information by checking the log file. Let's
    also summarize here Heroku's pipeline for running the application before proceeding
    to the steps for deploying the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, Heroku does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Runs the `npm install` script to install all the needed dependencies (it checks
    the dependencies in the `dependencies` section of the `package.json` file)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runs the `npm start` script from the `package.json` and serves the result of
    it on the known web address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, given this information and the information we gathered from the logs and
    running the `npm build` script, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Tell Heroku to install all the needed dependencies; for that, we need to move
    project dependencies from the `devDependencies` section to the `dependencies`
    section in the `package.json` file so that Heroku installs them all
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tell Heroku to run a build script after performing `npm install`; for that,
    we need to create a `postinstall` script in the `package.json` file where we will
    call the `npm run build` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a `server.js` file that serves the `index.html` file from the `dist`
    folder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide a way for Heroku to run the `server.js` script; for this, we need to
    create a `start` script in the `package.json` file that runs the `server.js` script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Start by moving all the dependencies, except the ones that have to do with
    testing, from the `devDependencies` section to the `dependencies` section of our
    `package.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s create a `postinstall` script in which we will tell Heroku to run
    the `npm run build` script. In the `scripts` section, add the `postinstall` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s create a `server.js` file in which we will serve the `index.html`
    file from the `dist` directory. Create a `server.js file` in the project''s folder
    and add the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, now we just need to create a `start` script in the `scripts` section
    of our `package.json` file and we are done! Our `start` script should just run
    `node server.js`, so let''s do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Commit your changes, go to the Heroku dashboard, and click on the **`Deploy
    Branch`** button. Do not forget to check running logs!
  prefs: []
  type: TYPE_NORMAL
- en: And yippee! The build was successful! After a successful build, you are invited
    to click the **`View`** button; don't be shy, click on it and you will see your
    application in action!
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing the application to run on Heroku](../Images/image00330.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Pomodoro application is successfully deployed to Heroku
  prefs: []
  type: TYPE_NORMAL
- en: Now you can use your Pomodoro application everywhere. Now you can ask your friends
    to use it as well by simply providing them the Heroku link.
  prefs: []
  type: TYPE_NORMAL
- en: Well, congratulations! You've just deployed your Vue application, and it can
    be used by everyone. How nice is it?
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the shopping list application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to deploy our shopping list application, we need to perform exactly
    the same steps as we have done with the Pomodoro application.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new application on your Heroku dashboard and connect it to your GitHub
    shopping list project. After that, copy the `server.js` file from the Pomodoro
    application, deal with the dependencies in the `package.json` file, and create
    `postinstall` and `start` scripts.
  prefs: []
  type: TYPE_NORMAL
- en: However, we still have one step left. Do not forget about our backend server
    that serves the REST API for the shopping lists. We need to run it as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Or even better, why do we need to run two servers if we can have just one server
    that does everything? We can integrate our JSON server with our express server
    by providing it the routing path to serve the shopping list endpoint, let''s say
    `api`. Open the `server.js` file, import the `jsonServer` dependency there, and
    tell the express app to use it. So, your `server.js` file will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding line, we tell our express app to use `jsonServer` and serve
    the `db.json` file over the `/api/` endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should also change the endpoint''s address in our `Vue` resource. Open `index.js` in
    the API folder and replace `localhost:3000` with an `api` prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We should also add JSON server support to `dev-server.js`; otherwise, we will
    not be able to run the application in development mode. So, open the `build/dev-server.js`
    file, import `jsonServer`, and tell the express app to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Try to run the application in dev mode (`npm run dev`). Everything works fine.
  prefs: []
  type: TYPE_NORMAL
- en: You can now also remove the server running command (`- nohup npm run server
    &`) from the `travis.yml` file. You can also remove the server script from `package.json`.
  prefs: []
  type: TYPE_NORMAL
- en: Run tests locally and check that they are not failing.
  prefs: []
  type: TYPE_NORMAL
- en: We are almost done. Let's try our application locally.
  prefs: []
  type: TYPE_NORMAL
- en: Trying Heroku locally
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes it gets a lot of try-fail iterations to get things work. We try something,
    commit, push, try to deploy, see whether it works. We realize that we have forgotten
    about something, commit, push, try to deploy, see the error log. Do it again and
    again. It might be really time-consuming because things over the network take
    time! Fortunately for us, the Heroku CLI provides a way to run the application
    locally as it was already deployed to the Heroku server. You just need to run
    the `heroku local web` command right after building the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Try it.
  prefs: []
  type: TYPE_NORMAL
- en: Open `http://localhost:5000` in your browser. Yes, it works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Trying Heroku locally](../Images/image00331.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Running the application locally with the Heroku local web command. It works!
  prefs: []
  type: TYPE_NORMAL
- en: Let's now commit and push the changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can wait for the successful Travis build and automatic deploy by Heroku
    after that, or you can just open your Heroku dashboard and click on the **`Deploy
    Branch`** button. Wait a bit. And ... it works! Here is the result of two deployments
    we performed today:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pomodoro application**: [https://catodoro.herokuapp.com/](https://catodoro.herokuapp.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shopping list application**:  [https://shopping-list-vue.herokuapp.com/](https://shopping-list-vue.herokuapp.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The respective GitHub repositories can be found at  [https://github.com/chudaol/Pomodoro](https://github.com/chudaol/Pomodoro)
     and  [https://github.com/chudaol/ShoppingList](https://github.com/chudaol/ShoppingList)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Fork, play, test, deploy. At this moment, you have all the instruments needed
    to enhance, improve, and show these applications to the whole world. Thank you
    for being with me through this exciting journey!
  prefs: []
  type: TYPE_NORMAL
