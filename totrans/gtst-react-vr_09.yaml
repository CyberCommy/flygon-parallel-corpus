- en: Do It Yourself – Native Modules and Three.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React VR makes it easy to do VR without having to know three.js. The three.js
    is the wrapper class that helps implement WebGL, which itself is a form of the
    native OpenGL rendering library.
  prefs: []
  type: TYPE_NORMAL
- en: React VR is fairly inclusive, but like all APIs, it can't do everything. Fortunately,
    React VR anticipated this; if React VR doesn't support a feature and you need
    it, you can build that feature yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using three.js from inside React VR code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basic three.js procedural code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up three.js to interact with our React VR components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using three.js to do things visually that are lower level with three.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Native modules and views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maybe you do know three.js and need to use it. **React Native modules** are
    how your code can directly include raw three.js programming. This is very useful
    if you need to programmatically create native three.js objects, modify material
    attributes, or use other three.js code that isn't directly exposed by React VR.
  prefs: []
  type: TYPE_NORMAL
- en: You may have some JavaScript code that does business logic, and don't want to,
    or can't rewrite that as React VR components. You might need to access three.js
    or WebVR components from React VR. You might need to build a high-performance
    database query with multiple threads so that the main rendering loop doesn't slow
    down. All of these things are possible with React Native.
  prefs: []
  type: TYPE_NORMAL
- en: This is a fairly advanced topic and will not normally be required to write engaging,
    effective WebVR demos; still, it's fantastic knowing that React VR and React are
    so extensible.
  prefs: []
  type: TYPE_NORMAL
- en: Making a three.js cube demo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s take a look at a simple box demo. Let''s start with a freshly
    generated site. Go to your node.js command-line interface and kill any *npm start* windows
    you have running and recreate a new, fresh site  by issuing the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The first task is to go to the `vr` folder and edit `client.js`. Up to this
    point, we haven''t had to edit this file; it contains boilerplate React VR code.
    Today, we''re going to edit it, as we aren''t doing just boilerplate. The bold
    lines in the following code are the lines we will add to `client.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to create the object CubeModule. You could put this in a separate
    file, and should if it gets complicated. For now, we can add it to the bottom
    of client.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: No other changes are needed. You will now see a bouncing, plain white cube.
    We haven't changed index.vr.js, so it still displays the hello text. This shows
    that both React VR and Native code, in this case three.js, are running at the
    same time.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/716e2f93-e93a-4c21-be6e-c24d931de8b0.png)'
  prefs: []
  type: TYPE_IMG
- en: OK, so we put in a bouncing cube. The nice thing about this code is that it
    shows some high levels of integration; yet, this is done in a very clean way.
    For example, the line—`const scene = new THREE.Scene()`—gives you a three.js-accessible
    scene, so we can do whatever we want with three.js, yet, all of the React VR keywords
    just work because it will use the existing scene. You don't have to import/export
    scenes from one side to another and maintain handles/pointers. It's all clean,
    declarative, as React VR is supposed to be. We have the regular scene and objects
    created outside of our normal React VR syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our previous animations, we changed `index.vr.js`. In this case, with three.js
    objects, we make those changes directly in this part of `client.js`; right where
    the code generator suggests it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`vr.render = function(timestamp) {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`// Any custom behavior you want to perform on each frame goes here`'
  prefs: []
  type: TYPE_NORMAL
- en: Making native code interact with React VR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can really see the power of React VR if we then go ahead and make this object
    interact with the rest of the world. To do that, we will need to change the index.vr.js.
    We will also use a `VrButton` for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: Note the spelling in `VrButton`. I was beating my head against the keyboard
    for a while on that one. I just naturally type "VR" instead of "Vr," but it does
    follow the React VR case standard.
  prefs: []
  type: TYPE_NORMAL
- en: The clue is that in the console you will see `VRButton is not defined`, which
    normally means that you forgot it in the `import` statement. In this particular
    case, you'll see an oddity of React; you can type `import { YoMomma } from 'react-vr';`
    and you won't get an error; try it. React VR is apparently too scared to talk
    back to YoMomma.
  prefs: []
  type: TYPE_NORMAL
- en: When we click on buttons, an important part of immersion is for them to make
    a click. Anyone that has their phone on silent, without vibration knows what I
    mean; you press on the cell phone and hear nothing and think it's broken. So,
    let's head to [FreeSound.org](http://FreeSound.org) and download some clicks.
  prefs: []
  type: TYPE_NORMAL
- en: 'I found *Switch Flip #1* by *IanStarGem*, and it''s Creative Commons licensed.
    So, let''s put that in the `static_assets` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will need to include the declaration of our `NativeModule`; usually,
    you do this at the top after the `import` directives, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that you could call your object `CubeModule` but you can get confused with
    the implementation versus definition. It does make it easier to type. JavaScript
    can be pretty forgiving. That may or may not be a good thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In any event, in `index.vr.js`, we need to setup our new inital state, or we
    get a black screen and an error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same file, right below the `render()` statement, change the `<View>`
    definition to the following (note that we are still ''inside'' the view and haven''t
    closed it yet):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We are cheating slightly here, that is, moving the view backward so that the
    objects are in front of us.
  prefs: []
  type: TYPE_NORMAL
- en: As React VR is not a CAD system, you can't edit visually, so you've got to think
    about the positioning of items when you do the code.
  prefs: []
  type: TYPE_NORMAL
- en: Layout graph paper might also help for something complicated.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the `<Pano>` statement, and before the `</View>` closing tag, insert
    the following (changing the template-generated Text statement):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When you refresh your browser, the cube will still bounce around, but you can
    click on the button and see the cube change color. When you move the mouse or
    controller's cursor over the button (visible as a `<Text>` component), you will
    see the button change to the cube's current color.
  prefs: []
  type: TYPE_NORMAL
- en: One neat thing you could do is pregenerate the new color of the cube in a static
    variable (so it doesn't go away like let will) and then make the mouse over color
    be that color.
  prefs: []
  type: TYPE_NORMAL
- en: A default color of white on white should be fixed too.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and try that; it's a fun exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we play the sound, we get the following error in the console of the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You may also see the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The fix for this problem is to make sure that you have the right audio format
    for your browser. The right formats are:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Audio files need to be mono; this is so they can be transformed into 3D space.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Audio files need to be 48 KHz or lower. This seemed to change between Firefox
    55 and 59, but it's safest to be as generic as possible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If your files are the wrong format, or you don''t hear the sound, there are
    two possible fixes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can fix these with Audacity or other sound editing tools.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can let me fix it! I''ve already downloaded and converted the file for
    you in the book files. However, if you don''t try to do the fix, you won''t learn.You
    could just download only 48 KHz mono files and avoid the conversion, but in practice
    these are fairly rare. Converting the sounds is easy and free with Audacity, you
    just have to learn a little bit of the program to do this. Inside the VR button
    all we need to do is load the modifed, mono sound file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: I mentioned this in an earlier section, but it bears repeating that if you get
    unexplained errors and you exclaim "I know the file is there and it plays!", try
    checking the format of the sound file.
  prefs: []
  type: TYPE_NORMAL
- en: Summing up the code so far
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We added a lot of code; let''s summarize where we are. React VR can sometimes
    be confusing, as it is a mixture of JavaScript and XML "ish" code (JSX), so here
    is the complete and total `index.vr.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the file, `client.js`, in the `vr` folder (the folder name is lowercase),
    will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Something more visual
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've done some neat interactivity, which is fantastic, although another big
    reason to use three.js directly is to do something rendering wise that React VR
    cannot do. Well, actually, React VR can do some amazing things through Native
    methods, so let's do exactly that.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's change our cube from bouncing around to spinning as well. It'll
    look more impressive when we add some of the visual effects.
  prefs: []
  type: TYPE_NORMAL
- en: Let's also add a few spheres around. We'll want some things to reflect. I chose
    reflection as an impressive thing that you cannot really do in real time with
    WebVR currently, although we can do something really close to it through environment
    mapping. For a fairly long discussion of what environment mapping is, you can
    go to: [http://bit.ly/ReflectMap](http://bit.ly/ReflectMap).
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your existing `index.vr.js`, below the `</VrButton>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also add an ambient and directional light to the top of `index.vr.js` inside
    the top level `<View>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Go ahead and load that, and make sure that you see a nice blue sphere and big
    red ball. Note that I''m coding slightly more dense than normal, so this book
    doesn''t kill more trees or photons.  Most of our changes are going to be in `client.js`.
    First, initialize all of the variables we need under `init`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will set up a custom background to the scene. Interestingly, this
    doesn''t show up when we have a  `<Pano>` statement, but that''s a good thing
    as we''re coding in `three.js` right now; it doesn''t understand VR, so the background
    isn''t quite right. This will show up on the images a little, but fixing that
    is best left as an exercise by the reader. To setup the custom background for
    `three.js`, continue adding to the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll create a torus and the cube we already created earlier (remember
    that this is all still in the `init` statement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'What we''ve done here is created some extra cameras. We will move these cameras
    to where the torus and our bouncing cube will be, then render those cameras to
    an off-screen buffer (that won''t be visible). Now that we have created those
    cameras, we can create our cube and torus three.js objects; note that this is
    a slight change to our earlier cube:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `cubeModule.init(cube);` statement should have already been there.
    Now, we just have to actually wrap the faux tinfoil around our objects; we will
    do this in the `vr.render` function. Here is the entire function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: I changed the box slightly by removing the function `Math.abs(..)` around the
    sine wave so that it'll rotate in a complete circle; this is so that we can see
    what is good about reflection maps, and what is bad.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, we got everything pasted in. You can watch the display with a grin
    on your face. Neat chrome knot objects! After you stare at it, you'll note that
    a few things aren't quite right. You can see the difference between the faked
    reflections and real reflections in the square box. It'll look a little "off,"
    but the chrome knot looks good.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the red highlight versus the green in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/4fba2cf3-bfb4-46b2-826c-83a442cd8a85.png)Creating good VR is all
    about reasonable compromises. In the case of reflections, they can look great,
    as the preceding image shows, but they can also look just a little disturbing.
    The box or a flat mirror would be a good example of something not to do. Curved
    objects look a lot more natural as you can see.'
  prefs: []
  type: TYPE_NORMAL
- en: Games and real-time programming are as much about careful design as a faithful
    recreation of the real world. Remember that we do not create something real; all
    we have to do is create something which will seem real.
  prefs: []
  type: TYPE_NORMAL
- en: There is a true reflector in three.js called `THREE.Reflector` if you want to
    build a flat mirror. It is well documented in the three.js examples.
  prefs: []
  type: TYPE_NORMAL
- en: With these techniques, and the React Native bridge, you can do some amazing
    things with React VR, without having to get deep into regular three.js programming.
  prefs: []
  type: TYPE_NORMAL
- en: Next steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you can see the basic three.js syntax for materials, you could look
    at the various three.js samples, and copy some of that code in. Don't just look
    at the samples on the screen. You will want to also try them in VR. Some game
    tricks, such as lens reflections or screen space reflections, do not look really
    good in VR. As always, test, test, and test.
  prefs: []
  type: TYPE_NORMAL
- en: I also changed the color of the button slightly, and we don't have a cursor
    when we shift into VR mode, so the button press doesn't always work. In the next
    chapter, I'll show you how to fix this, or you can investigate yourself.
  prefs: []
  type: TYPE_NORMAL
- en: I've also loaded a metal-like reflection texture in the source files, called
    `static_assets/metal_reflect.jpg`. You don't have to do the camera rendering to
    get something that looks shiny, especially if it's a dull reflection, and may
    not want the extra overhead of halving your frame rate (all of those camera renderings
    do take time). If this is the case, you can do a simple environment map and skip
    the camera loading and rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Extending React VR — Native Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can also extend React VR itself with something called **Native Views**.
    The word view might make you think of a camera rendering, although the meaning,
    in this case, is a little different. Think of these more as new React VR objects
    that are native three.js. They are very useful. You could use the three.js code we
    just went through  to mix in raw three.js programming, but you have limited ability
    to use declarative programming that way. Is there a more React VR way to do this?
    You can do this through Native Views.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you implement a Native View, you can control how properties and code interact
    with the rest of the runtime code. These injections will usually be visual, although
    you can inject sound as well.
  prefs: []
  type: TYPE_NORMAL
- en: You can also implement new Native objects. The programming is similar to what
    we have done so far; you implement base properties, expose the new keyword to
    the runtime, and then code them as if they were part of the React VR language.
    There are additional keywords and functions that let you describe your new React
    VR views in terms of props and types.
  prefs: []
  type: TYPE_NORMAL
- en: To create a native view, there is documentation at: [http://bit.ly/RCTNativeView.
     ](http://bit.ly/RCTNativeView)
  prefs: []
  type: TYPE_NORMAL
- en: You are getting to the point now that you should be able to do some amazing
    things with React VR, and I fully trust that you can pick apart my examples, extend
    them, and have a fun time.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed how to use the full power of three.js with React
    VR. While learning this, we demonstrated where to place native code and the React
    VR Native bridge. We built `three.js` meshes directly via JavaScript and added
    sound that made the world seem more alive. We also used React Native Views and
    the Native bridge to do customized rendering, including a reflection map—we added
    chrome to VR (as opposed to viewing VR with Chrome). We also showed how to get
    access to the React VR camera via the `vr.player.renderer` to do more three.js
    processing.
  prefs: []
  type: TYPE_NORMAL
- en: With a full-blown three.js included, we really can do anything we want with
    React VR. We should, however, use React VR where it is needed, and three.js where
    we need a little more detail, otherwise React VR will be icing on a bolt. It would
    be liable to cause rust and easily fall off.
  prefs: []
  type: TYPE_NORMAL
