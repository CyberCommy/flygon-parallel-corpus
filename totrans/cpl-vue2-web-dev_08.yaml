- en: Introducing Vue-Router and Loading URL-Based Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the next few chapters, we are going to be creating a shop interface. This
    shop is going to combine everything we have learned so far while introducing some
    more techniques, plugins, and functionality. We are going to look at retrieving
    a list of products from a CSV file, displaying them and their variations, and
    filtering the products by manufacturer or tags. We will also look at creating
    a product detail view and allowing the user to add and remove products and product
    variations, such as size or color, to their online shopping basket.
  prefs: []
  type: TYPE_NORMAL
- en: All of this will be achieved using Vue, Vuex, and a new Vue plugin, Vue-router.
    Vue-router is used for building **Single Page Applications** (**SPAs**) and allows
    you to map components to URLs, or in `VueRouter` terms, routes, and paths. This
    is an extremely powerful plugin and handles a lot of the intricate details required
    for the processing of URLs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is going to cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Initializing Vue-router and its options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating links with Vue-router
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making dynamic routes to update the View based on URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using props with URLs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nesting and naming routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to navigate programmatically with Vue-router
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and initializing Vue-router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to how we added Vue and Vuex to our applications, you can either directly
    include the library from unpkg, or head to the following URL and download a local
    copy for yourself: [https://unpkg.com/Vue-router](https://unpkg.com/vue-router).
    Add the JavaScript to a new HTML document, along with Vue, and your application''s
    JavaScript. Create an application container element, your view, as well. In the
    following example, I have saved the Vue-router JavaScript file as `router.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize a new Vue instance in your application JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to add `VueRouter` and utilize its power. Before we do that,
    however, we need to create some very simple components which we can load and display
    based on the URL. As we are going to be loading the components with the router,
    we don't need to register them with `Vue.component`, but instead create JavaScript
    objects with the same properties as we would a Vue component.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this first exercise, we are going to create two pages—Home and About pages.
    Found on most websites, these should help give you context as to what is loading
    where and when. Create two templates in your HTML page for us to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to encapsulate all your content in one "root" element (represented
    here by the wrapping `<div>` tags). You also need to ensure you declare the templates
    *before* your application JavaScript is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve created a Home page template, with the `id` of `homepage`, and an About
    page, containing some placeholder text from *lorem ipsum*, with the `id` of `about`.
    Create two components in your JavaScript which reference these two templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to give the router a placeholder to render the components in
    the view. This is done by using a custom `<router-view>` HTML element. Using this
    element gives you control over where your content will render. It allows us to
    have a header and footer right in the app view, without needing to deal with messy
    templates or includes the components themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `header`, `main`, and `footer` element to your app. Give yourself a logo
    in the header and credits in the footer; in the `main` HTML element, place the
    `router-view` placeholder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Everything in the app view is optional, except the `router-view`, but it gives
    you an idea of how the router HTML element can be implemented into a site structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next stage is to initialize the Vue-router and instruct Vue to use it.
    Create a new instance of `VueRouter` and add it to the `Vue` instance—similar
    to how we added `Vuex` in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to tell the router about our routes (or paths), and what component
    it should load when it encounters each one. Create an object inside the Vue-router
    instance with a key of `routes` and an array as the value. This array needs to
    include an object for each route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Each route object contains a `path` and `component` key. The `path` is a string
    of the URL that you want to load the `component` on. Vue-router serves up components
    based on a first-come-first-served basis. For example, if there are several routes
    with the same path, the first one encountered is used. Ensure each route has the
    beginning slash—this tells the router it is a root page and not a sub-page, we
    will cover sub-pages later on in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Press save and view your app in the browser. You should be presented with the
    content of the `Home` template component. If you observe the URL, you will notice
    that on page load a hash and forward slash (`#/`) is appended to the path. This
    is the router creating a method for browsing the components and utilizing the
    address bar. If you change this to the path of your second route, `#/about`, you
    will see the contents of the `About` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Vue-router is also able to use the JavaScript history API to create prettier
    URLs. For example, `yourdomain.com/index.html#about` would become `yourdomain.com/about`.
    This is activated by adding `mode: ''history''` to your `VueRouter` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: However, it also requires some server configuration to catch all requests and
    redirect them to your `index.html` page, which is beyond the scope of this book
    but is fully outlined in the Vue-router documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the folder for Vue-router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There may be scenarios where you want to host your Vue app in a sub-folder of
    your website. In this instance, you will need to declare the base folder of your
    project so Vue-router can construct, and listen out for, the correct URLs.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if your app was based on a `/shop/` folder, you would declare
    it using the `base` parameter on the Vue-router instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The value of this needs the slash at both the beginning and end.
  prefs: []
  type: TYPE_NORMAL
- en: Along with `base`, there are several other configuration options available for
    Vue-router—it is well worth being familiar with them, as they may solve a problem
    you have later on.
  prefs: []
  type: TYPE_NORMAL
- en: Linking to the different routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the router working as expected, we can now proceed with adding links into
    our application, allowing the user to navigate around the website. Links can be
    achieved in two ways: we can use a conventional `<a href="#/about">` tag, or alternatively
    we can utilize a new HTML element provided with the router of `<router-link to="/about">`.
    When using the router-link element, it works the same as an `<a>` tag, and in
    fact gets converted to one when running in the browser, but allows a lot more
    customization and integration with the router.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is highly advised to use the `router-link` element wherever possible, as
    it carries several advantages over the standard link:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mode changes**: The first advantage is linked to the `mode` of the router.
    Using the router link allows you to change the mode of your router, say from hash
    to history, and not have to change every single link in your app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CSS classes**: Another advantage that comes with using the router link is
    a CSS class that gets applied to links active in the "tree" and pages which are
    currently being viewed. Links in the tree are parent pages which also include
    the root page (for example, any links to "`/`" will always have the active class).
    This is one of the big benefits of using the router, as adding and removing these
    classes manually would require complex coding. These classes can be customized
    and we will do that later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**URL parameters and named routes**: The other advantage to using the router
    element is the power it gives you over using named routes and passing URL parameters.
    This further allows you to have one source of truth for the URL of a page and
    use names and shortcuts to reference a route. More on this will be covered later
    in the chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add the links to your pages within your view so you can navigate between pages.
    Within the `<header>` of your website, create a new `<nav>` element that contains
    an unordered list. For each page, add a new list item with a `router-link` element
    inside. Add a `to` attribute to the link path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Viewing the app in the browser should show your two links, allowing you to switch
    between the two content pages. You will also notice that, by clicking the link,
    the URL updates too.
  prefs: []
  type: TYPE_NORMAL
- en: If you inspect the links with the browser's HTML inspector, you will notice
    the change in CSS classes. The Home link will always have a class of `router-link-active—`this
    is because it is either active itself, or it has an active child, such as the
    About page. There is another CSS class which gets added and removed as you navigate
    between the two pages—`router-link-exact-active`. This *only* gets applied to
    the links on the currently active page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s customize the classes that get applied to the view. Head to the initialization
    of the router in your JavaScript and add two new keys to the object - `linkActiveClass`
    and `linkExactActiveClass`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The keys should be fairly self-explanatory, but `linkExactActiveClass` gets
    applied to the current page, the one being viewed, while `linkActiveClass` is
    the class that gets applied when the page, or one of its children, is active.
  prefs: []
  type: TYPE_NORMAL
- en: Linking to sub-routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There may be times you want to have links to children pages. For example `/about/meet-the-team`.
    Fortunately, there is not much work required to get this working. Create a new
    object in the `routes` array, pointing to a new component with a template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When navigating to this page, you will notice both the Home and About links
    have the `active` class and neither have the `current` class we created. If you
    were to create a link in your navigation to this page, a `current` class would
    be applied to that.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic routes with parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vue router easily allows you to have dynamic URLs. A dynamic URL allows you
    to use the same component to display different data while using the same template.
    An example of this would be for a shop, where all the category pages look the
    same but display different data based on the URL. Another example would be a product
    detail page—you don't want to have to create a component for every product, so
    instead, you use one component with a URL parameter.
  prefs: []
  type: TYPE_NORMAL
- en: URL parameters can appear anywhere in the path, and there can be one or many.
    Each parameter gets assigned a key, so it can be created and accessed consistently.
    We'll go into dynamic routes and parameters in more detail during Chapter 9, *Using
    Vue-Router Dynamic Routes to Load Data*. For now, we'll build a basic example.
  prefs: []
  type: TYPE_NORMAL
- en: Before we head into creating the component, let's examine a new variable available
    to us—`this.$route`.  In a similar way to how we accessed the global store with
    Vuex, this variable allows us to access a lot of information about the routes,
    URLs, and parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your Vue instance, as a test, add a `mounted()` function. Inside `console.log`,
    insert the `this.$route` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you open up your browser and look at the developer tools, you should see
    an object being output. Viewing this object will reveal several bits of information,
    such as the path and the components which match the current path. Heading to the
    `/about` URL will reveal different information about the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7dc8379e-4c58-4733-b535-4ba77c32c3a3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s create a component that uses the parameters from this object. Create
    a new object in your routes array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The thing you'll notice that is different with this path is the colon preceding
    the `name` in the path. This tells Vue-router that this part of the URL is dynamic,
    but the variable name for that section is `name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now create a new component called `User`, and create a template for it. For
    this example, our template will be inline and we will be using the ES2015 template
    syntax. This uses backticks and allows the passing of variables and new lines
    directly into the template without the need to escape them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The variable being output within the template is from the global router instance
    and is the `name` variable within the parameters object. The variable `name` references
    the variable preceded by the colon in the route path, within the `routes` array.
    Within the component template, we can also omit `this` variable from the `$route`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Head back to your browser and enter `#/user/sarah` at the end of your URL.
    You should see Hello sarah in the main body of your web page. Viewing the JavaScript
    browser console, you should see the `params` object has a key/value pair of `name:
    sarah` within it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4a642ae5-1ec3-4b35-9d77-815766ecf654.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This variable is also available to us within the component itself. For example,
    if we wanted to capitalize the first letter of our user''s name, we could make
    a computed variable which takes the route parameter and transforms it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If you're not familiar with what the preceding code is doing, it takes the first
    character of the string and makes it uppercase. It then splits the string after
    the first character (that is, the rest of the word) and appends it on the uppercase
    letter.
  prefs: []
  type: TYPE_NORMAL
- en: Adding this `computed` function and refreshing the app will yield Hello sarah.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, the route can accept as many parameters as you want and can be
    separated by static or dynamic variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changing the path to the following (while keeping the component name the same):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Would mean you would need to go to `/sarah/user/happy` to see the user component.
    You would, however, have access to a new parameter titled `emotion`, which means
    you could use the following template to render sarah is happy!:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Dynamic routes will come in handy when we come to build our shop over the next
    few chapters, as we'll be using it for both products and categories.
  prefs: []
  type: TYPE_NORMAL
- en: GET parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Along with the dynamic routes, Vue-router handles GET parameters in a really
    simple way. GET parameters are extra URL parameters you can pass to a web page
    that appear as key/value pairs. With GET parameters, the first one is preceded
    by a `?`—this tells the browser to expect parameters. Any further parameters are
    separated by an ampersand. An example would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This URL would yield `sarah` as the value of `name` and `happy` as the value
    for `emotion`. They are normally used for filtering or search—next time you search
    for something on Google, take a look at the URL and you will notice `?q=Your+search+query`
    in the address bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Vue router makes these parameters available to the developer within the `query`
    object in the `this.$route` variable. Try adding `?name=sarah` to the end of your
    URL and opening the JavaScript developer tool. Inspecting the query object will
    reveal an object with `name` as the key and `sarah` as the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/456ca4d1-ec7e-4ea7-9dc1-9016bb558e65.png)'
  prefs: []
  type: TYPE_IMG
- en: We'll be using the query object when we build the filtering in our shop categories.
  prefs: []
  type: TYPE_NORMAL
- en: Using props
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although using router parameters directly within the component works perfectly
    fine, it is not good practice as it ties the component directly to the route.
    Instead, `props` should be used—in the same way, we used them earlier in the book
    for HTML components. When enabled and declared, the parameter passed in via the
    URL becomes available to use as though it had been passed in via an HTML attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Using props for your route component is a better way to pass options and parameters
    into your route, as it has many benefits. Firstly, it decouples the component
    from a specific URL structure—as you'll see, we can pass props straight to the
    component itself. It also helps make your route component clearer; the incoming
    parameters are clearly laid out within the component itself, and the code is cleaner
    throughout the component.
  prefs: []
  type: TYPE_NORMAL
- en: Props only work with the dynamic routes—GET parameters would still be accessed
    with the preceding technique.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the preceding example, declare the `props` for both the `name` and `emotion`
    parameters. When using props with a URL-based variable, you will want to use the
    `String` data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We now have `this.name` available to us twice—through the `props` and through
    the computed value. However, as we have `this.name` and `this.emotion` via the
    `props`, we can update our component to use these variables, rather than the `$route`
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid conflicts with the prop, update the computed function to be called
    `formattedName()`. We can also remove the variable declaration from the function,
    as the new variable is a lot more readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Before the `props` work, Vue-router needs to be told to use them with a particular
    route. This is enabled within the `routes` array, on a route-by-route basis and,
    initially, is set with a `props: true` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Setting prop defaults
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the route parameters now available as `props`, this gives us the flexibility
    of easily creating a default. If we had wanted to make a parameter optional, we
    would have needed to add several `if()` statements to check the existence of the
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'With props, however, we can declare defaults as we did earlier. Add a default
    for the emotion variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now create a new route within our router, which uses the same component
    without the final variable. Don''t forget to enable `props` for the new route
    too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now, by visiting `/sarah/user`, we should be presented with text that declares
    sarah is happy.
  prefs: []
  type: TYPE_NORMAL
- en: Using static props
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Along with a Boolean value, the props parameter in the route can also accept
    an object with a list of the props to pass. This allows you to utilize the same
    component and alter its state based on the URL, without requiring the variables
    to be passed via the path for example, if you want to activate or deactivate part
    of the template.
  prefs: []
  type: TYPE_NORMAL
- en: When passing the props object in via the URL, it overwrites the whole props
    object, meaning you either have to declare none or all of them. The props variables
    will also take priority over the dynamic, URL-based variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update your new `/:name/user` path to include the `props` in the route - remove
    the `:name` variable from the path so it becomes just `/user`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Navigating to `/user` should reveal the same sentence as we had before. Passing
    `props` "behind the scenes" (not using the URL) is ideal in some scenarios where
    you may not want the user to share the specific URL or alter the app's state based
    on easily altered parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Nested routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nested routes differ from sub-routes as they exist *within* a component already
    matching the beginning part of a route. This allows you to show different content
    within an existing view.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good example of this would be Twitter. If you visit a Twitter user''s profile
    page, you are able to view who they are following, who follows them, and what
    lists they''ve created. If you observe the URL while you navigate through the
    pages, you will notice a recurring pattern: the username followed by the different
    page. The difference between nested routes and sub-routes is that nested routes
    allow you to keep components the same throughout the different sub-pages (for
    example, the header and sidebar).'
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of this are that the user can bookmark and share the link, it
    makes the page more accessible, and is good for SEO reasons. None of these advantages
    could be easily achieved using simple toggle or tab boxes to show different content
    in the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'To reproduce the Twitter pattern into a Vue route, it would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If we were to create this with the previous route method, we would have to build
    components for each page which contain the header and user information in the
    sidebar in their templates—that would be a pain if you needed to update the code!
  prefs: []
  type: TYPE_NORMAL
- en: Let's make some nested routes for our About page. We won't be using nested routes
    in our shop app, but it's important to understand the capabilities of Vue router.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create two new components—`AboutContact`, which will display contact information,
    and `AboutFood`, a component that will detail the food you like to eat! Although
    not required, it''s a good idea to keep a reference to the parent component (in
    this case, About) in the component name—this ties together the components when
    you come to look at them later on! Give each component a template with some fixed
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to create the placeholder in your `#about` template for the
    nested routes to render in. The element is exactly the same as one we''ve seen
    before—the `<router-view>` element. To demonstrate that this can be placed anywhere,
    add it between two paragraphs in your template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Viewing the About page in the browser won't render anything, nor will it break
    the app. The next step is to add the nested routes for these components to the
    router. Rather than adding them to the top level `routes` array, we create an
    array inside the `/about` route—with the key of `children`. The syntax of this
    array is an exact replica of the main array—that is, an array of route objects.
  prefs: []
  type: TYPE_NORMAL
- en: Add an object for each of the `routes` containing the `path` and `component`
    keys. The thing to note about the path is that it shouldn't start with a `/` if
    you want the path to be added to the end of the parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you wanted the URL to be `/about/contact` to render the `AboutContact`
    component, you would make the route component like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you wanted the URL to be simply `/contact`, but still render the
    `AboutContact` component inside the `About` component, you could add the preceding
    slash. Try viewing the app without the slash, and then with it added, to see the
    difference it makes. If you wanted a sub-route to show when the parent is loaded
    without a second part of the URL, you would use an empty path—`path: ''''`.'
  prefs: []
  type: TYPE_NORMAL
- en: For now, leave it without the slash and add the preceding `children` array.
    Head to your browser and navigate to the About page. Add `/contact` or `/food`
    to the end of the URL, and notice the new content appear in place of the `<router-link>`
    element you added to the template earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Links can be created to these components from anywhere, in the same fashion
    that you linked the Home and About pages. You can either add them to the `about`
    template, so they only appear when that page has been navigated to, or add them
    to the main navigation in your app view.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a 404 page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building an app or website, despite all good intentions, problems, issues,
    and mistakes do happen. For this reason, it's a good idea to have error pages
    in place. The most common page would be a 404 page—a message displayed when a
    link is incorrect or a page has moved. 404 is the official HTTP code for page
    not found.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, Vue-router will match the routes based on a first-come-first-served
    principle. We can use this to our advantage by using a wildcard (`*`) character
    as the last route. As the wildcard matches *every *route, only URLs which have
    not matched a previous route will be caught by this one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new component titled `PageNotFound` with a simple template, and add
    a new route which uses the wildcard character as the path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Open the app up in the browser and type anything at the end of the URL (except
    `about`) and press *Enter*—you should be presented with the 404 heading.
  prefs: []
  type: TYPE_NORMAL
- en: Although this is simulating a page not found request, it is not actually sending
    the correct HTTP code to the browser. If you are using a Vue web app in production
    it is a good idea to set up server-side error checking, so in the instance of
    an incorrect URL the browser can be correctly notified.
  prefs: []
  type: TYPE_NORMAL
- en: Naming components, routes, and views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding names to your routes and components is not required when using `Vue-router`,
    but is good practice to do so and a good habit to get into.
  prefs: []
  type: TYPE_NORMAL
- en: Naming components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Components with names allow you to debug your errors more easily. In Vue, when
    a JavaScript error is thrown from a component, it will give you the name of that
    component, rather than listing `Anonymous` as the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this would be if you tried to output a variable of `{{ test }}`
    in the food component—one that isn''t available. By default, a JavaScript console
    error would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/347a8709-6e4e-4b4a-9355-8d11bcbb4002.png)'
  prefs: []
  type: TYPE_IMG
- en: Note the two `<Anonymous>` components in the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'By adding names to our components, we can easily identify where the problem
    lies. Names have been added to both the `About` and `AboutFood` components in
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/143646ff-e373-42ac-ace2-b2e48a68ae04.png)'
  prefs: []
  type: TYPE_IMG
- en: You can easily see the error is in the `<AboutFood>` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a name to a component is as simple as adding a key of name to your object,
    with the name as the value. These names adhere to the same rules as to when we
    were creating our HTML element components: no spaces, but hyphens and letters
    are allowed. To allow me to quickly identify the code, I chose to name my component
    the same as the variable defining it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Naming routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another object you are able to name when using `VueRouter` is the route itself.
    This gives you the ability to simplify a route's location and update the path,
    without needing to find and replace all the instances in the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `name` key to your `routes`, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now use that name when creating your `router-link` component, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the colon before the `to` attribute. This ensures the contents are parsed
    as an object, not a literal string. Another advantage of using named routes is
    being able to pass specific attributes to our dynamic paths. Using the example
    from earlier in this chapter, we can build the URL in a programmatic way, abstracting
    the data away from the path construction. This is where named `routes` really
    come into their own. Say we had the following path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to pass in a name and emotion variable to the URL for the component
    to render. We can pass in as we did before, directly to the URL or, alternatively,
    use the `to` object notation with a named route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Viewing this in the browser will show the anchor link has been generated correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the flexibility to rearrange the URL, using the variables, without
    needing to update the rest of the app. If you wanted to pass parameters at the
    end of the URL (for example, `?name=sarah`), the `params` key can be changed to
    `query`, as it follows the same format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'With the path reconfigured not to accept parameters, it will generate the following
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Be careful when interchanging `params` and `query` - as they can affect whether
    you use `path` or `name`. When using `path`, the `params` object will be ignored,
    whereas the `query` one will not. To use the `params` object, you need to use
    a named route. Alternatively, pass the parameters into the `path` with the `$`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Named views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vue router also allows you to name the views, letting you pass in different
    components to different sections of the app. An example of this might be a shop,
    where you have a sidebar and main content area. Different pages may utilize these
    areas in different ways.
  prefs: []
  type: TYPE_NORMAL
- en: The About page may use the main content to show the About content while using
    the sidebar to show contact details. The shop page, however, will use the main
    content to list the products and the sidebar for displaying the filters.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, create a second `router-view` element as a sibling to your original
    one. Leave the original one in place, but add a `name` attribute to the second,
    with an appropriate title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: When declaring your routes in the router instance, we are now going to use a
    new key, `components`, and remove the previous singular `component` key. This
    accepts an object with key-value pairs of the name of the view and the name of
    the component.
  prefs: []
  type: TYPE_NORMAL
- en: It's advisable to leave your main route unnamed, so you don't need to update
    every route. If you decide to name your main route, you would be required to do
    this next step for every route in your app.
  prefs: []
  type: TYPE_NORMAL
- en: Update the `About` route to use this new key and make it into an object. The
    next step is to tell the code where each component will go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using default as the key, set the `About` component as the value. This puts
    the content from the About component in your unnamed `router-view`, the main one.
    This is also what using the singular `component` key is shorthand for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add a second key-value, specifying the name of the second router-view,
    `sidebar`. Name the component you want to populate this area when the `/about` URL is
    navigated to. For this, we will use the `AboutContact` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Running the app in your browser will render both components, with the contents
    of the contact component appearing in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: Programmatically navigating with, redirecting, and adding an alias
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While building your app, there may be situations that require some different
    navigation techniques. These may be navigating programmatically, for example in
    a component or the main Vue instance, redirecting users when they hit a specific
    URL, or loading the same component with various URLs.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating programmatically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may want to alter the path, URL, or user flow from the code, a component,
    or action. An example of this might be sending the user to the basket after they've
    added an item.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, you use a `push()` function on the router instance. The value of
    push can either be a string for a direct URL or it can accept an object to pass
    named routes or route parameters. The allowed contents of the `push` function
    are exactly the same as the `to=""` attribute on the `router-link` element. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you could direct to a named route with parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Redirecting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Redirecting using `VueRouter` is fairly straightforward. An example of a redirect
    might be if you move your `/about` page to the `/about-us` URL. You will want
    to redirect the first URL to the second, in case anyone has shared or bookmarked
    your link, or in case a search engine has cached the URL.
  prefs: []
  type: TYPE_NORMAL
- en: You may be tempted to create a basic component which, when created, uses the
    `router.push()` function to send the user to the new URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, you can add a route and specify the redirect within that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Once again, the contents of the redirect key can be a literal string or an object—much
    like the `push()` function. With the preceding, if the user visits `/about`, they
    will instantly be redirected to `/about-us` and the `About` component shown.
  prefs: []
  type: TYPE_NORMAL
- en: Alias routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There may be circumstances where you want to show the same component under two
    URLs. Although not recommended as standard practice, there are some edge cases
    where this is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'The alias key gets added to an existing route and accepts just a string of
    the path. Using the preceding example, the following will show the `About` component,
    whether the user visits `/about` or `/about-us`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should now be familiar with Vue-router, how to initialize it, what options
    are available, and how to create new routes—both static and dynamic. In the next
    few chapters, we'll begin creating our shop, starting with loading some shop data
    and creating a product page.
  prefs: []
  type: TYPE_NORMAL
