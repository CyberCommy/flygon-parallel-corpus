- en: Reactive Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed implementing typical data flow use cases
    with microservices using Spring cloud data flow.
  prefs: []
  type: TYPE_NORMAL
- en: Functional Programming marks a shift from traditional imperatives to a more
    declarative style of programming. Reactive programming builds on top of functional
    programming to provide an alternative style.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss the basics of reactive programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'The microservice architecture promotes message-based communication. One important
    tenet of reactive programming is building applications around events (or messages).
    Some of the important questions we need to answer include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What is reactive programming?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the typical use cases?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What kind of support does Java provide for it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the reactive features in Spring WebFlux?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Reactive Manifesto
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most applications from a few years back had the luxury of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Multi-second response times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple hours of offline maintenance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smaller volumes of data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Times have changed. New devices (mobiles, tablets, and so on) and newer approaches
    (cloud-based) have emerged. In today''s world, we are talking about:'
  prefs: []
  type: TYPE_NORMAL
- en: Sub-second response times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 100% availability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An exponential increase in data volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different approaches have emerged during the last few years to meet these emerging
    challenges. While reactive programming is not really a new phenomenon, it is one
    of the approaches that have been successful in dealing with these challenges.
  prefs: []
  type: TYPE_NORMAL
- en: The Reactive Manifesto ([http://www.reactivemanifesto.org](http://www.reactivemanifesto.org))
    aims to capture common themes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We believe that a coherent approach to systems architecture is needed, and
    we believe that all necessary aspects are already recognised individually: we
    want systems that are Responsive, Resilient, Elastic and Message Driven. We call
    these Reactive Systems.'
  prefs: []
  type: TYPE_NORMAL
- en: Systems built as Reactive Systems are more flexible, loosely coupled, and scalable.
    This makes them easier to develop and amenable to change. They are significantly
    more tolerant of failure, and when failure does occur, they meet it with elegance
    rather than disaster. Reactive Systems are highly responsive, giving users effective
    interactive feedback.
  prefs: []
  type: TYPE_NORMAL
- en: While the Reactive Manifesto clearly states the characteristics of responsive
    systems, it is not as clear on how Reactive Systems are built.
  prefs: []
  type: TYPE_NORMAL
- en: Characteristics of Reactive Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following figure shows the important characteristics of Reactive Systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d3c539b-22ee-49c8-a5e4-6b23bd5a740c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The important characteristics are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Responsive**: Systems respond in a timely manner to their users. Clear response
    time requirements are set, and the system meets them in all situations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resilient**: Distributed systems are built using multiple components. Failures
    can occur in any of these components. Reactive Systems should be designed to contain
    failures within a localized space, for example, within each component. This prevents
    the entire system from going down in cases of local failure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Elastic**: Reactive Systems stay responsive under varying loads. When under
    heavy load, these systems can add additional resources while releasing them when
    the load goes down. Elasticity is achieved using commodity hardware and software.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message driven**: Reactive Systems are driven by messages (or events). This
    ensures low coupling between components. This guarantees that the different components
    of the system can be scaled independently. Using non-blocking communication ensures
    that threads are alive for a shorter period of time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reactive Systems are responsive to different kinds of stimulus. A few examples
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**React to events**: Built based on message passing, Reactive Systems respond
    quickly to events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**React to load**: Reactive Systems stay responsive under varying loads. They
    use more resources under high loads and release them under lesser loads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**React to failures**: Reactive Systems can handle failures gracefully. Components
    of Reactive Systems are built to localize failures. External components are used
    to monitor the availability of components and have the capability to replicate
    components when needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**React to users**: Reactive Systems are responsive to users. They do not waste
    time performing additional processing when consumers are not subscribed to specific
    events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive use case - a stock price page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the Reactive Manifesto helps us understand the characteristics of a Reactive
    System, it does not really help with understanding how Reactive Systems are built.
    To understand this, we will consider the traditional approach to building a simple
    use case and compares it with the reactive approach.
  prefs: []
  type: TYPE_NORMAL
- en: The use case we want to build is a stock price page that displays the price
    of a specific stock. As long as the page remains open, we want to update the latest
    price of the stock on the page.
  prefs: []
  type: TYPE_NORMAL
- en: The traditional approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The traditional approach uses polling to check whether the stock price has
    changed. The following sequence diagram shows the traditional approach of building
    such a use case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e04c7836-703e-4344-a494-edd4c03f1f71.png)'
  prefs: []
  type: TYPE_IMG
- en: Once the page is rendered, it sends AJAX requests to the stock price service
    for the latest price at regular intervals. These calls have to be done irrespective
    of whether the stock price has changed since the web page does not have any knowledge
    of the stock price change.
  prefs: []
  type: TYPE_NORMAL
- en: The reactive approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactive approaches involve connecting the different components involved to
    be able to react to events as they occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the stock price web page is loaded, the web page registers for events
    from the stock price service. When the stock price change event occurs, an event
    is triggered. The latest stock price is updated on the web page. The following
    sequence diagram shows the reactive approach of building the stock price page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/47c7ae5a-4b29-4a4c-b5f7-276764b31395.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The reactive approach typically involves three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Subscribing to events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Occurrence of events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unregistering.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the stock price web page is initially loaded, it will subscribe to the
    stock price change event. The way you subscribe is different based on the reactive
    framework and/or the message broker (if any) that you use.
  prefs: []
  type: TYPE_NORMAL
- en: When the stock price change event for a specific stock occurs, a new event is
    triggered for all the subscribers of the event. The listener ensures that the
    web page is updated with the latest stock price.
  prefs: []
  type: TYPE_NORMAL
- en: Once the web page is closed (or refreshed), an unregister request is sent out
    by the subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison between the traditional and reactive approaches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The traditional approach is very simple. The reactive approach needs to implement
    a reactive subscribe and event chain. If the event chain involves a message broker,
    it becomes even more complex.
  prefs: []
  type: TYPE_NORMAL
- en: In the traditional approach, we poll for changes. This means that the entire
    sequence is triggered every minute (or the specified interval) irrespective of
    whether there is a change in the stock price. In the reactive approach, once we
    register for the event, the sequence is triggered only when the stock price changes.
  prefs: []
  type: TYPE_NORMAL
- en: The lifetime of the threads in the traditional approach is longer. All resources
    used by the thread are locked for a longer duration. Considering the big picture
    of a server serving multiple requests at the same time, there will be more contention
    for threads and their resources. In the reactive approach, threads live for a
    short span and hence there is less contention for resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scaling in the traditional approach involves scaling up the database and creating
    more web servers. Because of the small lifetime of threads, the same infrastructure
    can handle more users in the reactive approach. While the reactive approach has
    all the options of scaling of the traditional approach, it provides more distributed
    options. For example, the triggering of the stock price change event can be communicated
    to the application through a message broker, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/35f65ad1-5374-4f11-ae12-452937d91766.png)'
  prefs: []
  type: TYPE_IMG
- en: This means that the web application and the stock price change-triggered application
    can be scaled independently of each other. This gives more options in scaling
    up quickly when the need arises.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java 8 does not have any built-in support for reactive programming. A number
    of frameworks provide reactive features. We will discuss Reactive Streams, Reactor,
    and Spring WebFlux in subsequent sections.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactive Streams is an initiative to provide a standard for asynchronous stream
    processing with non-blocking back pressure. This encompasses efforts aimed at
    runtime environments (JVM and JavaScript) as well as network protocols.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Reactive streams aim to define a minimal set of interfaces, methods, and protocols
    to enable reactive programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive streams aim to be a language-neutral approach with implementation in
    the Java (JVM-based) and JavaScript languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple transport streams (TCP, UDP, HTTP, and WebSockets) are supported
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Maven dependencies for Reactive Streams are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A few of the important interfaces defined in Reactive Streams are shown as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A few important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Interface Publisher**: `Publisher` provides a stream of elements in response
    to the demand received from its Subscriber(s). A Publisher can serve any number
    of subscribers. The subscriber count might vary with time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface Subscriber** : `Subscriber` registers to listen to the stream of
    events. Subscribing is a two-step process. The first step is calling Publisher.subscribe(Subscriber).
    The second step involves making a call to Subscription.request(long). Once these
    steps are completed, the subscriber can start processing notifications using the
    `onNext(T t)` method. The `onComplete()` method signals the end of notifications.
    Demand can be signaled via Subscription.request(long) whenever the `Subscriber`
    instance is capable of handling more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface Subscription** : `Subscription` represents the link between one
    `Subscriber` and its `Publisher`. A subscriber can request more data using `request(long
    n)`. It can cancel the subscription to notifications using the `cancel()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactor is a reactive framework from the Spring Pivotal team. It builds on top
    of Reactive Streams. As we will discuss later in this chapter, Spring Framework
    5.0 uses the Reactor framework to enable reactive web features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dependencies for Reactor are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Reactor adds in a couple of important things on top of the `Subscriber`, `Consumer`,
    and `Subscriptions` terminology introduced by Reactive Streams.
  prefs: []
  type: TYPE_NORMAL
- en: '**Flux**: Flux represents a Reactive Stream that emits 0 to *n* element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mono**: Mono represents a Reactive Stream that emits either no elements or
    one element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In subsequent examples, we will create stub Mono and Flux objects, which would
    be pre-configured to emit elements at specific intervals. We will create Consumers
    (or Observers) to listen to these events and react to them.
  prefs: []
  type: TYPE_NORMAL
- en: Mono
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a Mono is very simple. The following Mono emits one element after a
    delay of 5 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to listen to the events from Mono and log them to the console. We can
    do that using the statement specified here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you run the program with the two preceding statements in a `Test`
    annotation as shown in the following code, you would see that nothing is printed
    to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing is printed to the console because the `Test` execution ends before
    the Mono emits the element after 5 seconds. To prevent this, let''s delay the
    execution of `Test` using `Thread.sleep`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When we create a subscriber using `stubMonoWithADelay.subscribe(System.out::println)`,
    we are using the functional programming feature introduced in Java 8\. `System.out::println`
    is a method definition. We are passing the method definition as a parameter to
    a method.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is possible because of a specific functional interface called `Consumer`.
    A functional interface is an interface with only one method. The `Consumer` functional
    interface is used to define an operation that accepts a single input argument
    and returns no result. An outline of the `Consumer` interface is shown in the
    following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of using a lambda expression, we can explicitly define `Consumer` as
    well. The following code snippet shows the important details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'A couple of important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`class SystemOutConsumer implements Consumer<String>`: We create a `SystemOutConsumer`
    class that implements the functional interface `Consumer`. The type of input is
    `String`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public void accept(String t)`: We define the accept method to print the content
    of the string to the console.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stubMonoWithADelay.subscribe(new SystemOutConsumer())`: We create an instance
    of `SystemOutConsumer` to subscribe the events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b65fe68-87d9-492d-92c8-e84f58c56aa0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can have multiple subscribers listening on events from a Mono or Flux. The
    following snippet shows how we can create an additional subscriber:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'A couple of important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`class WelcomeConsumer implements Consumer<String>`: We are creating another
    Consumer class, `WelcomeConsumer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stubMonoWithADelay.subscribe(new WelcomeConsumer())`: We are adding an instance
    of `WelcomeConsumer` as a subscriber to the events from Mono'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7891d557-00d5-4703-8345-60f1c0a992c7.png)'
  prefs: []
  type: TYPE_IMG
- en: Flux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Flux represents a reactive stream emitting 0 to *n* elements. The following
    snippet shows a simple Flux example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'A couple of important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Flux<String> stubFluxStream = Flux.just("Jane", "Joe")`: We are creating a
    Flux using the `Flux.just` method. It can create simple streams with hardcoded
    elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stubFluxStream.subscribe(new SystemOutConsumer())`: We are registering an
    instance of `SystemOutConsumer` as a subscriber on Flux.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f724d985-4bd0-47c0-8f7e-d1557589bc63.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following snippet shows a more complex example of a Flux with two subscribers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'A few important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Flux.fromIterable(streamOfNames).delayElements(Duration.ofMillis(1000))`:
    Creates a Flux from the specified list of strings. Elements are emitted at the
    specified delay of 1000 milliseconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stubFluxWithNames.subscribe(new SystemOutConsumer())` and `stubFluxWithNames.subscribe(new
    WelcomeConsumer())`: We are registering two subscribers on Flux.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Thread.sleep(10000)`: Similar to the first Mono example, we introduce sleep
    to make the program wait until all elements from the Flux are emitted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b955cd0f-3580-4d92-8759-2b6755b67939.png)'
  prefs: []
  type: TYPE_IMG
- en: Spring Web Reactive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Spring Web Reactive** is one of the important new features in Spring Framework
    5\. It brings in reactive capabilities for web applications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Web Reactive is based on the same fundamental programming model as Spring
    MVC. The following table provides a quick comparison of the two frameworks:'
  prefs: []
  type: TYPE_NORMAL
- en: '| . | **Spring MVC** | **Spring Web Reactive** |'
  prefs: []
  type: TYPE_TB
- en: '| **Use** | Traditional web application | Reactive web applications |'
  prefs: []
  type: TYPE_TB
- en: '| **Programming Model** | `@Controller` with `@RequestMapping` | The same as
    Spring MVC |'
  prefs: []
  type: TYPE_TB
- en: '| **Base API** | The Servlet API | Reactive HTTP |'
  prefs: []
  type: TYPE_TB
- en: '| **Runs on** | Servlet Containers | Servlet Containers(>3.1), Netty, and Undertow
    |'
  prefs: []
  type: TYPE_TB
- en: In the subsequent steps, we want to implement a simple use case for Spring Web
    Reactive.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the important steps involved:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a project using Spring Initializr
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Reactive Controller returning an event stream (Flux)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an HTML view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a project using Spring Initializr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with creating a new project using Spring Initializr ([http://start.spring.io/](http://start.spring.io/)).
    The following screenshot shows the details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/52db8feb-2324-4a34-b015-2a5662b71f89.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A few things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Group: `com.mastering.spring.reactive`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Artifact: `spring-reactive-example`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dependencies : `ReactiveWeb` (to build a reactive web application) and `DevTools`
    (for auto-reload when the application code is changed)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Download the project and import it into your IDE as a Maven project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important dependencies in the `pom.xml` file are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `spring-boot-starter-webflux` dependency is the most important dependency
    for Spring Web Reactive. A quick look at the `pom.xml` file of `spring-boot-starter-webflux`
    reveals the building blocks of Spring Reactive--`spring-webflux`, `spring-web`,
    and `spring-boot-starter-reactor-netty`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Netty** is the default embedded reactive server. The following snippet shows
    the dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Creating a Reactive Controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating a Spring Reactive Controller is very similar to creating a Spring
    MVC Controller. The basic constructs are the same: `@RestController` and the different
    `@RequestMapping` annotations. The following snippet shows a simple reactive controller
    named `StockPriceEventController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'A few important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@RestController and @GetMapping("/stocks/price/{stockCode}")`: Basic constructs
    are the same as Spring MVC. We are creating a mapping to the specified URI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Flux<String> retrieveStockPriceHardcoded(@PathVariable("stockCode") String
    stockCode)`: Flux represents a stream of 0 to *n* elements. The return type `Flux<String>`
    indicates that this method returns a stream of values representing the current
    price of a stock.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Flux.interval().map(l -> getCurrentDate() + " : " + getRandomNumber(100, 125))`:
    We are creating a hardcoded Flux returning a stream of random numbers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Duration.ofSeconds(5)`: Stream elements are returned every 5 seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Flux.<<****>>.log()`: Invoking the `log()` method on Flux helps observe all
    Reactive Streams signals and trace them using Logger support.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private String getCurrentDate()`: Returns the current time as a string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private int getRandomNumber(int min, int max)`: Returns a random number between
    `min` and `max`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an HTML view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous step, Creating a Reactive Controller, we mapped a Flux stream
    to the `"/stocks/price/{stockCode}"` URL. In this step, let's create a view to
    show the current value of the stock on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a simple static HTML page (`resources/static/stock-price.html`)
    with a button to start retrieving from the stream. The following snippet shows
    the HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to create a JavaScript method to register with the stream and append
    new elements to a specific div. The following snippet shows the JavaScript method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `EventSource` interface is used to receive server-sent events. It connects
    to a server over HTTP and receives events in a text/event-stream format. When
    it receives an element, the `onmessage` method is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows the code to register the onclick event for the
    get latest IBM price button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Launching SpringReactiveExampleApplication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Launch the application class `SpringReactiveExampleApplication` as a Java application.
    One of the last messages you would see in the startup log is `Netty started on
    port(s): 8080`. Netty is the default embedded server for Spring Reactive.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the browser when you navigate to the `localhost:8080/static/stock-price.html`
    URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e5a1fb94-6573-425e-a03e-2efad2b35747.png)'
  prefs: []
  type: TYPE_IMG
- en: When the Get Latest IBM Price button is clicked, `EventSource` kicks in and
    registers for events from `"/stocks/price/IBM"`. As soon as an element is received,
    it is shown on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the screen after a few events are received.
    You can observe that an event is received every 5 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/25d0acd5-4d9f-44b8-b61d-1dc74e9bc9ad.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next screenshot shows an extract from the log after the browser window
    is closed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f6cdc3b3-48f9-4155-b2e3-364ead91bfa5.png)'
  prefs: []
  type: TYPE_IMG
- en: You can observe a sequence of `onNext` method calls, which are triggered as
    soon as the element is available. When the browser window is closed, the `cancel()`
    method is called to terminate the stream.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we created a controller returning an event stream (as `Flux`)
    and a web page registering to the event stream using `EventSource`. In the next
    example, let's take a look at extending the reach of an event stream to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All normal databases operations are blocking; that is, the thread waits until
    a response is received from the database.
  prefs: []
  type: TYPE_NORMAL
- en: To fully benefit from Reactive Programming, end-to-end communication has to
    be reactive, that is, based on event streams.
  prefs: []
  type: TYPE_NORMAL
- en: '**ReactiveMongo** is designed to be reactive and avoid blocking operations.
    All operations, including select, update, or delete, return immediately. Data
    can be streamed into and out of the database using event streams.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will use the Spring Boot Reactive MongoDB starter to create
    a simple example connecting to ReactiveMongo.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps are involved:'
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Spring Boot Reactive MongoDB Starter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a model object the stock document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating `reactiveCrudRepository`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialising stock data using Command-line Runner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating Reactive methods in Rest Controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updating the view to subscribe to the event stream.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Integrating Spring Boot Reactive MongoDB Starter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To connect to the ReactiveMongo database, Spring Boot provides a starter project--Spring
    Boot Reactive MongoDB Starter. Let''s add this to our the `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `spring-boot-starter-data-mongodb-reactive` starter brings in the `spring-data-mongodb`,
    `mongodb-driver-async`, and `mongodb-driver-reactivestreams` dependencies. The
    following snippet shows the important dependencies in the `spring-boot-starter-data-mongodb-reactive`
    starter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `EnableReactiveMongoRepositories` annotation enables ReactiveMongo features.
    The following snippet shows it being added to the `SpringReactiveExampleApplication`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Creating a model object - a stock document
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create the `Stock` document class, as shown in the following code.
    It contains three member variables--`code`, `name`, and `description`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Creating a ReactiveCrudRepository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Traditional Spring Data Repositories are blocking. Spring Data introduces a
    new repository for interaction with reactive databases. The following code shows
    some of the important methods declared in the `ReactiveCrudRepository` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: All the methods in the preceding interface are non-blocking. They return either
    Mono or Flux, which can be used to retrieve elements when events are triggered.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to create a Repository for the Stock Document object. The following
    snippet shows the definition of `StockMongoReactiveCrudRepository`. We extend
    `ReactiveCrudRepository` with `Stock` as the document being managed and a key
    of type `String`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Initialising stock data using the Command Line Runner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s use the Command-line Runner to insert some data into ReactiveMongo.
    The following snippet shows the details added to `SpringReactiveExampleApplication`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `mongoRepository.save()` method is used to save the `Stock` document to
    ReactiveMongo. The `block()` method ensures that the save operation is completed
    before the next statement is executed.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Reactive methods in Rest Controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can now add in the controller methods to retrieve details using `StockMongoReactiveCrudRepository`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'A few important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`private final StockMongoReactiveCrudRepository repository`: `StockMongoReactiveCrudRepository`
    is injected in using the constructor injection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@GetMapping("/stocks") Flux<Stock> list()`: Exposes a `GET` method to retrieve
    a list of stocks. Returns a Flux indicating that this would be a stream of stocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@GetMapping("/stocks/{code}") Mono<Stock> findById(@PathVariable("code") String
    code)`: `findById` returns a Mono, indicating that it would return 0 or 1 stock
    element(s).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the view to subscribe to the event stream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want to update the view with new buttons to trigger events to list all stocks
    and show the details of a specific stock. The following snippet shows the code
    to be added to `resources\static\stock-price.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following snippet enables click events on the new buttons, trigger connection
    with their respective events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Launching SpringReactiveExampleApplication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Launch MongoDB and the `SpringReactiveExampleApplication` class. The following
    screenshot shows the screen loading the page at `http://localhost:8080/static/stock-price.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/199706d3-6975-4d2b-b217-cdb3cb27bfb5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows the screen when the stock list is clicked on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ceb45db-e838-4032-9e23-feda1864ec97.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows the screen when the `Show IBM Details button`
    is clicked on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90b80425-9787-40f4-b9c4-a9fd336c9ad2.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a quick peek into the world of Reactive Programming.
    We discussed the important frameworks in the Java Reactive world--Reactive Streams,
    Reactor, and Spring Web Flux. We implemented a simple web page using event streams.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive Programming is not a silver bullet. While it might not be the correct
    option for all use cases, it is a possible option you should evaluate. Its language,
    framework support, and the use of Reactive Programming are in the initial stages
    of evolution.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will move on to discuss best practices in developing
    applications using Spring Framework.
  prefs: []
  type: TYPE_NORMAL
