- en: Web Browsing with QtWebEngine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 8](033b3f28-c471-4561-9498-8737d8a82e81.xhtml), *Networking with
    QtNetwork*, you learned how to interact with systems over a network using sockets
    and HTTP. The modern web is much more than just networking protocols, however;
    it's a programming platform built on the combination of HTML, JavaScript, and
    CSS, and working with it effectively requires a complete web browser. Fortunately
    for us, Qt provides us with the `QtWebEngineWidgets` library, which gives our
    application a full web browser in a widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to learn how to access the web with Qt in the
    following section:'
  prefs: []
  type: TYPE_NORMAL
- en: Building a basic browser with `QWebEngineView`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced `QtWebEngine` usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to the basic PyQt5 setup that we''ve used in this book, you will
    need to make sure you have the `PyQtWebEngine` package installed from PyPI. You
    can do this using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You may also want the example code for this chapter, and this is available from
    [https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter16](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter16).
  prefs: []
  type: TYPE_NORMAL
- en: Check out the following video to see the code in action: [http://bit.ly/2M5xFtD](http://bit.ly/2M5xFtD)
  prefs: []
  type: TYPE_NORMAL
- en: Building a basic browser with QWebEngineView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary class used from `QtWebEngineWidgets` is the `QWebEngineView` class;
    this class provides a nearly complete Chromium-based browser in a `QWidget` object.
    Chromium is the open source project that underpins much of Google Chrome, the
    newest versions of Microsoft Edge, and many other browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Qt also has a deprecated `QtWebKit` module based on the **Webkit** rendering
    engine used in Safari, Opera, and some older browsers. There are some significant
    differences between the API and the rendering behavior of `QtWebKit` and `QtWebEngineWidgets`,
    with the latter being preferred for newer projects.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll see how easy it is to include web content in your Qt
    application by building a simple web browser using `QtWebEngineWidgets`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the QWebEngineView widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to make a copy of our Qt application template from [Chapter 4](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml),
    *Building Applications with QMainWindow,* and call it `simple_browser.py`; we're
    going to develop a rudimentary browser with tabs and a history display.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by importing the `QtWebEngineWidgets` library as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that there is also a `QtWebEngine` module, but it is for use with the **Qt
    Modeling Language** (**QML**) declarative framework, not the Qt Widgets framework
    covered by this book. `QtWebEngineWidgets` contains the widgets-based browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `MainWindow` class constructor, we''ll start the GUI by defining a navigation
    toolbar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've defined toolbar buttons for standard browser actions, as well as
    a `QLineEdit` object for the URL bar. We've also extracted icons for these actions
    from the default style, just as we did in the *Adding toolbars* section of [Chapter
    4](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml), *Building Applications with QMainWindow*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we''ll create a `QWebEngineView`  object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: A `QWebEngineView` object is a (mostly, as you'll see) fully functional and
    interactive web widget, capable of retrieving and rendering HTML, CSS, JavaScript,
    images, and other standard web content.
  prefs: []
  type: TYPE_NORMAL
- en: 'To load a URL in the view, we pass `QUrl` to its `load()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This will prompt the web view to download and render the page just like a normal
    web browser would.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, as good as that website is, we''d like to be able to navigate to
    others, so we''ll add the following connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've connected our `go` action to a `lambda` function that retrieves
    the text of the URL bar, wraps it in a `QUrl` object, and sends it to the web
    view. If you run the script at this point, you should be able to type a URL into
    the bar, hit Go**,** and browse the web just like any other browser.
  prefs: []
  type: TYPE_NORMAL
- en: '`QWebView` has slots for all the common browser navigation actions, which we
    can connect to our navigation bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With these signals connected, our script is well on its way to being a fully
    functional web-browsing experience. However, we're currently limited to a single
    browser window; we want tabs, so let's implement that in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing multiple windows and tabs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In `MainWindow.__init__()`, delete or comment-out the web view code you just
    added (going back to the creation of the `QWebEngineView` object). We''re going
    to move that functionality to a method instead, so that we can create multiple
    web views in a tabbed interface. We will do this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, we''ll replace our `QWebEngineView` object with a `QTabWidget` object
    as our central widget:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This tab widget will have movable and closable tabs, and a New button in the
    left corner for adding new tabs.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a new tab with a web view, we''ll create an `add_tab()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This method begins by creating a web view widget and adding it to a new tab
    in the tab widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our web view object, we need to connect some signals:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `QWebEngineView` object's `urlChanged` signal is emitted whenever a new
    URL is loaded into the view, and it sends with it the new URL as a `QUrl` object.
    We're connecting this signal to a `lambda` function that sets the tab title text
    to the URL, as well as another function that sets the contents of the URL bar.
    This will keep the URL bar in sync with the browser when the user navigates using
    hyperlinks in the web page, rather than directly using the URL bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then add default content to our web view using its `setHtml()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This sets the content of the browser window to whatever HTML string we give
    to it. If we also pass a `QUrl` object, it will be used as the current URL (and
    published to the `urlChanged` signal, for example).
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable navigation, we need to connect our toolbar actions to the browser
    widget. Since our browser has one global toolbar, we can''t just directly connect
    these to the web view widgets. We''ll need to connect them to methods that pass
    the signals on to the slots in the currently active web view. Start by creating
    the callback methods as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: These methods are essentially the same as those used with the single-pane browser,
    but with one crucial change—they use the tab widget's `currentWidget()` method
    to retrieve the `QWebEngineView` object for a currently visible tab, then call
    the navigation methods on that web view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in `__init__()`, connect the following methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: For convenience and keyboard-friendliness, we've also connected the URL bar's
    `returnPressed` signal to the `on_go()` method. We've also connected our New button
    to the `add_tab()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Give the browser a try now, and you should be able to add multiple tabs and
    browse independently in each one.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a tab for pop-up windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, there is a problem with our script in that if you *Ctrl* +click on
    a hyperlink, or open a link that is configured to open a new window, nothing happens.
    By default,  `QWebEngineView` is incapable of opening new tabs or windows. In
    order to enable this, we have to override its `createWindow()` method with a function
    that creates and returns a new `QWebEngineView` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this fairly easily by updating our `add_tab()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Rather than subclassing `QWebEngineView` to override the method, we'll just
    assign our `MainWindow.add_tab()` method to its `createWindow()` method. Then
    we just need to make sure that we return the created web view object at the end
    of the method.
  prefs: []
  type: TYPE_NORMAL
- en: Note that it's not our responsibility to load the URL in the `createWindow()`
    method; we only need to create the view and add it appropriately to the GUI. Qt
    will take care of doing what needs to be done browsing-wise in the web view object
    that we return.
  prefs: []
  type: TYPE_NORMAL
- en: Now when you try the browser, you should find that a *Ctrl *+ click opens a
    new tab with the requested link.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced QtWebEngine usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we have implemented a basic, serviceable browser, it leaves much to be
    desired. In this section, we're going to explore some of the more advanced features
    of `QtWebEngineWidgets` by fixing some pain points in our user experience and
    implementing useful tools such as history and text search.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing a profile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we can view multiple tabs in our browser, there is a small problem
    in the way they work with authenticated websites. Visit any website where you
    have a login account; log in, then *Ctrl *+ click on a link within the site to
    open it in a new tab. You'll find that you aren't authenticated in the new tab.
    This can be a real problem with sites that use multiple windows or tabs to implement
    their user interface. We'd like authentication and other session data to be browser-wide,
    so let's fix this.
  prefs: []
  type: TYPE_NORMAL
- en: Session information is stored in a **profile** that is represented by a `QWebEngineProfile`
    object. This object is autogenerated for each `QWebEngineWidget` object, but we
    can override it with an object of our own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating one in `MainWindow.__init__()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We will need to associate this profile object with each new web view as we create
    them in `add_tab()`. Profiles, however, are not actually a property of the web
    view; they're the property of the web page object. The page, represented by a
    `QWebEnginePage` object, can be thought of as the *model* for the web view. Each
    web view generates its own `page` object, which acts as an interface to the browsing
    engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'To override the web view''s profile, we need to create a `page` object, override
    its profile with our own, then override the web view''s page with our new page,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The profile *must* be passed as an argument to the `QWebEnginePage` constructor,
    as there is no accessor function to set it afterward. Once we've got a new `QWebEnginePage`
    object that uses our profile, we can call `QWebEngineView.setPage()` to assign
    it to our web view.
  prefs: []
  type: TYPE_NORMAL
- en: Now when you test the browser, your authentication status should remain intact
    across all tabs.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing history
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each `QWebEngineView` object manages its own browsing history, which we can
    access to allow the user to view and navigate the URLs visited.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build this feature, let''s create an interface that displays the history
    of the current tab and allows the user to click history items to navigate back
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a dock widget for history in `MainView.__init__()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The history dock just contains a `QListWidget` object, which will display the
    history of the currently selected tab.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we''ll need to refresh this list when the user switches tabs, connect
    the tab widget''s `currentChanged` signal to a callback that can do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `update_history()` method looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: First, we clear the list widget and retrieve the web view for the currently
    active tab. If a web view exists (it might not if all the tabs are closed), we
    retrieve the web view's history using the `history()` method.
  prefs: []
  type: TYPE_NORMAL
- en: This history is a `QWebEngineHistory` object; this object is a property of the
    web page object and tracks the browsing history. When the `back()` and `forward()`
    slots are called on a web view, this object is consulted to find the correct URL
    to load. The `items()` method of the history object returns a list of `QWebEngineHistoryItem`
    objects detailing the entire browsing history of the web view object.
  prefs: []
  type: TYPE_NORMAL
- en: Our `update_history` method iterates this list and adds a new `QListWidgetItem`
    object for each item in the history. Note that we're using the list widget item's
    `setData()` method rather than `setText()`, as it allows us to store the `QUrl`
    object directly instead of having to convert it to a string (`QListWidget` will
    automatically convert the URL to a string for display, using the URL's `toString()`
    method).
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to calling this method whenever the tabs are switched, we also
    need to call it when a web view navigates to a new page, in order to keep the
    history current as the user browses. To make this happen, add a connection to
    each newly generated web view in the `add_tab()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To finish our history feature, we''d like to be able to double-click an item
    in the history and navigate to its URL in the currently open tab. We''ll start
    by creating a `MainWindow` method to do the navigation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We're going to be using the `itemDoubleClicked` signal within `QListWidget`
    to trigger this method, which passes the `QListItemWidget` object that was clicked
    to its callback. We simply retrieve the URL from the list item by calling its
    `data()` accessor method, then pass the URL to the currently visible web view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, back in `__init__()`, we''ll connect the signal to the callback as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This completes our history functionality; launch the browser and you'll find
    you can view and navigate using the history list in the dock.
  prefs: []
  type: TYPE_NORMAL
- en: Web settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `QtWebEngine` browser, just like the Chromium browser that it's based on,
    offers a very customizable web experience; we can edit many of its settings to
    implement various security, functionality, or appearance changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we need to access the following default `settings` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `QWebEngineSettings` object returned by the `defaultSettings()` static method
    is a global object referenced by all web views in our program. We do not have
    to (nor can we) explicitly assign it to the web views after changing it. Once
    we've retrieved it, we can configure it in various ways and our settings will
    be respected by all the web views we create.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s alter the fonts a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we're setting the default font family for all sans-serif fonts
    to `Impact`. In addition to setting the font family, we can also set a default
    `fontSize` object and a `defaultTextEncoding` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `settings` object also has a number of attributes, which are Boolean switches
    that we can toggle; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we''re enabling the use of Pepper API plugins, such as Chrome''s
    Flash implementation. There are 29 attributes that we can toggle, a few examples
    of which are listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute | Default | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `JavascriptEnabled` | `True` | Allow running JavaScript code. |'
  prefs: []
  type: TYPE_TB
- en: '| `JavascriptCanOpenWindows` | `True` | Allow JavaScript to open new pop-up
    windows. |'
  prefs: []
  type: TYPE_TB
- en: '| `FullScreenSupportEnabled` | `False` | Allow the browser to be fullscreen.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `AllowRunningInsecureContent` | `False` | Allow running HTTP content on HTTPS
    pages. |'
  prefs: []
  type: TYPE_TB
- en: '| `PlaybackRequiresUserGesture` | `False` | Don''t play back media until the
    user interacts with the page. |'
  prefs: []
  type: TYPE_TB
- en: To alter settings for an individual web view, access its `QWebEnginSettings`
    object using `page().settings()`.
  prefs: []
  type: TYPE_NORMAL
- en: Building a text search feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we''ve loaded and displayed content in our web view widget, but we
    haven''t really done much with the actual content. One of the powerful features
    that we get with `QtWebEngine` is the ability to manipulate the contents of web
    pages by injecting our own JavaScript code into those pages. To see how this works,
    we''re going to use the following instructions to develop a text search feature
    that will highlight all instances of a search term:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by adding the GUI components to `MainWindow.__init__()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The search widget is just a `QLineEdit` object that is embedded in a dock widget.
    We've connected the `textChanged` signal to a callback function that will perform
    the search.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the search functionality, we need to write some JavaScript code
    that will locate and highlight all the instances of a search term for us. We could
    add this code as a string, but for clarity let''s write it in a separate file;
    open a file called `finder.js` and add in this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This book isn''t a JavaScript text, so we won''t get into the dirty details
    of how this code works, other than to summarize what''s happening:'
  prefs: []
  type: TYPE_NORMAL
- en: The `highlight_term()` function takes a single string as a search term. It begins
    by cleaning up any HTML `<found>` tags; this isn't a real tag—it's one we've invented
    for this functionality so that it won't conflict with any real tags.
  prefs:
  - PREF_UL
  - PREF_OL
  type: TYPE_NORMAL
- en: The function then searches forward and backward through the document looking
    for instances of the search term.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When it finds one, it wraps it in a `<found>` tag with the background color
    set to light green.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Back in `MainWindow.__init__()`, we''ll read in this file and save it as an
    instance variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s implement our search callback method under `MainWindow`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: To run JavaScript code in our current web view, we need to get a reference to
    its `QWebEnginePage` object. Then we can call the page's `runJavaScript()` method.
    This method simply takes a string containing JavaScript code and executes it on
    the web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we first run the contents of our `finder.js` file to set up the
    functions, then we call the `highlight_term()` function with the search term inserted.
    As a quick-and-dirty security measure, we''re also stripping all the double quotes
    from the search term; therefore, it can''t be used to inject arbitrary JavaScript.
    If you run the application now, you should be able to search for strings on the
    page, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/3e7dac13-b284-4ea5-ae91-54413221f4f9.png)'
  prefs: []
  type: TYPE_IMG
- en: This works pretty well, but it is not very efficient to redefine those functions
    every time we update the search term, is it? It would be great if we could just
    define those functions once and then have access to them on any page that we navigate
    to.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be done using the `QWebEnginePage` object''s `scripts` property. This
    property stores a collection of `QWebEngineScript` objects, which contain JavaScript
    snippets to be run each time a new page is loaded. By adding our scripts to this
    collection, we can ensure that our function definitions are run only on each page
    load, rather than every time we try to search. To make this work, we''ll start
    back in `MainWindow.__init__()` by defining a `QWebEngineScript` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Each script in the collection is run in one of 256 **worlds**, which are isolated
    JavaScript contexts. For us to have access to our functions in subsequent calls,
    we need to make sure our `script` object is executed in the main world by setting
    its `worldId` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`QWebEngineScript.MainWorld` is a constant that points to the main JavaScript
    execution context. If we did not set this, our script would run, but the functions
    would run in their own world, and wouldn''t be available in the web page context
    for us to use for searching.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our `script` object, we need to add it to the web page object.
    This should be done in `MainWindow.add_tab()`, when we create our `page` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can shorten the `text_search()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Apart from just running scripts, we can also retrieve data back from the scripts
    and send it to a callback method within our Python code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can make the following change to our JavaScript to return the
    number of matches from our function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This value is *not* returned from `runJavaScript()` as the JavaScript code is
    executed asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the return value, we need to pass a reference to a Python callable
    as a second argument to `runJavaScript()`; Qt will call that method with the return
    value of the called code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''re going to pass the output of the JavaScript call to a method called
    `match_count()`, which looks like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we'll just show a status bar message if there are any matches
    found. Try the browser again and you'll see that the message should successfully
    be conveyed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the possibilities made available to us by `QtWebEngineWidgets`.
    You implemented a simple browser, then learned how to utilize features such as
    browsing history, profile sharing, multiple tabs, and common settings. You also
    learned to inject arbitrary JavaScript into web pages and retrieve the results
    of those calls.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll learn how to prepare your code for sharing, distribution,
    and deployment. We'll discuss how to structure your project directory properly,
    how to distribute Python code using official tools, and how to create standalone
    executables for various platforms using PyInstaller.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Try these questions to test your knowledge from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The following code is giving you an attribute error; what's wrong?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The following code should connect this `UrlBar` class with a `QWebEngineView`
    so that the entered URL is loaded when the *return*/*Enter* key is pressed. It
    doesn't work, though; what is wrong?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: What is the result of the following code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Check out the documentation for  `QWebEngineView` at [https://doc.qt.io/qt-5/qwebengineview.html](https://doc.qt.io/qt-5/qwebengineview.html).
    How would you implement a zoom feature in your browser?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As the name implies, `QWebEngineView` represents the view portion of a model-view
    architecture. What class represents the model in this design?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given a `QWebEngineView` object that is named `webview`, write code to determine
    whether JavaScript is enabled on `webview`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You saw in our browser example that `runJavaScript()` can pass an integer value
    to a callback function. Write a simple demo script to test what other kinds of
    JavaScript objects can be returned, and how they would appear in Python code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For further information, please refer to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**QuteBrowser** is an open source web browser written in Python using `QtWebEngineWidgets`.
    You can find its source code at [https://github.com/qutebrowser/qutebrowser](https://github.com/qutebrowser/qutebrowser).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ADMBrowser** is a browser that is based on `QtWebEngineWidgets`, which was
    created by the author of this book, and can be used with kiosk systems. You can
    find it at [https://github.com/alandmoore/admbrowser](https://github.com/alandmoore/admbrowser).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QtWebChannel` is a feature that allows for more robust communication between
    your PyQt application and web content. You can start exploring this advanced feature
    at [https://doc.qt.io/qt-5/qtwebchannel-index.html](https://doc.qt.io/qt-5/qtwebchannel-index.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
