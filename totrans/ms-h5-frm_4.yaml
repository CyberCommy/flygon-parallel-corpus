- en: Chapter 4. Connection with Database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the earlier chapters, we learned about forms, such as what forms are, how
    we can validate them, and how we can improve the look and feel of them, but what
    is the use of forms until they store information? In this chapter, we will learn
    how to store the user's input data into a database using PHP and MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is PHP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is MySQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spoofing and forging forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linking of forms to the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PHP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PHP, which is also used as a general-purpose programming language, is basically
    a server-side scripting language, which is designed for web development. With
    a PHP processor module, PHP code is interpreted by a web server resulting in the
    generation of a web page.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than calling an external file to process data, PHP commands can be embedded
    directly into the HTML code. It can be used for standalone graphical applications
    and can be deployed on most of the web servers for almost every operating system
    and platform.
  prefs: []
  type: TYPE_NORMAL
- en: All variables in PHP are case-sensitive, but user-defined functions, classes,
    and keywords such as if, else, while, echo, and many more are case-insensitive.
  prefs: []
  type: TYPE_NORMAL
- en: On the server, first a PHP script is executed and then the HTML result is sent
    back to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Through an HTML form, the ability of PHP to easily manipulate the information
    submitted by the user is one of the reasons why it is popular.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use PHP, we have to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Get a web server that supports PHP and MySQL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this chapter, we will use WAMP (used for Windows operating systems) software,
    which automatically installs the Apache server, configures a MySQL database, and
    installs PHP-support applications for easy maintenance and configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, install PHP and MySQL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The default extension for a PHP file is `.php` and a PHP script starts with
    `<?php` and ends with `?>`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Including some PHP scripting code, a PHP file normally contains HTML tags. A
    semicolon is used to terminate PHP statements, and we do not need to use a semicolon
    to terminate the last line of a PHP block.
  prefs: []
  type: TYPE_NORMAL
- en: Form handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `$_GET` and `$_POST` PHP superglobals (built-in variables that are always
    available in all scopes) are used to collect the form data which is submitted
    by the user on clicking on the **Submit** button.
  prefs: []
  type: TYPE_NORMAL
- en: The GET method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the `GET` method, the information from a form is visible to everyone; for
    example, all the variable names and the values are displayed in the URL. Moreover,
    using the `GET` method has limits on the amount of information that can be sent,
    which varies from browser to browser.
  prefs: []
  type: TYPE_NORMAL
- en: This method is useful when we need to bookmark the web page because the variables
    are displayed in the URL.
  prefs: []
  type: TYPE_NORMAL
- en: We cannot use the `GET` method for sending sensitive data, such as passwords
    or credit card information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is a simple HTML page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When a user fills the preceding form and clicks on the **Submit** button, the
    form data is sent for processing to a PHP file named `example.php`. The form data
    is sent with `method="get"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `example.php` file will look similar to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The POST method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The information from a form is not visible to everyone in the `POST` method;for
    example, within the body of the HTTP request, all the variable names and the values
    are embedded. Moreover, using the `POST` method has no limitation on the amount
    of information to send.
  prefs: []
  type: TYPE_NORMAL
- en: This method is not useful when we need to bookmark the web page because the
    variables are not displayed in the URL.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, while uploading the files to the server, the `POST` method also supports
    advanced functionality such as support for multipart binary input.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `POST` method for sending sensitive data, such as passwords or
    credit card information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is a simple HTML page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When a user fills the preceding form and clicks on the submit button, the form
    data is sent for processing to a PHP file named `example.php`. The form data is
    sent with `method="post"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `example.php` file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Both the `GET` and `POST` methods populate the `$_GET` and `$_POST` arrays
    respectively. As these are superglobals, regardless of scope, they are always
    accessible, and they can be accessed from any class, function, or file without
    having to do anything special. These arrays are described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$_GET`: This is an array of variable, via the URL parameters is passed to
    the current script'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$_POST`: This is an array of variable, via the HTTP POST method is passed
    to the current script'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`POST` is the most preferred way to send form data because of security concerns.'
  prefs: []
  type: TYPE_NORMAL
- en: The filter method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `filter` method filters data by either validating or sanitizing the input
    fields. It plays a very important role and is useful when the data source contains
    unknown data, such as custom input or user supplied input.
  prefs: []
  type: TYPE_NORMAL
- en: For example, data entered through an HTML form in cases, such as survey forms,
    and new registrations.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main types of filtering:'
  prefs: []
  type: TYPE_NORMAL
- en: Validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sanitization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering of input data is one of the major concerns when it comes to security
    issues. External data includes input data from the user, cookies, web service
    data, or database query results. As all web forms and applications depend on external
    input so with filtering the input data we can be sure that our application gets
    valid input from the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `filter` functions can be used to filter a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '`filter_var_array()`: It gets multiple variables with the same or different
    filters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter_id()`: It returns the ID number of a specified filter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter_var()`: It filters a single variable with a specified filter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter_input()`: It gets one input variable by the name and optionally filters
    it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter_has_var()`: It checks whether a variable of a specified input type
    exists or not'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter_input_array()`: It gets several input variables and filters them with
    the same or different filters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter_list()`: It returns a list of all the supported filters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, we are validating an integer using the `filter_var()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `FILTER_VALIDATE_INT` filter is used to filter the
    variable. Since the integer is not valid, the output of the preceding code will
    be **Integer is invalid**, but if we try with a variable that is an integer, such
    as 819, the output will be **Integer is valid**.
  prefs: []
  type: TYPE_NORMAL
- en: Validating user input data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `filter` method is used to validate the user input data. It returns the
    value **true** on success and **false** on failure.
  prefs: []
  type: TYPE_NORMAL
- en: Strict format rules are followed for validating the IP address, URL, variables,
    or e-mail type.
  prefs: []
  type: TYPE_NORMAL
- en: Now, in the following example, we will validate an input field of a form. Before
    we start, we will first check the presence of the required input data. Then, using
    the `filter_var()` function, we will validate the input data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, an input `url` is sent using the `GET` method. It
    first checks if an input `email` variable of the `GET` type is present or not.
    When the input variable is present, it validates the URL.
  prefs: []
  type: TYPE_NORMAL
- en: Sanitizing user input data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The main purpose of sanitizing is to allow or not to allow the specified characters
    in the string. It always returns a string value. It does not follow any data format
    rules.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we will validate an input field of a form. Before
    we start, we will first check the presence of the required input data. Then, using
    the `filter_var()` function, we will sanitize the input data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, an input `string` is sent using the `POST` method.
    It first checks if an input `string` variable of the `POST` type exists. When
    the input variable is present, it validates the string.
  prefs: []
  type: TYPE_NORMAL
- en: When the user inputs a bad input string such as `MasteringååHTML5ååForms`, after
    sanitizing, the same string will look like `MasteringHTML5Form`.
  prefs: []
  type: TYPE_NORMAL
- en: The FILTER_CALLBACK filter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the `FILTER_CALLBACK` filter, it is possible to call a user-defined function
    and use it as a filter. We can get full control of data filtering using this.
  prefs: []
  type: TYPE_NORMAL
- en: In a similar manner as when specifying an option, the function which we want
    to use to filter is specified.
  prefs: []
  type: TYPE_NORMAL
- en: We can use an existing PHP function or also create our own user-defined functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we will create a user-defined function to replace
    all `*` symbols with whitespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The FILTER_CALLBACK filter](img/4661OS_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, at any place in a string and no matter how many times,
    all the `*` symbols are replaced with the whitespace characters.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, we first created a function to replace all the `*` symbols
    with whitespaces. Then, the `filter_var()` function is called with the `FILTER_CALLBACK`
    filter and an array containing the function.
  prefs: []
  type: TYPE_NORMAL
- en: Filter multiple inputs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Nowadays, almost every web form consists of more than one input field such as
    the registration page. When a form consists of more than one input field, calling
    `filter_var()` or `filter_input()` functions for every input field to validate
    or sanitize not only increases the size of the code but also the complexity. The
    remedy for this is to use the `filter_var_array()` or `filter_input_array()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we will validate two input fields of a form. We will
    use the `filter_var_array()` function to filter these variables and use the `POST`
    method. The input is in the form of age and e-mail address.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the input fields are sent using the `POST` method.
    Here, an array is set, which contains the name of the input variables, such as
    `age` and `email`. We have also used the filters on these input variables.
  prefs: []
  type: TYPE_NORMAL
- en: First, we call the `filter_var_array()` function with the `POST` method input
    variables and the array we had set. Then, we validated the `age` and `email` variables
    in the `$output` variable for the invalid inputs.
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter of the `filter_input_array()` or `filter_var_array()` function
    can be a single filter ID or an array. All the values in the input array are filtered
    by the specified filter when the parameter is a single filter ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following rules must be followed if the parameter is an array:'
  prefs: []
  type: TYPE_NORMAL
- en: The array value must be a filter ID or an array specifying the flags, filters,
    and options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There must be an associative array that contains an input variable as an array
    key, such as the `email` or `age` input variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A database is a structured and organized collection of data. Every frontend
    application needs a compatible database which works as a backend for the application.
    It is organized for efficient storage and retrieval based on the nature of the
    data rather than the collection or retrieval methods. Adding a database to a website
    provides the means for dynamic content, flexibility and manageability, and all
    kinds of user interactivity, which without this could not be easily accomplished.
  prefs: []
  type: TYPE_NORMAL
- en: To work with the corresponding data, database management system applications
    interact with the user, other applications, and the database itself. This application
    will work as a backend for managing all data. There are many well-known DBMSes,
    which include Microsoft SQL Server, Oracle, Sybase, MySQL, PostgreSQL, SQLite,
    Microsoft Access, dBASE, FoxPro, IBM's DB2, Libre Office Base, and FileMaker Pro.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL for PHP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with PHP, MySQL is the most compatible database system. This database
    is an essential part of almost every open source PHP application.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL is named after *My*, daughter of *Michael Widenius*, co-founder of MySQL.
    It is developed, distributed, and supported by Oracle Corporation. It is a freely
    available and easy-to-download open source database management system. It is very
    fast, reliable, and supports standard **Structured Query Language** (**SQL**).
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL is used to access and modify data or information from a storage area called
    a database. It is most noted for its quick processing, proven reliability, and
    ease and flexibility of use. Developed by IBM, it is an English-like language
    that processes data in groups of records rather than one record at a time. The
    following are a few of the functions of SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: Storing data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating tables and other database objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data in MySQL is stored in tables. A table is a collection of related data,
    and all data is arranged in columns and rows. Databases are useful when storing
    information categorically.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL-PHP connectivity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While working with any database, the first question that arises is "How can
    we access data from the database?" To access any database, we first have to connect
    to that database.
  prefs: []
  type: TYPE_NORMAL
- en: Open a connection to the MySQL server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To make a connection, we first have to open a connection to the MySQL server.
    In PHP, this is done with the `mysqli_connect()` function. This function returns
    a resource which is a pointer to the database connection. It's also called a database
    handle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for the `mysqli_connect()` function is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mysqli_connect(server,username,password,dbname);`'
  prefs: []
  type: TYPE_NORMAL
- en: 'It supports the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`server`: It is either an IP address or a hostname.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`password`: It is the password to log in with and is optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`username`: It is the MySQL username and is optional. Also, MySQL can have
    multiple users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dbname`: It is the default database to be used when performing queries and
    is optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Close a connection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PHP will automatically close the connection when the script ends. But if we
    want to close the connection before it ends, we use the `mysqli_close()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Create or select a database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once our connection to a database is successfully created, the next step is
    to create or select any database that is going to be used with our application.
  prefs: []
  type: TYPE_NORMAL
- en: Create a database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For creating a database, we use the `CREATE DATABASE` statement to create a
    database table in MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Select a database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For selecting an already present database, we use the `MYSQLI_SELECT_DB` statement
    to select a database in MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Create a table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we create or select a database, the next step is to create a table inside
    the database.
  prefs: []
  type: TYPE_NORMAL
- en: '`CREATE TABLE` is used to create a table in MySQL.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Primary keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To increase flexibility and reliability in a table, the primary key field must
    be present.
  prefs: []
  type: TYPE_NORMAL
- en: A table consists of many records and to uniquely identify each record, a primary
    key is used. Each record must have one value that is unique, and that unique value
    will act as the primary key. Also, a primary key value cannot be null, as to locate
    a record, the database engine requires a value. A primary key is a combination
    of columns, which uniquely identifies a record.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the `Employee` table that contains a record for each employee
    working in an organization:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Employee ID | Name | Designation | Location |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 101 | Gaurav Gupta | Programmer Analyst | Pune |'
  prefs: []
  type: TYPE_TB
- en: '| 102 | Gaurav Gupta | Programmer Analyst | Pune |'
  prefs: []
  type: TYPE_TB
- en: The table consists of two records with the same name, designation, and location.
    The employee's unique Employee ID number will be a good choice for a primary key
    in the `Employee` table. So, we set the column `Employee ID` as a primary key
    for this table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet is a sample code to create a table by defining a column
    as a primary key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Spoofing and forging forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, every website has an HTML form to complete for registration so that
    users can have access to that particular website. Since Internet crime is steadily
    increasing, how do we validate that the user who completed the form did so through
    your website? It is therefore necessary to know that no one has spoofed our form
    submission.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before, we see how we can protect our forms from spoofing, let us see how we
    can spoof a form. By following these two ways we can alter the form submission:'
  prefs: []
  type: TYPE_NORMAL
- en: Forging HTTP requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spoofing submissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forging HTTP requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can type our own requests by using telnet to access port 80\. So, botheration
    of generating or modifying forms for every type of attack is overcome by this
    method as it might just use raw HTTP for alteration of form data. Because of this,
    we can say that this method has a higher degree of complexity than others.
  prefs: []
  type: TYPE_NORMAL
- en: Forging HTTP requests is a more advanced form of automating attacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we are requesting to log in to the example forum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the preceding mentioned requests, you will need to change a few items,
    which are:'
  prefs: []
  type: TYPE_NORMAL
- en: Change `myname` to be our username
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change `mypass` to be our password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change `session_id` to the necessary value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change `Content-Length` to be the new length of the `POST` data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spoofing submissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us assume that the following HTML form is located at `http://sampledomain.com/form.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We assume that we will be able to refer to `$_POST[''browser'']` and it will
    have a value of either of the two options `chrome` or `firefox`. Now, if the user
    selects `chrome`, the request will look something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'A user can save the form from the browser to the local machine (desktop or
    laptop) then open the saved HTML file and make the following changes to it:'
  prefs: []
  type: TYPE_NORMAL
- en: Modify the `action` tag so that it now has the full URL to the form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove the `select` tag and replace it with a `textarea` tag in the form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now our form will look similar to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The user can now submit any value of `$_POST['myvar']` with these simple changes
    to the form. Moreover, there is no way to prevent the user who manipulated our
    form from submitting unexpected form variables or anything that can be achieved
    with an HTML form.
  prefs: []
  type: TYPE_NORMAL
- en: There are solutions available to prevent forms from spoofing. It is from a strict
    protocol perspective; the only thing we know is that HTTP requests and responses
    are going back and forth. There is no clear and concise way to determine that
    a form submission has not been spoofed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the following two ways, we can prevent forms from spoofing as they reduce
    the possibility of unwanted values that are submitted by following a general architecture
    for handling data and forms:'
  prefs: []
  type: TYPE_NORMAL
- en: Shared secrets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting expectations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shared secrets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Shared secrets are also referred to as one-time tokens or hashes. We create
    a secret that is only known by the server and the user. In this, the implementations
    vary widely but they share the characteristics of being transparent to the users
    and are difficult to exploit.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the implementation methods is that in the user''s session, we will store
    the secret as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it can be used as a hidden form variable in the form like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Every time we display the form, we would regenerate this secret so that the
    user always has a current and correct secret value. This helps in preventing **CSRF**
    (**Cross-Site Request Forgery**).
  prefs: []
  type: TYPE_NORMAL
- en: The page which will open can check this by comparing the secret sent by the
    form with the secret that was stored in the corresponding session variable.
  prefs: []
  type: TYPE_NORMAL
- en: Taking this further, we can even enhance the security of this method by restricting
    the timeout window rather than relying on the session timeout, which can be too
    large for your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Setting expectations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An application with a best architecture always assumes that:'
  prefs: []
  type: TYPE_NORMAL
- en: '**We are aware of what we are sending out**: It means we should keep track
    of the forms we have uploaded on the website and develop a policy for accepting
    form submissions, such as time outs, multiple forms per user ID, multiple submissions,
    and not accepting forms we don''t expect. This can be implemented using tokens.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**We are aware of what the return values will be**: It is important, as the
    `<select>` field contains certain values, we can get back something totally different,
    such as PHP code, SQL, or others:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To accept the form as valid, we must know the fields we need to have back
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We must restrict exactly what values we would accept as input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We must always minimize taking data from forms or from an external source and
    using it directly in our database queries or other internal parts of the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linking a form to a server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basic purpose of form is to accept user data or store data from the users,
    which can be accessed in various ways, such as a survey, a new registration, while
    making payments, and much more. So here, in this section, we will learn how to
    store the user's input data into the database.
  prefs: []
  type: TYPE_NORMAL
- en: We will reuse our form which we styled in [Chapter 3](ch03.html "Chapter 3. Styling
    the Forms"), *Styling the Forms*.
  prefs: []
  type: TYPE_NORMAL
- en: We will store the form data into a MySQL database using `phpMyAdmin` (open sourcetool
    to handle the administration of MySQL over World Wide Web).
  prefs: []
  type: TYPE_NORMAL
- en: For operating systems such as Linux, we use a XAMPP server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the server-side scripting code written in the same HTML page
    but the HTML file extension `.html` is changed to `.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Before executing the code, our prerequisite is that first we have to create
    and select one database and then create a table to store the information. After
    that, we perform some validations on the form inputs, and then finally, we implement
    the `Insert` query so as to store the user's input data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot displays the error messages when the user does not
    enter any data and submits the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Linking a form to a server](img/4661OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is the HTML code. The code remains the same but we have added
    the `method= "POST"` attribute in the `<form>` tag and the `name` attribute in
    the `<input>` types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: By clicking on the **Submit** button, we can either redirect the user to a new
    page, or populate a message on the screen, or simply write a message on the screen
    giving confirmation that our form has been submitted successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot displays the form after the user has entered the values
    in the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Linking a form to a server](img/4661OS_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following snippet is the MySQL code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, first we created a database and then we created a table
    to store the user's input data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot displays the values stored into the database after
    clicking on the **Submit** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Linking a form to a server](img/4661OS_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to store data into a database. We also learned
    about the basics of PHP and MySQL used for storing the data that the users input.
    We also saw some ways of how we can spoof a form and how we can prevent spoofing
    of forms.
  prefs: []
  type: TYPE_NORMAL
- en: Then, with the help of some code, we learned a practical implementation of storing
    form data by reusing the example we built in earlier chapters.
  prefs: []
  type: TYPE_NORMAL
