- en: Basic Vue.js Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, the following recipes will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning how to use computed properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering a list with a computed property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting a list with a computed property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatting currencies with filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatting dates with filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying and hiding an element conditionally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding styles conditionally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding some fun to your app with CSS transitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Outputing raw HTML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a form with checkboxes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a form with radio buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a form with a select element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will find all the building blocks needed to develop a fully
    functional, interactive, self-contained Vue application. In the first recipe,
    you will create computed properties that encapsulate the logic you can use to
    create a more semantic application; you will then explore some more text formatting
    with filters and the `v-html` directive. You will create a graphically appealing
    application with the help of conditional rendering and transitions. Finally, we
    will build some form elements such as checkboxes and radio buttons.
  prefs: []
  type: TYPE_NORMAL
- en: From now on, all recipes will be written exclusively with ES6\. At the time
    of this writing, if you are using Chrome 9x and JSFiddle to follow along, they
    should work seamlessly; if you are integrating this code into a bigger project,
    remember to use Babel (for more information, check out the *Using Babel to compile
    from ES6*  recipe in [Chapter 8](text00390.html) , *Organize + Automate + Deploy
    = Webpack* ).
  prefs: []
  type: TYPE_NORMAL
- en: Learning how to use computed properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Computed properties are data in Vue components that depend on some calculation
    on other, more primitive data. When this primitive data is reactive, the computed
    properties are up-to-date and reactive themselves. In this context, primitive
    is a relative term. You can certainly build computed properties based on other
    computed properties.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before venturing to prepare this recipe, be sure to familiarize yourself with
    the `v-model` directive and the `@event` notation. You can complete the *React
    to events like clicks and keystrokes* recipe in the preceding chapter if you are
    unsure.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A simple example will clarify what a computed property is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this example will display two input fields: one for the name and one
    for the surname, and one button specifically to save the surname. Examining the
    JavaScript code will reveal that while the name is declared in the data section
    of our object, the surname is declared at the beginning, external to our Vue instance.
    This implies that it will not be picked up by Vue as a reactive variable. We can
    check that while editing; the name affects the computed value, editing the surname
    does not, even if the surname variable itself is actually changed, as we can check
    in the browser console:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the app on JSFiddle; you will see both `John`  and `Snow`  in the input
    fields and, as a result of `computedFullName` , you will see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Image00018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Type `Johnny` instead of `John` and you will see the computed property changing
    in real time. This is because the variable name is reactive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Image00019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Type `Rain` instead of `Snow` then click on Save Surname . Nothing will happen
    because the `surname` is not reactive. It will not trigger an update on the view.
    Let''s check whether it was indeed saved:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Image00020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Replace `Johnny`  with `John` . The surname in the computed property instantly
    becomes "Rain". That''s because changing the first name triggered an update for
    the computed property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Image00021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We just experimentally verified that, although changes in variables are saved
    to memory, no view refresh is triggered when non-reactive variables are edited.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that the same limitation applies here for reactivity--if
    the variable is an array, changing the elements with bracket notation won't work,
    deleting an element without using `$remove`  won't work either. For other limitations
    of computed properties, you should check out the official documentation at [https://vuejs.org/v2/guide/computed.html](https://vuejs.org/v2/guide/computed.html)
    .
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following text, by the word dependencies I refer to variables that are
    reactive and are used inside a computed property. When a dependency is changed,
    the computed property is calculated.
  prefs: []
  type: TYPE_NORMAL
- en: Computed properties are not meant for memorizing data, but you can define a
    setter in case it makes more sense to set a value directly instead of indirectly
    manipulating it through its dependencies. Moreover, if a computed property returns
    an object, it will be a new object every time, not a modified version of the previous
    one. Lastly, the computed property will not be called if all the dependencies
    haven't changed.
  prefs: []
  type: TYPE_NORMAL
- en: This caching mechanism and defining a setter are analyzed in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Caching computed properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While functions inside the methods option are executed every time we call them,
    functions in computed are cached based on the dependencies, which in turn are
    defined by everything reactive found inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next recipe, composing computed properties is explored, but you can
    easily imagine how you can have very heavy calculations on a computed property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can use the same property over and over, without the need for re-evaluation
    at every usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Every time we call this function, we just fetch the cached value of `trillionthDigitOfPi`
    ; there is no need for calculations again.
  prefs: []
  type: TYPE_NORMAL
- en: Computed setters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we have a computed property that really represents a clear object
    in our model, and it feels cleaner to simply edit it directly than to modify its
    dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the context of a table factory, we would like to specify the number of tables
    or the number of legs we will build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Our state is only determined by `legCount` , and the number of tables is determined
    automatically. Create a new Vue instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To know the number of tables, we have the `tableCount`  computed property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `get` part is, as usual, the value of the property at any time, the setter
    allows us to set the number of tables directly (and the number of legs indirectly).
    We can then write the `update` method that is triggered whenever we change the
    number of tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Filtering a list with a computed property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the earlier version of Vue, filters were used in the `v-for` directives
    to only extract some values. They are still called filters, but they are not used
    in this sense anymore. They are relegated to the role of post-processing for text.
    To be honest, I never really understood how to use filters in Vue 1 with lists,
    but that won't be a problem in version 2 because the only proper way to filter
    a list is to use computed properties.
  prefs: []
  type: TYPE_NORMAL
- en: With this recipe, you will be able to filter your list from the simplest to-do
    list to the most complex bills-of-materials of a spaceship.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should have some familiarity with Vue lists and know the basics of computed
    properties; if you don't, the *Writing lists*  and *Learning how to use computed
    properties*  recipes will get you covered.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started with this recipe, we need an example list from which to filter
    our favorite elements. Let''s suppose we work for the *ACME Research and Development
    Laboratory* , and we are in charge of reproducing some experiment in any field
    we want. We may choose an experiment from the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s print the list right away using a simple `<ul>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are not a big fan of physics, you may want to filter out physics experiments
    from this list. To do this, we create a new variable that will hold only `nonPhysics`
    experiments. This variable will be a computed property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, of course, we now want the list to draw an element from here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If we start the program now, only the non-physics experiments are shown in the
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `nonPhysics` computed property will contain a copy of our array with the
    processing specified inside. It will simply check for experiments with fields
    that are not `Physics`  and pass the new array to be rendered as a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the filtering is totally arbitrary. We could take, instead
    of the word `Physics` , a word from a variable that in turn is taken from a textbox:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It turns out we''d like to reproduce such experiments but we are on a budget;
    anything over 3,000,000 euro is off limits for us. Let''s build a filter for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If we use this filter instead of the previous one, we still have the *Do-It-Yourself
    Particle Detector* physics experiment lying around. Since we don't like physics,
    we'd like to combine the two filters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the old version of Vue, you could just pipe the two filters inside `v-for`
    ; here, we will move the computed properties we just created down in the methods
     aisle and turn them into pure functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This way, the filters are composable; we can use them both in the `v-for` in
    the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to put less logic in the HTML would be to encapsulate everything
    in a dedicated computed property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The HTML becomes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: At last, the only element remaining on the list after all this filtering is
    the *Violinist in the Metro*  and, to be fair, 3 millions is the cost of the violin,
    not of the whole experiment.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting a list with a computed property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ordering inside a `v-for` with a filter is another thing that was considered
    for removal in Vue 1 and didn't survive in the current version.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting a list with a computed property offers much more flexibility and we
    can implement any custom logic for ordering. In this recipe, you will create a
    list with some numbers within; we will sort the list using them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete this recipe, you just require some familiarity with lists and computed
    properties; you can brush up on them with the *Writing lists*  and *Learning how
    to use computed properties*  recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's write a list of the largest dams in the world.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need an HTML table with three columns (Name , Country , Electricity
    ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we need the JavaScript of the Vue instance, which, for now, only contains
    a small database of dams, their location, and how much electricity they generate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `<tbody>` tag, we put a `v-for` that will simply iterate the list
    of dams we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This renders to the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We want to sort these dams by installed electricity power. To do this, we will
    create a computed property,  `damsByElectricity` , that will return an ordered
    set of dams:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding the computed property, we just have to write `damsByElectricity`
    instead of dams in the HTML. Everything else remains the same and will behave
    the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The computed property we just created,  `damsByElectricity` , will return an
    array that will be a sorted clone of `this.dams` . As always with computed properties,
    the result will be cached (or memorized); every time we need the result, if the
    original list is not changed, the function will not be called and the cached result
    will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sort` function accepts two parameters: two members of the list. The return
    value must be a positive number if the second member is after the first or a negative
    number if the opposite is true.'
  prefs: []
  type: TYPE_NORMAL
- en: The order we obtain with `d2.electricity - d1.electricity` is descending; if
    we want an ascending order, we have to commute the two operands or multiply them
    by *-1* .
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can expand on our list by binding a click event on a field in the table header
    to reverse the ordering so that when we click on `Electricity` , it will sort
    the dams the other way around.
  prefs: []
  type: TYPE_NORMAL
- en: We will use conditional styling; if you are not familiar with it, you will be
    after completing the *Adding styles conditionally*  recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it clear which way we are ordering, we should introduce two CSS classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, the content is the Unicode representation of an arrow pointing up for
    ascending and pointing down for descending.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we should keep track of the order with a variable order  that will be
    1 when ascending and -1 when descending:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The conditional styling is a simple ternary operator. Check the *Adding styles
    conditionally * recipe for more on conditional styling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `sort` method is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to do is edit the `damsByElectricity` computed property
    to take the order in to account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This way, the order will be reversed when order is `-1` , representing an ascending
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Formatting currencies with filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Formatting currencies in Vue 1 was somewhat limited; we will be using the excellent
    `accounting.js` library to build a much more powerful filter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basics of filtering are explored in the *Formatting your text with filters*
     recipe; where you build a basic filter ensure that you complete that, then come
    back here.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Add `accounting.js` to your page. Refer to [http://openexchangerates.github.io/accounting.js/](https://vuejs.org/v2/guide/computed.html)
     for more details on how to do it. If you are using JSFiddle though, you can just
    add it as an external resource to the left menu. You can add a link to CDN, which
    is serving it, for example, [https://cdn.jsdelivr.net/accounting.js/0.3.2/accounting.js](http://openexchangerates.github.io/accounting.js/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'This filter will be extremely simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You can try it out with a one-liner in HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: It will default to dollars, and it will print `I have $5.00 in my pocket` .
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you add `accounting.js` to your page in JSFiddle or manually in your page
    (or with an import ), you make object accounting available. This way, you can
    use external libraries in your filter (and everywhere else in your code).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Currency often ends up in tables and they need to be aligned; let''s see how
    that will work out. We begin with this HMTL table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We are iterating an inventory that, of course, we need to specify in our JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we have a table with the prices rendered on the page, but there
    is no currency symbol, no consistency in the number of digits after the decimal
    point, and no alignment.
  prefs: []
  type: TYPE_NORMAL
- en: We plan to use our filter to help us add all three of these.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on, the most astute readers may have noted that I used strings
    to represent the prices. Why not numbers? This is because numbers in JavaScript
    are floating points; in other words, they are not accurate because the number
    of decimal digits "floats."
  prefs: []
  type: TYPE_NORMAL
- en: If we have a kitten key chain on sale for 0.83 euros and we have a kitty 50%
    discount on that, we should sell it for 0.415 euros. Since 0.5 cents do not exist,
    we will perform some rounding.
  prefs: []
  type: TYPE_NORMAL
- en: 'A client surfs our online shop and is amazed by our kitty discounts. He buys
    3\. If you do the math, that would result in 1.245 euros; we apply the `Math.round`
    function on it and that should result in 1.25 euros. We can check it with this
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'However, consider that we code all our calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We lost one cent in the process. Imagine having a big application processing
    thousands of such transactions, or imagine that this was not a price but an exchange
    rate. Imagine you have to return this result to the backend and the calculations
    don't match up. The errors can accumulate and the final number can diverge significantly.
    This is just a small example, but there is more that can go wrong with floating
    point numbers when used with money.
  prefs: []
  type: TYPE_NORMAL
- en: Using strings (or integers) to represent currencies gives you the level of precision
    that you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using our previous filter will introduce the dollar sign and two numbers after
    the decimal point, but we will still be short of the alignment we want. We should
    add a new style to our CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Assigning the class price to the price column will ensure alignment on the
    point. Here''s the complete code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the code for the JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Formatting dates with filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes you need a slightly more powerful filter than a basic one. You have
    to use similar filters many times, but every time with a slight variation. Having
    too many filters can create confusion. This example with dates will illustrate
    the problem and the solution.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before moving ahead, make yourself more comfortable with filters by going through
    the *Formatting your text with filters* recipe in [Chapter 1](text00026.html)
    , *Getting started with Vue.js*  *;* if you already know filters, keep reading.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say we are curating an interactive page to learn history. We have our
    Vue instance with the following JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In our data, we have a date written informally as a string in our instance
    data. Our HTML can contain a timeline of the French Revolution and, at some point,
    can contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We need a filter capable of completing the sentence. For this, one possible
    library is the excellent `moment.js` and, for our purposes, we''ll choose the
    localized version: [https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.14.1/moment-with-locales.js](https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.14.1/moment-with-locales.js)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding the library, write the following filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This will display a nicely formatted date: `The Storming of the Bastille, happened
    on July 14, 1789` .
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we want a multi-language site and we would like the date to be formatted
    in French? The `moment.js`  library is great with locales; in fact, let''s write
    the same text in French:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to amend our filter with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Our result is `La prise de la Bastille, survenue le 14 juillet 1789` , nice!
    We don''t want to hard-code the language in every page though. It''s much better
    to add a parameter in our filter. We want to be able to pass a variable to the
    filter with the language, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'To achieve this, we have to add a second parameter to the filter declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This way, we can pass the language in a parameter through a variable in the
    page, for example, depending on the selected language.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying and hiding an element conditionally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Displaying and hiding an element on a web page is fundamental to some designs.
    You could have a popup, a set of elements that you want to display one at a time,
    or something that shows only when you click on a button.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use conditional display and learn about the important
    `v-if` and `v-show` directives.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before venturing into this recipe, ensure that you know enough about computed
    properties or take a look at the *Filtering a list with a computed property* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s build a ghost that is only visible at night:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `v-show` guarantees that the `<div>` ghost will be displayed only when
    `isNight` is `true.` For example, we may write as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This will make the ghost visible. To make the example more real, we can write
    `isNight` as a computed property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If you load this program in JSFiddle, you will see the ghost only after midnight
    and before 7:00\. If you really can''t wait to see the ghost, you can cheat and
    insert a time in the night, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `v-show` directive evaluates the `isNight` computed property and puts a
    `display: none`  in the element `style` attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: This means that the element is completely rendered by Vue; it's just invisible,
    like a ghost.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other directive for displaying elements conditionally is the `v-if` directive.
    The behavior is the same as that of `v-show` except that you won''t find the element
    in the DOM at all. When `v-if`  evaluates to `true` , the element will be added
    dynamically, no element styling involved. To try it, just replace the `v-show`
    with `v-if` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In general, if it makes no difference, using `v-show` is better because it requires
    fewer resources in the long run. On the other hand, if you are not even sure that
    some elements will appear on the page, using `v-if` will let your users save some
    CPU time (you never know when your app will go viral and have millions of users;
    you can save a lot of energy by choosing the right one!).
  prefs: []
  type: TYPE_NORMAL
- en: On a side note, don't wait in front of the page until midnight. Nothing will
    happen. Computed properties are re-evaluated only when reactive properties inside
    them change. In this case, we have a `Date`  that is not reactive and, thus, will
    not trigger any update.
  prefs: []
  type: TYPE_NORMAL
- en: Adding styles conditionally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One great feature of modern web page architecture is the ability to pack tons
    of display logic in CSS. This means you can have a very clean and expressive HTML
    and still create impressive interactive pages via CSS.
  prefs: []
  type: TYPE_NORMAL
- en: Vue is particularly good at expressing relationships between HTML and CSS and
    allows you to encapsulate complex logic in easy-to-use functions.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will explore the basics of styling with Vue.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will build a text area that warns you when you are reaching the maximum
    allowed number of characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The text written inside will be bound to the `memeText` variable and the `length`
    of our text is written at the end via mustaches.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to change the background color when only 10 characters are left. For
    this, we have to bake a little CSS class `warn` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use this class on the `textarea` to signal the imminent alt on writing.
    Let''s take a look at our JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This is just our model; we want to add a function,  `longText` , that will
    evaluate to true whenever we reach 40 characters (10 characters away from 50):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now everything is in place to actually add the warn style conditionally. To
    do this, we have two options: **object syntax**  and **array syntax** . Let''s
    first try with the object syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This means that, whenever `longText` evaluates to `true` (or in general to a
    truthy), the class warn will be added to the `textarea` .
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you try to write past the 39 characters in the text area, the background
    will turn misty rose. The general object syntax for *n* classes is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'There are, however, a couple of alternatives to this syntax. First of all,
    you don''t need to write the full object in the HTML; you can also bind to an
    object. The general way to do it is as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, manipulating the classes object will add or remove the warn
    class from the `<div>` . An even more clever way to bind is to a computed property
    that itself returns an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'And, of course, it''s much easier to put some custom logic inside the computed
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Adding some fun to your app with CSS transitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Transitions are effects that can be applied when elements are inserted, updated,
    and removed from the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we will build a little riddle for our friends to enjoy. When
    they want to know the solution, it will appear with a fading transition.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete this lesson, you should already know conditional display and conditional
    rendering. The *Displaying and hiding an element conditionally*  recipe will teach
    you how to do that.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s set up the riddle in our HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The Vue instance is initialized very easily; you just have to write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'In the CSS, we want to make clear that the `<div>` solution can be clicked
    on, and so we add the following rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: At this point the application works, but you will see the Dragon immediately.
    We want to add a touch of class to our riddle and make the dragon appear with
    a fading effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need two CSS classes; the first class will be applied for one tick when
    the solution appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The second one will be persistent after the first one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we wrap the solution in a transition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The name of the transition is the first word of the CSS class selectors `(fade
    )` , and Vue will look for them based on whether the element is appearing or disappearing
    from the screen. If no name is specified and only `<transition>` is used, Vue
    will use the transition name,  `v`  for CSS.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, the dragon that was previously invisible is appearing and so, 
    `fade-enter` will be applied for a tick (a tick is a cycle for refreshing the
    view, but you can think of it as a frame in an animation). This means the `<span>`
    will be effectively invisible at the beginning because the opacity will be set
    to `0` .
  prefs: []
  type: TYPE_NORMAL
- en: After that, the `fade-enter` class will be removed and `fade-enter-active` ,
    which was attached to  `fade-enter` , is now the only class remaining. The opacity
    will go to `1` in half a second as you can see from the rules of the class. Where
    is 1 specified? It's the default value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete set of classes Vue will look for in transitions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name-enter` : This is the starting class for `enter` ; it is applied before
    an element is inserted, and removed after one frame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name-enter-active` : This is the persistent class for `enter` . It is applied
    before an element is inserted and is removed when the transition/animation finishes.
    Use this to define the features of the transition, such as duration and easing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name-enter-to` : This is the ending class for `enter` . It is applied when
    `name-enter` is removed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name-leave` : This is the starting class for `leave` . It is applied when
    `leave` transition is triggered and is removed after one frame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name-leave-active` : This is the persistent class for `leave` . It is applied
    when `leave` transition is triggered and is removed when the transition/animation
    finishes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name-leave-to` : This replaces `name-leave` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, name is the name of your transition (`v` where no name is specified).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Transitions are cool, but there is a tree that is blocking our view in this
    recipe and it''s ruining the transition''s reputation; to follow along, consider
    the following HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'A little bit of CSS is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, a simple Vue instance is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the application, this is what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00026.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Clicking on the tree reveals the real message.
  prefs: []
  type: TYPE_NORMAL
- en: Outputting raw HTML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes you need to insert HTML content, such as line breaks ( `<br>` ), in
    your application data. This can be easily achieved with the `v-html` directive.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will build a thank-you note.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, you don't need any special knowledge, but we will build upon
    some basic Vue functionalities; if you completed a recipe in this or the last chapter,
    you are good to go.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say you have a friend John. You want to prepare a formatted thank-you
    note before receiving a gift, but you don''t know what he''ll be giving you yet.
    You prewrite three texts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider that you were to output this variable directly in mustaches, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem is that, in this case, you would get plain text and all the HTML
    gibberish:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00027.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is not what you're looking for; you would like your thank-you letter well
    formatted following the HTML tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'What you need to do is use the `v-html` directive, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'This way, the HTML tags won''t be escaped by Vue and will be interpreted as
    is in our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00028.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Outputting raw HTML in general is very dangerous. Explaining web security is
    beyond the scope of this book, but just to get the idea, imagine that you have
    a comments section in your website, and that someone puts an `<img>` in a comment.
    If you were to interpret that as HTML and display it to other users, you could
    make your users download an image they don't necessarily want; if the image is
    not yours, you may be charged for bandwidth you didn't plan. Now you can expand
    this reason. If a user puts a `<script>` in the comment, this poses a greater
    risk as scripts can do almost anything.
  prefs: []
  type: TYPE_NORMAL
- en: Vue, by default, avoids the problem altogether by not letting you output HTML
    by default; that's why we need the special `v-html` directive to see it. This
    said, always ensure that you are in full control of the content you are outputting.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is another way to output raw HTML; it is advanced, but it's much cleaner
    and maintainable, especially if you have a component that depends heavily on HTML
    formatting.
  prefs: []
  type: TYPE_NORMAL
- en: In these more contrived cases, you can opt for **functional components**  that
    are covered in detail in the *Create a functional component* recipe in [Chapter
    9](text00431.html) , *Advanced Vue.js - Directives, Plugins and Render Functions*
    , but here you will find an example that is an extension of what we have just
    done.
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTML you should write is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'You can already see that the intent is clear: to write a thank-you note for
    the batman gift using the HTML `<strong>` as decoration. The JavaScript to create
    the `<thanks>` component is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you will need the Vue instance as well.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a form with checkboxes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asking for user input is fundamental in today's web apps. Presenting the user
    with multiple choices makes the interface more fun to use and is necessary for
    structured input.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to create checkboxes by building a confirmation
    page for your own print shop!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already know how data binding works in Vue, so you are good to go. Otherwise
    go back to the first recipe, collect 200, and then proceed to the *React to events
    like clicks and keystrokes* recipe in [Chapter 1](text00026.html) , *Getting started
    with Vue.js* , to learn more about the `v-model` directive.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s suppose you have to set up a Martian printing shop with three different
    printers:'
  prefs: []
  type: TYPE_NORMAL
- en: Monochrome printer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plasma Color printer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3D DNA Clone printer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The confirmation page will basically be just a form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of name, we will use `v-model` to bind our model to the view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Every `<input>` checkbox with the same `v-model` will participate in a reactive
    array that will be updated in real time. Let''s declare this array in the Vue
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'This is just a regular array. All the selected printers will be inserted and
    removed automatically from the array. Here''s the complete HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in a form like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00029.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Put `{{ outputPrinter }}` somewhere inside your app in a  `<div>`  tag and see
    for yourself the array changing in real time while selecting printers.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you check the first and last printer, the array will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: You can than use this array to send it via AJAX to a web service or to further
    build upon it.
  prefs: []
  type: TYPE_NORMAL
- en: Checkboxes in Vue are just regular `<input>` elements, the only difference being
    that we don't really need the name attribute used in traditional forms. That's
    because we won't have a second page to submit our values (the page that normally
    reads the value using the name attributes).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To reach this "second page" I was talking about, just click on the submit button.
    This is the default behavior and, in our case it's not what we want; since we
    usually don't like having to change page when dealing with Vue, I will show you
    how to prevent it.
  prefs: []
  type: TYPE_NORMAL
- en: Modern websites tend to give feedback for your action on the same page, sometimes
    without interrupting your workflow (what if you want to clone another five or
    six creatures in the same session?)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s turn it into something more useful. First of all, we have to prevent
    the button default action, which is to change page; for this, we use the prevent
    modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The `printHandler` will be a method in our Vue instance that will get us some
    feedback. You are free to add whatever you want as a handler, perhaps a popup
    that tells you that printing is in progress; maybe you can just go back to the
    home page.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will just check whether the button works with an alert
    popup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Creating a form with radio buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Radio buttons let you choose only one option among many. When the user selects
    a radio button, any previously selected radio button is deselected. A common example
    of its use is when you are creating a registration form and you choose between
    male and female.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will resemble the *Creating a form with checkboxes* recipe because
    we are using a similar technique. I suggest you to complete both the recipes to
    become a black belt in Vue forms.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First of all, we need something to choose from, so we write an array in our
    Vue instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the variable gender (singular) to hold the value of the chosen
    option. From here, we can set up a form in just a few lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run the app and it will work; however, you need to add a mustache after
    the form to see what is happening :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'This way, you can see how clicking on the radio buttons affects the internal
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00030.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here we just inserts three radio buttons. Since they all have `v-model="gender"`
    , they logically belong to the same group. This means that only one of the values
    can be selected at any given time. We can have as many groups as we want in the
    same form.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, the value of the radio buttons was completely fixed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'We can change the `value="male"` to make it reactive using `v-bind:value` .
    This binds the value to whatever variable we pass to it. For example, let''s say
    we have an array of genders in our model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'We can rewrite the preceding radio button like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Here,  `:value` is a shorthand for `v-bind:value` .
  prefs: []
  type: TYPE_NORMAL
- en: To put what we have learned into practice, let's build a simple game.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you are a farmer, and you start with zero animals in your farm. Every
    day, there are new animals on sale at the animal market. You can only buy one
    on any given day. We can express this choice with radio buttons!
  prefs: []
  type: TYPE_NORMAL
- en: 'So we have an animals array in our model, an animal variable that will contain
    our choice for the day, and a farm array (initially empty) that will represent
    our hoarding. We add a little randomness with the `i` variable to hold a random
    number representing the available animals for the day:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: I used emojis to represent the animals because they are super fun to use. If
    you don't know where to find them, just copy and paste them from [http://emojipedia.org/](http://emojipedia.org/)
    and look for animals.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start from the same HTML we used at the beginning; we just need to change
    the legend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point we should add a list of animals from which to choose, but we
    want it to be dynamic, that is, a different pair of animals for every day:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: This means that the value (and the label) of the radio button will change as
    the `i` variable is changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only thing remaining is a way to buy the animal, add it to the farm, and
    wait for the next day. We will summarize all this in a submit button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `addToFarm` method is defined by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t do anything if the animal was not chosen; otherwise, add the animal
    to the farm, draw a random number for the next day, and reset the selection. To
    see your farm, add this to your HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Your app will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00034.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a form with a select element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Select elements or "drop-down lists" are used in a form when radio buttons won't
    cut it, either because there are too many choices or because they always take
    the same space no matter how many options.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I suggest you complete a recipe on data binding or forms before delving into
    the world of select elements. The *Creating a form with radio buttons* recipe
    will make you familiar with radio buttons, which have a function similar to select
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will create a simple country selector. I will start by writing
    the selector without the help of Vue, just to brush up on HTML. First, create
    a `form` in which to put the `select` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `fieldset` , write the code for the `select` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Run the application. There you have a working select element right from the
    start. The anatomy is pretty simple. Every `<option>` will lengthen the list of
    things to choose from.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, there is not much to be done with this element. Let''s bind the chosen
    country to a variable with Vue. You have to edit your HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you have to add `choosenCountry` to your model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to surround the form with `<div id="app">` or it won't be picked
    up by Vue.
  prefs: []
  type: TYPE_NORMAL
- en: Run the application now; you will notice that, whereas earlier the drop-down
    started with Japan  already selected, now it's obeying our initialization in the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that, initially, no country will be selected. We can add a mustache
    to see the current status of the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The country selector will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00035.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you bind a `<select>` element with `v-model` , the selected option will
    populate the bound variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that, if you set a value for your options, the variable will take it instead
    of what is written within the tags. For example, you can write as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that you have every country bound to a numeric value.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Often, countries and cities are arranged in hierarchical ways. This means that
    we need two or more select elements to pin down a user birth place, for example.
    In this paragraph, we will explore a little bit of hierarchical selection with
    multiple drop-down menus. Since there are too many cities in the world, I will
    use a biological equivalent and we will select from animals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: We will call the top level a `clan` , the second level a `type`  and the last
    will be an animal. I know it's an unorthodox way of classifying animals, but it
    will work for this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the two variables that will hold the state to our Vue model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now add the first `select` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a drop-down menu with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Mammalia
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Birds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variable types don't really do anything in this particular case.
  prefs: []
  type: TYPE_NORMAL
- en: 'We would like to populate a second drop-down with the `type`  of a particular
    `clan` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'When the variable clan has a value, this select element will let you choose
    the type of animal. Consider that we add a third select for the species though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: It will cause an error in our program because `clans[clan]` is undefined and
    Vue will try to evaluate it. To correct this, we may want the third select element
    to appear only when the first and the second have a value. For this, we can use
    the `v-show` directive, but the problem is that Vue renders the elements with
    `v-show` , and only after rendering, will it hide them. This means that the error
    will still be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'The right way is to use `v-if` , which prevents the rendering of the element
    if the condition inside is not satisfied is, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Go ahead and choose your favorite animal hierarchically!
  prefs: []
  type: TYPE_NORMAL
