- en: Using Spark SQL in Graph Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will present typical use cases for using Spark SQL in graph
    applications. Graphs are common in many different domains. Typically, graphs are
    analyzed using special graph processing engines. GraphX is the Spark component
    for graph computations. It is based on RDDs and supports graph abstractions and
    operations, such as subgraphs, aggregateMessages, and so on. In addition, it also
    exposes a variant of the Pregel API. However, our focus will be on the GraphFrame
    API implemented on top of Spark SQL Dataset/DataFrame APIs. GraphFrames is an
    integrated system that combines graph algorithms, pattern matching, and queries.
    GraphFrame API is still in beta (as of Spark 2.2) but is definitely the future
    graph processing API for Spark applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'More specifically, in this chapter, you will learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using GraphFrames for creating large-scale graphs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing some basic graph operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Motif analysis using GraphFrames
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing subgraphs using GraphFrames
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing graph algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing graphs containing multiple types of relationships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partitioning in GraphFrames
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing large-scale graph applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Analysis of graphs based on large Datasets is becoming increasingly important
    in various areas, such as social networks, communication networks, citation networks,
    web graphs, transport networks, product co-purchasing networks, and so on. Typically,
    graphs are created from source data in a tabular or relational format, and then
    applications, such as search and graph algorithms, are run on them to derive key
    insights.
  prefs: []
  type: TYPE_NORMAL
- en: 'GraphFrames provide a declarative API that can be used for both interactive
    queries and standalone programs on large-scale graphs. As GraphFrames are implemented
    on top of Spark SQL, it enables parallel processing and optimization across the
    computation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00207.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The main programming abstraction in GraphFrame's API is a GraphFrame. Conceptually,
    it consists of two DataFrames representing the vertices and edges of the graph.
    The vertices and edges may have multiple attributes, which can also be used in
    queries. For example, in a social network, the vertices can contain the name,
    age, location, and other attributes, while the edges can represent the relationships
    between the nodes (people in the network). As the GraphFrame model can support
    user-defined attributes with each vertex and edge, it is equivalent to the property
    graph model. Additionally, views can be defined using patterns to match various
    shapes of subgraphs in the network.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will build graphs from several public Datasets
    that are available in a relational format, and then run various graph operations
    and algorithms on them. GraphFrames optimize the execution across the relational
    and graph portions of the computation. These computations can be specified using
    relational operators, patterns, and calls to algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will use the Spark shell for defining graphs,
    querying them, and running algorithms on them interactively.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring graphs using GraphFrames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we explore data, modeled as a graph, using Spark GraphFrames.
    The vertices and edges of the graph are stored as DataFrames, and Spark SQL and
    DataFrame-based queries are supported to operate on them. As DataFrames can support
    a variety of data sources, we can read our input vertices and edges information
    from relational tables, files (JSON, Parquet, Avro, and CSV), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The vertex DataFrame must contain a column called `id` which specifies unique
    IDs for each vertex. Similarly, the edges DataFrame must contain two columns named
    `src` (source vertex ID) and `dst` (destination vertex ID). Both the vertices
    and edges DataFrames can contain additional columns for the attributes.
  prefs: []
  type: TYPE_NORMAL
- en: GraphFrames exposes a concise language-integrated API that unifies graph analytics
    and relational queries. The system optimizes across the steps based on join plans
    and performing algebraic optimizations. Machine learning code, external data sources,
    and UDFs can be integrated with GraphFrames to build more complex applications.
  prefs: []
  type: TYPE_NORMAL
- en: We will start our coding exercises with a simple example in which we read in
    the vertices and edges from a file containing Amazon co-purchase data. The nodes
    represent the various items and the edges between the source and destination vertices
    define an **alsopurchased** relationship. The Dataset for these exercises can
    be downloaded from [https://snap.stanford.edu/data/amazon0601.html](https://snap.stanford.edu/data/amazon0601.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the Spark shell as shown to include the GraphFrame library in the Spark
    shell environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we import all the packages we need in our examples, as listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Constructing a GraphFrame
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A GraphFrame can be constructed using two DataFrames: a vertex DataFrame and
    an edge DataFrame. Here, we create the GraphFrame from a single DataFrame containing
    edge information.'
  prefs: []
  type: TYPE_NORMAL
- en: We will derive the vertex DataFrame from the source and destination vertices
    specified for the edges contained in our input file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Read in the input file to create an RDD for the edges, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, define a schema for the edges and convert the edges RDD into a DataFrame,
    as shown in the next few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create a DataFrame for the vertices by selecting distinct source and
    destination vertices from the edges DataFrame. A union of the resulting two DataFrames,
    with distinct vertices selected, gives us the final vertices DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can verify the number of nodes and vertices in these DataFrames by matching
    them with the numbers reported at the source site (for our input Dataset):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create a `GraphFrame` for the Amazon co-purchase data from the vertices
    and edges DataFrames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will explore a few properties of the graph we just created.
  prefs: []
  type: TYPE_NORMAL
- en: Basic graph queries and operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will cover simple graph queries and operations on the structure
    of our graph. These include displays of the vertices, edges, and the in- and out-degrees
    of the vertices, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also apply filters to the edges and vertices and their properties, as
    shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, we can also use `groupBy` and `sort` operations, as shown in
    the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we explore structural patterns present in our graph.
  prefs: []
  type: TYPE_NORMAL
- en: Motif analysis using GraphFrames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finding motifs helps us execute queries to discover structural patterns in our
    graphs. Network motifs are subgraphs or patterns that occur repeatedly in the
    graph and represent the interactions or relationships between the vertices. Motifs
    can be used in our product co-purchasing graph to gain insights into user behavior
    based on structural properties of the graph representing the products, and their
    attributes and the relationships between them. Such information can be used in
    recommendation and/or advertising engines.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following motif represents a use case where a customer who
    bought product **(a)** also purchased the other two products, **(b)**, and **(c)**,
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00208.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Refer to *Motif Analysis* in the *Amazon Product Co-Purchasing Network*, by
    *Abhishek Srivastava* for a detailed coverage of motif analysis.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will use GraphFrames to primarily `model 3-` and `4-`node
    motifs that represent various relationships in the co-purchasing network Dataset.
    GraphFrame motif finding uses a declarative **Domain-Specific Language** (**DSL**)
    for expressing structural queries. Within a pattern, names are assigned to vertices
    and edges. The basic unit of a pattern is an edge. For example, `(a) – [e] ->
    (b)` expresses an edge `e` from vertex `a` to vertex `b`. The vertices are denoted
    by parentheses `(a)`, while edges are denoted by square brackets `[e]`. A pattern
    is expressed as a union of edges and the edge patterns can be joined with semicolons.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start our coding exercises with a simple query in which we search for
    sets of products where purchases of product `a` also meant purchases of product
    `b` or vice versa. The find operation here will search for pairs of vertices connected
    by edges in both directions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also apply filters to the result; for example, we have specified the
    value of the vertex `b` as `2` in the following filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example specifies two separate edges from `a` (to `b` and `c`).
    This pattern typically represents a case in which when a customer buy a product
    **(a)** then she also buys either of, or both, **(b)** and **(c)**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00208.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Additionally, the pattern also specifies that the same vertex `a` is the common
    source for edges `e1` and `e2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As the edges columns contain redundant information, we can omit names for vertices
    or edges in motifs when they are not required; for example, in the pattern `(a)-[]->(b)`,
    `[]` represents an arbitrary edge between vertices `a` and `b`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no column for the edge in the result. Similarly, `(a)-[e]->()` indicates
    an outgoing edge of vertex `a` but does not name the destination vertex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, we specify two separate edges from `a` (to `b` and
    `c`), and another edge from `b` to `a`. This pattern typically represents the
    case in which there is a reciprocating relationship between `a` and `b` (a strongly
    connected component indicative of a close similarity between the products):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00209.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, we specify two separate edges from `a` and `c` (to
    `b`). This pattern typically represents the case in which when customers buys
    largely unrelated products (`a` and `c`), then they also buy `b`. This is a converging
    motif and the business can use this information to, for example, stock this subset
    of products together:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00210.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, we specify edges from `a` to `b` and `b` to `c`,
    and another one from `c` to `b`. This pattern typically represents the case in
    which when a customer buys a product **(a)**, she may also buy **(b)** and then
    go on to buy **(c)**. This can be indicative of some prioritization on the items
    being purchased. Additionally, the strongly connected component in the motif indicates
    a close relationship between **(b)** and **(c)**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00211.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The 4-node motifs example is very resource intensive requiring over 100 GB disk
    space and over 14 GB RAM. Alternatively, you can refer to the next section to
    create a smaller subgraph to run this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next example, we present a `4-node` motif. This pattern typically represents
    the case in which there is a higher probability of a customer buying **(b)**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00212.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00213.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we shift our focus to creating and processing subgraphs.
  prefs: []
  type: TYPE_NORMAL
- en: Processing subgraphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GraphFrames provide a powerful way to select subgraphs based on a combination
    of motif finding and DataFrame filters. The following examples show how to select
    a subgraph based on vertex and edge filters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will apply a series of graph algorithms to our graph.
  prefs: []
  type: TYPE_NORMAL
- en: Applying graph algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GraphFrames provide a suite of standard graph algorithms. We provide brief descriptions
    of the graph algorithms and code snippets for applying them.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we compute the **strongly connected component** (**SCC**) of each vertex
    and return a graph with each vertex assigned to the SCC containing that vertex.
    We display the count of nodes in the SCC, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we compute the number of triangles passing through each vertex. The number
    of triangles is a measure of the density of the vertex neighborhood. There are
    many practical applications of triangle counting in networks, for example, community
    detection, roles behavior, spam detection, detecting subsets of web pages with
    a common topic, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, we will apply the PageRank algorithm to determine
    an estimate of how important the product is. The underlying assumption is that
    more popular products are likely to receive more links from other product nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next example, we apply the Label Propagation algorithm to find communities
    of products in our graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, we apply the Shortest Paths algorithm to find a path
    between two vertices in the graph so that the number of its constituent edges
    is minimized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the following section, we show how to save GraphFrames to persistent storage
    and then retrieve the same to recreate the original GraphFrame.
  prefs: []
  type: TYPE_NORMAL
- en: Saving and loading GraphFrames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As GraphFrames are built on the DataFrames API, they support saving and loading
    to and from various data sources. In the following code, we show saving the vertices
    and edges to Parquet files on HDFS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can recreate the vertex and edge DataFrames from persistent storage, and
    then the graph, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we use a richer Dataset to demonstrate the use of vertex
    and edge attributes in GraphFrames-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing JSON input modeled as a graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will analyze a JSON Dataset modeled as a graph. We will
    apply GraphFrame functions from the previous sections and introduce some new ones.
  prefs: []
  type: TYPE_NORMAL
- en: For hands-on exercises in this section, we use a Dataset containing Amazon product
    metadata; product information and reviews on around 548,552 products. This Dataset
    can be downloaded from [https://snap.stanford.edu/data/amazon-meta.html](https://snap.stanford.edu/data/amazon-meta.html).
  prefs: []
  type: TYPE_NORMAL
- en: For processing simplicity, the original Dataset was converted to a JSON format
    file with each line representing a complete record. Use the Java program (`Preprocess.java`)
    provided with this chapter for the conversion.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a DataFrame from the input file, and print out the schema
    and a few sample records. It is a complex schema with nested elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00214.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can print out an array of struct elements in the data. More specifically,
    we print out the list of similar products (that get co-purchased with the current
    product):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also flatten the nested structure of the reviews element by using explode
    and access specific elements within it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create the nodes and edges DataFrames, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'For the edges DataFrame, we use explode on similar or also purchased products
    column called `similarLines` to create new rows for each element in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we show some basic operations using the node attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create a subgraph for Book group products only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important to note that the number of edges is equal to the edges in the
    original graph. GraphFrame does not automatically remove the edges that are not
    related to Book group products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following steps, we join the vertices and edges DataFrames, temporarily,
    to get rid of the extra edges in our DataFrame and create a `GraphFrame` with
    nodes and edges related to Book products only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We can combine the motif finding with filters containing the attributes of
    the vertices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00215.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00216.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00217.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: GraphFrames provides the `AggregateMessages` primitive for developing graph
    algorithms. This component can be used for sending messages between vertices,
    and also for aggregating the messages for each vertex.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we compute the sum of the number of purchased products
    of adjacent products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we explore GraphFrames with edges representing multiple
    types of relationships.
  prefs: []
  type: TYPE_NORMAL
- en: Processing graphs containing multiple types of relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the next few examples, we use an augmented edges DataFrame containing a
    relationship column. We insert two types of relationships in the column based
    on the number of similar purchases and the number of categories that a product
    belongs to.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, we join the nodes and edges DataFrames, and subsequently drop the
    node-related columns after the relationship computation is completed to obtain
    our final edges DataFrame (with the relationship column suitably populated):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we count the number of records for each type of relationship and list
    a few edges along with the relationship values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, we filter on product vertices with a sales rank of
    following 2,000,000 and edges having the `highSimilars` relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, we create a subgraph from selected columns and filter
    on a specific group of products. We also select a subset of edges based on the
    `highSimilars` relationship. Furthermore, we find the motifs and apply further
    filters on them to obtain the final results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we apply a few graph algorithms to the subgraphs that are based on node
    and edge relationship attributes. In the following example, we first find the
    motifs matching the pattern in our graph, and then filter on a combination of
    node and edge attributes. We run the BFS algorithm on the final subgraph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00218.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the following example, we run the PageRank algorithm on the Books subgraph
    to find the top ten book titles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00219.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Understanding GraphFrame internals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following sections, we briefly present GraphFrame internals with respect
    to its execution plan and partitioning.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing GraphFrame physical execution plan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the GraphFrames are built on Spark SQL DataFrames, we can view the physical
    plan to understand the execution of the graph operations, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00220.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We will explore this in more detail in [Chapter 11](part0197.html#5RRUQ0-e9cbc07f866e437b8aa14e841622275c),
    *Tuning Spark SQL Components for Performance*.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding partitioning in GraphFrames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spark splits data into partitions and executes computations on the partitions
    in parallel. You can adjust the level of partitioning to improve the efficiency
    of Spark computations.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we examine the results of repartitioning a GraphFrame.
    We can partition our GraphFrame based on the column values of the vertices DataFrame.
    Here, we use the values in the group column to partition by group or product type.
    Here, we will present the results of repartitioning by comparing the before and
    after distribution of the records.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create the two GraphFrames as shown. As there are nulls in the `group`
    column, we replace them with a value of `unknown`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create the second GraphFrame after repartitioning the original GraphFrame.
    Here, we use the number of groups as our initial number of partitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Displaying the vertices in the following two graphs shows that the records
    are bunched together by groups in the second graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The default number of partitions in the first graph is `9` and in the second,
    as specified, there are `11`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also write out the contents of the partitions to files to explore their
    contents, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The sample contents of a partition from one of the output files are listed
    here for the first graph showing a mix of records:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00221.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The sample contents of a partition from one of the output files are listed
    here for the second graph showing records belonging to the same group:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00222.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We notice that most of our records are in five main product groups and we may
    want to reduce the total number of partitions. We use the coalesce operation to
    achieve that, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced GraphFrame applications. We provided examples
    of using Spark SQL DataFrame/Dataset APIs to build graph applications. Additionally,
    we also applied various graph algorithms to graph applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will shift our focus to using Spark SQL with SparkR.
    Additionally, we will explore typical use cases and data visualization using Spark
    SQL and SparkR.
  prefs: []
  type: TYPE_NORMAL
