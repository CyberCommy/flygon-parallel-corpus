- en: Continuously Delivering ECS Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Continuous delivery** is the practice of creating a repeatable and reliable
    process for releasing software, so that you can deploy new features to production
    frequently and on demand, with a lower cost and risk. There are numerous benefits
    to adopting continuous delivery, and today, more and more organizations are adopting
    it, to get features to the market faster, increase customer satisfaction, and
    lower the cost of software delivery.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing continuous delivery requires a high degree of automation across
    the end-to-end life cycle of software delivery. So far, in this course, you have
    worked with many technologies that support automation and continuous delivery,
    in general. For example, Docker inherently brings a high degree of automation
    and promotes repeatable and consistent build processes, all of which are critical
    components of continuous delivery. The make workflow in the `todobackend` repository
    takes this a step further, automating a full test, build, and publish workflow
    for your Docker images. We have also been using CloudFormation extensively throughout
    this course, which provides us with the ability to create, update, and destroy
    complete AWS environments in a completely automated fashion, and allows us to
    easily deploy new features (in the form of new Docker images) in a reliable and
    consistent manner. Continuous delivery brings all of these features and capabilities
    together to create an end-to-end process for the delivery of software changes,
    from the time they are developed and committed to source code, to the time they
    are regression-tested and deployed to production. To achieve this level of end-to-end
    orchestration and automation, we need to adopt new tools that are engineered for
    this purpose, and AWS offers a number of services that work together to deliver
    this, including AWS CodePipeline, CodeBuild, and CloudFormation.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how you can implement an end-to-end continuous
    delivery pipeline (using CodePipeline, CodeBuild, and CloudFormation) that will
    continuously test, build, and publish Docker images, and then continuously deploy
    your freshly built Docker images to a non-production environment. The pipeline
    will also support controlled releases into a production environment, by automatically
    creating change sets that must be reviewed and approved before deploying new changes
    into production.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing CodePipeline and CodeBuild
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom CodeBuild container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding CodeBuild support to your application repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a continuous integration pipeline using CodePipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a continuous deployment pipeline using CodePipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuously delivering your applications to production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following lists the technical requirements for completing this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Administrator access to an AWS account.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A local AWS profile, configured as per the instructions in Chapter 3.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The AWS CLI version 1.15.71 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter continues on from Chapter 12, so it requires that you have successfully
    completed all configuration tasks defined in Chapter 12.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter requires you to have both the `todobackend` and `todobackend-aws`
    repositories published to a GitHub account that you have administrative access
    to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following GitHub URL contains the code samples used in this chapter: [https://github.com/docker-in-aws/docker-in-aws/tree/master/ch13](https://github.com/docker-in-aws/docker-in-aws/tree/master/ch13)
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2BVGMYI](http://bit.ly/2BVGMYI)'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing CodePipeline and CodeBuild
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**CodePipeline** and **CodeBuild** are two services from the developer tools
    portfolio of AWS that, along with the CloudFormation service that we have been
    working with extensively throughout this book, provide the building blocks for
    creating complete and comprehensive continuous delivery solutions to pave your
    application''s path from development to production.'
  prefs: []
  type: TYPE_NORMAL
- en: CodePipeline allows you to create complex pipelines that take your applications'
    source code, build, test, and publish application artifacts, and then deploy your
    applications into non-production and production environments. The top-level building
    blocks of these pipelines are stages, which must always start with a source stage
    that includes one or more source materials for your pipeline, such as the source
    code repository for your application. Each stage can then be comprised of one
    or more actions that produce an artifact that can be used later on in your pipeline,
    or achieve a desired outcome, such as deploying to an environment. You can define
    actions in sequence or in parallel, which allows you to orchestrate almost any
    scenario you want; for example, I have used CodePipeline to orchestrate the deployment
    of complete, complex, multi-application environments in a highly controlled fashion
    that can easily be visualized and managed.
  prefs: []
  type: TYPE_NORMAL
- en: Every CodePipeline pipeline must define at least two stages, and we will see
    an example of this initially, when we create a continuous integration pipeline
    including a source stage (which collects application source code from a source
    code repository) and a build stage (which tests, builds, and publishes application
    artifacts from the application source collected by the source stage).
  prefs: []
  type: TYPE_NORMAL
- en: An important concept to understand here is the concept of artifacts. Many actions
    in CodePipeline consume input artifacts and produce output artifacts, and the
    ability for one action to consume the output of an earlier action is the essence
    of how CodePipeline works.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, the following diagram illustrates the initial continuous integration
    pipeline that we will create:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/27880320-80ab-4e17-8106-8fc29ba82459.png)Continuous integration
    pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, the **Source Stage** includes a single **Source Action**
    that is linked to your todobackend GitHub repository. This action will download
    the latest source code whenever changes are committed to your GitHub repository,
    and will produce an output artifact that zips up your source code and makes it
    available for the build stage that immediately follows. The **Build Stage** has
    a single **Build Action** that takes your source action output artifact as an
    input, and then tests, builds, and publishes a Docker image. The **Build Action**
    in the preceding diagram is executed by the AWS CodeBuild service, which is a
    fully managed build service that provides a container-based build agent for running
    build jobs on demand. CodePipeline ensures that the CodeBuild build job is supplied
    with an input artifact that includes your application source code, which allows
    CodeBuild to then run your local test, build, and publish the workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have discussed the concept of the source and build stages in CodePipeline;
    the other common stage that you will use in your pipelines is a deploy stage,
    where you deploy your application artifacts into a target environment. The following
    diagram illustrates how you can extend the pipeline shown in the preceding diagram
    to continuously deploy your applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a2ac7b82-63b4-4d97-a803-2126e603a611.png)Continuous deployment pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, a new stage (called **Dev Stage**) has been added;
    it leverages CodePipeline's integration with CloudFormation to deploy your applications
    into a non-production environment, which we refer to as dev (development). Because
    we are using CloudFormation for deployment, we need to provide a CloudFormation
    stack to deploy, and this is provided by adding the todobackend-aws repository
    as another source action in the source stage. The **Deploy Action** also requires
    another input artifact that defines the tag of the Docker image to deploy, and
    this is provided as an output artifact (called `ApplicationVersion`) of the CodeBuild
    build action in the build stage. Don't worry if this doesn't make too much sense
    right now; we will cover all of the details and set up these pipelines in this
    chapter, but it is important to at least understand the concepts of stages, actions,
    and how artifacts can be passed between them to achieved your desired outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, CodePipeline can support deployments into multiple environments, and
    the final section of this chapter will extend our pipeline to perform a controlled
    release into a production environment, as illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d3186f6c-4547-4471-9e0e-a4d4fa6b7191.png)Continuous delivery pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, a new stage (called **Production Stage**) is added
    to the pipeline, which can only be executed if your application has been successfully
    deployed in your dev environment. Unlike the continuous deployment approach of
    the dev stage, which immediately deploys into your dev environment, the production
    stage first creates a CloudFormation change set, which identifies all of the changes
    that will be made as part of the deployment, and then triggers a manual approval
    action that requires somebody to review the change set and approve or reject the
    changes. Assuming that the changes are approved, the production stage will then
    deploy the changes to the production environment, and these sets of actions will
    collectively combine to offer support for controlled releases into production
    (or other controlled) environments.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have had a high-level overview of CodePipeline, let's get started
    by creating the continuous integration pipeline that we discussed in the very
    first diagram. Before, we can build this pipeline, we need to build a custom build
    container to meet the requirements of the Docker workflow defined in the todobackend
    repository, and we also need to add support for CodeBuild, after which we can
    create our pipeline in CodePipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom CodeBuild container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS CodeBuild provides a build service that uses a container build agent to
    execute your builds.  CodeBuild provides a number of AWS curated images that target
    specific application languages and/or platforms, such as [Python, Java, PHP and
    many more](https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref-available.html).
    CodeBuild does provide an image that is designed for building Docker images; however,
    this image is somewhat limited, in that it does not include tools like the AWS
    CLI, GNU make, and Docker Compose, all of which we require for building the todobackend
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Although you can run pre-build steps that install additional tools in CodeBuild,
    this approach slows down your builds, as the installation of the additional tools
    will happen on each and every build. CodeBuild does support using your own custom
    images, which allows you to pre-package all of the tools required for your application
    builds.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our use case, the CodeBuild build environment must include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Access to a Docker daemon, given the build stands up a multi-container environment
    to run integration and acceptance tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GNU Make
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may be wondering how you can meet the first requirement, given that your
    CodeBuild runtime environment is located within an isolated container that has
    no direct access to the underlying infrastructure it is running on. Docker does
    support the concept of **Docker in Docker** (**DinD**), where the Docker daemon
    runs inside of your Docker container, allowing you to install a Docker client
    that can build Docker images and orchestrate multi-container environments, using
    tools like Docker Compose.
  prefs: []
  type: TYPE_NORMAL
- en: The practice of Docker in Docker is [somewhat controversial](http://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/), and
    is an example of using Docker more like a virtual machine than a container. However,
    for the purposes of running a build, this approach is completely acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a custom CodeBuild container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we need to build our custom CodeBuild image, which we will define in
    a Dockerfile called `Dockerfile.codebuild`, located within the todobackend-aws
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows the Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Because Docker publishes a Docker in Docker image, we can simply base our customization
    from this image; we have the Docker in Docker functionality for free. The DinD
    image is based on Alpine Linux, and already includes the required Docker daemon
    and Docker client. Next, we will add the specific tools that we require for our
    build. This includes the bash shell, GNU make, and a Python 3 runtime, which is
    required to install Docker Compose and the AWS CLI.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now build this image locally by using the `docker build` command, demonstrated
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The command in the preceding example, creates the newly built Docker image with
    a name of `codebuild`. This is OK for now, but we will need to publish this CodeBuild
    to the **Elastic Container Registry** (**ECR**), so that it is available for CodeBuild.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a repository for the custom CodeBuild container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, that you have built a custom CodeBuild image, you need to publish the image
    to a location that CodeBuild can pull the image from. If you are using the ECR,
    you will typically publish this image to a repository within ECR, and that is
    the approach we will take.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to add a new repository to the `ecr.yml` file, in the root
    of the `todobackend-aws` folder, which you created earlier in the chapter::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, you create a new repository with the name `docker-in-aws/codebuild`,
    which will result in a fully qualified repository by the name of `<account-id>.dkr.ecr.<region>.amazonaws.com/docker-in-aws/codebuild` (for
    example, `385605022855.dkr.ecr.us-east-1.amazonaws.com/docker-in-aws/codebuild`).
    Note that you must grant pull access to the CodeBuild service, as CodeBuild needs
    to pull the image to run as its build container.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now deploy the changes to the ECR stack by using the `aws cloudformation
    deploy` command, which you may recall from the chapter, Publishing Docker Images
    Using ECR is deployed to a stack called ecr-repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the deployment is complete, you need to retag the image that you created
    earlier, with the fully qualified name of your new ECR repository, after which
    you can log in to ECR and publish the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Adding CodeBuild support to your application repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever you create a CodeBuild project, you must define how CodeBuild should
    test and build your application source code, and then publish application artifacts
    and/or Docker images. CodeBuild defines these tasks within a build specification,
    which provides the build instructions the CodeBuild agent should execute when
    running a build.
  prefs: []
  type: TYPE_NORMAL
- en: 'CodeBuild allows you to provide a build specification in several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Self-defined**: CodeBuild looks for a file that is defined within the source
    repository of the project.  By default, this is a file called `buildspec.yml`;
    however, you can also configure a custom file where your build specification is
    located.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Preconfigured**: When you create a CodeBuild project, you can define a build
    specification as part of your project setup.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**On demand**: If you initiate a CodeBuild build job using the AWS CLI or SDK,
    you can override the preconfigured or self-defined build specification'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, I recommend using the self-defined method, as it allows the repository
    owner (typically, your developers) to configure and maintain the specification
    independently of CodeBuild; this is the approach we will take.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates adding a build specification to the todobackend
    repository, in a file called `buildspec.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The build specification starts by specifying a version that must be included
    in every build specification, the most current version being `0.2`, as of the
    writing of this book. Next, you define the phases sequence, which is required,
    defining the commands that CodeBuild will run during the various phases of the
    build.  In the previous example, you define three phases:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pre_build`: Commands that CodeBuild will run before the build. Here, you can
    run commands such as logging into ECR, or any other commands that are required
    for your build to run successfully.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`build`: These commands run your build steps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`post_build`: Commands that CodeBuild will run after your build. These typically
    involve clean up tasks, such as logging out of ECR and removing temporary files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find more information about the CodeBuild build specifications at [https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html](https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'During the `pre_build` stage, you perform the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: The first two commands are used to start the Docker daemon in your custom CodeBuild
    image; the `nohup` command starts the Docker daemon as a background task, while
    the `timeout` command is used to ensure the Docker daemon has started successfully,
    before attempting to continue.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Export a `BUILD_ID` environment variable, which is used to add build information
    to the application version that will be generated for your build. This `BUILD_ID`
    value will be added to the application version tag that is attached to the Docker
    image that is built during the build phase, and therefore, it can only include
    characters that are compatible with Docker''s tag format. The CodeBuild job ID
    is exposed to your build agent via the `CODEBUILD_BUILD_ID` environment variable,
    and has the format `<project-name>:<job-id>`, where `<job-id>` is a UUID value.
    The colon in the CodeBuild job ID is not supported in Docker tags; hence, you
    strip the `<project-name>`: portion of the job ID using a `sed` expression, leaving
    just the job ID value that will be included in the Docker tag.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Export the `APP_VERSION` environment variable, which is used in the Makefile
    to define the application version that is tagged on the built Docker image. When
    you use CodeBuild with CodePipeline, it is important to understand that the source
    artifact presented to CodeBuild is actually a zipped version located in an S3
    bucket that CodePipeline creates after cloning the source code from your source
    repository. CodePipeline does not include any Git metadata; therefore, the `APP_VERSION`
    directive in the todobackend Makefile - `export APP_VERSION ?= $(shell git rev-parse
    --short HEAD` -  will fail, as the Git client will not have any Git metadata available.
    Luckily, the `?=` syntax in GNU Make means to use the value of the aforementioned
    environment variable, if it is already defined in the environment. So, we can
    export `APP_VERSION` in the CodeBuild environment, and Make will just use the
    configured value, rather than run the Git commands. In the previous example, you
    construct the `APP_VERSION` from a variable called `CODEBUILD_RESOLVED_SOURCE_VERSION`,
    which is the full commit hash of the source repository, and is set by CodePipeline.
    You also append the `BUILD_ID` variable calculated in the previous command, which
    allows you to trace a specific Docker image build to a CodeBuild build job.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log in to ECR using the `make login` command included in the source repository.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the `pre_build` stage has completed, the build stage is straightforward,
    and simply executes the various build steps that we have executed manually so
    far in this book. The final `post_build` stage runs the `make clean` task to tear
    down the Docker Compose environment, and then removes any local ECR credentials
    by running the `make logout` command.
  prefs: []
  type: TYPE_NORMAL
- en: One important point to note is that the `post_build` stage always runs, even
    if the build stage fails. This means you should only reserve `post_build` tasks
    for actions that you would run regardless of whether the build passes or fails.
    For example, you might be tempted to run the `make publish` task as a `post_build`
    step; however, if you do this, and the previous build stage fails, CodeBuild will
    still attempt to run the make publish task, given that it is defined as a `post_build`
    step. Placing the make publish task as the final action in the build stage ensures
    that if make test or make release fails, the build stage will immediately exit
    with an error, bypassing the make publish action and  proceeding to execute the
    cleanup tasks in the `post_build` step.
  prefs: []
  type: TYPE_NORMAL
- en: You can find out more about all of the CodeBuild phases, and whether they execute
    on success/failure, at [https://docs.aws.amazon.com/codebuild/latest/userguide/view-build-details.html#view-build-details-phases](https://docs.aws.amazon.com/codebuild/latest/userguide/view-build-details.html#view-build-details-phases).
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step that you need to perform is to commit and push your changes
    to your Git repository, so that the newly created `buildspec.yml` file will be
    available when you configure CodePipeline and CodeBuild:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Creating a continuous integration pipeline using CodePipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have established the prerequisites for supporting CodeBuild, you
    can create a continuous integration CodePipeline pipeline that will use CodeBuild
    to test, build, and publish your Docker image. Continuous integration focuses
    on continuously merging application source code changes into your master branch
    and validating the changes by creating a build and running automated tests against
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'As per the first diagram in this chapter, this generally involves two stages
    when you configure a CodePipeline pipeline for continuous integration:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source Stage**: Downloads the source application repository and makes it
    available for subsequent stages. For our use case, you will connect CodePipeline
    to the master branch of your GitHub repository, and subsequent commits to this
    repository will automatically trigger a new pipeline execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build Stage**: Runs the build, test, and publish workflow defined in the
    source application repository. For our use case, we will use CodeBuild to run
    this stage, which will execute the build tasks defined in the source repository
    `buildspec.yml` file that you created earlier in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a CodePipeline pipeline using the AWS console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started, first, select **Services** from the AWS console and choose **CodePipeline**.
    If this is the first time that you have used CodePipeline, you will be presented
    with an introduction page, and you can click the Get started button to start the
    CodePipeline wizard.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are first asked to enter a name for your pipeline, and after clicking Next
    step, you are prompted to set up a source provider, which defines the provider
    of the source repository or files that will be used in your pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/db98d662-8e5f-410b-8afe-1492bf859b6d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After selecting GitHub from the drop-down menu, click on the Connect to GitHub button,
    which will redirect you to GitHub, where you will be prompted to log in and grant
    CodePipeline access to your GitHub account:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9b6c00bb-874c-48ea-9185-b8f5d82bc591.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After clicking on the Authorize aws-codesuite button, you will be redirected
    back to the CodePipeline wizard, and you can select the todobackend repository
    and master branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/44a9298c-0671-4f61-b714-fae334ce3b7c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you click on Next step, you will be asked to select a build provider, which
    defines the provider of the build service that will perform build actions on your
    source repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4ebf9916-9332-4ea5-b7c5-89c361a8123c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After selecting AWS CodeBuild and choosing the Create a new build project option,
    you need to configure the build project, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Environment image: For Environment image, select the Specify a Docker image
    option, and then set the Environment type to Linux, Custom image type to Amazon
    ECR; then, choose the `docker-in-aws/codebuild repository/latest` image you published
    earlier in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Advanced: Ensure that the Privileged flag is set, as shown in the following
    screenshot. This is required whenever you run Docker in Docker images:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](assets/132bf4f5-0a72-458b-ab05-419745b1bae5.png)'
  prefs: []
  type: TYPE_IMG
- en: After completing the build project configuration, ensure that you click on Save
    build project before clicking Next step to continue.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next stage, you will be asked to define a Deploy stage. At this point,
    we only want to perform the continuous integration tasks of testing, building,
    and publishing our Docker application, so select the No Deployment option and
    click Next step to continue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c5d4b3fa-d8ea-4c84-968d-565b491923cf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The final step is to configure an IAM role that CodePipeline can assume to
    perform the various build and deployment tasks in your pipeline. Click on the
    Create role button, which will open a new window that asks you to create a new
    IAM role, with the appropriate permissions, for CodePipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d924fc71-95b4-41d3-a6e8-29ad258664cf.png)'
  prefs: []
  type: TYPE_IMG
- en: After reviewing the Policy Document, click on Allow, which will select the new
    role in the CodePipeline wizard. Finally, click on Next step, review the pipeline
    configuration, and then click Create pipeline to create your new pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, your pipeline will be created, and you will be taken to the
    pipeline configuration view for your pipeline. Whenever you create a pipeline
    for the first time, CodePipeline will automatically trigger the first execution
    of your pipeline, and after a few minutes, you should notice that the build stage
    for your pipeline has failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a014138c-d861-4c94-9165-871b35dc3908.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To find out more information about why the build failed, click on the Details
    link, which will pop up more details about the failure, and will also include
    a link to the CodeBuild job where the failure occurred. If you click on this link
    and scroll down, you can see that the failure occurred in the `pre_build` stage,
    and in the build logs that the issue is related to an IAM permission issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4640dbba-7a70-49ac-8992-d1d43e7b3d1c.png)'
  prefs: []
  type: TYPE_IMG
- en: The problem is that the IAM role that was automatically created during the CodePipeline
    wizard does not include permissions to log in to ECR.
  prefs: []
  type: TYPE_NORMAL
- en: 'To resolve this, open the IAM console, select Roles from the left-hand menu,
    and locate the `code-build-todobackend-service-role` that was created by the wizard.
    In the Permissions tab, click on Attach Policy, locate the `AmazonEC2ContainerRegistryPowerUser` managed
    policy, and click on the Attach Policy button.  The power user role grants login,
    pull, and push permissions, and because we will be publishing to ECR as a part
    of the build workflow, this level of access is required. Once you have completed
    the configuration, the Permissions tab for the role should look the same as what''s
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6e394fa4-1f87-4edd-9edd-6b53978de78a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that you have resolved the permissions issue, navigate back to the CodePipeline
    details view for your pipeline, click on the Retry button in the build stage,
    and confirm retrying the failed build. This time, after a few minutes, the build
    should complete successfully, and you can use the `aws ecr list-images` command
    to verify that a new image has been published to ECR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the last image published is in the format `<long commit hash>`.`<uuid>`,
    where `<uuid>` is the CodeBuild job ID, confirming that CodeBuild has successfully
    published a new image to ECR.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a continuous delivery pipeline using CodePipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, you have a continuous integration pipeline that will automatically publish
    new Docker images for your application whenever a commit is pushed on the master
    branch to your source repository. At some point, you will want to deploy your
    Docker images to an environment (perhaps a staging environment, where you may
    run some end-to-end tests to verify that your application works as expected),
    and then to a production environment that services your end users. Although you
    could deploy these changes manually by updating the `ApplicationImageTag` input
    to the todobackend stack, ideally, you want to be able to continuously deploy
    these changes automatically into at least one environment, which provides immediate
    access to developers, testers, and product managers, allowing for fast feedback
    from the key stakeholders involved in the development of your applications.
  prefs: []
  type: TYPE_NORMAL
- en: This concept is referred to as continuous deployment. In other words, whenever
    you are continuously integrating and building tested software artifacts, you then
    continuously deploy those artifacts.  Continuous deployment is very common these
    days, especially if you are deploying into a non-production environment. What
    is far less common is continuous deployment all the way to production. To achieve
    this, you must have a high degree of automated post-deployment testing available,
    and, at least in my experience, this is something that is still difficult to achieve
    for most organizations. A far more common approach is what is referred to as continuous
    delivery, which you can think of as the ability to automatically deploy all the
    way to production once you are sure your release is ready for production.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous delivery allows for the common scenario where you have a requirement
    to perform controlled releases into production,  rather than continuously deploying
    into production as soon as a release is available. This is somewhat more achievable
    than continuous deployment all the way to production, as it allows for the manual
    testing of your non-production environments before you choose to deploy to production.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have some context around what continuous delivery is, let's extend
    our pipeline to support continuous delivery.
  prefs: []
  type: TYPE_NORMAL
- en: CodePipeline includes support for ECS as a deployment target, where you can
    deploy new images published by your continuous integration pipeline to a target
    ECS cluster and ECS service. In this chapter, I will be using CloudFormation to
    deploy application changes; however, you can read more about the ECS deployment
    mechanism at [https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-cd-pipeline.html](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-cd-pipeline.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The first stage of this is to configure the continuous deployment of your code
    changes into a non-production environment, requiring you to perform the following
    configuration actions, which will be discussed in further detail:'
  prefs: []
  type: TYPE_NORMAL
- en: Publish version information in your source repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add CodePipeline support to your deployment repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add your deployment repository to CodePipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add an output artifact for your build actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an IAM role for CloudFormation deployments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a deployment stage to the pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing version information in your source repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A key requirement of our pipeline is the ability to deploy a newly built Docker
    image into our AWS environments. At the moment, CodePipeline has no real awareness
    of the Docker image tag that is published. We know that the tag is configured
    within the CodeBuild environment, but CodePipeline has no understanding of this.
  prefs: []
  type: TYPE_NORMAL
- en: In order to use the Docker image tag that is generated in the CodeBuild build
    stage, you need to produce an output artifact that is first collected by CodeBuild,
    and then made available to future deployment stages in CodePipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, you must first define the artifact(s) that CodeBuild should collect,
    which you can do by adding an `artifacts` parameter to the `buildspec.yml` build
    specification in the todobackend repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `artifacts` parameter configures CodeBuild to
    look for an artifact at the location `version.json`. Notice that you also add
    an additional command to the build phase, which writes the output of the `make
    version` command to the `version.json` file where CodeBuild expects to find an
    artifact.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, ensure that you commit and push your changes to the todobackend
    repository , so that the changes will be available for future builds.
  prefs: []
  type: TYPE_NORMAL
- en: Adding CodePipeline support to the deployment repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you use CodePipeline to deploy your environments using CloudFormation,
    you need to ensure that you can supply a configuration file that includes input
    stack parameters, stack tags, and stack policy configuration. This file must be
    implemented in a JSON format, as defined at [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/continuous-delivery-codepipeline-cfn-artifacts.html#w2ab2c13c15c15](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/continuous-delivery-codepipeline-cfn-artifacts.html#w2ab2c13c15c15),
    so we need to modify the format of the input parameters file in the `todobackend-aws`
    repository, which is currently in a `<parameter>=<value>` format, located in a
    file called `dev.cfg`. As per the referenced document, all of your input parameters
    need to reside in a JSON file under a key called `Parameters`, which you can define
    in a new file called `dev.json`, located at the root of the `todobackend-aws`
    repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, notice that I have updated the `ApplicationImageTag`
    value to `latest`. This is because our pipeline will actually obtain the value
    for the `ApplicationImageTag` input dynamically, from the build stage of our pipeline,
    and the `latest` value is a safer default value, in the event that you want to
    deploy your stack manually, from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the `dev.cfg` file is redundant, and can be deleted from your
    repository; however, note that you will need to modify the way you run deployments
    manually, from the command line, given that the `aws cloudformation deploy` command
    expects input parameters to be provided in a `<parameter>=<value>` format.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way that you can solve this is to use the `jq` utility to transform your
    new `dev.json` configuration file into the required `<parameter>=<value>` format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This command is now quite a mouthful, so, in order to simplify running this
    command, you could add a simple Makefile to the `todobackend-aws` repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `%` character in the task name captures a wildcard
    text value whenever you execute the `make deploy` command. For example, if you
    run make `deploy`/`dev`, then the `%` character would capture `dev`, and if you
    run make `deploy`/`prod`, then the captured value would be `prod`. You can then
    refer to the captured value by using the `$*` variable, which you can see that
    we have substituted in the stack name (`todobackend-$*`, which would expand to
    `todobackend-dev` and `todobackend-prod`, using the previous examples), and in
    the command to cat the `dev.json` or `prod.json` file. Note that because we have
    named our stack `todobackend` throughout this book, this command won't quite work
    for us, but if you rename your stack to `todobackend-dev`, this command will make
    it much easier to deploy to a given environment manually.
  prefs: []
  type: TYPE_NORMAL
- en: Before you continue, you need to add the new `dev.json` file, commit, and push
    your changes to the source Git repository, as we will soon add the `todobackend-aws`
    repository as another source in your CodePipeline pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an IAM role for CloudFormation deployments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you use CodePipeline to deploy your CloudFormation stacks, CodePipeline
    requires you to specify an IAM role that will be assumed by the CloudFormation
    service to deploy your stack. CloudFormation supports the ability to specify an
    IAM role that the CloudFormation service will assume, which is a powerful capability
    that allows for more advanced configuration scenarios, such as cross-account deployments
    from a central build account. This role must specify the CloudFormation service
    as a trusted entity that can assume the role; hence, you typically can't use administrative
    roles created for human access, such as the admin role that you have been using
    throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the required role, navigate to the IAM console, select Roles from
    the left-hand menu, and click on the Create role button. In the Choose the service section,
    select CloudFormation, and then click Next: Permissions to continue. On the Attach
    permissions policies screen, you can create or select an appropriate policy with
    the various permissions required to create the resources in your stack. To keep
    things simple, I will just select the AdministratorAccess policy. However, in
    a real-world scenario, you should create or choose a policy that only grants the
    specific permissions required to create your CloudFormation stacks. After clicking
    the Next: Review button, specify the role name of `cloudformation-deploy`, and
    click on the Create role button to create the new role:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2e5c6f9d-08b7-4abf-9aa4-8ae01e773f32.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding a deployment repository to CodePipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have the appropriate stack configuration file and an IAM deployment
    role in place for CodePipeline, you can get started in modifying your pipeline
    to support the continuous delivery of application changes to your target AWS environments.
    The first modification that you need to perform is to add the todobackend-aws
    repository as another source action to the source stage of your pipeline. To do
    this, navigate to the details view for your pipeline, and click on the Edit button.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Edit screen, you can click on the pencil icon at the top right-hand
    corner of the source stage, which will change the view and allow you to add a
    new source action, either before, after, or at the same level as the current action
    for the todobackend repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/99536673-029a-4c09-b052-0f5e5314af0f.png)Editing a pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: 'For our scenario, we can download the deployment repository source in parallel;
    so, add a new action at the same level as the other source repository, which will
    open an Add action dialog. Select Source for the Action category, configure an
    Action name of `DeploymentRepository` or similar, and, after choosing GitHub as
    the Source provider and clicking on the Connect to GitHub button, select the master
    branch on the `docker-in-aws/todobackend-aws` repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2b70a550-a045-4e69-b305-4a204589bfe5.png)Adding a deployment repository'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, scroll to the bottom of the page, and configure a name for the output
    artifact of this source action. CodePipeline will make the infrastructure templates
    and configuration in the deployment repository available to other stages in your
    pipeline, which you can reference by the configured output artifact name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3dfcd5c8-f127-4f80-a986-f2484d9a2254.png)Configuring an output artifact
    name'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, you also configure the output artifact name as
    `DeploymentRepository` (the same as the source action name), which helps, as the
    pipeline details view only shows stage and action names, and does not show artifact
    names.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an output artifact to the build stage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After adding the DeploymentRepository action, the Edit pipeline screen should
    look as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f8faf3c3-1c42-456f-8918-12c795137764.png)Edit pipeline screen'
  prefs: []
  type: TYPE_NORMAL
- en: The next pipeline configuration task that you need to perform is to modify the
    CodeBuild build action within the build stage, which was created for you by the
    CodePipeline wizard, when you created the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do this by clicking on the pencil icon in the right-hand corner of
    the CodeBuild action box as shown in the preceding screenshot, which opens the
    Edit action dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/76a52a53-f5b4-48dd-99ff-14fadd367347.png)Editing build action'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, notice that the CodePipeline wizard has already
    configured an input and output artifact:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Input artifacts: The CodePipeline wizard names this `MyApp`, which refers to
    the output artifact associated with the source repository that you referenced
    when you created the pipeline (in this case, this is the GitHub todobackend repository).
    If you want to rename this artifact, you must ensure that you rename the output
    artifact name on the owning action (in this case, the source action in the source
    stage), and then update any action that uses the artifact as an input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Output artifacts: The CodePipeline wizard names this `MyAppBuild` by default,
    which can then be referenced in later stages of your pipeline. The output artifacts
    are determined by the artifacts property in the `buildspec.yml` file, and for
    our use case, this artifact is not the application build; instead, it is just
    a version artifact that captures version metadata (`version.json`), so we rename
    this artifact to `ApplicationVersion`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a deployment stage to the pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After clicking on the Update button in the preceding screenshot, you can add
    a new stage by clicking the Add Stage box below the build stage. For the stage
    name, enter the name `Dev`, which will represent a deployment into an environment
    called Dev, and then click on the Add Action box to add a new action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/294d261f-8ecd-4942-8a13-7c8e5773895a.png)Adding a deploy action'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because this is a deployment stage, select Deploy from the Action category
    drop-down menu, configure an action name of Deploy, and select AWS CloudFormation
    as the Deployment provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6aafc914-9182-4329-881f-2c1faf719f56.png)Configuring a CloudFormation
    deploy action'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will expose a number of configuration parameters related to CloudFormation
    deployment, as shown in the preceding screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Action mode: Select the Create or update a stack option, which will create
    a new stack if the stack does not exist, or update an existing stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Stack name: References the existing todobackend stack that you have already
    deployed in previous chapters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Template: Refers to the CloudFormation template file that should be deployed.
    This is expressed in the format `InputArtifactName::TemplateFileName`, which,
    in our case, is `DeploymentRepository::stack.yml`, given that we configured an
    output artifact name of `DeploymentRepository` for the `DeploymentRepository`
    source action, and our stack is located in the file `stack.yml`, at the root of
    the repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Template configuration: Refers to the configuration file that is used to provide
    stack parameters, tags, and a stack policy. This needs to reference the new `dev.json`
    file that you created earlier,, within the `todobackend-aws` deployment repository;
    it is configured in the same format as the template parameter, with a value of `DeploymentRepository::dev.json`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you have configured the properties shown in the preceding screenshot,
    scroll down further and expand the Advanced section, as demonstrated in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7a23b618-6734-4918-96ab-b21350aecc7c.png)Configuring additional
    CloudFormation deploy action properties'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following describes each of the additional parameters that you need to
    configure:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Capabilities: This grants permission to the CloudFormation deployment action
    to create IAM resources on your behalf, and is identical in meaning to the`--capabilities`
    flag that you pass to the `aws cloudformation deploy` command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Role name: This specifies the IAM role used by the CloudFormation deployment
    action to deploy your CloudFormation stack. Reference the `cloudformation-deploy`
    role that you created earlier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Parameter overrides: This parameter allows you to override input parameter
    values that are normally supplied by the template configuration file (`dev.json`),
    or default values within the CloudFormation template. For our use case, we need
    to override the `ApplicationImageTag` parameter, given that this needs to reflect
    the image tag that is created as part of the build stage. CodePipeline supports
    two types of parameter overrides (see [Using Parameter Override Functions](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/continuous-delivery-codepipeline-parameter-override-functions.html)),
    and, for our use case, we are using the `Fn::GetParam` override, which can be
    used to extract property values from a JSON file in an artifact that is output
    by your pipeline. Recall that we added a `make version` task to the todobackend
    repository earlier in this chapter, which outputs the file `version.json` that
    is collected as an artifact as part of the CodeBuild build specification. We updated
    the build action to refer to this artifact as `ApplicationVersion`. In the preceding
    screenshot, the input list that is supplied to the `Fn::GetParam` call first references
    the artifact (`ApplicationVersion`), the path to the JSON file in the artifact
    (`version.json`), and finally, the key within the JSON file (`Version`) that holds
    the parameter override value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Input artifacts: This must specify any input artifacts that you reference in
    your deployment configuration. Here, we add `DeploymentRepository` (used for both
    the template and template configuration parameters) and `ApplicationVersion` (used
    in the parameter overrides configuration).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once complete, click on the Add action button, and then you can click on Save
    pipeline changes to complete the configuration of your pipeline. At this point,
    you can test that your new deployment action is working by clicking on the Release
    change button, which manually triggers a new execution of your pipeline; within
    a few minutes, your pipeline should successfully build, test, and publish a new
    image as part of the build stage, and then successfully deploy your changes to
    your todobackend stack via the dev stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9c4d6c8e-0bbc-47b0-85dd-6e7afdb035c0.png)Successful CloudFormation
    deployment via CodePipeline'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, you can click on the Details link, either during
    or after deployment, which takes you to the CloudFormation console and shows you
    details about the in-progress or completed deployment. If you expand the Parameters
    tab, you should see that ApplicationImageTag is referencing a tag in the format
    of  `<long commit hash>`.`<codebuild job id>`, confirming that our pipeline has,
    in fact, deployed the Docker image that was built during the build stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/28a8570e-e4d2-4ab4-ac45-13e6a2063286.png)Confirming an overridden
    input parameter'
  prefs: []
  type: TYPE_NORMAL
- en: Continuously delivering to production using CodePipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we are continuously deploying into a non-production environment, the
    final step in our continuous delivery journey is to enable the ability to deploy
    application releases into production in a controlled fashion. CodePipeline supports
    this capability by leveraging a useful feature of CloudFormation, called change
    sets. A change set describes the various configuration changes that will be applied
    to a given CloudFormation stack, based on any changes that may have been applied
    to your stack template file and/or input parameters. For new application releases,
    you are typically only changing an input parameter that defines the version of
    your new application artifact(s). For example, the dev stage of our pipeline overrides
    the `ApplicationImageTag` input parameter. In some scenarios, you may make wider
    changes to your CloudFormation stack and input parameters. For example, you might
    need to add new environment variables for your container, or you might add new
    infrastructure components or supporting services to you stack. These changes are
    typically committed to your deployment repository, and, given that our deployment
    repository is a source in our pipeline, any changes to your deployment repository
    will be captured as a change.
  prefs: []
  type: TYPE_NORMAL
- en: CloudFormation change sets provide an opportunity for you to review any changes
    that are about to be applied to a target environment, and if the change set is
    deemed safe, you can then initiate a deployment from that change set. CodePipeline
    supports generating CloudFormation change sets as a deployment action, which can
    then be combined with a separate manual approval action, which allows for an appropriate
    person to review the change set and subsequently approve or reject the change.
    If the change is approved, you can then trigger a deployment from the change set,
    providing an effective means to provide controlled releases into your production
    environment, or any type of environment that requires some form of change control.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now extend our pipeline to support the controlled deployment of application
    releases into a new production environment, which requires you to perform the
    following configuration changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new environment configuration file to your deployment repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a create change set action to the pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a manual approval action to the pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a deploy change set action to the pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy to production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a new environment configuration file to your deployment repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because we are creating a new production environment, we need to add an environment
    configuration file to the deployment repository, which will include input parameters
    specific to your production environment. As shown in the previous example, which
    demonstrates adding a new file called `prod.json` at the root of the `todobackend-aws`
    repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the format of the configuration file is identical to the `dev.json`
    file that we modified earlier. In a real-world scenario, of course, you would
    expect differences in the configuration file. For example, we are using the same
    application subnets and VPC ID; you would typically have a separate VPC, or even
    a separate account, for production, but to keep things simple, we will just deploy
    our production environment into the same VPC and subnets as our dev environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also need to make a few minor changes to our CloudFormation stack file,
    as there are some hardcoded names that will cause conflicts if you attempt to
    create a new stack in the same AWS account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, I have commented the previous configurations, and
    then highlighted the new configuration that is required. In all cases, we replace
    the hardcoded reference to todobackend with a reference to the stack name. Given
    that CloudFormation stack names must be unique within a given AWS account and
    region, this ensures that the modified resources will have unique names that do
    not conflict with other stacks in the same account and region.
  prefs: []
  type: TYPE_NORMAL
- en: To keep things simple, the CloudFormation stack for the production environment
    will use the same secret that we created back in the *Managing Secrets* chapter.
    In a real-world scenario, you would maintain separate secrets per environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the new configuration file and template changes in place, make sure that
    you have committed and pushed your changes to GitHub before proceeding to the
    next section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Adding a create change set action to the pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now ready to add a new stage to our pipeline that will deploy our application
    to production. We will create the first action in this stage, which creating a
    CloudFormation change set.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the pipeline details view for your pipeline, click on the Edit button and
    add a new stage called Production after the dev stage, and then add an action
    to the new stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/709983ae-b16b-4beb-8387-94be2f9b2b00.png)Adding a production stage
    to the pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Add action dialog box, you need to create an action that is similar
    to the deploy action that you created for the dev stage, with a few variations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1b96f366-2196-493a-af18-a12ece18dcb5.png)Adding a create change
    set action to the pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you compare the deploy action configuration for the dev stage, with the
    new create change set action configuration as shown in the preceding screenshot,
    the configuration is very similar, except for the following key differences:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Action mode: You configure this as `create` or `replace` a change set, which,
    instead of deploying the stack, will just create a new change set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Stack name: Because this action relates to our production environment, you
    need to configure a new stack name, which we will call `todobackend-prod`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Change set name: This defines a name for the change set. I typically just name
    this the same as the stack name, given that the action will create or replace
    the change set on each execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Template configuration: Here, you need to reference the new `prod.json` file
    that you added to the `todobackend-aws` repository in the earlier example, as
    this holds the input parameters specific to your production environment. This
    file is made available via the `DeploymentRepository` artifact that is created
    from the `todobackend-aws` repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, you need to scroll down, expand the Advanced section, configure the Parameter
    overrides property using the `Fn::GetParam`  syntax, and finally, configure both
    the `ApplicationVersion` and `DeploymentRepository` artifacts as input artifacts.
    This is identical to the configuration that you performed earlier, for the `dev`/`deploy`
    action.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a manual approval action to the pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After you have completed the configuration of the ChangeSet action, you will
    need to add a new action that comes after the ChangeSet action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8e665d07-b1fc-496e-aa77-9f0d637f6c89.png)Adding an approval action
    to the pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: In the Add action dialog box, select Approval for the Action category, and then
    configure an Action name of ApproveChangeSet. After selecting an Approval type
    of Manual approval, notice that you can add an SNS topic ARN and other information
    to the manual approval request. This could then be used to send an email to the
    approver, or to trigger a lambda function that performs some custom action, such
    as posting a message into a messaging tool like Slack.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a deploy change set action to the pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final action that you need to create is one that will deploy the change
    set created earlier in the ChangeSet action, once the ApproveChangeSet action
    has been approved:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8e4948db-2942-4902-9e0b-1ef79d3935f1.png)Adding an execute change
    set action to the pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, we have selected an Action mode of Execute a change
    set, and then configured the Stack name and Change set name, which must match
    the same values that you configured earlier, in the ChangeSet action.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to production
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After clicking on Add action in the preceding screenshot, your pipeline configuration
    for the new production stage should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/04e63fe0-ea86-4462-8481-35d21211f1e4.png)Adding a create change
    set action to the pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you can save your pipeline changes by clicking the Save pipeline
    changes button, and test your new pipeline stage by clicking the Release change
    button, which will force a new pipeline execution. After the pipeline successfully
    executes the build and dev stages, the production stage will be invoked for the
    first time, with a CloudFormation change set created by the ChangeSet action,
    after which the approval action will be triggered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fe4dfcc1-0aef-4ddd-998c-946d30339bd9.png)Adding a create change
    set action to the pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: 'The pipeline will now wait for approval, and this is where an approver would
    typically review the previously created change set by clicking on the Details
    link for the ChangeSet action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ba618105-d503-4550-91a1-8173242461a1.png)CloudFormation change set'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding screenshot, the change set indicates that all
    resources in the stack will be created, given that the production environment
    does not currently exist. Subsequent deployments should have very little changes,
    given that the stack will be in place, and the typical change is to deploy a new
    Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: 'After reviewing the change set and returning to the CodePipeline details view,
    you can now approve (or reject) the change set by clicking on the Review button. 
    This will present an Approve or reject the revision dialog box, where you can
    add a comment and either Approve or Reject the change:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2af34076-a505-4017-b38f-120ab29e1f8b.png)Approving or rejecting
    a manual approval action'
  prefs: []
  type: TYPE_NORMAL
- en: If you click on Approve, the pipeline will proceed to the next action, which
    is to deploy the change set associated with the earlier ChangeSet action. For
    this first execution, a new stack called `todobackend-prod` will be deployed,
    and, once complete, you have successfully deployed a brand new production environment
    using CodePipeline!
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should test and verify that your new stack and application
    are working as expected, following the steps in the *Deploying an Application
    Load Balancer* section of the *Deploying Applications Using ECS* chapter to obtain
    the DNS name of the application load balancer endpoint that your production application
    endpoint will be served from. I also encourage you to trigger the pipeline, either
    manually or by making a test commit to either repository, and then reviewing the
    subsequent change set that is generated for an application deployment to an existing
    environment. Note that you can choose when you want to deploy to production. For
    example, your developers may commit application changes many times, with each
    change automatically deployed to your non-production environment, before you choose
    to deploy your next release to production. When you do choose to deploy to production,
    your production stage will take the most recent release that has been successfully
    deployed to your non-production environment.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have completed testing your production deployments, if you are using
    a free tier account, bear in mind that you now have multiple EC2 instances and
    RDS instances running, so you should consider tearing down your production environment,
    in order to avoid incurring charges.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you created an end-to-end continuous delivery pipeline that
    automatically tests, builds, and publishes Docker images for your application,
    continuously deploys new application changes into a non-production environment,
    and allows you to perform controlled releases into production that generate change
    sets and require manual approval before deployment to production can commence.
  prefs: []
  type: TYPE_NORMAL
- en: You learned how to integrate your GitHub repositories with CodePipeline by defining
    them as source actions in a source stage, and then created a build stage that
    used CodeBuild to test, build, and publish Docker images for your application.
    You added a build specification to the todobackend repository, which CodeBuild
    uses to execute your builds, and you created a custom CodeBuild container that
    was able to run Docker in Docker, to allow you to build a Docker image and perform
    integration and acceptance tests in a Docker Compose environment.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you created a deploy stage in CodePipeline, which automatically deploys
    application changes to the existing todobackend stack that we have worked with
    throughout this book. This required you to add a new source action in the source
    stage for the `todobackend-aws` repository, which makes the CloudFormation stack
    file and environment configuration file available as artifacts for later CloudFormation
    deployment actions. You also needed to create an output artifact for the todobackend
    repository, which, in this case, simply captures the Docker image tag built and
    published during the build stage, and makes it available for subsequent stages.
    You then referenced this artifact as a parameter override to your dev stage deployment
    action, overriding the `ApplicationImageTag` parameter with the Docker image tag
    output in the build action version artifact.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you extended the pipeline to support controlled releases in a production
    environment, which requires a create change set action that creates a CloudFormation
    change set, a manual approval action that allows somebody to review the change
    set and approve/reject it, and a deployment action that executes the previously
    generated change set.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will change tracks and introduce the AWS Fargate service,
    which allows you to deploy your Docker applications without a need to deploy and
    manage your own ECS clusters and ECS container instances. We will take this opportunity
    to add support for the AWS X-Ray service by deploying an X-Ray daemon using Fargate,
    and will publish the daemon endpoint by using ECS service discovery.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What file do you typically include at the root of your application repository
    to support AWS CodeBuild?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True/false: AWS CodeBuild is a build service that spins up virtual machines
    and runs build scripts using AWS CodeDeploy.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the Docker configuration that you need to run to support the building
    of Docker images and multi-container build environments?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You wish to review the changes made to your CloudFormation templates before
    they are deployed. What feature of CloudFormation would you use to achieve this?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When deploying CloudFormation stacks using the CodePipeline CloudFormation deploy
    action, which service must be the trusted for the service role that you specify
    for these actions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You set up a new CodeBuild project that includes a build task that publishes
    to the Elastic Container Registry. Your first build fails when you attempt to
    publish the image. You confirm that the target ECR repository exists, and that
    you can manually publish images to the repository yourself. What is the likely
    cause of this problem?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You create a custom build container for CodeBuild that is published to ECR,
    and create a repository policy that allows ECR pull access from your AWS account.
    When executing a build, you get failures indicating that CodeBuild was unable
    to retry the custom image. How would you resolve this?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You create a custom build container that uses Docker in Docker to support Docker
    image builds. When the build container starts and you attempt to start the Docker
    daemon, a permissions error occurs. How would you resolve this?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can check the following links for more information about the topics covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: CodePipeline User Guide: [https://docs.aws.amazon.com/codepipeline/latest/userguide/welcome.html](https://docs.aws.amazon.com/codepipeline/latest/userguide/welcome.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CodeBuild User Guide: [https://docs.aws.amazon.com/codebuild/latest/userguide/welcome.html](https://docs.aws.amazon.com/codebuild/latest/userguide/welcome.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build Specification Reference for CodeBuild: [https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html](https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using AWS CodePipeline with CodeBuild: [https://docs.aws.amazon.com/codebuild/latest/userguide/how-to-create-pipeline.html](https://docs.aws.amazon.com/codebuild/latest/userguide/how-to-create-pipeline.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS CodePipeline Pipeline Structure Reference: [https://docs.aws.amazon.com/codepipeline/latest/userguide/reference-pipeline-structure.html](https://docs.aws.amazon.com/codepipeline/latest/userguide/reference-pipeline-structure.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Parameter Override Functions with AWS CodePipeline Pipelines: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/continuous-delivery-codepipeline-parameter-override-functions.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/continuous-delivery-codepipeline-parameter-override-functions.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
