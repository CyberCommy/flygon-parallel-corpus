- en: '*Chapter 15*: Understanding the Boot Process'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第15章*：理解引导过程'
- en: The boot process is what happens between the moment you power on a machine (physical
    or virtual) and when the operating system is completely loaded.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 引导过程是指从您打开机器（物理或虚拟）的那一刻到操作系统完全加载的过程。
- en: 'Like in many good video games, there are three stages for it: the initial startup
    performed by the hardware (again physical or virtual), the load of the initial
    stages of the operating system, and then the mechanism that helps run the required
    services in the system. We will review the three stages in this chapter, and we
    will also add tips and tricks in order to intervene in a system and perform rescue
    operations.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 就像许多好的视频游戏一样，它有三个阶段：硬件执行的初始启动（再次是物理或虚拟），操作系统初始阶段的加载，然后是帮助在系统中运行所需服务的机制。 我们将在本章中审查这三个阶段，并且还将添加提示和技巧，以干预系统并执行救援操作。
- en: 'The sections in this chapter in which we will cover all these topics are as
    follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将涵盖的部分如下：
- en: Understanding the boot process – BIOS and UEFI booting
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解引导过程 - BIOS和UEFI引导
- en: Working with GRUB, the bootloader, and initrd system images
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GRUB，引导加载程序和initrd系统映像
- en: Managing the boot sequence with systemd
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用systemd管理引导顺序
- en: Intervening in the boot process to gain access to a system
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 干预引导过程以获取对系统的访问权限
- en: It is very likely that you will not need to make many changes in the first two
    stages of the boot process, but these are the points that could be extremely helpful
    in cases of emergency, forensics, or major failures. That's why it's important
    to go through them carefully.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在引导过程的前两个阶段，您很可能不需要进行太多更改，但在紧急情况，取证或重大故障的情况下，这些点可能极其有帮助。 这就是为什么仔细阅读它们很重要。
- en: The third stage, the one managed by **systemd**, is where more actions and changes
    will be performed in order to manage which services are running by default in
    the system. We have already seen examples of most of the tasks to be performed
    in previous chapters; however, in this one we will provide a comprehensive review.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 第三阶段，由 **systemd** 管理，将执行更多操作和更改，以管理系统中默认运行的服务。 我们已经在之前的章节中看到了大部分要执行的任务的示例；
    但是，在这一章中，我们将提供全面的审查。
- en: Let's get started with stage one.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始第一阶段。
- en: Understanding the boot process – BIOS and UEFI booting
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解引导过程 - BIOS和UEFI引导
- en: Computers have hardware-embedded software controllers, also called **firmware**,
    that let you manage the very lowest layers of the hardware. This firmware is what
    performs the first recognition of what hardware is available in the system and
    what hardware features are enabled (such as **pre-boot network execution**, called
    **PXE**).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机具有硬件嵌入式软件控制器，也称为 **固件**，可让您管理硬件的最底层。 这个固件是对系统中可用的硬件进行第一次识别以及启用的硬件功能（如 **预引导网络执行**，称为
    **PXE**）。
- en: In the architecture known as **PC** (for **Personal Computer**), also referred
    to as x86, which Intel and IBM popularized, the embedded firmware is referred
    to as **BIOS**, which stands for **Basic Input and Output System**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在被称为 **PC**（**个人计算机**）的架构中，也称为x86，由英特尔和IBM推广，嵌入式固件称为 **BIOS**，代表 **基本输入输出系统**。
- en: 'The BIOS boot process, with Linux, takes the following steps:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: BIOS引导过程，使用Linux，采取以下步骤：
- en: The machine is powered on and BIOS firmware is loaded.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算机开机并加载BIOS固件。
- en: The firmware initializes devices such as keyboard, mouse, storage, and other
    peripherals.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 固件初始化设备，如键盘，鼠标，存储和其他外围设备。
- en: The firmware reads the configuration, including the boot order, specifying which
    storage device is the one to continue the boot process with.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 固件读取配置，包括引导顺序，指定哪个存储设备是继续引导过程的设备。
- en: Once the storage device is selected, BIOS will load the **Master Boot Record**
    (**MBR**) on it, which will enable running the **operating system loader**. In
    RHEL, the operating system loader is called **Grand Unified Bootloader** (**GRUB**).
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦选择了存储设备，BIOS将加载其中的 **主引导记录** (**MBR**)，这将启用 **操作系统加载程序**。 在RHEL中，操作系统加载程序称为
    **Grand Unified Bootloader** (**GRUB**)。
- en: GRUB loads the configuration and the `vmlinuz`, and the initial boot image in
    a file called `initrd`. All of the GRUB configuration `vmlinuz` and `initrd` files
    are stored in the `/boot` partition.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GRUB加载配置和 `vmlinuz`，以及名为 `initrd` 的初始引导映像文件。 所有GRUB配置 `vmlinuz` 和 `initrd` 文件都存储在
    `/boot` 分区中。
- en: The initial boot image enables loading the first process of the system, also
    referred to as `init`, which in RHEL8 is **systemd**.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始引导映像使得加载系统的第一个进程成为可能，也称为 `init`，在RHEL8中是 **systemd**。
- en: '*systemd* loads the rest of the operating system.'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*systemd* 加载操作系统的其余部分。'
- en: For this process to happen, the disk has to have an MBR partition table, and
    the partition assigned to `/boot` has to be marked as bootable.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个过程发生，磁盘必须有一个MBR分区表，并且分配给 `/boot` 的分区必须标记为可引导。
- en: Tip
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The MBR partition table format is very limited, allowing only four primary partitions
    and using extensions such as extended partitions to overcome this limit. It is
    not recommended to use this type of partition unless it is completely required.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: MBR分区表格式非常有限，只允许四个主分区，并使用扩展分区等扩展来克服这一限制。 不建议使用这种类型的分区，除非完全需要。
- en: 'The UEFI boot process is very similar to the BIOS boot process. **UEFI** stands
    for **Unified Extensible Firmware Interface**. The main difference in the boot
    sequence is that UEFI can access and read disk partitions directly. The flow for
    it is as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: UEFI引导过程与BIOS引导过程非常相似。 **UEFI** 代表 **统一可扩展固件接口**。 引导顺序的主要区别在于UEFI可以直接访问和读取磁盘分区。
    其流程如下：
- en: The machine is powered on and the UEFI firmware is loaded.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算机开机并加载UEFI固件。
- en: The firmware initializes devices such as keyboard, mouse, storage, and other
    peripherals.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 固件初始化设备，如键盘，鼠标，存储和其他外围设备。
- en: The firmware reads the configuration, in which it is specified which storage
    device and bootable partition to continue the boot process with (UEFI does not
    need an MBR to boot).
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 固件读取配置，其中指定了继续引导过程所需的存储设备和可引导分区（UEFI不需要MBR引导）。
- en: Once the storage device is selected, the partitions on it are read from the
    `/boot/efi` partition, and it continues to load GRUB.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择存储设备后，从`/boot/efi`分区读取其中的分区，并继续加载GRUB。
- en: GRUB then loads the `vmlinuz`, and the `initrd`. GRUB configuration `vmlinuz`
    and `initrd` files are stored in the `/boot` partition.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，GRUB加载`vmlinuz`和`initrd`。GRUB配置`vmlinuz`和`initrd`文件存储在`/boot`分区中。
- en: The initial boot image enables loading the first process of the system, also
    referred to as `init`, which in RHEL8 is **systemd**.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始引导映像使系统的第一个进程加载，也称为`init`，在RHEL8中是**systemd**。
- en: '*systemd* loads the rest of the operating system.'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*systemd*加载操作系统的其余部分。'
- en: UEFI has several advantages over BIOS, enabling more complete pre-boot environments
    and other capabilities such as secure boot and support for GPT partitions that
    can go beyond the 2 TB limit that MBR partitions have.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: UEFI相对于BIOS具有几个优点，可以启用更完整的预引导环境和其他功能，例如安全引导和对GPT分区的支持，可以超出MBR分区的2TB限制。
- en: The installer will take care of creating the boot and, if needed, UEFI partitions
    and binaries.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 安装程序将负责创建引导以及如果需要的UEFI分区和二进制文件。
- en: The part of pre-boot that needs to be known for the Red Hat Certified System
    Administrator certification is how to load the operating system loader from it.
    Through BIOS or UEFI we can select from which storage device the operating system
    will load and move to the next phase. Let's go to this next phase in the next
    section.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 需要了解的预引导部分是如何从中加载操作系统加载程序，这是红帽认证系统管理员认证考试的一部分。通过BIOS或UEFI，我们可以选择从哪个存储设备加载操作系统，并转移到下一个阶段。让我们在下一节中进入下一个阶段。
- en: Working with GRUB, the bootloader, and initrd system images
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GRUB、引导加载程序和initrd系统映像进行工作。
- en: Once the pre-boot execution is completed, the system will be running the GRUB
    bootloader.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 预引导执行完成后，系统将运行GRUB引导加载程序。
- en: GRUB has the mission to load the main file of an operating system, the **kernel**,
    pass parameters and options to it, and load the initial RAM disk, also known as
    **initrd**.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: GRUB的任务是加载操作系统的主文件**kernel**，向其传递参数和选项，并加载初始RAM磁盘，也称为**initrd**。
- en: 'GRUB can be installed by using the `grub2-install` command. We will need to
    know which disk device will be used to boot, in this case, `/dev/vda`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`grub2-install`命令安装GRUB。我们需要知道将用于引导的磁盘设备，例如`/dev/vda`：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Important note
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You should point `grub-install` to the disk you will use to boot the system,
    the same one that you configured in the BIOS/UEFI to boot from.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该将`grub-install`指向您将用于引导系统的磁盘，与您在BIOS/UEFI中配置的相同磁盘。
- en: This is intended to be used to manually rebuild a system or to fix a broken
    boot.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于手动重建系统或修复损坏引导的。
- en: 'GRUB files are stored in `/boot/grub2`. The main configuration file is `/boot/grub2/grub.cfg`;
    however, if you take a close look at this file you will see the following header:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: GRUB文件存储在`/boot/grub2`中。主配置文件是`/boot/grub2/grub.cfg`；但是，如果您仔细查看此文件，您将看到以下标题：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see, this file is automatically generated and, therefore, not intended
    to be edited manually. How do we make changes to it then? There are two ways to
    do so:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此文件是自动生成的，因此不打算手动编辑。那么我们如何进行更改呢？有两种方法可以这样做：
- en: The first way is by following the instructions mentioned in the `grub.cfg` file.
    This means editing the `/etc/default/grub` file and/or the contents in the `/etc/grub.d/`
    directory, and then regenerating the GRUB configuration by running `grub2-mkconfig`.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种方法是按照`grub.cfg`文件中提到的说明进行操作。这意味着编辑`/etc/default/grub`文件和/或`/etc/grub.d/`目录中的内容，然后通过运行`grub2-mkconfig`重新生成GRUB配置。
- en: The second way is by using the `grubby` command-line tool.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种方法是使用`grubby`命令行工具。
- en: Important note
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In RHEL, when there is a new version of the kernel, it is not updated, but a
    new kernel is installed alongside the previous one, adding a new entry in GRUB.
    In this way, there is an easy way to roll back to a previous working kernel in
    case it's needed. During the installation, a new updated `initrd` is created for
    the new kernel.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在RHEL中，当有新版本的内核时，不会更新现有内核，而是在先前的内核旁边安装新的内核，并在GRUB中添加新的条目。这样，如果需要，可以轻松回滚到以前的工作内核。在安装过程中，为新内核创建了新的更新的`initrd`。
- en: 'Let''s take a look at the current kernel configuration with `grubby`. The `--default-kernel`
    option will show which kernel file is loaded by default:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`grubby`查看当前的内核配置。`--default-kernel`选项将显示默认加载的内核文件：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `--default-title` option will show the name used during boot:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`--default-title`选项将显示引导时使用的名称：'
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can see more information for the default kernel by using the `--info` option:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`--info`选项，我们可以查看默认内核的更多信息：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can see the options passed to GRUB:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到传递给GRUB的选项：
- en: '`index`: Shows the index number of the entry'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index`：显示条目的索引号'
- en: '`kernel`: The file containing the kernel that will be loaded to run the core
    of the operating system'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kernel`：包含将加载以运行操作系统核心的内核的文件'
- en: '`root`: The partition, or logical volume, that will be assigned to the root
    `/` directory and mounted'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`root`：将分配给根`/`目录并挂载的分区或逻辑卷'
- en: '`initrd`: File containing the RAM disk to perform the initial part of the boot
    process'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initrd`：包含RAM磁盘的文件，用于执行引导过程的初始部分'
- en: '`title`: Descriptive title to be shown to the user during the boot process'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`：在引导过程中向用户显示的描述性标题'
- en: '`id`: Identifier of the boot entry'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：引导项的标识符'
- en: Tip
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'You may want to run the `grubby` command to obtain the information for the
    kernel configured as default. To do so, you can do it by running the following
    command: `grubby --info=$(grubby --default-kernel)`.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望运行`grubby`命令以获取默认配置的内核信息。为此，可以通过运行以下命令来执行：`grubby --info=$(grubby --default-kernel)`。
- en: 'Let''s make the boot process more verbose by removing the `quiet` and `rhbg`
    arguments passed to the kernel:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s test it by rebooting the machine with the `systemctl reboot` command.
    This is an example output:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.1 – Verbose boot'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_15_001.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.1 – Verbose boot
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'In a normal boot, this may not be very useful as it goes too fast. However,
    if there are issues, it can help debug the situation from the console. To review
    these messages after booting, the `dmesg` command can be used:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.2 – Output of the dmesg command'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_15_002.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.2 – Output of the dmesg command
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add an argument to the kernel by using the `--args` option. Let''s add
    the `quiet` option again:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Important note
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: The `--info` and `--update-kernel` options accept the `ALL` option to review
    or do actions to all the configured kernels.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: If any administration task requires us to change kernel parameters, now we know
    how to do it. Let's move to the next section of the boot process, `initrd`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'The `/boot/initramfs-4.18.0-240.15.1.el8_3.x86_64.img`. It can be regenerated
    by using the `dracut` command. Let''s see an example of how to rebuild the current
    `initrd` file:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can see in the previous output what kernel modules and files, required for
    early access, are included in the `initrd` file. This step is useful when our
    `initrd` file is corrupted and also when restoring a system from a backup, if
    done in different hardware, to include the proper storage drivers.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the manual page of `dracut` to learn more on options to create `initrd`
    files. There''s a Red Hat knowledge base article to unpack `initrd`, an interesting
    exercise to learn more: [https://access.redhat.com/solutions/24029.](https://access.redhat.com/solutions/24029'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: We have learned the very basics of the early stages of the boot process in order
    to be able to start troubleshooting boot issues, as required to become an RHCSA.
    This advanced topic could be covered in an entire book, but very little of it
    will be used in your daily tasks as a system administrator. That's why we only
    included the required aspects of it. We will include a specific use case in the
    last section of this chapter called *Intervening in the boot process to gain access
    to a system* and fix disk issues. Let's move on to the next topic on how services
    are managed in RHEL with **systemd**.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Managing the boot sequence with systemd
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already learned how the firmware of the system will take care of pointing
    at a disk to run the operating system loader, which in RHEL is GRUB.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: GRUB will load the kernel and initrd to prepare the system to start. Then it's
    time to start the first process of the system, also referred to as process 1 or
    PID 1 (**PID** stands for **process identifier**). This process has to take care
    of loading all the required services in the system efficiently. In RHEL8, the
    PID 1 is run by **systemd**.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B16799_04_Final_Sk_ePub.xhtml#_idTextAnchor059), *Tools for
    Regular Operations*, we described services and targets management with systemd.
    Let's review in this chapter its interactions with the boot sequence.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'The first two things related to the boot sequence that we can do with `systemctl`
    tool:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will see that the system will reboot. We can check how long the system has
    been running with the `uptime` command:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now it''s time to check `poweroff`. Before doing so, remember that after running
    this command you will need to have a way to power on the machine again. Once we
    are aware of the process we are going to follow, let''s run it:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now I shall power my machine on again.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: There is a command that will stop the system but without sending the signal
    to power the machine off, which is `systemctl halt`. The cases where this can
    be used are rare; however, it's good to know that it exists and what it does.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: The previously shown commands can be abbreviated to `reboot` and `poweroff`.
    If you check the file in `/usr/sbin/poweroff` you will see that it is a symbolic
    link pointing to `systemctl`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 4*](B16799_04_Final_Sk_ePub.xhtml#_idTextAnchor059), *Tools for
    Regular Operations*, we also reviewed how to set a default `systemctl`. However,
    we can override the default configuration during boot time by passing the `systemd.unit`
    parameter to the kernel. We can do that using `grubby`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now the system is rebooting. The `systemd.unit=emergency.target` parameter has
    been passed by **GRUB** to the **kernel**, and from the **kernel** to **systemd**,
    which, in turn, will ignore the default configuration and load the services required
    for the **emergency target**.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the system is started in emergency mode and is waiting for the root password
    to give you control:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.3 – RHEL system booted in emergency mode'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_15_003.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.3 – RHEL system booted in emergency mode
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: In emergency mode, there is no network configured and no other process running.
    You can make changes to the system knowing that no other user is accessing it.
    Also, only the `/` filesystem is mounted in read-only mode.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'If a filesystem in the system is broken, this would be a good way to check
    it without any service accessing it. Let''s try it with the command for checking
    the filesystem, which is called `fsck`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The filesystem is OK. We could run `xfs_repair` on it, as it is an `xfs` filesystem
    (`fsck` detects the filesystem used) if it had issues that required a fix.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point we may be thinking, how can we make changes to the root filesystem
    if it''s already mounted as read-only at `/`? The process starts by remounting
    the `/` filesystem as read-write:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Remember, you can access the manual pages for the command by running `man mount`.
    Now our root filesystem is mounted in `/` as read-write. We also need to mount
    `/boot`, so let''s do it:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With the `/boot` mounted, let''s do some admin tasks, such as removing the
    arguments we have used in GRUB:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: And we are back to a regular boot in the system. This may not be a practical
    way to go to emergency mode in Linux, but it shows how to pass parameters to systemd
    at boot.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: There is `rescue.target` that loads more services and makes the process somewhat
    easier. It does so by waiting for `sysinit.target` to complete, something that
    the emergency target does not do. A good exercise would be to repeat the previous
    sequence with `rescue.target`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: We will see in the coming section how to make this change, and similar ones,
    for a one-time boot only and more easily during the GRUB boot sequence, and in
    a way in which no password is required.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Intervening in the boot process to gain access to a system
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes you need to intervene in a system that was handed over in which you
    do not have the password for the `root` user. This is an exercise that, though
    it sounds like an emergency situation, is more frequent than you would expect.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: The boot sequence must not have any disk encrypted for it to work or you will
    need the password for the encrypted volumes.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'The way to perform this procedure starts by stopping the boot process during
    the GRUB menu. This means we need to restart the system. Once the BIOS/UEFI checks
    have finished, the system will load GRUB. There we can stop the count by pressing
    the down or up arrow key while it''s waiting for the selection of the kernel,
    as in the following screenshot:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.4 – GRUB menu to select the kernel'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_15_004.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.4 – GRUB menu to select the kernel
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'We move back to the first entry. Then we read the bottom of the screen where
    we find the instructions to edit the boot line:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.5 – GRUB menu to select the kernel'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_15_005.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.5 – GRUB menu to select the kernel
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'If we press the *E* key, we will be able to edit the boot line selected in
    the menu. We will see the following five lines:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.6 – GRUB menu to select the kernel'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_15_006.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.6 – GRUB menu to select the kernel
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'The first three lines with `load_video`, `set` `gfx_payload=keep`, and `insmod
    gzio` are setting options for GRUB. The next two options are the ones that are
    important. Let''s review them:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '`linux`: Defines the kernel to be loaded and passes parameters to it'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initrd`: Defines where to load the initrd and if there are any options for
    it'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the `linux` line is so long that it is wrapped, as we can see
    by the `\` symbols, which mean that the line continues below.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'We shall now go to the end of the `linux` line and add the `rd.break` option,
    as in the following screenshot:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.7 – linux kernel line edited with the rd.break option'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_15_007.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.7 – linux kernel line edited with the rd.break option
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'To boot the edited line, we only need to press *Ctrl* + *X*. The `rd.break`
    option stops the boot process before the initrd is loaded. The situation now is
    the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: A single shell is loaded.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current root filesystem mounted on `/` is a minimal one with basic administration
    commands.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The target root filesystem is mounted in `/sysroot` as read-only (instead of
    on `/`).
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No other filesystems are mounted.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SELinux is not loaded.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first thing we can do now is switch to the real, on-disk root filesystem
    with `chroot`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now our root filesystem is properly mounted, but read-only. Let''s change that
    in the same way as we did in the previous section:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we need to change the root user password with the `passwd` command:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The password for the root user is now changed and the `/etc/shadow` file has
    been updated. However, it was modified without SELinux enabled, and therefore
    it could cause an issue in the next boot. To avoid that, there is a mechanism
    to fix the SELinux labels during the next boot. This mechanism consists of creating
    the `/.autorelabel` hidden empty file and then rebooting the system:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once the file is created, it''s time to reboot it to apply the SELinux changes.
    In this status, the machine may require forcing the power off and then powering
    on. During the next boot, we will see the SELinux autorelabel happening:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.8 – SELinux autorelabel during boot'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_15_008.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.8 – SELinux autorelabel during boot
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Now we can log in with the root user and its new password.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have reviewed the boot sequence in this chapter. As you have seen, it is
    not long, but it is complex and it is also very important as no system can run
    if it cannot boot. We have learned the main differences between a BIOS-enabled
    system and a UEFI one, which enables some capabilities but also has its own requirements.
    We have also learned about GRUB and its important role in the boot sequence, how
    to modify entries permanently with `grubby`, and how to make a one-time modification.
    We now know the main files to boot, such as the kernel, `vmlinuz`, and the initial
    RAM disk, `initrd`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also showed us how to start in emergency and rescue modes, as well
    as how to intervene in a system to reset the root password.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: We are now more prepared to handle any difficult situation in our systems with
    these tools and procedures. It's time to dive deeper and learn about kernel tuning
    and performance profiles in the next chapter.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
