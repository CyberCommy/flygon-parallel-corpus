- en: '*Chapter 15*: Understanding the Boot Process'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The boot process is what happens between the moment you power on a machine (physical
    or virtual) and when the operating system is completely loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like in many good video games, there are three stages for it: the initial startup
    performed by the hardware (again physical or virtual), the load of the initial
    stages of the operating system, and then the mechanism that helps run the required
    services in the system. We will review the three stages in this chapter, and we
    will also add tips and tricks in order to intervene in a system and perform rescue
    operations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The sections in this chapter in which we will cover all these topics are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the boot process – BIOS and UEFI booting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with GRUB, the bootloader, and initrd system images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the boot sequence with systemd
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intervening in the boot process to gain access to a system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is very likely that you will not need to make many changes in the first two
    stages of the boot process, but these are the points that could be extremely helpful
    in cases of emergency, forensics, or major failures. That's why it's important
    to go through them carefully.
  prefs: []
  type: TYPE_NORMAL
- en: The third stage, the one managed by **systemd**, is where more actions and changes
    will be performed in order to manage which services are running by default in
    the system. We have already seen examples of most of the tasks to be performed
    in previous chapters; however, in this one we will provide a comprehensive review.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started with stage one.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the boot process – BIOS and UEFI booting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Computers have hardware-embedded software controllers, also called **firmware**,
    that let you manage the very lowest layers of the hardware. This firmware is what
    performs the first recognition of what hardware is available in the system and
    what hardware features are enabled (such as **pre-boot network execution**, called
    **PXE**).
  prefs: []
  type: TYPE_NORMAL
- en: In the architecture known as **PC** (for **Personal Computer**), also referred
    to as x86, which Intel and IBM popularized, the embedded firmware is referred
    to as **BIOS**, which stands for **Basic Input and Output System**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The BIOS boot process, with Linux, takes the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The machine is powered on and BIOS firmware is loaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The firmware initializes devices such as keyboard, mouse, storage, and other
    peripherals.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The firmware reads the configuration, including the boot order, specifying which
    storage device is the one to continue the boot process with.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the storage device is selected, BIOS will load the **Master Boot Record**
    (**MBR**) on it, which will enable running the **operating system loader**. In
    RHEL, the operating system loader is called **Grand Unified Bootloader** (**GRUB**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: GRUB loads the configuration and the `vmlinuz`, and the initial boot image in
    a file called `initrd`. All of the GRUB configuration `vmlinuz` and `initrd` files
    are stored in the `/boot` partition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The initial boot image enables loading the first process of the system, also
    referred to as `init`, which in RHEL8 is **systemd**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*systemd* loads the rest of the operating system.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For this process to happen, the disk has to have an MBR partition table, and
    the partition assigned to `/boot` has to be marked as bootable.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The MBR partition table format is very limited, allowing only four primary partitions
    and using extensions such as extended partitions to overcome this limit. It is
    not recommended to use this type of partition unless it is completely required.
  prefs: []
  type: TYPE_NORMAL
- en: 'The UEFI boot process is very similar to the BIOS boot process. **UEFI** stands
    for **Unified Extensible Firmware Interface**. The main difference in the boot
    sequence is that UEFI can access and read disk partitions directly. The flow for
    it is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The machine is powered on and the UEFI firmware is loaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The firmware initializes devices such as keyboard, mouse, storage, and other
    peripherals.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The firmware reads the configuration, in which it is specified which storage
    device and bootable partition to continue the boot process with (UEFI does not
    need an MBR to boot).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the storage device is selected, the partitions on it are read from the
    `/boot/efi` partition, and it continues to load GRUB.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: GRUB then loads the `vmlinuz`, and the `initrd`. GRUB configuration `vmlinuz`
    and `initrd` files are stored in the `/boot` partition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The initial boot image enables loading the first process of the system, also
    referred to as `init`, which in RHEL8 is **systemd**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*systemd* loads the rest of the operating system.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: UEFI has several advantages over BIOS, enabling more complete pre-boot environments
    and other capabilities such as secure boot and support for GPT partitions that
    can go beyond the 2 TB limit that MBR partitions have.
  prefs: []
  type: TYPE_NORMAL
- en: The installer will take care of creating the boot and, if needed, UEFI partitions
    and binaries.
  prefs: []
  type: TYPE_NORMAL
- en: The part of pre-boot that needs to be known for the Red Hat Certified System
    Administrator certification is how to load the operating system loader from it.
    Through BIOS or UEFI we can select from which storage device the operating system
    will load and move to the next phase. Let's go to this next phase in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Working with GRUB, the bootloader, and initrd system images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the pre-boot execution is completed, the system will be running the GRUB
    bootloader.
  prefs: []
  type: TYPE_NORMAL
- en: GRUB has the mission to load the main file of an operating system, the **kernel**,
    pass parameters and options to it, and load the initial RAM disk, also known as
    **initrd**.
  prefs: []
  type: TYPE_NORMAL
- en: 'GRUB can be installed by using the `grub2-install` command. We will need to
    know which disk device will be used to boot, in this case, `/dev/vda`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You should point `grub-install` to the disk you will use to boot the system,
    the same one that you configured in the BIOS/UEFI to boot from.
  prefs: []
  type: TYPE_NORMAL
- en: This is intended to be used to manually rebuild a system or to fix a broken
    boot.
  prefs: []
  type: TYPE_NORMAL
- en: 'GRUB files are stored in `/boot/grub2`. The main configuration file is `/boot/grub2/grub.cfg`;
    however, if you take a close look at this file you will see the following header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this file is automatically generated and, therefore, not intended
    to be edited manually. How do we make changes to it then? There are two ways to
    do so:'
  prefs: []
  type: TYPE_NORMAL
- en: The first way is by following the instructions mentioned in the `grub.cfg` file.
    This means editing the `/etc/default/grub` file and/or the contents in the `/etc/grub.d/`
    directory, and then regenerating the GRUB configuration by running `grub2-mkconfig`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second way is by using the `grubby` command-line tool.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In RHEL, when there is a new version of the kernel, it is not updated, but a
    new kernel is installed alongside the previous one, adding a new entry in GRUB.
    In this way, there is an easy way to roll back to a previous working kernel in
    case it's needed. During the installation, a new updated `initrd` is created for
    the new kernel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the current kernel configuration with `grubby`. The `--default-kernel`
    option will show which kernel file is loaded by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `--default-title` option will show the name used during boot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see more information for the default kernel by using the `--info` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the options passed to GRUB:'
  prefs: []
  type: TYPE_NORMAL
- en: '`index`: Shows the index number of the entry'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kernel`: The file containing the kernel that will be loaded to run the core
    of the operating system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`root`: The partition, or logical volume, that will be assigned to the root
    `/` directory and mounted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initrd`: File containing the RAM disk to perform the initial part of the boot
    process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title`: Descriptive title to be shown to the user during the boot process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`id`: Identifier of the boot entry'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'You may want to run the `grubby` command to obtain the information for the
    kernel configured as default. To do so, you can do it by running the following
    command: `grubby --info=$(grubby --default-kernel)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make the boot process more verbose by removing the `quiet` and `rhbg`
    arguments passed to the kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s test it by rebooting the machine with the `systemctl reboot` command.
    This is an example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.1 – Verbose boot'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_15_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.1 – Verbose boot
  prefs: []
  type: TYPE_NORMAL
- en: 'In a normal boot, this may not be very useful as it goes too fast. However,
    if there are issues, it can help debug the situation from the console. To review
    these messages after booting, the `dmesg` command can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.2 – Output of the dmesg command'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_15_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.2 – Output of the dmesg command
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add an argument to the kernel by using the `--args` option. Let''s add
    the `quiet` option again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The `--info` and `--update-kernel` options accept the `ALL` option to review
    or do actions to all the configured kernels.
  prefs: []
  type: TYPE_NORMAL
- en: If any administration task requires us to change kernel parameters, now we know
    how to do it. Let's move to the next section of the boot process, `initrd`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `/boot/initramfs-4.18.0-240.15.1.el8_3.x86_64.img`. It can be regenerated
    by using the `dracut` command. Let''s see an example of how to rebuild the current
    `initrd` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We can see in the previous output what kernel modules and files, required for
    early access, are included in the `initrd` file. This step is useful when our
    `initrd` file is corrupted and also when restoring a system from a backup, if
    done in different hardware, to include the proper storage drivers.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the manual page of `dracut` to learn more on options to create `initrd`
    files. There''s a Red Hat knowledge base article to unpack `initrd`, an interesting
    exercise to learn more: [https://access.redhat.com/solutions/24029.](https://access.redhat.com/solutions/24029'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: We have learned the very basics of the early stages of the boot process in order
    to be able to start troubleshooting boot issues, as required to become an RHCSA.
    This advanced topic could be covered in an entire book, but very little of it
    will be used in your daily tasks as a system administrator. That's why we only
    included the required aspects of it. We will include a specific use case in the
    last section of this chapter called *Intervening in the boot process to gain access
    to a system* and fix disk issues. Let's move on to the next topic on how services
    are managed in RHEL with **systemd**.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the boot sequence with systemd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already learned how the firmware of the system will take care of pointing
    at a disk to run the operating system loader, which in RHEL is GRUB.
  prefs: []
  type: TYPE_NORMAL
- en: GRUB will load the kernel and initrd to prepare the system to start. Then it's
    time to start the first process of the system, also referred to as process 1 or
    PID 1 (**PID** stands for **process identifier**). This process has to take care
    of loading all the required services in the system efficiently. In RHEL8, the
    PID 1 is run by **systemd**.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B16799_04_Final_Sk_ePub.xhtml#_idTextAnchor059), *Tools for
    Regular Operations*, we described services and targets management with systemd.
    Let's review in this chapter its interactions with the boot sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first two things related to the boot sequence that we can do with `systemctl`
    tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We will see that the system will reboot. We can check how long the system has
    been running with the `uptime` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s time to check `poweroff`. Before doing so, remember that after running
    this command you will need to have a way to power on the machine again. Once we
    are aware of the process we are going to follow, let''s run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now I shall power my machine on again.
  prefs: []
  type: TYPE_NORMAL
- en: There is a command that will stop the system but without sending the signal
    to power the machine off, which is `systemctl halt`. The cases where this can
    be used are rare; however, it's good to know that it exists and what it does.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The previously shown commands can be abbreviated to `reboot` and `poweroff`.
    If you check the file in `/usr/sbin/poweroff` you will see that it is a symbolic
    link pointing to `systemctl`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 4*](B16799_04_Final_Sk_ePub.xhtml#_idTextAnchor059), *Tools for
    Regular Operations*, we also reviewed how to set a default `systemctl`. However,
    we can override the default configuration during boot time by passing the `systemd.unit`
    parameter to the kernel. We can do that using `grubby`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now the system is rebooting. The `systemd.unit=emergency.target` parameter has
    been passed by **GRUB** to the **kernel**, and from the **kernel** to **systemd**,
    which, in turn, will ignore the default configuration and load the services required
    for the **emergency target**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the system is started in emergency mode and is waiting for the root password
    to give you control:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.3 – RHEL system booted in emergency mode'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_15_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.3 – RHEL system booted in emergency mode
  prefs: []
  type: TYPE_NORMAL
- en: In emergency mode, there is no network configured and no other process running.
    You can make changes to the system knowing that no other user is accessing it.
    Also, only the `/` filesystem is mounted in read-only mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a filesystem in the system is broken, this would be a good way to check
    it without any service accessing it. Let''s try it with the command for checking
    the filesystem, which is called `fsck`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The filesystem is OK. We could run `xfs_repair` on it, as it is an `xfs` filesystem
    (`fsck` detects the filesystem used) if it had issues that required a fix.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point we may be thinking, how can we make changes to the root filesystem
    if it''s already mounted as read-only at `/`? The process starts by remounting
    the `/` filesystem as read-write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember, you can access the manual pages for the command by running `man mount`.
    Now our root filesystem is mounted in `/` as read-write. We also need to mount
    `/boot`, so let''s do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `/boot` mounted, let''s do some admin tasks, such as removing the
    arguments we have used in GRUB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: And we are back to a regular boot in the system. This may not be a practical
    way to go to emergency mode in Linux, but it shows how to pass parameters to systemd
    at boot.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: There is `rescue.target` that loads more services and makes the process somewhat
    easier. It does so by waiting for `sysinit.target` to complete, something that
    the emergency target does not do. A good exercise would be to repeat the previous
    sequence with `rescue.target`.
  prefs: []
  type: TYPE_NORMAL
- en: We will see in the coming section how to make this change, and similar ones,
    for a one-time boot only and more easily during the GRUB boot sequence, and in
    a way in which no password is required.
  prefs: []
  type: TYPE_NORMAL
- en: Intervening in the boot process to gain access to a system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes you need to intervene in a system that was handed over in which you
    do not have the password for the `root` user. This is an exercise that, though
    it sounds like an emergency situation, is more frequent than you would expect.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The boot sequence must not have any disk encrypted for it to work or you will
    need the password for the encrypted volumes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way to perform this procedure starts by stopping the boot process during
    the GRUB menu. This means we need to restart the system. Once the BIOS/UEFI checks
    have finished, the system will load GRUB. There we can stop the count by pressing
    the down or up arrow key while it''s waiting for the selection of the kernel,
    as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.4 – GRUB menu to select the kernel'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_15_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.4 – GRUB menu to select the kernel
  prefs: []
  type: TYPE_NORMAL
- en: 'We move back to the first entry. Then we read the bottom of the screen where
    we find the instructions to edit the boot line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.5 – GRUB menu to select the kernel'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_15_005.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.5 – GRUB menu to select the kernel
  prefs: []
  type: TYPE_NORMAL
- en: 'If we press the *E* key, we will be able to edit the boot line selected in
    the menu. We will see the following five lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.6 – GRUB menu to select the kernel'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_15_006.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.6 – GRUB menu to select the kernel
  prefs: []
  type: TYPE_NORMAL
- en: 'The first three lines with `load_video`, `set` `gfx_payload=keep`, and `insmod
    gzio` are setting options for GRUB. The next two options are the ones that are
    important. Let''s review them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`linux`: Defines the kernel to be loaded and passes parameters to it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initrd`: Defines where to load the initrd and if there are any options for
    it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the `linux` line is so long that it is wrapped, as we can see
    by the `\` symbols, which mean that the line continues below.
  prefs: []
  type: TYPE_NORMAL
- en: 'We shall now go to the end of the `linux` line and add the `rd.break` option,
    as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.7 – linux kernel line edited with the rd.break option'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_15_007.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.7 – linux kernel line edited with the rd.break option
  prefs: []
  type: TYPE_NORMAL
- en: 'To boot the edited line, we only need to press *Ctrl* + *X*. The `rd.break`
    option stops the boot process before the initrd is loaded. The situation now is
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A single shell is loaded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current root filesystem mounted on `/` is a minimal one with basic administration
    commands.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The target root filesystem is mounted in `/sysroot` as read-only (instead of
    on `/`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No other filesystems are mounted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SELinux is not loaded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first thing we can do now is switch to the real, on-disk root filesystem
    with `chroot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now our root filesystem is properly mounted, but read-only. Let''s change that
    in the same way as we did in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to change the root user password with the `passwd` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The password for the root user is now changed and the `/etc/shadow` file has
    been updated. However, it was modified without SELinux enabled, and therefore
    it could cause an issue in the next boot. To avoid that, there is a mechanism
    to fix the SELinux labels during the next boot. This mechanism consists of creating
    the `/.autorelabel` hidden empty file and then rebooting the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the file is created, it''s time to reboot it to apply the SELinux changes.
    In this status, the machine may require forcing the power off and then powering
    on. During the next boot, we will see the SELinux autorelabel happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.8 – SELinux autorelabel during boot'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_15_008.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.8 – SELinux autorelabel during boot
  prefs: []
  type: TYPE_NORMAL
- en: Now we can log in with the root user and its new password.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have reviewed the boot sequence in this chapter. As you have seen, it is
    not long, but it is complex and it is also very important as no system can run
    if it cannot boot. We have learned the main differences between a BIOS-enabled
    system and a UEFI one, which enables some capabilities but also has its own requirements.
    We have also learned about GRUB and its important role in the boot sequence, how
    to modify entries permanently with `grubby`, and how to make a one-time modification.
    We now know the main files to boot, such as the kernel, `vmlinuz`, and the initial
    RAM disk, `initrd`.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also showed us how to start in emergency and rescue modes, as well
    as how to intervene in a system to reset the root password.
  prefs: []
  type: TYPE_NORMAL
- en: We are now more prepared to handle any difficult situation in our systems with
    these tools and procedures. It's time to dive deeper and learn about kernel tuning
    and performance profiles in the next chapter.
  prefs: []
  type: TYPE_NORMAL
