- en: Isomorphic Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we provided an introduction to GopherJS, and we covered
    code examples to perform various front-end operations. One of the interesting
    tasks that we performed on the client side, was template rendering, using an inline
    Go template. However, rendering inline Go templates in the web browser is not
    a maintainable solution. For one thing, mixing HTML code from an inline Go template,
    along with Go source code, can become an unmaintainable arrangement as the project
    codebase grows. In addition to this, real-world web applications often require
    having multiple template files that are often nested together with a layout hierarchy
    in mind. In addition to that, the template package from Go's standard library
    was designed particularly for templates rendered on the server side since it depends
    on accessing template files from the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: To fully unleash the power of templates across environments, we need a solution
    that provides more flexibility to render any template within a set of templates
    for a given project. This flexibility can be found by implementing isomorphic
    template rendering using the `isokit` package from the Isomorphic Go toolkit.
    Using the functionality from the `isokit` package, we can render a template belonging
    to a template set, either on the server side or on the client side, and we'll
    show you exactly how that's done in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The web template system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IGWEB page structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template categories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom template functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feeding data to the content template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Isomorphic template rendering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The web template system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In web programming, a **web template** is a text document that describes the
    format in which a web page should appear to the user. In this book, we will focus
    on web templates from Go's `html/template` package—the package that implements
    data-driven templates suitable for use in web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Web templates (we'll refer to them simply as *templates* moving forward) are
    text documents, that are typically implemented in HTML, and may contain special
    commands that are embedded inside of them. In Go, we refer to these commands as
    *actions.* We denote actions in templates by placing them inside a pair of opening
    and closing double curly braces—`{{` and `}}`.
  prefs: []
  type: TYPE_NORMAL
- en: Templates form the means to present data to the user in a manner that is intuitive
    and acceptable. In fact, you can think of a template as the means by which we
    dress up data.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will use the file extension of `.tmpl` to designate Go template
    source files. You may notice that some other Go projects use the file extension
    of `.html` instead. There is no hard set rule to prefer one extension over the
    other, just remember that once you choose which file extension to use, it's best
    to stick with it to promote uniformity in the project codebase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Templates are used in conjunction with a **web template system**. In Go, we
    have the robust `html/template` package from the standard library to render templates. When
    we use the term *render template*, we refer to the process by which one or more
    templates, along with a **data object**, is processed through a **template engine**
    that generates HTML web page output, as depicted in *Figure 4.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3e99fcd-9757-43c8-a6ef-4409d6d14330.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: How a web page is rendered by a web template system'
  prefs: []
  type: TYPE_NORMAL
- en: The key components in *Figure 4.1*, the **template engine**, the **template
    data object**, and the **templates**, can be classified as comprising a **web
    template system**. Each component plays an important role toward rendering the
    web page output, and in the following sections, we'll consider the role that each
    component plays in this process of producing the HTML output to display in the
    web browser. In this chapter, we will build IGWEB's About page.
  prefs: []
  type: TYPE_NORMAL
- en: The template engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The major responsibility of a template engine is to take one or more template
    files, along with a data object, and generate text output. In our specific field
    of study, isomorphic web development, this text output is in the HTML format and
    can be consumed by web clients. In Go, the `html/template` package can be considered
    as our template engine.
  prefs: []
  type: TYPE_NORMAL
- en: The template engine is activated by the route handler, when it's time to serve
    the HTML output. From the perspective of an isomorphic web application, the template
    engine can be activated by both the server-side route handler and the client-side
    route handler.
  prefs: []
  type: TYPE_NORMAL
- en: When the template engine is activated from the server-side route handler, the
    produced HTML web page output is written out to the web client in the server response,
    by the web server instance, using `http.ResponseWriter`. This activity typically
    occurs when a page on the website is accessed for the first time, and the initial
    page request is serviced on the server side. In this scenario, the HTML that is
    returned from the template engine describes a full HTML web page document and
    includes the opening and closing `<html>` and `<body>` tags.
  prefs: []
  type: TYPE_NORMAL
- en: When the template engine is activated from the client-side route handler, the
    produced HTML content is rendered in a designated area of a fully rendered web
    page. We will be rendering HTML content on the client side for a given web page
    on IGWEB in a designated area, known as the *primary content area.* We will cover
    the primary content area, a `<div>` container, later in this chapter. Client-side
    template rendering typically occurs on a subsequent user interaction with the
    website, such as when the user clicks on a link in the navigation bar to access
    a particular page on the website. In this scenario, the HTML that is returned
    from the template engine represents only a portion of a HTML web page.
  prefs: []
  type: TYPE_NORMAL
- en: Worth nothing is that Go comes with two template packages. The `text/template`
    package is used to generate text, and the `html/template` package is meant to
    be used to generate HTML output. The `html/template` package provides the same
    interface as the `text/template` package. In this book, we are specifically interested
    in generating the HTML web page output, and this is why we will be focusing on
    the `html/template` package. The `html/template` package provides us with extra
    security by generating the HTML output that is safe against code injection, which
    the regular `text/template` package doesn't do. This is why it's best to use the
    `html/template` package for the purpose of web development.
  prefs: []
  type: TYPE_NORMAL
- en: The template data object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The major responsibility of the template data object (or simply the *data object*)
    is to supply a given template with data that is to be presented to the user. In
    the About page that we will be constructing, there are two pieces of data that
    need to be presented. The first need is subtle, it's the title of the web page
    that will be displayed in the web browser's title bar window, or as the title
    of the web browser tab containing the web page. The second data need is more profound,
    it is the data object, the list of gophers that should be displayed on the About
    page.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the following `About` struct from the `templatedata` package, defined
    in the `shared/templatedata/about.go` source file, to fulfill the data needs of
    the About page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `PageTitle` field represents the web page title that should be displayed
    in the web browser's title bar (or as the title of the web browser tab). The `Gophers`
    field is a slice of pointers to a `Gopher` struct. The `Gopher` struct represents
    a gopher, a member of the IGWEB team, that should be displayed on the About page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The definition for the `Gopher` struct can be found in the `gopher.go` source
    file found in the `shared/models` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `Name` field represents the name of the Gopher. The `Title` field represents
    the title that the IGWEB organization has bestowed to a particular gopher. The
    `Biodata` field represents a brief bio about a particular gopher. We used a loren
    ipsum generator, to generate some random gibberish in Latin, to populate this
    field. The `ImageURI` field is the path to the image of the gopher that should
    be displayed, relative to the server root. The gopher's image will be displayed
    on the left-hand side of the page, and the the gopher's profile information will
    be displayed on the right-hand side of the page.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `StartTime` field represents the date and time that the gopher
    joined the IGWEB organization. We will be displaying the gopher's start time in
    the standard time format, and later in this chapter we will learn how to display
    the start time using Ruby-style formatting by implementing a custom template function.
    In [Chapter 9](cbb6c046-c40f-4681-a25d-9b979614b2cf.xhtml), *Cogs – Reusable Components*,
    we will learn how to display the start time in the human readable time format.
  prefs: []
  type: TYPE_NORMAL
- en: The templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Templates are responsible for presenting information to the user in an intuitive
    and understandable manner. Templates form the view layer of the isomorphic web
    application. Go templates are a combination of standard HTML markup mixed with
    a lightweight template language that provides us with the means to perform token
    substitution, looping, conditional flow of control, template nesting, and the
    ability to call custom template functions within the template using pipelining
    constructs. All of the aforementioned activities can be performed using template
    actions, and we will be using them throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: The templates for the IGWEB project can be found in the `shared/templates` folder.
    They are considered as isomorphic templates, since they can be utilized on the
    server side and on the client side. We will now explore the web page layout organization
    of IGWEB, and directly after that, we will examine the templates needed to implement
    the structure of a web page on IGWEB.
  prefs: []
  type: TYPE_NORMAL
- en: IGWEB page structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Figure 4.2* depicts a wireframe design illustrating the structure of a web
    page on IGWEB. The figure provides us with a good idea of the fundamental layout
    and navigational needs of the website:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c6bfd34-adfd-4181-ae26-8bdcdae0d8ea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: IGWEB wireframe design'
  prefs: []
  type: TYPE_NORMAL
- en: 'By organizing the web page structure into these individual areas, we can demarcate
    the unique function(s) that each area plays in the web page structure as a whole.
    Let''s go ahead and examine each individual area that comprises the page structure:'
  prefs: []
  type: TYPE_NORMAL
- en: The header
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The primary content area
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The footer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The header
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The header area, as depicted in *Figure 4.2*, appears at the top of the web
    page. It marks the beginning of the web page, and it is useful for the purposes
    of branding, navigation, and user interactivity. It is comprised of the top bar
    and the navigation bar.
  prefs: []
  type: TYPE_NORMAL
- en: The top bar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As depicted in *Figure 4.2*, the top bar is a subarea that exists within the
    header. At the left-most side of the top bar is the logo for IGWEB. Besides having
    an obvious function for branding purposes, the logo also serves as a navigational
    component, since when the user clicks on it, they will be returned to the home
    page. At the right-most side of the top bar are ancillary user controls to activate
    specific functionality—the shopping cart and the live chat feature.
  prefs: []
  type: TYPE_NORMAL
- en: The navigation bar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The navigation bar, as depicted in *Figure 4.2*, is a subarea that exists within
    the header. The navigation area consists of links to various pages on the website.
  prefs: []
  type: TYPE_NORMAL
- en: The primary content area
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary content area, as depicted in *Figure 4.2*, is sandwiched between
    the header area and the footer area. The contents of an individual web page will
    be displayed here. For example, the About page will display the pictures and profile
    information for the IGWEB team gophers in the primary content area.
  prefs: []
  type: TYPE_NORMAL
- en: The footer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The footer area, as depicted in *Figure 4.2*, appears at the bottom of the web
    page. It contains the copyright notice of the website. The footer marks the end
    of the web page.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have established the web page structure for IGWEB, we will learn
    how we can implement the structure using a preplanned hierarchy of Go templates.
    To improve our understanding, we will organize templates into categories based
    on their functional purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Template categories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Organizing templates into categories based on their functional purpose allows
    us to be productive when implementing the structure of a web page. Templates can
    be organized into the following three categories, based on the role they serve
    in implementing the web page structure:'
  prefs: []
  type: TYPE_NORMAL
- en: Layout templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partial templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layout templates** describe the general layout of the entire web page. They
    provide us with a bird''s-eye view of the page structure and give us a sense of
    how all the other templates fit in.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Partial templates** contain only a part of the web page, and hence they are
    named **partials**. They are partial in nature, since they are meant to fulfill
    a particular need within a region of the web page, such as displaying the footer
    of the web page.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Regular templates** contain content that is meant for a specific section
    of the website, and this content is meant to be displayed in the primary content
    area. In the following sections, we will examine each template category, and consider
    the respective template implementation performed for each category.'
  prefs: []
  type: TYPE_NORMAL
- en: Layout templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A page layout template, also known as a **layout template**, holds the structure
    of the entire web page. Since they define the overall structure for the web page,
    they require other templates (partial and regular) to complete them. For isomorphic
    web applications, these types of templates are used to render the web page on
    the server side for the initial web page response, that is sent to the client. In
    the IGWEB project, we place layout templates in the `shared/templates/layouts` folder.
  prefs: []
  type: TYPE_NORMAL
- en: The web page layout template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s the web page layout template found in the `webpage_layout.tmpl` source
    file in the `shared/templates/layouts` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the layout template covers the entire web page, from the opening
    `<html>` tag to the closing `</html>` tag. The layout template issues the `template`
    actions (shown in bold) to render the `header` partial template, the `pagecontent`
    regular template, and the `footer` partial template.
  prefs: []
  type: TYPE_NORMAL
- en: The dot `.` between the `partials/header_partial` template name and the closing
    pair of curly braces, `}}`, is known as an action. The template engine considers
    this to be a command that is to be replaced with the value of the data object
    that is fed into the template upon the execution of the template. By placing the
    dot here, we ensure that the header partial template, which is responsible for
    displaying the content in the header area of the website, has access to the data
    object that was fed into the template. Notice that we have done the same thing,
    for the `pagecontent` template, and the `partials/footer_partial` template.
  prefs: []
  type: TYPE_NORMAL
- en: Partial templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Partial templates, also known as **partials**, typically hold portions of content
    for a specific area of the web page. Examples of a partial template include the
    header and footer of the web page. Partial templates for the header and footer
    come in very handy when including them in the page layout template, since the
    header and footer will be preset on all web pages in the website. Let's examine
    how the header and footer partial templates are implemented. In the IGWEB project,
    we place partial templates in the `shared/templates/partials` folder.
  prefs: []
  type: TYPE_NORMAL
- en: The header partial template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s an example of the header partial found in the `header_partial.tmpl`
    source file in the `shared/templates/partials` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Between the opening `<head>` and closing `</head>` tags, we include the icon
    for the website along with external CSS style sheets and external JavaScript source
    files. The `igweb.css` stylesheet defines the styles for the IGWEB website (shown
    in bold). The `client.js` JavaScript source file, is the JavaScript source file
    for the client-side web application, which is transpiled into JavaScript by GopherJS
    (shown in bold).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we render the top bar, and the navigation partial templates, inside
    the header partial template using the `template` actions (shown in bold). We don't
    include the dot `.` here, since these partials don't need access to the data object.
    Both the content for the top bar and the navigation bar are within their own respective
    `<div>` containers.
  prefs: []
  type: TYPE_NORMAL
- en: The top bar partial template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s the top bar partial template found in the `topbar_partial.tmpl` source
    file in the `shared/templates/partials` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The top bar partial template is a good example of a static template where there's
    no dynamic action going on. There are no `template` actions defined within it,
    and it's main purpose is to include the HTML markup to render the website logo,
    the shopping cart icon, and the live chat icon.
  prefs: []
  type: TYPE_NORMAL
- en: The navigation bar partial template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s an example of the navigation bar partial template found in the `navbar_partial.tmpl`
    source file in the `shared/templates/partials` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The navigation bar partial template is also a static template. It contains the
    `div` container that contains the list of navigation links that make up IGWEB's
    navigation bar. These links allow users to access the Home, Products, About, and
    Contact pages.
  prefs: []
  type: TYPE_NORMAL
- en: The footer partial template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s an example of the footer partial template found in the `footer_partial.tmpl`
    source file in the `shared/templates/partials` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The footer partial template is also a static template, whose current, sole purpose
    is to have the HTML markup that contains the copyright notice for the IGWEB website.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've covered all the partial templates that comprise the web page
    structure, it's time to examine what a regular template looks like, both from
    the perspective of the server side and that of the client side.
  prefs: []
  type: TYPE_NORMAL
- en: Regular templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **regular template** is used to hold the primary content that is to be displayed
    on the web page. For example, in the About page, the primary content would be
    the information about the gophers on the IGWEB team along with their individual
    pictures.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will build the About page. We can see exactly what will
    go into the primary content area in the About page, by examining its wireframe
    design depicted in *Figure 4.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/827e74b7-b222-454c-a3a3-ebee1049e08a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: Wireframe design for the about page'
  prefs: []
  type: TYPE_NORMAL
- en: For each gopher on the IGWEB team, we will display the gopher's picture, its
    name, its title, and a brief description about its role (randomly generated Latin
    gibberish). We will also display the date/time that the gopher joined the IGWEB
    team in several different time formats.
  prefs: []
  type: TYPE_NORMAL
- en: We will render the About page in two markedly different ways, depending on whether
    the rendering takes place on the server side or the client side. On the server
    side, when we render the About page, we are in need of a page template, that is
    a regular template, that contains the layout for the whole web page, in addition
    to containing the content of the About page. On the client side, we only need
    to render the content contained in the About page to populate the primary content
    area, since the web page has already been rendered for us from the initial page
    load.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we can define two subcategories of regular templates: a *page
    template* that will serve our server-side rendering needs, and a *content template* that
    will serve our client-side rendering needs. In the IGWEB project, we will place
    regular templates in the `shared/templates` folder.'
  prefs: []
  type: TYPE_NORMAL
- en: The page template for the about page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s an example of the page template for the About page, from the `about_page.tmpl`
    source file in the `shared/templates` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We use the `define` action in the page template, to define the region of the
    template that contains the template section that we have declared as the `pagecontent`
    section. We have a corresponding `end` action to mark the end of the `pagecontent`
    section. Notice that we have a template action in between the define and end actions
    to include the template named `about_content`. Also note that we provide the dot
    (`.`) action to pass the data object to the `about_content` template.
  prefs: []
  type: TYPE_NORMAL
- en: This page template is a good example that shows how we can render layout templates
    inside of a regular template. In the last line of the template, we declare a `template`
    action to load the layout template for the web page that is named `layouts/webpage_layout`.
    Again, notice that we provide the dot (`.`) action to pass the data object to
    the web page layout template.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've examined the `about_page` template, it's time to examine the
    `about_content` template.
  prefs: []
  type: TYPE_NORMAL
- en: The content template for the about page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s an example of the content template, which is rendered into the primary
    content area found in the About page, from the `about_content.tmpl` source file
    in the `shared/templates` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We use the `range` action to iterate through the Gophers property of the data
    object supplied to the template (shown in bold). Notice that we use the dot (`.`)
    action to access the `Gophers` property of the data object. Remember, the Gophers
    property is a slice of pointers to a `Gopher` struct. We print out the fields
    of each `Gopher` struct, in their designated area in the template, using the dot
    (`.`) action (shown in bold). We use the `end` action to denote the end of the
    `range` looping action (shown in bold).
  prefs: []
  type: TYPE_NORMAL
- en: Important to note is that the content template is required on both the server
    side and the client side. Remember, that on the server side, the full web page
    layout needs to be rendered, in addition to the content template. On the client
    side, we only need to render the content template.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that in the last two places where we print the `StartTime` field using
    the dot (`.`) action, we make use of the pipe (`|`) operator to format the `StartTime`
    field using a custom function. First, we use the `rubyformat` function to show
    the `StartTime` value in Ruby date/time format, and then we use the `unixformat`
    function to populate the `"data-starttimeunix"` attribute with the Unix time representation
    of the `StartTime` value. Let's take a look at where these custom functions are
    defined in the IGWEB project codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Custom template functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We defined our custom template functions in the `funcs.go` source file found
    in the `shared/templatefuncs` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `RubyDate` function displays a given time using the time layout specified
    by the `time.RubyDate` constant. We call the function in a template using the
    `rubyformat` function name.
  prefs: []
  type: TYPE_NORMAL
- en: 'As noted before, inside the about content template (`shared/templates/about_content.tmpl)`,
    we use the pipe (`|`) operator to apply the `rubyformat` function to the `StartTime`
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this way, custom template functions provide us with the flexibility to format
    values in our templates to meet the unique needs that our project may require.
    You might be wondering, how we map the `rubyformat` name to the `RubyDate` function.
    We create a template function map that contains this mapping; we will cover how
    we can use the template function map across environments, later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that the three subfolders, `templates`, `templatedata`, and `templatefuncs`,
    reside in the `shared` folder imply that the code found within these folders can
    be used across environments. In fact, any code contained within the `shared` folder
    and its subfolders, is code that's meant for sharing across environments.
  prefs: []
  type: TYPE_NORMAL
- en: We will be covering the `UnixTime` function, referred to as the `unixformat`
    function in the template, in [Chapter 9](cbb6c046-c40f-4681-a25d-9b979614b2cf.xhtml),
    *Cogs – Reusable Components*.
  prefs: []
  type: TYPE_NORMAL
- en: Feeding data to the content template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The data object that we will feed to the about content template is a slice of
    pointers to `Gopher` structs that represent each gopher on the IGWEB team. The
    plan for feeding data to our template is to obtain a slice of gophers from the
    Redis datastore and populate the `Gophers` property of the template data object
    for the About page along with the data object's `PageTitle` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'We call the `GetGopherTeam` method on our datastore object to obtain a slice
    of gophers that belongs to the IGWEB team. Here''s the declaration of the `GetGopherTeam`
    function from the `redis.go` source file found in the `common/datastore` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `GetGopherTeam` function checks if the `gopher-team` key exists in the `Redis`
    database. The slice of gophers are stored as JSON-encoded data within the `Redis`
    database. If the `gopher-team` key exists, we attempt to `unmarshal` the JSON-encoded
    data into the `t` variable, which is a slice of pointers to the `Gopher` structs.
    If we were able to successfully `unmarshal` the JSON data we will return the `t` variable.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we've created the means to fetch the data for our team of gophers
    that will be displayed on the About page. You might be wondering, why can't we
    just feed the about content template with the slice of gophers, as the data object,
    and call it a day? Why do we need to pass a data object with a type of `templatedata.About` to
    the about content template?
  prefs: []
  type: TYPE_NORMAL
- en: The one-word answer to both of these questions is *extensibility*. Currently,
    the `About` section doesn't just need the slice of Gophers—it also needs a page
    title that will be displayed in the web browser's title window and/or in the web
    browser tab. So for all the sections of IGWEB, we have created accompanying structs
    to model the individual data needs for each page of the website in the `shared/templatedata`
    folder. Since the `templatedata` package is found in the `shared` folder, the
    `templatedata` package is isomorphic and can be accessed across environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'We defined the `About` struct in the `about.go` source file found in the `shared/templatedata`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `PageTitle` field of the `string` type is the title of the About page. The `Gophers` field
    is a slice of pointers pointing to the `Gopher` structs. This slice represents
    the gopher team that will be displayed on the about page. As we saw earlier in
    this chapter, we'll use the `range` action in the content template to iterate
    through the slice and display the profile information for each gopher.
  prefs: []
  type: TYPE_NORMAL
- en: Coming back to the topic of extensibility, the fields defined for the structs
    in the `templatedata` package are not meant to stay stationary and unchanging.
    They are meant to change over time to accommodate the future needs of the particular
    web page they are meant to serve.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if an IGWEB product manager decides that they should have pictures
    of the gopher team members working, studying, and playing in the office, for public
    relations purposes, they can easily accommodate the request by adding a new field
    to the `About` struct called `OfficeActivityImages`. This new field could be a
    slice of strings that denotes the server relative path to the images of gophers,
    engaging in the various activities, that should be displayed on the About page.
    We would then add a new section in our template, where we would `range` through
    the `OfficeActivityImages` slice, and display each image.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have the data needs for the About page satisfied, and we have all
    our templates lined up. It's now time to focus on how to perform the rendering
    of the templates, on both the server side and the client side. This is where isomorphic
    template rendering comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: Isomorphic template rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Isomorphic template rendering allows us to render and reuse templates across
    environments. The traditional procedure to render templates in Go, which relies
    on accessing templates through the file system, comes with certain limitations
    that prevent us from rendering these same templates on the client side. It's important
    for us to acknowledge these limitations to fully appreciate the benefits that
    isomorphic template rendering presents for us.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of filesystem-based template rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to sharing template rendering responsibilities with the client,
    there are certain limitations in the template rendering workflow that we need
    to acknowledge. First, and foremost, template files are defined on the web server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider an example that follows the classic web application architecture
    to fully understand the limitations we face. Here''s an example of server-side
    template rendering using a template file, `edit.html`, taken from the *Writing
    Web Applications* article ([https://golang.org/doc/articles/wiki/](https://golang.org/doc/articles/wiki/))
    from the Go website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `editHandler` function is responsible for handling the `/edit` route. The
    last two lines (shown in bold) are of particular interest for our consideration.
    The `ParseFiles` function in the `html/template` package is called to parse the
    `edit.html` template file. After the template is parsed, the `Execute` function
    in the `html/template` package is called to execute the template along with the `p` data
    object, which is a `Page` struct. The produced web page output is then written
    out to the client as a web page response using `http.ResponseWriter`, `w`.
  prefs: []
  type: TYPE_NORMAL
- en: The *Writing Web Applications* article from the Go website is an excellent article
    to learn and understand classic, sever-side web application programming with Go.
    I highly recommend that you read this article: [https://golang.org/doc/articles/wiki/](https://golang.org/doc/articles/wiki/).
  prefs: []
  type: TYPE_NORMAL
- en: The drawback of rendering templates in this manner is that we are anchored to
    the server-side file system, where the `edit.html` template file resides. The
    dilemma we face is that the client needs access to the contents of template files
    in order to render a template on the client-side. It is not possible to make the
    `ParseFiles` function call on the client side, because we don't have access to
    any template file that can be read on the local file system.
  prefs: []
  type: TYPE_NORMAL
- en: The robust security sandbox implemented in modern web browsers, prevents clients
    from accessing template files from the local file system, as it rightly should.
    In contrast, calling the `ParseFiles` function makes sense, from the server side,
    since the server-side application can actually access the server-side filesystem,
    where the templates reside.
  prefs: []
  type: TYPE_NORMAL
- en: So how do we get past this roadblock? The `isokit` package comes to our rescue
    by providing us the capability to gather a group of templates from the server-side
    file system, and create an in-memory template collection, called a template set.
  prefs: []
  type: TYPE_NORMAL
- en: The in-memory template set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `isokit` package comes with the functionality to render templates in an
    isomorphic manner. In order to think isomorphically, when it comes to template
    rendering, we have to step away from the thought process of rendering a template
    from the file system, as we have been much accustomed to in the past. Instead,
    we have to think in terms of maintaining a set of templates in-memory, where we
    could access a particular template by the name that we have given to it.
  prefs: []
  type: TYPE_NORMAL
- en: When we use the term, in-memory, we are not referring to an in-memory database,
    but rather having the template set persisted in the running application itself,
    whether it's on the server side or the client side. The template set stays resident
    in memory for the application to utilize while it is running.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Template` type from the `isokit` package represents an isomorphic template,
    one that can be rendered either on the server side or the client side. In the
    type definition of `Template`, notice that the `*template.Template` type is embedded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Embedding the `*template.Template` type allows us to tap into all the functionality
    from the `Template` type defined in the `html/template` package. The `templateType` field
    indicates the type of template we are dealing with. Here''s the constant grouping
    declaration with all the possible values for this field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the constant grouping declaration has accounted for all the
    template categories that we will be dealing with: regular templates, partial templates,
    and layout templates.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at what the `TemplateSet` struct from the `isokit` package
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `members` field is `map` with a key of type `string` and a value that is
    a pointer to an `isokit.Template` struct. The `Funcs` field is an optional function
    map (`template.FuncMap`) that can be supplied to the template set, to call custom
    functions inside of a template. The `bundle` field is the template bundle. The
    `TemplateBundle` is a `map`, where the key represents the name of the template
    (a `string` type) and the value is the contents of the template file (also of
    the `string` type). The `TemplateFilesPath` field represents the path where all
    of the web application's isomorphic templates reside.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the `TemplateBundle struct` looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `items` field of the `TemplateBundle struct` is simply a `map` having a
    key of the `string` type and a value of the `string` type. The `items` map serves
    an important purpose, it is the data structure that will be `gob` encoded on the
    server side, and we''ll expose it to the client side using the `/template-bundle`
    server-side route, where it can be retrieved through an XHR call and decoded,
    as depicted in *Figure 4.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/866af4e4-0fb8-4963-a065-9106142a273c.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 How the items in a template bundle get transported to the client-side
  prefs: []
  type: TYPE_NORMAL
- en: The template bundle type plays a critical role since we use it as the basis
    to recreate the in-memory template set on the client-side. This allows us to provide
    the full set of templates for use on the client side. Now that we're armed with
    the knowledge that we can utilize the concept of a template set to isomorphically
    render templates, let's see how it's done in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the template set on the server side
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s examine the variable declarations at the beginning of the `igweb.go`
    source file found in the `igweb` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The variables declared here are critical for the proper operation of the web
    server instance. The `WebAppRoot` variable is responsible for specifying where
    the `igweb` project folder resides. The `WebServerPort` variable is responsible
    for specifying on what port the web server instance should run on. The `DBConnectionString`
    variable is used to specify the connection string to the database. The `StaticAssetsPath`
    variable is used to specify the directory that contains all of the static (nondynamic)
    assets for the project. These assets may consist of CSS style sheets, JavaScript
    source files, images, fonts, and anything else that isn't meant to be dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: 'We initialize the variables in the `init` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `WebAppRoot` and `WebServerPort` variables are obtained from the `IGWEB_APP_ROOT`
    and `$IGWEB_SERVER_PORT` environment variables, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: We will cover the `WebAppMode` variable and the `$IGWEB_MODE` environment variable
    in [Chapter 11](19922281-fd33-4fab-bac2-75066243176d.xhtml), *Deploying an Isomorphic
    Go Web Application*.
  prefs: []
  type: TYPE_NORMAL
- en: If the `$IGWEB_SERVER_PORT` environment variable has not been set, the default
    port is set to `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: The `DBConnectionString` variable is assigned the value of `"localhost:6379"`,
    which is the hostname and port on which the Redis database instance is running.
  prefs: []
  type: TYPE_NORMAL
- en: The `StaticAssetsPath` variable is assigned to the `static` folder, which resides
    inside the `WebAppRoot` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine the beginning of the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Right at the beginning of the `main` function, we check whether the `WebAppRoot`
    variable has been set, and if it hasn't been set, we exit from the application.
    One of the biggest advantages of setting the `$IGWEB_APP_ROOT` environment variable,
    which is used to populate the `WebAppRoot` variable, is that we can issue the
    `igweb` command from any folder on the system.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `main` function, we initialize the `env` object. Right after calling
    the `initializeDatastore` function to initialize the datastore, we make a call
    to the `initializeTemplateSet` function (shown in bold), passing a reference to
    the `env` object to the function. This function, as you may have guessed from
    its name, is responsible for initializing the template set. We will make use of
    the second argument, of the `bool` type, passed to the function in [Chapter 11](19922281-fd33-4fab-bac2-75066243176d.xhtml), *Deploying
    an Isomorphic Go Web Application*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine the `initializeTemplateSet` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We start by initializing the `isokit` package's exported variables for the `WebAppRoot`,
    `TemplateFilesPath`, and `StaticAssetsPath` variables. We create a new template
    set, `ts`, by calling the `NewTemplateSet` function found in the `isokit` package.
  prefs: []
  type: TYPE_NORMAL
- en: Right after we create our template set object, `ts`, we declare a function map,
    `funcMap`. We have populated our map with two custom functions that will be exposed
    to our templates. The key for the first function is `rubyformat`, and the value
    is the `RubyDate` function found in the `templatefuncs` package. This function
    will return the Ruby format for a given time value. The key for the second function
    is `unixformat`, and this function will return the Unix timestamp for a given
    time value. We populate the `Funcs` field of the template set object with the
    `funcMap` object that we just created. Now, all the templates in our template
    set have access to these two custom functions.
  prefs: []
  type: TYPE_NORMAL
- en: Up to this point, we've prepped the template set, but we haven't populated the
    template set's `bundle` field. In order to do this, we must call the `GatherTemplate`
    method of the `TemplateSet` object, which will gather all the templates found
    in the directory specified by `isokit.TemplateFilesPath` and all of its subdirectories.
    The names of the template filenames without the `.tmpl` file extension will be
    used as the key in the bundle map. The string contents of the template file will
    be used as the value in the bundle map. If the template is a layout or partial,
    their respective directory name will be included in the name to refer to them.
    For example, the `partials/footer.tmpl` template will have a name of `partials/footer`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our template set is fully prepped, we can populate the `TemplateSet`
    field of the `env` object, so that our server-side application has access to the
    template set. This comes in handy later on, since it allows us to access the template
    set from any request handler function defined in our server-side web application,
    providing us the capability to render any template that exists within the template
    set.
  prefs: []
  type: TYPE_NORMAL
- en: Registering the server-side handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After we have initialized the template set inside the `main` function of the
    `igweb.go` source file, we create a new Gorilla Mux router, and we call the `registerRoutes`
    function to register all the routes of the server-side web application. Let''s
    examine the lines of the `registerRoutes` function that are essential for the
    proper functioning of the client-side web application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We register a handler for the `/js/client.js` route and specify that it will
    be handled by the `GopherjsScriptHandler` function from the `isokit` package.
    This will associate the route to serving the `client.js` JavaScript source file that
    was built by running the `gopherjs build` command in the `client` directory.
  prefs: []
  type: TYPE_NORMAL
- en: We handle the `map` file of the `client.js.map` in a similar manner. We register
    a `/js/client.js.map` route and specify that it will be handled by the `GopherjsScriptMapHandler`
    function from the `isokit` package.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've registered the routes for the JavaScript source file and the
    JavaScript source `map` file that are critical for our client-side application
    to function, we need to register a route to access the template bundle. We will
    call the `Handle` method on the `r` router object and specify that the `/template-bundle`
    route will be handled by the `TemplateBundleHandler` function, found in the `handlers`
    package. This route will be retrieved by the client through an XHR call, and the
    server will send the template bundle as `gob` encoded data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The very last route that we register, which is of particular interest for us
    right now, is the `/about` route. Here''s the line of code where we register the
    `/about` route and associate it with the `AboutHandler` function found in the
    handlers package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've seen how to set up the template set in our server-side web application,
    and how we registered the routes that are of importance to us in this chapter,
    let's go ahead and take a look at the server-side handlers, starting with the
    `TemplateBundleHandler` function in the `handlers` package.
  prefs: []
  type: TYPE_NORMAL
- en: Serving the template bundle items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s the `TemplateBundleHandler` function found in the `templatebundle.go`
    source file in the `handlers` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The code to encode data to `gob` format should look familiar, it's just like
    how we encoded the cars slice to gob format in the *Transmitting gob encoded data
    section* from the [Chapter 3](0f18d7dd-b081-4090-8b9c-c7a392261b31.xhtml), *Go
    on the Front-End with GopherJS*. Inside the `TemplateBundleHandler` function,
    we first declare `templateContentItemsBuffer`, of the `bytes.Buffer` type, which
    will hold the `gob` encoded data. We then create a new `gob` encoder, `enc`. Right
    after this, we'll create an `m` variable and assign it the value of the template
    bundle map. We call the `Encode` method of the `enc` object, and pass in the reference
    to the `m` map. At this point, `templateContentItemsBuffer` should contain the
    `gob` encoded data that represents the `m` map. We will write out a content-type
    header to specify that the server will be sending out binary data (`application/octet-stream`).
    We will then write out the binary contents of `templateContentItemsBuffer` by
    calling its `Bytes` method. In the *Setting up the template set on the client
    side* section of this chapter, we'll see how the client-side web application picks
    up the template bundle items, and utilizes it to create a template set on the
    client side.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering the about page from the server side
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve seen how the server-side application transmits the template
    bundle to the client-side application, let''s take a look at the `AboutHandler`
    function found in the `about.go` source file in the `handlers` folder. This is
    the server-side handler function that is responsible for rendering the About page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AboutHandler` function has three responsibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Fetching the gophers from the datastore
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the template data object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering the About page template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first line of code, defined in the function, fetches the gopher objects
    from the datastore, where a gopher object represents an individual gopher team
    member. In our sample data set, there are three gophers: Molly, Case, and Wintermute.'
  prefs: []
  type: TYPE_NORMAL
- en: The second line of code is used to set up the template data object of the `templatedata.About` type.
    This is the data object that will be fed into the template. The `PageTitle` property
    of the data object is used to display the page title, and we will populate the
    `Gophers` property of the object with the slice of gopher objects that are retrieved
    from the datastore.
  prefs: []
  type: TYPE_NORMAL
- en: In the third, and final line of the handler function, we call the `Render` method
    of the template set to render the template. The first parameter passed to the
    method is the name of the template to be rendered. In this case, we have specified
    that we want to render the `about_page` template. Take note that this is a page
    template that will not only render the About page content but also the entire
    web page layout, which in addition to the primary content area section will also
    include the header, the top bar, the navigation bar, and the footer areas of the
    web page.
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter to the function is the template render parameters (`isokit.RenderParams`).
    We have populated the `Writer` field, with `http.ResponseWriter`, `w`. Also, we
    have populated the `Data` field, which represents the data object that should
    be supplied to the template with the `templateData` object that we had just created.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s all there is to it. Now we can render this template on the server side.
    We have now implemented the classic web application architecture flow where the
    entire web page is rendered from the server side. We can access the About page
    at `http://localhost:8080/about`. Here''s how the About page looks rendered from
    the server side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2c0612e-9e58-4e6c-a86d-014515d6a91b.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 The About page rendered from the server side
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the template set on the client side
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve seen how a web template gets rendered on the server side, it''s
    time to focus on how a web template gets rendered on the client side. The primary
    entry point of our client-side web application is the `main` function defined
    in the `client.go` source file in the `client` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: First, we assign the document object to the `D` variable, we're performing the
    usual aliasing operation here to save us some typing. We then declare a `switch`
    block on the document object's `readyState` property. We obtain the document object's
    `readyState` by calling the `ReadyState` method on the `Document` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ready state property of a document describes the loading state of the document.
    You can read more about this property at the Mozilla Developer Network: [https://developer.mozilla.org/en-US/docs/Web/API/Document/readyState](https://developer.mozilla.org/en-US/docs/Web/API/Document/readyState).'
  prefs: []
  type: TYPE_NORMAL
- en: In the first `case` statement, we will check whether the `readyState` value
    is `"loading"`, and if it is, it indicates that the document is still loading.
    We set up an event listener to listen for the `DOMContentLoaded` event. The `DOMContentLoaded`
    event will be the cue that tells us that the web page has fully loaded, at which
    point, we can call the `run` function as a goroutine. We will call the `run` function
    as a goroutine since we don't want any operations inside the `run` function to
    block, because we are calling it from within the event handler function.
  prefs: []
  type: TYPE_NORMAL
- en: In the second `case` statement, we will check whether the `readyState` value
    is either `"interactive"` or `"complete"`. An `interactive` state indicates that
    the document has finished loading, but there may be some resources, such as images
    or style sheets, that haven't fully loaded. The `complete` state indicates that
    the document and all subresources have finished loading. If `readyState` is either
    interactive or complete, we will call the `run` function.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `default` statement handles unexpected behavior. Ideally, we should
    never reach the `default` scenario, and if we ever do, we will print a message
    in the web console indicating that we have encountered an unexpected document
    `readyState` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The functionality that we have created in our `main` function provides us with
    the valuable benefit of being able to import our GopherJS produced JavaScript
    source file, `client.js`, from the `<head>` section of our HTML document as an
    external JavaScript source file, as shown here (shown in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This means that we don't have to import the external JavaScript source file
    right before the closing `</body>` tag to ensure that the web page has fully loaded.
    The procedure to include the external JavaScript source file, in the head declaration
    itself, is more robust, since our code specifically accounts for `readyState`
    in a responsible manner. The other, more brittle approach, is apathetic to `readyState`,
    and is dependent on the location of the included `<script>` tag within the HTML
    document to function properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `run` function, we will first print a message in the web console,
    indicating that we have successfully entered the client-side application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We will then fetch the template set from the server-side `/template-bundle`
    route that we set up earlier in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We will create a channel called `templateSetChannel`, of the `*isokit.TemplateSet` type,
    in which we will receive the `TemplateSet` object. We will create a function map,
    containing the `rubyformat` and `unixformat` custom functions. We will then call
    the `FetchTemplateBundleWithSuppliedFunctionMap` function from the `isokit` package,
    supplying the `templateSetChannel` that we had just created, along with the `funcMap`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: The `FetchTemplateBundleWithSuppliedFunctionMap` function is responsible for
    fetching the template bundle items map from the server side, and assembling the
    template set using this map. In addition to that, the received `TemplateSet` object's
    `Funcs` property will be populated with the `funcMap` variable, ensuring that
    the custom functions will be accessible to all templates in our template set.
    Upon successfully calling this method, the template set will be sent over `templateSetChannel`.
    Finally, we will assign the `ts` variable with the `*isokit.TemplateSet` value
    that we receive from `templateSetChannel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a new instance of the `Env` object, which we will use throughout
    the client-side application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We will then populate the `TemplateSet` property with the `Env` instance that
    we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To save ourselves from having to type out `dom.GetWindow()` to access the `Window`
    object, and `dom.GetWindow().Document()` to access the `Document` object, we can
    populate the `Window` and `Document` properties of the `env` object with their
    respective values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be dynamically replacing the contents of the primary content `div` container
    as the user clicks on different sections of the website using the navigation bar.
    We will populate the `PrimaryContent` property of the `env` object to hold the
    primary content `div` container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This comes in handy, when we need to access this `div` container from within
    the route handler functions. It saves us from having to perform a DOM operation
    to retrieve this element each time we need it in the route handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will call the `registerRoutes` function and supply it with the reference
    to the `env` object as the sole input argument to the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This function is responsible for registering all the client-side routes and
    their associated handler functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will call the `initializePage` function and supply it with the reference
    to the `env` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This function is responsible for initializing interactive elements and components
    on the web page for a given client-side route.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two tasks that are of particular interest for us in the `registerRoutes`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the client-side router
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Registering the client-side route
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating the client-side router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we will create a new instance of the `isokit` router object and assign
    it to the `r` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Registering the client-side route
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second line of code, registers the client-side `/about` route, along with
    its associated client-side handler function, `AboutHandler`, from the `handlers`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We will be covering the rest of the `registerRoutes` function in more detail
    in [Chapter 5](8c1d6725-c841-42b2-904d-e34ba3764cc3.xhtml), *End-to-End Routing*.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing interactive elements on the web page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `initializePage` function will get called only once when the web page is
    first loaded. Its role is to initialize the functionality that enables user interactivity
    with the client-side web application. This would be the respective `initialize`
    function for a given web page, which would be responsible for initializing event
    handlers and reusable components (cogs).
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `initializePage` function, we will extract the `routeName` from
    the `PathName` property of the window''s location object; the route name for the
    `http://localhost:8080/about` URL will be `"about"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: If no `routeName` is available, we will assign the value of `"index"`, the route
    name for the home page, to `routeName`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will declare a `switch` block on `routeName`, and here''s the corresponding
    `case` statement that handles the scenario where `routeName` is equal to `"about"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The designated `initialize` function for the About page, is the `InitializeAboutPage`
    function, which is defined in the `handlers` package. This function is responsible
    for enabling user interactivity on the About page.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've set up the template set on the client-side, and registered the
    `/about` route, let's go ahead and take a look at the client-side About page handler
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering the about page from the client side
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s the definition of the client-side `AboutHandler` function in the `about.go`
    source file found in the `client/handlers` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We start out by creating a channel, `gopherTeamChannel`, which we will use to
    retrieve a slice of `Gopher` instances. We will call the `FetchGopherTeam` function
    as a goroutine, and supply it with `gopherTeamChannel` as the sole input argument
    to the function.
  prefs: []
  type: TYPE_NORMAL
- en: We will then receive the value returned from `gopherTeamChannel` and assign
    it to the `gophers` variable.
  prefs: []
  type: TYPE_NORMAL
- en: We will declare and initialize the `templateData` variable, the `about_content`
    template's data object, which has a type of `templatedata.About`. We will set
    the `PageTitle` property of the template data object and we populate the `Gophers`
    property with the `gophers` variable that we had just created.
  prefs: []
  type: TYPE_NORMAL
- en: We will call the `Render` method on the template set object to render the about
    template. The first argument we pass to the function is the name of the template,
    `about_content` that corresponds to the about content template. On the server
    side, we used the `about_page` template, since we also needed to generate the
    entire web page layout. Since we are operating from the client side, this is not
    necessary since we only need to populate the primary content area with the rendered
    content from the `about_content` template.
  prefs: []
  type: TYPE_NORMAL
- en: The second and final argument to the `Render` method is the render parameters
    of the `isokit.RenderParams` type. Let's examine each property that we set in
    the `RenderParams` object.
  prefs: []
  type: TYPE_NORMAL
- en: The `Data` property specifies the template data object that the template will
    be using.
  prefs: []
  type: TYPE_NORMAL
- en: The `Disposition` property specifies the disposition of the template content
    that will be rendered relative to an associated target element. The `isokit.PlacementReplaceInnerContents`
    disposition instructs the renderer to replace the inner contents of the associated
    target element.
  prefs: []
  type: TYPE_NORMAL
- en: The `Element` property specifies the associated target element that the renderer
    should take into consideration upon performing a template rendering. We will be
    placing the rendered content from the template in the primary content `div` container,
    and so we'll assign `env.PrimaryContent` to the `Element` property.
  prefs: []
  type: TYPE_NORMAL
- en: The `PageTitle` property specifies the web page title that should be used. The
    template data object's `PageTitle` property is equally important on the client
    side as it was on the server side, since the client-side renderer has the capability
    to change the web page's title.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we make a call to the `InitializeAboutPage` function to enable functionality
    that requires user interactivity. If the About page was the first page that was
    rendered on the website (from the server side), the `InitalizeAboutPage` function
    would be called from the `initializePage` function found in the `client.go` source
    file. If we landed on the About page subsequently, by clicking on the About link
    on the navigation bar, then the request is serviced by the client-side `AboutHandler`
    function and we enable the functionality that requires user interactivity by calling
    the `InitializeAboutPage` function.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to user interactivity on the About page, we only have one reusable
    component that displays the time in a human readable format. We don't set up any
    event handlers, since we don't have any buttons or user input fields on this particular
    page. This being the case, we will skip the `InitializeAboutPage` function for
    now, and return to it in [Chapter 9](cbb6c046-c40f-4681-a25d-9b979614b2cf.xhtml),
    *Cogs – Reusable Components*. We'll show you an example of setting up event handlers
    in the designated `initialize` function for a given web page, in [Chapter 5](8c1d6725-c841-42b2-904d-e34ba3764cc3.xhtml), *End-to-End
    Routing*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FetchGopherTeam` function is responsible for making an XHR call to the
    `/restapi/get-gopher-team` Rest API endpoint and retrieving the list of gophers
    that appear on the About page. Let''s examine the `FetchGopherTeam` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We make an XHR call by calling the `Send` function from the `xhr` package, and
    specifying that we will be using the `GET` HTTP method to make the call. We also
    specify that the call will be made to the `/restapi/get-gopher-team` endpoint.
    The last argument to the `Send` function is `nil`, since we will not be sending
    any data to the server from the client side.
  prefs: []
  type: TYPE_NORMAL
- en: If the XHR call is successfully made, the server will respond with JSON encoded
    data, representing a slice of gophers. We will create a new JSON decoder to decode
    the server's response into the `gophers` variable. Finally, we will send the `gophers`
    slice over `gopherTeamChannel`.
  prefs: []
  type: TYPE_NORMAL
- en: Now it's time to examine the Rest API endpoint that is responsible for servicing
    our XHR call to get the IGWEB team's gophers.
  prefs: []
  type: TYPE_NORMAL
- en: The gopher team Rest API endpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `/restapi/get-gopher-team` route is handled by the `GetGopherTeamEndpoint`
    function defined in the `gopherteam.go` source file found in the `endpoints` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We will declare and initialize the `gophers` variable to the value returned
    from calling the `GetGopherTeam` method of the Redis datastore object, `env.DB`.
    We will then set a header to indicate that the server will be sending a JSON response.
    Finally, we will use a JSON encoder to encode the slice of gophers as JSON data.
    The data is sent to the client using `http.ResponseWriter`, `w`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now set up everything we need to render the About page from the client
    side. We can view our client-side rendered About page by clicking on the About
    link on the navigation bar. Here''s what the About page looks like rendered from
    the client side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/30089b59-1891-4621-84ef-65e9290362dd.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 The About page rendered from the client-side
  prefs: []
  type: TYPE_NORMAL
- en: Can you make out any difference between the About page rendered on the server
    side and the one that was rendered on the client side? You shouldn't be able to
    see any differences since they are practically identical! We saved the user from
    having to witness a full page reload by simply rendering the About page content
    in the primary content area `div` container.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the start times that are displayed for each gopher. The first
    time presented here, follows Go's default time formatting. The second time is
    the time using the Ruby date format. Recall that we use a custom function to present
    the time in this format. The third start time is displayed in human readable format.
    It uses a reusable component to format the time, which we will cover in [Chapter
    9](cbb6c046-c40f-4681-a25d-9b979614b2cf.xhtml), *Cogs – Reusable Components*.
  prefs: []
  type: TYPE_NORMAL
- en: We now know how to render templates isomorphically, and we will be following
    this same procedure for the other pages on IGWEB.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we introduced you to the web template system and the individual
    components that comprise it—the template engine, the template data object, and
    the templates. We explored the purpose of each component of the web template system,
    and we designed the web page structure for IGWEB. We covered the three template
    categories: the layout template, the partial template, and the regular template.
    We then implemented each section of the IGWEB page structure as a template. We
    showed you how to define custom template functions that we could reuse across
    environments.'
  prefs: []
  type: TYPE_NORMAL
- en: We then introduced you to the concept of isomorphic template rendering. We identified
    the limitations of standard template rendering, based on loading the template
    file from the file system, and introduced the in-memory template set, provided
    by the `isokit` package to render templates isomorphically. We then demonstrated
    how to set up the template set and render the About page on both the server side
    and on the client side.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we briefly touched upon routing, only so much to understand
    how to register the `/about` route, with its associated handler function on both
    the server side and the client side. In [Chapter 5](8c1d6725-c841-42b2-904d-e34ba3764cc3.xhtml), *End-to-End
    Routing*, we will explore end-to-end application routing in further detail.
  prefs: []
  type: TYPE_NORMAL
