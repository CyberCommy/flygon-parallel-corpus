- en: RESTful Web Services Using Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple Spring Boot application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a RESTful web service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating multiple profiles for Spring Boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying RESTful web services to Heroku
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containerizing the RESTful web service using Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring the Spring Boot 2 application using Micrometer and Prometheus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In recent years, the drive for microservice-based architectures has gained wide
    adoption, thanks to the simplicity and ease of maintenance it provides when done
    the right way. A lot of companies, such as Netflix and Amazon, have moved from
    monolithic systems to more focused and lighter systems, all talking with each
    other via RESTful web services. The advent of RESTful web services and its straightforward
    approach to creating web services using the known HTTP protocol has made it easier
    for communication between applications than the older SOAP-based web services.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at the **Spring Boot** framework, which provides
    a convenient way to create production-ready microservices using Spring libraries.
    Using Spring Boot, we will develop a simple RESTful web service and deploy it
    to the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple Spring Boot application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Boot helps in creating production-ready, Spring-based applications easily.
    It provides support for working with almost all Spring libraries, without any
    need to configure them explicitly. There are auto-configuration classes provided
    for easy integration with most commonly-used libraries, databases, and message
    queues.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will look at creating a simple Spring Boot application with
    a controller that prints a message when opened in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Boot supports Maven and Gradle as its build tools, and we will be using
    Maven in our recipes. The following URL, [http://start.spring.io/](http://start.spring.io/),
    provides a convenient way to create an empty project with the required dependencies.
    We will use it to download an empty project. Follow these steps to create and
    download an empty Spring Boot-based project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to [http://start.spring.io/](http://start.spring.io/) to see something
    similar to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b5e3a855-cad8-4f41-9ebb-850abb91ce31.png)'
  prefs: []
  type: TYPE_IMG
- en: You can select the dependency-management and build tool, selecting the appropriate
    option in the dropdown after the **Generate a** text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Spring Boot supports Java, Kotlin, and Groovy. You can choose the language by
    changing the dropdown after the **with** text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Spring Boot version by choosing its value from the dropdown after
    the and Spring Boot text. For this recipe, we'll use the latest stable edition
    of Spring Boot 2, that is 2.0.4.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the left-hand side, under Project Metadata, we have to provide Maven-related
    information, that is, the group ID and artifact ID. We'll use Group as `com.packt`
    and Artifact as `boot_demo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the right-hand side, under Dependencies, you can search for the dependencies
    you want to add. For this recipe, we need web and Thymeleaf dependencies. This
    means that we want to create a web application that uses Thymeleaf UI templates
    and would want all the dependencies, such as Spring MVC and Embedded Tomcat, to
    be part of the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Generate Project button to download the empty project. You can
    load this empty project in any IDE of your choice, just like any other Maven project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, you will have your empty project loaded into an IDE of your choice
    and will be ready to explore further. In this recipe, we will make use of the
    Thymeleaf template engine to define our web pages and create a simple controller
    to render the web page.
  prefs: []
  type: TYPE_NORMAL
- en: The complete code for this recipe can be found at `Chapter09/1_boot_demo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have followed the group ID and artifact ID naming convention as mentioned
    in the *Getting ready* section, you will have a package structure, `com.packt.boot_demo`,
    and a `BootDemoApplication.java` main class already created for you. There will
    be an equivalent package structure and a `BootDemoApplicationTests.java` main
    class under the `tests` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new class, `SimpleViewController`, under the `com.packt.boot_demo`
    package, with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a web page, `message.html`, under `src/main/resources/templates`, with
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: From the command prompt, navigate to the project root folder and issue the `mvn
    spring-boot:run` command; you'll see the application being launched. Once it completes
    the initialization and starts, it will be running on the default port, `8080`.
    Navigate to `http://localhost:8080/message` to see the message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are using Spring Boot's Maven plugin, which provides us with convenient tools
    to launch the application during development. But for production, we will create
    a fat JAR, that is, a JAR comprising all the dependencies, and deploy it as a
    Linux or Windows service. We can even run the fat JAR using the `java -jar` command.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will not go into the working of Spring Boot or the other Spring libraries.
    Spring Boot creates an embedded Tomcat running on the default port, that is, `8080`.
    It then registers all the controllers, components, and services that are available
    in the packages and sub-packages of the class with the `@SpringBootApplication` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: In our recipe, the `BootDemoApplication` class in the `com.packt.boot_demo`
    package is annotated with `@SpringBootApplication`. So, all the classes that are
    annotated with `@Controller`, `@Service`, `@Configuration`, and `@Component` get
    registered with the Spring framework as beans and are managed by it. Now, these
    can be injected into the code by using the `@Autowired` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways we can create a web controller:'
  prefs: []
  type: TYPE_NORMAL
- en: Annotating with `@Controller`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Annotating with `@RestController`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the first approach, we create a controller that can serve both raw data
    and HTML data (generated by template engines such as Thymeleaf, Freemarker, and
    JSP). In the second approach, the controller supports endpoints that can only
    serve raw data in the form of JSON or XML. In our recipe, we used the former approach,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can annotate the class with `@RequestMapping` , say, `@RequestMapping("/api")`.
    In this case, any HTTP endpoints exposed in the controller are prepended by `/api`.
    There is a specialized annotation mapping for the HTTP `GET`, `POST`, `DELETE`,
    and `PUT` methods, which are `@GetMapping`, `@PostMapping`, `@DeleteMapping`,
    and `@PutMapping`, respectively. We can also rewrite our controller class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We can modify the port by providing `server.port = 9090` in the `application.properties`
    file. This file can be found in `src/main/resources/application.properties`. There
    is a whole set of properties ([http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html](http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html))
    that we can use to customize and connect with different components.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will look at how to integrate with a database to create,
    read, modify, and delete the data. For this, we will set up a MySQL database with
    the required table. Subsequently, we will update the data in a table from our
    Spring Boot application.
  prefs: []
  type: TYPE_NORMAL
- en: We will be using Windows as the development platform for this recipe. You can
    perform a similar action on Linux as well, but you would first have to set up
    your MySQL database.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start integrating our application with the database, we need to set
    up the database locally on our development machines. In the subsequent sections,
    we will download and install MySQL tools and then create a sample table with some
    data, which we will use with our application.
  prefs: []
  type: TYPE_NORMAL
- en: Installing MySQL tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, download the MySQL installer from [https://dev.mysql.com/downloads/windows/installer/5.7.html](https://dev.mysql.com/downloads/windows/installer/5.7.html).
    This MySQL bundle is for Windows only. Follow the onscreen instructions to successfully
    install MySQL along with other tools such as MySQL Workbench. To confirm that
    the MySQL daemon (`mysqld`) is running, open the task manager and you should be
    able to see a process similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d1a7d2a-8bae-412a-8268-7448d9872d33.png)'
  prefs: []
  type: TYPE_IMG
- en: You should remember the password you set for the root user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the MySQL workbench; on starting up, you should be able to see something
    similar to the following screenshot, among other things provided by the tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07d591cd-63f0-4f83-afff-9e73c07bf04e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you don''t find a connection like in the preceding image, you can add one
    using the (+) sign. When you click on (+), you will see the following dialog.
    Fill it in and click on Test Connection to get a success message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/558a654f-24cf-42bc-9e5c-063e240daea3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A successful Test Connection will result in the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/92db869d-b0c8-40a0-ad8d-a3b63206221c.png)'
  prefs: []
  type: TYPE_IMG
- en: Double-click on the connection to connect to the database, and you should see
    a list of DBs on the left-hand side, an empty area on the right-hand side, and
    a menu and toolbars on the top. From the File menu, click on New Query Tab, or
    press *Ctrl* + *T* to get a new query window. Here, we will write our queries
    to create a database and create a table within that database.
  prefs: []
  type: TYPE_NORMAL
- en: The bundled installer downloaded from [https://dev.mysql.com/downloads/windows/installer/5.7.html](https://dev.mysql.com/downloads/windows/installer/5.7.html)
    is for Windows only. Linux users have to download the MySQL Server and MySQL Workbench
    (GUI for interacting with DB) separately.
  prefs: []
  type: TYPE_NORMAL
- en: The MySQL server can be downloaded from [https://dev.mysql.com/downloads/mysql/](https://dev.mysql.com/downloads/mysql/).
  prefs: []
  type: TYPE_NORMAL
- en: The MySQL Workbench can be downloaded from [https://dev.mysql.com/downloads/workbench/](https://dev.mysql.com/downloads/workbench/).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a sample database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run the following SQL statement to create a database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Creating a person table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run the following SQL statements to use the newly created database and create
    a simple person table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Populating sample data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go ahead and insert some sample data in the table we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our database ready, we will go ahead and download the empty
    Spring Boot project from [http://start.spring.io/](http://start.spring.io/) with
    the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f336164-f3e0-4bb5-8fe4-439252c7baf0.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a model class, `com.packt.boot_db_demo.Person`, to represent a person.
    We will make use of Lombok annotations to generate the getters and setters for
    us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `com.packt.boot_db_demo.PersonMapper` to map the data from the database
    into our model class, `Person`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add a method to get all the rows from the table. Note that the next
    few methods will be written inside the `PersonMapper` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Another method to get the details of a single person identified by ID is as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The method to create a new row in the table is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The method to update an existing row in the table, identified by the ID, is
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The method to delete a row from the table, identified by the ID, is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a `com.packt.boot_db_demo.PersonController` class, which we will
    use to write our web endpoints:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create an endpoint to list all the entries in the `person` table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create an endpoint to add a new row in the `person` table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create an endpoint to add a new row or edit an existing row in the `person`
    table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create an endpoint to delete a row from the `person` table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `src/main/resources/application.properties` file to provide the
    configuration related to our data source, that is, our MySQL database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You can run the application from the command line using `mvn spring-boot:run`.
    This application starts up on the default port, that is, `8080`. Navigate to `http://localhost:8080/persons`
    in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: The complete code for this recipe can be found at `Chapter09/2_boot_db_demo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'On visiting `http://localhost:8080/persons`, this is what you will find:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/db4bfc97-92cf-41ab-80a7-00fd37217a9f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On clicking on **New Person**, you''ll get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f5cf0ca-3c12-435a-9fb2-64c2891729fd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On clicking on **Edit**, you''ll get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/afe20954-24b9-43f5-b76b-1f4b171e1666.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Firstly, `com.packt.boot_db_demo.PersonMapper` annotated with `org.apache.ibatis.annotations.Mapper`
    knows how to execute the query provided within the `@Select`, `@Update`, and `@Delete`
    annotations and to return relevant results. This is all managed by the MyBatis
    and Spring Data libraries.
  prefs: []
  type: TYPE_NORMAL
- en: You must be wondering how the connection to the database was achieved. One of
    the Spring Boot auto-configuration classes, `DataSourceAutoConfiguration`, does
    the work of setting up by making use of the `spring.datasource.*` properties defined
    in your `application.properties` file to give us an instance of `javax.sql.DataSource`.
    This `javax.sql.DataSource` object is then used by the MyBatis library to provide
    you with an instance of `SqlSessionTemplate`, which is what is used by our `PersonMapper`
    under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we make use of `com.packt.boot_db_demo.PersonMapper` by injecting it into
    the `com.packt.boot_db_demo.PersonController` class by using `@AutoWired`. The
    `@AutoWired` annotation looks for any Spring managed beans, which are either instances
    of the exact type or its implementation. Take a look at the *Creating a simple
    Spring Boot application* recipe in this chapter to understand the `@Controller`
    annotation.
  prefs: []
  type: TYPE_NORMAL
- en: With very little configuration, we have been able to quickly set up simple CRUD
    operations. This is the flexibility and agility that Spring Boot provides to developers!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a RESTful web service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our previous recipe, we interacted with data using web forms. In this recipe,
    we will see how to interact with data using RESTful web services. These web services
    are a means to interact with other applications using the known HTTP protocol
    and its methods, namely GET, POST, and PUT. The data can be exchanged in the form
    of XML, JSON, or even plain text. We will be using JSON in our recipe.
  prefs: []
  type: TYPE_NORMAL
- en: So, we will create RESTful APIs to support retrieving data, creating new data,
    editing data, and deleting data.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As usual, download the starter project from [http://start.spring.io/](http://start.spring.io/) by
    selecting the dependencies shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90cb2683-ac4e-49f1-bd9d-78582636818c.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Copy the `Person` class from the previous recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We will do the `PersonMapper` part in a different way. We will write all our
    SQL queries in a mapper XML file and then refer to them from the `PersonMapper`
    interface. We will place the mapper XML under the `src/main/resources/mappers`
    folder. We'll set the value of the `mybatis.mapper-locations` property to `classpath*:mappers/*.xml`.
    This way, the `PersonMapper` interface can discover the SQL queries corresponding
    to its methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `com.packt.boot_rest_demo.PersonMapper` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the SQL in `PersonMapper.xml`. Make sure that the `namespace` attribute
    of the `<mapper>` tag is the same as the fully qualified name of the `PersonMapper`
    mapper interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the application properties in the `src/main/resources/application.properties`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an empty controller for the REST APIs. This controller will be marked
    with the `@RestController` annotation because all the APIs in it are going to
    deal solely with data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an API to list all the rows in the `person` table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an API to get the details of a single person:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an API to add new data to the table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an API to edit the data in the table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an API to delete the data in the table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You can find the complete code at `Chapter09/3_boot_rest_demo`. You can launch
    the application by using `mvn spring-boot:run` from the project folder. Once the
    application has started, navigate to `http://localhost:8080/api/persons` to view
    all the data in the person table.
  prefs: []
  type: TYPE_NORMAL
- en: To test the other APIs, we will make use of the Postman REST client app for
    Google Chrome.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what adding a new person looks like. Look at the request body, that
    is, the person detail specified in JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f79bf64e-58f7-4c15-b37e-2e8e8acfc231.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is how we edit a person''s details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b66cfed2-0bea-475f-a514-ddbd7126ec02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is what deleting a person looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0cd04988-3536-48af-b94d-7cb0c1ec1eb9.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let's look at how the `PersonMapper` interface discovers the SQL statements
    to execute. If you look at `src/main/resources/mappers/PersonMapper.xml`, you
    will find that the `<mapper>` `namespace` attribute is `org.packt.boot_rest_demo.PersonMapper`.
    This is a requirement that the value of the `namespace` attribute should be the
    fully qualified name of the mapper interface, which, in our case, is `org.packt.boot_rest_demo.PersonMapper`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `id` attributes of the individual SQL statements defined within `<select>`,
    `<insert>`, `<update>`, and `<delete>` should match the name of the method in
    the mapper interface. For example, the `getPersons()` method in the `PersonMapper`
    interface looks for a SQL statement with `id="getPersons"`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the MyBatis library discovers the location of this mapper XML by reading
    the value of the `mybatis.mapper-locations` property.
  prefs: []
  type: TYPE_NORMAL
- en: Coming to the controller, we have introduced a new annotation, `@RestController`.
    This special annotation indicates, in addition to it being a web controller, that
    all the methods defined in the class return a response that is sent via the HTTP
    response body; so do all the REST APIs. They just work with the data.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, you can launch your Spring Boot application either by using the Maven
    Spring Boot plugin, `mvn spring-boot:run`, or by executing the JAR created by
    the Maven package, `java -jar my_jar_name.jar`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating multiple profiles for Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generally, web applications are deployed on different environments – first,
    they are run locally on a developer's machine, then deployed on test servers,
    and finally deployed on production servers. We would have the application interacting
    with components located in different places for each environment. The best approach
    for this is to maintain different profiles for each environment. One way to do
    this is by creating different versions of the `application.properties` file, that
    is, different versions of the file that stores the application-level properties.
    These property files in Spring Boot can also be YML files, such as `application.yml`.
    Even if you create different versions, you need a mechanism to tell your applications
    to pick the relevant version of the file, based on the environment it has been
    deployed to.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot provides amazing support for such a feature. It allows you to have
    multiple configuration files, each representing a specific profile, and then,
    you can launch your application in different profiles, depending on the environment
    it is being deployed to. Let's see this in action, and then we will explain how
    it works.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, there are two options to host another instance of your MySQL
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a cloud provider such as AWS and use its Amazon **Relational Database Service**
    (**RDS**) ([https://aws.amazon.com/rds/](https://aws.amazon.com/rds/)). They have
    a certain free usage limit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a cloud provider such as DigitalOcean ([https://www.digitalocean.com/](https://www.digitalocean.com/))
    to purchase a droplet (that is, a server) for as little as $5 per month. Install
    the MySQL server on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use VirtualBox to install Linux on your machine, assuming we are using Windows,
    or vice versa if you are using Linux. Install the MySQL server on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The options are much more, right from hosted database services to servers,
    which give you complete root access to install the MySQL server. For this recipe,
    we did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We purchased a basic droplet from DigitalOcean.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We installed MySQL using `sudo apt-get install mysql-server-5.7` with a password
    for the root user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We created another user, `springboot`, so that we can use this user to connect
    from our RESTful web service application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We modified the MySQL configuration file so that the MySQL allows remote connections.
    This can be done by editing the `bind-address` property in the `/etc/mysql/mysql.conf.d/mysqld.cnf`
    file for the IP of the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the MySQL workbench, we added the new MySQL connection by using `IP = <Digital
    Ocean droplet IP>`, `username = springboot`, and `password = springboot`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The  location for the MySQL configuration file in Ubuntu OS is `/etc/mysql/mysql.conf.d/mysqld.cnf`.
    One way to find out the location of a configuration file specific to your OS is
    to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Run `mysql --help`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the output, search for `Default options are read from the following files
    in the given order:`. What follows is the possible locations for the MySQL configuration
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will create the required table and populate some data. But before that,
    we will create the `sample` database as `root` and grant all privileges on it
    to the `springboot` user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s connect to the database as the `springboot` user, create the required
    table, and populate it with some sample data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have our cloud instance of the MySQL DB ready. Let's look at how to
    manage the information of two different connections based on the profile the application
    is running in.
  prefs: []
  type: TYPE_NORMAL
- en: The initial sample app required for this recipe can be found at `Chapter09/4_boot_multi_profile_incomplete`.
    We will convert this app to make it run on different environments.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `src/main/resources/application.properties` file, add a new `springboot`
    property, `spring.profiles.active = local`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file, `application-local.properties`, in `src/main/resources/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following properties to `application-local.properties` and remove them
    from the `application.properties` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Create another file, `application-cloud.properties`, in `src/main/resources/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following properties to `application-cloud.properties`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete code for the complete application can be found at `Chapter09/4_boot_multi_profile_incomplete`**.** You
    can run the application using the `mvn spring-boot:run` command. Spring Boot reads
    the `spring.profiles.active` property from the `application.properties` file and
    runs the application in a local profile. Open the `http://localhost:8080/api/persons` URL
    in the browser to find the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the application on the cloud profile by using the `mvn spring-boot:run
    -Dspring.profiles.active=cloud` command. Then, open `http://localhost:8080/api/persons`
    in the browser to find the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that there is a different set of data returned by the same API
    and the preceding data was inserted in our MySQL database running on the cloud.
    So, we have been able to successfully run the app in two different profiles: local
    and cloud.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are multiple ways Spring Boot can read the configuration for the application.
    Some significant ones are listed here in the order of their relevance (the property
    defined in the earlier source overrides the property defined in the later sources):'
  prefs: []
  type: TYPE_NORMAL
- en: From the command line. The properties are specified using the `-D` option, like
    we did while launching the app in the cloud profile, `mvn spring-boot:run -Dspring.profiles.active=cloud`.
    Or, if you are using JAR, it would be `java -Dspring.profiles.active=cloud -jar
    myappjar.jar`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the Java system properties, using `System.getProperties()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OS environment variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profile-specific application properties, `application-{profile}.properties`,
    or the `application-{profile}.yml` files, outside of the packaged JAR.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profile-specific application properties, the `application-{profile}.properties`
    or `application-{profile}.yml` files, packaged within the JAR.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application properties, `application.properties`, or `application.yml` defined
    outside of the packaged JAR.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application properties, `application.properties`, or `application.yml` packaged
    within the JAR.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration classes (that is, annotated with `@Configuration`) serving as
    property sources (annotated with `@PropertySource`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot's default properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our recipe, we specified all the generic properties, such as the following,
    in the `application.properties` file, and any profile-specific properties were
    specified in the profile-specific application properties file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding list, we can find that the `application.properties` or `application-{profile}.properties`
    file can be defined outside the application JAR. There are default locations where
    Spring Boot will search for the properties file, and one such path is the `config`
    subdirectory of the current directory the app is running from.
  prefs: []
  type: TYPE_NORMAL
- en: The complete list of Spring Boot-supported application properties can be found
    at [http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html](http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html).
    In addition to these, we can create our own properties, which will be required
    for our application.
  prefs: []
  type: TYPE_NORMAL
- en: The complete code for this recipe can be found at `Chapter09/4_boot_multi_profile_complete`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can create a configuration server using Spring Boot, which will act as a
    repository for all the properties for all the apps in all the profiles. The client
    apps can then connect with the configuration server to read the relevant properties
    based on the app name and the app profile.
  prefs: []
  type: TYPE_NORMAL
- en: In the configuration server, the application properties can be read from the
    filesystem using the classpath or a GitHub repository. The advantage of using
    a GitHub repository is that the property files can be versioned. The property
    files in the configuration server can be updated, and these updates can be pushed
    to the client apps by setting up a message queue to relay the changes downstream.
    Another way is to use the `@RefreshScope` beans and then invoke the `/refresh`
    API whenever we need the client apps to pull the configuration changes.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying RESTful web services to Heroku
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Platform as a Service** (**Paas**) is one of the cloud computing models (the
    other two being **Software as a Service** (**SaaS**) and **Infrastructure as a
    Service** (**IaaS**)) where the cloud computing provider provides managed computing
    platforms, which includes OS, programming language runtime, database, and other
    add-ons such as queues, log management, and alerting. They also provide you with
    tools to ease the deployment and dashboards to monitor your applications.'
  prefs: []
  type: TYPE_NORMAL
- en: Heroku is one of the earliest players in the field of PaaS providers. It supports
    the following programming languages: Ruby, Node.js, Java, Python, Clojure, Scala,
    Go, and PHP. Heroku supports multiple data stores, such as MySQL, MongoDB, Redis,
    and Elastic search. It provides integration with logging tools, network utilities,
    email services, and monitoring tools.
  prefs: []
  type: TYPE_NORMAL
- en: Heroku provides a command-line tool called heroku-cli ([cli.heroku.com](http://cli.heroku.com)),
    which can be used to create Heroku applications, deploy, monitor, add resources,
    and more. The functionality provided by their web dashboard is supported by the
    CLI as well. It uses Git to store the application's source code. So, when you
    push the application code to Heroku's Git repository, it triggers a build, based
    on the build pack you are using. Then, it either uses the default way to spawn
    the application or `ProcFile` to execute your application.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will deploy our Spring Boot-based RESTful web service to
    Heroku. We will continue to use the database we created on another cloud provider
    in the previous recipe, *Creating multiple profiles for Spring Boot*.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we proceed with deploying our sample application on Heroku, we need to
    sign up for a Heroku account and install its tools, which will enable us to work
    from the command line. In the subsequent sections, we will guide you through the
    signup process, creating a sample app via the web UI, and via the Heroku **command-line
    interface** (**CLI**).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Heroku account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Visit [http://www.heroku.com](http://www.heroku.com) and sign up if you don''t
    have an account. If you have an account, you can log in. To sign up, visit [https://signup.heroku.com](https://signup.heroku.com):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0adec601-5151-4e7f-9284-f2aa214d06b3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To log in, the URL is [https://id.heroku.com/login](https://id.heroku.com/login):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7628a737-18d7-4b89-8687-eb40e6609e82.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you log in successfully, you will see a dashboard with the list of apps,
    if you have any:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/778b9c57-33dd-4792-8caf-cae817772c6b.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a new app from the UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Click on New | Create new app, fill in the details, and click on Create App:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f73432fd-4370-4bf1-aa8a-98407d34d47c.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a new app from the CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to create a new app from the CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the Heroku CLI from [https://cli.heroku.com](https://cli.heroku.com).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once installed, Heroku should be in your system's `PATH` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open a command prompt and run `heroku create`. You will see an output similar
    to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The app name is generated dynamically and a remote Git repository is created.
    You can specify the app name and region (as done via the UI) by running the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The deployment to Heroku is done via `git push` to the remote Git repository
    created on Heroku. We will see this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: We have the source code for the app at `Chapter09/5_boot_on_heroku`. So, copy
    this application and go ahead and deploy on Heroku.
  prefs: []
  type: TYPE_NORMAL
- en: You have to log into the Heroku account before running any of the commands in
    Heroku's cli. You can log in by running the `heroku login` command.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run the following command to create a Heroku application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the Git repository in the project folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the Heroku Git repository as a remote to your local Git repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Push the source code, that is, the master branch, to the Heroku Git repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'When the code is pushed to the Heroku Git repository, it triggers a build.
    As we are using Maven, it runs the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Once the code has completed the build and deployed, you can open the application
    by using the `heroku open` command. This will open the application in a browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can monitor the logs of the application using the `heroku logs --tail` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the app has been successfully deployed, and after you run the `heroku
    open` command, you should see the URL being loaded by the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/661af9df-5c65-4418-9727-ba2d9c7d00c5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking on the Persons link will display the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The interesting thing here is that we have our app running on Heroku, which
    is connecting to a MySQL database on a DigitalOcean server. We can even provision
    a database along with the Heroku app and connect to that database. Check out how
    to do this in the *There's more...* section.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add a new DB add-on to the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Here, `addons:create` takes the add-on name and the service plan name, both
    separated by a colon (`:`). You can learn more about the add-on details and plans
    at [https://elements.heroku.com/addons/jawsdb-maria](https://elements.heroku.com/addons/jawsdb-maria).
    Also, the Heroku CLI command to add the add-on to your application is given toward
    the end of the add-on details page for all add-ons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the DB dashboard to view the connection details, such as URL, username,
    password, and the database name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `jawsdb` dashboard looks something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6677a63b-02f6-4c51-8144-2aafa8f92507.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can even get the MySQL connection string from the `JAWSDB_URL` configuration
    property. You can list the configuration for your app by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the connection details, create a new connection in MySQL Workbench, and
    connect to this connection. The database name is also created by the add-on. Run
    the following SQL statements after connecting to the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new properties file for the Heroku profile, `application-heroku.properties`,
    at  `src/main/resources`, with the following properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: You can find the connection-related details in the add-on dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: Update the `src/main/resources/application.properties` file to replace the value
    of the `spring.profiles.active` property to `heroku`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Commit and push the changes to the Heroku remote:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the deployment succeeds, run the `heroku open` command. Once the page
    loads in the browser, click on the Persons link. This time, you will see a different
    set of data, the one we entered in our Heroku add-on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: With this, we have integrated with a database that we created in Heroku.
  prefs: []
  type: TYPE_NORMAL
- en: Containerizing the RESTful web service using Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have advanced a lot from the time when an app would be installed across servers,
    to each server being virtualized and the app then being installed on these smaller
    virtual machines. Scalability issues for the applications were resolved by adding
    more virtual machines, with the app running to the load balancer.
  prefs: []
  type: TYPE_NORMAL
- en: In virtualization, a large server is divided into multiple virtual machines
    by allocating the computing power, memory, and storage among the multiple virtual
    machines. This way, each of the virtual machines is in itself capable of all those
    things that a server was, albeit on a smaller scale. With this virtualization
    has helped us a lot in judiciously making use of the server's computing, memory,
    and storage resources.
  prefs: []
  type: TYPE_NORMAL
- en: However, virtualization needs some setup, that is, you need to create the virtual
    machine, install the required dependencies, and then run the app. Moreover, you
    may not be 100% sure if the app would run successfully. The reason for failure
    may be due to the incompatible OS versions or even due to some configuration missed
    while setting up or some missing dependency. This setup also leads to some difficulty
    in horizontal scaling because there is some time spent in the provisioning of
    the virtual machine and then deploying the app.
  prefs: []
  type: TYPE_NORMAL
- en: Using tools such as Puppet and Chef does help in provisioning, but then the
    setting up of the app can often result in issues that might be due to a missing
    or incorrect configuration. This led to the introduction of another concept, called
    containerization.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the world of virtualization, we have the host OS and then the virtualization
    software, that is, the hypervisor. We then end up creating multiple machines,
    where each machine has its own OS on which apps are deployed. However, in containerization,
    we don''t divide the resources of the server. Instead, we have the server with
    its host OS, and above that, we have a containerization layer which is a software
    abstraction layer. We package apps as containers, where a container is packaged
    with just enough OS functions required to run the app, the software dependencies
    for the app, and then the app itself. The following image, taken from [https://docs.docker.com/get-started/#container-diagram](https://docs.docker.com/get-started/#containers-vs-virtual-machines),
    best depicts this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/70fd5b75-23b5-4275-b212-bb5b974061dc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding image illustrates a typical architecture of virtualization systems.
    The following image illustrates a typical architecture of containerization systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0601180f-dc65-4c35-95b1-08f08095ce22.png)'
  prefs: []
  type: TYPE_IMG
- en: The biggest advantage of containerization is that you bundle all the dependencies
    of the app into a container image. This image is then run on the containerization
    platform, leading to the creation of a container. We can have multiple containers
    running simultaneously on the server. If there is a need to add more instances,
    we can just deploy the image, and this deployment can be automated to support
    high scalability in an easy way.
  prefs: []
  type: TYPE_NORMAL
- en: Docker is one of the popular software-containerization platform. In this recipe,
    we will package our sample app found at the location `Chapter09/6_boot_with_docker` into
    a Docker image and run the Docker image to launch our application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we will use a Linux server running Ubuntu 16.04.2 x64:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the latest `.deb` file from [https://download.docker.com/linux/ubuntu/dists/xenial/pool/stable/amd64/](https://download.docker.com/linux/ubuntu/dists/xenial/pool/stable/amd64/).
    For other Linux distros, you can find the packages at [https://download.docker.com/linux/](https://download.docker.com/linux/):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the Docker package using the `dpkg` package manager:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The name of the package will vary based on the version you have downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'After successful installation, the Docker service starts running. You can verify
    this by using the `service` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The application to be dockerized is available at `Chapter09/6_boot_with_docker`,
    in the source code downloaded for this book.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create `Dockerfile` at the root of the application with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to build a Docker image using the `Dockerfile` we
    created in the preceding step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'You can view the images that were installed by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: You will see that there are OpenJDK and Ubuntu images as well. These were downloaded
    to build the image for our app, which is listed first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the image to create a container that contains our running application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The large string printed after the `run` command is the identifier of the container.
    You can use the initial few characters to uniquely identify the container. Alternatively,
    you can use the container name, `restapp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The app will have already started. You can view the logs by running the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'You can view the Docker containers created by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding command looks similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf9fa9e9-2603-47ff-93ca-65a4a13ba499.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can manage the container by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Once the app is running, open `http://<hostname>:8090/api/persons`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You define the container structure and its contents by defining `Dockerfile`.
    `Dockerfile` follows a structure, where each line is of the `INSTRUCTION arguments` form.
    There is a predefined set of instructions, namely `FROM`, `RUN`, `CMD`, `LABEL`,
    `ENV`, `ADD`, and `COPY`. A complete list can be found at [https://docs.docker.com/engine/reference/builder/#from](https://docs.docker.com/engine/reference/builder/#from).
    Let''s look at our defined `Dockerfile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The first two lines, using the `FROM` instruction, specified the base image
    for our Docker image. We use the Ubuntu OS image as the base image and then combine
    it with the OpenJDK 9 image. The `VOLUME` instruction is used to specify the mount
    point for the image. This is usually a path in the host OS.
  prefs: []
  type: TYPE_NORMAL
- en: The `ADD` instruction is used to copy the file from the source to the destination
    directory under the working directory. The `ENV` instruction is used to define
    the environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: The `ENTRYPOINT` instruction is used to configure the container to run as an
    executable. For this instruction, we pass an array of arguments, which we would
    otherwise have executed directly from the command line. In our scenario, we are
    using the bash shell to run `java -$JAVA_OPTS -jar <jar name>`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have defined `Dockerfile`, we instruct the Docker tool to build an image
    using `Dockerfile`. We also provide a name for the image using the `--tag` option.
    When building our app image, it will download the required base images, which,
    in our case, are the Ubuntu and OpenJDK images. So, if you list the Docker images,
    you will see the base images along with our app image.
  prefs: []
  type: TYPE_NORMAL
- en: This Docker image is a reusable entity. If we need more instances of the app,
    we spawn a new container using the `docker run` command. When we run the Docker
    image, we have multiple options, where one of them is a `-p` option, which maps
    the ports from within the container to the host OS. In our case, we map the `8080`
    port of our Spring Boot app to `8090` of the host OS.
  prefs: []
  type: TYPE_NORMAL
- en: Now, to check the status of our running app, we can check the logs using `docker
    logs restapp`. Apart from this, the `docker` tool supports multiple commands.
    It's highly recommended to run `docker help` and explore the commands that are
    supported.
  prefs: []
  type: TYPE_NORMAL
- en: Docker, the company behind Docker containerization platform, has created a set
    of base images, which can be used to create containers. There are images for MySQL
    DB, Couchbase, Ubuntu, and other operating systems. You can explore the packages
    at [https://store.docker.com/](https://store.docker.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring the Spring Boot 2 application using Micrometer and Prometheus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Monitoring and collecting performance metrics is an important part of application
    development and maintenance. One would be interested in metrics such as memory
    usage, response time of the various endpoints, CPU usage, load on the machine,
    garbage-collection frequency, and pauses. There are different ways to enable capturing
    metrics, such as using Dropwizard Metrics ([https://metrics.dropwizard.io/4.0.0/](https://metrics.dropwizard.io/4.0.0/)[)](https://metrics.dropwizard.io/4.0.0/)
    or Spring Boot's metrics framework.
  prefs: []
  type: TYPE_NORMAL
- en: The instrumentation of code in Spring Boot 2 onward is done using a library
    called Micrometer ([https://micrometer.io/](https://micrometer.io/)). Micrometer
    provides a vendor-neutral code-instrumentation so that you can use any monitoring
    tool and have Micrometer provide the metrics data in the format understood by
    the tool. This is like SLF4J for logging. It is a facade over the metrics endpoints
    that produces output in a vendor-neutral way.
  prefs: []
  type: TYPE_NORMAL
- en: Micrometer supports tools such as Prometheus ([https://prometheus.io/](https://prometheus.io/)),
    Netflix Atlas ([https://github.com/Netflix/atlas](https://github.com/Netflix/atlas)),
    Datadog ([https://www.datadoghq.com/](https://www.datadoghq.com/)) and upcoming
    support for InfluxDB ([https://www.influxdata.com/](https://www.influxdata.com/)),
    statsd ([https://github.com/etsy/statsd](https://github.com/etsy/statsd)), and
    Graphite ([https://graphiteapp.org/](https://graphiteapp.org/)). Applications
    using earlier version of Spring Boot, such as 1.5, can also make use of this new
    instrumentation library, as shown in the *There's more...* section.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use Micrometer to instrument our code and ship the metrics
    to Prometheus. So, first, we will start by setting up Prometheus in the *Getting
    ready* section.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prometheus ([https://prometheus.io/](https://prometheus.io/)) is a monitoring
    system and time-series database that allows us to store time-series data, which
    includes the metrics of an application over time, a simple way to visualize the
    metrics, or setting up alerts on different metrics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to get Prometheus running on our machines
    (in our case, we will be running on Windows. Similar steps will be applicable
    for Linux as well):'
  prefs: []
  type: TYPE_NORMAL
- en: Download the Prometheus distribution from [https://github.com/prometheus/prometheus/releases/download/v2.3.2/prometheus-2.3.2.windows-amd64.tar.gz](https://github.com/prometheus/prometheus/releases/download/v2.3.2/prometheus-2.3.2.windows-amd64.tar.gz).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract it using 7-Zip ([https://www.7-zip.org/](https://www.7-zip.org/)) on
    Windows to a location that we will call `PROMETHEUS_HOME`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `%PROMETHEUS_HOME%` to your PATH variables (on Linux, it would be `$PROMETHEUS_HOME`
    to the PATH variable).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run Prometheus using the `prometheus --config "%PROMETHEUS_HOME%/prometheus.yml"` command.
    You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/804808bc-52af-40a7-be2c-1ea1286bcde8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Open `http://localhost:9090` in your browser to see the Prometheus console.
    Enter `go_gc_duration_seconds` in the empty text box and click on the Execute
    button to show the metrics captured. You can switch the tab to a Graph version
    to visualize the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7a5e02c6-6401-4eb0-be61-01832f3f8fc4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding metrics are for Prometheus itself. You can navigate to `http://localhost:9090/targets`
    to find out the targets monitored by  the Promethues shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f07d688a-c972-46fc-9fbb-63bb1da19831.png)'
  prefs: []
  type: TYPE_IMG
- en: When you open the `http://localhost:9090/metrics` in your browser, you will
    see the metric value at the current time instant. It's difficult to understand
    without visualization. Such metrics are helpful when collected over time and visualized
    using graphs.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have Prometheus up and running. Let's enable the Micrometer and metrics
    publishing in the format understood by Prometheus. For this, we will be reusing
    the code used in the *Interacting with the database* recipe in this chapter. This
    recipe is available at `Chapter09/2_boot_db_demo`. So, we will just copy the same
    code into `Chapter09/7_boot_micrometer` and then enhance parts to add support
    for Micrometer and Prometheus, as seen in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Update `pom.xml` to include the Spring boot actuator and Micrometer Prometheus
    registry dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In Spring Boot 2 onwards, Micrometer comes configured with actuator, so we just
    need to add actuator as the dependency and then the `micrometer-registry-prometheus`
    dependency produces a metrics representation that is understood by Prometheus.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the application (one of the ways is to run `mvn spring-boot:run`) 
    and open the actuator endpoint, by default it will be `<root_url>/actuator`. We
    will find that there are few actuator endpoints available by default, but the
    Prometheus metrics endpoint is not part of it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/02e97a6b-0504-47fb-bbc7-93e9c63e2a59.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To enable the Prometheus endpoint in actuator, we need to add the following
    property in the `src/main/resources/application.properties` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Restart the app and browse to `http://localhost:8080/actuator/`. Now, you will
    see that only the Prometheus endpoint is available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ddf35ffd-8415-47d6-bd39-15c400d80707.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Open `http://localhost:8080/actuator/prometheus` to see the metrics in a format
    understood by Prometheus:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/07b55bf4-6d26-4cd8-88d4-bbfda24bbb31.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Configure Prometheus to call `http://localhost:8080/actuator/prometheus` at
    a specific frequency, which can be configured. This can be done by updating the
    `%PROMETHEUS_HOME%/prometheus.yml` configuration file with a new job under the `scrape_configs`
    property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: You will see that, by default, there is a job to scrap the Prometheus metrics
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Restart Prometheus server and visit `http://localhost:9090/targets`. You will
    see a new section, `spring_apps`, with the target we have added:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/83686243-24fd-45a4-a616-2473f8fc4249.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can plot a metric from the metrics captured by visiting `http://localhost:9090/graph`,
    typing `jvm_memory_max_bytes` in the text box, and clicking on Execute to get
    a graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/92e2a62a-ac7d-4d2c-a45f-717c9058a108.png)'
  prefs: []
  type: TYPE_IMG
- en: So, we have finally set up the ingestion of metrics in Prometheus and creating
    charts on Prometheus out of the metric values.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Boot provides a library called actuator with features to help you monitor
    and manage the application when deployed to production. This out-of-the-box functionality
    doesn't require any setup from the developers' side. So you get auditing, health
    checks, and metrics-gathering all without any work.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned before, actuator uses Micrometer to instrument and capture different
    metrics from the code, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: JVM memory usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connection-pooling information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Response time of different HTTP endpoints in the app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frequency of invocation of different HTTP endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To enable your application to have these production-ready features, you need
    to add the following dependency to your `pom.xml` if you are using Maven (there
    is an equivalent for Gradle):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, actuator is available at the `/actuator` endpoint, but this can
    be configured by overriding the `management.endpoints.web.base-path` property
    in the `src/main/resources/application.properties` file with a different value,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'All the endpoints available for monitoring and auditing the application are
    enabled by default except for the `/shutdown` endpoint, which is disabled by default.
    This endpoint is used to shut down the application. Here are some of the endpoints
    that are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `auditevents` | Exposes audit events information for the current application
    |'
  prefs: []
  type: TYPE_TB
- en: '| `beans` | Displays a complete list of all the Spring beans in your application
    |'
  prefs: []
  type: TYPE_TB
- en: '| `env` | Exposes properties from Spring’s `ConfigurableEnvironment` |'
  prefs: []
  type: TYPE_TB
- en: '| `health` | Shows application health information |'
  prefs: []
  type: TYPE_TB
- en: '| `info` | Displays arbitrary application info |'
  prefs: []
  type: TYPE_TB
- en: '| `metrics` | Shows metrics information for the current application |'
  prefs: []
  type: TYPE_TB
- en: '| `mappings` | Displays a collated list of all `@RequestMapping` paths |'
  prefs: []
  type: TYPE_TB
- en: '| `prometheus` | Exposes metrics in a format that can be scraped by a Prometheus
    server |'
  prefs: []
  type: TYPE_TB
- en: You can see that these are very sensitive endpoints that need to be secured.
    The good thing is that Spring Boot actuator integrates well with Spring Security
    to secure these endpoints. So if Spring Security is on the classpath, it secures
    these endpoints by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'These endpoints can be accessed by JMX or via the web. Not all of the actuator
    endpoints are enabled for access by the web by default instead they are enabled
    by default for access using JMX. Only the following properties are enabled for
    access by default from the web:'
  prefs: []
  type: TYPE_NORMAL
- en: '`health`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`info`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And this is the reason we had to add the following configuration property to
    make the Prometheus endpoint, along with health, information, and metrics, available
    on the web:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Even if we enable Prometheus, we need to have the `micrometer-registry-prometheus`
    library on our classpath. Only then will we be able to view the metrics in the
    Prometheus format. So, we added the following dependency to our pom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The output format processed by Prometheus is simple: it takes in `<property_name
    value>` with each property in a new line. Spring Boot actuator doesn''t push the
    metrics to Prometheus; instead, we configure Prometheus to pull the metrics from
    a given URL at a frequency defined in its configuration. The default configuration
    of Prometheus, which is available in its home directory, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'So it is configured with default values for intervals at which Prometheus will
    fetch the metrics and for intervals at which it will evaluate the rules defined
    under `rule_files`. Scrape is the activity of pulling the metrics from different
    targets defined under the `scrape_configs` option, and evaluate is the act of
    evaluating different rules defined in `rule_files`. To enable Prometheus to scrap
    the metrics from our Spring Boot app, we add a new job under `scrape_configs`
    by providing the job name, the path of the metrics relative to the application
    URL, and the URL of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: We also saw how we can view the values of these metrics from `http://localhost:9090/graph`
    and how these can be visualized using the simple graph support provided by Prometheus.
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Alerting can be enabled in Prometheus by configuring another service, called
    Alertmanager ([https://prometheus.io/docs/alerting/alertmanager/](https://prometheus.io/docs/alerting/alertmanager/)).
    This service can be used to send alerts to emails, pagers, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The graphing support in Prometheus is naive. You can use Grafana ([https://grafana.com/](https://grafana.com/)),
    which is one of the leading open source software in analyzing time-series data,
    such as the one stored in Prometheus. This way you can configure Grafana to read
    the time-series data from Prometheus and build dashboards with predefined metrics
    plotted on different types of charts.
  prefs: []
  type: TYPE_NORMAL
