- en: Searching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important operations for all data structures is searching for
    the elements from the stored data. There are various methods to search for an
    element in the data structures; in this chapter, we shall explore the different
    strategies that can be used to find elements in a collection of items.
  prefs: []
  type: TYPE_NORMAL
- en: The searching operation is a very important operation for sorting. It is virtually
    impossible to sort the data without using some variant of a search operation.
    The sorting algorithm will be fast if the searching algorithm is efficient. In
    this chapter, we will be discussing different searching algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: The performance of a search operation is heavily influenced by whether the items
    about to be searched have already been sorted or not, as we will see in the subsequent
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand various searching algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the implementation of the popular searching algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the implementation of the binary searching algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the implementation of interpolation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The source code used in this chapter is available at the following GitHub link:
    [https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-3.7-Second-Edition/tree/master/Chapter09](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-3.7-Second-Edition/tree/master/Chapter09).'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to searching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Searching algorithms are categorized into two broad types:'
  prefs: []
  type: TYPE_NORMAL
- en: The searching algorithm is applied to the list of items that are already sorted;
    that is, applied to the ordered set of items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The searching algorithm is applied to the unordered set of items, which are
    not sorted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linear search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *searching* operation is to find out a given item from the stored data.
    If the searched item is available in the stored list then it returns the index
    position where it is located, or else it returns that the item is not found. The
    simplest approach to search for an item in a list is the linear search method,
    in which we look for items one by one in the whole list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take an example of `5` list items `{60, 1, 88, 10, 11, 100}` to understand
    the linear search algorithm, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/03ac28e0-5e8e-46c6-89c4-92f96fb74625.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding list has elements that are accessible through the list index.
    To find an element in the list, we employ the linear searching technique. This
    technique traverses the list of elements by using the index to move from the beginning
    of the list to the end. Each element is examined, and if it does not match the
    search item, the next item is examined. By hopping from one item to the next,
    the list is traversed sequentially.
  prefs: []
  type: TYPE_NORMAL
- en: We use list items with integer values in this chapter to help you understand
    the concept, since integers can be compared easily; however, a list item can hold
    any other data type as well.
  prefs: []
  type: TYPE_NORMAL
- en: Unordered linear search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The linear search approach depends on how the list items are stored—whether
    they are sorted in order or stored without any order. Let's first see if a list
    has items that are not sorted.
  prefs: []
  type: TYPE_NORMAL
- en: Consider an example list that contains elements 60, 1, 88, 10, and 100—an unordered list.
    The items in the list have no order by magnitude. To perform a search operation
    on such a list, one proceeds from the very first item and compares that with the
    search item. If the search item is not matched then the next element in the list
    is examined. This continues till we reach the last element in the list or until
    a match is found.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the implementation in Python for the linear search on an unordered
    list of items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `search` function takes two parameters; the first is the list that holds
    our data, and the second parameter is the item that we are looking for, called the
    **search term**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The size of the array is obtained and determines the number of times the `for`
    loop is executed. The following code depicts this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: On every pass of the `for` loop, we test if the search term is equal to the
    indexed item. If this is true, then there is a match, and there is no need to
    proceed further with the search. We return the index position where the searched
    item is found in the list.
  prefs: []
  type: TYPE_NORMAL
- en: If the loops run to the end of the list with no match found, then `None` is
    returned to signify that there is no such item in the list.
  prefs: []
  type: TYPE_NORMAL
- en: In an unordered list of items, there is no guiding rule for how elements are
    inserted. Thus, it impacts the way the search is performed. As such, we must visit
    all the items in the list one after the other. As can be seen in the following
    diagram, the search for the term **66** starts from the first element and moves
    to the next element in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, the first **60** is compared with **66**, and if it is not equal, we
    compare **66** with the next element **1**, then **88**, and so on till we find
    the search term in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ba66df36-c90d-478a-a31d-9baa5b3407b0.png)'
  prefs: []
  type: TYPE_IMG
- en: The unordered linear search has a worst-case running time of `O(n)`. All the
    elements may need to be visited before finding the search term. The worst-case
    scenario will be when the search term is located at the last position of the list.
  prefs: []
  type: TYPE_NORMAL
- en: Ordered linear search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another case in a linear search is when the list elements have been sorted;
    then our search algorithm can be improved. Assuming the elements have been sorted
    in ascending order, the search operation can take advantage of the ordered nature
    of the list to make the search more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm is reduced to the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Move through the list sequentially
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a search item is greater than the object or item currently under inspection
    in the loop, then quit and return `None`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the process of iterating through the list, if the search term is greater
    than the current item, then there is no need to continue with the search.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider an example to see how this works. We take a list of items,
    as shown in the following diagram, and we want to search term `5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/409f41bf-abb5-425d-a412-05fa3f565249.png)'
  prefs: []
  type: TYPE_IMG
- en: When the search operation starts and the first element is compared with the search
    term (**5**), no match is found. However, there are more elements in the list
    so the search operation moves on to examine the next element. A more compelling
    reason to move on in the sorted list is that we know the search item may match
    any of the elements greater than **2**.
  prefs: []
  type: TYPE_NORMAL
- en: After the fourth comparison, we come to the conclusion that the search term
    cannot be found in any position later in the list where **6** is located. In other
    words, if the current item is greater than the search term, then it means there
    is no need to further search the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the implementation of the linear search when the list is already sorted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `if` statement now caters for checking if the search
    item is found in the list or not. `elif` tests the condition where `ordered_list[i]
    > term`. The method returns `None` if the comparison evaluates to `True`.
  prefs: []
  type: TYPE_NORMAL
- en: The last line in the method returns `None` because the loop may go through the
    list and still the search item is not matched in the list.
  prefs: []
  type: TYPE_NORMAL
- en: The worst-case time complexity of an ordered linear search is `O(n)`. In general,
    this kind of search is considered inefficient especially when dealing with large
    datasets.
  prefs: []
  type: TYPE_NORMAL
- en: Binary search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A binary search is a search strategy used to find elements within a **sorted**
    array or list; thus, the binary search algorithm finds a given item from the given
    sorted list of items. It is a very fast and efficient algorithm to search an element,
    and the only drawback is that we need a sorted list. The worst-case running time
    complexity of a binary search algorithm is `O(log n)` whereas the linear search
    has `O(n)`.
  prefs: []
  type: TYPE_NORMAL
- en: A binary search algorithm works as follows. It starts searching the item by
    dividing the given list by half. If the search item is smaller than the middle
    value then it will look for the searched item only in the first half of the list,
    and if the search item is greater than the middle value it will only look at the
    second half of the list. We repeat the same process every time until we find the
    search item or we have checked the whole list.
  prefs: []
  type: TYPE_NORMAL
- en: Let's understand the binary search using an example. Suppose we have a book
    of 1,000 pages, and we want to reach the page number 250\. We know that every
    book has its pages numbered sequentially from `1` upwards. So, according to the
    binary search analogy, we first check the search item 250 which is less than the
    500 (which is the midpoint of the book). Thus, we search the required page only
    in the first half of the book. We again see the midpoint of the first half of
    the book, that is, using page 500 as a reference we find the midpoint, that is,
    250. That brings us closer to finding the 250th page. And then we find the required
    page in the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider another example to understand the workings of binary search.
    We want to search for an item **43** from a list of 12 items, as shown in the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/692a7fab-d183-4d56-810f-b0ba163436cc.png)'
  prefs: []
  type: TYPE_IMG
- en: We start searching the item by comparing it to the middle item of the list,
    which is **37** in the example. If the search item is less than the middle value
    we only look at the first half of the list; otherwise, we will look in the other
    half. So we only need to search for the item in the second half. We follow the
    same concept until we find the search item **43** in the list as shown in the
    preceding diagram.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the implementation of the binary search algorithm on an ordered
    list of items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s assume we have to find the position where item **10** is located in
    the list as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c6fea9e7-dc50-4b14-a11a-c80121e372d0.png)'
  prefs: []
  type: TYPE_IMG
- en: The algorithm uses a `while` loop to iteratively adjust the limits in the list
    within which we have to find a search item. The terminating condition to stop
    the `while` loop is that the difference between the starting index, `index_of_first_element`,
    and the `index_of_last_element` index should be positive.
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm first finds the midpoint of the list by adding the index of the
    first element (**0**) to that of the last (**4**) and dividing it by **2** to
    find the middle index, `mid_point`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the midpoint is `100`, and the value **10** is not found at the
    middle position in the list. Since we are searching for the item **10**, that
    is less than the midpoint, so it lies on the first half of the list, thus, we
    adjust the index range to be `index_of_first_element` to `mid_point-1` as shown
    in the following diagram, However, if we were searching for **120**, in that case,
    as 120 is greater than the middle value (100), we would search the item in the
    second half of the list, and we need to change the list index range to be `mid_point
    +1 `to  `index_of_last_element`. It is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/d775d66a-c695-499a-b072-9627fa419a4d.png)'
  prefs: []
  type: TYPE_IMG
- en: With our new indexes of `index_of_first_element` and `index_of_last_element`
    now being **0** and **1** respectively, we compute the midpoint `(0 + 1)/2`, which
    equals `0`. The new midpoint is **0**, so we find the middle item and compare
    it with the search item, `ordered_list[0]`, which yields the value **10**. Now,
    our search item is found, and the index position is returned.
  prefs: []
  type: TYPE_NORMAL
- en: This reduction of our list size by half, by readjusting the index of `index_of_first_element`
    and `index_of_last_element`, continues as long as `index_of_first_element` is
    less than `index_of_last_element`. When this fails to be the case, it is most
    likely that our search term is not in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation we discussed is an iterative one. We can also develop a
    recursive variant of the algorithm by applying the same principle and shifting
    the pointers that mark the beginning and end of the search list. Consider the
    following code for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'A call to this recursive implementation of the binary search algorithm and
    its output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, the only distinction between the recursive binary search and the iterative
    binary search is the function definition and also the way in which `mid_point`
    is calculated. The calculation for `mid_point` after the `((last_element_index
    - first_element_index) // 2)` operation must add its result to `first_element_index`.
    That way, we define the portion of the list to attempt the search.
  prefs: []
  type: TYPE_NORMAL
- en: The binary search algorithm has the worst-case time complexity of `O(log n)`.
    The half of the list on each iteration follows `log(n)` of the number of elements
    and their progression.
  prefs: []
  type: TYPE_NORMAL
- en: It goes without saying that `log x` is assumed to be referring to log base two.
  prefs: []
  type: TYPE_NORMAL
- en: Interpolation search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The interpolation searching algorithm is an improved version of the binary search
    algorithm. It performs very efficiently when there are uniformly distributed elements
    in the sorted list. In a binary search, we always start searching from the middle
    of the list, whereas in the interpolation search we determine the starting position
    depending on the item to be searched. In the interpolation search algorithm, the
    starting search position is most likely to be the closest to the start or end
    of the list depending on the search item. If the search item is near to the first
    element in the list, then the starting search position is likely to be near the
    start of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interpolation search is another variant of the binary search algorithm
    that is quite similar to how humans perform the search on any list of items. It
    is based on trying to make a good guess of the index position where a search item
    is likely to be found in a sorted list of items. It works in a similar way to
    the binary search algorithm except for the method to determine the splitting criteria
    to divide the data in order to reduce the number of comparisons. In the case of
    a binary search, we divide the data into equal halves and in the case of an interpolation
    search, we divide the data using the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding formula, the `lower_bound_index` variable is the lower-bound
    index, which is the index of the smallest value in the, `upper_bound_index` list,
    denoting the index position of the highest value in the list. The `input_list[lower_bound_index] `
    and `input_list[lower_bound_index]` variables are the lowest and highest values
    respectively in the list. The `search_term` variable contains the value of the
    item that is to be searched.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider an example to understand how the interpolation searching algorithm
    works using the following list of `7` items:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/69b60fe9-60b7-4ff4-a1c2-e7d5ed404713.png)'
  prefs: []
  type: TYPE_IMG
- en: To find **120**, we know that we should look at the right-hand portion of the
    list. Our initial treatment of binary search would typically examine the middle
    element first in order to determine if it matches the search term.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more human-like method would be to pick a middle element in such a way as
    to not only split the array in half but to get as close as possible to the search
    term. The middle position was calculated using the following rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We shall replace this formula with a better one that brings us closer to the
    search term in the case of the interpolation search algorithm. The `mid_point`
    will receive the return value of the `nearest_mid` function, which is computed
    using the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `nearest_mid` function takes, as arguments, the lists on which to perform
    the search. The `lower_bound_index` and `upper_bound_index` parameters represent
    the bounds in the list within which we are hoping to find the search term. Furthermore, `search_value`
    represents the value being searched for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given our search list, **44**, **60**, **75**, **100**, **120**, **230**, and
    **250**, `nearest_mid` will be computed with the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compute the `mid_point` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It can now be seen that the `mid_point` value will receive the value `5`. So
    in the case of an interpolation search, the algorithm will start searching from
    the index position `5`,which is the index of the location of our search term.
    Thus, the item to be searched will be found in the first comparison, whereas in
    the case of a binary search, we would have chosen **100** as `mid_point`, which
    would have required another run of the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more visual illustration of how a typical binary search differs from an interpolation
    is given as follows. In a typical binary search, it finds the **midpoint** that
    looks like it''s in the middle of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/59172fff-5a88-43bd-a9a8-c0825a1650bd.png)'
  prefs: []
  type: TYPE_IMG
- en: One can see that the **midpoint **is actually standing approximately in the
    middle of the preceding list. This is as a result of dividing by list two.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of an interpolation search, on the other hand, the **midpoint**
    is moved to the most likely position where the item can be matched:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/fdb75873-7f16-4c81-bbe3-a62b392095ad.png)'
  prefs: []
  type: TYPE_IMG
- en: In an interpolation search, the **midpoint** is generally more to the left or
    right. This is caused by the effect of the multiplier being used when dividing
    to obtain the **midpoint**. In the preceding diagram, our **midpoint** has been
    skewed to the right.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of the interpolation algorithm remains the same as that of
    the binary search except for the way we compute the **midpoint**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we provide the implementation of the interpolation search algorithm,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `nearest_mid` function makes use of a multiplication operation. This can
    produce values that are greater than `upper_bound_index` or lower than `lower_bound_index`.
    When this occurs, it means the search term, `term`, is not in the list. `None`
    is, therefore, returned to represent this.
  prefs: []
  type: TYPE_NORMAL
- en: 'So what happens when `ordered_list[mid_point]` does not equal the search term?
    Well, we must now readjust `index_of_first_element` and `index_of_last_element`
    so that the algorithm will focus on the part of the array that is likely to contain
    the search term. This is exactly like what we did in the binary search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If the search term is greater than the value stored at `ordered_list[mid_point]`,
    then we only adjust the `index_of_first_element` variable to point to the `mid_point
    + 1` index.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how the adjustment occurs. The `index_of_first_element`
    is adjusted and pointed to the `mid_point+1` index:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b4d74ddb-972e-4f1b-8f31-404863c144c7.png)'
  prefs: []
  type: TYPE_IMG
- en: The diagram only illustrates the adjustment of the midpoint. In interpolation,
    the midpoint rarely divide the list into two equal halves.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, if the search term is less than the value stored at `ordered_list[mid_point]`,
    then we only adjust the `index_of_last_element` variable to point to the index
    `mid_point - 1`. This logic is captured in the else part of the if statement `index_of_last_element
    = mid_point - 1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/62be8deb-9a92-4fcc-bb9a-29e33f89e048.png)'
  prefs: []
  type: TYPE_IMG
- en: The diagram shows the effect of the recalculation of **index_of_last_element**
    on the position of the **midpoint**.
  prefs: []
  type: TYPE_NORMAL
- en: Let's use a more practical example to understand the inner workings of both
    the binary search and interpolation algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider for example the following list of elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: At index 0, the value 2 is stored, and at index 7, the value 77 is stored. Now,
    assume that we want to find the element 2 in the list. How will the two different
    algorithms go about it?
  prefs: []
  type: TYPE_NORMAL
- en: 'If we pass this list to the `interpolation search` function, then the `nearest_mid`
    function will return a value equal to `0` using the formula of `mid_point` computation
    which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As we get the `mid_point` value `0`, we start the interpolation search with
    the value at index `0`. Just with one comparison, we have found the search term.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, the binary search algorithm needs three comparisons to arrive
    at the search term, as illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7ea01d77-5583-4145-ad5c-99486e10f863.png)'
  prefs: []
  type: TYPE_IMG
- en: The first `mid_point` value calculated is `3`. The second `mid_point` value
    is `1` and the last `mid_point` value where the search term is found is `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, it is clear that the interpolation search algorithm performs better
    than binary search in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a search algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The binary search and interpolation search algorithms are better in performance
    compared to both ordered and unordered linear search functions. Because of the
    sequential probing of elements in the list to find the search term, ordered and
    unordered linear searches have a time complexity of `O(n)`. This gives a very
    poor performance when the list is large.
  prefs: []
  type: TYPE_NORMAL
- en: The binary search operation, on the other hand, slices the list in two anytime
    a search is attempted. On each iteration, we approach the search term much faster
    than in a linear strategy. The time complexity yields `O(log n)`. Despite the
    speed gain in using a binary search, the main disadvantage of it is that it cannot
    be applied on an unsorted list of items, neither is it advised to be used for
    a list of small size due to an overhead of sorting.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to get to the portion of the list that holds a search term determines,
    to a large extent, how well a search algorithm will perform. In the interpolation
    search algorithm, the midpoint is computed in such as way that it gives a higher
    probability of obtaining our search term faster. The average-case time complexity
    of the interpolation search is `O( log ( log n))`, whereas the worst-case time
    complexity of the interpolation search algorithm is `O(n)`. This shows that interpolation
    search is better than binary search and provides faster searching in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the two important types of search algorithms.
    The implementation of both linear and binary search algorithms were discussed
    and their comparisons drawn. The binary search variant, interpolation search,
    was also discussed in detail in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We will be using the concepts of searching for sorting algorithms in the next
    chapter. We will also use the knowledge that we have gained to perform sorting
    algorithms on a list of items.
  prefs: []
  type: TYPE_NORMAL
