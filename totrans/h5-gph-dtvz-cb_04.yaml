- en: Chapter 4. Let's Curve Things Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Building a bubble chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a pie chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a doughnut chart to show relationships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging a radar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structuring a tree chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we built a component for linear graphs ranging through
    dots, lines, and bars. Most of the data we worked with was two-dimensional, while
    we ended our lesson with a four-dimensional chart. It was still represented using
    linear art. In this chapter, we will leverage the capability of creating non-linear
    data to represent data.
  prefs: []
  type: TYPE_NORMAL
- en: Building a bubble chart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although many items in our chart will have correlations with earlier charts
    that we created in [Chapter 3](ch03.html "Chapter 3. Creating Cartesian-based
    Graphs"), *Creating Cartesian-based Graphs*, we will start from scratch. Our goal
    is to create a chart that has bubbles in it—the bubbles enable us to showcase
    data with three data points (x, y, and the size of the bubble). This type of chart
    is really ideal when animated as it can showcase changes over time (it could showcase
    many years in a few seconds).
  prefs: []
  type: TYPE_NORMAL
- en: A great demo of the powers of bubble charts can be seen in a TED presentation
    by Hans Rosling ([http://blog.everythingfla.com/2012/05/hans-rosling-data-vis.html](http://blog.everythingfla.com/2012/05/hans-rosling-data-vis.html)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a bubble chart](img/3707OT_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start up our project with a canvas setup and skip the HTML end. If you
    have forgotten how to create it please refer to the *Graphics with 2D Canvas*
    recipe in [Chapter 1](ch01.html "Chapter 1. Drawing Shapes in Canvas"), *Drawing
    Shapes in Canvas*.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three major steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the data source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the background
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the chart data info into the chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s list the steps required to create a bubble chart:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next data object should look familiar in an array that has objects within
    it with student scores in English, Math, and programming. Build the data object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create our chart information; contrary to previous charts, this chart has a
    third parameter for our bubble information. Define our chart rules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The last data object will contain all the styling information that we might
    want to change in the future. Add a styling object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We create an event callback when the document is ready to trigger `init`, so
    let''s create the `init` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We start creating our outline when we create our style object. Now it''s time
    to draw everything into our canvas. So we start by setting up our base canvas
    style:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to save our current, canvas-based graphic layout information, change
    it to make it easier to position elements and then return it back to its original
    state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it is time to draw the outlines with the help of our `chartInfo` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now it is time to add the data into our chart by creating the `addDots` method.
    The function `addDots` will take in the data with the definition of rules (keys)
    to be used, contrary to what we did in the earlier recipes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This block of code, although redone from scratch, bears a lot of resemblance
    to the *Spreading data in a scatter chart* recipe in [Chapter 3](ch03.html "Chapter 3. Creating
    Cartesian-based Graphs"), *Creating Cartesian-based Graphs*, with modifications
    to enable the third level of data and the new charting format.
  prefs: []
  type: TYPE_NORMAL
- en: That's it. You should have a running bubble chart. Now when you run the application,
    you will see that the `x` parameter is showcasing the math score, the `y` parameter
    is showcasing the programming score, while the size of our bubble showcases the
    student's score in English.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with the `createOutline` function. In this method, apart from
    the regular canvas drawing methods that we grow to love, we introduce a new style
    of coding where we manipulate the actual canvas to help us define our code in
    an easier way. The two important key methods here are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be leveraging both the methods a few times. The `save` method saves
    the current view of the canvas while the `restore` method returns users to the
    last saved canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the first use of this style, we are using it to draw our text by rotating
    it to the right. The `translate` method moves the `0, 0` coordinates of the canvas
    while the `rotate` method rotates the text using radians.
  prefs: []
  type: TYPE_NORMAL
- en: After drawing the external bars, it's time for us to use this new capability
    to our advantage. Most charts rely on a y coordinate that grows upwards, but this
    canvas has the y values growing from the top to the bottom of the canvas area.
    We can flip this relationship by adding some code before we loop through to add
    the range values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding lines, we are first moving the `0,0` coordinates of our canvas
    to be exactly at the bottom-right range of our chart, and then we are flipping
    our canvas by switching the scale value. Note that from now on if we try to add
    text to the canvas, it will be upside down. Keep that in mind as we are now drawing
    in a canvas that is flipped upside down.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing to note in our first loop when we try to type in new text is that
    when we want to add text, we first undo our scale and then return back our canvas
    for it to be flipped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that we are multiplying our y coordinate by `*-1`. We are doing this because
    we actually want the value of our y coordinate to be negative as we have just
    flipped the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The work around the x bar text is very similar; notice the main differences
    related to finding the x and y value calculations.
  prefs: []
  type: TYPE_NORMAL
- en: It's time to dig into the `addDots` function. The function will again look familiar
    if you've been following [Chapter 3](ch03.html "Chapter 3. Creating Cartesian-based
    Graphs"), *Creating Cartesian-based Graphs*, but this time we are working with
    a modified canvas.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with a few helper variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We are adding the bubble effect dynamically, which means that this method can
    work even if there are only two points of information and not three. We continue
    by testing to see if our data object contains the bubble information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If so, we add a few more variables and align our text to the left as we are
    going to use it in this example.
  prefs: []
  type: TYPE_NORMAL
- en: It's time for us to look through our data object and propagate the data on the
    chart.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: For each loop, we recalculate the `_x` and `_y` coordinates based on the current
    values.
  prefs: []
  type: TYPE_NORMAL
- en: If we have a third element, we are ready to develop a bubble. If we do not have
    it, we need to create a simple dot.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: At this stage, we should have an active bubble/dot method. All that is left
    is for us to integrate our overlay copy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add a label, let''s take a peek at the function signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `context` and `chartInfo` parameters are already a standard in our samples.
    The idea of keys was to enable us to switch what data will be tested dynamically.
    The keys' values are the array positions `0` and `1` that are correlated to the
    x and y coordinates, and position `2` is used for bubbles, as we've seen earlier.
    The `label` parameter enables us to send in a key value for the label. In this
    way, if the label is there we will add a label and if it is not there we will
    not.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Then we add the preceding `if` statement. If our label is set, we position the
    style and create the text of the label.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a pie chart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps to create a pie chart are relatively easy and short. Pie charts are
    ideal for showcasing a closed amount of data that we want to easily compare between
    data fields such as, in our example, dividing the number of people in the world
    into groups based on their region:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a pie chart](img/3707OT_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step will be to update our canvas size in the HTML area to be a rectangular
    area. In our sample, we will update the values to 400 x 400\. That's about it;
    let's start building it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following steps we will create our first pie chart. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up our data source and our global variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Prepare our canvas (from here on we are delving into the `init` function):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Count the total data (world population):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Set up 360 degrees in radians and move our pivot point to `0,0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Draw the pie chart by using the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: That's it; we have just created a basic pie chart—I told you it would be easy!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our pie chart, as its name indicates, uses pies and always showcases 100 percent
    of data. As our arc method works based on radians, we need to convert these data
    points from percentile to radians.
  prefs: []
  type: TYPE_NORMAL
- en: After figuring out what the total of all the values is and the total radians
    in a circle (`2*PI`), we are ready to loop through and draw the slices.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The logic is relatively simple; we loop through all the data elements, change
    the fill style based on the data object, and move our pointer to `0,0` (to the
    center of our screen as we have changed the pivot point of our canvas).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we draw the arc. Pay attention to the highlighted text; we start with where
    we left off our current total and through that we calculate the angle in radians:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can turn this value into a percentage value that we can duplicate against
    the total radian of our circle. Our second parameter is very close, so we just
    add into it the current value of the current region we are in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: And the last point to note here is that we are setting the arc's last parameter
    to `false` (counter clockwise) as that works best for our calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, we update our `currentTotal` value to encompass the newly
    added region as that will be our starting point in the next round of our `for`
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A pie chart without any information on its content is probably not going to
    work as well as a chart with information, but we can figure out the locations...
    well worry not; we are going to revisit our old friends `cos` and `sin` to help
    us locate the dots on our circle, to enable us to add textual information on our
    newly created pie.
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting Math.cos() and Math.sin()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will start with adding a new global variable to store the color of our lines
    and then we will call it `copyStyle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we are right back into our `init` function, let''s add it into our
    `for` loop just before the last line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, we will first set our new `copyStyle` variable as our fill and
    stroke value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Our next step is to locate where in our pie we would like to draw a line out
    so that we can add the text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To accomplish this, we will use a new variable that will store the mid-value
    between the last total and the new value (the center of the new slice). So far
    so good. Now we need to figure out how to get the x and y positions of that point.
    Lucky for us, there is a very easy way of doing it in a circle by using the `Math.cos`
    (for the x) and `Math.sin` (for our y) functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Armed with our `midRadian` variable, we will get the value for a circle with
    a radius of `1`, so all that is left for us to do is duplicate that value by our
    real radius to find our starting point. As we want to draw a line in the same
    direction to the arc externally, we will find the points of an imaginary circle
    that is larger; so for that we are going to use the same formula, but instead
    upgrade our radius values by 20, creating a diagonal line that is correlative
    to the arc.
  prefs: []
  type: TYPE_NORMAL
- en: 'All that is left for us to do is figure out what text we would want to have
    within our chart, using the same arc point with a larger circle size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Looks good... The only problem is that we don't have our values; let's add them
    and figure out the challenges involved with them.
  prefs: []
  type: TYPE_NORMAL
- en: Improving our bubbles' text format
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a real-world example, we would probably want to use a rollover if this was
    a live application (we will visit that idea in a later chapter), but let''s try
    to figure out a way to create the chart capable of containing all the information.
    We stopped in our preceding line of code with a really large exterior circle (`radius+40`).
    Well that''s because we wanted to slip in a new line of text right under, so let''s
    do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s a bit of a mouthful, but it''s basically the same as the preceding line
    with a new line of text and an extra change, as we are shifting the y value by
    12 pixels to account for the first line of text on the same area. To get this
    working, we are using two helper functions that format our text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If you run the application in its current format, you will find that the text
    just doesn't look good on the page, and that is where the artist within you needs
    to sort things out. I've continued the sample in our source files until it felt
    right, so check it out or create your own variations from here on.
  prefs: []
  type: TYPE_NORMAL
- en: Using a doughnut chart to show relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The doughnut chart is a fancy pie chart. So if you haven''t created a pie chart
    yet, I strongly encourage you to revisit the previous recipe, *Creating a pie
    chart*. A doughnut chart is a layered pie chart. This chart is ideal for condensing
    the comparable data between data types that would fit into a pie chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using a doughnut chart to show relationships](img/3707OT_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to grab our code from the last example and adjust it to fit our
    needs. So we will start with the same HTML file and the same code from the last
    example.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update our data with some dummy data (we will create two data objects):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the `init` function by extracting all the pie-creating lines to a separate
    function and adding a new function `createHole` (for our doughnut):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the pie creation to change the text layout to fit into a pie chart:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to create the method `createHole` (actually a simple circle):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: That's it! We can now create an endless doughnut with as many layers as we would
    like by changing the radius, making it smaller each time we add a new layer.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The core logic of the doughnut chart is the same as that of the pie chart.
    Our main focus is really about reformatting and rewiring the content to be outlined
    at the visual level. As such, part of our work is to delete the things that are
    not relevant and to make the needed updates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The main thing to note is that we are hardcoding a value that is 20 less than
    the current radius. If we wanted our sample to work for every possible option,
    we would need to figure out a smarter way of generating this data as ideally we
    would want the text to be in between the doughnut area and rotated, but we have
    done things of that nature before so I'll leave that for you to explore.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although our doughnut is created and ready, it would help if we add some more
    information to it, such as outlines and a legend, as we extracted the majority
    of the text from the last example.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an outline
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will use shadows to create a glow around our shapes. The easiest and quickest
    way to do it is to revisit the `init` function and add into it the shadow information
    to create this effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The key here is that we are setting our offset on both the x and y values to
    be `0`, and as such our shadow is being used as a glow. Every element that will
    be drawn from here on will have a shadow, and that works perfectly for us.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a legend
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Hey, since we have a huge hole in our doughnut, how about we put our legend
    right in the middle of everything? As sometimes the middle isn't exactly the best-looking
    thing, it will probably be best to manually figure out what is the perfect position
    after we create the legend.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We start by removing our shadow, by setting its alpha to `0` and moving our
    pivot point. (I tweaked these numbers after the legend was created until I was
    happy.)
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, we are ready to create our legend with the `createLegend` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We have completed a fully fledged doughnut chart with a legend.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating a pie chart* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging a radar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Radars are very misunderstood charts but are really amazing. A radar enables
    us to showcase a really large amount of comparable data in a very condensed way.
    The radar chart is known as a spider chart as well.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Warning**'
  prefs: []
  type: TYPE_NORMAL
- en: You really need to be friendly with the `Math.cos` and `Math.sin` functions,
    as we are going to use them plenty of times in this chart type. With that said,
    if you don't feel comfortable with them yet, it would be a good idea to start
    from the start of the chapter to refresh your memory on this.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As always, we are going to start with our base HTML page with an `init` callback.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: A radar chart is really a line chart wrapped up into a circular shape with a
    lot of different math involved; but it's the same idea—instead of spreading our
    data horizontally, we are spreading our data around a center point.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/3707OT_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s see what are the steps involved in creating a radar chart:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create/Organize the chart data and the actual data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a few helper variables and an `init` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it is time to create the `createSpider` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We split the creation of the radar web into two stages. The first is the lines
    coming out of the center of the web and the other is the actual webs that loop
    around this center point. Let''s start with the first step and continue to the
    next part in the second loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s time to integrate our data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations, you have just created a radar/spider chart.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The radar chart is one of our more complicated chart types. So far it uses a
    lot of cos/sin functions, but the logic is very consistent and as such relatively
    simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a deeper look into the `drawWeb` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We start by creating a few helper variables and repositioning our pivot point
    to the center of the screen to help us with our calculations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We then create our spikes based on the number of courses, as each course will
    be represented with a spike.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to create the interwebs of our spider web now that we have our core
    building blocks (the spikes):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In this multidimensional loop, we are running through step by step to draw lines
    from one dot on a circle to the next (from one spike point to the next), growing
    our radius each time we are done with creating a complete shape. Each shape we
    create here represents a growth by 10 in the students' score, as our students
    can only have scores between 0 and 100\. We can ignore extreme cases in this sample.
    (You might need to adjust this code if your data range doesn't start at 0.)
  prefs: []
  type: TYPE_NORMAL
- en: While our `drawDataWeb` method changes, the radius based on the score assumes
    a range of 0 to 100\. (If your ranges are not the same, you will need to modify
    this code, or modify your data sets to be between 0 and 100 when sent to the method.)
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our radar isn't perfect as it could use a legend and some textual information
    around our radar so that we know what each bar represents. We will let you sort
    out a legend as we've done in the previous recipe *Using a doughnut chart to show
    relationships*.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a rotated legend
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To fix this issue and add our text, we will revisit our function `drawWeb`
    with our first loop in that function, and instead of updating the cos/sin values
    to find the rotation, we will just rotate our canvas and integrate our text at
    the edge each time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The logic here is a bit simpler as we are just rotating our canvas each time
    and using the exact same code over and over until the rotation comes to a full
    circle.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring a tree chart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many types of trees in the virtual world, although the most intuitive
    one is a family tree. A family tree is a bit more complex than a basic data tree
    such as a class inheritance tree, as for the most part classes have only one parent
    while family trees usually have two.
  prefs: []
  type: TYPE_NORMAL
- en: We will build an inheritance tree for the display objects of ActionScript 3.0.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please note that this sample is cutting edge in HTML5\. One of the new features
    that no one really knows whether will get adopted or not is E4X. It's been embraced
    by Firefox, but not all browsers have implemented it (it is fully supported in
    Flash as well).
  prefs: []
  type: TYPE_NORMAL
- en: '**ECMAScript for XML** (**E4X**) is a programming language extension that adds
    native XML support to ECMAScript. It has replaced the DOM interface and is implemented
    as a primitive (such as numbers and Booleans), making it faster and more optimized.'
  prefs: []
  type: TYPE_NORMAL
- en: As we are mainly working locally, we are going to save our XML document directly
    in our JavaScript to avoid sandbox security issues.
  prefs: []
  type: TYPE_NORMAL
- en: To help us space out our elements, we will make our canvas area much larger
    in this sample (800 x 400). Alright, let's start implementing our tree sample
    created with E4X.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/3707OT_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by creating our XML object that contains our class tree (please
    note that this will only work on an up-to-date version of Firefox as at the time
    of this book being written):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Then create our standard helper and styling objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We will implement our `init` function and then call the `drawTree` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Time to implement the `drawTree` function (our recursive function):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Tah Dah! We just created our first tree.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information on how E4X works, I recommend checking out some online
    resources such as [http://goo.gl/jLWYd](http://goo.gl/jLWYd) and [http://goo.gl/dsHD4](http://goo.gl/dsHD4).
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a deeper look at how our recursive `drawTree` works. The basic idea
    of `createTree` is to create the current node in focus and to check if the node
    has children; if it does, to send them to the `drawTree` and have them recursively
    continue until all the children are created and done. One of the most critical
    things you need to worry about when creating a recursive function (a function
    that calls itself) is to make sure that it doesn't end up being endless, and as
    our scenario has a very defined end that is based on the XML structure, we are
    safe.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by creating the current node in focus, based on the point values that
    were sent over in our function''s parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Right after these lines is where it starts getting really interesting. If our
    node is complex, we are going to assume that it has children, as that''s our base
    rule in creating our XML object; and if so, it''s time for us to draw the children:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by drawing a visualizer bar to help us see what the children of the
    current element are, and create a few helper variables in the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating our outline helper lines, it''s time for us to loop through
    the children and send them to `drawTree` with their new positions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: That covers all the logic. At this stage, the logic will start all over again
    for each element, one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a perfect world our work with our tree would be done by now, but many a
    time in real-world scenarios we would encounter issues. If we play with our current
    tree enough, we will discover visual issues, such as if a child node has more
    than one child, its children will overlap the other tree branches. For example,
    if we update our `Loader` class to have two new children (two dummy classes just
    for the sake of our example):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: If you refresh your browser (currently only Firefox), you will see that our
    elements are overlapping as we didn't take into account the option of children
    that have children. If we review our code more deeply, we will see that in the
    current logic format there is no way to solve the problem as the creation of the
    children is happening separately. We will need to figure out a way to manage lines
    so that our elements will have a way to know that they are about to overlap.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, we will need to make our recursive function more complex,
    as it will need to keep track of its children''s x position so that it can offset
    whenever there is an overlap. Please review the modified code (changes marked
    in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Wow that looks complicated—it's because it is! So let's break the logic down.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is simple, but as for every simple idea, sometimes it's harder to visualize
    after it's implemented. The idea is that every time we create a new tree element,
    we will return `0` if it has no children, and if it has children, we will send
    back the next free position for future children. We added a fourth parameter to
    the function as well, and we sent that information each time we looped through
    children. That way each child is aware of where the last child left off. If an
    element's real position can't be worked out, we draw a redirect line as per the
    amount of the offset and update `startXPoint`. Take a deeper look at this (so
    far my favorite code in the cookbook), which was fun to figure out!
  prefs: []
  type: TYPE_NORMAL
