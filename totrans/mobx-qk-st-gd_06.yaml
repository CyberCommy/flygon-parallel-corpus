- en: Handling Real-World Use Cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applying the principles of MobX can seem daunting when you first start using
    it. To help you with this process, we are gong to tackle two non-trivial examples
    of using the MobX triad of *observables-actions-reactions*. We will cover the
    modeling of the observable state, and then identify the actions and the reactions
    that track the observables. Once you go through these examples, you should be
    able to make the mental shift in tackling state management with MobX.
  prefs: []
  type: TYPE_NORMAL
- en: 'The examples we will cover in this chapter include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Form validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Page routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be required to have JavaScript programming language. Finally, to use
    the Git repository of this book, the user needs to install Git.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Mobx-Quick-Start-Guide/tree/master/src/Chapter06](https://github.com/PacktPublishing/Mobx-Quick-Start-Guide/tree/master/src/Chapter06)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2LDliA9](http://bit.ly/2LDliA9)'
  prefs: []
  type: TYPE_NORMAL
- en: Form validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Filling up forms and validating fields is the classic use-case of the web. So,
    it's fitting we start here and see how MobX can help us simplify it. For our example,
    we will consider a User Enrollment form that takes in some standard inputs like
    first name, last name, email, and password.
  prefs: []
  type: TYPE_NORMAL
- en: 'The various states of enrollment are captured in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The interactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Looking at the preceding screenshot, we can see some standard interactions
    going on, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Entering inputs for various fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validation on those fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clicking the Enroll button to perform a network operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are few other interactions here that do not meet the eye immediately:'
  prefs: []
  type: TYPE_NORMAL
- en: Network-based validation for the email to ensure that we are not registering
    with an existing email address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing a progress indicator for the enroll operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many of these interactions will be modeled with actions and reactions in MobX.
    The state will, of course, be modeled with observables. Let's see how the O*bservables-Actions-Reactions*
    triad comes to life in this example.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling the observable state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The visual design for the example already hints at the core state that we need.
    This includes the `firstName`, `lastName`, `email`, and `password` fields. We
    can model these as *observable properties* of the `UserEnrollmentData` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we also need to track the async validation that will happen with
    email. We do that with the boolean `validating` property. Any errors that are
    found during the validation are tracked with `errors`. Finally, the `enrollmentStatus`
    tracks the network operation around enrollment. It is a string-enum that can have
    one of four values: `none`, `pending`, `completed`, or `failed`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that `errors` is marked with `@observable.ref`, as it only needs
    to track reference changes. This is because the validation output is an *opaque
    object*, which does not have anything observable besides a change in reference.
    Only when `errors` has a value do we know that there are validation errors.
  prefs: []
  type: TYPE_NORMAL
- en: Onto the actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The actions here are quite straightforward. We need one to *set the field value*
    based on user changes. The other is do *enrollment* when the Enroll button is
    clicked. These two can be seen in the following code.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a general practice, always start with a call to `configure({ enforceActions:
    ''strict'' })`. This ensures that your observables are only mutated inside an
    action, giving you all the benefits we discussed in [Chapter 5](part0083.html#2F4UM0-58c2559ca4304cecab9bc46f496bc070),
    *Derivations, Actions, and Reactions*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The use of `flow()` for the `enroll` action is deliberate. We are dealing with
    async operations internally, so the mutations that happen after the operation
    completes must be wrapped in `runInAction()` or an `action()`. Doing this manually
    can be cumbersome and also adds noise to the code.
  prefs: []
  type: TYPE_NORMAL
- en: With `flow()`, you get clean looking code by using a generator function with
    `yield` statements for the `promises`. In the preceding code, we have two `yield`
    points, one for `validateFields()` and the other for `enroll()`, both of which
    return `promises`. Notice that we have no wrapper code after these statements,
    making it easier to follow the logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'One other action that is implicit here is `validateFields()`. Validation is
    actually a side effect that is triggered any time the fields change, but can also
    be invoked directly as an action. Here, again, we use `flow()` to handle the mutations
    after running through the async validations:'
  prefs: []
  type: TYPE_NORMAL
- en: We are using the `validate.js` ([https://validatejs.org](https://validatejs.org))
    NPM package to handle the field validations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the  `flow()` can take in arguments (eg: `fields`) just like regular
    functions. Since the validation for email involves an async operation, we are
    tracking the entire validation as an async operation. We do this with the `validating`
    property. When the operation completes, we set it back to `false` in the `finally`
    block.
  prefs: []
  type: TYPE_NORMAL
- en: Completing the triad with reactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the fields are changed, we need to ensure that the values that have been
    entered are valid. Thus, validation is a side effect of entering values for the
    various fields. We know that MobX offers three ways in which you can handle this
    side effect, and they are `autorun()`, `reaction()`, and `when()`. Since validation
    is an effect that should be performed every time a field changes, `when()`, a
    one-time only effect, can be ruled out. That leaves us with `reaction()` and `autorun()`.
    Typically, a form will only validate when a field has actually changed. This means
    the effect needs to trigger only after a change.
  prefs: []
  type: TYPE_NORMAL
- en: 'That narrows down our choice to `reaction(<tracking-function>, <effect-function>)`,
    as that''s the only type of reaction that ensures the `effect` function triggers
    after the `tracking` function returns a different value. `autorun()`, on the other
    hand, executes immediately, which is too soon to perform validation. With that,
    we can now introduce the *validation* side effect in the `UserEnrollmentData`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: Technically, this could also be achieved with an `autorun()`, but will require
    an additional boolean flag to ensure the validation is not performed the first
    time. Either solution would work well in this situation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `tracking` function in the preceding `reaction()` picks up the fields to
    monitor. When any of them change, the `tracking` function produces a new value,
    which then triggers the validation. We have already seen the `validateFields()`
    method, which is also an action that uses `flow()`. The `reaction()` is set up
    in the constructor of `UserEnrollmentData`, so the monitoring starts immediately.
  prefs: []
  type: TYPE_NORMAL
- en: When `this.validateFields()` is called, it gives back a `promise`, which could
    be canceled prematurely using its `cancel()` method. If `validateFields()` gets
    called too frequently, a previous invocation of the method could still be in progress.
    In those cases, we could `cancel()` the previously returned promise to avoid unnecessary
    work.
  prefs: []
  type: TYPE_NORMAL
- en: We will leave it as a reader exercise to tackle this interesting use-case.
  prefs: []
  type: TYPE_NORMAL
- en: We also keep track of the `disposer` function returned by the `reaction()`,
    which we call inside `cleanup()`. This is required to clean up and avoid potential
    memory leaks when `UserEnrollmentData` is no longer needed. It is always good
    to have an exit point for reactions where its *disposer* gets called. In our case,
    we call `cleanup()` from the root React component, in its `componentWillUnmount()`
    hook. We will see that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Now, validation is not the only side effect of our example. The more grandiose
    side effect is the UI in the form of React components.
  prefs: []
  type: TYPE_NORMAL
- en: React components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The UI as we know is a side effect in MobX and is identified by the use of `observer()`
    decorators on the React components. These observers can read observables in the
    `render()` method, which sets up the tracking. Any time those observables change,
    MobX will re-render the component. This automatic behavior with minimal ceremony
    is very powerful and allows us to create granular components that react to fine-grained
    observable state.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we do have some granular observer components, namely the input
    fields, the enroll button, and the app component. They are marked by orange boxes
    in the following component tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Each field input is separated out into an observer component: **InputField**.
    The email field has its own component, **EmailInputField**, since its visual feedback
    also involves showing a progress bar during validation and disabling it while
    it checks if the entered email is registered already. Similarly, the **EnrollButton**
    also has a spinner to show the progress during the enroll operation.'
  prefs: []
  type: TYPE_NORMAL
- en: We are using **Material-UI** ([https://material-ui.com](https://material-ui.com))
    as the component library. This provides an excellent set of React components styled
    to the Material Design guidelines by Google.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `InputField` observes just the field that it is rendering, identified by
    the `field` prop, which is dereferenced from the `store` prop (using `store[field]`).
    This serves as the `value` for the `InputField`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: User edits (`onChange` event) to this input are notified back to the store with
    the `store.setField()` action. The `InputField` is a *controlled component* in
    the React parlance.
  prefs: []
  type: TYPE_NORMAL
- en: The key idea of the `InputField` component is about passing the observable (`store`)
    instead of the value (`store[field]`). This ensures the dereferencing of the observable
    property happens inside the `render()` of the component. This is important for
    a granular observer optimized for rendering and tracking just what it needs. You
    can think of it as a *design pattern* when creating MobX observer components.
  prefs: []
  type: TYPE_NORMAL
- en: The UserEnrollmentForm component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We use several of these `InputFields` in the `UserEnrollmentForm` component.
    Note that the `UserEnrollmentForm` component *is not an observer*. Its purpose
    is to get hold of the store via the `inject()` decorator and pass it down to some
    of its child *observer components*. The `inject()` here uses the *function-based*
    argument, which is more type-safe than the *string-based* argument of `inject(''store'')`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `store`, an instance of `UserEnrollmentData`, is passed down via the `Provider`
    component setup at the root of the component tree. This is created in the `constructor`
    for the root component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With the `Provider`, any component can now `inject()` the `store` and get access
    to the observable state. Notice the use of the `componentWillUnmount()` hook to
    invoke `this.store.cleanup()`. This internally disposes the validation reaction,
    as described in the earlier section (*"Completing the triad with reactions"*).
  prefs: []
  type: TYPE_NORMAL
- en: Other observer components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a few more granular observers in our component tree. One of the simplest
    ones is the `App` component, which provides a simple branching logic. If we are
    still in the process of enrolling, the `UserEnrollmentForm` is shown. Upon enrollment,
    the `App` shows the `EnrollmentComplete` component. The observable tracked here
    is `store.enrollmentStatus`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `EmailInputField` is fairly self-explanatory and reuses the `InputField`
    component. It also includes a progress bar to show the async validation operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, the last observer component is the `EnrollButton`, which observes
    the `enrollmentStatus` and fires the `enroll()` action on the `store`. While the
    enrollment is in progress, it also shows the circular spinner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The collection of these granular observers improves the efficiency of the UI
    by speeding up React's reconciliation process. As the changes are localized to
    a specific component, React only has to reconcile the virtual-DOM changes for
    that specific observer component. MobX encourages the use of such granular observers
    and sprinkling them throughout your component tree.
  prefs: []
  type: TYPE_NORMAL
- en: If you are looking for a library built specifically for form validation with
    MobX, look at *mobx-react-form* ([https://github.com/foxhound87/mobx-react-form](https://github.com/foxhound87/mobx-react-form)).
  prefs: []
  type: TYPE_NORMAL
- en: Page routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Single page apps** (**SPA**) have become commonplace in many of the web apps
    we see today. These apps are characterised by the use of logical, client-side
    routes within a single page. You can navigate to various parts (*routes*) of the
    application by modifying the URL without a full page load. This is handled by
    libraries such as `react-router-dom`, which works with the browser history to
    enable *URL* driven route changes.'
  prefs: []
  type: TYPE_NORMAL
- en: Route change or navigation can be treated as a *side effect* in the MobX world.
    There is some state change happening to the observables, which results in navigation
    happening in the SPA. In this example, we will build this observable state, which
    tracks the current page shown in the browser. Using a combination of `react-router-dom`
    and the `history` package, we will show how routing becomes a side effect of the
    change in observable state.
  prefs: []
  type: TYPE_NORMAL
- en: The Cart checkout workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at a use-case where we can see the route change (navigation) as
    a MobX-driven side effect. We will use the typical Cart checkout workflow as our
    example. As seen in the following screenshot, we start at the *home route*, which
    is the entry point of the workflow. From there, we go through the remaining steps:
    *viewing the cart*, *selecting a payment option*, *seeing the confirmation*, and
    then *tracking the order:*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We have deliberately kept the various steps visually simple. This allows us
    to focus more on the navigation aspect rather than the details of what happens
    within each step. However, there are certain elements that are *common across
    all of these steps* of the workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'As seen in the following screenshot, each step has a load operation that fetches
    details for that step. Once loaded, you can click on the button to go to the next
    step. Before the navigation happens, there is an async operation that is performed.
    After it completes, we navigate to the next step in the workflow. Since every
    step follows this template, we will model it as such in the next section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Modeling the observable state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The essence of this SPA is the checkout workflow that takes you step by step,
    where each step is a route. Since a route is driven by a URL, we need a way to
    monitor the URL and also have the ability to change it as we move between steps.
    The navigation between steps is a side effect of some change in the observable
    state. We will model this workflow with a `CheckoutWorkflow` class that contains
    the core observable state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen in the preceding code, we are representing each of the steps
    with a  `name` and a `stepClass`. The `name` is also how we identify the corresponding
    route for that step, stored in the singleton `routes` object. The ordered list
    of `steps` is stored as a static property of the `CheckoutWorkflow` class. We
    could have also loaded these steps from a separate JavaScript file (module), but
    for simplicity, we have kept it here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The core observable state is quite simple here: a `currentStep` property that
    stores the string name of the current step and a `step` property, an instance
    of the `stepClass`, stored as an `observable.ref` property. As we navigate between
    steps, these two properties change to reflect the current step. We will see how
    these properties are used in handling the route change.'
  prefs: []
  type: TYPE_NORMAL
- en: A route for a step, a step for a route
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may be wondering why we need two separate properties to track the current
    step. Yes, it may seem superfluous, but there is a reason for that. Since our
    workflow is going to be a set of url-routes, the change in route can also happen
    by using the back button of the browser or by directly typing a URL. One way to
    co-relate a route with a step is by using its *name*, which is exactly what we
    do with the `currentStep` property. Notice how the `name` of the step exactly
    matches the keys of the `routes` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a route changes externally, we rely on the browser history to notify us
    of the URL change. The `tracker` property, which is an instance of `HistoryTracker`
    (a custom class we will create), contains the logic to listen to *browser history*
    and track the current URL in the browser. It exposes an observable property that
    is tracked by the `CheckoutWorkflow`. We will look at its implementation a little
    later in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Each step in the `CheckoutWorkflow` is a subtype of a `WorkflowStep` class.
    The `WorkflowStep` captures the details of a step and its async operations. The
    workflow simply orchestrates the flow of steps and transitions between them upon
    completion of the async operation in each step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: For most of the steps, we are extending the `MockWorkflowStep` that stamps out
    a template `WorkflowStep` with some baked in defaults. This keeps the steps really
    simple, so we can focus on the routing between steps. Notice in the following
    snippet, where we are simply simulating a network delay for the `load` and `main`
    operations. The `delay()` function is just a simple helper that returns a `Promise`
    that resolves after the given millisecond interval.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see how the `getLoadOperation()` and `getMainOperation()` methods are
    used in the next section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The WorkflowStep
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `WorkflowStep` acts as a template for all the steps in the workflow. It
    contains some observable state to keep track of the two async operations it performs:
    *loading details* and *doing the main work*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`load()` and `perform()` are the two async operations that a `WorkflowStep`
    does. Their status is tracked with the `loadState` and `operationState` observables,
    respectively. Each of these operations calls a delegate method that is overridden
    by the subclass to provide the actual promise. `load()` calls `getLoadOperation()`
    and `perform()` calls `getMainOperation()`, each of which produces a promise.'
  prefs: []
  type: TYPE_NORMAL
- en: '`doAsync()` is a helper function that takes in a *promise function* and notifies
    the state using the passed-in callback (`setState`). Notice the use of `runInAction()`
    here to ensure all mutations happen inside an action.'
  prefs: []
  type: TYPE_NORMAL
- en: '`load()` and `perform()` use the `doAsync()` function to update the `loadState`
    and `operationState` observables appropriately:'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a different way of writing the `doAsync()` function. **Hint**: We
    have seen it in an earlier chapter. We''ll leave that as an exercise for the reader.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We can now see that the observable state is carried by the `CheckoutWorkflow`
    and the `WorkflowStep` instances. One thing that may not be clear is how the orchestration
    is performed by the `CheckoutWorkflow`. For that, we have to look at the actions
    and reactions.
  prefs: []
  type: TYPE_NORMAL
- en: Actions and reactions of the workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already seen that the `WorkflowStep` has two ***action*** methods, `load()`
    and `perform()`, that handle the async operations of the step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `load()` action is invoked by `CheckoutWorkflow` as it loads each step
    of the workflow. `perform()` is a user invoked action that happens when the user
    clicks the button exposed on the React component for the step. Once `perform()`
    completes, the `operationState` will change to `completed`. The `CheckoutWorkflow`
    tracks this and automatically loads the next step in sequence. In other words,
    the workflow progresses as a reaction (or side effect) to the change in `operationState`
    of the current step. Let''s see all of this in the following set of code snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The constructor of `CheckoutWorkflow` sets up the core side effects. The first
    thing we need to know is the current page served by the browser using `this.tracker.page`.
    Remember that we are co-relating the `currentStep` of the workflow with the current
    URL-based route using a shared name.
  prefs: []
  type: TYPE_NORMAL
- en: The first side effect is executed using `autorun()`, which as we know, runs
    immediately and then any time the tracked observables change. Inside the `autorun()`,
    we are loading the `currentStep` by first making sure it is a valid step. Since
    we are observing the `currentStep` inside the `autorun()`, we have to ensure that
    we are keeping `this.tracker.page` in sync. We do this after successfully loading
    the current step. Now, any time the `currentStep` changes, `tracker.page` is automatically
    brought in sync, which means that the URL and route update to reflect the current
    step. We will see a little later how the `tracker`, an instance of `HistoryTracker`,
    actually handles this internally.
  prefs: []
  type: TYPE_NORMAL
- en: The next side effect is the `reaction()` to the change in `tracker.page`. This
    is a counter-part to the previous side effect. Any time the `tracker.page` changes,
    we have to change the `currentStep` as well. After all, these two observables
    have to work in tandem. Because we are already tracking the `currentStep` with
    a separate side effect (the `autorun()`), the current `step` is loaded with the
    instance of the `WorkflowStep`.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing striking over here is that, when `currentStep` changes, `tracker.page`
    is updated. Also, when `tracker.page` changes, `currentStep` is updated. So, it
    may appear that there is an infinite loop here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: However, MobX will see that once the change is propagated in one direction,
    there is no update happening from the other side, as both are in sync. This means
    the two inter-dependent values quickly reach stability and there is no infinite
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: Loading a step
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `WorkflowStep` is where a step comes to life and the only one that can
    create an instance is the `CheckoutWorkflow`. After all, it is the owner of the
    entire workflow. It does this in the `loadStep()` action method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The interesting parts of the preceding code are outlined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We get the `stepClass` of the current step index by retrieving it from the list
    of steps. We create an instance of this `stepClass`, which is assigned to the
    observable `step` property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then trigger the `load()` of the `WorkflowStep`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Possibly the most interesting part is awaiting the change in `operationState`
    of the `step`. We know from earlier that the `operationState` tracks the status
    of the main async operation of the step. Once it becomes `completed`, we know
    it's time to move to the next step.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Notice the use of the `when()` with a promise. This gives us a nice way to
    demarcate code that needs to execute after the `when()` resolves. Also notice
    that we are keeping track of the promise in the `nextStepPromise` property. This
    is needed to ensure that we also `cancel` out the promise in case we move to a
    different step before the current step completes. It is worth pondering when this
    situation could arise. **Hint**: The flow of steps is not always linear. A step
    could be changed via a *route change* as well, such as by clicking the back button
    of the browser!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The HistoryTracker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last piece of the *observable state puzzle* is the `HistoryTracker`, a class
    dedicated to monitoring the browser's URL and history. It relies on the `history`
    NPM package ([https://github.com/ReactTraining/history](https://github.com/ReactTraining/history))
    to do most of the work. The *history* package also powers the `react-router-dom`
    library, which we will be using for our React components.
  prefs: []
  type: TYPE_NORMAL
- en: 'The core responsibility of `HistoryTracker` is to expose an observable called
    `page` that tracks the current URL (route) in the browser. It also does the reverse
    where it keeps the URL in sync with the current `page`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: With the `reaction()` set up in the constructor, a route change (URL change)
    is effectively a side effect of a change in the `page` observable. This is achieved
    by pushing a route (URL) onto the browser history.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other important aspect of `HistoryTracker`, as the name suggests, is tracking
    the browser history. This is done with the `startListening()` method, which can
    be invoked by the consumers of this class. The `CheckoutWorkflow` calls this in
    its constructor to set up the tracker. Note that `startListening()` is given a
    map of routes, with the `key` pointing to a URL path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: When the URL changes in the browser, the `page` observable is updated accordingly.
    This happens in the `identifyRoute()` method, which is called from the callback
    to `history.listen()`. We have decorated it with action since it *mutates* the
    `page` observable. Internally, MobX notifies all of the observers of `page`—for
    example, `CheckoutWorkflow`, which uses the `page` observable to update its `currentStep`.
    This keeps the whole routing in sync and ensures that the changes are bi-directional.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the bi-directional syncing of the `currentStep`,
    `page`, and the *url-route*. Note that the interactions with the `history` package
    are shown in *grey* arrows, while the dependencies between observables are shown
    in orange arrows. This difference in color is intentional and suggests that *url-based-routing*
    is effectively a side effect of change in the observable state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The React components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, modeling of the observable state is more interesting than
    the React UI components. On the React side, we have the top level component that
    sets up the `Provider` with the instance of `CheckoutWorkflow` as the `store`.
    The `Provider` comes from the `mobx-react` package and helps in injecting the
    `store` to any React component decorated with `inject()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `App` component simply sets up all the Routes using the `react-router-dom`
    package. The paths used in the `<Route />` components match the URLs we saw earlier
    on the `routes` object. Notice that the `history` from the `HistoryTracker` is
    used for the `Router`. This allows sharing of the browser history between *react-router*
    and *mobx*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned earlier, we have deliberately kept the individual steps of the
    workflow very simple. They all follow a fixed template, as described by the `WorkflowStep`.
    Its React counterpart is `TemplateStepComponent`, which renders the step and exposes
    the button for navigating to the next step.
  prefs: []
  type: TYPE_NORMAL
- en: The TemplateStepComponent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`TemplateStepComponent` gives the visual representation to the `WorkflowStep`.
    It renders the feedback when the step is loading and also when the main operation
    is being performed. Additionally, it shows the details of the step once it is
    loaded. These details are shown via the `renderDetails` prop, which accepts a
    React component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `Observer` component is something we have not seen before. This is a special
    component provided by the `mobx-react` package that simplifies the creation of
    granular observers. A typical MobX observer component will require you to create
    a separate component, decorate it with `observer()` and/or `inject()` it, and
    ensure that the proper observables are passed as props into that component. You
    can bypass all that ceremony by simply wrapping a section of the *virtual-dom*
    with `<Observer />`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It accepts a function as its only child, wherein you can read observables from
    the surrounding scope. MobX will automatically track the observables being used
    in the *function-as-child component*. A closer look at the `Observer` reveals
    these details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we are passing a function as the child to `<Observer
    />`. Within that function, we use the `step.loadState` observable. MobX automatically
    renders the *function-as-child* component when the `step.loadState` changes. Notice
    that we are not passing any props into the `Observer` or to the child component.
    It reads it directly from the props of the outer component. This is the advantage
    of using `Observer`. You can create anonymous observers without much effort.
  prefs: []
  type: TYPE_NORMAL
- en: A subtle point to note is that `TemplateStepComponent` is not an observer itself.
    It simply gets hold of the `store` with `inject()`, which is then used inside
    the `<Observer />` regions.
  prefs: []
  type: TYPE_NORMAL
- en: The ShowCart component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ShowCart` is the component that shows the list of items in the cart. Here,
    we are reusing the `TemplateStepComponent` and plugin details of the cart with
    the `renderDetails` prop. This can be seen in the following code. We are not showing
    the `CartItem` and `TotalItem` components for simplicity. They are pure presentation
    components that render a single cart item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: A state-based router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can now see how the routing between all the `WorkflowStep` instances is
    achieved purely via a state-based approach. All of the navigation logic lies inside
    the MobX store, which in this case is `CheckoutWorkflow`. By connecting the observables
    (`tracker.page`, `currentStep`, and `step`) via a set of reactions, we have created
    *side effects* that update the browser history as well as create instances of
    `WorkflowStep`, which are used by the `TemplateStepComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: Because we are sharing the browser history (via `HistoryTracker`) between `react-router-dom`
    and MobX, we can keep the observables in sync with the URL changes.
  prefs: []
  type: TYPE_NORMAL
- en: This state-based approach to routing helps in keeping a crisp mental model of
    the workflow. All of the logic of your feature stays inside the MobX Store, improving
    the readability. Writing *unit tests* for such a state-based solution is also
    straightforward. In fact, it is not surprising to have most of the unit tests
    in a MobX app to be centered around *stores* and *reactions*. Many of the React
    components become pure observers of the observables and can be treated as plain
    *presentation components*.
  prefs: []
  type: TYPE_NORMAL
- en: With MobX, you have the flexibility to focus squarely on the domain logic and
    ensure that there is appropriate *observable state* that can be rendered on the
    UI. By encapsulating all of the domain logic and state inside the stores, and
    all presentation in the React components, there is clear separation of concerns.
    This greatly improves the **developer experience** (**DX**) and helps you scale
    better over time. That is the true promise of MobX.
  prefs: []
  type: TYPE_NORMAL
- en: For a more feature-rich, state-based routing solution with MobX, look at` mobx-state-router` ([https://github.com/nareshbhatia/mobx-state-router](https://github.com/nareshbhatia/mobx-state-router)).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we applied a variety of techniques and concepts that we have
    learned over the last few chapters. Each of the two examples, f*orm validation*
    and p*age routing*, presented a unique set of approaches for modeling the observable
    state. We also saw how to create granular observer components to enable efficient
    rendering of the React components.
  prefs: []
  type: TYPE_NORMAL
- en: 'A practical application of MobX always starts with modeling the *observable
    state*. After all, that is the data that drives the UI. The next step is to identify
    the *actions* that mutate the observables. Finally, you need to call out the *side-effects*
    and see which observables these effects depend on. This is the side effect model
    that''s applied to real-world scenarios, manifesting in the form of the MobX triad:
    O*bservables-Actions-Reactions*.'
  prefs: []
  type: TYPE_NORMAL
- en: With all of the knowledge we have accumulated so far, we are now ready to go
    deeper into MobX, starting with [Chapter 7](part0124.html#3M85O0-58c2559ca4304cecab9bc46f496bc070), *Special
    API for Special Cases*.
  prefs: []
  type: TYPE_NORMAL
