- en: Switching Contexts - No DOM, Different Vanilla
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we turn our attention away from the browser, we'll move on to a context that
    most backend programmers will be familiar with. Node.js provides us with a familiar
    language, known as JavaScript, that can be used in a system context. While Node.js
    is known for being a language that servers can be written in, it can be used for
    most capabilities that other languages are known for. If we wanted to create a
    **command-line interface** (**CLI**) tool, for example, we have the ability to
    do that.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js also gives us a similar programming context that we have seen in the
    browser. We get an event loop that allows us to have asynchronous **input and
    output** (**I/O**). How this is achieved is through the libuv library. Later in
    this chapter, we will explain this library and how it helps to give us the common
    event loop that we are used to. First, we will look at getting Node.js up and
    running, along with writing some simple programs that we can run.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the DOM-less world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging and inspecting code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter requires the following technical requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: An editor or IDE such as VS Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter's code, which can be found at [https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter05](https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter05).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previous chapters have asked for a Node.js runtime. In this chapter, we will
    take a look at how we can get this installed on our system. If we head over to
    [https://Node.js.org/en/](https://nodejs.org/en/), we will be able to download
    either the **Long-Term Support** (**LTS**) version or the current version. For
    this book, it is recommended to get the current version as the module support
    is better.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Windows, all we need to do is download and run the executable. For OS X
    and Linux, this should also be simple. For Linux users especially, there may be
    a version in the repository manager for a specific distribution, but this version
    may be old or line up with the LTS version. Remember: we want to be running the
    latest version of Node.js.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have it installed, we should be able to invoke the `node` command from
    any command line (Linux users may have to invoke the `Node.js` command since some
    repositories already had a node package inside of their repository). Once invoked,
    we should be greeted with a **Read Evaluate Print Loop** (**REPL**) tool. This
    gives us the ability to test out some code before we actually write it into a
    file. Run the following fragments of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: From these examples, it should be obvious that we are working in a similar environment
    to the one we are used to in the browser. We have access to most of the data manipulation
    and functional concepts that we had in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the libraries/APIs that we do not have access to are ones that are specific
    to the browser, such as the DOM APIs. We also don't have access to any of the
    browser external resource access libraries, such as `Fetch` or `XMLHttpRequest`.
    We have lower-level versions of them that we will talk about later, but it should
    be noted that, in some ways, it isn't as simple as calling the fetch API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and play with the REPL system. If we want to come out of it, we just
    need to use *Ctrl* + *C* twice on Windows (Linux should be the same; for OS X,
    we need to use *command* + *C*). Now, to run a script, all we need to do is put
    some code in a JavaScript file and call **`node <filename>`**. This should run
    our script in immediate mode. This can be seen in the following `example.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To get access to the various built-in libraries that Node.js gives us, we can
    utilize two different methods. First, we can use the old `require` system. The
    following script shows this capability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is the current way of bringing in built-in/user-built modules. It was the
    style that the Node team decided on since there was no common way of bringing
    in modules. We had systems such as RequireJS or CommonJS, and Node.js decided
    on the CommonJS style of bringing in modules. However, as we have learned, there
    is also a standardized way of bringing modules into the browser. The same is true
    for the Node.js platform.
  prefs: []
  type: TYPE_NORMAL
- en: The module system is currently in its experimental phase, but if need be, use
    a system such as RollupJS to change the code into a system version that is universally
    recognized, such as the **Universal Module Dependency** (**UDM**) system.
  prefs: []
  type: TYPE_NORMAL
- en: 'This system should look very familiar. The following script shows the previous
    example but in the module import system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also need to have a `package.json` file that has `"type" : "module"`
    in its manifest.'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the package.json file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `package.json` file holds all of the information about the package we are
    trying to build. It even gives us the ability to tie it into our version control
    system, and we can even tie it into our build system. Let's go over this now.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, a `package.json` file should have the following fields filled out:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: This is the name of the package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`version`: This is the current version of our software package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type`: This should either be `module` or `commonjs`. This will allow us to
    distinguish between legacy systems and the new ECMAScript module system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`license`: This is how we want to license our module. Most of the time, just
    go ahead and put the MIT license. However, if we do want to lock it down more,
    we could always use the GPL or LGPL license.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`author`: This is an object with the `name`, `email`, and `url` fields. This
    gives attribution to the software and helps people to know who built it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main`: This is the main entry point of the module. This will allow others
    to use our module and require/import it. It will also let the system know where
    to look for our starting point of the module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are many additional fields that can be used, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`man`: This allows the `man` command to find the file that we wish to serve
    for our documentation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description`: This allows us to provide more information about our module
    and what it does. If the description is longer than two to three sentences, it
    is recommended to have an accompanying `README` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`repository`: This allows others to find the repository and contribute to it
    or submit bug reports/feature requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`config`: This is an object that can be used by the scripts that we define
    in the scripts section of our `package.json` file. Scripts will be discussed in
    more detail soon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dependencies`: This is a list of modules that our module depends on. This
    can range from modules that live in the public `npm` registry, private repositories,
    Git repositories, tarballs, and even local file paths for local development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`devDependencies`: This is a list of dependencies that are needed for the development
    of this package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`peerDependencies`: This is a list of dependencies that our package may need
    if someone utilizes a piece of the system. This allows our users to download the
    core system, and if they want to utilize other pieces, they can download the peer
    dependencies that these other subsystems need.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OS`: This is a list of OSes that we run on. This can also be the negative
    version of this, such as `!darwin`, meaning that this system will run on all OSes
    other than OS X.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`engines`: The versions of Node.js that we run on. We will want to use this
    when we utilize a feature (such as ECMAScript modules) that has been introduced
    in a recent version. We may also want to utilize this feature if we''re using
    modules that have been deprecated and want to lock the Node.js version to an older
    one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a few more fields that are located in the `package.json` file, but
    these are the most common ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'One specific section of the `package.json` file that we want to look at is
    the scripts section. If we go to the website of `npm`,about the scripts section,
    it states the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `scripts` property is a dictionary containing script commands that are run
    at various times in the life cycle of your package. The key is the life cycle
    event, and the value is the command to run at that point.
  prefs: []
  type: TYPE_NORMAL
- en: If we go to the more details section, we will see that there are life cycle
    hooks that we can use so that we have various scripts running through the bundling
    and distribution process.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that this information is specific to **Node Package Manager**
    (**npm**). While learning about Node.js, we will come across `npm` quite a bit,
    so learning about Node.js has also meant learning about `npm`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the specific points that we are interested in are the **prepare** and
    **install** sections of the packaging life cycle. Let''s see what these sections
    cover:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Prepare** will run the script before the package is packed into a tarball
    and published to the remote repository. It''s a great way to run compilers and
    bundlers to get our package ready for deployment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Install** will run the script after the package has been installed. This
    is great when we pull a package and want to run something such as `node-gyp` or
    something that our package may need that''s specific to the OS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another great thing about the `scripts` section is that we can put any arbitrary
    strings here and run `npm run <script>`. Whatever we decide to use as the value
    will be evaluated when we run the command. Let''s add the following to our `package.json`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us the ability to grab configuration data. On top of this, we
    have added a script that can be run with the `npm run example-script` command.
    If we create a `main.js` file and add the following fields to it, we should get
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows that we can put primitive values inside the configuration, but we
    can''t try to access something that is a complex object. We can do the following
    to get to the properties of the `testdata` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've gained some insight into the Node.js and `npm` ecosystems, let's
    take a look at how Node.js is put together and some of the key modules that we
    will be utilizing in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the DOM-less world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we stated in the introduction, Node.js came out of the idea that if we are
    writing code in the browser, then we should be able to run it on the server. Here,
    we have a single language for both contexts and we don't have to context switch
    when we work on either section.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js can function in this way with a mixture of two libraries. These libraries
    are V8, which we should already be familiar with, and libuv, which we aren't currently
    familiar with. The libuv library gives us asynchronous I/O. Every OS has a different
    way of handling this I/O, so libuv gives us a nice C wrapper around all of these
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: The libuv library queues up requests for I/O onto a stack of requests. Then,
    it farms them out to a certain amount of threads (Node.js utilizes four by default).
    Once the responses come back from these threads, libuv will put them on the response
    stack and alert V8 that the responses are ready to be consumed. Once V8 gets around
    to this alert, it will pull the value off and utilize it for its response to the
    request that we made. This is how the Node.js runtime is able to have asynchronous
    I/O and still maintain a single thread of execution (at least, that's how it looks
    to the user).
  prefs: []
  type: TYPE_NORMAL
- en: 'With this basic understanding, we should be able to start writing some basic
    scripts that handle various I/O operations and utilize one of the ideas that made
    Node.js special: the streaming system.'
  prefs: []
  type: TYPE_NORMAL
- en: A first look at streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we saw in the DOM, streams give us the ability to control the flow of data
    and be able to process data in a way that creates a nonblocking system. We can
    see this by creating a simple stream. Let''s go ahead and utilize one of the built-in
    streams that comes with Node.js, `readFileStream`. Let''s write the following
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have imported the `fs` library and the `PassThrough` stream from the
    `stream` library. Then, we created a read stream for the `example.txt` file, as
    well as a `PassThrough` stream.
  prefs: []
  type: TYPE_NORMAL
- en: A `PassThrough` stream allows us to process the data without having to explicitly
    create a stream ourselves. We read in the data and piped it to our `PassThrough`
    stream.
  prefs: []
  type: TYPE_NORMAL
- en: From here, we are able to get a handle to the data event, which gives us a chunk
    of data. On top of this, we have made sure to put our data event listener after
    the `pipe` method. By doing this, we have made sure that no `data` events run
    before we have attached our listener.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the following `example.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we run the `node --experimental-modules read_file_stream.js` command,
    we will see that it prints out a `Buffer`. All of the data processing is in binary
    chunks that are wrapped in `Buffer` objects unless we explicitly set it to something
    such as object mode. If we change the console log command to print out the following,
    we should get output in plain text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a program that counts the number of times the word `the` is used
    in the text. We can do this with our `PassThrough` stream, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We need to keep a count of the number of times we see the word `the`. We also
    are going to create a byte buffer of the `the` string. We will also need to keep
    track of our current position. By doing this, whenever we get data, we can run
    through it and test each byte. If the byte matches the current position that we
    are holding, then we need to do another check. If it equals our character byte
    count for the word `the`, then we update the number of `the` and reset our current
    position. Otherwise, we set our current position to the next index. If we don't
    get a match, we need to reset our current position; otherwise, we will get any
    combination of the characters *t*, *h*, and *e*.
  prefs: []
  type: TYPE_NORMAL
- en: This is an interesting example of how to utilize a `PassThrough` stream, but
    let's go ahead and create our own write `Transform` stream. We are going to apply
    the same operation that we did before, but we are going to build a custom stream.
    As stated in the documentation, we must write the `_transform` function and, optionally,
    implement the `_flush` function. We are going to implement both the `_transform`
    and `_flush` functions. We are also going to utilize the new class syntax instead
    of utilizing the old prototype-based system. One thing to keep in mind when building
    our own custom streams is to run the `super(options)` method before we do anything
    else in our stream. This will allow the user to pass various stream options that
    they have access to without us needing to do anything.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all of this in mind, we should get something that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: First, we import the `Transform` stream from the `stream` base library. We extend
    it and create a couple of private variables, that is, the current position in
    the `the` buffer and the current count of `the` in our stream. We also create
    a static variable for the buffer that we are comparing it to. Then, we have our
    constructor. This is where we pass the options to the `Transform` stream's constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we implement the `_transform` method in the same way that we implemented
    the `data` event on the `PassThrough` stream. The only new piece should be the
    call to the callback at the end. This lets our stream know that we are ready to
    process more data. If we need to error out, we can pass that as the first argument.
    We can also pass a second parameter, as shown in the `_flush` function. This allows
    us to pass the processed data to whoever may be listening. In our case, we only
    want to pass the number of `the` that we found in the text. We can also only pass
    a `Buffer`, `String`, or `Uint8Array`, so we decide to pass the string version
    of our number (we could have used a `Buffer` and this would have probably been
    the better choice). Finally, we export this from our module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside of our `read_file_stream` file, we will import this module with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can utilize it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: By doing this, we have wrapped all of that logic into a separate module and
    a reusable stream instead of just doing this in the `data` event of `PassThrough`.
    We also have the ability to chain our stream implementation to another stream
    (in this case, there would probably be no point unless we were going to pass it
    to a socket).
  prefs: []
  type: TYPE_NORMAL
- en: This was a short introduction to the stream interface and provided an overview
    of what we will be discussing at length in later chapters. Next, we will take
    a look at some modules that come with Node.js and how they can help us to write
    server applications.
  prefs: []
  type: TYPE_NORMAL
- en: A high-level look at modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three I/O modules that allow our applications to work with the filesystem
    and access the outside world. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`net`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These three modules will likely be the main modules that a user will utilize
    when developing Node.js applications. Let's take a look at each of them individually.
  prefs: []
  type: TYPE_NORMAL
- en: fs module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s create a basic example of accessing the filesystem and opening
    a file, adding some text to it, closing the file, and then appending some more
    text to it. This would look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: First, we are grabbing the promise-based version of the library. Most of the
    built-in modules have a promise-based version, which can lead to nice-looking
    code, especially compared to the callback system. Next, we write to a file and
    give it some text. The `writeFile` method allows us to write to a file and create
    the file if it doesn't exist. After this, we open up `FileHandle` for our file.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js took the POSIX style of I/O. This means that everything is treated like
    a file. In this case, everything is assigned a **file descriptor** (**fd**). This
    looks like a number to us in languages such as C++. After, we can pass this number
    to a variety of file functions that are available to us. Node.js, in the promises
    API, decided to switch to a `FileHandle` object, which is what we get instead
    of this file descriptor. It leads to cleaner code and a layer of abstraction over
    the system that is sometimes needed.
  prefs: []
  type: TYPE_NORMAL
- en: The `a` that we can see as the second argument states how we are going to use
    the file. In this case, we are going to append to the file. If we opened it with
    `r`, this means that we want to read from it, while if we opened it with `w`,
    this means that we want to overwrite whatever is already there.
  prefs: []
  type: TYPE_NORMAL
- en: Having an understanding of a Unix system can go a long way to understanding
    how Node.js works and how all of this corresponds to the programs that we are
    trying to write.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we append some text to the file and close it. Finally, we console log
    whatever is in the file and state that we want to read it in as UTF-8 text instead
    of in binary.
  prefs: []
  type: TYPE_NORMAL
- en: There are many more APIs associated with the filesystem, and it is recommended
    to go through the promise documentation to see what capabilities we have, but
    they all boil down to us having access to the filesystem and being able to read/write/append
    to various files and directories. Now, let's move on to the `net` module.
  prefs: []
  type: TYPE_NORMAL
- en: net module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `net` module gives us access to lower-level socket systems and even to
    local **InterProcess Communication** (**IPC**) schemes that we can use. IPC schemes
    are communication strategies that allow us to talk between processes. Processes
    don''t share memory, which means that we have to communicate through other means.
    In Node.js, this usually means three different strategies, and they all depend
    on how quickly and how tightly coupled we want the systems to be. These three
    strategies are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Unnamed pipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Named pipes/local domain sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TCP/UDP sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, we have unnamed pipes. These are one-way communication systems that
    are not seen on the filesystem and are shared between a `parent` and a `child`
    process. This means that a `parent` process would spawn a `child` process and
    `parent` would pass the *location* of one end of the pipe to `child`. By doing
    this, they would be able to communicate over this channel. An example of this
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `child` file will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We grab the fork method from the `child_process` module (this allows us to spawn
    new processes). Then, we fork a new `child` off of the `child` JavaScript file
    and are given a handler to that `child` process. As part of the fork process,
    Node.js automatically creates an unnamed pipe for us so that we can talk between
    the two processes. Then, we listen for events on the `child` process and do various
    things based on the message that we receive.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the `child` side, we can automatically listen for events from whoever spawned
    us and we can send messages through our process interface (this is global in each
    Node.js file that is started). As shown in the following code, we are able to
    talk between two separate processes. If we wanted to actually see this, we would
    have to add a timeout to our `parent` process so that it doesn''t send the `DISCONNECT`
    message for `15` seconds, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we bring up a task manager, we will see that two Node.js processes have
    been started. One of these is `parent` while the other one is `child`. We are
    talking over an unnamed pipe, so they are considered tightly coupled because they
    are the only ones that share it. This is great for systems that we want to have
    a `parent`/`child` relationship and do not expect to have either of them spawned
    in a different way.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of creating this tight link between the two processes, we can use something
    called a named pipe (these are known as Unix domain sockets on OS X and Linux).
    It works similarly to an unnamed pipe, but we are able to connect two unrelated
    processes. To achieve this type of connection, we can utilize the `net` module.
    It provides a low-level API that can be used to create, connect, and listen to
    these connections. We also get a low-level socket connection, so it behaves similarly
    to the `http(s)` modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start up a connection, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we import the `net`, `path`, and `os` modules. The `path` module helps
    to create and resolve filesystem paths without us having to write path expressions
    specifically for an OS. The `os` module, as we saw previously, can give us information
    about the OS that we are currently on. When we create the pipe name, Windows needs
    to be at `\\?\pipe\<something>`. On another OS, it can just be a regular path.
    Something else to note is that any other OS besides Windows will not clean the
    pipe after we have finished using it. This means that we will need to make sure
    we delete the file before we exit the program.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we create a pipe name based off of the platform. In any case, we
    make sure that it is in our current working directory (`process.cwd()`) and that
    it is called `temp`. From here, we can create a server and listen for connections
    on this file. When someone connects, we receive a `Socket` object. This is a full
    Duplex stream, which means that we can read and write from it. We are also able
    to pipe information to and from it. In our case, we want to log to the console
    that `socket` joined and then send a `DISCONNECT` message. Once we get the close
    event, we just log that `socket` closed down.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our client code, we should have something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This code is fairly similar, except we create a `Socket` object directly and
    try to connect to the same pipe name. Once we're connected, we log this. When
    we get data, we check whether it is equal to our `DISCONNECT` message, and if
    it is, we get rid of the socket.
  prefs: []
  type: TYPE_NORMAL
- en: What's nice about the IPC mechanism is that we can pass messages between different
    programs written in different languages. The only thing that they need to have
    in common is some form of common *language*. There are many systems out there
    that can do this. Although this isn't the focus of this book, note that if we
    needed to hook into another program, we could do this fairly easily with the `net`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: http module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final module we are going to take a high-level look at is the `http` module.
    This module allows us to create `http` servers with ease. The following is a simple
    example of an `http` server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If we head to `localhost:8000` in our browser, we should see the JSON object
    in our browser. If we wanted to get even fancier, we could send back some basic
    HTML, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Instead of setting our content type to `application/json`, we set it to `text/html`
    so that the browser knows how to interpret this request. Then, we end the response
    with our basic HTML. How would we be able to respond to the server if our HTML
    requests a CSS file?
  prefs: []
  type: TYPE_NORMAL
- en: 'We would need to interpret the request and be able to send some CSS. We could
    do this with something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We are able to pull various pieces of information from the request that we receive.
    In this case, all we care about is whether this was a `GET` request and that it
    is asking for the `main.css` resource. If it is, we return the CSS; otherwise,
    we just return our HTML. It should be noted that this code should look somewhat
    familiar to web server frameworks such as Express. Express adds a bunch of helper
    methods and ways to protect our server, but it should be noted that we can write
    simple servers with fewer dependencies and only by utilizing the modules that
    are internal to Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use the `http` module to fetch data from various resources. If
    we use the `get` method built into the `http` module or even the more generic
    request method, we can get resources from various other servers. The following
    code illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: First, we can see that we have to utilize the `https` module. Since this web
    page is located on a server that is utilizing **Secure Socket Layer** (**SSL**)
    certificates, we have to use the secure connection method. Then, we simply call
    the `get` method, passing in the URL that we want, and read the data from the
    response. If, for some reason, we do not get a 200 response (an okay message),
    we error out.
  prefs: []
  type: TYPE_NORMAL
- en: These three modules should showcase that we have quite a bit of power inside
    of the Node.js ecosystem and should spark some curiosity in how we can use Node.js,
    without any dependencies, to make useful systems. In the next section, we will
    take a look at how we can debug our Node.js code in a command-line debugger, along
    with the code inspection system that we are used to using with Chrome.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging and inspecting code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One area that new Node.js developers struggle with is debugging code. Instead
    of having the inspector, we have a system where the first crash will dump some
    information to our screen and instantly kick us to the command-line. This can
    be seen with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that we are trying to reassign a constant, so Node.js is going
    to throw an error similar to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: While this can be scary, it also shows us where the error is. The first line
    in this stack trace tells us it is at *line 3*, *character 7*.
  prefs: []
  type: TYPE_NORMAL
- en: A stack trace is a way for a system to provide the developer with information
    about which functions were calling what. In our case, `Object.<anonymous>` was
    called by `Module.__compile`, and so on. This can help when a good chunk of the
    stack is ours and the error actually occurs farther up.
  prefs: []
  type: TYPE_NORMAL
- en: With this information, we know how to correct the issue, but what do we do if
    we want to break on a specific statement or a specific line? This is where the
    inspector system comes into play. Here, we can utilize statements that are similar
    to the ones we saw in the web version of our code. If we insert a debug statement
    in the middle of our code, our command line will stop at that point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create some rudimentary code to showcase this. The following code should
    give us plenty to showcase the use of the inspector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This code will allow us to play around with various parts of the inspector.
    If we run the `npm inspect bad_code.js` command, we should break on the call to
    `fun`. We are greeted with a Terminal interface that states we are in debug mode.
    Now that we have stopped execution here, we can set up a watcher. This allows
    us to capture various variables and expressions and see what their results are
    on the next break. Here, we set up a watcher on the `x` variable by executing
    `watch('x')` in the debugger. From here, if we type `next`, we will move to the
    next line. If we do this a couple of times, we will notice that once we pass the
    assignment of our variable, the watcher will change the `x` variable from undefined
    to 10.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be especially helpful when we need to debug a stateful system that
    is sharing state among quite a few objects. It can also be helpful when we are
    trying to see what we have access to. Let''s set up a few more watchers so that
    we can see what their values are when our next debug statement is hit. Set up
    watchers on the following variables: `item`, `tempObj`, and `alternative`. Now,
    type `cont`. This will move us to our next debugger statement. Let''s see what''s
    printed out by our watchers. When we move to the next point, we will see that
    `tempObj` and `x` are not defined, but that we have access to `item` and `alternative`.'
  prefs: []
  type: TYPE_NORMAL
- en: This is what we expect, seeing how we are scoped inside the outer `fun` function.
    There's much more we can do with this version of the inspector, but we can also
    hook up to the inspector that we are used to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we use the following command to run our code, we will be able to attach
    the debug tools to our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: With this, we will get an address that we can connect to. Let's do just that.
    We will also need to have some long-running code; otherwise, the script will exit
    and we will have nothing to listen to. Let's move back to the `named_pipe.js`
    example. Run `node --inspect -–experimental-modules named_pipe.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should get something that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If we head to the following address in our Chrome browser, we should be greeted
    with a familiar sight:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have the full power of the inspector from Chrome for our Node.js code.
    Here, we can see that if we connect to our named pipe server with our `named_pipe_child.js`
    file, we will be greeted with the console logs in the debugger. Now, if we add
    debugger statements, we should get breakpoints inside of the inspector. If we
    add a debug statement right when a socket connects to us, when we connect with
    our child socket, we will be able to run through our code the same way we can
    in the browser! This is a great way to debug and step through our code.
  prefs: []
  type: TYPE_NORMAL
- en: We are also able to memory profile. If we head to the Memory tab and create
    a heap snapshot, we will get a nice dump of our memory. It should look quite familiar
    to what we have seen already.
  prefs: []
  type: TYPE_NORMAL
- en: With all of this under our belt, we can move onto more complex topics surrounding
    Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the advent of Node.js, we are able to have a programming language that
    we can utilize on both the client and server. While the APIs that are given to
    us in Node.js may not look familiar, we can create powerful server applications
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we covered the basics of streaming and some of the APIs that
    allow us to create these powerful server applications. We also took a look at
    the tools that allow us to debug with and without a GUI.
  prefs: []
  type: TYPE_NORMAL
- en: With all of this under our belt, in the next chapter, we will take a deeper
    dive into the mechanisms we can use to pass data between threads and processes.
  prefs: []
  type: TYPE_NORMAL
