- en: Basic Particle System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *particle syste**m* is a graphics technique where we emit a large number of
    sprites from an *emitter* and have those sprites go through a life cycle where
    they change in a variety of ways. We build some randomness into our sprite life
    cycle to create a wide range of interesting effects such as explosions, sparks,
    snow, dust, fire, engine exhaust, and so on. Some particle effects can interact
    with their environment. In our game, we are going to use particle effects to create
    nice-looking engine exhaust and ship explosion effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this chapter, you will need to include several images in your build to
    make this project work. Make sure you include the `/Chapter08/sprites/` folder
    from the project''s GitHub. If you haven''t yet downloaded the GitHub project,
    you can get it online here: [https://github.com/PacktPublishing/Hands-On-Game-Develop](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly).'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter and the beginning of the next one are going to feel like a digression
    at first. We will be spending a lot of time in the following two chapters working
    on something other than our game. If you are interested in particle systems, I
    promise it will be worth it. When you create a particle system, you spend a lot
    of time tweaking them and playing with them to get them to look right. To do this
    directly within the game will result in a lot of compiling and testing. What we
    need is a tool where we can configure and test a particle system before we add
    it to our game. This chapter and half of the next chapter are dedicated to building
    this tool. If you are not interested in learning how to build the tool, you can
    skim the text in this chapter, and download and compile the tool from GitHub.
    If you are as interested in learning how JavaScript, HTML, and WebAssembly can
    interact in an application, this chapter and the first half of [Chapter 9](b602b8b6-5bec-435f-8b9e-1ad4e4a5f18a.xhtml),
    *Improved Particle Systems*, are a good tutorial for learning how to write an
    application and not just a game with WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: A brief introduction to SVG
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trigonometry again?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The simple particle emitter tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Point class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Particle Class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Emitter Class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebAssembly interface functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling and testing the particle emitter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding to the virtual file system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is going to be a brief digression from *particle systems* because
    I would like to take the time to create a *particle system design tool*, which
    will require that we add files to the WebAssembly virtual file system. We are
    going to add an input element with a type of file that we can use to load an image
    into the virtual file system. We will need to check the file we are loading to
    verify it is a `.png` file, and if it is, we will draw and move the image around
    on the canvas using WebAssembly and SDL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Emscripten does not create a virtual file system by default. Because we will
    need to use a virtual file system that will not initially have anything inside
    of it, we will need to pass the following flag to em++ to force Emscripten to
    build a virtual filesystem: `-s FORCE_FILESYSTEM=1`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we will do is copy `canvas_shell.html` from [Chapter 2](0c9c09be-1e03-4074-9718-7bc3bf9e70e2.xhtml),
    *HTML5 and WebAssembly*, and use it to create a new shell file we will call `upload_shell.html`.
    We will need to add some code into the JavaScript that will handle file loads
    and insert that file into the WebAssembly virtual file system. We also need to
    add an HTML `input` element of `file` type that will not display until the `Module`
    object has finished loading. In the following code, we have the new shell file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the header, the only changes we are making are to the title, and the style
    sheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `body` tag, we are leaving the `canvas` and `textarea` elements alone,
    but there are significant changes to the JavaScript. The first thing we will do
    to the JavaScript is to add a `ShowFileInput` function to display the `file_input_label`
    element, which starts as hidden by our CSS. You can see it in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we have added a call to this function in our `postRun` array so
    that it runs after the module is loaded. That is to make sure no one loads an
    image file before the `Module` object has loaded and our page can handle it. Aside
    from the addition of `ShowFileInput` to the `postRun` array, the `Module` object
    is unchanged. After our `Module` object code, we added a `handleFiles` function
    that is called by our file input element when the user picks a new file to load.
    Here is the code for that function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that the function is designed to handle multiple files at once
    by looping over the `files` parameter passed into `handleFiles`. The first thing
    we will do is check to see if the image file type is PNG. When we compile the
    WebAssembly, we need to tell it what image file types SDL will handle. The PNG
    format should be all you need, but it is not difficult to add other types here.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do not want to check for PNG files specifically, you can leave out the
    `.png` part of the match string and later add additional file types into the compile
    command-line parameters. If the file is an `image/png` type, we put the filename
    into its variable, `file_name`, and create a `FileReader` object. We then define
    the function that runs when the `FileReader` loads the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This function takes in the data as an 8-bit unsigned integer array and then
    passes it into the `Module` function, `FS_createDataFile`. This function takes
    as its parameters a string that is the parent directory `''/''` of our file, the
    filename, `file_name`, the data we read from our file, followed by `canRead`,
    `canWrite`, and `canOwn`, which should all be set to `true` because we would like
    to be able to have our WebAssembly read, write, and own this file. We then use
    `Module.ccall` to call a function defined in our WebAssembly called `add_image`
    that will take the filename so that our WebAssembly can render this image to the
    HTML canvas using SDL. After we define the function that tells the `FileReader`
    what to do when a file is loaded, we have to instruct the `FileReader` to go ahead
    and read in the loaded file as an `ArrayBuffer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After the JavaScript, we added a file `input` element and a label to go along
    with it, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The label is purely for styling. Styling an input file element is not a straightforward
    thing in CSS. We will go over how to do that in a little bit. Before discussing
    the CSS, I would like to go over the WebAssembly C code that we will use to load
    and render this image using SDL. The following code will go inside of a file we
    have named `upload.c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: There are three functions we have defined inside of our new `upload.c` file.
    The first function is the `add_image` function. This function takes in a `char*`
    string that represents the file we have just loaded into the WebAssembly virtual
    file system. We use SDL to load the image into a surface, and then we use that
    surface to create a texture we will use to render the image we loaded. The second
    function is `show_animation`, which we use to move the image around the canvas.
    The third is the `main` function, which always gets run when the module is loaded,
    so we use it to initialize our SDL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a quick look at the `add_image` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we do in the `add_image` function is use the `file_name` parameter
    we passed in to load an image into an `SDL_Surface` object pointer, using the
    `IMG_Load` function that is a part of the `SDL_image` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If the load fails, we print an error message and return from the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If it does not fail, we use the surface to create a texture that we will be
    able to render in the frame animation. Then, we free the surface because we no
    longer need it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The final thing we do is use the `SDL_QueryTexture` function to get the image''s
    width and height, and load those values into the `dest` rectangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `show_animation` function is similar to other game loops we have written
    in the past. It should run every frame, and as long as a sprite texture is loaded,
    it should clear the canvas, increment the sprite''s `x` and `y` values, and then
    render the sprite to the canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we do in `show_animation` is to check if the `sprite_texture`
    is still `NULL`. If it is, the user has not loaded a PNG file yet so we can not
    render anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing we will do is clear the canvas with the color black:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will increment the sprite''s `x` and `y` coordinates and use those
    values to set the `dest` (destination) rectangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we render the sprite to the back buffer, and then move the back buffer
    to the canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The final function in `upload.c` is the `main` function, which gets called
    when the module is loaded. This function is used for initialization purposes and
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'It calls a few SDL functions to initialize our SDL renderer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, it sets up the `show_animation` function to run every time we render
    a frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The final thing we will do is set up a CSS file to display the HTML in our
    shell file correctly. Here are the contents of the new `upload.css` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The first few classes, `body`, `#output`, and `#canvas`, are not much different
    from the version of those classes we had in previous CSS files, so we do not need
    to go into any detail on those. After those classes is a CSS class that looks
    a little different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'That defines the look of an `input` element that has a type of `file`. For
    some reason, using CSS to style a file input element is not very straightforward.
    Instead of styling the element directly, we will hide the element with the `display:
    none;` attribute and then create a styled label, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'That is why, in the HTML, we have a label element immediately after our input
    file element. You may notice that our label also has set the `display` to `none`.
    That is so that the user can not use the element to upload a PNG file until after
    the `Module` object is loaded. If you look back to the JavaScript inside of our
    HTML shell file, we called the following code on `postRun` so that the label becomes
    visible after our `Module` is loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now, we should have an app that can load an image into the WebAssembly virtual
    file system. In the next several sections, we will expand this app to configure
    and test a simple particle emitter.
  prefs: []
  type: TYPE_NORMAL
- en: A brief introduction to SVG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SVG stands for *Scalable Vector Graphics* and is an alternative to the immediate-mode
    raster graphics rendering that takes place in the HTML canvas. SVG is an XML-based
    graphics rendering language and should look at least somewhat familiar to anyone
    familiar with HTML. An SVG tag can be placed right inside of the HTML and accessed
    like any other DOM node. Because we are writing a tool for configuring particle
    emitter data, we will be adding SVG into our app for data visualization purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Vector versus raster graphics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a game developer, you may not be familiar with *vector graphics*. When we
    render computer graphics, no matter what format we use, they will need to be *rasterized*
    into a grid of pixels before the game displays them on a computer screen. Working
    with raster graphics is working with our images on the pixel level. Vector graphics,
    on the other hand, involves dealing with graphics at a different level of abstraction
    where we are working with lines, points, and curves. In the end, a vector-based
    graphics engine still must figure out how the lines, points, and curves it is
    dealing with are converted to pixels, but working with vector graphics is not
    without its benefits. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Vector graphics can be cleanly scaled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vector graphics allow for smaller downloads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vector graphics can easily be modified at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the sweet spots for using vector graphics on the web is for *data visualization*.
    This book is not about SVG or data visualization, and SVG is not currently fast
    enough to be used for game rendering for most applications. It is, however, a
    useful tool when you want to render graphical aids to go along with data on a
    website. We will be adding a little SVG into our particle emitter configuration
    tool as a visual aid to help the user see the direction the emitter is configured
    to emit particles. Because we are using this as a visual aid, it is not strictly
    necessary to have it inside of our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we will do is add a few tags to our HTML. We need an SVG tag
    to set up an area we can use to draw our vector circle graphic. We also need a
    couple of input values that allow us to enter two angles with values in degrees.
    These two input fields will take the minimum and maximum angles to emit a particle.
    When we have this working, it will give some direction to our particle emission.
    Here is the HTML code we need to add to our `body` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We have set the `id` to pie in the `svg` tag. That will allow us to modify the
    values inside of this tag with lines and arcs later. We have given it a height
    and width of `200` pixels.
  prefs: []
  type: TYPE_NORMAL
- en: The `viewbox` is set to `-1 -1 2 2`. This says that the top-left coordinate
    of our SVG drawing area is set to coordinate `-1, -1`. The second two numbers,
    `2 2`, are the width and height in the drawing space of the SVG drawing area.
    That means that our drawing space will go from coordinates `-1, -1` in the top-left
    corner to `1, 1` in the bottom right. That will make it easy to deal with sine
    and cosine values when we need to calculate our angles.
  prefs: []
  type: TYPE_NORMAL
- en: Trigonometry again?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OMG yes, there is more *trigonometry*. I have already covered basic trigonometry
    in, [Chapter 7](71d18599-d302-4d52-9e7c-343a94835b27.xhtml), *Collision Detection*,
    but believe it or not, trigonometry is really useful in game development. Trigonometry
    happens to be very useful for particle systems and we will be using SVG and some
    trig to build a little pie chart we can use to visualize the direction of our
    particle emitter. So, let''s take a second to quickly review things one more time:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Sine = Opposite/Hypotenuse (SOH)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Cosine = Adjacent/Hypotenuse (CAH)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Tangent = Opposite/Adjacent (TOA)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember the word SOHCAHTOA?
  prefs: []
  type: TYPE_NORMAL
- en: 'If we are using a 2D Cartesian coordinate system (spoiler alert, we are) the
    *opposite* edge in our scenario is just the *Y* coordinate, and the *adjacent*
    edge is the *X* coordinate. So, in terms of a 2D Cartesian coordinate system,
    our ratios look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Sine = Y/Circle Radius*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Cosine = X/Circle Radius*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Tangent = Y/X*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you are calling a function in the JavaScript math library such as `cos`
    (for cosine) or `sin` (for sine), you usually pass in an angle measured in radians.
    You would get back the ratio, which if you are dealing with a *unit circle* (circle
    with a radius of 1), gives you the *X* value for cosine and the *Y* value for
    sine. So most of the time, all you need to remember is this:'
  prefs: []
  type: TYPE_NORMAL
- en: If you want the *Y* coordinate, use sine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want the *X* coordinate, use cosine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We used this earlier to figure out the direction and velocity of our ship. We
    will use it later to get the direction and velocity of our particles given an
    angle. And, we are going to use it right now to figure out how to draw the SVG
    chart that shows us at what angle we will emit our particles.
  prefs: []
  type: TYPE_NORMAL
- en: We are taking in two different angles to get a range of angles to emit particles.
    Because we want our angles to overlap the angle 0 degrees, we have to allow the
    `min_angle` to go negative. Our minimum angle can go from -90 degrees to 359 degrees,
    and the max angle can go from 0 degrees to 360 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: I prefer to measure angles in degrees instead of radians. Math functions typically
    use radians, so if you are more comfortable in using radians in your interface,
    you can save yourself the trouble of running the conversion. Radians is a measurement
    of angle based on a *unit circle*. A *unit circle* has a circumference of *2π*.
    If you measure an angle in radians, you are determining your angle based on how
    far around the *unit circle* you would have to walk to get to that point. So,
    if you walked from one side of your *unit circle* to the opposite side, you would
    have to walk a distance of π. Therefore *π* (in radians) = 180 degrees. If you
    wanted an angle one-quarter of the circle, you would have to walk a distance of
    *π / 2* around your circle, so *π / 2 = 90 degrees*. I still find a 360-degree
    circle more intuitive because we spent a lot more time learning about degrees
    when I was in school. Radians were mentioned as an afterthought. If this had not
    been the case, I am sure I would find measuring my angle in terms of a *unit circle*
    to make a lot more sense.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of a 360-degree circle is only intuitive because they drilled it into
    us when we were in school. The only reason we have this model of a circle is that
    we inherited it from the ancient Babylonians who used a base 60 mathematical system,
    which is also the reason we have 60 seconds in a minute and 60 minutes in an hour.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later, we will be using SVG and some trig to draw a little pie chart that represents
    the direction particles will be emitted from our particle system. We need this
    directionality to create our engine exhaust particle emitter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/47c00130-a4f0-451c-847c-bf530e50b17b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: Our SVG pie chart'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will be implementing our SVG pie chart using JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have discussed a little of the trigonometry necessary to draw our
    SVG chart, let me step through the JavaScript we need to add to make our code
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Even though it is the last function in this code, I would like to begin by explaining
    the `SetPie` function, which is used to set the SVG pie chart that shows the emission
    angle range in red that the user has entered. Way back when we set up the SVG
    tag, we set the `viewport` to go from `x` and `y` values of `-1` to `1`. That
    is great, because using `Math.cos` and `Math.sin` will give us the values of the
    *X* and *Y* coordinates for the *unit circle*, which has a radius of `1` and so
    those values will also run from `-1` to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use `document.getElementById(''pie'')` to grab the `svg` element from the
    DOM so we can modify it based on a change to the angle values. Next, we get the
    `x` and `y` coordinates on a unit circle with the `Math.cos` and `Math.sin` functions,
    respectively. We then do the same thing to get the ending `x` and `y` coordinates
    using the `end_angle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'What we need to do in SVG is draw two paths. The first path will be drawn in
    red and will represent the angle where the particle system emitter will emit particles.
    The second path will be drawn in blue and will represent the part of our emission
    circle where we will not emit particles. When we draw an SVG arc, we give the
    arc two points and tell it with a flag if we need to take the long way (obtuse
    angle) or the short way (acute angle) around the circle. We do this by checking
    to see if the emission angle is less than π and set a flag that will go into our
    SVG based on this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to define the path data and put it into the SVG path object. The
    following code sets the path data for the portion of our emitter in which we emit
    our particles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'A series of commands define path data in SVG. If you look at the definition
    of `path_data_1`, it begins with `M 0 0`, which tells SVG to move the cursor to
    position `0, 0` without drawing. The next command is `L ${start_x} ${start_y}`.
    Because we are using a string template literal, `${start_x}` and `${start_y}`
    are replaced with the values in the `start_x` and `start_y` variables. This command
    draws a line from the current location we have moved to in the previous step `(0,0)`
    to the coordinates `start_x` and `start_y`. The next command in our path is the
    `Arc` command and begins with `A`: `A 1 1 0 ${arc_flag_1} 1 ${end_x} ${end_y}`.'
  prefs: []
  type: TYPE_NORMAL
- en: The first two parameters, `1 1`, are the `x` and `y` radius of an ellipse. Because
    we want a unit circle, both of these values are `1`. The `0` that follows is an
    *X*-axis rotation that SVG uses when drawing an ellipse. Because we are drawing
    a circle, we set this to `0`. The value after that is `${arc_flag_1}`. That is
    used to set the *large arc flag*, which tells SVG if we are drawing the obtuse
    arc (we set the value to 1) or the acute arc (we set the value to 0). The value
    after this is the *sweep flag*. This flag determines if we are drawing in the
    clockwise (value is 1) or counter-clockwise (value is 0) direction. We always
    want to draw in the clockwise direction, so this value is going to be 1\. The
    last two parameters in our *arc* command are `${end_x} ${end_y}`. These values
    are the end position of our arc, which we had determined earlier by getting the
    cosine and sine of our ending angle. After we have completed our arc, we finish
    our shape by drawing a line back to the `0,0` coordinate using the `L 0 0` line
    command.
  prefs: []
  type: TYPE_NORMAL
- en: After we have drawn the emission angle in red, we cover the remainder of the
    circle in blue with a second path by drawing from the ending position to the starting
    position.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to build a simple particle emitter configuration
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: The simple particle emitter tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have created a simple web app that can upload a PNG image file
    to the WebAssembly *virtual file system*, and an SVG chart to display the emission
    direction of the particles, we are going to add a simple particle system configuration
    tool. For this first version of our particle system configuration tool, we are
    going to keep the number of configurable values small. Later, we will add more
    features to our particle system tool, but for the moment this is the list of parameters
    we will be able to use to configure a particle emitter:'
  prefs: []
  type: TYPE_NORMAL
- en: Image file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimum emission angle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maximum emission angle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maximum particles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Particle lifetime in milliseconds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Particle acceleration (or deceleration)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alpha fade (will the particles fade out over time?)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emission rate (number of particles to emit per second)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: X position (emitter x coordinate)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Y position (emitter y coordinate)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Radius (how far from the emitter's position can we create a particle?)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimum starting velocity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maximum starting velocity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That will let us create a very basic particle emitter. We will improve this
    emitter in the next section, but we need to start somewhere. I do not plan on
    discussing any of the CSS we have added to enhance the look of this tool. The
    first thing I want to do is cover the HTML that will go into the new shell file,
    which we are calling `basic_particle_shell.html`. We need to add some HTML `input`
    fields to take in all of the configurable values we discussed previously. We will
    also need a button to update the emitter once we have written in our changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code into the `<body>` tag in our new shell file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The CSS file styles this container to appear on the left side of the web page.
    The user can load an image into the virtual file system as they could previously,
    but this time all of the values in these input fields are used to create a particle
    emitter. The user can modify these settings and click the Update Emitter button
    to update the values used by the emitter. That will allow the user to test some
    basic emitter settings.
  prefs: []
  type: TYPE_NORMAL
- en: The code inside of the main function will need to be added to prevent the SDL
    Event handler from intercepting the keyboard events and preventing the default
    behavior inside of these input elements. We will cover that code a little later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that I have shown you the HTML elements that must be added to allow us
    to configure a particle system, let''s step through the JavaScript code that will
    enable us to pass these values into the WebAssembly module. Here is what that
    JavaScript code looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the `Module` code is unmodified, but we have added several functions
    and some new variables. We have added a global `ready` variable that is set to
    `false` when initialized. This flag will be set to `true` when the `Module` is
    loaded. As it was in the previous section, `ShowFileInput` runs after the `Module`
    is loaded using the `postRun` array. We have tweaked this code to set the `ready`
    flag that we mentioned earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In an earlier section, we created a `handleFiles` function that loaded a file
    into our WebAssembly virtual file system. We now need to modify that function
    to call a function, `add_emitter`, that we will need to define inside of our C++
    code. We will call this function, passing in all of the values we have defined
    in the HTML input elements. Here is what that function looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FileReader` code, and the call to `Module.FS_createDataFile` from the
    previous iteration of this function, is still here. In addition to that, we use
    `document.getElementById` to grab the HTML elements and store the value of those
    elements into a set of variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Many of these values need to be explicitly coerced into numbers using the `Number`
    coercion function. The `alpha_fade` variable must be coerced into a `Boolean`
    value. Now that we have all of these values inside of variables, we can use `Module.ccall`
    to call the C++ function, `add_emitter`, passing in all of these values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'At the very end of this, we set the `image_added` flag to `true`. We will not
    allow the user to update an emitter unless a call to `add_emitter` has created
    it. We have also added a new function, `UpdateClick`, that we will call whenever
    someone clicks the Update Emitter button, assuming that they have already created
    an emitter. Here is what the code in that function looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we do is make sure that the `Module` object is loaded, and
    that we created the emitter. If either of these has not happened, we do not want
    to run this code, so we must return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The remainder of this code is similar to the code we added to `handleFiles`.
    First, we grab all of the HTML elements and coerce the values in them into the
    appropriate data types to pass into our call to the C++ function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'After getting all of the values from the input elements, we use those values
    to call the `update_emitter` C++ function, passing in those values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will be implementing a `Point` class to track game object
    positions.
  prefs: []
  type: TYPE_NORMAL
- en: The Point class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In previous chapters, we have dealt with the 2D *X* and *Y* coordinates directly
    in our classes. I want to add a little bit of functionality that deals with our
    *X* and *Y* coordinates. For this, we are going to need to define a new class
    called `Point`. Eventually, `Point` will do more than what we are using it for
    here. But for right now, I would like to be able to create a `Point` object and
    be able to `Rotate` that point by an angle. Here is the class definition for `Point`
    that we have added to the `game.hpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The first several functions and the `operator=` are pretty straightforward.
    They set the x and y attributes either through a constructor or by using a line
    of code such as `point_1 = point_2;`. The last function, `Rotate`, is the entire
    reason we created this class. Its job is to take the *X* and *Y* coordinates and
    rotate them around the point `0,0`. Here is the code that gets that done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This `Rotate` function will eventually be used all over the game. For right
    now, we will use it to define the velocities of our particles based on the emission
    angles.
  prefs: []
  type: TYPE_NORMAL
- en: The Particle class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Particle` class is the class we will use to represent the individual particles
    that are emitted by our particle system. The `Particles` class will need to be
    created with a constructor and later updated with an `Update` function used to
    modify the defining attributes of the particle. There will be a `Spawn` function
    used to activate the `Particle`, a `Move` function to move the particle through
    its life cycle eventually deactivating it, and a `Render` function that will perform
    the SDL rendering tasks required to draw the particle to the canvas. Here is what
    the `Particle` class looks like in our `game.hpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We will define the functions associated with the `Particle` class inside of
    the `particle.cpp` file. At the top of this file, we have defined a constructor
    and an `Update` function. We call the `Update` function whenever the user clicks
    the Update Emitter button on the web page. That will update all of the particles
    to use the new values for their lifetime, acceleration, and alpha fade. Here is
    what the code to these first two functions looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Spawn` function is called by the `Emitter` whenever it needs to emit a
    particle. The `Emitter` checks that the particle it is emitting has an active
    flag set to `false`. The values passed into `Spawn`, such as the *X* and *Y* coordinates,
    the velocity `x` and `y` values, and the starting alpha value, are all calculated
    by the `Emitter` when it emits a new particle. Here is what the code looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Move` function of every active particle is called once per frame by the
    emitter, and is where the particle calculates its new position, alpha, and determines
    if it is still active based on how long it has been alive. Here is what the code
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `Render` function makes calls to the SDL functions that set the
    alpha value for the particle and then copies that particle to the renderer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will discuss the `Emitter` class and the code we will
    need to make that class work.
  prefs: []
  type: TYPE_NORMAL
- en: The Emitter class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Emitter` class manages a pool of particles and is where the loaded sprite
    texture that the particles use to render themselves resides. Our emitters will
    only be circular. It is possible to define emitters with many different possible
    shapes, but for our game, a circle-shaped emitter will work fine. Right now, our
    `Emitter` class is going to be pretty basic. In later sections, we will add some
    new features, but right now I want to create a very basic particle system. Here
    is what the class definition looks like in the `game.hpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The attributes inside this class mirror the HTML input elements we created earlier
    in this chapter. These values get set either when the `Emitter` is created using
    the constructor, or when the user clicks the update button, which calls the `Update`
    function. The `Move` function will be called once per frame, and will move then
    render all of the particles that are active inside the particle pool. It will
    also determine if a new particle should be emitted by calling the `Spawn` function
    on a free particle.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will define all of these functions within the `emitter.cpp` file. Here is
    what the `Emitter` constructor and `Update` functions look like inside of the
    `emitter.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Both of these functions set the attributes of the `Emitter` class and set up
    the particle pool based on the `max_particles` value passed into these functions.
    The `GetFreeParticle` function is called by the `Move` function to get a particle
    from the particle pool that is not currently active. The `Move` function first
    figures out if it needs to emit a new particle, and if it does, calls the `GetFreeParticle`
    function to grab an inactive particle, and then uses the attributes of the `Emitter`
    to set the values to use when spawning a particle. It will loop over all of the
    particles in the pool, and if the particle is active, it will `Move` and then
    `Render` that particle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We will compile these classes into our WebAssembly module, but they will not
    be used to interact directly with the JavaScript we defined earlier. For that,
    we are going to need to define some functions in a new file that we will discuss
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly interface functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to define the functions that will interact with our JavaScript. We
    also need to define some global variables that will be used by several of our
    classes. Here is the code from the new `basic_particle.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two global variables are `SDL_Window` and `SDL_Renderer`. We need
    these as global objects (particularly the renderer) so that they can be used to
    render our textures to the canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we have our emitter. Right now, we are only supporting a single
    emitter. In later versions, we will want to have several emitters that we have
    configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The remaining global variables are all related to keeping track of time between
    frames in both milliseconds (`diff_time`) and terms of fractions of a second (`delta_time`).
    The `last_time` and `current_time` variables are primarily used to calculate those
    other two time-related variables. Here is what the definitions look like in the
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'After we define our global variables, it is time to define the functions that
    will interact with our JavaScript. The first one of these functions is `add_emitter`.
    That is a simple function that looks to see if an emitter has been defined and,
    if it has, delete it. Then, it creates a new emitter with the values that were
    passed into this function from the JavaScript using the values that were inside
    of the HTML input elements at the time. Here is what the function looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'You may have noticed these two lines that precede the definition of the `add_emitter`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We need those lines to prevent *name mangling* and *dead code elimination*.
    If you've never heard those terms before, let me explain.
  prefs: []
  type: TYPE_NORMAL
- en: C++ name mangling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first of these lines, `extern "C"`, tells the compiler that this is a C
    function and instructs it not to use C++ *name mangling* on that function. If
    you are not familiar with C++ name mangling, the basics of it are this: C++ supports
    function overloading. In other words, you can have multiple functions with the
    same name that have different parameters. C++ will call the correct function based
    on the parameters that are getting passed into that function. Because of this
    functionality, C++ will *mangle* the names as it compiles them, giving each function
    a different name during the compilation process. Because I am now using C++ and
    I am no longer using C, these functions I would like to be called from JavaScript
    are subject to this name mangling process. The `extern "C"` directive tells the
    C++ compiler that these are C functions, and to please not mangle the names so
    that I can call them externally from my JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: Dead code elimination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, Emscripten uses *dead code elimination* to remove any function that
    you are not calling from somewhere inside of your C++ code. In most instances,
    this is a good thing. You do not want unused code taking up space inside of your
    WebAssembly module. That creates a problem when there is a function that exists
    to be called from the JavaScript, but not from inside of the C++ code. The Emscripten
    compiler sees that nothing is calling this function, and eliminates it. `EMSCRIPTEN_KEEPALIVE`
    tells the Emscripten compiler not to remove this code because you would like to
    call it from an external source.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the emitter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After the `add_emitter` code, the next function that is set up for an external
    call is `update_emitter`. This function first checks to see if there is a defined
    emitter, and if so, calls an update function that updates all of the attributes
    on the emitter to the values passed in from the HTML input elements. Here is what
    the code looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The looping function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next function, `show_emission`, is the function that would be our game
    loop if this app were a game. This function gets called for every frame rendered
    and is responsible for the setting of timer values, preparing our SDL to render,
    and calling the emitter `Move` function, which will move and render all of the
    particles in our particle system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The first few lines calculate the `delta_time` and `diff_time` global variables,
    which are used by the particles to adjust the movement of the particles based
    on the frame rate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'If the emitter has not been set, we do not want to render anything, so we return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'If the emitter exists, we need to clear out the renderer using a black color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we call the emitter `Move` function, which both moves all the particles
    and copies the sprite texture to the appropriate position in the renderer. Then,
    we call the `SDL_RenderPresent` function, to render to the HTML canvas element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final function is the `main` function, which is called automatically when
    the WebAssembly module is loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The first couple of lines initialize our SDL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, the next several lines are used to disable the SDL text input and
    keyboard events. These lines prevent SDL from capturing the keyboard input we
    need to set the input values inside of our HTML elements. In most games, we would
    not want these lines, because we would prefer these events to be captured so that
    we could manage our game input from within our WebAssembly module. But, if we
    want our app to work, and we want our users to be able to change our HTML input,
    we must have these lines in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The next line gets the starting clock value for the `last_time` global variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The last line in this function prior to the return is used to set up our loop
    function. Our loop function will be called every time a frame is rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will compile and test an early version of our emitter
    configuration tool.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling and testing the particle emitter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wow, that was a lot of code. Okay, now that we have everything that we need
    in our particle emitter config tool, we need to take the time to compile and test
    it. After we test this version, we can use this same call to em++ to test the
    advanced version we will start building in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run this command at the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Your particle emitter configuration tool should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c029c870-aef9-443f-8eb4-257c5e87a519.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: Screenshot of the particle system configuration tool'
  prefs: []
  type: TYPE_NORMAL
- en: Do not forget that you must run WebAssembly apps using a web server, or with
    `emrun`. If you would like to run your WebAssembly app using `emrun`, you must
    compile it with the `--emrun` flag. The web browser requires a web server to stream
    the We1bAssembly module. If you attempt to open an HTML page that uses WebAssembly
    in a browser directly from your hard drive, that WebAssembly module will not load.
  prefs: []
  type: TYPE_NORMAL
- en: Use this interface to upload a `.png` image file and play around with the numbers
    we have in the fields on the left. We do not yet have enough values to make an
    excellent particle emitter, but you can get a feel for the basics with what we
    currently have.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to create a basic particle emitter configuration
    tool. We covered how to force Emscripten to create a virtual file system when
    there are no files loaded into it at application startup. We learned how we could
    load an image from our user's computer into the browser's virtual file system,
    and added functionality to allow us to upload a `.png` image file. We covered
    some basics of SVG, discussed the differences between vector and raster graphics,
    and learned how we would use SVG to draw pie charts for our configuration tool.
    We covered some basic trigonometry that was useful in this chapter, and will only
    become more useful in later chapters. We created a new HTML shell file that interacts
    with our WebAssembly, to help us configure a new particle system for our game.
    We created a `Point`, `Particle`, and `Emitter` class in a WebAssembly module
    that we are using for the emitter, which we will eventually use inside of our
    game. Finally, we learned about C++ name mangling, dead code elimination, and
    the circumstances where we must avoid them when writing Emscripten code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will improve our *particle emitter configuration tool*.
    By the end of the chapter, we will use it to configure effects in our game such
    as explosions, solar flares, and spaceship exhaust plumes. The tool can be used
    to play around with different effects, and get a feeling for how they look before
    we add that effect into our game. Finally, we will take the values we used in
    our configuration tool and use them as a starting point for configuring the particle
    effects in our game.
  prefs: []
  type: TYPE_NORMAL
