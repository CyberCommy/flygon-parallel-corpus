- en: 7\. Doing Basic Statistics with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll learn how to use the main descriptive statistics metrics
    and also produce and understand the main visualizations used in Exploratory Data
    Analysis.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to load and prepare a dataset for
    basic statistical analysis, calculate and use the main descriptive statistics
    metrics, use descriptive statistics to understand numerical and categorical variables,
    and use visualizations to study relationships between variables.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python and its analytical libraries, such as pandas and Matplotlib, make it
    very easy to perform both simple and complex statistical calculations on many
    types of datasets. This chapter introduces the first steps for any statistical
    analysis: defining and understanding the problem, loading and preparing the dataset,
    and after that, understanding the variables individually and exploring some relationships
    between them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter consists of three sections: in the first section, we introduce
    the dataset we will be using in this chapter along with a hypothetical (yet very
    realistic) business problem. Then we load the dataset and perform many of the
    common tasks of data preparation, including changing variable types and filtering
    for useful observations. With the dataset ready, the second section presents a
    brief conceptual introduction to the main metrics of descriptive statistics, then
    this knowledge is immediately applied to the dataset we are working with. As part
    of this, we will produce an example of how to translate the information of descriptive
    statistics into knowledge. The third section introduces the learner to the practice
    of **Exploratory Data Analysis** (**EDA**). Beginning with some questions and
    basic calculations, we complement our understanding of basic statistics with some
    of the most useful statistical visualizations, such as histograms, boxplots, and
    scatterplots.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will take a different approach from that traditionally taken in
    other treatments of the subject; rather than just presenting the statistical concepts,
    we will be more practical and use them as tools for doing data analysis, which
    means transforming data into information and information into knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: Data Preparation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All applied statistics starts with a dataset and a problem to solve. In the
    real world, we never do statistical analysis in a vacuum; there is always a business
    problem to solve, a topic that needs to be quantitatively understood, or a scientific
    question to ask. Understanding the problem is always the very first step of any
    statistical analysis. The second step is to collect and prepare the data. Data
    collection is not a topic of this book, so we will go directly into data preparation.
    Therefore, before diving into doing some statistical calculations, we need to
    make sure we understand our business problem and that we have prepared our dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Dataset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this subsection, we will introduce the dataset we will use in this chapter
    and perform some basic data preparation tasks. Knowing the dataset will give you
    a bit more context when we define the business problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use the **strategy games** dataset, which contains real-world
    information about strategy games from the Apple App Store (available at [https://www.kaggle.com/tristan581/17k-apple-app-store-strategy-games](https://www.kaggle.com/tristan581/17k-apple-app-store-strategy-games),
    under the following license: Attribution 4.0 International (CC BY 4.0)). It was
    collected in August 2019 and it contains 18 columns from about 17,000 strategy
    games. The description of the columns the file contains is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL**: The URL of the game'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ID**: The assigned ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Name**: The name of the game'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subtitle**: The secondary text under the name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Icon URL**: 512 px x 512 px JPG'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Average User Rating**: Rounded to the nearest 0.5'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User Rating Count**: Number of ratings internationally; null means it is
    below 5'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Price**: Price in USD'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**In-app Purchases**: Prices of available in-app purchases'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Description**: App description'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Developer**: App developer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Age Rating**: Either 4+, 9+, 12+, or 17+'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Languages**: ISO2A language codes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Size**: Size of the app in bytes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Primary Genre**: The main genre'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Genres**: Genres of the app'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Original Release Date**: When it was released'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Current Version Release Date**: When it was last updated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can also download the dataset from the GitHub repository at [https://packt.live/2O1hv2B](https://packt.live/2O1hv2B).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Business Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use this dataset along with a fictional business problem to learn how
    to turn data into information and information into useful recommendations. Imagine
    it is a glorious Monday morning and you are enjoying an excellent cup of a premium
    Guatemalan coffee. As part of a talented analytics team, you receive the following
    news:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The CEO of the game development company you work for has come up with a plan
    to strengthen the position of the company in the gaming market. From his industry
    knowledge and other business reports, he knows that a very effective way to attract
    new customers is to develop a great reputation in the mobile game space. Given
    this fact, he has the following plan: develop a strategy game for the iOS platform
    that will get a lot of positive attention, which in turn will bring a large number
    of new customers to the company. He is sure his plan will work if and only if
    the game gets great ratings from users. Since he is new in the mobile game space,
    he asks you for your help to answer the following question: What types of strategy
    games have great user ratings?*'
  prefs: []
  type: TYPE_NORMAL
- en: Now, you are the owner of this business problem. Before you get dirty with your
    data, you must be sure you understand the problem, and that at least in principle
    the problem is solvable (partially or completely) with the dataset that you have.
    We will use the dataset we introduced earlier to perform some statistical analysis
    and draw some recommendations about what makes a strategy game receive good ratings
    in this sub-market of the gaming industry.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the Dataset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s begin by loading the dataset and the libraries we will be using in this
    chapter. First, let''s load the libraries we''ll use for now, which are NumPy,
    Seaborn, pandas, and Matplotlib:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s read the dataset. This can be done by using a single line of code,
    thanks to the power of pandas. The dataset contains 18 columns of 17,007 strategy
    games. This line will read the CSV file and create a DataFrame ready to be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It is always a good idea to check if we''ve loaded the correct/expected number
    of rows and columns from the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Good, now we know we have read all the rows and columns from the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s take a quick look at the first five rows of our newly created DataFrame
    to see what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1: First five rows and nine columns of the DataFrame'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_07_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.1: First five rows and nine columns of the DataFrame'
  prefs: []
  type: TYPE_NORMAL
- en: 'A couple of things to notice here:'
  prefs: []
  type: TYPE_NORMAL
- en: Column names were read correctly (URL, Name, ID, and so on); however, the names
    from the file are not that friendly if we want easy typing, since they contain
    uppercase and lowercase letters, and some contain blank spaces between words.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The DataFrame was loaded using the automatically produced integer index. We
    can see this by looking at the left-most column and looking at the integers printed
    there in bold (`0`, `1`, `2`, …).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's address these two issues separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, it is useful to have a single standard format for the names of your
    DataFrame columns. This is of course a personal choice, and there are no strict
    guidelines regarding this. However, I recommend the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: Lowercase names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No blank spaces – instead of blank spaces, use underscores to separate words
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using this format will allow you to type faster by achieving the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding confusion when typing ("Was this letter upper or lowercase?").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking advantage of the autocomplete features in your favorite IDE and/or Jupyter
    Notebook (using the *Tab* key in Jupyter).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To make the change, let''s create a dictionary (using the dictionary comprehension
    Python feature) that contains both the original column name and the transformed
    version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting dictionary is this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2: Dictionary with original and transformed column names'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_07_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.2: Dictionary with original and transformed column names'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can use this dictionary to change the column names using the `rename`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The second issue was related to the index of the DataFrame. It is always recommended
    to use a meaningful DataFrame index, as it will make our data processing easier,
    particularly the issue of merging with other tables. In this case, we have a column
    that includes a unique ID (`id`) for each row of our dataset, so let''s use this
    column as the index for our DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can again use the following line of code to look at the first rows and
    columns of our modified DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The result looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3: First rows and columns of the modified DataFrame'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_07_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.3: First rows and columns of the modified DataFrame'
  prefs: []
  type: TYPE_NORMAL
- en: Now it looks better; however, it still needs a bit more preparation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We know there are 18 columns in this dataset; however, there are some columns
    that we can anticipate won''t provide useful information. How can we know whether
    a column will provide useful information? Everything depends on the context: remember
    that in this case, our goal is to understand what makes a strategy game receive
    great ratings. In this context, it can be safely assumed that the URL of the game
    and the URL of the game''s icon won''t provide any useful information about this
    problem. Therefore, there is no reason to keep these columns. To drop the columns,
    run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Another important processing step is to make sure that the columns in our DataFrame
    are correctly typed, which will make everything else easier: calculations, visualizations,
    and the creation of new features. We can use the `info()` method to check the
    type of our columns along with other useful information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4: Output of the info method'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_07_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.4: Output of the info method'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the columns that are conceptually numerical and categorical
    variables seem to have the correct types: `float64` and `object` respectively.
    However, we have two columns that refer to dates, and they have the `object` type.
    Let''s transform those two columns to a `datetime` type using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the previous lines of code, we can again check the column types
    by using the `info` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5: Output of the info method after changing the two date column
    types'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_07_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.5: Output of the info method after changing the two date column types'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the two columns that contain dates (`original_release_date` and
    `current_version_release_date`) have the correct `datetime64` type.
  prefs: []
  type: TYPE_NORMAL
- en: Our dataset now seems to be ready for us to start working on analyzing some
    data. The usage of the term *seems* is because as we analyze our dataset, we may
    find some additional preparation/cleaning is needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can take a final look at the processed DataFrame using the `head()` method
    again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6: First rows and columns of the processed DataFrame'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_07_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.6: First rows and columns of the processed DataFrame'
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with a real-world dataset, it is almost certain that you will
    find missing values in some of the columns, therefore it is a good idea to check
    for how many missing values you have in each column of the dataset. We can do
    this with the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding line of code shows us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7: Number of nulls by columns'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_07_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.7: Number of nulls by columns'
  prefs: []
  type: TYPE_NORMAL
- en: 'We see that there are more than 11,000 missing values in the `subtitle` column,
    although for the analysis we will do in this chapter, perhaps that column is not
    that important (perhaps we should eliminate it? What do you think?). On the other
    hand, `average_user_rating` and `user_rating_count` have the same number of missing
    values: 9,446\. That suggests that those missing values might be related. Let''s
    verify this hunch using the `np.array_equal` NumPy function. This function evaluates
    whether two arrays are equal element-wise and returns `True` if that is the case.
    We will use this function to check whether these columns have missing values in
    the same corresponding places. By doing this, we will confirm that the missing
    values happen on the same rows. The following lines of code accomplish what we
    just explained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This gives the result `True`.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the result, we can conclude that whenever we have a missing value in one
    of the columns, the other column also shows a missing value. Therefore, our guess
    was correct: if we don''t have a `user_rating_count`, we don''t have an `average_user_rating`
    either (if it was the case, then we would have to deal with the missing values
    those two columns separately). Going back to the columns'' description (the *Introducing
    the Dataset* section) for user rating count, we find that "null means it is below
    5", therefore if we have fewer than 5 people rating a game, then we don''t have
    a rating at all.'
  prefs: []
  type: TYPE_NORMAL
- en: Continuing with our exploration of missing values, for the in-app purchases
    column, we have 9,324, a relatively high value. Finally, for price, languages,
    and size, we have 24, 60, and 1 missing values respectively, which is not a big
    deal for our purposes, given the dimensions of our data.
  prefs: []
  type: TYPE_NORMAL
- en: Now we know that we have missing values in some of the columns of our dataset,
    there are many ways to deal with them. *Imputation* basically means replacing
    missing values with reasonable values. There are very complex methods for doing
    that, which are beyond the scope of this book. We will use very simple approaches
    to deal with some missing values; however, we will wait until we finish our preparation
    to decide what to do about these missing values. Imputation is usually the last
    step in the data preparation process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it is time for us to decide which observations (games) are relevant for
    our analysis; in other words, we have to answer the question: Should we keep all
    the games we have?'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the context of our analysis, there is one thing that is clear: games that
    have no ratings are of no use for our goal, since we want to understand the ratings.
    Therefore, we should exclude them from our analysis. The following line of code
    will keep only the rows in which the `average_user_rating` is not null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the number of nulls in `average_user_rating` was `9446`, so the
    last line of code will remove those rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another fact we should be aware of: the number of people rating the
    game. From the dataset description, we know that at least five users must rate
    the game for the game to have a rating. For reasons that we will explain in *Chapter
    9*, *Intermediate Stats with Python*, we will keep only those games that have
    at least 30 user ratings (basically, a size of `30`, for technical reasons, guarantees
    that the mean rating is usable for analysis). The following line of code will
    perform the operation we just described:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how many observations we have left by using the `shape` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it is a good idea to check again how many missing values we have in each
    of the columns. We will use the same code we used before for this task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8: Number of nulls by column'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_07_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.8: Number of nulls by column'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we see that from the potentially relevant columns, there are only two with
    missing values: `in-app_purchases` (`1,313`) and `languages` (`14`).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick note on all the exercises and related tests scripts: If you are using
    a **command-line interface** (**CLI**) (such as Windows'' Command Prompt or Mac''s
    Terminal) to run the tests scripts, it will throw an error as `Implement enable_gui
    in a subclass`, which is to do with some of the commands used in the notebooks
    (such as `%matplotlib inline`). So, if you want to run the test scripts, then
    please use the IPython shell. It is best to run the code of the exercises on Jupyter
    Notebooks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.01: Using a String Column to Produce a Numerical Column'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will create a new numerical variable in our DataFrame that
    will have information about the number of languages in which the game is available.
    This will be an example of how to transform text data into numerical information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a copy of the DataFrame we have been using so far and name it `games2`,
    so we have another object to work with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the first five values of the `languages` column using the `head`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The result looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9: First five values of the languages column'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_07_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.9: First five values of the languages column'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, it consists of a string of language abbreviations separated
    commas. Use the `fillna()` method to replace the missing values in that column
    with `EN`, which is the most common value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `split` (which works in the same way as the `split` method for strings)
    method from the `str` accessor method to get a list of the different languages,
    and save the resulting series in an object named `list_of_languages`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s create a column in the DataFrame called `n_languages` that
    has the count of how many elements we have in each of the resulting lists. For
    this, use a `lambda` function with the `apply` method that returns the length
    of the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The first 10 elements of the new column should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we have used a text column and produced a numerical column
    from a text-based one, by using the `str.split` method of pandas and a lambda
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/31xEnyy](https://packt.live/31xEnyy).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/38lpuk2](https://packt.live/38lpuk2).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we talked about the importance of defining the business problem,
    and we also introduced the dataset we will use in the rest of the chapter. After
    all the work we have done, the dataset is at a point where we can start making
    sense of the values. For this, we will use descriptive statistics, which is the
    topic of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating and Using Descriptive Statistics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Descriptive statistics is a set of methods that we use to summarize the information
    of a set of measurements (data), which helps us to make sense of it. In this section,
    we will first explain the need for descriptive statistics. After that, we will
    introduce the most common metrics of descriptive statistics, including mean, median,
    and standard deviation. First, we will understand them at a conceptual level using
    a simple set of measurements, and then we will apply what we have learned about
    them to the dataset we prepared in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: The Need for Descriptive Statistics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Why do we need descriptive statistics? Here is an example that will show you
    why we need these types of analytical tools: our brains are very good at a wide
    variety of tasks, such as recognizing the emotion expressed in a human face. Try
    to notice how much effort your brain puts into reading the emotion of the following
    face:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10: A facial expression'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_07_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.10: A facial expression'
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: practically nothing, and certainly you can say something meaningful
    about what is going on in the picture.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in contrast, let''s give our brain a different task: we will use the games
    dataset from the previous section, randomly choose 300 observations from the average
    user ratings column, and then print them. The following lines of code do just
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11: Random sample of 300 average user ratings'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_07_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.11: Random sample of 300 average user ratings'
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the output, try to analyze it, and answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: How much mental effort does it take to say something meaningful?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What can you say about average ratings just by looking at the numbers?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Your answers to these questions will most probably be something like:'
  prefs: []
  type: TYPE_NORMAL
- en: How much mental effort does it take to say something meaningful? *"I had to
    spend some time looking at the numbers."*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What can you say about average ratings just by looking at the numbers? *"Not
    much, the numbers end in either .0 or .5."*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Just by looking at *Figure 7.10*, we can automatically *summarize* and understand
    the information contained in thousands of pixels by saying *woman laughing*. However,
    in the case of *Figure 7.11*, there is no way we can understand something about
    them in an automatically. This is why we need descriptive statistics: it allows
    us to summarize and understand numerical information by performing relatively
    simple calculations.'
  prefs: []
  type: TYPE_NORMAL
- en: A Brief Refresher of Statistical Concepts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are reading this book, it is very likely that you have already learned
    or used some of the most common descriptive statistics, and it is very hard for
    me to provide an original definition of the concepts that have been presented
    in literally hundreds of books on statistics. Therefore, you can view the following
    pages just as a refresher of the most important concepts regarding descriptive
    statistics measures.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this subsection, just to make the conceptual explanations a bit easier to
    understand, we will divert a bit from our strategy game dataset, and we will use
    a small set of 24 observations. Suppose we have the heights (in meters) of 24
    men. Here we have the original observations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use this small set of observations for our conceptual introduction
    to the most important descriptive statistics. To make our calculations easy, let´s
    create a pandas series containing these values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now we are ready for our review of the most commonly used descriptive statistics.
  prefs: []
  type: TYPE_NORMAL
- en: '**Arithmetic mean**: Also known simply as **mean**, this is a measure of the
    *center of the distribution* or the center of the set of numbers. Given a set
    of observations, the mean is calculated by summing the observations and dividing
    that sum by the number of observations. The formula is as follows, where *x bar*
    (*x̄*) is the mean and *n* is the number of observations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12: Formula for arithmetic mean'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_07_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.12: Formula for arithmetic mean'
  prefs: []
  type: TYPE_NORMAL
- en: The mean is especially useful and informative when most of the values are clustered
    around a single *center*, because in that case the mean will be close to that
    center, and thus will be close to many values, making it a *representative* number
    of the set of observations. Many (perhaps most) of the numerical variables you
    will encounter in real-world data will have values that will cluster around the
    mean, therefore the mean is usually a good indicator of the *typical* value of
    a set of measurements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s calculate the mean for the set of men''s heights by using the built-in
    pandas method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This number tells us that 1.78 meters is a value that is *representative* of
    the set of the heights of the 24 men. After performing this calculation, we know
    that a typical man (from the population from which we got that sample) will have
    a height of around `1.78` meters.
  prefs: []
  type: TYPE_NORMAL
- en: Something to be aware of about the mean is that it gets affected by extreme
    values. This is especially troublesome when analyzing variables in which the extreme
    values could potentially be orders of magnitude greater than the most common values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it is worth mentioning that the arithmetic mean is often what most
    people have in mind when they say the word *average*, although there are other
    averages, such as the median, which we will define later.
  prefs: []
  type: TYPE_NORMAL
- en: '**Standard deviation**: This is a measure of the spread of the data. It measures
    how different or *dispersed* the observations in a set of measurements are. The
    mathematical formula is based on the arithmetic mean, and for your reference,
    it is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13: Formula for standard deviation'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_07_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.13: Formula for standard deviation'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding formula, *s* refers to the standard deviation, *x bar* (*x̄*)
    is the mean, and *N* is the number of observations. Because of a technical detail
    (beyond our scope) the formula has *N – 1* instead of just *N* as a denominator,
    but let''s pretend for a moment that we have an *N* in the denominator: if you
    look at the formula closely you will see that what we have inside the square root
    symbol is *the mean of the squared deviations with respect to the mean*. So, the
    standard deviation is a kind of arithmetic mean of how distant the observations
    are to its mean. The square root is in the formula, so the resulting number is
    in the same units as the original measurements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s calculate the standard deviation of our small set of measurements of
    men''s heights, again using pandas'' built-in methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Our answer is `0.094` meters, or 9.4 centimeters. The interpretation of this
    number is that, *on average*, a man's height differs by 9.4 centimeters from the
    mean (which was in this case 1.78 meters). Notice that we say *on average*, meaning
    that we can expect individual men's heights to be closer or farther apart than
    9.4 centimeters from the average, but 9.4 is an informative number of how far
    apart we expect a typical observation will be from the mean.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand the concept of standard deviation, it would be useful
    to contrast the former calculation with another hypothetical set of measurements.
    Let''s say we have the heights of another 24 men with a similar average:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s calculate the average, to see how these 24 men compare with the average
    of our first group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This is around 3 centimeters below the average of the first group. Now let''s
    calculate the standard deviation of the second group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This is only 1 centimeter, which means that the heights of the second group
    are much more homogeneous. In other words, the heights of the second group are
    closer to each other (that is, they have less dispersion) than the heights in
    the first group. Since we have very few observations, we can tell this by looking
    closely at the measurements of the second group: notice that all the measurements
    are between 1.73 and 1.77, so the variability is less compared with the first
    group.'
  prefs: []
  type: TYPE_NORMAL
- en: On the extreme end, if all observations are exactly the same, that is, there
    is no variation among them, then the standard deviation will be zero. The more
    different the measurements, the larger the standard deviation will be.
  prefs: []
  type: TYPE_NORMAL
- en: There are other measures of the spread of the data, but the standard deviation
    is maybe the most important. You should make sure you know how to interpret it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Quartiles**: Quartiles are *measures of location*. They indicate that the
    value is in a certain relative position when the observations have been ordered
    from the smallest (minimum) to the largest (maximum) values. The first, second,
    and third quartiles are usually denoted as **Q1**, **Q2**, and **Q3**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q1**: Divides the data in such a way that 25% of the observations are below
    this value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Q2**: Also called *the median*, this is the number that divides the set of
    numbers in two halves, meaning that 50% of the observations are below this value,
    and the other 50% are above this value. The median is another type of average.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Q3**: Divides the data in such a way that 75% of the observations are below
    this value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Again using our first 24 heights, we can order them and split this little dataset
    into four parts, each consisting of 6 observations. This is visually shown in
    the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.14: Illustration of quartiles'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_07_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.14: Illustration of quartiles'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we can split the dataset into *exactly* four parts. The first
    one consists of the smallest six observations; the sixth observation is `1.68`,
    and the next one (which belongs to the second quartile) is `1.73`. Technically
    any number between `1.68` and `1.73` (`1.68` < `Q1` < `1.73`) could be called
    the *first quartile*, for instance, `1.70`, because the statement *25% of observations
    are below 1.70* would be true. We could also pick `1.71` because the statement
    *25% of observations are below 1.71* would also be true.
  prefs: []
  type: TYPE_NORMAL
- en: The median (`Q2`) splits the observations into two halves. `1.80` is the 12th
    and 13th observation in this case, so the median is `1.80`. (If there was a number
    between the 12th and 13th observation, the median would be the number in between.)
  prefs: []
  type: TYPE_NORMAL
- en: Finally, for the third quartile (`Q3`), we see from the figure that any number
    between `1.84` and `1.85` (say 1.845) would be a value that splits the bottom
    75% observations from the top 25%.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that I have not given any formula to calculate quartiles, so how exactly
    are the quartiles calculated? There are a few methods that we won''t be going
    into in this book. The exact method is not important – what is really important
    is that you understand the concept. Now let''s see how to calculate these values.
    In the following line of code, we will use the `quantile` method from pandas (quartiles
    are a special case of the more general concept of **quantile**, a concept close
    to that of **percentile**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We had to pass a list to this method indicating the percentage (proportion)
    of observations where we wanted the splits—these are 25%, 50%, and 75%, that correspond
    to `Q1`, `Q2`, and `Q3` respectively. As you can see, the first quartile (`1.7175`)
    is a number between 1.68 and 1.73, the median is `1.80`, and the third quartile
    (`1.8425`) is a number between 1.84 and 1.85.
  prefs: []
  type: TYPE_NORMAL
- en: 'To calculate quantiles, as opposed to quartiles, we use any proportion to split
    the observations into two parts: for example, let''s say that we what to divide
    the observations between the bottom 80% and the top 20%, the 80th percentile is
    equivalent to the 0.8 quantile, and would be the number below which there are
    80% of observations. Similarly, the 33rd percentile would be equivalent to the
    0.33 quantile and would be the number below which there are 33% of observations.
    This explains why we have to pass a list of quantiles to the quantile function
    in pandas; for instance, the following code calculates the 0.33 and 0.8 quantiles
    (which correspond to the 33rd and 80th percentiles):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: According to this result, 80% of our observations are below `1.858`. As a mini-exercise,
    check if the 33rd percentile is what you would expect by comparing its value to
    the range illustrated in *Figure 7.14*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Descriptive statistics is not only about the standard set of metrics such as
    mean, median, and so on. Any simple, *descriptive* calculation done on the data
    is also considered to be descriptive statistics, including sums, proportions,
    percentages, and so on. For instance, let''s calculate the proportion of men above
    1.80 meters. There are many ways to do it, but we will use a two-step approach.
    First, let''s run the following line of code, which gives the value `True` if
    the observation satisfies the condition and `False` otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The result looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.15: Boolean series'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_07_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.15: Boolean series'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second step is to count how many `True` values we have. We can do this
    with the `sum` method, which will transform `True` to 1s and `False` to 0s. Then
    we could simply divide by the number of observations in our series by the `shape`
    method. The whole line of code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Or 54% of our 24 heights are equal to or greater than 1.8 meters. This proportion
    is also considered descriptive statistics, since it is a number that is also describing
    what is going on with our data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding calculation could have been done more succinctly like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As a mini-exercise, you can use the mean formula given in *Figure 7.12* to deduce
    why the `mean` method will give you the proportion of true values in a Boolean
    series.
  prefs: []
  type: TYPE_NORMAL
- en: Using Descriptive Statistics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have refreshed our understanding of the most important measures
    of descriptive statistics, it is time for us to go back to our original dataset
    and start using those concepts in the context of the business problem given to
    us.
  prefs: []
  type: TYPE_NORMAL
- en: 'The descriptive statistics we reviewed in the preceding section are so important
    that the pandas `describe` method (which belongs to both series and DataFrames)
    calculates all of them. In addition, we will find the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Count**: Number of non-null values in the column'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minimum**: Smallest value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maximum**: Largest value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the `describe` method is used on a DataFrame, it takes all the columns
    with numerical types and calculates their descriptive statistics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.16: Descriptive statistics for numerical columns of the DataFrame'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_07_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.16: Descriptive statistics for numerical columns of the DataFrame'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before interpreting the results, you need to be aware that by default, pandas
    shows the output in scientific notation: for example, `4.311000e+03` means 4.311
    x 103 = 4,311\. The notation `"e+k"` means (x 10k) and `"e-k"` means (x 10-k).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To put these concepts into practice, let''s read and interpret the statistics
    from the `user_rating_count` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '`count`: The value in the output for count is 4,311\. This is the amount of
    not-null observations in our variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mean`: The value in the output for mean is 5,789.75\. Now we know that on
    average we have about 5,800 users rating a game in our dataset. To extract more
    information about this number (and whether it is useful or not), let''s read the
    other statistics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std`: The standard deviation value is 5,592.43\. On average, the number of
    users rating a game in our dataset varies from the mean by almost 5,600 users:
    think about it, the average number of ratings was roughly 5,800, and the *typical*
    deviation from that number is almost ~5,600\. This tells us that the variability
    is very large in this variable (dispersion is high), or in other words: we have
    some games with only a few user ratings, and we have some games with a very large
    number of user ratings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min`, `25%`, `50%`, `75%`, `max`: These numbers tell us important information
    about how the observations in our variable are distributed. We see that the minimum
    is 30 (remember that we explicitly selected games with at least 30 ratings), and
    the maximum value is more than 3 million! The first quartile tells us that 25%
    of the games in our dataset have less than 70 user ratings; this is very few,
    considering that the mean was 5,789.75\. The median is 221 user ratings, so half
    of our games have less than 221 ratings! Finally, the third quartile indicates
    that 75% of the observations are below 1,192.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, we have more or less only read the results, so now let's discuss a bit
    more to be able to transform this data into useful information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowing the maximum (more than 3 million), we can be sure that the *mean* of
    this variable has been highly affected by the extreme values, namely hugely popular
    games. So perhaps the mean is not that informative for this variable. Maybe it
    is not meaningful to talk about *the typical number of user ratings for a game*,
    because the data suggests there is no *typical* number. In fact, we know that
    more than 75% of the observations have fewer than 1,200 user ratings. This would
    imply that we should observe a few popular games. Let''s test this hunch and dive
    a bit into the games with the most ratings, using the `sort_values` method from
    the series to see the first 10 values of `user_rating_count` in descending order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.17: First 10 values of user rating count'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_07_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.17: First 10 values of user rating count'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that only two games have more than one million user ratings, which explains
    the high variability we observed from the standard deviation (5,592.43). Let''s
    check how many games have at least 100,000 user ratings. First, we will filter
    our column by the condition `>= 100000` and then we will use the `sum` method,
    which will count how many values satisfy that condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: So only 40 games have more than 100,000 ratings, which is less than 1% of the
    current dataset (of 4,311 games) and 0.23% of the original dataset (of 17,007
    games).
  prefs: []
  type: TYPE_NORMAL
- en: In summary, the number of user ratings that a game has is highly variable. In
    addition, 25% of the games in our sample have less than 70 user ratings, and half
    of the games have less than 221\. Moreover, we have only `40` games with more
    than 100,000 user ratings, with the first and second most popular games having
    more than 3.0 million and more than 1.2 million respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the way we might present the information to the CEO:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The data from the user rating count, which is a proxy for the popularity of
    the game, suggests that it is very hard for a strategy game to become hugely popular.
    The data tells us that less than 1% of the strategy games can be considered hugely
    popular (in terms of the number of user ratings), while more than 75% of the games
    have less than 1,200 user ratings, indicating a relatively low user base. Keep
    in mind that for this exercise we have excluded those games that have less than
    30 user ratings, therefore the odds for a strategy game to become hugely popular
    is way below 1%.*'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding paragraph is an example of how to extract valuable information
    from descriptive statistics. Notice that we had no need to mention any statistical
    terminology, such as mean, median, or standard deviation, nor the terms quantile,
    percentile, and so on. Notice also that the fact that the mean was 5,789.75 was
    not used, because that fact was not necessary for the message we were trying to
    convey. That is the kind of information that someone like a CEO would like to
    hear, since it is clear, informative, and actionable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We finish this section with a very important piece of advice: don''t make the
    mistake of presenting a list of the descriptive statistics calculations as your
    *analysis*. Another common mistake is to include a paragraph containing analysis
    such as *the mean is x*, *the standard deviation is y*, *the maximum is 88*, basically
    just re-writing the information contained in the statistical table. Keep in mind
    that it is your job not only to perform the calculations, but also to explain
    what these numbers mean and their implications regarding the problem you are trying
    to solve.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.02: Calculating Descriptive Statistics'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will use descriptive statistics to calculate the value
    of the average user rating variable. For this, we will use the descriptive statistics
    metrics that we discussed in the previous section. In addition, we will also perform
    other descriptive calculations, including counts and proportions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Calculate the descriptive statistics of the `average_user_rating` column:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the median and the third quartile have the same value, `4.5`,
    which means that at least 25% of the games have an average rating of `4.5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Calculate the number and the proportion of games with a rating of exactly `4.5`.
    The `mean` method can be used for this goal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The output we get is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Use the `unique` method to see the unique values for this variable. What do
    you notice?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we have used descriptive statistics to understand another
    key variable of our business problem.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2VUWhI3](https://packt.live/2VUWhI3).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2Zp0Z1u](https://packt.live/2Zp0Z1u).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some questions that might come to mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Is the mean of this variable a statistic you would use to understand this variable?
    Would you choose it as a *typical* value of the variable, or would you choose
    another value?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on the standard deviation, would you consider that this variable has high
    or low variability?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How could the information you obtained by using the descriptive statistics be
    summarized in a paragraph?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we learned why we need and use descriptive statistics. From
    the first example we introduced, we learned that our brains don't have the capacity
    to automatically make sense of numerical information. It is therefore necessary
    to have these types of analytical tools if we want to understand numerical data.
  prefs: []
  type: TYPE_NORMAL
- en: Then we presented a brief refresher on (or introduction to) some of the most
    commonly used metrics of descriptive statistics, including mean, standard deviation,
    and quantiles. Then we immediately applied that knowledge using the strategy games
    dataset and calculated the descriptive statistics for the numerical variables.
    We analyzed the results for the user rating count variable and produced a summary
    that contained relevant information that a non-technical audience can understand.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we did all the calculations using pandas built-in methods such as `mean`,
    `std`, `describe`, and `quantile`, among others.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the basics of descriptive statistics, we can expand our statistical
    toolkit and complement our analysis using visualizations, which we will cover
    in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Exploratory Data Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will be referring back to the business problem that we
    performed some initial analysis on in the first section of this chapter, which
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The CEO of the game development company you work for has come up with a plan
    to strengthen the position of the company in the gaming market. From his industry
    knowledge and other business reports, he knows that a very effective way to attract
    new customers is to develop a great reputation in the mobile game space. Given
    this fact, he has the following plan: develop a strategy game for the iOS platform
    that will get a lot of positive attention, which in turn will bring a large number
    of new customers to the company. He is sure his plan will work if and only if
    the game gets great ratings from users. Since he is new in the mobile game space,
    he asks you for your help to answer the following question: What types of strategy
    games have great user ratings?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will do some exploratory data analysis. You can think of
    this section as a continuation of the last section, as we will continue using
    descriptive statistics, and in addition to that, we will expand our analytical
    toolkit with one of the most powerful analytical devices: visualizations.'
  prefs: []
  type: TYPE_NORMAL
- en: The field of **Exploratory Data Analysis** (**EDA**) (like any other field related
    to data) has been growing rapidly, and the content of this section covers only
    some of the very basic concepts and visualizations. Despite that, it is very likely
    that you will use the visualizations presented in this section in every data analysis
    project you will encounter.
  prefs: []
  type: TYPE_NORMAL
- en: What Is EDA?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have refreshed our basic statistical definitions, we are ready
    to put them to use and complement the information we get from them with visualizations.
    In simple terms, EDA is the process of analyzing data by combining descriptive
    statistics with visualizations. The reasons and objectives of doing EDA include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the distributions of the variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the relationships between two or more variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting patterns that can't be found using numerical calculations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spotting anomalies or outliers in the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formulating a hypothesis about causal relationships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Informing us about how to engineer new variables (feature engineering)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Informing us about possible formal inferential statistical tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By definition, while doing EDA we are exploring the data, so there are no recipes
    or sets of fixed steps to follow, and a lot of creativity is involved. However,
    it is also very important to provide some structure to the process, otherwise
    we could be producing plots and calculations with no clear end point. In data
    analytics (as in life), without a clear purpose, it is very easy to get lost,
    since there are countless ways to look at any regularly-sized dataset. Before
    starting to perform EDA, we need to define what is that we are trying to find,
    which is where the understanding of the business problem is key.
  prefs: []
  type: TYPE_NORMAL
- en: 'I would recommend performing EDA in two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Univariate step**: Understand each of the most important variables in the
    dataset: distributions, key characteristics, extreme values, and so on.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Look for relationships**: With the business/scientific problem in mind, *formulate
    a list of questions* whose answers will give you useful information about the
    problem you are trying to solve, and then let these questions guide the EDA process.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first step is what is usually called *univariate analysis*, and is relatively
    straightforward. For the second step, we use *bi-variate* or *multivariate* techniques
    since we need to look for relationships between variables. In the next section,
    we will do univariate EDA.
  prefs: []
  type: TYPE_NORMAL
- en: Univariate EDA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the name implies, univariate EDA is about analyzing a single variable at
    the time. In the previous section, we saw how easy it is to calculate the main
    descriptive statistics with pandas. Now we will complement the information we
    get from descriptive statistics using appropriate visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before performing EDA, it is absolutely necessary to know which type of variables
    we are working with. As a refresher, here we have the main types of variables
    we can encounter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Numerical variables**: Those variables that can take numerical values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'a. **Continuous**: These are variables that can take a whole range of real
    values between a certain interval, such as height, weight, and mass.'
  prefs: []
  type: TYPE_NORMAL
- en: 'b. **Discrete**: These are variables that take only a specific, limited number
    of values, frequently integers. Examples include the number of children in a family
    or the number of employees.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Categorical variables**: Those that can take only a specified number of categories
    as values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'a. **Ordinal**: Variables where the categories have some natural order. For
    instance, the variable `age group` could have the categories 20-29, 30-39, 40-49,
    and 50+. Notice that there is an order in those categories: 20-29 is lower than
    40-49.'
  prefs: []
  type: TYPE_NORMAL
- en: 'b. **Nominal**: These are categorical variables where there are no ordered
    relationships. For example, the colors blue, green, and red are categories without
    any sort of order.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Time-related variables**: Variables that relate to dates or datetimes.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s begin by identifying the numerical variables in our dataset. As we did
    previously while preparing the dataset, we realized that the variables that are
    *conceptually* numerical have an appropriate corresponding Python numerical data
    type. Let''s use the `info` method in our (modified) games DataFrame to check
    this again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.18: Numerical variables in the dataset'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_07_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.18: Numerical variables in the dataset'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, the columns that are conceptually numerical: `average_user_rating`,
    `user_rating_count`, `price`, and `size` have datatypes of `float64`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most commonly used useful visualization for a single numerical variable
    is the histogram. Let''s see how it looks and then describe how it''s constructed.
    For this, we will use the `size` variable. Since this variable is in bytes, before
    visualizing it we will transform it to megabytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use pandas'' built-in `hist` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We have included two additional parameters: `bins`, which is (roughly) the
    number of bars we see, and `ec` (edge color), which is the color of the bar edges.
    The resulting figure is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.19: Histogram of size'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_07_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.19: Histogram of size'
  prefs: []
  type: TYPE_NORMAL
- en: The histogram is built by dividing the *range* of the variable, which is defined
    as the maximum minus the minimum into equally sized intervals called bins. In
    this case, the maximum and the minimum are 4,005.6 and 0.2 respectively, so the
    range is about 4,005\. Since we indicated 30 as the number of bins, each bin will
    have a size of about 133 ~ 4,005 / 30\. So, the first bin goes from roughly the
    minimum (about 0) to 133, the second bin goes from 133 to 266 = 133 + 133, and
    so on. The height of the bar corresponds to the number of observations that fall
    in the interval of a particular bin. For instance, we see that the first bar goes
    a bit beyond 2,500 observations, which is the number of observations that fall
    in the first bin (which goes from 0 to ~133). As with quartiles, the exact algorithm
    to build the histogram varies with the software used. Pandas uses the Matplotlib
    implementation, so please check out Matplotlib's documentation if you want to
    know the details.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should get used to seeing histograms and try reading them. For instance,
    the histogram of the *size* shows the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An important proportion of the games fall in the first bin (the tallest bar).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the values are below 500 MB.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The number (frequency) of observations goes down as the variable increases:
    we observe fewer and fewer games as the size grows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *x* axis of the plot goes until about 4,000 MB; however, we don't even see
    a bar there, the reason being that we have so few observations and that bar is
    so tiny that it's indistinguishable from zero. This means that we must have at
    least one extreme value (a game of a very large size).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The height of the bars above 1,000 MB is very low, so there are very few games
    above 1,000 MB.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The histogram is a perfect complement for the numerical information we get
    from the descriptive statistics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The median tells us that more than half of the games have a size of less than
    97.3 MB, and the game with the largest size is more than 40 times the median,
    which we could consider an *outlier* or an observation that is much more extreme
    than most of the values in our variable. As we did with user rating count, we
    could examine the largest games by sorting the series in descending order and
    then showing the first 12 values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.20: Largest values of size'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_07_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.20: Largest values of size'
  prefs: []
  type: TYPE_NORMAL
- en: We see that there are actually a few outliers, which are not just the maximum.
    There is actually no standard definition of *outlier*—it depends on the context.
    We are calling these observations outliers because they can be considered large
    sizes for a set of games in which 75% of them have sizes of less than 208 MB.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, back to histograms. One very cool feature of pandas is its ability to produce
    histograms for many numerical variables at the same time using the `hist` method
    of the `DataFrame` class. This feature will be useful when you have a lot of numerical
    variables in your dataset and you want to take a quick look at them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Pandas automatically takes all the numerical variables and produces a grid
    (which is adjustable) of rows and columns with the plots. In our case, we have
    four numerical variables, and the result is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.21: Example of histograms of a DataFrame'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_07_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.21: Example of histograms of a DataFrame'
  prefs: []
  type: TYPE_NORMAL
- en: The fact that we have a few extreme values (outliers) in `price`, `size`, and
    `user_rating_count` has the effect of not letting us see how the values of these
    variables are truly distributed.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our knowledge of quantiles (and percentiles), let''s create a filter that
    will exclude the 1% of largest values in each of these three variables, which
    will hopefully allow us to understand the distributions better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.22: Example of histograms of a DataFrame'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_07_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.22: Example of histograms of a DataFrame'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the histograms have revealed more information, here are a few of the
    things we can read from the histograms:'
  prefs: []
  type: TYPE_NORMAL
- en: Most games are free, and of the very few that are not free, the vast majority
    cost less than 10 dollars.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4.5 is the most common average user rating; in fact, we observe very few games
    with low average ratings (3 or below).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Larger-sized games are rare.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most games have very few user ratings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an exercise, try to extract more information from these graphs and complement
    it with the descriptive statistics for these variables: for instance, comment
    on the decaying pattern of the size variable, or the highly concentrated pattern
    we see in the user rating count: what could explain those shapes?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s talk about another useful plot to see the distribution of a continuous
    variable: the boxplot. A boxplot is a graphical representation of the position
    statistics `Q1`, median, and `Q3`, and usually also shows the minimum and maximum.
    The boxplot for the sample dataset of 24 observations can be generated using the
    following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows (annotations of the descriptive statistics have been
    added to the figure):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.23: Example of a boxplot'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_07_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.23: Example of a boxplot'
  prefs: []
  type: TYPE_NORMAL
- en: 'The boxplot consists of two *whiskers* and a box. The first whisker (usually)
    starts at the minimum value, then it goes until **Q1**, which marks the beginning
    of the box, therefore the first whisker covers the bottom 25% of observations.
    The box goes from **Q1** to **Q3**, covering the *middle half* of the observations.
    The height of the box is called the **Inter Quartile Range** (**IQR**) and is
    a measure of dispersion, which tells us how *packed* the middle 50% of observations
    are: a larger IQR implies more dispersion. The line in the middle of the box corresponds
    to the median, and finally, the upper whisker (usually) finishes at the maximum
    value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice I have added a couple of *usually* in parenthesis for the maximum and
    minimum. When an observation is above *Q3 + 1.5 x IQR* (or below *Q1 - 1.5 x IQR*),
    it is often considered a candidate for an outlier and is plotted as a dot. If
    we have such observations, then the upper (lower) whisker ends at *Q3 + 1.5 x
    IQR* (or *Q1 - 1.5 x IQR*). Here is, for example, the boxplot for the `size` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.24: Boxplot of size'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_07_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.24: Boxplot of size'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the upper whisker does not finish on the maximum value, but it
    goes until *Q3 + 1.5 x IQR*. From this plot, we can say that the variable has
    many extreme values. Although the boxplots might sometimes be useful for univariate
    EDA, the histogram is preferable. The best use for boxplots is when analyzing
    the relation of a numerical variable versus a categorical one. We will return
    to the boxplots in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish this subsection, let''s see how to produce a bar plot, which is used
    to show either counts, proportions, or percentages of a categorical variable.
    Let''s take a look at the `age_rating` column, which is a categorical variable.
    The following line will count the number of games for each of the values of the
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the result is also a pandas series, we can chain the methods and use
    the `plot` method with the argument `kind = ''bar''` to get our bar plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The result looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.25: Bar plot for absolute counts of age_rating'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_07_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.25: Bar plot for absolute counts of age_rating'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to visualize the proportions, we could have modified the preceding
    line of code by adding the `normalize=True` argument to the `value_counts` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The figure looks almost identical, the only change being in the *y* axis labels,
    which now show the proportions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.26: Bar plot for proportions of age ratings'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_07_26.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.26: Bar plot for proportions of age ratings'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, another alternative to visualize proportions is using a pie chart.
    Pie charts are known to have some problems, among them the fact that they are
    not a good way to convey information, which is why I never use them. However,
    they are useful for presenting business information, so if your boss asks you
    for a pie chart, here is how to produce one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.27: Pie chart of age ratings'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_07_27.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.27: Pie chart of age ratings'
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem with pie charts is that they are just a way to beautify documents,
    not a good way to communicate quantitative information; visualizations are meant
    to be used when we want to complement and go beyond what numerical calculations
    can communicate. If we want to communicate proportions (or percentages), it is
    simply better to show the actual values, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Bi-variate EDA: Exploring Relationships Between Variables'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Exploring relationships between variables is one of the most interesting aspects
    of statistical analysis. When exploring relations between pairs of variables,
    and considering only the broadest division of numerical and categorical variables,
    we have three cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Numerical versus numerical
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numerical versus categorical
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Categorical versus categorical
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the first case, the scatter plot is the visualization of choice. For the
    second case, depending on what we are trying to find, we have some choices, but
    often boxplots are most useful. Finally, for the third case, the most common choice
    is to present what is called a contingency table: although some visualizations
    options exist for comparing categorical data, they are not so common.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we said back in *Exploratory Data Analysis*, when doing this type of analysis,
    it is often a good idea to formulate a list of questions we want to answer before
    we start producing visualizations. Keeping in mind our business problem, we will
    try to shed some light on the following three questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the relationship between the size and average user rating?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the relationship between the age rating and average user rating?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the relationship between having in-app purchases and the game rating?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will try answering the first question using a scatter plot. In its most
    simple version, the scatter plots show each point of a pair of variables using
    a Cartesian plane. Each pair of points is represented by a dot, and the pattern
    of the dots indicate if there is some kind of relationship between the two plotted
    variables. The following table shows illustrations of some of the patterns you
    can detect using a scatter plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.28: Examples of patterns in scatter plots'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_07_28.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.28: Examples of patterns in scatter plots'
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep in mind that the examples from the table are just for reference: usually,
    real-world datasets do not offer such easily identifiable patterns.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we can create plots using pandas, we will use Seaborn, a very popular
    statistical visualization that is capable of producing beautiful and complex plots
    with just a few lines of code. We will use the `scatterplot` function, which takes
    the names of the variables that will go on each axis and the name of the DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we have the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.29: Scatter plot of size versus average user ratings'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_07_29.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.29: Scatter plot of size versus average user ratings'
  prefs: []
  type: TYPE_NORMAL
- en: If we take a look at the upper-right quarter of the plot, it looks like games
    of a certain size, say above 1,500 MB, tend to have ratings of 3.5 and above.
    Since size is a proxy for the quality of the graphics and the complexity of the
    game, this plot seems to suggest that a way to improve the chances of getting
    a decent average rating is by producing games of a certain complexity and visual
    quality. However, the plot also shows relatively small games getting average ratings
    of 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s explore the relationship between a numerical and a categorical variable.
    Maybe we can get more insights into the ratings if we treat the average rating
    as a categorical variable; after all, due to some quirks of the dataset, this
    variable is discrete instead of continuous; it takes values only on whole and
    half points. The following code categorizes the variable using the mapping defined
    in a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'We have created a new average user rating scale that uses categorical variables.
    We can now use a boxplot to see if the distribution of size values changes for
    the different types of ratings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.30: Boxplot of size versus categorical user ratings'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_07_30.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.30: Boxplot of size versus categorical user ratings'
  prefs: []
  type: TYPE_NORMAL
- en: We have restricted the dataset to games below 600 MB to see if the relationship
    of size-rating holds for games that are not too large. We see that the distributions
    are in fact different, with poorly-rated games having smaller sizes in general
    than the other categories (the boxplot is lower than the rest). Notice that the
    distributions of good and excellently-rated games are almost identical, perhaps
    suggesting that, for games below 600 MB, complexity and quality graphics influence
    ratings up to a point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s review the third case: how to explore the relationship between
    two categorical variables. To do this, let''s explore age ratings versus the categorical
    rating that we just created. We can produce a table that counts how many observations
    we have in each combination of the values of our two variables. This is often
    called a contingency table. Pandas has the handy `crosstab` function for this
    purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.31: Contingency table of age ratings versus categorical user ratings'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_07_31.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.31: Contingency table of age ratings versus categorical user ratings'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is good to have the counts; however, it is still a bit tricky to make sense
    of this data. What we need in order to find out if these two variables are related
    is to find out whether the proportion of age ratings changes according to how
    good or bad the game has been rated. For instance, if we find that 90% of 4+ games
    are poorly rated, and at the same time, only 15% of 17+ games are poorly rated,
    then it is reasonable to assume that these variables have some sort of relationship.
    To perform this calculation, we have to normalize the rows of the former table.
    We do this by adding the `normalize=''index''` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'We have multiplied the whole table by 100, so it is easier to read as percentages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.32: Row-normalized contingency table of age ratings versus categorical
    user ratings'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_07_32.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.32: Row-normalized contingency table of age ratings versus categorical
    user ratings'
  prefs: []
  type: TYPE_NORMAL
- en: Since the rows have been normalized, every row should add up to 100\. Now we
    can easily compare the distribution of the different user ratings across the different
    age ratings. For instance, we observe that the proportion of excellently rated
    games is almost the same, regardless of the age rating, and that the same happens
    (more or less) for the other columns. This suggests that perhaps the age rating
    of the game is not a big factor for the ratings of the games.
  prefs: []
  type: TYPE_NORMAL
- en: Here is where statistical analysis becomes an art. The findings of the initial
    exploration produce new questions and hypotheses that we would further explore
    using more numerical and visual analysis, and hopefully, after a few iterations,
    we will produce useful information we can turn into knowledge about the problem
    at hand.
  prefs: []
  type: TYPE_NORMAL
- en: I will close this section by stating that while the scope of this book focuses
    on visualizing the relationships between two variables, it is possible to visually
    explore relationships between three or more variables. However, keep in mind that
    having more than two variables in a visualization often exponentially increases
    the complexity of the analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.03: Practicing EDA'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will use a boxplot to visualize whether free games have
    different ratings than paid games.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s take a look at the different prices we have in our dataset. For
    this, take a look at the unique values of price:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks like all the games are sold for some number of dollars plus `99` cents.
    We know that in practice `2.99` means `3` dollars. Transform this variable to
    integer values using the built-in `round` method, so the values are nice round
    numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this is a discrete numerical variable, use a bar plot to visualize the
    distribution of the games for each of the prices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.33: Bar plot of the number of observations by price'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_07_33.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.33: Bar plot of the number of observations by price'
  prefs: []
  type: TYPE_NORMAL
- en: 'It looks like the majority of the games are free. To simplify the analysis,
    create a categorical variable named `cat_price` that indicates whether a games
    is free or paid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Use a boxplot to visualize the relationship between the variable created in
    the previous point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.34: Boxplot: cat_price versus average user ratings'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_07_34.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.34: Boxplot: cat_price versus average user ratings'
  prefs: []
  type: TYPE_NORMAL
- en: From the plot, we can see that the distributions of average user ratings look
    almost identical for free and paid games. This suggests that the status of free
    versus paid games does not affect the rating of the game.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we have used a boxplot to explore the distribution of the
    variable price and see if there is some relationship between this variable and
    the average user rating.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2VBV2gI](https://packt.live/2VBV2gI).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2YUGv1I](https://packt.live/2YUGv1I).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned about EDA, which is the process of complementing
    descriptive statistics with visualizations. We learned about some of the most
    useful types of visualizations that are used in virtually every type of statistical
    analysis. You have become familiar with histograms, boxplots, bar plots, and scatter
    plots, which are all powerful tools to complement the numerical analysis and reveal
    useful information about a dataset.
  prefs: []
  type: TYPE_NORMAL
- en: EDA is an essential step in every statistical analysis since it allows us, among
    other things, to get to know the variables in a dataset, recognize potential relationships
    between them, and generate a hypothesis that can be formally tested using formal
    inferential methods. Now that we have learned the basics of descriptive statistics,
    we can move on to learn about inferential statistics, but first, we must learn
    about some fundamentals of probability theory, which is the topic of the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 7.01: Finding Out Highly Rated Strategy Games'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The game development company you work for has come up with a plan to strengthen
    its position in the gaming market. From industry knowledge and other business
    reports, it is evident that a very effective way to attract new customers is to
    develop a great reputation in the mobile game space. Given this fact, your company
    has the following plan: develop a strategy game for the iOS platform that will
    get a lot of positive attention, which in turn will bring a large number of new
    customers to the company. The company believes that this plan will work if and
    only if the game gets great ratings from users. Since you are an experienced individual
    in the mobile game space, you are asked to answer the following question: what
    types of strategy games have great user ratings?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of this activity is two-fold: first is to create a new variable based
    on the combination of two categorical variables. Then, use the `groupby` method
    to calculate descriptive statistics on the user ratings to see whether there is
    a relationship between the average user ratings and the newly created variable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Steps for completion:'
  prefs: []
  type: TYPE_NORMAL
- en: Load the `numpy` and `pandas` libraries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load the strategy games dataset (in the `data` folder of the chapter).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Perform all the transformations we did in the first section of the chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Change the names of the variables.
  prefs: []
  type: TYPE_NORMAL
- en: b. Set the column `id` to `index`.
  prefs: []
  type: TYPE_NORMAL
- en: c. Drop the `url` and `icon_url` columns.
  prefs: []
  type: TYPE_NORMAL
- en: d. Change `original_release_date` and `current_version_release_date` to `datetime`.
  prefs: []
  type: TYPE_NORMAL
- en: e. Eliminate the rows where `average_user_rating` is null from the DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: f. Keep in the DataFrame only the rows where `user_rating_count` is equal or
    greater than 30.
  prefs: []
  type: TYPE_NORMAL
- en: Print the dimensions of the dataset. You must have a DataFrame with 4,311 rows
    and 15 columns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Impute the missing values in the `languages` column with the string `EN` to
    indicate that those games are available only in English.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable called `free_game` that has the value of `free` if the game
    has a price of zero and `paid` if the price is above zero.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable called `multilingual` that has the values of `monolingual`
    if the language column has only one language string, and `multilingual` if the
    language column has at least two language strings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create one variable that contains the four combinations from the two variables
    created in the previous step (`free-monolingual`, `free-multilingual`, `paid-monolingual`,
    and `paid-multilingual`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate how many observations we have of each type in the `price_language`
    variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `groupby` method on the games DataFrame, group by the newly created
    variable, then select the `average_user_rating` variables and calculate the descriptive
    statistics.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 681.
  prefs: []
  type: TYPE_NORMAL
- en: In this activity, we have shown one approach to create a new categorical variable
    that results from the possible combinations of two other categorical variables.
    Then we have used the `groupby` method to calculate the descriptive statistics
    across the possible values of the newly created variable.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we learned about the first steps toward performing any kind
    of statistical analysis: first, we defined our business problem and introduced
    the dataset. Based on the problem we wanted to solve, we prepared the dataset
    accordingly: we deleted some records, imputed missing values, transformed the
    types of some variables, and created new ones. Then we learned about the need
    for descriptive statistics; we learned how easy it is to calculate them using
    pandas and how to use and interpret those calculations. In the final section,
    we learned about how we can combine visualizations with descriptive statistics
    to get a deeper understanding of the relationships between variables in our datasets.
    What we learned in this chapter are concepts and techniques that you will be able
    to put in practice in any data analysis you perform. However, to get more sophisticated
    in your analysis, you need to have a good grasp of the basics of probability theory,
    which is the subject of our next chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: QDN92
  prefs: []
  type: TYPE_NORMAL
- en: MWM57
  prefs: []
  type: TYPE_NORMAL
