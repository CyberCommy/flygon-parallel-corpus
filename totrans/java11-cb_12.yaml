- en: The Read-Evaluate-Print Loop (REPL) Using JShell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting familiar with REPL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating JShell and its commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluating code snippets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object-oriented programming in JShell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving and restoring the JShell command history
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the JShell Java API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**REPL** stands for the **Read-Evaluate-Print Loop** and, as the name states,
    it reads the command entered on the command line, evaluates it, prints the result
    of evaluation, and continues this process on any command entered.'
  prefs: []
  type: TYPE_NORMAL
- en: All the major languages, such as Ruby, Scala, Python, JavaScript, and Groovy,
    have REPL tools. Java was missing the much-needed REPL. If we had to try out some
    sample code, say using `SimpleDateFormat` to parse a string, we had to write a
    complete program with all the ceremonies, including creating a class, adding a
    main method, and then the single line of code we want to experiment with. Then,
    we have to compile and run the code. These ceremonies make it harder to experiment
    and learn the features of the language.
  prefs: []
  type: TYPE_NORMAL
- en: With a REPL, you can type only the line of code that you are interested in experimenting
    with and you will get immediate feedback on whether the expression is syntactically
    correct and gives the desired results. REPL is a very powerful tool, especially
    for people coming to the language for the first time. Suppose you want to show
    how to print *Hello World* in Java; for this, you'd have to start writing the
    class definition, then the `public static void main(String [] args)` method, and
    by the end of it, you would have explained or tried to explain a lot of concepts
    that would otherwise be difficult for a newbie to comprehend.
  prefs: []
  type: TYPE_NORMAL
- en: Anyways, with Java 9 and onward, Java developers can now stop whining about
    the absence of a REPL tool. A new REPL, called JShell, is being bundled with the
    JDK installation. So, we can now proudly write *Hello World* as our first *Hello
    World* code.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore the features of JShell and write code that
    will truly amaze us and appreciate the power of REPL. We will also see how we
    can create our own REPLs using the JShell Java API.
  prefs: []
  type: TYPE_NORMAL
- en: Getting familiar with REPL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will look at a few basic operations to help us get familiar
    with the JShell tool.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Make sure you have the latest JDK version installed, which has JShell. JShell
    is available from JDK 9 onward.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should have `%JAVA_HOME%/bin` (on Windows) or `$JAVA_HOME/bin` (on Linux)
    added to your `PATH` variable. If not, please visit the *Installing JDK 18.9 on
    Windows and setting up the PATH variable* and *Installing JDK 18.9 on Linux (Ubuntu,
    x64) and configuring the PATH variable* recipes in [Chapter 1](4dbea9e1-3ed8-4fcc-8e46-8a12457e3434.xhtml),
    *Installation and a Sneak Peek into Java 11*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the command line, type `jshell` and press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see a message and then a `jshell>` prompt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e2b2e440-013a-437a-b2fe-0667e558a108.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Forward slash(`/`)**,** followed by the JShell-supported commands, help you
    in interacting with JShell. Just like we try `/help intro` to get the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5c77960d-77a3-4adc-b739-afbe540bc99c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s print a `Hello World` message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/91029a86-a887-453e-b956-f2970368704a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s print a customized `Hello World` message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/446baf78-c749-42d9-9e80-b174d6a0168f.png)'
  prefs: []
  type: TYPE_IMG
- en: You can navigate through the executed commands using the up and down arrow keys.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code snippets entered at the `jshell` prompt are wrapped with just enough
    code to execute them. So, variable, method, and class declarations get wrapped
    within a class, and expressions get wrapped within a method which is in turn wrapped
    within the class. Other things, such as imports and class definitions, remain
    as they are because they are top-level entities, that is, wrapping a class definition
    within another class is not required as a class definition is a top-level entity
    that can exist by itself. Similarly, in Java, import statements can occur by themselves
    and they occur outside of a class declaration and hence need not be wrapped inside
    a class.
  prefs: []
  type: TYPE_NORMAL
- en: In the subsequent recipes, we will see how to define a method, import additional
    packages, and define classes.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding recipe, we saw `$1 ==> "Hello World"`. If we have some value
    without any variable associated with it, `jshell` gives it a variable name, such
    as `$1` or `$2`.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating JShell and its commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to leverage a tool, we need to be familiar with how to use it, the
    commands it provides, and the various shortcut keys that we can use to be productive.
    In this recipe, we will look at the different ways we can navigate through JShell
    and also at the different keyboard shortcuts it provides to be productive while
    using it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spawn JShell by typing `jshell` on the command line. You will be greeted with
    a welcome message that contains the instructions to get started.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type `/help intro` to get a brief introduction to JShell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b70a0a34-b052-4ee7-913d-280051978691.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Type `/help` to get a list of the supported commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/eaef19b9-06dc-4b27-a94f-e613306bf0cc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To get more information about a command, type `/help <command>`. For example,
    to get information about `/edit`, type `/help /edit`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9b27e73d-2cc1-4d0d-b575-201dfd8ad866.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There is autocompletion support in JShell. This makes Java developers feel
    at home. You can invoke auto-completion using the *Tab* key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/be642668-7b04-4b58-89a2-2377e5816a36.png)'
  prefs: []
  type: TYPE_IMG
- en: You can use `/!` to execute a previously executed command, and `/line_number`
    to re-execute an expression at the line number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To navigate the cursor through the command line, use *Ctrl* + *A* to reach the
    beginning of the line and *Ctrl* + *E* to reach the end of the line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Evaluating code snippets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will look at executing the following code snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: Import statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class declarations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface declarations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method declarations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Field declarations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the command line and launch JShell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By default, JShell imports a few libraries. We can check that by issuing the `/imports`
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/53d40193-23d2-4d38-9add-d41744f823a0.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's import `java.text.SimpleDateForm` by issuing the `import java.text.SimpleDateFormat`
    command. This imports the `SimpleDateFormat` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s declare an `Employee` class. We will issue one statement in each line
    so that it''s an incomplete statement, and we''ll proceed in the same way as we
    do in any ordinary editor. The following illustration will clarify this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f1891d8e-b111-4e17-8bfe-6507c85e19c3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s declare an `Employability` interface, which defines a method, `employable()`,
    as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding interface, when created via `jshell`, is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c9c87021-e754-422a-ae41-94d6894e703c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s declare a `newEmployee(String empId)` method, which constructs an `Employee`
    object with the given `empId`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding method defined in JShell is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9bd0dddc-3b37-433a-ad81-33da5acb6c52.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will use the method defined in the previous step to create a statement that
    declares an `Employee` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/8b923e7a-b343-4711-8557-b54d6aab68fe.png)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can invoke an undefined method. Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The image below shows the definition of `newMethod()` invoking `undefinedMethod()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a00c521-41c3-4a74-9c11-8cd8eb7e0b36.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, the method cannot be invoked before the method being used has been
    defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The below image shows the method `undefinedMethod()` being defined and then
    `newMethod()` can be successfully invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98ba3d0a-baba-47c9-aa22-c64fdbe1fde4.png)'
  prefs: []
  type: TYPE_IMG
- en: We can invoke `newMethod()` only after we have defined `undefinedMethod()`.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented programming in JShell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will make use of predefined Java class definition files and
    import them into JShell. Then, we will play around with those classes in JShell.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The class definition files we will use in this recipe are available in `Chapter12/4_oo_programming`,
    in the code downloads for this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are three class definition files: `Engine.java`, `Dimensions.java`, and
    `Car.java`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory where these three class definition files are available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `/open` command allows us to load the code from within a file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Load the `Engine` class definition and create an `Engine` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7b878742-330f-4cb5-aef2-7b8394a76bb2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Load the `Dimensions` class definition and create a `Dimensions` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4998d93c-85f2-4174-abe9-fbf9719054a0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Load the `Car` class definition and create a `Car` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d0ee5237-e262-4cd5-82f3-fa32cba224f5.png)'
  prefs: []
  type: TYPE_IMG
- en: Saving and restoring the JShell command history
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will want to try out some code snippets in `jshell` as a means to explain
    Java programming to someone who is new to it. Moreover, some form of record of
    what code snippets were executed will be useful for the person who is learning
    the language.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will execute a few code snippets and save them into a file.
    We will then load the code snippets from the saved file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s execute a series of code snippets, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3a9285e5-04ba-4e58-b76f-f9a75bf7c4a1.png)'
  prefs: []
  type: TYPE_IMG
- en: Save the code snippets executed into a file called `history` using the `/save
    history` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exit the shell using `/exit` and list the files in the directory by using `dir`
    or `ls`, depending on the OS. There will be a `history` file in the listing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `jshell` and check for the history of code snippets executed using `/list`.
    You will see that there are no code snippets executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Load the `history` file using `/open history` and then check for the history
    of the code snippets executed using `/list`. You will see all the previous code
    snippets being executed and added to the history:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/47ce2ead-0eb4-4a84-8a94-0b4c07917ad0.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the JShell Java API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JDK 11 provides the Java API for creating tools such as `jshell` for evaluating
    Java code snippets. This Java API is present in the `jdk.jshell` module ([http://cr.openjdk.java.net/~rfield/arch/doc/jdk/jshell/package-summary.html](http://cr.openjdk.java.net/~rfield/arch/doc/jdk/jshell/package-summary.html)).
    So, if you want to use the API in your application, you need to declare a dependency
    on the `jdk.jshell` module.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use the JShell JDK API to evaluate simple code snippets,
    and you'll also see different APIs to get the state of JShell. The idea is not
    to recreate JShell but to show how to make use of its JDK API.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we will not be using JShell; instead, we will follow the usual
    way of compiling using `javac` and running using `java`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our module will depend on the `jdk.jshell` module. So, the module definition
    will look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an instance of the `jdk.jshell.JShell` class by using its `create()`
    method or the builder API in `jdk.jshell.JShell.Builder`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Read the code snippet from `System.in` using `java.util.Scanner`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `jdk.jshell.JShell#eval(String snippet)` method to evaluate the input.
    The evaluation will result in a list of `jdk.jshell.SnippetEvent`, which contains
    the status and output of the evaluation. The `TODO` in the preceding code snippet
    will be replaced by the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When the evaluation is completed, we will print the snippets processed by using
    the `jdk.jshell.JShell.snippets()` method, which will return `Stream` of `Snippet`
    processed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can print the active method and variables, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Before the application exits, we close the `JShell` instance by invoking its
    `close()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for this recipe can be found in `Chapter12/6_jshell_api`. You can
    run the sample by using the `run.bat` or `run.sh` scripts available in the same
    directory. The sample execution and output are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/47744154-6e86-4218-b780-966a546e8b13.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The code snippets passed to the `JShell` evaluation engine are categorized
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Erroneous**: Syntactically incorrect input'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Expressions**: An input that might or might not result in some output'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Import**: An import statement'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Method**: A method declaration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Statement**: A statement'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type declaration**: A type, that is, class/interface declaration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Variable declaration**: A variable declaration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these categories are captured in the `jdk.jshell.Snippet.Kind` enum.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
