- en: Chapter 1. Demystifying Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices are an architecture style and an approach for software development
    to satisfy modern business demands. Microservices are not invented; they are more
    of an evolution from the previous architecture styles.
  prefs: []
  type: TYPE_NORMAL
- en: We will start the chapter by taking a closer look at the evolution of the microservices
    architecture from the traditional monolithic architectures. We will also examine
    the definition, concepts, and characteristics of microservices. Finally, we will
    analyze typical use cases of microservices and establish the similarities and
    relationships between microservices and other architecture approaches such as
    **Service Oriented Architecture** (**SOA**) and Twelve-Factor Apps. Twelve-Factor
    Apps defines a set of software engineering principles of developing applications
    targeting the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter you, will learn about:'
  prefs: []
  type: TYPE_NORMAL
- en: The evolution of microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The definition of the microservices architecture with examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concepts and characteristics of the microservices architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typical use cases of the microservices architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The relationship of microservices with SOA and Twelve-Factor Apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The evolution of microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices are one of the increasingly popular architecture patterns next
    to SOA, complemented by DevOps and cloud. The microservices evolution is greatly
    influenced by the disruptive digital innovation trends in modern business and
    the evolution of technologies in the last few years. We will examine these two
    factors in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Business demand as a catalyst for microservices evolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this era of digital transformation, enterprises increasingly adopt technologies
    as one of the key enablers for radically increasing their revenue and customer
    base. Enterprises primarily use social media, mobile, cloud, big data, and Internet
    of Things as vehicles to achieve the disruptive innovations. Using these technologies,
    enterprises find new ways to quickly penetrate the market, which severely pose
    challenges to the traditional IT delivery mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: The following graph shows the state of traditional development and microservices
    against the new enterprise challenges such as agility, speed of delivery, and
    scale.
  prefs: []
  type: TYPE_NORMAL
- en: '![Business demand as a catalyst for microservices evolution](img/B05447_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Microservices promise more agility, speed of delivery, and scale compared to
    traditional monolithic applications.
  prefs: []
  type: TYPE_NORMAL
- en: Gone are the days when businesses invested in large application developments
    with the turnaround time of a few years. Enterprises are no longer interested
    in developing consolidated applications to manage their end-to-end business functions
    as they did a few years ago.
  prefs: []
  type: TYPE_NORMAL
- en: The following graph shows the state of traditional monolithic applications and
    microservices in comparison with the turnaround time and cost.
  prefs: []
  type: TYPE_NORMAL
- en: '![Business demand as a catalyst for microservices evolution](img/B05447_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Microservices provide an approach for developing quick and agile applications,
    resulting in less overall cost.
  prefs: []
  type: TYPE_NORMAL
- en: Today, for instance, airlines or financial institutions do not invest in rebuilding
    their core mainframe systems as another monolithic monster. Retailers and other
    industries do not rebuild heavyweight supply chain management applications, such
    as their traditional ERPs. Focus has shifted to building quick-win point solutions
    that cater to specific needs of the business in the most agile way possible.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take an example of an online retailer running with a legacy monolithic
    application. If the retailer wants to innovate his/her sales by offering their
    products personalized to a customer based on the customer's past shopping, preferences,
    and so on and also wants to enlighten customers by offering products based on
    their propensity to buy them, they will quickly develop a personalization engine
    or offers based on their immediate needs and plug them into their legacy application.
  prefs: []
  type: TYPE_NORMAL
- en: '![Business demand as a catalyst for microservices evolution](img/B05447_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding diagram, rather than investing in rebuilding the core
    legacy system, this will be either done by passing the responses through the new
    functions, as shown in the diagram marked **A**, or by modifying the core legacy
    system to call out these functions as part of the processing, as shown in the
    diagram marked **B**. These functions are typically written as microservices.
  prefs: []
  type: TYPE_NORMAL
- en: This approach gives organizations a plethora of opportunities to quickly try
    out new functions with lesser cost in an experimental mode. Businesses can later
    validate key performance indicators and alter or replace these implementations
    if required.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Modern architectures are expected to maximize the ability to replace their parts
    and minimize the cost of replacing their parts. The microservices approach is
    a means to achieving this.
  prefs: []
  type: TYPE_NORMAL
- en: Technology as a catalyst for the microservices evolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Emerging technologies have also made us rethink the way we build software systems.
    For example, a few decades back, we couldn't even imagine a distributed application
    without a two-phase commit. Later, NoSQL databases made us think differently.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, these kinds of paradigm shifts in technology have reshaped all the
    layers of the software architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The emergence of HTML 5 and CSS3 and the advancement of mobile applications
    repositioned user interfaces. Client-side JavaScript frameworks such as Angular,
    Ember, React, Backbone, and so on are immensely popular due to their client-side
    rendering and responsive designs.
  prefs: []
  type: TYPE_NORMAL
- en: With cloud adoptions steamed into the mainstream, **Platform as a Services**
    (**PaaS**) providers such as Pivotal CF, AWS, Salesforce.com, IBMs Bluemix, RedHat
    OpenShift, and so on made us rethink the way we build middleware components. The
    container revolution created by Docker radically influenced the infrastructure
    space. These days, an infrastructure is treated as a commodity service.
  prefs: []
  type: TYPE_NORMAL
- en: The integration landscape has also changed with **Integration Platform as a
    Service** (**iPaaS**), which is emerging. Platforms such as Dell Boomi, Informatica,
    MuleSoft, and so on are examples of iPaaS. These tools helped organizations stretch
    integration boundaries beyond the traditional enterprise.
  prefs: []
  type: TYPE_NORMAL
- en: 'NoSQLs have revolutionized the databases space. A few years ago, we had only
    a few popular databases, all based on relational data modeling principles. We
    have a long list of databases today: Hadoop, Cassandra, CouchDB, and Neo 4j to
    name a few. Each of these databases addresses certain specific architectural problems.'
  prefs: []
  type: TYPE_NORMAL
- en: Imperative architecture evolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Application architecture has always been evolving alongside demanding business
    requirements and the evolution of technologies. Architectures have gone through
    the evolution of age-old mainframe systems to fully abstract cloud services such
    as AWS Lambda.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using AWS Lambda, developers can now drop their "functions" into a fully managed
    compute service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Read more about Lambda at: [https://aws.amazon.com/documentation/lambda/](https://aws.amazon.com/documentation/lambda/)'
  prefs: []
  type: TYPE_NORMAL
- en: Different architecture approaches and styles such as mainframes, client server,
    N-tier, and service-oriented were popular at different timeframes. Irrespective
    of the choice of architecture styles, we always used to build one or the other
    forms of monolithic architectures. The microservices architecture evolved as a
    result of modern business demands such as agility and speed of delivery, emerging
    technologies, and learning from previous generations of architectures.
  prefs: []
  type: TYPE_NORMAL
- en: '![Imperative architecture evolution](img/B05447_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Microservices help us break the boundaries of monolithic applications and build
    a logically independent smaller system of systems, as shown in the preceding diagram.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we consider monolithic applications as a set of logical subsystems encompassed
    with a physical boundary, microservices are a set of independent subsystems with
    no enclosing physical boundary.
  prefs: []
  type: TYPE_NORMAL
- en: What are microservices?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices are an architecture style used by many organizations today as
    a game changer to achieve a high degree of agility, speed of delivery, and scale.
    Microservices give us a way to develop more physically separated modular applications.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices are not invented. Many organizations such as Netflix, Amazon,
    and eBay successfully used the divide-and-conquer technique to functionally partition
    their monolithic applications into smaller atomic units, each performing a single
    function. These organizations solved a number of prevailing issues they were experiencing
    with their monolithic applications.
  prefs: []
  type: TYPE_NORMAL
- en: Following the success of these organizations, many other organizations started
    adopting this as a common pattern to refactor their monolithic applications. Later,
    evangelists termed this pattern as the microservices architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices originated from the idea of hexagonal architecture coined by Alistair
    Cockburn. Hexagonal architecture is also known as the Ports and Adapters pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Read more about hexagonal architecture at [http://alistair.cockburn.us/Hexagonal+architecture](http://alistair.cockburn.us/Hexagonal+architecture).
  prefs: []
  type: TYPE_NORMAL
- en: 'Microservices are an architectural style or an approach to building IT systems
    as a set of business capabilities that are autonomous, self-contained, and loosely
    coupled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What are microservices?](img/B05447_01_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram depicts a traditional N-tier application architecture
    having a presentation layer, business layer, and database layer. The modules **A**,
    **B**, and **C** represent three different business capabilities. The layers in
    the diagram represent a separation of architecture concerns. Each layer holds
    all three business capabilities pertaining to this layer. The presentation layer
    has web components of all the three modules, the business layer has business components
    of all the three modules, and the database hosts tables of all the three modules.
    In most cases, layers are physically spreadable, whereas modules within a layer
    are hardwired.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now examine a microservices-based architecture.
  prefs: []
  type: TYPE_NORMAL
- en: '![What are microservices?](img/B05447_01_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can note in the preceding diagram, the boundaries are inversed in the
    microservices architecture. Each vertical slice represents a microservice. Each
    microservice has its own presentation layer, business layer, and database layer.
    Microservices are aligned towards business capabilities. By doing so, changes
    to one microservice do not impact others.
  prefs: []
  type: TYPE_NORMAL
- en: There is no standard for communication or transport mechanisms for microservices.
    In general, microservices communicate with each other using widely adopted lightweight
    protocols, such as HTTP and REST, or messaging protocols, such as JMS or AMQP.
    In specific cases, one might choose more optimized communication protocols, such
    as Thrift, ZeroMQ, Protocol Buffers, or Avro.
  prefs: []
  type: TYPE_NORMAL
- en: As microservices are more aligned to business capabilities and have independently
    manageable life cycles, they are the ideal choice for enterprises embarking on
    DevOps and cloud. DevOps and cloud are two facets of microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: DevOps is an IT realignment to narrow the gap between traditional IT development
    and operations for better efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Read more about DevOps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://dev2ops.org/2010/02/what-is-devops/](http://dev2ops.org/2010/02/what-is-devops/)'
  prefs: []
  type: TYPE_NORMAL
- en: Microservices – the honeycomb analogy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The honeycomb is an ideal analogy for representing the evolutionary microservices
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: '![Microservices – the honeycomb analogy](img/B05447_01_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the real world, bees build a honeycomb by aligning hexagonal wax cells. They
    start small, using different materials to build the cells. Construction is based
    on what is available at the time of building. Repetitive cells form a pattern
    and result in a strong fabric structure. Each cell in the honeycomb is independent
    but also integrated with other cells. By adding new cells, the honeycomb grows
    organically to a big, solid structure. The content inside each cell is abstracted
    and not visible outside. Damage to one cell does not damage other cells, and bees
    can reconstruct these cells without impacting the overall honeycomb.
  prefs: []
  type: TYPE_NORMAL
- en: Principles of microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will examine some of the principles of the microservices
    architecture. These principles are a "must have" when designing and developing
    microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Single responsibility per service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The single responsibility principle is one of the principles defined as part
    of the SOLID design pattern. It states that a unit should only have one responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Read more about the SOLID design pattern at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://c2.com/cgi/wiki?PrinciplesOfObjectOrientedDesign](http://c2.com/cgi/wiki?PrinciplesOfObjectOrientedDesign)'
  prefs: []
  type: TYPE_NORMAL
- en: This implies that a unit, either a class, a function, or a service, should have
    only one responsibility. At no point should two units share one responsibility
    or one unit have more than one responsibility. A unit with more than one responsibility
    indicates tight coupling.
  prefs: []
  type: TYPE_NORMAL
- en: '![Single responsibility per service](img/B05447_01_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding diagram, **Customer**, **Product**, and **Order**
    are different functions of an e-commerce application. Rather than building all
    of them into one application, it is better to have three different services, each
    responsible for exactly one business function, so that changes to one responsibility
    will not impair others. In the preceding scenario, **Customer**, **Product**,
    and **Order** will be treated as three independent microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices are autonomous
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microservices are self-contained, independently deployable, and autonomous services
    that take full responsibility of a business capability and its execution. They
    bundle all dependencies, including library dependencies, and execution environments
    such as web servers and containers or virtual machines that abstract physical
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: One of the major differences between microservices and SOA is in their level
    of autonomy. While most SOA implementations provide service-level abstraction,
    microservices go further and abstract the realization and execution environment.
  prefs: []
  type: TYPE_NORMAL
- en: In traditional application developments, we build a WAR or an EAR, then deploy
    it into a JEE application server, such as with JBoss, WebLogic, WebSphere, and
    so on. We may deploy multiple applications into the same JEE container. In the
    microservices approach, each microservice will be built as a fat Jar, embedding
    all dependencies and run as a standalone Java process.
  prefs: []
  type: TYPE_NORMAL
- en: '![Microservices are autonomous](img/B05447_01_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Microservices may also get their own containers for execution, as shown in the
    preceding diagram. Containers are portable, independently manageable, lightweight
    runtime environments. Container technologies, such as Docker, are an ideal choice
    for microservices deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Characteristics of microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The microservices definition discussed earlier in this chapter is arbitrary.
    Evangelists and practitioners have strong but sometimes different opinions on
    microservices. There is no single, concrete, and universally accepted definition
    for microservices. However, all successful microservices implementations exhibit
    a number of common characteristics. Therefore, it is important to understand these
    characteristics rather than sticking to theoretical definitions. Some of the common
    characteristics are detailed in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Services are first-class citizens
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the microservices world, services are first-class citizens. Microservices
    expose service endpoints as APIs and abstract all their realization details. The
    internal implementation logic, architecture, and technologies (including programming
    language, database, quality of services mechanisms, and so on) are completely
    hidden behind the service API.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, in the microservices architecture, there is no more application development;
    instead, organizations focus on service development. In most enterprises, this
    requires a major cultural shift in the way that applications are built.
  prefs: []
  type: TYPE_NORMAL
- en: In a **Customer Profile** microservice, internals such as the data structure,
    technologies, business logic, and so on are hidden. They aren't exposed or visible
    to any external entities. Access is restricted through the service endpoints or
    APIs. For instance, Customer Profile microservices may expose **Register Customer**
    and **Get Customer** as two APIs for others to interact with.
  prefs: []
  type: TYPE_NORMAL
- en: Characteristics of services in a microservice
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As microservices are more or less like a flavor of SOA, many of the service
    characteristics defined in the SOA are applicable to microservices as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some of the characteristics of services that are applicable
    to microservices as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Service contract**: Similar to SOA, microservices are described through well-defined
    service contracts. In the microservices world, JSON and REST are universally accepted
    for service communication. In the case of JSON/REST, there are many techniques
    used to define service contracts. JSON Schema, WADL, Swagger, and RAML are a few
    examples.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Loose coupling**: Microservices are independent and loosely coupled. In most
    cases, microservices accept an event as input and respond with another event.
    Messaging, HTTP, and REST are commonly used for interaction between microservices.
    Message-based endpoints provide higher levels of decoupling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service abstraction**: In microservices, service abstraction is not just
    an abstraction of service realization, but it also provides a complete abstraction
    of all libraries and environment details, as discussed earlier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service reuse**: Microservices are course-grained reusable business services.
    These are accessed by mobile devices and desktop channels, other microservices,
    or even other systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Statelessness**: Well-designed microservices are stateless and share nothing
    with no shared state or conversational state maintained by the services. In case
    there is a requirement to maintain state, they are maintained in a database, perhaps
    in memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Services are discoverable**: Microservices are discoverable. In a typical
    microservices environment, microservices self-advertise their existence and make
    themselves available for discovery. When services die, they automatically take
    themselves out from the microservices ecosystem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service interoperability**: Services are interoperable as they use standard
    protocols and message exchange standards. Messaging, HTTP, and so on are used
    as transport mechanisms. REST/JSON is the most popular method for developing interoperable
    services in the microservices world. In cases where further optimization is required
    on communications, other protocols such as Protocol Buffers, Thrift, Avro, or
    Zero MQ could be used. However, the use of these protocols may limit the overall
    interoperability of the services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service composeability**: Microservices are composeable. Service composeability
    is achieved either through service orchestration or service choreography.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'More detail on SOA principles can be found at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://serviceorientation.com/serviceorientation/index](http://serviceorientation.com/serviceorientation/index)'
  prefs: []
  type: TYPE_NORMAL
- en: Microservices are lightweight
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Well-designed microservices are aligned to a single business capability, so
    they perform only one function. As a result, one of the common characteristics
    we see in most of the implementations are microservices with smaller footprints.
  prefs: []
  type: TYPE_NORMAL
- en: When selecting supporting technologies, such as web containers, we will have
    to ensure that they are also lightweight so that the overall footprint remains
    manageable. For example, Jetty or Tomcat are better choices as application containers
    for microservices compared to more complex traditional application servers such
    as WebLogic or WebSphere.
  prefs: []
  type: TYPE_NORMAL
- en: Container technologies such as Docker also help us keep the infrastructure footprint
    as minimal as possible compared to hypervisors such as VMWare or Hyper-V.
  prefs: []
  type: TYPE_NORMAL
- en: '![Microservices are lightweight](img/B05447_01_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding diagram, microservices are typically deployed in Docker
    containers, which encapsulate the business logic and needed libraries. This help
    us quickly replicate the entire setup on a new machine or on a completely different
    hosting environment or even to move across different cloud providers. As there
    is no physical infrastructure dependency, containerized microservices are easily
    portable.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices with polyglot architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As microservices are autonomous and abstract everything behind service APIs,
    it is possible to have different architectures for different microservices. A
    few common characteristics that we see in microservices implementations are:'
  prefs: []
  type: TYPE_NORMAL
- en: Different services use different versions of the same technologies. One microservice
    may be written on Java 1.7, and another one could be on Java 1.8.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different languages are used to develop different microservices, such as one
    microservice is developed in Java and another one in Scala.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different architectures are used, such as one microservice using the Redis cache
    to serve data, while another microservice could use MySQL as a persistent data
    store.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Microservices with polyglot architecture](img/B05447_01_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, as **Hotel Search** is expected to have high transaction
    volumes with stringent performance requirements, it is implemented using Erlang.
    In order to support predictive searching, Elasticsearch is used as the data store.
    At the same time, **Hotel Booking** needs more ACID transactional characteristics.
    Therefore, it is implemented using MySQL and Java. The internal implementations
    are hidden behind service endpoints defined as REST/JSON over HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: Automation in a microservices environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the microservices implementations are automated to a maximum from development
    to production.
  prefs: []
  type: TYPE_NORMAL
- en: As microservices break monolithic applications into a number of smaller services,
    large enterprises may see a proliferation of microservices. A large number of
    microservices is hard to manage until and unless automation is in place. The smaller
    footprint of microservices also helps us automate the microservices development
    to the deployment life cycle. In general, microservices are automated end to end—for
    example, automated builds, automated testing, automated deployment, and elastic
    scaling.
  prefs: []
  type: TYPE_NORMAL
- en: '![Automation in a microservices environment](img/B05447_01_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As indicated in the preceding diagram, automations are typically applied during
    the development, test, release, and deployment phases:'
  prefs: []
  type: TYPE_NORMAL
- en: The development phase is automated using version control tools such as Git together
    with **Continuous Integration** (**CI**) tools such as Jenkins, Travis CI, and
    so on. This may also include code quality checks and automation of unit testing.
    Automation of a full build on every code check-in is also achievable with microservices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The testing phase will be automated using testing tools such as Selenium, Cucumber,
    and other AB testing strategies. As microservices are aligned to business capabilities,
    the number of test cases to automate is fewer compared to monolithic applications,
    hence regression testing on every build also becomes possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infrastructure provisioning is done through container technologies such as Docker,
    together with release management tools such as Chef or Puppet, and configuration
    management tools such as Ansible. Automated deployments are handled using tools
    such as Spring Cloud, Kubernetes, Mesos, and Marathon.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices with a supporting ecosystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the large-scale microservices implementations have a supporting ecosystem
    in place. The ecosystem capabilities include DevOps processes, centralized log
    management, service registry, API gateways, extensive monitoring, service routing,
    and flow control mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: '![Microservices with a supporting ecosystem](img/B05447_01_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Microservices work well when supporting capabilities are in place, as represented
    in the preceding diagram.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices are distributed and dynamic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Successful microservices implementations encapsulate logic and data within
    the service. This results in two unconventional situations: distributed data and
    logic and decentralized governance.'
  prefs: []
  type: TYPE_NORMAL
- en: Compared to traditional applications, which consolidate all logic and data into
    one application boundary, microservices decentralize data and logic. Each service,
    aligned to a specific business capability, owns its data and logic.
  prefs: []
  type: TYPE_NORMAL
- en: '![Microservices are distributed and dynamic](img/B05447_01_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The dotted line in the preceding diagram implies the logical monolithic application
    boundary. When we migrate this to microservices, each microservice **A**, **B**,
    and **C** creates its own physical boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices don't typically use centralized governance mechanisms the way
    they are used in SOA. One of the common characteristics of microservices implementations
    is that they do not relay on heavyweight enterprise-level products, such as **Enterprise
    Service Bus** (**ESB**). Instead, the business logic and intelligence are embedded
    as a part of the services themselves.
  prefs: []
  type: TYPE_NORMAL
- en: '![Microservices are distributed and dynamic](img/B05447_01_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A typical SOA implementation is shown in the preceding diagram. Shopping logic
    is fully implemented in ESB by orchestrating different services exposed by Customer,
    Order, and Product. In the microservices approach, on the other hand, Shopping
    itself will run as a separate microservice, which interacts with Customer, Product,
    and Order in a fairly decoupled way.
  prefs: []
  type: TYPE_NORMAL
- en: SOA implementations heavily relay on static registry and repository configurations
    to manage services and other artifacts. Microservices bring a more dynamic nature
    into this. Hence, a static governance approach is seen as an overhead in maintaining
    up-to-date information. This is why most of the microservices implementations
    use automated mechanisms to build registry information dynamically from the runtime
    topologies.
  prefs: []
  type: TYPE_NORMAL
- en: Antifragility, fail fast, and self-healing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Antifragility is a technique successfully experimented at Netflix. It is one
    of the most powerful approaches to building fail-safe systems in modern software
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The antifragility concept is introduced by Nassim Nicholas Taleb in his book
    *Antifragile: Things That Gain from Disorder*.'
  prefs: []
  type: TYPE_NORMAL
- en: In the antifragility practice, software systems are consistently challenged.
    Software systems evolve through these challenges and, over a period of time, get
    better and better at withstanding these challenges. Amazon's GameDay exercise
    and Netflix' Simian Army are good examples of such antifragility experiments.
  prefs: []
  type: TYPE_NORMAL
- en: Fail fast is another concept used to build fault-tolerant, resilient systems.
    This philosophy advocates systems that expect failures versus building systems
    that never fail. Importance should be given to how quickly the system can fail
    and if it fails, how quickly it can recover from this failure. With this approach,
    the focus is shifted from **Mean Time Between Failures** (**MTBF**) to **Mean
    Time To Recover** (**MTTR**). A key advantage of this approach is that if something
    goes wrong, it kills itself, and downstream functions aren't stressed.
  prefs: []
  type: TYPE_NORMAL
- en: Self-healing is commonly used in microservices deployments, where the system
    automatically learns from failures and adjusts itself. These systems also prevent
    future failures.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is no "one size fits all" approach when implementing microservices. In
    this section, different examples are analyzed to crystalize the microservices
    concept.
  prefs: []
  type: TYPE_NORMAL
- en: An example of a holiday portal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the first example, we will review a holiday portal, **Fly By Points**. Fly
    By Points collects points that are accumulated when a customer books a hotel,
    flight, or car through the online website. When the customer logs in to the Fly
    By Points website, he/she is able to see the points accumulated, personalized
    offers that can be availed of by redeeming the points, and upcoming trips if any.
  prefs: []
  type: TYPE_NORMAL
- en: '![An example of a holiday portal](img/B05447_01_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's assume that the preceding page is the home page after login. There are
    two upcoming trips for **Jeo**, four personalized offers, and 21,123 loyalty points.
    When the user clicks on each of the boxes, the details are queried and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The holiday portal has a Java Spring-based traditional monolithic application
    architecture, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An example of a holiday portal](img/B05447_01_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding diagram, the holiday portal's architecture is web-based
    and modular, with a clear separation between layers. Following the usual practice,
    the holiday portal is also deployed as a single WAR file on a web server such
    as Tomcat. Data is stored on an all-encompassing backing relational database.
    This is a good fit for the purpose architecture when the complexities are few.
    As the business grows, the user base expands, and the complexity also increases.
    This results in a proportional increase in transaction volumes. At this point,
    enterprises should look to rearchitecting the monolithic application to microservices
    for better speed of delivery, agility, and manageability.
  prefs: []
  type: TYPE_NORMAL
- en: '![An example of a holiday portal](img/B05447_01_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Examining the simple microservices version of this application, we can immediately
    note a few things in this architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each subsystem has now become an independent system by itself, a microservice.
    There are three microservices representing three business functions: **Trips**,
    **Offers**, and **Points**. Each one has its internal data store and middle layer.
    The internal structure of each service remains the same.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each service encapsulates its own database as well as its own HTTP listener.
    As opposed to the previous model, there is no web server or WAR. Instead, each
    service has its own embedded HTTP listener, such as Jetty, Tomcat, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each microservice exposes a REST service to manipulate the resources/entity
    that belong to this service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is assumed that the presentation layer is developed using a client-side JavaScript
    MVC framework such as Angular JS. These client-side frameworks are capable of
    invoking REST calls directly.
  prefs: []
  type: TYPE_NORMAL
- en: When the web page is loaded, all the three boxes, Trips, Offers, and Points
    will be displayed with details such as points, the number of offers, and the number
    of trips. This will be done by each box independently making asynchronous calls
    to the respective backend microservices using REST. There is no dependency between
    the services at the service layer. When the user clicks on any of the boxes, the
    screen will be transitioned and will load the details of the item clicked on.
    This will be done by making another call to the respective microservice.
  prefs: []
  type: TYPE_NORMAL
- en: A microservice-based order management system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s examine another microservices example: an online retail website. In
    this case, we will focus more on the backend services, such as the Order Service
    which processes the Order Event generated when a customer places an order through
    the website:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A microservice-based order management system](img/B05447_01_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This microservices system is completely designed based on reactive programming
    practices.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Read more on reactive programming at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.reactivemanifesto.org](http://www.reactivemanifesto.org)'
  prefs: []
  type: TYPE_NORMAL
- en: When an event is published, a number of microservices are ready to kick-start
    upon receiving the event. Each one of them is independent and does not rely on
    other microservices. The advantage of this model is that we can keep adding or
    replacing microservices to achieve specific needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding diagram, there are eight microservices shown. The following
    activities take place upon the arrival of **Order Event**:'
  prefs: []
  type: TYPE_NORMAL
- en: Order Service kicks off when Order Event is received. Order Service creates
    an order and saves the details to its own database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the order is successfully saved, Order Successful Event is created by Order
    Service and published.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A series of actions take place when Order Successful Event arrives.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delivery Service accepts the event and places Delivery Record to deliver the
    order to the customer. This, in turn, generates Delivery Event and publishes the
    event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Trucking Service picks up Delivery Event and processes it. For instance, Trucking
    Service creates a trucking plan.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Customer Notification Service sends a notification to the customer informing
    the customer that an order is placed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inventory Cache Service updates the inventory cache with the available product
    count.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stock Reorder Service checks whether the stock limits are adequate and generates
    Replenish Event if required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Customer Points Service recalculates the customer's loyalty points based on
    this purchase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Customer Account Service** updates the order history in the customer''s account.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this approach, each service is responsible for only one function. Services
    accept and generate events. Each service is independent and is not aware of its
    neighborhood. Hence, the neighborhood can organically grow as mentioned in the
    honeycomb analogy. New services can be added as and when necessary. Adding a new
    service does not impact any of the existing services.
  prefs: []
  type: TYPE_NORMAL
- en: An example of a travel agent portal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This third example is a simple travel agent portal application. In this example,
    we will see both synchronous REST calls as well as asynchronous events.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the portal is just a container application with multiple menu
    items or links in the portal. When specific pages are requested—for example, when
    the menu or a link is clicked on—they will be loaded from the specific microservices.
  prefs: []
  type: TYPE_NORMAL
- en: '![An example of a travel agent portal](img/B05447_01_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When a customer requests a booking, the following events take place internally:'
  prefs: []
  type: TYPE_NORMAL
- en: The travel agent opens the flight UI, searches for a flight, and identifies
    the right flight for the customer. Behind the scenes, the flight UI is loaded
    from the Flight microservice. The flight UI only interacts with its own backend
    APIs within the Flight microservice. In this case, it makes a REST call to the
    Flight microservice to load the flights to be displayed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The travel agent then queries the customer details by accessing the customer
    UI. Similar to the flight UI, the customer UI is loaded from the Customer microservice.
    Actions in the customer UI will invoke REST calls on the Customer microservice.
    In this case, customer details are loaded by invoking appropriate APIs on the
    Customer microservice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, the travel agent checks the visa details for the customer's eligibility
    to travel to the selected country. This also follows the same pattern as mentioned
    in the previous two points.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, the travel agent makes a booking using the booking UI from the Booking
    microservice, which again follows the same pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The payment pages are loaded from the Payment microservice. In general, the
    payment service has additional constraints such as PCIDSS compliance (protecting
    and encrypting data in motion and data at rest). The advantage of the microservices
    approach is that none of the other microservices need to be considered under the
    purview of PCIDSS as opposed to the monolithic application, where the complete
    application comes under the governing rules of PCIDSS. Payment also follows the
    same pattern as described earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the booking is submitted, the Booking microservice calls the flight service
    to validate and update the flight booking. This orchestration is defined as part
    of the Booking microservice. Intelligence to make a booking is also held within
    the Booking microservice. As part of the booking process, it also validates, retrieves,
    and updates the Customer microservice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the Booking microservice sends the Booking Event, which the Notification
    service picks up and sends a notification of to the customer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The interesting factor here is that we can change the user interface, logic,
    and data of a microservice without impacting any other microservices.
  prefs: []
  type: TYPE_NORMAL
- en: This is a clean and neat approach. A number of portal applications can be built
    by composing different screens from different microservices, especially for different
    user communities. The overall behavior and navigation will be controlled by the
    portal application.
  prefs: []
  type: TYPE_NORMAL
- en: The approach has a number of challenges unless the pages are designed with this
    approach in mind. Note that the site layouts and static content will be loaded
    by the **Content Management System** (**CMS**) as layout templates. Alternately,
    this could be stored in a web server. The site layout may have fragments of UIs
    that will be loaded from the microservices at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices benefits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices offer a number of benefits over the traditional multitier, monolithic
    architectures. This section explains some key benefits of the microservices architecture
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: Supports polyglot architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With microservices, architects and developers can choose fit for purpose architectures
    and technologies for each microservice. This gives the flexibility to design better-fit
    solutions in a more cost-effective way.
  prefs: []
  type: TYPE_NORMAL
- en: As microservices are autonomous and independent, each service can run with its
    own architecture or technology or different versions of technologies.
  prefs: []
  type: TYPE_NORMAL
- en: The following shows a simple, practical example of a polyglot architecture with
    microservices.
  prefs: []
  type: TYPE_NORMAL
- en: '![Supports polyglot architecture](img/B05447_01_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There is a requirement to audit all system transactions and record transaction
    details such as request and response data, the user who initiated the transaction,
    the service invoked, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding diagram, while core services such as the Order and
    Products microservices use a relational data store, the Audit microservice persists
    data in Hadoop File System (HDFS). A relational data store is neither ideal nor
    cost effective in storing large data volumes such as in the case of audit data.
    In the monolithic approach, the application generally uses a shared, single database
    that stores Order, Products, and Audit data.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the audit service is a technical microservice using a different
    architecture. Similarly, different functional services could also use different
    architectures.
  prefs: []
  type: TYPE_NORMAL
- en: In another example, there could be a Reservation microservice running on Java
    7, while a Search microservice could be running on Java 8\. Similarly, an Order
    microservice could be written on Erlang, whereas a Delivery microservice could
    be on the Go language. None of these are possible with a monolithic architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling experimentation and innovation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modern enterprises are thriving towards quick wins. Microservices are one of
    the key enablers for enterprises to do disruptive innovation by offering the ability
    to experiment and fail fast.
  prefs: []
  type: TYPE_NORMAL
- en: As services are fairly simple and smaller in size, enterprises can afford to
    experiment new processes, algorithms, business logics, and so on. With large monolithic
    applications, experimentation was not easy; nor was it straightforward or cost
    effective. Businesses had to spend huge money to build or change an application
    to try out something new. With microservices, it is possible to write a small
    microservice to achieve the targeted functionality and plug it into the system
    in a reactive style. One can then experiment with the new function for a few months,
    and if the new microservice does not work as expected, we can change or replace
    it with another one. The cost of change will be considerably less compared to
    that of the monolithic approach.
  prefs: []
  type: TYPE_NORMAL
- en: '![Enabling experimentation and innovation](img/B05447_01_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In another example of an airline booking website, the airline wants to show
    personalized hotel recommendations in their booking page. The recommendations
    must be displayed on the booking confirmation page.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding diagram, it is convenient to write a microservice
    that can be plugged into the monolithic applications booking flow rather than
    incorporating this requirement in the monolithic application itself. The airline
    may choose to start with a simple recommendation service and keep replacing it
    with newer versions till it meets the required accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: Elastically and selectively scalable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As microservices are smaller units of work, they enable us to implement selective
    scalability.
  prefs: []
  type: TYPE_NORMAL
- en: Scalability requirements may be different for different functions in an application.
    A monolithic application, packaged as a single WAR or an EAR, can only be scaled
    as a whole. An I/O-intensive function when streamed with high velocity data could
    easily bring down the service levels of the entire application.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of microservices, each service could be independently scaled up
    or down. As scalability can be selectively applied at each service, the cost of
    scaling is comparatively less with the microservices approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, there are many different ways available to scale an application
    and is largely subject to the architecture and behavior of the application. **Scale
    Cube** defines primarily three approaches to scaling an application:'
  prefs: []
  type: TYPE_NORMAL
- en: Scaling the *x* axis by horizontally cloning the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling the *y* axis by splitting different functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling the *z* axis by partitioning or sharding the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Read more about Scale Cube in the following site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://theartofscalability.com/](http://theartofscalability.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: When *y* axis scaling is applied to monolithic applications, it breaks the monolithic
    to smaller units aligned with business functions. Many organizations successfully
    applied this technique to move away from monolithic applications. In principle,
    the resulting units of functions are in line with the microservices characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, in a typical airline website, statistics indicate that the ratio
    of flight searching to flight booking could be as high as 500:1\. This means one
    booking transaction for every 500 search transactions. In this scenario, the search
    needs 500 times more scalability than the booking function. This is an ideal use
    case for selective scaling.
  prefs: []
  type: TYPE_NORMAL
- en: '![Elastically and selectively scalable](img/B05447_01_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The solution is to treat search requests and booking requests differently. With
    a monolithic architecture, this is only possible with *z* scaling in the scale
    cube. However, this approach is expensive because in the *z* scale, the entire
    code base is replicated.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, Search and Booking are designed as different microservices
    so that Search can be scaled differently from Booking. In the diagram, Search
    has three instances, and Booking has two instances. Selective scalability is not
    limited to the number of instances, as shown in the diagram, but also in the way
    in which the microservices are architected. In the case of Search, an **in-memory
    data grid** (**IMDG**) such as Hazelcast can be used as the data store. This will
    further increase the performance and scalability of Search. When a new Search
    microservice instance is instantiated, an additional IMDG node is added to the
    IMDG cluster. Booking does not require the same level of scalability. In the case
    of Booking, both instances of the Booking microservice are connected to the same
    instance of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing substitution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microservices are self-contained, independent deployment modules enabling the
    substitution of one microservice with another similar microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Many large enterprises follow buy-versus-build policies to implement software
    systems. A common scenario is to build most of the functions in house and buy
    certain niche capabilities from specialists outside. This poses challenges in
    traditional monolithic applications as these application components are highly
    cohesive. Attempting to plug in third-party solutions to the monolithic applications
    results in complex integrations. With microservices, this is not an afterthought.
    Architecturally, a microservice can be easily replaced by another microservice
    developed either in-house or even extended by a microservice from a third party.
  prefs: []
  type: TYPE_NORMAL
- en: '![Allowing substitution](img/B05447_01_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A pricing engine in the airline business is complex. Fares for different routes
    are calculated using complex mathematical formulas known as the pricing logic.
    Airlines may choose to buy a pricing engine from the market instead of building
    the product in house. In the monolithic architecture, Pricing is a function of
    Fares and Booking. In most cases Pricing, Fares, and Booking are hardwired, making
    it almost impossible to detach.
  prefs: []
  type: TYPE_NORMAL
- en: In a well-designed microservices system, Booking, Fares, and Pricing would be
    independent microservices. Replacing the Pricing microservice will have only a
    minimal impact on any other services as they are all loosely coupled and independent.
    Today, it could be a third-party service; tomorrow, it could be easily substituted
    by another third-party or home-grown service.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling to build organic systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microservices help us build systems that are organic in nature. This is significantly
    important when migrating monolithic systems gradually to microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Organic systems are systems that grow laterally over a period of time by adding
    more and more functions to it. In practice, an application grows unimaginably
    large in its lifespan, and in most cases, the manageability of the application
    reduces dramatically over this same period of time.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices are all about independently manageable services. This enable us
    to keep adding more and more services as the need arises with minimal impact on
    the existing services. Building such systems does not need huge capital investments.
    Hence, businesses can keep building as part of their operational expenditure.
  prefs: []
  type: TYPE_NORMAL
- en: A loyalty system in an airline was built years ago, targeting individual passengers.
    Everything was fine until the airline started offering loyalty benefits to their
    corporate customers. Corporate customers are individuals grouped under corporations.
    As the current systems core data model is flat, targeting individuals, the corporate
    environment needs a fundamental change in the core data model, and hence huge
    reworking, to incorporate this requirement.
  prefs: []
  type: TYPE_NORMAL
- en: '![Enabling to build organic systems](img/B05447_01_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding diagram, in a microservices-based architecture, customer
    information would be managed by the Customer microservice and loyalty by the Loyalty
    Points microservice.
  prefs: []
  type: TYPE_NORMAL
- en: In this situation, it is easy to add a new Corporate Customer microservice to
    manage corporate customers. When a corporation is registered, individual members
    will be pushed to the Customer microservice to manage them as usual. The Corporate
    Customer microservice provides a corporate view by aggregating data from the Customer
    microservice. It will also provide services to support corporate-specific business
    rules. With this approach, adding new services will have only a minimal impact
    on the existing services.
  prefs: []
  type: TYPE_NORMAL
- en: Helping reducing technology debt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As microservices are smaller in size and have minimal dependencies, they allow
    the migration of services that use end-of-life technologies with minimal cost.
  prefs: []
  type: TYPE_NORMAL
- en: Technology changes are one of the barriers in software development. In many
    traditional monolithic applications, due to the fast changes in technologies,
    today's next-generation applications could easily become legacy even before their
    release to production. Architects and developers tend to add a lot of protection
    against technology changes by adding layers of abstractions. However, in reality,
    this approach does not solve the issue but, instead, results in over-engineered
    systems. As technology upgrades are often risky and expensive with no direct returns
    to business, the business may not be happy to invest in reducing the technology
    debt of the applications.
  prefs: []
  type: TYPE_NORMAL
- en: With microservices, it is possible to change or upgrade technology for each
    service individually rather than upgrading an entire application.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading an application with, for instance, five million lines written on EJB
    1.1 and Hibernate to the Spring, JPA, and REST services is almost similar to rewriting
    the entire application. In the microservices world, this could be done incrementally.
  prefs: []
  type: TYPE_NORMAL
- en: '![Helping reducing technology debt](img/B05447_01_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding diagram, while older versions of the services are
    running on old versions of technologies, new service developments can leverage
    the latest technologies. The cost of migrating microservices with end-of-life
    technologies is considerably less compared to enhancing monolithic applications.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing the coexistence of different versions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As microservices package the service runtime environment along with the service
    itself, this enables having multiple versions of the service to coexist in the
    same environment.
  prefs: []
  type: TYPE_NORMAL
- en: There will be situations where we will have to run multiple versions of the
    same service at the same time. Zero downtime promote, where one has to gracefully
    switch over from one version to another, is one example of a such a scenario as
    there will be a time window where both services will have to be up and running
    simultaneously. With monolithic applications, this is a complex procedure because
    upgrading new services in one node of the cluster is cumbersome as, for instance,
    this could lead to class loading issues. A canary release, where a new version
    is only released to a few users to validate the new service, is another example
    where multiple versions of the services have to coexist.
  prefs: []
  type: TYPE_NORMAL
- en: With microservices, both these scenarios are easily manageable. As each microservice
    uses independent environments, including service listeners such as Tomcat or Jetty
    embedded, multiple versions can be released and gracefully transitioned without
    many issues. When consumers look up services, they look for specific versions
    of services. For example, in a canary release, a new user interface is released
    to user A. When user A sends a request to the microservice, it looks up the canary
    release version, whereas all other users will continue to look up the last production
    version.
  prefs: []
  type: TYPE_NORMAL
- en: Care needs to be taken at the database level to ensure the database design is
    always backward compatible to avoid breaking the changes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Allowing the coexistence of different versions](img/B05447_01_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding diagram, version 1 and 2 of the **Customer** service
    can coexist as they are not interfering with each other, given their respective
    deployment environments. Routing rules can be set at the gateway to divert traffic
    to specific instances, as shown in the diagram. Alternatively, clients can request
    specific versions as part of the request itself. In the diagram, the gateway selects
    the version based on the region from which the request is originated.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting the building of self-organizing systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microservices help us build self-organizing systems. A self-organizing system
    support will automate deployment, be resilient, and exhibit self-healing and self-learning
    capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: In a well-architected microservices system, a service is unaware of other services.
    It accepts a message from a selected queue and processes it. At the end of the
    process, it may send out another message, which triggers other services. This
    allows us to drop any service into the ecosystem without analyzing the impact
    on the overall system. Based on the input and output, the service will self-organize
    into the ecosystem. No additional code changes or service orchestration is required.
    There is no central brain to control and coordinate the processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine an existing notification service that listens to an **INPUT** queue
    and sends notifications to an **SMTP** server, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Supporting the building of self-organizing systems](img/B05447_01_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's assume, later, a personalization engine, responsible for changing the
    language of the message to the customer's native language, needs to be introduced
    to personalize messages before sending them to the customer, the personalization
    engine is responsible for changing the language of the message to the customer's
    native language.
  prefs: []
  type: TYPE_NORMAL
- en: '![Supporting the building of self-organizing systems](img/B05447_01_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With microservices, a new personalization microservice will be created to do
    this job. The input queue will be configured as INPUT in an external configuration
    server, and the personalization service will pick up the messages from the INPUT
    queue (earlier, this was used by the notification service) and send the messages
    to the OUTPUT queue after completing process. The notification services input
    queue will then send to OUTPUT. From the very next moment onward, the system automatically
    adopts this new message flow.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting event-driven architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microservices enable us to develop transparent software systems. Traditional
    systems communicate with each other through native protocols and hence behave
    like a black box application. Business events and system events, unless published
    explicitly, are hard to understand and analyze. Modern applications require data
    for business analysis, to understand dynamic system behaviors, and analyze market
    trends, and they also need to respond to real-time events. Events are useful mechanisms
    for data extraction.
  prefs: []
  type: TYPE_NORMAL
- en: A well-architected microservice always works with events for both input and
    output. These events can be tapped by any service. Once extracted, events can
    be used for a variety of use cases.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the business wants to see the velocity of orders categorized by
    product type in real time. In a monolithic system, we need to think about how
    to extract these events. This may impose changes in the system.
  prefs: []
  type: TYPE_NORMAL
- en: '![Supporting event-driven architecture](img/B05447_01_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the microservices world, **Order Event** is already published whenever an
    order is created. This means that it is just a matter of adding a new service
    to subscribe to the same topic, extract the event, perform the requested aggregations,
    and push another event for the dashboard to consume.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling DevOps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microservices are one of the key enablers of DevOps. DevOps is widely adopted
    as a practice in many enterprises, primarily to increase the speed of delivery
    and agility. A successful adoption of DevOps requires cultural changes, process
    changes, as well as architectural changes. DevOps advocates to have agile development,
    high-velocity release cycles, automatic testing, automatic infrastructure provisioning,
    and automated deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Automating all these processes is extremely hard to achieve with traditional
    monolithic applications. Microservices are not the ultimate answer, but microservices
    are at the center stage in many DevOps implementations. Many DevOps tools and
    techniques are also evolving around the use of microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a monolithic application that takes hours to complete a full build
    and 20 to 30 minutes to start the application; one can see that this kind of application
    is not ideal for DevOps automation. It is hard to automate continuous integration
    on every commit. As large, monolithic applications are not automation friendly,
    continuous testing and deployments are also hard to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, small footprint microservices are more automation-friendly
    and therefore can more easily support these requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices also enable smaller, focused agile teams for development. Teams
    will be organized based on the boundaries of microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Relationship with other architecture styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have seen the characteristics and benefits of microservices, in
    this section, we will explore the relationship of microservices with other closely
    related architecture styles such as SOA and Twelve-Factor Apps.
  prefs: []
  type: TYPE_NORMAL
- en: Relations with SOA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SOA and microservices follow similar concepts. Earlier in this chapter, we discussed
    that microservices are evolved from SOA, and many service characteristics are
    common in both approaches.
  prefs: []
  type: TYPE_NORMAL
- en: However, are they the same or are they different?
  prefs: []
  type: TYPE_NORMAL
- en: As microservices are evolved from SOA, many characteristics of microservices
    are similar to SOA. Let's first examine the definition of SOA.
  prefs: []
  type: TYPE_NORMAL
- en: 'The definition of SOA from *The Open Group* consortium is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Service-Oriented Architecture (SOA) is an architectural style that supports
    service orientation. Service orientation is a way of thinking in terms of services
    and service-based development and the outcomes of services.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: 'A service:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: Is a logical representation of a repeatable business activity that has a specified
    outcome (e.g., check customer credit, provide weather data, consolidate drilling
    reports)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: It is self-contained.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: It may be composed of other services.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: It is a "black box" to consumers of the service."
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We observed similar aspects in microservices as well. So, in what way are microservices
    different? The answer is: it depends.'
  prefs: []
  type: TYPE_NORMAL
- en: The answer to the previous question could be yes or no, depending upon the organization
    and its adoption of SOA. SOA is a broader term, and different organizations approached
    SOA differently to solve different organizational problems. The difference between
    microservices and SOA is in a way based on how an organization approaches SOA.
  prefs: []
  type: TYPE_NORMAL
- en: In order to get clarity, a few cases will be examined.
  prefs: []
  type: TYPE_NORMAL
- en: Service-oriented integration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Service-oriented integration refers to a service-based integration approach
    used by many organizations.
  prefs: []
  type: TYPE_NORMAL
- en: '![Service-oriented integration](img/B05447_01_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Many organizations would have used SOA primarily to solve their integration
    complexities, also known as integration spaghetti. Generally, this is termed as
    **Service-Oriented Integration** (**SOI**). In such cases, applications communicate
    with each other through a common integration layer using standard protocols and
    message formats such as SOAP/XML-based web services over HTTP or JMS. These types
    of organizations focus on **Enterprise Integration Patterns** (**EIP**) to model
    their integration requirements. This approach strongly relies on heavyweight ESB
    such as TIBCO Business Works, WebSphere ESB, Oracle ESB, and the likes. Most ESB
    vendors also packed a set of related products such as rules engines, business
    process management engines, and so on as an SOA suite. Such organizations' integrations
    are deeply rooted into their products. They either write heavy orchestration logic
    in the ESB layer or the business logic itself in the service bus. In both cases,
    all enterprise services are deployed and accessed via ESB. These services are
    managed through an enterprise governance model. For such organizations, microservices
    are altogether different from SOA.
  prefs: []
  type: TYPE_NORMAL
- en: Legacy modernization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SOA is also used to build service layers on top of legacy applications.
  prefs: []
  type: TYPE_NORMAL
- en: '![Legacy modernization](img/B05447_01_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Another category of organizations would use SOA in transformation projects or
    legacy modernization projects. In such cases, the services are built and deployed
    in the ESB layer connecting to backend systems using ESB adapters. For these organizations,
    microservices are different from SOA.
  prefs: []
  type: TYPE_NORMAL
- en: Service-oriented application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some organizations adopt SOA at an application level.
  prefs: []
  type: TYPE_NORMAL
- en: '![Service-oriented application](img/B05447_01_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this approach, lightweight integration frameworks, such as Apache Camel or
    Spring Integration, are embedded within applications to handle service-related
    cross-cutting capabilities such as protocol mediation, parallel execution, orchestration,
    and service integration. As some of the lightweight integration frameworks have
    native Java object support, such applications would even use native **Plain Old
    Java Objects** (**POJO**) services for integration and data exchange between services.
    As a result, all services have to be packaged as one monolithic web archive. Such
    organizations could see microservices as the next logical step of their SOA.
  prefs: []
  type: TYPE_NORMAL
- en: Monolithic migration using SOA
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![Monolithic migration using SOA](img/B05447_01_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last possibility is transforming a monolithic application into smaller units
    after hitting the breaking point with the monolithic system. They would break
    the application into smaller, physically deployable subsystems, similar to the
    *y* axis scaling approach explained earlier, and deploy them as web archives on
    web servers or as JARs deployed on some home-grown containers. These subsystems
    as service would use web services or other lightweight protocols to exchange data
    between services. They would also use SOA and service design principles to achieve
    this. For such organizations, they may tend to think that microservices are the
    same old wine in a new bottle.
  prefs: []
  type: TYPE_NORMAL
- en: Relations with Twelve-Factor apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cloud computing is one of the rapidly evolving technologies. Cloud computing
    promises many benefits, such as cost advantage, speed, agility, flexibility, and
    elasticity. There are many cloud providers offering different services. They lower
    the cost models to make it more attractive to the enterprises. Different cloud
    providers such as AWS, Microsoft, Rackspace, IBM, Google, and so on use different
    tools, technologies, and services. On the other hand, enterprises are aware of
    this evolving battlefield and, therefore, they are looking for options for de-risking
    from lockdown to a single vendor.
  prefs: []
  type: TYPE_NORMAL
- en: Many organizations do lift and shift their applications to the cloud. In such
    cases, the applications may not realize all the benefits promised by cloud platforms.
    Some applications need to undergo overhaul, whereas some may need minor tweaking
    before moving to cloud. This by and large depends upon how the application is
    architected and developed.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if the application has its production database server URLs hardcoded
    as part of the applications WAR, it needs to be modified before moving the application
    to cloud. In the cloud, the infrastructure is transparent to the application,
    and especially, the physical IP addresses cannot be assumed.
  prefs: []
  type: TYPE_NORMAL
- en: How do we ensure that an application, or even microservices, can run seamlessly
    across multiple cloud providers and take advantages of cloud services such as
    elasticity?
  prefs: []
  type: TYPE_NORMAL
- en: It is important to follow certain principles while developing cloud native applications.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Cloud native is a term used for developing applications that can work efficiently
    in a cloud environment, understanding and utilizing cloud behaviors such as elasticity,
    utilization based charging, fail aware, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Twelve-Factor App, forwarded by Heroku, is a methodology describing the characteristics
    expected from modern cloud-ready applications. Twelve-Factor App is equally applicable
    for microservices as well. Hence, it is important to understand Twelve-Factor
    App.
  prefs: []
  type: TYPE_NORMAL
- en: A single code base
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code base principle advises that each application has a single code base.
    There can be multiple instances of deployment of the same code base, such as development,
    testing, and production. Code is typically managed in a source control system
    such as Git, Subversion, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '![A single code base](img/B05447_01_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Extending the same philosophy for microservices, each microservice should have
    its own code base, and this code base is not shared with any other microservice.
    It also means that one microservice has exactly one code base.
  prefs: []
  type: TYPE_NORMAL
- en: Bundling dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As per this principle, all applications should bundle their dependencies along
    with the application bundle. With build tools such as Maven and Gradle, we explicitly
    manage dependencies in a `pom.xml` or the `.gradle` file and link them using a
    central build artifact repository such as Nexus or Archiva. This ensures that
    the versions are managed correctly. The final executables will be packaged as
    a WAR file or an executable JAR file, embedding all the dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: '![Bundling dependencies](img/B05447_01_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the context of microservices, this is one of the fundamental principles to
    be followed. Each microservice should bundle all the required dependencies and
    execution libraries such as the HTTP listener and so on in the final executable
    bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Externalizing configurations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This principle advises the externalization of all configuration parameters from
    the code. An application's configuration parameters vary between environments,
    such as support to the e-mail IDs or URL of an external system, username, passwords,
    queue name, and so on. These will be different for development, testing, and production.
    All service configurations should be externalized.
  prefs: []
  type: TYPE_NORMAL
- en: '![Externalizing configurations](img/B05447_01_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The same principle is obvious for microservices as well. The microservices configuration
    parameters should be loaded from an external source. This will also help to automate
    the release and deployment process as the only difference between these environments
    is the configuration parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Backing services are addressable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All backing services should be accessible through an addressable URL. All services
    need to talk to some external resources during the life cycle of their execution.
    For example, they could be listening or sending messages to a messaging system,
    sending an e-mail, persisting data to database, and so on. All these services
    should be reachable through a URL without complex communication requirements.
  prefs: []
  type: TYPE_NORMAL
- en: '![Backing services are addressable](img/B05447_01_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the microservices world, microservices either talk to a messaging system
    to send or receive messages, or they could accept or send messages to other service
    APIs. In a regular case, these are either HTTP endpoints using REST and JSON or
    TCP- or HTTP-based messaging endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Isolation between build, release, and run
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This principle advocates a strong isolation between the build, release, and
    run stages. The build stage refers to compiling and producing binaries by including
    all the assets required. The release stage refers to combining binaries with environment-specific
    configuration parameters. The run stage refers to running application on a specific
    execution environment. The pipeline is unidirectional, so it is not possible to
    propagate changes from the run stages back to the build stage. Essentially, it
    also means that it is not recommended to do specific builds for production; rather,
    it has to go through the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: '![Isolation between build, release, and run](img/B05447_01_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In microservices, the build will create executable JAR files, including the
    service runtime such as an HTTP listener. During the release phase, these executables
    will be combined with release configurations such as production URLs and so on
    and create a release version, most probably as a container similar to Docker.
    In the run stage, these containers will be deployed on production via a container
    scheduler.
  prefs: []
  type: TYPE_NORMAL
- en: Stateless, shared nothing processes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This principle suggests that processes should be stateless and share nothing.
    If the application is stateless, then it is fault tolerant and can be scaled out
    easily.
  prefs: []
  type: TYPE_NORMAL
- en: All microservices should be designed as stateless functions. If there is any
    requirement to store a state, it should be done with a backing database or in
    an in-memory cache.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing services through port bindings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A Twelve-Factor application is expected to be self-contained. Traditionally,
    applications are deployed to a server: a web server or an application server such
    as Apache Tomcat or JBoss. A Twelve-Factor application does not rely on an external
    web server. HTTP listeners such as Tomcat or Jetty have to be embedded in the
    service itself.'
  prefs: []
  type: TYPE_NORMAL
- en: Port binding is one of the fundamental requirements for microservices to be
    autonomous and self-contained. Microservices embed service listeners as a part
    of the service itself.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency to scale out
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This principle states that processes should be designed to scale out by replicating
    the processes. This is in addition to the use of threads within the process.
  prefs: []
  type: TYPE_NORMAL
- en: In the microservices world, services are designed to scale out rather than scale
    up. The *x* axis scaling technique is primarily used for a scaling service by
    spinning up another identical service instance. The services can be elastically
    scaled or shrunk based on the traffic flow. Further to this, microservices may
    make use of parallel processing and concurrency frameworks to further speed up
    or scale up the transaction processing.
  prefs: []
  type: TYPE_NORMAL
- en: Disposability with minimal overhead
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This principle advocates building applications with minimal startup and shutdown
    times with graceful shutdown support. In an automated deployment environment,
    we should be able bring up or bring down instances as quick as possible. If the
    application's startup or shutdown takes considerable time, it will have an adverse
    effect on automation. The startup time is proportionally related to the size of
    the application. In a cloud environment targeting auto-scaling, we should be able
    to spin up new instance quickly. This is also applicable when promoting new versions
    of services.
  prefs: []
  type: TYPE_NORMAL
- en: In the microservices context, in order to achieve full automation, it is extremely
    important to keep the size of the application as thin as possible, with minimal
    startup and shutdown time. Microservices also should consider a lazy loading of
    objects and data.
  prefs: []
  type: TYPE_NORMAL
- en: Development and production parity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This principle states the importance of keeping development and production environments
    as identical as possible. For example, let's consider an application with multiple
    services or processes, such as a job scheduler service, cache services, and one
    or more application services. In a development environment, we tend to run all
    of them on a single machine, whereas in production, we will facilitate independent
    machines to run each of these processes. This is primarily to manage the cost
    of infrastructure. The downside is that if production fails, there is no identical
    environment to re-produce and fix the issues.
  prefs: []
  type: TYPE_NORMAL
- en: Not only is this principle valid for microservices, but it is also applicable
    to any application development.
  prefs: []
  type: TYPE_NORMAL
- en: Externalizing logs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A Twelve-Factor application never attempts to store or ship log files. In a
    cloud, it is better to avoid local I/Os. If the I/Os are not fast enough in a
    given infrastructure, it could create a bottleneck. The solution to this is to
    use a centralized logging framework. Splunk, Greylog, Logstash, Logplex, and Loggly
    are some examples of log shipping and analysis tools. The recommended approach
    is to ship logs to a central repository by tapping the logback appenders and write
    to one of the shippers' endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: In a microservices ecosystem, this is very important as we are breaking a system
    into a number of smaller services, which could result in decentralized logging.
    If they store logs in a local storage, it would be extremely difficult to correlate
    logs between services.
  prefs: []
  type: TYPE_NORMAL
- en: '![Externalizing logs](img/B05447_01_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In development, the microservice may direct the log stream to `stdout`, whereas
    in production, these streams will be captured by the log shippers and sent to
    a central log service for storage and analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Package admin processes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Apart from application services, most applications provide admin tasks as well.
    This principle advises to use the same release bundle as well as an identical
    environment for both application services and admin tasks. Admin code should also
    be packaged along with the application code.
  prefs: []
  type: TYPE_NORMAL
- en: Not only is this principle valid for microservices, but also it is applicable
    to any application development.
  prefs: []
  type: TYPE_NORMAL
- en: Microservice use cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A microservice is not a silver bullet and will not solve all the architectural
    challenges of today's world. There is no hard-and-fast rule or rigid guideline
    on when to use microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices may not fit in each and every use case. The success of microservices
    largely depends on the selection of use cases. The first and the foremost activity
    is to do a litmus test of the use case against the microservices' benefits. The
    litmus test must cover all the microservices' benefits we discussed earlier in
    this chapter. For a given use case, if there are no quantifiable benefits or the
    cost outweighs the benefits, then the use case may not be the right choice for
    microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s discuss some commonly used scenarios that are suitable candidates for
    a microservices architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: Migrating a monolithic application due to improvements required in scalability,
    manageability, agility, or speed of delivery. Another similar scenario is rewriting
    an end-of-life heavily used legacy application. In both cases, microservices present
    an opportunity. Using a microservices architecture, it is possible to replatform
    a legacy application by slowly transforming functions to microservices. There
    are benefits in this approach. There is no humongous upfront investment required,
    no major disruption to business, and no severe business risks. As the service
    dependencies are known, the microservices dependencies can be well managed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utility computing scenarios such as integrating an optimization service, forecasting
    service, price calculation service, prediction service, offer service, recommendation
    service, and so on are good candidates for microservices. These are independent
    stateless computing units that accept certain data, apply algorithms, and return
    the results. Independent technical services such as the communication service,
    the encryption service, authentication services, and so on are also good candidates
    for microservices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In many cases, we can build headless business applications or services that
    are autonomous in nature—for instance, the payment service, login service, flight
    search service, customer profile service, notification service, and so on. These
    are normally reused across multiple channels and, hence, are good candidates for
    building them as microservices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There could be micro or macro applications that serve a single purpose and performing
    a single responsibility. A simple time tracking application is an example of this
    category. All it does is capture the time, duration, and task performed. Common-use
    enterprise applications are also candidates for microservices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backend services of a well-architected, responsive client-side MVC web application
    (the **Backend as a Service** (**BaaS**) scenario) load data on demand in response
    to the user navigation. In most of these scenarios, data could be coming from
    multiple logically different data sources as described in the *Fly By Points*
    example mentioned earlier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Highly agile applications, applications demanding speed of delivery or time
    to market, innovation pilots, applications selected for DevOps, applications of
    the System of Innovation type, and so on could also be considered as potential
    candidates for the microservices architecture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications that we could anticipate getting benefits from microservices such
    as polyglot requirements, applications that require **Command Query Responsibility
    segregations** (**CQRS**), and so on are also potential candidates of the microservices
    architecture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the use case falls into any of these categories, it is a potential candidate
    for the microservices architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are few scenarios in which we should consider avoiding microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: If the organization's policies are forced to use centrally managed heavyweight
    components such as ESB to host a business logic or if the organization has any
    other policies that hinder the fundamental principles of microservices, then microservices
    are not the right solution unless the organizational process is relaxed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the organization's culture, processes, and so on are based on the traditional
    waterfall delivery model, lengthy release cycles, matrix teams, manual deployments
    and cumbersome release processes, no infrastructure provisioning, and so on, then
    microservices may not be the right fit. This is underpinned by Conway's Law. This
    states that there is a strong link between the organizational structure and software
    it creates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Read more about the Conway''s Law at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.melconway.com/Home/Conways_Law.html](http://www.melconway.com/Home/Conways_Law.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Microservices early adopters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many organizations have already successfully embarked on their journey to the
    microservices world. In this section, we will examine some of the frontrunners
    on the microservices space to analyze why they did what they did and how they
    did it. We will conduct some analysis at the end to draw some conclusions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Netflix** ([www.netflix.com](http://www.netflix.com)): Netflix, an international
    on-demand media streaming company, is a pioneer in the microservices space. Netflix
    transformed their large pool of developers developing traditional monolithic code
    to smaller development teams producing microservices. These microservices work
    together to stream digital media to millions of Netflix customers. At Netflix,
    engineers started with monolithic, went through the pain, and then broke the application
    into smaller units that are loosely coupled and aligned to the business capability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uber** ([www.uber.com](http://www.uber.com)): Uber, an international transportation
    network company, began in 2008 with a monolithic architecture with a single code
    base. All services were embedded into the monolithic application. When Uber expanded
    their business from one city to multiple cities, the challenges started. Uber
    then moved to SOA-based architecture by breaking the system into smaller independent
    units. Each module was given to different teams and empowered them to choose their
    language, framework, and database. Uber has many microservices deployed in their
    ecosystem using RPC and REST.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Airbnb** ([www.airbnb.com](http://www.airbnb.com)): Airbnb, a world leader
    providing a trusted marketplace for accommodation, started with a monolithic application
    that performed all the required functions of the business. Airbnb faced scalability
    issues with increased traffic. A single code base became too complicated to manage,
    resulted in a poor separation of concerns, and ran into performance issues. Airbnb
    broke their monolithic application into smaller pieces with separate code bases
    running on separate machines with separate deployment cycles. Airbnb developed
    their own microservices or SOA ecosystem around these services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Orbitz** ([www.orbitz.com](http://www.orbitz.com)): Orbitz, an online travel
    portal, started with a monolithic architecture in the 2000s with a web layer,
    a business layer, and a database layer. As Orbitz expanded their business, they
    faced manageability and scalability issues with monolithic-tiered architecture.
    Orbitz then went through continuous architecture changes. Later, Orbitz broke
    down their monolithic to many smaller applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**eBay** ([www.ebay.com](http://www.ebay.com)): eBay, one of the largest online
    retailers, started in the late 1990s with a monolithic Perl application and FreeBSD
    as the database. eBay went through scaling issues as the business grew. It was
    consistently investing in improving its architecture. In the mid 2000s, eBay moved
    to smaller decomposed systems based on Java and web services. They employed database
    partitions and functional segregation to meet the required scalability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon** ([www.amazon.com](http://www.amazon.com)): Amazon, one of the largest
    online retailer websites, was run on a big monolithic application written on C++
    in 2001\. The well-architected monolithic application was based on a tiered architecture
    with many modular components. However, all these components were tightly coupled.
    As a result, Amazon was not able to speed up their development cycle by splitting
    teams into smaller groups. Amazon then separated out the code as independent functional
    services, wrapped with web services, and eventually advanced to microservices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gilt** ([www.gilt.com](http://www.gilt.com)): Gilt, an online shopping website,
    began in 2007 with a tiered monolithic Rails application and a Postgres database
    at the back. Similarly to many other applications, as traffic volumes increased,
    the web application was not able to provide the required resiliency. Gilt went
    through an architecture overhaul by introducing Java and polyglot persistence.
    Later, Gilt moved to many smaller applications using the microservices concept.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Twitter** ([www.twitter.com](http://www.twitter.com)): Twitter, one of the
    largest social websites, began with a three-tiered monolithic rails application
    in the mid 2000s. Later, when Twitter experienced growth in its user base, they
    went through an architecture-refactoring cycle. With this refactoring, Twitter
    moved away from a typical web application to an API-based even driven core. Twitter
    uses Scala and Java to develop microservices with polyglot persistence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nike** ([www.nike.com](http://www.nike.com)): Nike, the world leader in apparel
    and footwear, transformed their monolithic applications to microservices. Similarly
    to many other organizations, Nike too was run with age-old legacy applications
    that were hardly stable. In their journey, Nike moved to heavyweight commercial
    products with an objective to stabilize legacy applications but ended up in monolithic
    applications that were expensive to scale, had long release cycles, and needed
    too much manual work to deploy and manage applications. Later, Nike moved to a
    microservices-based architecture that brought down the development cycle considerably.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The common theme is monolithic migrations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we analyze the preceding enterprises, there is one common theme. All these
    enterprises started with monolithic applications and transitioned to a microservices
    architecture by applying learning and pain points from their previous editions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even today, many start-ups begin with monolith as it is easy to start, conceptualize,
    and then slowly move to microservices when the demand arises. Monolithic to microservices
    migration scenarios have an added advantage: they have all the information upfront,
    readily available for refactoring.'
  prefs: []
  type: TYPE_NORMAL
- en: Though, for all these enterprises, it is monolithic transformation, the catalysts
    were different for different organizations. Some of the common motivations are
    a lack of scalability, long development cycles, process automation, manageability,
    and changes in the business models.
  prefs: []
  type: TYPE_NORMAL
- en: While monolithic migrations are no-brainers, there are opportunities to build
    microservices from the ground up. More than building ground-up systems, look for
    opportunities to build smaller services that are quick wins for business—for example,
    adding a trucking service to an airline's end-to-end cargo management system or
    adding a customer scoring service to a retailer's loyalty system. These could
    be implemented as independent microservices exchanging messages with their respective
    monolithic applications.
  prefs: []
  type: TYPE_NORMAL
- en: Another point is that many organizations use microservices only for their business-critical
    customer engagement applications, leaving the rest of the legacy monolithic applications
    to take their own trajectory.
  prefs: []
  type: TYPE_NORMAL
- en: Another important observation is that most of the organizations examined previously
    are at different levels of maturity in their microservices journey. When eBay
    transitioned from a monolithic application in the early 2000s, they functionally
    split the application into smaller, independent, and deployable units. These logically
    divided units are wrapped with web services. While single responsibility and autonomy
    are their underpinning principles, the architectures are limited to the technologies
    and tools available at that point in time. Organizations such as Netflix and Airbnb
    built capabilities of their own to solve the specific challenges they faced. To
    summarize, all of these are not truly microservices, but are small, business-aligned
    services following the same characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: There is no state called "definite or ultimate microservices". It is a journey
    and is evolving and maturing day by day. The mantra for architects and developers
    is the replaceability principle; build an architecture that maximizes the ability
    to replace its parts and minimizes the cost of replacing its parts. The bottom
    line is that enterprises shouldn't attempt to develop microservices by just following
    the hype.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the fundamentals of microservices with the
    help of a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: We explored the evolution of microservices from traditional monolithic applications.
    We examined some of the principles and the mind shift required for modern application
    architectures. We also took a look at the characteristics and benefits of microservices
    and use cases. In this chapter, we established the microservices' relationship
    with service-oriented architecture and Twelve-Factor Apps. Lastly, we analyzed
    examples of a few enterprises from different industries.
  prefs: []
  type: TYPE_NORMAL
- en: We will develop a few sample microservices in the next chapter to bring more
    clarity to our learnings in this chapter.
  prefs: []
  type: TYPE_NORMAL
