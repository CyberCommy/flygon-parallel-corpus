- en: Chapter 6. Advanced Meterpreter Scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Passing the hash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a persistent connection with backdoors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pivoting with meterpreter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Port forwarding with meterpreter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Meterpreter API and mixins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Railgun - converting ruby into a weapon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding DLL and function definitions to Railgun
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a "Windows Firewall De-activator" meterpreter script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing an existing meterpreter script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about several powerful meterpreter commands
    which can be very helpful in post-exploitation. Meterpreter adds a lot of flexibility
    to the post-exploitation process by providing a very interactive and useful command
    interpreter. It not only eases the task, but also makes it more powerful and comprehensive.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will take meterpreter a step ahead by learning some advanced
    concepts. So far, we have been using various commands and scripts that Metasploit
    provides to us, but during the process of penetration testing, a situation may
    arise when you will have to add your own scripts to meterpreter. The modular architecture
    of the platform makes it very easy to develop and integrate your own scripts and
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: We will start this chapter by learning some advanced meterpreter functionalities
    such as passing the hash, pivoting, port forwarding, and so on. Then, we will
    move to developing our own meterpreter scripts. In order to understand this chapter
    completely, you should be aware of the basic Ruby concepts. Even a basic idea
    about the Ruby language can help you in building smart meterpreter scripts. In
    order to facilitate the readers, I will start with some basic development concepts.
    Then, we will analyze some existing Ruby codes and see how we can reuse them or
    edit them according to our needs. Then, we will learn to develop our own simple
    "Windows Firewall De-activator" meterpreter script.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter will enhance your understanding about the platform in detail. So
    let us move ahead and start working out the recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Passing the hash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Passing the hash or hashdump is the process of extracting the Windows logon
    hash files. Hashdump meterpreter script extracts and dumps the password hashes
    from the target machine. Hashes can be used to crack the logon passwords and gain
    authorized entry into other systems on the LAN for future pen tests.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before starting with the recipe, let us first understand about Windows passwords
    and their storage format.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you type your password into the Windows Logon screen, it encrypts your
    password using an encryption scheme that turns your password into something that
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`7524248b4d2c9a9eadd3b435c51404ee`'
  prefs: []
  type: TYPE_NORMAL
- en: This is a password hash. This is what is actually being checked against when
    you type your password in. It encrypts what you typed and bounces it against what
    is stored in the registry and/or SAM file.
  prefs: []
  type: TYPE_NORMAL
- en: The SAM file holds the usernames and password hashes for every account on the
    local machine, or domain if it is a domain controller. It can be found on the
    hard drive in the folder `%systemroot%system32config`.
  prefs: []
  type: TYPE_NORMAL
- en: However, this folder is locked to all accounts including Administrator while
    the machine is running. The only account that can access the SAM file during operation
    is the "System" account. So, you will have to keep in mind that you need an escalated
    privilege while you are trying to dump the hashes.
  prefs: []
  type: TYPE_NORMAL
- en: Hashes will appear completely alien to you as they are encrypted text. Windows
    uses the **NTLM (NT LAN Manager)** security protocol to provide authentication.
    It is the successor of the LM protocol which was used in the older versions of
    Windows.
  prefs: []
  type: TYPE_NORMAL
- en: In order to decode the dumped hashes, we will require a NTLM/LM decryptor. There
    are different tools available for it. Some of them use a brute force technique
    (John the riper, pwdump) while some use rainbow tables (rainbow crack).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start with an active meterpreter session. I am assuming that you have
    penetrated the target and gained a meterpreter session. You can refer to recipes
    in [Chapter 4](ch04.html "Chapter 4. Client-side Exploitation and Antivirus Bypass"),
    *Client-side Exploitation and Antivirus Bypass* for more details on compromising
    a windows machine. The use of script is simple and straightforward. Let us first
    check our privilege on the target machine. We must have the system privilege in
    order to extract the hashes. We will be using the `getuid` command to know our
    current privilege level. To escalate our privilege, we will use the `getsystem`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we have system privileges on the target, so we can move ahead and try the
    hashdump script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the script has successfully extracted the password hashes from
    the SAM file. Now we can use different tools to crack this hash. Some of the well-known
    tools are John the riper, pwdump, rainbow crack, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us look at an alternate method of decrypting the hash, other than using
    the tools discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Online password decryption
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is a very popular website for decrypting the NTLM/LM hashes [http://www.md5decrypter.co.uk/](http://www.md5decrypter.co.uk/).
    It finds out the password by matching the hash with its huge database of hashes
    to find a match. It is an effective and fast technique for breaking simple and
    weak passwords. The following screenshot shows the result of decoding the hash
    that we dumped previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Online password decryption](img/7423_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, a match has been found for our input hash and the corresponding
    readable password is 123.
  prefs: []
  type: TYPE_NORMAL
- en: 'A point to note here is that cracking passwords depends totally upon the strength
    of it. A weaker password will be fairly easy to crack compared to a complex one.
    Complex passwords will generate hashes which are not present in the online databases.
    Hence, consider using rainbow table-based crackers. More information on this subject
    can be found at the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bernardodamele.blogspot.in/#!http://bernardodamele.blogspot.com/2011/12/dump-windows-password-hashes.html](http://bernardodamele.blogspot.in/#!http://bernardodamele.blogspot.com/2011/12/dump-windows-password-hashes.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a persistent connection with backdoors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this book with a pre-exploitation technique where we focused on information
    gathering. Then, we moved ahead to the exploitation phase where we learned different
    ways of compromising the target. Then, we learned some useful post-exploitation
    techniques that can be implemented after compromising the target. Now, in this
    recipe we will learn the **ever-exploitation technique** in which we will try
    to establish a persistent connection with our target, so that we can connect to
    it at our will. As the attacker, or the target machine, cannot be always available,
    backdooring the target can be effective for setting persistent connections.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Meterpreter provides us with two scripts which can perform the task of backdooring
    the target. They are Metsvc and Persistence. The working of both the scripts is
    similar. Let us deal with both these scripts one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both these meterpreter scripts create files on the target system so it can trigger
    alarms in the antivirus. So it is recommended to kill the antivirus program before
    running these scripts.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Metsvc script works by creating temporary files such as the DLLs, the backdoor
    server, and the service on the target machine. The script can also start a matching
    multi/handler to automatically connect back to the backdoor. `-A` parameter is
    used for this purpose. Let us run the script on our Windows 7 target machine and
    analyze the result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Once the backdoor files are uploaded successfully, it will automatically connect
    back to the multi/handler on port 31337\. Using this backdoor, we can easily connect
    to the target machine at our will.
  prefs: []
  type: TYPE_NORMAL
- en: Another useful backdooring script to look for is the persistence script. It
    works similar to Metscv, but it has some extra features like connecting back to
    the target at regular intervals, connecting back on system boot, autorun, and
    so on. Let us look at the different options available to us.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see it has some extra options compared to Metsvc. Let us execute
    the script and pass different parameters according to our requirements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Notice the different parameters passed along with the script. The `-A` parameter
    automatically starts a listener on the attacking machine. The `-S` operator sets
    the backdoor to load every time Windows boots up. The `-U` operator executes the
    backdoor every time the user logs into the system. The `-i` operator sets the
    interval after which the backdoor will try to connect back to the agent handler.
    `-p` is the port number and `-r` is the IP address of the target machine. The
    output of the script execution also contains some useful information. The script
    has created a resource file for cleanup so that you can remove the backdoor after
    use. The script has created a vbs file in the `temp` folder on the target machine.
    Also it has created registry entries to auto load the backdoor every time Windows
    boots.
  prefs: []
  type: TYPE_NORMAL
- en: We have provided an interval of 60 seconds for the backdoor to connect back
    to the agent handler. After successful execution of the script, you will see that
    at an interval of 60 seconds a meterpreter session will be opened automatically
    on the target machine.
  prefs: []
  type: TYPE_NORMAL
- en: This quick demonstration explains how we can set up a persistent connection
    with our target machine. You can try out different scenarios with these two scripts
    and analyze its working. In the next recipe, we will focus on another interesting
    concept called pivoting.
  prefs: []
  type: TYPE_NORMAL
- en: Pivoting with meterpreter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have covered most of the major meterpreter commands and script. You
    must have noticed how powerful meterpreter can be during post exploitation phase.
    In this recipe, we will discuss one of the coolest and my favorite concept called
    pivoting. Let us begin with the recipe by first understanding the meaning of pivoting,
    why is it needed and at last how can Metasploit be useful for pivoting.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before starting with the recipe, let us first understand pivoting in detail.
    Pivoting refers to the method used by penetration testers that uses a compromised
    system to attack other systems on the same network. This is a multi-layered attack
    in which we can access even those areas of the network which are only available
    for local internal use such as the intranet. Consider the scenario shown in the
    following diagram.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/7423_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The attacker can compromise the outside nodes of a network which are connected
    to the Internet. These nodes are then connected with a firewall. Behind the firewall
    is the main server. Now since the attacker has no access to the server, he can
    use the nodes as a medium to access it. If the attacker can successfully compromise
    the node then it can further penetrate the network to reach up to the server as
    well. This is a typical scenario that involves pivoting. The red lines in the
    diagram show the pivoted path set up between the attacker and server through the
    compromised node. In this recipe, we will be using some of the meterpreter networking
    commands which we learned in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us see how we can implement the previously discussed scenario using meterpreter.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, our target node is a Windows 7 machine which is connected to
    a network. The server is running on Windows 2003\. The node has been compromised
    by using client-side browser vulnerability and we have an active meterpreter connection
    established. Let us start with running an ipconfig on the target node to see the
    available interfaces on it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the target node has two interfaces. One is 192.168.56.1 which
    is connected to the Internet and the other is 10.0.2.15 which is the IP interface
    for the internal network. Our next aim will be to find what other systems are
    available in this local network. To do this we will use a meterpreter script called
    `arp_scanner`. This script will perform an ARP scan on the internal network to
    find out other available systems.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: So the script has successfully discovered two available IP addresses on the
    network. Let us pick up the first IP address and perform pivoting on it.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to access the system (which is the server) with IP 10.0.2.7, we will
    have to route all the packets through the IP 10.0.2.15 which is the target node.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we will use a command named `route.` We have learned about this
    command in our previous chapter as well. To use this command, we will background
    the current meterpreter session.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Look at the parameters of the route command. The `add` parameter will add the
    details into the routing table. Then we have provided the IP address of the target
    node and the default gateway. Then at last, we have provided the current active
    meterpreter session ID (which is 1). The `route print` command shows the table
    and you can clearly see that all the traffic sent through this network will now
    pass through the meterpreter session 1.
  prefs: []
  type: TYPE_NORMAL
- en: Now you can do a quick port scan on the IP address 10.0.2.7 which was previously
    unreachable for us but now we have routed our packets through the target node
    so we can easily figure out the open ports and services. Once you have figured
    out that it is running a Windows 2003 server, you can go ahead and use the `exploit/windows/smb/ms08_067_netapi`
    or any other OS based exploit to compromise the server or access its services.
  prefs: []
  type: TYPE_NORMAL
- en: Port forwarding with meterpreter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Discussion of pivoting is never complete without talking about port forwarding.
    In this recipe, we will continue from our previous recipe on pivoting and see
    how we can port forward the data and request from the attacking machine to the
    internal network server via the target node. An important thing to note here is
    that we can use the port forwarding to access various services of the internal
    server, but if we have to exploit the server then we will have to use the complete
    concept discussed in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start from the same scenario which we discussed in the previous recipe.
    We have compromised the target node which is a Windows 7 machine and we have added
    the route information to forward all the data packets sent on the network through
    the meterpreter session. Let us take a look at the route table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: So our table is all set. Now we will have to set up port forwarding so that
    our request relays through to reach the internal server.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose the internal server is running a web service on port 80 and we want
    to access it through port forwarding. Now, to do this, we will use the `portfwd`
    command. Let us check the available options with this command then pass the relevant
    values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Successful execution of the command shows that a local TCP relay has been set
    up between the attacker and the internal server. The listener port on the attacker
    machine is 4321 and the service to access on the internal server is on port 80.
  prefs: []
  type: TYPE_NORMAL
- en: As we have already set the route information, the entire relay happens transparently.
    Now, if we try to access the internal server through our browser by using the
    URL `http://10.0.2.7:80` then we will be directed to the http intranet service
    of the internal network.
  prefs: []
  type: TYPE_NORMAL
- en: Port forwarding can be very handy in situations when you have to run commands
    or applications that Metasploit does not provide. In such situations, you can
    use port forwarding to ease up your task.
  prefs: []
  type: TYPE_NORMAL
- en: This was a small demonstration of port forwarding. In the next recipe we will
    start with Ruby programming to develop our own meterpreter scripts.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Port forwarding works on a simple concept of providing a restricted service
    from an unsecure location or network. An authenticated or reliable system/software
    can be used to set up a communication medium between the unsecure and secure network.
    We have already discussed a simple use of port forwarding in the first chapter
    where we talked about setting Metasploit on a virtual machine and connecting it
    with the host operating system using PuTTY.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7423_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram demonstrates the process of port forwarding with a simple
    example. The outside source wants to access the IRC server running on port 6667,
    but the firewall is configured to block any outside access to port 6667(red line
    in the diagram). So, the external source connects to an SSH server (for example,
    PuTTY) running on port 22 which is not blocked by the firewall. This will provide
    a firewall bypass to the external source and now it can access the IRC server
    through port forwarding from port 22 to port 6667\. Hence, an access tunnel is
    created (blue line in the diagram) as a result of port forwarding.
  prefs: []
  type: TYPE_NORMAL
- en: Meterpreter API and mixins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the past one and a half chapters, we have learned extensively about using
    meterpreter as a potential post exploitation tool. You might have realized the
    important role of meterpreter to make our penetration task easier and faster.
    Now, from this recipe, we will move ahead and discuss some advanced concepts related
    to meterpreter. We will dive deeper into the core of Metasploit to understand
    how meterpreter scripts function and how we can build our own scripts.
  prefs: []
  type: TYPE_NORMAL
- en: From a penetration tester's point of view it is very essential to know how to
    implement our own scripting techniques so as to fulfill the needs of the scenario.
    There can be situations when you have to perform tasks where the meterpreter may
    not be enough to solve your task. So you can't sit back. This is where developing
    our own scripts and modules become handy. So let us start with the recipe. In
    this recipe, we will discuss about meterpreter API and some important mixins,
    and then in later recipes, we will code our own meterpreter scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Meterpreter API can be helpful for programmers to implement their own scripts
    during penetration testing. As the entire Metasploit framework is built using
    Ruby language, an experience in Ruby programming can enhance your penetration
    experience with Metasploit. We will be dealing with Ruby scripts in the next few
    recipes so some Ruby programming experience will be required ahead. Even if you
    have a basic understanding of Ruby and other scripting languages then it will
    be easy for you to understand the concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us start with launching an interactive Ruby shell at the meterpreter. Here,
    I am assuming that we have already exploited the target (Windows 7) and have an
    active meterpreter session.
  prefs: []
  type: TYPE_NORMAL
- en: The Ruby shell can be launched by using the `irb` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now we are into the Ruby shell and can execute our Ruby scripts. Let us start
    with a basic addition of two numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'So our shell is working fine and can interpret the statements. Let us perform
    a complex operation now. Let us create a hash and store some values in it along
    with the keys. Then, we will delete the values conditionally. The script will
    look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The script is simple to understand. In the first line, we created keys (a and
    b) and assigned them values. Then, in the next line we added a condition which
    deletes any hash element whose value is less than 25.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some print API calls which will be useful to us while writing
    meterpreter scripts.
  prefs: []
  type: TYPE_NORMAL
- en: '`print_line("message"):` This call will print the output and add a carriage
    return at the end.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print_status("message"):` This call is used most often in the scripting language.
    This call will provide a carriage return and print the status of whatever is executing,
    with a [*] prefixed at the beginning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`print_good("message"):` This call is used to provide a result of any operation.
    The message is displayed with a [+] prefixed at the beginning indicating that
    the action is successful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`print_error("message"):` This call is used to display an error message that
    may occur during script execution. The message is displayed with a [-] prefixed
    at the beginning of the error message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The reason why I discussed these different print calls is that they are widely
    used while writing meterpreter scripts in respective situations. You can find
    documentations related to meterpreter API in `/opt/framework3/msf3/documentation`.
    Go through them in order to have a clear and detailed understanding. You can also
    refer to `/opt/framework3/msf3/lib/rex/post/meterpreter` where you can find many
    scripts related to meterpreter API.
  prefs: []
  type: TYPE_NORMAL
- en: Within these scripts are the various meterpreter core, desktop interaction,
    privileged operations, and many more commands. Review these scripts to become
    intimately familiar with how meterpreter operates within a compromised system.
  prefs: []
  type: TYPE_NORMAL
- en: '**Meterpreter mixins**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Meterpreter mixins are Metasploit specific irb calls. These calls are not available
    in irb but they can be used to represent the most common tasks while writing meterpreter
    scripts. They can simplify our task of writing meterpreter specific scripts. Let
    us see some useful mixins:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cmd_exec(cmd):` This executes the given command as hidden and channelized.
    The output of the command is provided as a multiline string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eventlog_clear(evt = ""):` This clears a given event log or all event logs
    if none is given. It returns an array of event logs that were cleared.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eventlog_list():` This enumerates the event logs and returns an array containing
    the names of the event logs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`file_local_write(file2wrt, data2wrt):` This writes a given string to a specified
    file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_admin?():` This identifies whether or not the user is an admin. Returns
    true if the user is an admin and false if not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_uac_enabled?():` This determines whether **User Account Control (UAC)**
    is enabled on the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`registry_createkey(key):` This creates a given registry key and returns true
    if successful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`registry_deleteval(key,valname):` This deletes a registry value given the
    key and value name. It returns true if successful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`registry_delkey(key):` This deletes a given registry key and returns true
    if successful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`registry_enumkeys(key):` This enumerates the sub keys of a given registry
    key and returns an array of sub keys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`registry_enumvals(key):` This enumerates the values of a given registry key
    and returns an array of value names.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`registry_getvaldata(key,valname):` This returns the data of a given registry
    key and its value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`service_create(name, display_name, executable_on_host,startup=2):` This function
    is used for the creation of a service that runs its own process. Its parameters
    are the service name as a string, the display name as a string, the path of the
    executable on the host that will execute at start-up as a string, and the start-up
    type as an integer: 2 for Auto, 3 for Manual, or 4 for Disable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`service_delete(name):` This function is used for deleting a service by deleting
    the key in the registry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`service_info(name):` This gets the Windows service information. The information
    is returned in a hash with the display name, start-up mode, and command executed
    by the service. The service name is case sensitive. Hash keys are Name, Start,
    Command, and Credentials.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`service_list():` This lists all the Windows services present. It returns an
    array containing the services'' names.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`service_start(name):` This function is used for the service start-up. It returns
    0 if the service is started, 1 if the service is already started, and 2 if the
    service is disabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`service_stop(name):` This function is used for stopping a service. It returns
    0 if the service is stopped successfully, 1 if the service is already stopped
    or disabled, and 2 if the service cannot be stopped.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This was a quick reference to some important meterpreter mixins. Using these
    mixins can reduce the complexity of our scripts. We will understand their usage
    in the next few recipes where we will be creating and analyzing meterpreter scripts.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The meterpreter API simply creates a mini Ruby interpreter that can understand
    and interpret Ruby instructions. The major advantage of using API is that it gives
    us the flexibility to perform our own operations. We cannot have commands for
    all operations. There can be situations where we may need specific scripts to
    perform our task. This is where APIs can be handy.
  prefs: []
  type: TYPE_NORMAL
- en: Railgun - converting Ruby into a weapon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we saw the use of the meterpreter API to run Ruby scripts.
    Let us take that a step ahead. Suppose we want to make remote API calls on the
    victim machine then what can be the simplest method? Railgun is the obvious answer.
    It is a meterpreter extension that allows an attacker to call DLL functions directly.
    Most often, it is used to make calls to the Windows API, but we can call any DLL
    on the victim's machine.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start using Railgun, we will require an active meterpreter session on our
    target machine. To start the Ruby interpreter, we will use the `irb` command as
    discussed in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we move into calling DLLs, let us first see the essential steps to follow
    in order to get the best out of Railgun.
  prefs: []
  type: TYPE_NORMAL
- en: Identify the function(s) you wish to call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the function on [http://msdn.microsoft.com/en-us/library/aa383749(v=vs.85).aspx](http://msdn.microsoft.com/en-us/library/aa383749(v=vs.85).aspx).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the library (DLL) in which the function is located (for example, `kernel32.dll)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The selected library function can be called as `client.railgun.dll_name.function_name(arg1,
    arg2, ...)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Windows MSDN library can be used to identify useful DLLs and functions to
    call on the target machine. Let us call a simple `IsUserAnAdmin` function of `shell32.dll`
    and analyze the output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the function returned `false` value indicating that the user
    is not an admin. Let us escalate our privilege and try the call again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This time the function returned `true` indicating that our privilege escalation
    was successful and now we are working as the system admin. Railgun provides us
    with the flexibility to easily perform those tasks which are not present in the
    form of modules. So, we are not just limited to those scripts and modules that
    the framework provides us with, in fact, we can make calls on demand.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can further extend this call into a small Ruby script with error checking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Using Railgun can be a very powerful and exciting experience. You can practice
    your own calls and scripts to analyze the outputs. However, what if the DLL or
    the function you want to call is not a part of the Railgun definition. In that
    case, Railgun also provides you with the flexibility to add your own functions
    and DLLs to Railgun. We will deal with it in our next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Railgun is a particular Ruby command interpreter that can be used to make remote
    DLL calls to the compromised target. Remote DLL calls are an important process
    in penetration testing as it gives us the command over the compromised target
    to execute any system instruction with full privilege.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Railgun is an interesting tool that can enhance the process of penetration testing.
    Let us find out some more information about Railgun.
  prefs: []
  type: TYPE_NORMAL
- en: Railgun definitions and documentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Railgun currently supports ten different Windows API DLLs. You can find their
    definitions in the following folder: `pentest/exploits/framework3/lib/rex/post/meterpreter/extensions/stdapi/railgun/def`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from this, you can also read the Railgun documentation from the following
    location:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/opt/framework3/msf3/external/source/meterpreter/source/extensions/stdapi/server/railgun/railgun_manual.pdf`'
  prefs: []
  type: TYPE_NORMAL
- en: Adding DLL and function definition to Railgun
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we focused on calling Windows API DLLs through Railgun.
    In this recipe, we will focus on adding our own DLL and function definitions to
    Railgun. In order to do this, we should have an understanding of Windows DLLs.
    The Railgun manual can be helpful in giving you a quick idea about different Windows
    constants that can be used while adding function definitions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adding a new DLL definition to Railgun is an easy task. Suppose you want to
    add a DLL that ships with Windows but it is not present in your Railgun, then
    you can create a DLL definition under `pentest/exploits/framework3/lib/rex/post/meterpreter/extensions/stdapi/railgun/def`
    and name it as `def_dllname.rb`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the example of adding a shell32.dll definition into Railgun. We can
    start with adding the following lines of codes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Saving this code as `def_shell32.dll` will create a Railgun definition for shell32.dll.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step is to add functions to the DLL definition. If you take a look
    at the `def_shell32.dll` script in Metasploit you will see that the `IsUserAnAdmin`
    function is already added into it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The function simply returns a Boolean True or False, depending upon the condition.
    Similarly, we can add our own function definition in shell32.dll. Consider the
    example of adding the `OleFlushClipboard()` function. This will flush any data
    that is present on the Windows clipboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding the following line of code in the shell32.dll definition will serve
    our purpose:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To test the function, save the file and go back to the meterpreter session to
    check if the function executes successfully or not.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Alternately, you can also add the DLLs and functions directly to Railgun using
    `add_dll` and `add_function`. Here is a complete script which checks for the availability
    of shell32\. dll and the `OleFlushClipboard` function and if they are not present
    then they are added using the `add_dll` and `add_function` calls.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This was a short demonstration of using Railgun as a powerful tool to call Windows
    APIs depending on our need. You can look for various useful Windows API calls
    in the MSDN library, and add them into Railgun and enhance the functionality of
    your framework. It can be used to call any DLL that is residing on the target
    machine. In the next recipe, we will move ahead to develop our own meterpreter
    scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Building a "Windows Firewall De-activator" meterpreter script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we have used several meterpreter scripts such as `killav.rb` and `persistence.rb`.
    Let's start discussing about developing our own meterpreter script. Ruby knowledge
    is essential for writing any module in Metasploit. You should have basic understanding
    of Ruby. There is not enough documentation available to learn directly about meterpreter
    scripting. The simplest and best practice is to learn Ruby language and side by
    side keep looking at the codes of various available modules. You can also read
    the Metasploit developer guide to understand about the different libraries provided
    by the framework which you can use while writing your own modules. The documentation
    can be found at [http://dev.metasploit.com/redmine/projects/framework/wiki/DeveloperGuide](http://dev.metasploit.com/redmine/projects/framework/wiki/DeveloperGuide).
  prefs: []
  type: TYPE_NORMAL
- en: The script we will develop here is a Windows Vista/7 firewall de-activator script.
    It will make use of the Windows command called `netsh` and meterpreter will execute
    the command on the target machine by using a mixin called `cmd_exec()`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Meterpreter scripts run in context with the exploited client so it becomes easier
    for you to just focus on the task which you want to perform through your script.
    You don't have to worry about the connectivity or any other parameters. Let us
    look at some important guidelines that should be kept in mind while writing meterpreter
    scripts
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoiding global variables:** This is a general principal for coding on any
    framework. Use of global variables should be avoided as they can interfere with
    the framework variables. Use only instance, local and constant variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use of comments:** Comments are essential while writing codes. This can help
    you keep a track of which part is responsible for a particular action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Including parameters:** You might have noticed in several recipes how we
    passed parameters along with the script. The most elementary, yet helpful, parameter
    is `-h` or the `help` option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Printing results:** Printing the result of the operation can prove whether
    the execution of a script was a success or failure. Using different printing calls
    as `print_status, print_error`, and so on should be used extensively to display
    relevant information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Platform validation:** Make sure that you validate the platform on which
    you want your script to perform an action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintaining the file convention:** Once you have completed writing the script,
    save it under `/pentest/exploits/framework3/scripts/meterpreter`. Following the
    framework file convention can avoid any conflicts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use of mixins:** Mixins are an important concept in meterpreter. Using mixins
    we can make our script look simpler and easier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should keep these guidelines in mind while writing meterpreter scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Let us open any text editor to start writing the Ruby script. If you are working
    on BackTrack then you can use the Gedit text editor.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Type the following lines of code in the text editor. Before moving on to the
    explanation section, give a thorough look at the script and try to figure out
    what each line means. The script is easy to catch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Once you have typed the code, save it as `myscript.rb` under `/pentest/exploits/framework3/scripts/meterpreter`.
  prefs: []
  type: TYPE_NORMAL
- en: To execute this script, we will need a meterpreter session. Ruby scripts can
    be executed using the `run` command. However, before using the script, make sure
    you have system privileges on the target machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Bingo! Successful execution of the script will silently disable the default
    firewall. The execution of the command occurs in the background so the target
    user remains unaware of it. Let us now understand the script in detail.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us analyze each segment of the script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: These lines of code are nothing but the options that we can pass along with
    the script. In this script, the only option available to us is the `-h` parameter
    which displays the script usage message. You can save this piece of code as a
    template for creating options in your scripts. You will encounter several code
    snippets which can be directly used in your own script.
  prefs: []
  type: TYPE_NORMAL
- en: The script starts with creation of a hash (opts) which includes the Rex library
    which is the short form for the Ruby Extensions Library. The only key is `-h`.
    The usage value is set to 'false' which means that this is an optional parameter
    for the script. The next few lines of code match the options provided with the
    script and jumps to the particular case to display the message using `print_line()`.
    In our case, we have used only one option (`-h`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This part of the script is operation specific. It starts with verifying the
    client operating system. Then it uses a meterpreter mixin `cmd_exec()` which can
    execute commands as hidden and channelized. The command to be executed is `netsh
    advfirewall set AllProfiles state off`. The mixin evokes this command on the client
    machine in context with the command prompt and its successful execution disables
    the windows firewall.
  prefs: []
  type: TYPE_NORMAL
- en: You can play with the script by adding more functionalities and trying different
    possibilities. The more you experiment, the better you will learn.
  prefs: []
  type: TYPE_NORMAL
- en: This was a short demonstration on how to build a meterpreter script. In the
    next recipe, we will look at an advanced meterpreter script and understand it
    in detail.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us extend our discussion to reusing the codes for faster and efficient penetration
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: Code re-use
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Code re-use can be an effective technique in building your own scripts. You
    can find some readymade functions such as creating multi handler, setting up parameter
    checks, adding payloads. You can use them directly in your code and leverage its
    functionality. Remember that the best way to learn about meterpreter scripting
    is by looking at the built-in scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing an existing meterpreter script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have learned how to build our own script, let us move ahead and
    analyze an existing script that performs some advanced tasks. Once you are able
    to read an existing script completely, you can implement the functions from them
    according to your need. Code re-use is an effective technique to increase the
    optimization of codes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To view an existing script, browse to `pentest/exploits/framework3/scripts/meterpreter`.
  prefs: []
  type: TYPE_NORMAL
- en: You can find all the available meterpreter scripts in this folder. We will be
    analyzing the `persistence.rb` script which helps in setting up a backdoor on
    the target user. We have discussed the usage of this script in the previous chapter.
    Here we will look under the hood of how this script functions.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us analyze each section of the code one by one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The code starts with declaring variables which are used in the script. You can
    see some of the common variables such as `rhost, rport, payload_type` which we
    have been using throughout the exploitation process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The next part of the script consists of different parameters (flags) that are
    required to pass along with the script. The parameters having a `true` value are
    compulsory flags whose values have to be passed by the penetration tester. Parameters
    with a `false` value are optional.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The next section of the script comprises of function declaration. The first
    two functions are generally available in all meterpreter scripts. The usage function
    is used to display an introductory message of the script. It contains a short
    description about the use of the script. The `wrong_meter_version()` is used to
    verify whether the meterpreter version is supported by the script or not. Some
    scripts do not support the older versions of meterpreter so a validation can be
    helpful.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The next function is about creating a payload. You can directly use this function
    in your script if you want to create a payload (power of code reuse). The function
    `create_payload()` takes up two values namely `payload_type` and `lport`. If you
    remember the variable declaration section, then these two variables have been
    initialized with some default values.
  prefs: []
  type: TYPE_NORMAL
- en: The `pay = client.framework.payloads.create(payload)` call allows us to create
    a payload from the Metasploit framework.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to note in this snippet is `pay.datastore['LHOST'] = lhost` and `pay.datastore['LPORT']
    = lport`. The datastore is simply a hash of values that may be used by modules
    or the framework itself to reference programmer or user controlled values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The next function is for creating persistent scripts. The scripts are created
    depending upon the payload and other parameter values passed along with the script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The next function is for creating a log directory for the script. The `host
    = @client.sys.config.sysinfo["Computer"]` call extracts the system info of the
    compromised target. The directory and filename is created using the Rex::FileUtils
    library which is responsible for performing file and directory operations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This function starts writing files to disk. It saves the various backdoor files
    in the folders and directories created in the previous function. The `Rex::Text.rand_text_alpha((rand(8)+6))
    + ".vbs"` call generates a random text for the filename to be created in the temp
    directory. The `fd.write()` call writes the files to disk.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This function creates a multi handler to connect back to the attacking system.
    This is, again, a general function which can be used in your script if you want
    an auto connect back feature by setting a multi handler.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This function is responsible for executing the script on the target machine.
    The persistence script creates vbs scripts on the target machine, so they must
    be executed in order to open a connection. The `Targets_exec()` function solves
    this purpose. This function can again be used as a general function in your own
    script if you want to execute scripts on the target machine. The `session.sys.process.execute()`
    call is responsible for executing the script and the `proc.pid` returns the process
    ID of the backdoor process created.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining part of the code is self-explanatory where these functions are
    called, a clear script is created, and an option check is implemented. This recipe
    might have given you a clear idea of what happens in the background when we execute
    a meterpreter script. It is very essential from a pen tester's point of view to
    be able to read and modify the codes according to the work scenario. This is where
    the beauty of the open source framework lies. You can make modifications according
    to your needs and you can learn by directly analyzing the available source codes.
  prefs: []
  type: TYPE_NORMAL
