- en: 'Chapter 2. Triple ''A'' Games: Art and Audio'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we are comfortable navigating around the interface and have built a
    simple game, we can start to create more complex projects. In this chapter we
    are going to focus on creating art, adding animation, and implementing an audio
    soundscape. All three of these elements are incredibly important for the creation
    of a game as each of them helps the player to understand what is happening and
    makes the experience more immersive. How we go about building a game can be drastically
    affected by the types of assets we use and how they are implemented. We will start
    by looking at importing external images and move onto some practical examples
    of how to create a tileset and make an animated character. We will then move onto
    audio files and how to add ambience to a game. We will wrap up the chapter with
    a brief talk on how to make a game look more professional. Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Manufacturing art assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'More often than not, when creating a game, the majority of the art assets will
    be created in an external program and it will need to be imported. It is true
    that GameMaker: Studio does have an in-built image editor that we will investigate
    later, but its capabilities are fairly limited. It''s perfect for creating simple
    art, but there are many other tools that provide us with much more advanced techniques
    for creating complex art.'
  prefs: []
  type: TYPE_NORMAL
- en: There are many popular software options you might want to consider. The most
    full featured option and the most expensive is **Adobe Photoshop** , which is
    the preferred option for most professional artists and can be purchased at [http://www.photoshop.com/](http://www.photoshop.com/).
    A free alternative with many similar capabilities is **GIMP**, downloadable at
    [http://www.gimp.org/](http://www.gimp.org/). Both these packages offer a full
    suite of advanced tools for creating images. There are also many other simpler
    tools available, such as **Pickle** [http://www.pickleeditor.com/](http://www.pickleeditor.com/),
    **Spriter** [http://www.brashmonkey.com/](http://www.brashmonkey.com/), and **PyxelEdit**
    [http://pyxeledit.com/](http://pyxeledit.com/), all of which are free and worth
    checking out.
  prefs: []
  type: TYPE_NORMAL
- en: If you just want to skip the art creation and prefer some premade pieces, there
    are plenty of places to download sprites. One of the most popular sites for sprites
    is the **Spriters Resource** [http://spriters-resource.com/](http://spriters-resource.com/).
    They have assets for every type of game you can imagine. You can also check out
    the GameMaker forums [http://gmc.yoyogames.com/](http://gmc.yoyogames.com/). Here
    you will find many active people who are willing to make or share their art assets.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the image file formats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'GameMaker: Studio is capable of importing four image types: BMP, GIF, JPG,
    and PNG. Each format has its own unique capability and drawback that will dictate
    how they should be used. The **BMP** format is the least used format these days
    because the data is not compressed. Uncompressed images are generally considered
    inefficient due to their large file size. **GIF** is the only format that can
    be animated, but is limited to 256 colors and a single level of transparency.
    This is perfect for classic 8-bit styled art where everything has a hard edge.
    **JPG** images have the smallest file size due to the lack of any transparency
    and their lossy compression format. This is a good choice for backgrounds and
    opaque sprites only. **PNG** image formats are the most useful because they are
    more efficient than BMPs, have 16 million colors and full transparency, and it
    is the format that GameMaker: Studio outputs as a texture page when the game is
    compiled.'
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book we will be utilizing only two of the image formats, GIF
    and PNG. We will be using GIF images for everything that is animated as it is
    the simplest way to import animation. As in the previous chapter, if we load an
    animated GIF image, each frame of animation will be separated in the **Sprite
    Properties Editor**. Unfortunately this means that we are limited to an 8-bit
    art style with our characters having hard edges due to the single level of transparency.
    If we want to have a smoother, cleaner look we will want to have our edges anti-aliased
    and that requires the use of a PNG image. Attempting to have smooth edges in a
    GIF image is one of the most common mistakes an artist can make. As we will see
    in the following screenshot, on the left-hand side we have a GIF image in the
    8-bit art style with crisp hard edges and on the right-hand side a PNG image with
    smooth, anti-aliased edges.
  prefs: []
  type: TYPE_NORMAL
- en: In the center we have the same smooth sprite used in the PNG but saved as a
    GIF. Notice the edge pixels that were once slightly transparent are now a solid
    white outline.
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the image file formats](img/4100OT_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Importing sprite sheets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While all the animations in this book will be using GIF images for the sake
    of expediency, it would be remiss if we did not cover how to import a **sprite
    sheet**. A sprite sheet is generally a PNG file with all the frames of animation
    of an object, such as a character, placed evenly in a grid. We can then quickly
    cut out each frame of animation in GameMaker to build the individual sprites we
    need. Let's try this out!
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by opening a **New Project** called `Chapter_02`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Sprite and name it `spr_PlayerSpriteSheet`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Edit Sprite** button to open the **Sprite Editor**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **File**, select **Create from Strip**, and then open `Chapter 2/Sprites/PlayerSpriteSheet.png`
    with nothing selected in the **Image Information** section. This will open the
    **Loading a strip image** editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The sprite sheet we just loaded consists of a six frame run cycle. Since we
    want all the frames, we need to set **number of images** to `6`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The layout of the sprite sheet has two rows of three images. Set **images per
    row** to `3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since each image is 64 x 64 pixels in size we need to set **image width** and
    **image height** to `64`. The other options for offsets and separation are not
    necessary for such a small sprite sheet, but they would come in handy if we had
    a complete set of animations for this character. The setting should look like
    the following image:![Importing sprite sheets](img/4100OT_02_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **OK**. We now have an animated sprite with smooth edges!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are finished with this sprite. Now click the check mark of the **Sprite Editor**
    and the **Sprite Properties** editor and click on the **OK** button to close it
    down.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Introducing the image editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the big benefits of developing with GameMaker: Studio is that it has
    an in-built **Image Editor** for creating sprites and backgrounds. This editor
    may appear to be very basic but there are a lot of excellent tools available to
    use. There are a variety of different drawing tools including the standard tools
    such as pencil, eraser, and fill. One very useful and unique feature in the editor
    is the ability to paint with both mouse buttons. The **Colors** | **Left** and
    **Colors** | **Right** color options, as seen in the following image, indicate
    the color that will be used depending on whether the left or right mouse button
    is being used. We can also adjust a wide range of things through the **Transform**
    and **Image** menus. The **Transform** menu contains the ability to affect the
    size and placement of the pixels in the image. The **Image** menu contains the
    image alteration tools such as the ability to change the color, blur the image,
    and add glows.'
  prefs: []
  type: TYPE_NORMAL
- en: Rather than talking about the image editor, let's build some art assets in it.
    We will start by creating a tileset and then move onto an animated character,
    both of which can be used later in [Chapter 4](ch04.html "Chapter 4. The Adventure
    Begins"), *The Adventure Begins*. If you would rather work in an external editor,
    feel free to still follow along as the general theory of creating these assets
    is somewhat universal.
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing the image editor](img/4100OT_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating backgrounds with tilesets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **tileset** is a special type of background asset that allows games to have
    an immense amount of variation in the environment without using a lot of computer
    memory. It is important to keep the file size and memory usage small, especially
    for HTML5 games. The browser needs to download all these assets because we have
    no idea how powerful a computer the user has.
  prefs: []
  type: TYPE_NORMAL
- en: Creating natural looking tilesets is all about tricking the eye. Our eyes are
    very good at spotting patterns; they recognize differences in shape, contrast,
    and color, when there is repetition. Knowing that our brains are hardwired this
    way allows us to use this to our advantage. We can break up patterns by using
    odd shapes, minimizing contrast, and using similar colors in our artwork.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to create a tileset for one of the most common surfaces seen in
    games: a stone floor. Now this may seem easy, but it is amazing how often this
    is done incorrectly.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating backgrounds with tilesets](img/4100OT_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Create a new background resource and name it `bg_StoneFloor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we want this to be a tileset, make sure you check the box for **Use as
    tile set**. This will display the **Tile Properties** which allows you to set
    the tile width and height, offsets, and separation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **tile width** and **tile height** to `32` as seen in the preceding
    image. We are now ready to start building tiles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Edit Background** button. This will open up the **Image Editor**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are going to start by creating the master tile from which all other tiles
    will be based. In the **Image Editor**, Select **File** | **New** and set the
    **Width** and **Height** to `32`.![Creating backgrounds with tilesets](img/4100OT_02_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Fill an Area** tool and apply a light gray color to the entire
    sprite. This is the base and we will change the colors later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before starting to paint in a bunch of stones, we need to first think about
    the potential issues and the best solution for solving them. The most common problem
    people have creating a tileset is that they start by trying to create the final
    product instead of building up to it. This includes choosing the colors and adding
    details before ensuring that it can, in fact, tile properly.
  prefs: []
  type: TYPE_NORMAL
- en: When looking at tiling textures, we need to ensure that we try our best to break
    the grid. The entire world is going to be based on small, 32 x 32 pixel tiles,
    but we don't want the viewer to notice this. Our goal then, is to use irregular
    shapes and attempt to avoid horizontal and vertical alignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating backgrounds with tilesets](img/4100OT_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Select the **Draw on the Image** tool and a dark gray color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make life a bit easier we can zoom in on the image. This can be done with
    the magnifying glass or with the middle mouse scroll button.![Creating backgrounds
    with tilesets](img/4100OT_02_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw the outlines of small rocks, but do remember to keep a bit of variety in
    the size and shape. Also, don't forget to keep the diagonal lines to a width of
    just one pixel! Once you have done this, it should look similar to the preceding
    example screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Image Editor** menu, select **Transform** | **Shift**. This will
    open the **Shift the Image** dialog box that allows you to move pixels horizontally
    or vertically.![Creating backgrounds with tilesets](img/4100OT_02_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Horizontal** and **Vertical** values to `16` and check the **Wrap
    Horizontally** and **Wrap Vertically** boxes. This will move the image 16 pixels
    down and to the right (half the tile size), and wrap the remaining pixels as can
    be seen in the preceding screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By shifting the pixels we can now see how the edges would have tiled. You probably
    notice that it doesn't work perfectly. In the following example screenshot, you
    can see that there are several lines that just end without creating whole stones.
    You may also not like the size of certain stones or see lines that are too thick.
    The goal here is to fix this up and repeat the process until everything lines
    up as you like.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating backgrounds with tilesets](img/4100OT_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Draw the lines and cover over the old ones where necessary to fix any stones
    that appeared to be incorrect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Re-apply the **Transform** | **Shift** tool with the same settings. If you see
    errors, fix them and repeat until you are happy.![Creating backgrounds with tilesets](img/4100OT_02_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we are satisfied with the tile pattern and that it repeats correctly along
    the edges, we are ready to add color. In general, it is best not to use a fully
    desaturated gray color scheme to represent stone, as most stones have some color.
    When selecting colors, the goal is to avoid using just a single color with light/dark
    variations, but rather choose a range of similar colors. To do this, start by
    selecting a neutral base color like beige. From there, each additional color should
    have a slight change in **hue**, **saturation,** and **luminance**. For example,
    the second color could be slightly redder, a bit less vibrant, and darker than
    the first beige.
  prefs: []
  type: TYPE_NORMAL
- en: Select a light brown color and use the **Fill an Area** tool to fill in a few
    of the stones.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat this process with the other brown variants until there are no gray colored
    stones remaining.![Creating backgrounds with tilesets](img/4100OT_02_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once all the stones have been filled, we need to make sure it still tiles. Use
    **Transform** | **Shift** to see if the colors line up correctly. If there are
    any issues (as seen in the preceding screenshot) just adjust the colors until
    you are happy again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final step for our base tile is to change the dark gray lines into a dark
    brown. Now you are probably thinking that this is going to be incredibly tedious,
    but luckily, the image editor has a tool to make this easy.
  prefs: []
  type: TYPE_NORMAL
- en: Select a dark brown color with the left mouse button. This color should appear
    under **Color** | **Left**.![Creating backgrounds with tilesets](img/4100OT_02_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Change all Pixels with the Same Color** tool, as seen previously,
    and left click on one of the dark gray pixels. The stone outline should all be
    the dark brown color now, as we will see in the following screenshot:![Creating
    backgrounds with tilesets](img/4100OT_02_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Excellent work! We now have a base tile to build all our other tiles from.
    The next step is to add border tiles so that there is an edge for separating different
    materials. If we are going to have a square room, we will need a total of nine
    tiles: the base tile and the eight tiles representing border edges and corners.
    Let''s add some more space to our canvas and fill it up with our tiles.'
  prefs: []
  type: TYPE_NORMAL
- en: Select **Transform** | **Resize Canvas**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increase the **New Size** | **Width** and **New Size** | **Height** by `300`
    percent or `96` pixels. Then under **Position** click on the center square so
    that the canvas expands all around the tile we created. The settings can be seen
    in the following screenshot.![Creating backgrounds with tilesets](img/4100OT_02_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will want to make sure that you line everything up correctly, so turn on
    the grid. Select **View** | **Toggle Grid** or click on the **Toggle Grid** icon.![Creating
    backgrounds with tilesets](img/4100OT_02_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point you probably can't see any grid. This is because the default grid
    is set to 1 x 1 pixel. Select **View** | **Grid Options** to open the **Grid Settings**.
    Change the **Horizontal size** and **Vertical size** to `32` and check **Snap
    to the grid**. Feel free to change the **Color**, as we did in the previous screenshot,
    if you want. Then click on **OK**.![Creating backgrounds with tilesets](img/4100OT_02_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the **Selecting a Region** tool, drag to select the entire base tile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Copy** (*Ctrl* + *C*) and **Paste** (*Ctrl* + *V*) the tile and then drag
    it into one of the available spaces. Repeat this step until all nine spots have
    a base tile in them as seen in the following screenshot:![Creating backgrounds
    with tilesets](img/4100OT_02_17.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back to the **View** | **Grid Options** and turn off **Snap to the grid**.
    Otherwise you will get very frustrated trying to draw the borders!![Creating backgrounds
    with tilesets](img/4100OT_02_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want a border of eight pixels in thickness. Using the same colors as the
    stones, use the **Draw a Line** tool to create a border around the outer perimeter
    of the tileset as seen previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fantastic work! We now have a basic tileset, so let's test it out.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't already have one, create a new room.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Room Properties** editor, select the **tiles** tab.![Creating backgrounds
    with tilesets](img/4100OT_02_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it isn't already selected, set the background image to `bg_StoneFloor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To select a tile, just left click on the one you want to use in the preview
    area as seen in the preceding screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is possible to have multiple layers of tiles which can be very useful when
    you want to place odd shaped tiles (a tree, a signpost) without having to create
    new ones for each surface type (stone floor, grass). It is also useful for compiling
    several tiles to create a more natural surface, such as the stone floor with a
    dirt tiles set on top.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to keep this simple so let's leave the **Current Tile Layer** at
    `1000000`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the room, use left click to place an individual tile or hold *Shift* to paint
    tiles in the room. Try to layout the tiles as if there were multiple rooms with
    hallways, much like the following screenshot.![Creating backgrounds with tilesets](img/4100OT_02_20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It looks fairly decent, but there are some noticeable issues, specifically that
    the inner corners do not have the borders on them. You may also feel that the
    tiles repeat a little too much with an area this large. Since we are going to
    create more tiles for the first problem, we might as well add a few for the second!
  prefs: []
  type: TYPE_NORMAL
- en: Reopen the `bg_StoneFloor` if it isn't still open and select **Transform** |
    **Resize Canvas**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increase the size by `133` percent or to `128` pixels. Under **Position** click
    on the upper left arrow, then click on **OK**. It should now look like the following
    screenshot.![Creating backgrounds with tilesets](img/4100OT_02_21.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **View** | **Toggle Grid** so that we can see the grid. We need to copy
    the original base tile, which we can find in row two and column two.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the **Selecting a Region** tool, select the pixels from the original base
    tile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy and paste this tile into each empty cell on the outer edge of the image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to create four corner pieces to fix our room layout. For this we will
    use the four tiles along the right-hand side edge that we just placed. Use the
    **Draw on the Image** tool to draw the corner trim and repeat this for all four
    corner tiles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have three remaining tiles along the bottom which we will use as alternates
    to the base tile. As long as we don't affect a one pixel border around the outer
    edge, we can change the inside as much as we want and it will still tile properly.
  prefs: []
  type: TYPE_NORMAL
- en: Change the shape and alternate the colors of a few of the stones in the inner
    area of each of the three remaining tiles. The tileset, as seen in the following
    screenshot, is now complete!![Creating backgrounds with tilesets](img/4100OT_02_22.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, go back to the room and place down the corner tiles where necessary
    and lay down a random variation of the alternate tiles.![Creating backgrounds
    with tilesets](img/4100OT_02_23.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, with a small 128 x 128 texture we can easily fill a large area
    while providing the illusion of randomness. To add more variation, we could easily
    create palette swap versions, where we can adjust the hue and saturation. So we
    could have, for example, a blue-gray tileset. With more practice we can start
    adding details such as shadows to add more perspective to the world. For all your
    future tilesets, just remember to use non-uniform shapes, minimize the contrast,
    and vary the colors only slightly. More importantly, always ensure that the base
    tile repeats correctly before building the edges and alternates!
  prefs: []
  type: TYPE_NORMAL
- en: Animating and creating sprites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Animated sprites are a sequence of static images which, when played, appear
    to have a movement. It lets the player know that they are running, when they are
    attacking with a sword, and that a button is clickable. Good games have animation
    on everything interactive and often on many of the background elements, so much
    so that you may not even notice it. It is the tiny details such as animation that
    really breathe life into a game.
  prefs: []
  type: TYPE_NORMAL
- en: The illusion of action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating animation takes time and a sharp eye, but basic animation, even of
    characters, can be done by everyone. There are a few important rules to follow
    to make animating easier. First, it is about the appearance of an action, rather
    than the accuracy of an action. As can be seen in the following screenshot, the
    first sword set swinging animation is technically accurate; the sword would be
    in each of these positions. However, the second set will appear more natural as
    it includes a blur effect that one would expect to see in a sword swing.
  prefs: []
  type: TYPE_NORMAL
- en: '![The illusion of action](img/4100OT_02_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Maximize the sprite space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second rule is maximizing the sprite space. Most games use box-based collision
    rather than pixel perfect collision. Therefore you want to use as much of the
    sprite as available for the animation you need. Often developers waste a lot of
    space because they are thinking in terms of the real world instead of a game world.
    For example, one common issue can be seen in a jump animation. In the following
    screenshot, the first jump animation has the character starting from the ground,
    jumping up into the air, falling down, and landing. The second jump animation
    is the same, but all the empty space has been removed. Not only is this more efficient,
    but it can also help to prevent collision bugs since we always know where the
    collision box is.
  prefs: []
  type: TYPE_NORMAL
- en: '![Maximize the sprite space](img/4100OT_02_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Looping an animation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last major rule and probably the most important is repeatability. Most of
    the game animation is at some point going to loop, and having a noticeable repeating
    sequence is going to be very jarring to the player. One common cause of these
    repeatability issues is having too much animation. The more frames of animation
    you have, the more likely that something will pop out. The key here is simplicity
    and removing the frames you do not need. In the following screenshot you can see
    two running animations, the first with five frames and the second with only three.
    The top one will appear a bit smoother but also a bit less repeatable due to the
    slight differences in the stride. The second one in the end will look better as
    it has fewer frames and less difference in the stride as a result.
  prefs: []
  type: TYPE_NORMAL
- en: '![Looping an animation](img/4100OT_02_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With those three rules in mind, let''s build a simple character run cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new sprite and name it `spr_WalkCycle`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Edit Sprite**; this will open the **Sprite Editor**. This editor
    is for dealing with the all the individual images that make up an animated sprite.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Sprite Editor**, select **File** | **New** which will open a dialog
    box for the new image dimensions. Keep it at `32` x `32` and click on **OK**.![Looping
    an animation](img/4100OT_02_27.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should now see, as in the previous screenshot, an empty image titled **image
    0** in the **Sprite Editor**. Double click on the image to open the **Image Editor**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we need a character design. When designing your character you need to think
    about what the character is going to do, the world they exist in, and the collision
    area. In our case, the character will only walk, the world will be an outdoor
    adventure game, and will have a large square collision box.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you don't want to come up with your own character we have supplied a sprite,
    `Chapter_02/Sprites/WalkCycle.gif`, with the first frame of animation.
  prefs: []
  type: TYPE_NORMAL
- en: The first frame of animation that we will create should be the character at
    their full extension of their walk cycle, the legs far apart, and touching the
    bottom of the sprite. The character will be at the lowest point of the stride
    on this frame, so make sure that the head is at least one pixel, preferably two,
    away from the top of the sprite.![Looping an animation](img/4100OT_02_28.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The character designed here in the preceding screenshot is an ape type creature
    wearing a jacket. The reason for the jacket is to make the arms more readable
    when they swing. We can see that this character is quite thick which makes the
    large collision area more believable. Finally, the back leg is a little darker
    as if there were a shadow. Once again, this is to help with readability.
  prefs: []
  type: TYPE_NORMAL
- en: Once we are happy with the first frame, we need to move onto the next keyframe.
    A **keyframe** is the point in an animation where the biggest amount of change
    happens. In this case it will be when the character is at their highest point
    and the arms and legs are crossing each other.
  prefs: []
  type: TYPE_NORMAL
- en: '![Looping an animation](img/4100OT_02_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the **Sprite Editor**, select **Animation** | **Set Length** and set the
    **Number of frames** to `3`, as seen in the previous screenshot. This will duplicate
    the first frame twice, giving us two more frames of animation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open **image 1** and use the **Selecting a Region** tool to raise the upper
    half of the body to the top of the sprite as seen in the following screenshot.
    This frame will represent the highest point of the stride, where the character
    is on one foot with the other foot crossing over. We can also select and shift
    the hands and feet to quickly get them into position.![Looping an animation](img/4100OT_02_30.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the pencil and eraser tools, paint the arms and legs into the appropriate
    position with the leg on the ground in the front of the leg being lifted and only
    one arm showing. Once you are happy with what it looks like, close the image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open **image 2**. This is the opposite motion of the first frame which makes
    things quite easy to change. The hands and feet are already in position, so we
    just need to repaint the arms and legs accordingly, as seen in the following screenshot
    on the left-hand side. Once this is done, close the image.![Looping an animation](img/4100OT_02_31.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we need to duplicate **image 1** and place it at the end so that the walk
    cycle can loop. Select **image 1** and copy and paste the frame. This will duplicate
    the frame and is labeled **image 2**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **image 2** and click on the right facing arrow in the **Sprite Editor**
    toolbar. This will move the frame to the end of the animation. Select and open
    **image 3** so we can repaint the legs so that the back leg is on the ground and
    the front leg is in the air, crossing over. Once this is done, close the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To see how the animation plays, check the **Show Preview** checkbox in the **Sprite
    Editor** and set the **Speed** to `5`. See the following screenshot.![Looping
    an animation](img/4100OT_02_32.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There we have it! A decent walk cycle that loops properly, if a little choppy.
    If we want to smoothen this animation a bit, just add a frame of animation in
    between the keyframes and follow the same procedure we just went through. It should
    end up looking something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Looping an animation](img/4100OT_02_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Manufacturing audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Audio is incredibly important for creating a professional quality game. Unfortunately,
    it is often the most neglected element and the last to be implemented. One reason
    for this is the fact that we can play a game without the audio and still enjoy
    the experience. However, a good soundscape in a game will make it much more immersive
    and help improve user feedback.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to create audio we will need to use external software, as GameMaker:
    Studio does not come with any built-in audio creation tools. There are a range
    of software choices to choose from. For creating sound effects and music there
    are popular programs such as the very full featured **Reason**, [http://www.propellerheads.se/](http://www.propellerheads.se/),
    which emulates a rack of synthesizers, mixers, and other components. On the free
    side, there is **BFXR** , [http://www.bfxr.net/](http://www.bfxr.net/), that allows
    you to create game sounds online and then there is also **Sonant** , [http://sonantlive.bitsnbites.eu/](http://sonantlive.bitsnbites.eu/),
    for making music. All these packages are fun and easy to use. One thing to keep
    in mind is that audio is very challenging to create. Sometimes it is better to
    just download some free music or sounds and there are plenty of sites out there
    with both free and purchasable audio. **Freesound** , `http://www.freesound.org`,
    have thousands of audio clips that you can download and use. For a more classic
    chiptune style of music and sounds there is the **8-bit Collective** , `http://8bc.org/`,
    a site dedicated to game audio.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the audio file formats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If adding audio wasn''t challenging enough already, HTML5 makes it just a little
    bit harder. The first difficulty we will encounter is the fact that the HTML5
    audio tag has not been standardized as of yet. There are two file formats competing
    to be the official HTML5 standard: MP3 and OGG. The **MP3** file format is one
    of the most commonly used formats, but has the drawback of being licensed and
    patented, which could result in large fees being paid out. The **OGG** file format
    is both open source and patent free making it a viable alternative. On top of
    this issue is the fact that the various browsers have their own preference for
    file types. For example, Internet Explorer accepts MP3s but not OGG, while Opera
    accepts OGG but not MP3\. Google Chrome and Mozilla Firefox are hedging their
    bets and support both. GameMaker: Studio deals with this issue by converting all
    audio to both MP3 and OGG file formats when the game is exported.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the GM:S Audio engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GameMaker: Studio comes with two different sound engines for controlling the
    various audio in games: **GM:S Audio** and **Legacy Sound**. These systems are
    completely independent from each other and you can have one system or the other
    active in a game.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The GM:S Audio engine is the new, more robust sound system that was designed
    to allow a full 3D soundscape through the use of emitters and listeners. **Emitters**
    allow for the positioning in game space where sounds are going to occur. There
    are functions for adding falloff of the sounds, velocity to emulate movement,
    and more. **Listeners** give even more control by dictating how the sound is played
    based on where the player is in the game, including their orientation and velocity.
    If you do not declare a listener, then the sounds become universal. This will
    eventually become the primary audio engine in GameMaker: Studio, but because of
    the HTML5 audio issues, it doesn''t work properly in all browsers.'
  prefs: []
  type: TYPE_NORMAL
- en: The Legacy Sound engine is the original sound system that GameMaker used and
    as the name indicates, this engine is no longer being actively developed and many
    of the functions have already been made obsolete. It is a much simpler system
    with no 3D capabilities, though for most games this will be more than enough.
    The one big benefit this engine has is that the audio should work in all browsers.
  prefs: []
  type: TYPE_NORMAL
- en: We will be using the Legacy Sound engine throughout this book to ensure maximum
    capability, but we need to know how to use the GM:S Audio engine for the future.
    Let's test these features by creating a very simple demonstration of positional
    sound. We are going to create an object in our room and make it play a sound that
    can only be heard as the mouse approaches the location.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the GM:S Audio engine](img/4100OT_02_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In order to select which system you are using, click on **Resources** | **Change
    Global Game Settings**. In the **General Tab**, there is a **Use New Audio Engine**
    checkbox; make sure you check this. If it is checked, it is using the GM:S Audio
    engine; if it is not, then it is using Legacy Sound.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Sound and name it `snd_Effect`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load `Chapter 2/Sounds/Effect.wav`. Make sure the **Kind** is set to **Normal
    Sound**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object and name it `obj_Sound`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new Script and name it `scr_Sound_Create`. First, we need to create
    an emitter and capture it in a variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we will position the emitter to where our object is. The parameters for
    this function are: the emitter to apply this to and the X/Y/Z coordinates. We
    will use the object''s X and Y, but since this is a 2D example, we will set the
    Z to 0:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We also want to have a **falloff** on the emitter so that the sound becomes
    louder as the listener approaches. The parameters we have are: the emitter, the
    distance for how far the sound should be at half volume, the total falloff distance,
    and the falloff factor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The emitter is all set up; now let''s play the sound on the emitter. The parameters
    for this function are: the emitter, the sound to play, whether it should loop,
    and its priority. We will want this to **loop** so that we can hear the sound:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is finished and should look like the following when all put together:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Add a **Create** event and drag a **Control** | **Execute Script** icon into
    the Actions with this script attached.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The sound will play now, but it will not have a direction until we have a **listener**.
    We will move the listener position based on the location of the mouse on every
    step. Create a new Script and name it `scr_Sound_Step`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We only need one line of code for positioning the listener's X/Y/Z coordinates.
    The X and Y will be set to the mouse X and Y and once again Z is set to `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: On the `obj_Sound` object, add a **Step** | **Step** event and drag an **Execute
    Script** icon into the Actions with the step script attached.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open up the room and place the instance of `obj_Sound` object into the center
    of the room.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should be able to hear the sound quietly and as you move the mouse around
    closer to the center of the screen the louder it should become. If you have surround
    sound or headphones, you will also notice that the sound moves from the left to
    the right channels. This is just a sample of what can be done with the GM:S Audio
    engine and it will be exciting to use once it works in all browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Raising the quality bar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When looking at the hundreds of thousands of games out there, it is quite easy
    to recognize the top-tier games from the bottom-tier. However, when we look across
    the spectrum at all the best games, there is a stark difference between them.
    Some games are very minimalist, some are photo-realistic, while others are fantastical.
    These games might be made by a few people, or a large team of specialists. What
    is it that makes games that are fundamentally so different still able to achieve
    the same definition of quality? The answer is quite simple and can be summed up
    by three general principles: Consistency, Readability, and Polish. While creating
    high caliber art and audio, it does require plenty of acquired skills learned
    through years of study and practice. Following these few rules will help make
    any game appear more professional.'
  prefs: []
  type: TYPE_NORMAL
- en: Consistency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consistency sounds obvious but it is actually a lot more challenging than one
    might expect. Each sprite, background, or other art asset needs to be built with
    the same rule set. In the following screenshot you can see three variations of
    a plane flying with a city background. The first image is completely inconsistent
    as it has a flat shade with a pixel block styled plane and a photo-realistic background.
    The next image is more consistent than the first image as the city is flat shaded,
    but it lacks the crispness of the pixel block style. This is where most people
    might stop as it is close enough but there is still room for improvement. The
    final image is the most consistent as everything has the flat shading and the
    pixel block styling.
  prefs: []
  type: TYPE_NORMAL
- en: This process works just as easily in the opposite direction by having the plane
    become more photo-realistic. All that is needed is to choose one set of options
    and apply it equally across everything.
  prefs: []
  type: TYPE_NORMAL
- en: '![Consistency](img/4100OT_02_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Readability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Readability is all about ensuring that the correct information is being conveyed
    to the user. This can mean a wide range of things such as making sure the background
    is separated from the foreground, or making sure that collectible items don't
    look like hazards. In the following image, there are two sets of potions; one
    is poison and the other gives health. Just having a different color is not as
    readable to the player as indicating poison with a skull and the health with a
    heart. It is important to allow the player to easily understand what is going
    on so that they can react to it rather than contemplate it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Readability](img/4100OT_02_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Polish
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, the biggest factor, though often the least visible, is polish. Polish
    is all about the small details. It is a wide ranging element that covers everything
    from having particle effects when you collect an item to ensuring that the scoreboard
    is properly centered. In the following image, we have two avatar icons with statistic
    bars. The one on the left is functionally correct and looks decent. The one on
    the right, however, appears to be much more polished. The statistic bars are moved
    to the left so that there is no gap between them and the avatar icon, which was
    also centered properly. Hopefully you can see how a few slight adjustments can
    add a lot to the quality of polish.
  prefs: []
  type: TYPE_NORMAL
- en: '![Polish](img/4100OT_02_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating art and audio for games is an enormous task, both in terms of the
    time it takes and the assets to be produced. As a game developer, it is your responsibility
    to ensure that everything is cohesive and aesthetically pleasing, whether you
    are creating the assets or working with artists and sound designers. In this chapter
    you have started to understand how art and audio works in GameMaker: Studio and
    what the difference is between good and good enough. You learned about the acceptable
    image formats and how to import a sprite sheet. You created a tileset that will
    make better use of computer memory and allow for large unique worlds. You animated
    a sprite and made it loop properly. You also learned how to control sounds and
    the direction they are heard from. You are now ready to start making real games!'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we are going to build our second game, a side scrolling
    shooter. We will create a player that moves around the screen, build several enemies
    that shoot weapons, create moving backgrounds, and implement a win/lose condition.
    Most exciting of all is that we will do all of this while learning the **GameMaker
    Language** (**GML**).
  prefs: []
  type: TYPE_NORMAL
