- en: Composing Readable Go Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写可读的Go代码
- en: 'Learning how to write readable Go code is an essential part of the language.
    Language developers used their previous experience while writing other languages
    to create a language that they felt was clear and concise. A commonly used phrase
    in describing the proper way to write with this language is *idiomatic Go*. This
    phrase is used to describe the *correct* way to program in Go. Style is often
    subjective, but the Go team has worked hard in order to write the language in
    an opinionated way and facilitate developer velocity, readability, and collaboration.
    In this chapter, we are going to talk about how to maintain some core tenets of
    the language:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何编写可读的Go代码是语言的一个重要部分。语言开发人员在编写其他语言时使用了他们的先前经验来创建一种他们认为清晰简洁的语言。在描述使用这种语言编写的正确方式时，经常使用的短语是*惯用Go*。这个短语用来描述在Go中编程的*正确*方式。风格往往是主观的，但Go团队为了以一种有见地的方式编写语言并促进开发者的速度、可读性和协作而努力工作。在本章中，我们将讨论如何保持语言的一些核心原则：
- en: Simplicity
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单
- en: Readability
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可读性
- en: Packaging
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包
- en: Naming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名
- en: Formatting
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式化
- en: Interfaces
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口
- en: Methods
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法
- en: Inheritance
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承
- en: Reflection
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反射
- en: Understanding these patterns and idioms will help you to write Go code that
    is more easily readable and operable between teams. Being able to write idiomatic
    Go will help raise the level of your code quality and help your project maintain
    velocity.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这些模式和惯用法将帮助您编写更易读和可操作的Go代码。能够编写惯用的Go将有助于提高代码质量水平，并帮助项目保持速度。
- en: Maintaining simplicity in Go
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持Go中的简单性
- en: Out of the box, Go doesn't follow specific patterns that other programming languages
    use. The writers chose different idioms for some of these following language constructs
    in order to keep the language simple and clear. Keeping the simplicity of the
    language has been a difficult task for language developers. Having tooling, libraries,
    fast execution, and fast compilation, all while maintaining simplicity, has been
    at the forefront of the language's development. Go's language developers have
    kept on track with these decisions with a design-by-consensus model—having a general
    consensus on adding things to a language ensures they are added in a way that
    is important to the development of the language.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Go默认不遵循其他编程语言使用的特定模式。作者选择了不同的惯用法来保持语言简单和清晰。保持语言的简单性对语言开发人员来说是一项艰巨的任务。拥有工具、库、快速执行和快速编译，同时保持简单性，一直是语言开发的重中之重。Go的语言开发人员一直坚持这些决定，采用共识设计模式——对向语言添加新功能的共识确保了这些功能的重要性。
- en: Language maintainers are active on the GitHub issues page and are very happy
    to review pull requests if you have them. Getting feedback from others who write
    with the language allows language maintainers to make informed decisions about
    adding new features and functionality to the language while maintaining readability
    and simplicity.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 语言维护者在GitHub的问题页面上活跃，并且非常乐意审查拉取请求。从其他使用该语言的人那里获得反馈，使语言维护者能够就向语言添加新功能和功能做出明智的决定，同时保持可读性和简单性。
- en: 'The following section will show us the next fundamental aspect of the Go language:
    readability.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分将向我们展示Go语言的下一个基本方面：可读性。
- en: Maintaining readability in Go
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持Go语言中的可读性
- en: Readability is another core tenet of Go. Being able to quickly grok a new code
    base and understand some of its nuances is an important part of any programming
    language. As distributed systems continue to grow, with vendored libraries and
    APIs becoming more commonplace, being able to easily read the code that is included
    and be able to make sense of it is helpful for forward momentum. This also makes
    broken code easier to fix.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性是Go的另一个核心原则。能够快速理解新代码库并理解其中一些微妙之处是任何编程语言的重要部分。随着分布式系统的不断增长，供应商库和API变得更加普遍，能够轻松阅读包含的代码并理解其中的意义对于推动前进是有帮助的。这也使得破损的代码更容易修复。
- en: Having concrete data types, interfaces, packages, concurrency, functions, and
    methods has helped Go to continue moving forward. Readability is one of the most
    important parameters of being able to maintain a large code base over an extended
    period of time, and this is one of the most important things that sets Go apart
    from its competitors. The language was constructed with readability as a first
    class citizen.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有具体的数据类型、接口、包、并发、函数和方法有助于Go继续前进。可读性是能够在较长时间内维护大型代码库的最重要参数之一，这是Go与竞争对手之间最重要的区别之一。该语言是以可读性作为一等公民构建的。
- en: Go has a lot of complex looking underlying internal parts of the language, but
    these are really not complex at all. Things such as simply defined constants,
    interfaces, packages, garbage collection, and easy to implement concurrency are
    all complex under the hood, but transparent to the end user. Having these constructs
    available  has helped to make Go thrive as a language.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言有许多复杂的底层内部部分，但这些实际上并不复杂。诸如简单定义的常量、接口、包、垃圾回收和易于实现的并发等都是复杂的内部部分，但对最终用户来说是透明的。拥有这些构造有助于使Go语言蓬勃发展。
- en: Let's see what packaging in Go means in the next section.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节看看Go语言中的打包意味着什么。
- en: Exploring packaging in Go
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Go中的打包
- en: Packaging is a fundamental part of the Go language. Every single Go program
    is required to have a package definition on the first line of the program. This
    helps readability, maintainability, referencing, and organization.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 打包是Go语言的一个基本部分。每个Go程序都需要在程序的第一行定义一个包。这有助于可读性、可维护性、引用和组织。
- en: The `main` package in a Go program uses the main declaration. This main declaration
    calls the `main` function of the program. After this occurs, we have other imports
    within the `main` function that can be used to import other packages within the
    program. We should try and keep the main package small in order to modularize
    all dependencies within our programs. We will talk about package naming next.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Package naming
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While naming packages, developers should adhere to the following rules:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Packages shouldn't have underscores, hyphens, or mixedCaps
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packages shouldn't be named with generic naming schemes, such as common, util,
    base, or helper
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package naming should be related to the function that the package is performing
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packages should retain a decent-sized scope; all the elements in a package should
    have similar goals and objectives
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing internal packages can help while you're vetting new packages before
    they are aligned with your public API
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packaging layout
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we discuss the layout of a Go program, we have a couple of different processes
    that we should follow. A common convention is to keep your main programs in a
    folder named `cmd`. Your other packages that you build to be executed from the `main`
    function should live in a `pkg` directory. This separation helps to encourage
    the reuse of packages. In the following example, if we want to reuse the notification
    package for both the CLI and web main programs, we have the ability to do that
    easily with one import. The following a screenshot shows this separation:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2cc26180-33c9-43f4-9e5b-cfd15626cdc3.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: 'An anti-pattern for Go is to have a one-to-one file for package mapping. We
    should be writing Go with the idea of driving common use cases together within
    a specific directory structure. For example, we could create a single directory
    per file and test it as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7259ab0e-d9fa-475c-b009-2f29fc0ca1d2.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: 'Instead, however, we should create our packages as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c59b9d7d-6f00-4d7a-bcd5-cf018c48e5b5.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
- en: All of these different notification strategies share a common practice. We should
    attempt to keep similar functionality coupled in the same package. This will help
    others to understand any context in which the notifications package has similar
    functionality.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Internal packaging
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many Go programs use the concept of an internal package in order to signify
    an API that is not ready for external consumption. The idea of internal packages
    was first introduced in Go 1.4, to add boundaries around components within your
    program. These internal packages cannot be imported from outside the subtree in
    which they are stored. This is useful if you want to maintain your internal packages
    and not expose them to the rest of the program. Once you've vetted internal packages
    in the manner you deem fit, you can change the folder name and expose the previously
    internal package.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de065a1d-6412-4b9d-95de-bb151434405f.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, we can see that we have an internal directory. This
    is only accessible from within this project. The `pkg` and `cmd` directories,
    however, will be accessible from other projects. This is important as we continue
    to develop new products and features that should not yet be available for import
    in other projects.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Vendor directory
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The idea of a vendor directory originated with the release of Go 1.5\. The
    `vendor` folder is a place to store a compiled grouping of external and internal
    sources into a directory within the project. This means that the code composer
    no longer has to copy in dependent packages to the source tree. The `vendor` folder
    is searched for when the `GOPATH` looks for dependencies. This is good for a number
    of reasons:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: We can keep local copies of external dependencies on our projects. This can
    be helpful if we want to execute our programs on networks that have limited or
    no external network connectivity.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This makes compilation of our Go programs faster. Storing all of these vendored
    dependencies locally means that we don't need to pull down our dependencies at
    build time.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you'd like to use third-party code but have tweaked it for your particular
    use case, you can vendor that code and change it for internal release.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go modules
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go modules were introduced in Go 1.11\. They afford the ability to keep track
    of versioned dependencies within a Go code base. They are a collection of Go packages
    that are stored as a cohesive unit in a `go.mod` file within a project directory.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'We will perform the following steps to initialize a new module:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'We first execute `go mod init repository`:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After you've initialized this new module, you can build your Go package and
    execute it as you normally would. You'll have any imported modules from within
    your project saved in a `go.mod` file within your project's directory.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As an example, if we want to be able to create a simple web server using the
    Gin framework [[https://github.com/gin-gonic/gin](https://github.com/gin-gonic/gin)],
    we would create a directory for this in our project structure as follows: `/home/bob/git/HighPerformanceWithGo/6-composing-readable-go-code/goModulesExample`.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'We next create a simple web server that returns a response with  `bar` to a
    `/foo` request:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After this, we can create a new Go module in our newly created directory:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0a10594a-9569-461b-aca2-1c5d84a65580.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
- en: 'Next, we can execute our Go program; the proper dependencies will be pulled
    in as necessary:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/840e0cfe-d102-4b92-b4b9-95bb3ca725d7.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
- en: 'We can now see that we have our dependencies for our simple web server stored
    in the `go.sum` file within our directory (I''ve used the `head` command to truncate
    the list to the top 10 entries):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c420a06b-62d2-4fed-a04e-91e34413a63e.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
- en: Go modules help keep vendored items within a Go repository clean and consistent.
    We can also use a vendored repository if we want to keep all of our dependencies
    local to our project.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Opinions on vendoring dependencies within your repository often vary greatly.
    Some like to use a vendored repository because it decreases build time and limits
    the risk of not being able to pull packages from an external repository. Others
    feel that vendoring can be a hindrance to package updates and security patches.
    Whether you choose to use a vendored directory in your program is up to you, but
    the fact that Go modules include this functionality in the language is convenient.
    The following output illustrates this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23e64c8a-290f-46fb-8f24-aa4aaaa29eff.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
- en: Being able to vendor directories with the built-in compilation tools makes it
    easy to set up and configure.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss naming things in Go.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Understanding naming in Go
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a lot of consistent behaviors that Go programmers like to retain
    in order to keep readable, maintainable code. Go naming schemes tend to be consistent,
    accurate, and short. We want to create names with the following idioms in mind:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'Local variables for iterators should be short and simple:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i` for an iterator; `i` and `j` if you have a two-dimensional iterator'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r` for a reader'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`w` for a writer'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch` for channels'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Global variable names should be short and descriptive:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RateLimit`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Log`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pool`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Acronyms should follow the convention of using all capitals:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FooJSON`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FooHTTP`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Avoid stuttering with the package name:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log.Error()` instead of `log.LogError()`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Interfaces with one method should follow the method name plus the `-er` suffix:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stringer`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Reader`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Writer`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Logger`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Names in Go should follow a Pascal or mixedCaps case method:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`var ThingOne`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`var thingTwo`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's important to remember that, if a name has an initial capital letter, it
    is exported and can be used in other functions. Remember this whilst coming up
    with your own naming schemes for things.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Following some of these naming conventions can you to have readable, consumable,
    reusable code. Another good practice is to use consistent naming styles. If you're
    instantiating the same type of parameter, make sure that it follows a consistent
    naming convention. This makes it easier for new consumers to follow along with
    the code that you have written.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss formatting Go code.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Understanding formatting in Go
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in [Chapter 1](27d9fd37-672c-499b-88b9-89b9990117ed.xhtml), *Introduction
    to Performance in Go*, `gofmt` is an opinionated formatter for Go code. It indents
    and aligns your code the way the language maintainers intended for it to be read.
    Many of the most popular code editors today can execute `gofmt` when a file is
    saved. Doing this, as well as having your continuous integration software verification,
    saves you having to focus on the formatting of the code that you're writing since
    the language will be prescriptive in output. Using this tool will make Go code
    easier to read, write, and maintain with multiple contributors. It also removes
    quite a bit of controversy within the language, since spaces, tabs, and braces
    are positioned automatically.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also add a pre-commit hook to our Git repository (in `.git/hooks/pre-commit`)
    in order to corroborate the fact that all of the code that is being committed
    to a repository is formatted as expected. The following code block illustrates
    this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After we add this pre-commit hook, we can confirm that things are working as
    expected by adding some erroneous spacing to a file within our repository. After
    we do so and `git commit` our code, we will see a warning message as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`gofmt` also has a lesser known but vastly helpful simplify method, which will
    perform source transformations where possible. This will take some of the composite,
    slice and range composite literals, and shorten them. The simplify formatting
    command will take the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will simplify to the following code: `gofmt -s gofmtSimplify.go`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of this `gofmt` code snippet is as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that the variable `b` in the preceding code snippet has a simple definition
    and that the empty variable in the range definition has been removed by the `gofmt`
    tool. This tool can help you to have more cleanly defined code in your repository.
    It can also be used as a mechanism for writing code in such way that the writer
    can think through the problem, but the resulting code from `gofmt` can be stored
    in the shared repository in a tightly knit fashion.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss interfaces in Go.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Briefing on interfaces in Go
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go's interfacing system is different from the interfacing systems in other languages.
    They are named collections of methods. Interfaces are important in composing readable
    Go code because they make the code scalable and flexible. Interfaces also give
    us the ability to have polymorphism (providing a single interface to items with
    different types) in Go. Another positive aspect of interfaces is that they are
    implicitly implemented—the compiler checks that a specific type implements a specific
    interface.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define an interface as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If we want to implement an interface, all we need to do is implement the methods
    that are referenced in the interface. The compiler validates your interface's
    methods so that you don't have to perform this action.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also define an empty interface, which is an interface that has zero
    methods, represented by `interface{}`. Empty interfaces are valuable and practical
    in Go, as we can pass arbitrary values to them, as shown in the following code
    block:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As we execute our empty interface example, we can see that the type and value
    of the x interface change as we change the definition of the (initially) empty
    interface:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c77209dc-7c5a-47e0-ad53-ab7a6d084287.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: Empty, mutable interfaces are convenient because they give us the flexibility
    to manipulate our data in a way that makes sense to the code composer.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss comprehending methods in Go.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Comprehending methods in Go
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Methods in Go are functions that have a special type, called a `receiver`, that
    sits between the `function` keyword and the method name associated with the keyword.
    Go doesn't have classes in the same manner that other programming languages do
    . Structs are often used in conjunction with methods in order to bundle data and
    its corresponding methods in a similar fashion to how classes are constructed
    in other languages. As we instantiate a new method, we can add struct values in
    order to enrich the function call.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'We can instantiate a structure and a method as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After this has been done, we can then use this struct and method to display
    information about a user as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will return the result from `userExample.displayEmail()`, which prints
    the pertinent part of the structs as part of the method call as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cc7465c3-67c7-48fa-9461-d20edab04dad.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: As we have larger structs of data, we have the ability to reference the data
    that is stored within these structs easily and effectively. If we decided that
    we wanted to write a method to find the end user's phone number, it would be simple
    to use our existing data type and write a method similar to the `displayEmail`
    method in order to return the end user's phone number.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: The methods we have looked at so far only have value receivers. Methods can
    also have pointer receivers. Pointer receivers are helpful when you would like
    to update the data in place and have the results available to the caller function.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Consider our previous example with a couple of modifications. We are going to
    have two methods that will allow us to update our user's email address and phone
    number. The email address update is going to use a value receiver, whereas the
    phone update is going to use a pointer receiver.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'We create these functions in the following code block in order to be able to
    update the end user''s information easily:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We next create our example end user in `main`, as shown in the following code
    block:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We then update the email and phone number of our end user in the following
    code block:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In our resulting output, we can see that the user email has not been updated
    from the perspective of the receiver, but that the user''s phone number has:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a399ec7d-6ede-4114-b0a5-79f20cc686d6.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
- en: This is important to remember when attempting to mutate state from within method
    calls. Methods are very helpful in manipulating data in Go programs.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: It's now time to see what inheritance in Go is all about.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Comprehending inheritance in Go
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go does not have inheritance. Composition is used in order to embed items (mostly
    structs) in one another. This is convenient when you have a baseline struct that
    is used for many different functions, with other structs that build on top of
    the initial struct.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: We can describe some of the items in my kitchen to show how inheritance works.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'We can initialize our program as shown in the following code block. In this
    block, we create two structs:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '`Utensils`: For the utensils I have in my drawers in my kitchen'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '`Appliances`: For the appliances I have in my kitchen'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'I can next use Go''s nested structuring to create a `Kitchen` struct that contains
    all of the utensils and appliances as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'I can then fill my kitchen with the utensils and appliances that I have:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Once all of these things are in, we can see the resulting output where my kitchen
    items (the `Utensils` and `Appliances`) are organized in my `Kitchen` struct.
    My `Kitchen` struct is then easily referenced later in other methods.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Having nested structs can be very practical for future extension. If I decided
    that I'd like to add other elements in my house to this structure, I could make
    a `House` struct and nest my `Kitchen` struct within the `House` struct. I could
    also compose structs for other rooms in my house and add them to the house struct
    as well.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore reflection in Go.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Exploring reflection in Go
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reflection in Go is a form of metaprogramming. Using reflection in Go lets the
    program understand its own structure. There are times when you want to use a variable
    at runtime that doesn't exist when the program was composed. We use reflection
    to check the key and value pair that is stored within an interface variable. Reflection
    is not often clear, so be wary of using it—it should be used in special cases
    when necessary. It only has runtime checks (not compile checks), so we need to
    use reflection with common sense.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s important to remember that Go''s variables are statically typed. There
    are many different variable types that we can use in Go—`rune`, `int`, `string`,
    and so on. We can declare a specific type as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Both variables, `x` and `y`, will be int typed variables.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three important pieces of reflection that are used in order to find
    out information:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Types
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kinds
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Values
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These three different pieces all work together to deduce the information you
    might need to know in relation to an interface. Let's take a look at each one
    individually and see how they mesh together.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Types
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Being able to tell the type of a variable is important in Go. In our example,
    we can validate the fact that a string type is, in fact, a string, as shown in
    the following code block:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output from our program will show us that the reflection type will accurately
    derive the `foo string` type:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f130eaff-5d87-4cb7-87d2-445a2c22918b.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
- en: 'Although this example is simple, it''s important to understand the underlying
    principle: if, instead of validating the string, we are looking at an incoming
    network call or the return from an external library call, or trying to build a
    program that can handle different types, the reflection library''s `TypeOf` definition
    can help us to identify these types correctly.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Kinds
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A kind is used as a placeholder to define the kind of type that a specific
    type represents. It is used to denote what the type is made of. This is very useful
    in determining what sort of structure has been defined. Let''s look at an example:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In our example, we can see that we have created a slice of strings – `foo`,
    `bar`, and `baz`. From there, we can use reflection to find the type of `i`, and
    we can use the `Kind()` function to determine what the type is made of—in our
    case, a slice as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/97e57f40-2a7e-409a-b097-8cc345e9c95c.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
- en: This can be useful if we want to deduce the type of a particular interface.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Values
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Values in reflection help to read, set, and store results on particular variables.
    In the following example, we can see that we set an example variable, `foo`, and,
    using the reflection package, we can deduce the value of our example variable
    in the resulting print statement as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In our output, we can see that the value of the example variable, `foo`, gets
    returned:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3cfa0b8-90ae-4ce5-9e59-ceb21c646150.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
- en: These three different functions within the reflect system help us to deduce
    types that we can use within our code base.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to use some core tenets of the language to write
    readable Go code. We learned how simplicity and readability are important, and
    how packaging, naming, and formatting are vital to writing readable Go. Also,
    we learned how interfaces, methods, inheritance, and reflection can all be used
    to write code that others can understand. Being able to use these core Go concepts
    effectively will help you produce more efficient code.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn about memory management in Go and
    how to optimize for the memory resources that we have at hand.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习Go语言中的内存管理，以及如何针对手头的内存资源进行优化。
