- en: Composing Readable Go Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Learning how to write readable Go code is an essential part of the language.
    Language developers used their previous experience while writing other languages
    to create a language that they felt was clear and concise. A commonly used phrase
    in describing the proper way to write with this language is *idiomatic Go*. This
    phrase is used to describe the *correct* way to program in Go. Style is often
    subjective, but the Go team has worked hard in order to write the language in
    an opinionated way and facilitate developer velocity, readability, and collaboration.
    In this chapter, we are going to talk about how to maintain some core tenets of
    the language:'
  prefs: []
  type: TYPE_NORMAL
- en: Simplicity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Readability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packaging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Naming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reflection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding these patterns and idioms will help you to write Go code that
    is more easily readable and operable between teams. Being able to write idiomatic
    Go will help raise the level of your code quality and help your project maintain
    velocity.
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining simplicity in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Out of the box, Go doesn't follow specific patterns that other programming languages
    use. The writers chose different idioms for some of these following language constructs
    in order to keep the language simple and clear. Keeping the simplicity of the
    language has been a difficult task for language developers. Having tooling, libraries,
    fast execution, and fast compilation, all while maintaining simplicity, has been
    at the forefront of the language's development. Go's language developers have
    kept on track with these decisions with a design-by-consensus model—having a general
    consensus on adding things to a language ensures they are added in a way that
    is important to the development of the language.
  prefs: []
  type: TYPE_NORMAL
- en: Language maintainers are active on the GitHub issues page and are very happy
    to review pull requests if you have them. Getting feedback from others who write
    with the language allows language maintainers to make informed decisions about
    adding new features and functionality to the language while maintaining readability
    and simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following section will show us the next fundamental aspect of the Go language:
    readability.'
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining readability in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Readability is another core tenet of Go. Being able to quickly grok a new code
    base and understand some of its nuances is an important part of any programming
    language. As distributed systems continue to grow, with vendored libraries and
    APIs becoming more commonplace, being able to easily read the code that is included
    and be able to make sense of it is helpful for forward momentum. This also makes
    broken code easier to fix.
  prefs: []
  type: TYPE_NORMAL
- en: Having concrete data types, interfaces, packages, concurrency, functions, and
    methods has helped Go to continue moving forward. Readability is one of the most
    important parameters of being able to maintain a large code base over an extended
    period of time, and this is one of the most important things that sets Go apart
    from its competitors. The language was constructed with readability as a first
    class citizen.
  prefs: []
  type: TYPE_NORMAL
- en: Go has a lot of complex looking underlying internal parts of the language, but
    these are really not complex at all. Things such as simply defined constants,
    interfaces, packages, garbage collection, and easy to implement concurrency are
    all complex under the hood, but transparent to the end user. Having these constructs
    available  has helped to make Go thrive as a language.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see what packaging in Go means in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring packaging in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Packaging is a fundamental part of the Go language. Every single Go program
    is required to have a package definition on the first line of the program. This
    helps readability, maintainability, referencing, and organization.
  prefs: []
  type: TYPE_NORMAL
- en: The `main` package in a Go program uses the main declaration. This main declaration
    calls the `main` function of the program. After this occurs, we have other imports
    within the `main` function that can be used to import other packages within the
    program. We should try and keep the main package small in order to modularize
    all dependencies within our programs. We will talk about package naming next.
  prefs: []
  type: TYPE_NORMAL
- en: Package naming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While naming packages, developers should adhere to the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Packages shouldn't have underscores, hyphens, or mixedCaps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packages shouldn't be named with generic naming schemes, such as common, util,
    base, or helper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package naming should be related to the function that the package is performing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packages should retain a decent-sized scope; all the elements in a package should
    have similar goals and objectives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing internal packages can help while you're vetting new packages before
    they are aligned with your public API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packaging layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we discuss the layout of a Go program, we have a couple of different processes
    that we should follow. A common convention is to keep your main programs in a
    folder named `cmd`. Your other packages that you build to be executed from the `main`
    function should live in a `pkg` directory. This separation helps to encourage
    the reuse of packages. In the following example, if we want to reuse the notification
    package for both the CLI and web main programs, we have the ability to do that
    easily with one import. The following a screenshot shows this separation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2cc26180-33c9-43f4-9e5b-cfd15626cdc3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'An anti-pattern for Go is to have a one-to-one file for package mapping. We
    should be writing Go with the idea of driving common use cases together within
    a specific directory structure. For example, we could create a single directory
    per file and test it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7259ab0e-d9fa-475c-b009-2f29fc0ca1d2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Instead, however, we should create our packages as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c59b9d7d-6f00-4d7a-bcd5-cf018c48e5b5.png)'
  prefs: []
  type: TYPE_IMG
- en: All of these different notification strategies share a common practice. We should
    attempt to keep similar functionality coupled in the same package. This will help
    others to understand any context in which the notifications package has similar
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Internal packaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many Go programs use the concept of an internal package in order to signify
    an API that is not ready for external consumption. The idea of internal packages
    was first introduced in Go 1.4, to add boundaries around components within your
    program. These internal packages cannot be imported from outside the subtree in
    which they are stored. This is useful if you want to maintain your internal packages
    and not expose them to the rest of the program. Once you've vetted internal packages
    in the manner you deem fit, you can change the folder name and expose the previously
    internal package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de065a1d-6412-4b9d-95de-bb151434405f.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, we can see that we have an internal directory. This
    is only accessible from within this project. The `pkg` and `cmd` directories,
    however, will be accessible from other projects. This is important as we continue
    to develop new products and features that should not yet be available for import
    in other projects.
  prefs: []
  type: TYPE_NORMAL
- en: Vendor directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The idea of a vendor directory originated with the release of Go 1.5\. The
    `vendor` folder is a place to store a compiled grouping of external and internal
    sources into a directory within the project. This means that the code composer
    no longer has to copy in dependent packages to the source tree. The `vendor` folder
    is searched for when the `GOPATH` looks for dependencies. This is good for a number
    of reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: We can keep local copies of external dependencies on our projects. This can
    be helpful if we want to execute our programs on networks that have limited or
    no external network connectivity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This makes compilation of our Go programs faster. Storing all of these vendored
    dependencies locally means that we don't need to pull down our dependencies at
    build time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you'd like to use third-party code but have tweaked it for your particular
    use case, you can vendor that code and change it for internal release.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go modules were introduced in Go 1.11\. They afford the ability to keep track
    of versioned dependencies within a Go code base. They are a collection of Go packages
    that are stored as a cohesive unit in a `go.mod` file within a project directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will perform the following steps to initialize a new module:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first execute `go mod init repository`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: After you've initialized this new module, you can build your Go package and
    execute it as you normally would. You'll have any imported modules from within
    your project saved in a `go.mod` file within your project's directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As an example, if we want to be able to create a simple web server using the
    Gin framework [[https://github.com/gin-gonic/gin](https://github.com/gin-gonic/gin)],
    we would create a directory for this in our project structure as follows: `/home/bob/git/HighPerformanceWithGo/6-composing-readable-go-code/goModulesExample`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We next create a simple web server that returns a response with  `bar` to a
    `/foo` request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, we can create a new Go module in our newly created directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0a10594a-9569-461b-aca2-1c5d84a65580.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we can execute our Go program; the proper dependencies will be pulled
    in as necessary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/840e0cfe-d102-4b92-b4b9-95bb3ca725d7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can now see that we have our dependencies for our simple web server stored
    in the `go.sum` file within our directory (I''ve used the `head` command to truncate
    the list to the top 10 entries):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c420a06b-62d2-4fed-a04e-91e34413a63e.png)'
  prefs: []
  type: TYPE_IMG
- en: Go modules help keep vendored items within a Go repository clean and consistent.
    We can also use a vendored repository if we want to keep all of our dependencies
    local to our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Opinions on vendoring dependencies within your repository often vary greatly.
    Some like to use a vendored repository because it decreases build time and limits
    the risk of not being able to pull packages from an external repository. Others
    feel that vendoring can be a hindrance to package updates and security patches.
    Whether you choose to use a vendored directory in your program is up to you, but
    the fact that Go modules include this functionality in the language is convenient.
    The following output illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23e64c8a-290f-46fb-8f24-aa4aaaa29eff.png)'
  prefs: []
  type: TYPE_IMG
- en: Being able to vendor directories with the built-in compilation tools makes it
    easy to set up and configure.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss naming things in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding naming in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a lot of consistent behaviors that Go programmers like to retain
    in order to keep readable, maintainable code. Go naming schemes tend to be consistent,
    accurate, and short. We want to create names with the following idioms in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Local variables for iterators should be short and simple:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i` for an iterator; `i` and `j` if you have a two-dimensional iterator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r` for a reader'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`w` for a writer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch` for channels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Global variable names should be short and descriptive:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RateLimit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Log`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pool`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Acronyms should follow the convention of using all capitals:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FooJSON`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FooHTTP`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Avoid stuttering with the package name:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log.Error()` instead of `log.LogError()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Interfaces with one method should follow the method name plus the `-er` suffix:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stringer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Reader`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Writer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Logger`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Names in Go should follow a Pascal or mixedCaps case method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`var ThingOne`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`var thingTwo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's important to remember that, if a name has an initial capital letter, it
    is exported and can be used in other functions. Remember this whilst coming up
    with your own naming schemes for things.
  prefs: []
  type: TYPE_NORMAL
- en: Following some of these naming conventions can you to have readable, consumable,
    reusable code. Another good practice is to use consistent naming styles. If you're
    instantiating the same type of parameter, make sure that it follows a consistent
    naming convention. This makes it easier for new consumers to follow along with
    the code that you have written.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss formatting Go code.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding formatting in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in [Chapter 1](27d9fd37-672c-499b-88b9-89b9990117ed.xhtml), *Introduction
    to Performance in Go*, `gofmt` is an opinionated formatter for Go code. It indents
    and aligns your code the way the language maintainers intended for it to be read.
    Many of the most popular code editors today can execute `gofmt` when a file is
    saved. Doing this, as well as having your continuous integration software verification,
    saves you having to focus on the formatting of the code that you're writing since
    the language will be prescriptive in output. Using this tool will make Go code
    easier to read, write, and maintain with multiple contributors. It also removes
    quite a bit of controversy within the language, since spaces, tabs, and braces
    are positioned automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also add a pre-commit hook to our Git repository (in `.git/hooks/pre-commit`)
    in order to corroborate the fact that all of the code that is being committed
    to a repository is formatted as expected. The following code block illustrates
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After we add this pre-commit hook, we can confirm that things are working as
    expected by adding some erroneous spacing to a file within our repository. After
    we do so and `git commit` our code, we will see a warning message as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`gofmt` also has a lesser known but vastly helpful simplify method, which will
    perform source transformations where possible. This will take some of the composite,
    slice and range composite literals, and shorten them. The simplify formatting
    command will take the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This will simplify to the following code: `gofmt -s gofmtSimplify.go`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of this `gofmt` code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that the variable `b` in the preceding code snippet has a simple definition
    and that the empty variable in the range definition has been removed by the `gofmt`
    tool. This tool can help you to have more cleanly defined code in your repository.
    It can also be used as a mechanism for writing code in such way that the writer
    can think through the problem, but the resulting code from `gofmt` can be stored
    in the shared repository in a tightly knit fashion.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss interfaces in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Briefing on interfaces in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go's interfacing system is different from the interfacing systems in other languages.
    They are named collections of methods. Interfaces are important in composing readable
    Go code because they make the code scalable and flexible. Interfaces also give
    us the ability to have polymorphism (providing a single interface to items with
    different types) in Go. Another positive aspect of interfaces is that they are
    implicitly implemented—the compiler checks that a specific type implements a specific
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define an interface as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If we want to implement an interface, all we need to do is implement the methods
    that are referenced in the interface. The compiler validates your interface's
    methods so that you don't have to perform this action.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also define an empty interface, which is an interface that has zero
    methods, represented by `interface{}`. Empty interfaces are valuable and practical
    in Go, as we can pass arbitrary values to them, as shown in the following code
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As we execute our empty interface example, we can see that the type and value
    of the x interface change as we change the definition of the (initially) empty
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c77209dc-7c5a-47e0-ad53-ab7a6d084287.png)'
  prefs: []
  type: TYPE_IMG
- en: Empty, mutable interfaces are convenient because they give us the flexibility
    to manipulate our data in a way that makes sense to the code composer.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss comprehending methods in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Comprehending methods in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Methods in Go are functions that have a special type, called a `receiver`, that
    sits between the `function` keyword and the method name associated with the keyword.
    Go doesn't have classes in the same manner that other programming languages do
    . Structs are often used in conjunction with methods in order to bundle data and
    its corresponding methods in a similar fashion to how classes are constructed
    in other languages. As we instantiate a new method, we can add struct values in
    order to enrich the function call.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can instantiate a structure and a method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After this has been done, we can then use this struct and method to display
    information about a user as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return the result from `userExample.displayEmail()`, which prints
    the pertinent part of the structs as part of the method call as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cc7465c3-67c7-48fa-9461-d20edab04dad.png)'
  prefs: []
  type: TYPE_IMG
- en: As we have larger structs of data, we have the ability to reference the data
    that is stored within these structs easily and effectively. If we decided that
    we wanted to write a method to find the end user's phone number, it would be simple
    to use our existing data type and write a method similar to the `displayEmail`
    method in order to return the end user's phone number.
  prefs: []
  type: TYPE_NORMAL
- en: The methods we have looked at so far only have value receivers. Methods can
    also have pointer receivers. Pointer receivers are helpful when you would like
    to update the data in place and have the results available to the caller function.
  prefs: []
  type: TYPE_NORMAL
- en: Consider our previous example with a couple of modifications. We are going to
    have two methods that will allow us to update our user's email address and phone
    number. The email address update is going to use a value receiver, whereas the
    phone update is going to use a pointer receiver.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create these functions in the following code block in order to be able to
    update the end user''s information easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We next create our example end user in `main`, as shown in the following code
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We then update the email and phone number of our end user in the following
    code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In our resulting output, we can see that the user email has not been updated
    from the perspective of the receiver, but that the user''s phone number has:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a399ec7d-6ede-4114-b0a5-79f20cc686d6.png)'
  prefs: []
  type: TYPE_IMG
- en: This is important to remember when attempting to mutate state from within method
    calls. Methods are very helpful in manipulating data in Go programs.
  prefs: []
  type: TYPE_NORMAL
- en: It's now time to see what inheritance in Go is all about.
  prefs: []
  type: TYPE_NORMAL
- en: Comprehending inheritance in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go does not have inheritance. Composition is used in order to embed items (mostly
    structs) in one another. This is convenient when you have a baseline struct that
    is used for many different functions, with other structs that build on top of
    the initial struct.
  prefs: []
  type: TYPE_NORMAL
- en: We can describe some of the items in my kitchen to show how inheritance works.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can initialize our program as shown in the following code block. In this
    block, we create two structs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Utensils`: For the utensils I have in my drawers in my kitchen'
  prefs: []
  type: TYPE_NORMAL
- en: '`Appliances`: For the appliances I have in my kitchen'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'I can next use Go''s nested structuring to create a `Kitchen` struct that contains
    all of the utensils and appliances as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'I can then fill my kitchen with the utensils and appliances that I have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Once all of these things are in, we can see the resulting output where my kitchen
    items (the `Utensils` and `Appliances`) are organized in my `Kitchen` struct.
    My `Kitchen` struct is then easily referenced later in other methods.
  prefs: []
  type: TYPE_NORMAL
- en: Having nested structs can be very practical for future extension. If I decided
    that I'd like to add other elements in my house to this structure, I could make
    a `House` struct and nest my `Kitchen` struct within the `House` struct. I could
    also compose structs for other rooms in my house and add them to the house struct
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore reflection in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring reflection in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reflection in Go is a form of metaprogramming. Using reflection in Go lets the
    program understand its own structure. There are times when you want to use a variable
    at runtime that doesn't exist when the program was composed. We use reflection
    to check the key and value pair that is stored within an interface variable. Reflection
    is not often clear, so be wary of using it—it should be used in special cases
    when necessary. It only has runtime checks (not compile checks), so we need to
    use reflection with common sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s important to remember that Go''s variables are statically typed. There
    are many different variable types that we can use in Go—`rune`, `int`, `string`,
    and so on. We can declare a specific type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Both variables, `x` and `y`, will be int typed variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three important pieces of reflection that are used in order to find
    out information:'
  prefs: []
  type: TYPE_NORMAL
- en: Types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kinds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These three different pieces all work together to deduce the information you
    might need to know in relation to an interface. Let's take a look at each one
    individually and see how they mesh together.
  prefs: []
  type: TYPE_NORMAL
- en: Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Being able to tell the type of a variable is important in Go. In our example,
    we can validate the fact that a string type is, in fact, a string, as shown in
    the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from our program will show us that the reflection type will accurately
    derive the `foo string` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f130eaff-5d87-4cb7-87d2-445a2c22918b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Although this example is simple, it''s important to understand the underlying
    principle: if, instead of validating the string, we are looking at an incoming
    network call or the return from an external library call, or trying to build a
    program that can handle different types, the reflection library''s `TypeOf` definition
    can help us to identify these types correctly.'
  prefs: []
  type: TYPE_NORMAL
- en: Kinds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A kind is used as a placeholder to define the kind of type that a specific
    type represents. It is used to denote what the type is made of. This is very useful
    in determining what sort of structure has been defined. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In our example, we can see that we have created a slice of strings – `foo`,
    `bar`, and `baz`. From there, we can use reflection to find the type of `i`, and
    we can use the `Kind()` function to determine what the type is made of—in our
    case, a slice as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/97e57f40-2a7e-409a-b097-8cc345e9c95c.png)'
  prefs: []
  type: TYPE_IMG
- en: This can be useful if we want to deduce the type of a particular interface.
  prefs: []
  type: TYPE_NORMAL
- en: Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Values in reflection help to read, set, and store results on particular variables.
    In the following example, we can see that we set an example variable, `foo`, and,
    using the reflection package, we can deduce the value of our example variable
    in the resulting print statement as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In our output, we can see that the value of the example variable, `foo`, gets
    returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3cfa0b8-90ae-4ce5-9e59-ceb21c646150.png)'
  prefs: []
  type: TYPE_IMG
- en: These three different functions within the reflect system help us to deduce
    types that we can use within our code base.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to use some core tenets of the language to write
    readable Go code. We learned how simplicity and readability are important, and
    how packaging, naming, and formatting are vital to writing readable Go. Also,
    we learned how interfaces, methods, inheritance, and reflection can all be used
    to write code that others can understand. Being able to use these core Go concepts
    effectively will help you produce more efficient code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn about memory management in Go and
    how to optimize for the memory resources that we have at hand.
  prefs: []
  type: TYPE_NORMAL
