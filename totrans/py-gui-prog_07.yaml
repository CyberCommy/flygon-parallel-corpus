- en: Navigating Records with Treeview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You've received another request for features in the application. Now that your
    users can open arbitrary files, they'd like to be able to see what's in those
    files and correct old records using the data entry form they've grown accustomed
    to, rather than having to switch over to a spreadsheet. In a nutshell, it's finally
    time to implement read and update capabilities in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Modifying our CSV model for read and update capabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discovering the ttk `Treeview` widget, and building a list of records with it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing record loading and updating in our data record form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redesigning the menu and application with read and update in mind
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing read and update in the model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our entire design up to this point has been centered around a form that only
    appends data to a file; adding read and update capabilities is a fundamental change
    that will touch nearly every portion of the application. It may seem like a daunting
    task, but by taking it one component at a time, we'll see that the changes are
    not so overwhelming.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we should do is update our documentation, starting with the
    `Requirements` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And, of course, also update the part that is not required that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, it's a simple matter of making the code match with the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Adding read and update to our model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open `models.py` and consider what''s missing from the `CSVModel` class:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll need a method that can retrieve all records in a file so we can display
    them. We'll call it `get_all_records()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll need a method to fetch individual records from the file by row number.
    We can call this `get_record()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll need to save records in a way that can not only append new records, but
    update existing records as well. We can update our `save_record()` method to accommodate
    this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing  get_all_records()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start a new method called `get_all_records()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we've done is check if the model's file exists yet. Remember
    that when our application starts, it generates a default filename pointing to
    a file that likely doesn't exist yet, so `get_all_records()` will need to handle
    this situation gracefully. It makes sense to return an empty list in this case,
    since there's no data if the file doesn't exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the file does exist, let''s open it in read-only mode and get all the records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'While not terribly efficient, pulling the entire file into memory and converting
    it into a list is acceptable in our case, since we know that our largest files
    should be limited to a mere 401 rows: 20 plots times 5 labs plus a header row.
    This code is just a little too trusting, however. We should at least do some sanity
    checks to make sure that the user has actually opened a CSV file containing the
    proper fields and not some other arbitrary file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check that the file has the correct field structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we first find any missing fields by converting a list of our `fields`
    dictionary `keys` and the CSV file's `fieldnames` to Python `set` objects. We
    can subtract the `fieldnames` set from `keys` and determine which fields, if any,
    are missing in the file. If there are any, we'll raise an exception; otherwise,
    we convert the CSV data to `list`.
  prefs: []
  type: TYPE_NORMAL
- en: Python `set` objects are very useful for comparing the content of the `list`,
    `tuple`, and other sequence objects. They provide an easy way to get information
    such as the difference (items in `x` that are not in `y`) or intersection (items
    in both `x` and `y`) between two sets, or allow you to compare sequences without
    respect to order.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can return the `records` list, we need to correct one issue; all data
    in a CSV file is stored as text, and read by Python as a string. Most of this
    is not a problem, since Tkinter will take care of converting strings to `float`
    or `int` as necessary, but `bool` values are stored in the CSV file as the strings
    `True` and `False`, and coercing these values directly back to `bool` doesn't
    work. `False` is a non-empty string, and all non-empty strings evaluate to `True`
    in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this, let''s first define a list of strings that should be interpreted
    as `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Any values not in this list will be considered `False`. We'll do a case-insensitive
    comparison, so there are only lowercase values in our list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create a list of fields that are `boolean` fields using a list comprehension
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We know that `Equipment Fault` is our only boolean field, so technically we
    could just hardcode that here, but it's a good idea to design your model so that
    any changes to the schema will be automatically handled appropriately by the logic
    portions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s check these boolean fields in each row by adding the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: For every record, we iterate through our list of the boolean fields and check
    its value against our list of truthy strings, setting the value of the item accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the boolean values fixed, we can return our `records` list as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Implementing  get_record()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our `get_record()` method needs to take a row number and return a single dictionary
    containing the data for that row.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is pretty simple if we leverage our `get_all_records()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Since our files are small and there's very little overhead to pulling all the
    records, we can simply do that and then dereference the record we need.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that it's possible to pass `rownum` that doesn't exist in our records
    list; in this case, we'd get `IndexError`; our calling code will need to catch
    this error and deal with it appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Adding update to save_record()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To convert our `save_record()` method so that we can update records, the first
    thing we'll need to do is provide the ability to pass in a row number to update.
    The default will be `None`, which will indicate that the data is a new row that
    should be appended.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new method signature looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Our existing logic doesn't need to change, but it should only be run if `rownum`
    is `None`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the first thing to do in the method is check `rownum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: For relatively small files, the simplest way to update a single row is to load
    the entire file into a list, change the row in the list, and then write the entire
    list back to a clean file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the `if` block, we''ll add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we leverage our `get_all_records()` method to fetch the CSV file's
    content into a list. We then replace the dictionary in the requested row with
    the `data` dictionary provided. Finally, we open the file in write mode (`w`),
    which will clear its content and replace it with whatever we write to the file,
    and write the header and all records back to the file.
  prefs: []
  type: TYPE_NORMAL
- en: The approach we're taking makes it unsafe for two users to work in the save
    CSV file simultaneously. Creating software that allows for multiple users editing
    a single file is notoriously difficult, and many programs simply opt to prevent
    it in the first place using lock files or other protection mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: This method is finished, and that's all we need to change in our model to enable
    updating and viewing. Now, it's time to add the necessary features to our GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a record list view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The record list view will allow our users to browse the content of the file
    and open records for viewing or editing. Our users are accustomed to seeing this
    data in a spreadsheet, laid out in a table-like format, so it makes sense to design
    our view in a similar fashion. Since our view mainly exists for finding and selecting
    individual records, we don't need to display all the information; just enough
    for the users to distinguish one record from another.
  prefs: []
  type: TYPE_NORMAL
- en: A quick analysis shows that we need CSV row number, `Date`, `Time`, `Lab`, and
    `Plot`.
  prefs: []
  type: TYPE_NORMAL
- en: For building table-like views with selectable rows, Tkinter gives us the ttk 
    `Treeview` widget. To build our record list view, we'll need to learn about `Treeview`.
  prefs: []
  type: TYPE_NORMAL
- en: The ttk Treeview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Treeview` is a ttk widget designed to show columns of data in a hierarchical
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps the best example of this kind of data is a filesystem tree:'
  prefs: []
  type: TYPE_NORMAL
- en: Each row can represent a file or directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each directory can contain additional files or directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each row can have additional data properties, such as permissions, size, or
    ownership information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To explore how `Treeview` works, we'll create a simple file browser with some
    help from `pathlib`.
  prefs: []
  type: TYPE_NORMAL
- en: In previous chapters, we used `os.path` to work with file paths. `pathlib` is
    a new addition to the Python 3 standard library that provides a more object-oriented
    approach to paths.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new file called `treeview_demo.py` and start with this template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll start by getting a list of all the file paths under the current working
    directory. `Path` has a method called `glob` that will give us such a list as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`glob()` expands wildcard characters like `*` and `?` against a filesystem
    tree. The name goes back to a very early Unix command, though the same wildcard
    syntax is now used across most modern operating systems.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Path(''.'')` creates a path object referencing the current working directory,
    and `**/*` is a special wildcard syntax that recursively grabs all objects under
    the path. The result is a list of the `Path` objects that include every directory
    and file under our current directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With that done, we can create and configure our `Treeview` widget by executing
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Like any Tkinter widget, the first argument to `Treeview` is its `parent` widget.
    Each column in the `Treeview` widget is given an identifying string; by default,
    there is always one column named `"#0"`. This column represents the basic identifying
    information about each item in the tree, such as a name or ID number. To add more
    columns, we specify them using the `columns` argument. This list contains any
    number of strings that will be used to identify the subsequent columns.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set `selectmode`, which determines how users can select items in
    the tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the options for `selectmode`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Value** | **Behavior** |'
  prefs: []
  type: TYPE_TB
- en: '| `selectmode` | Selections can be made |'
  prefs: []
  type: TYPE_TB
- en: '| `none` (as a string, not the `None` object) | No selections can be made |'
  prefs: []
  type: TYPE_TB
- en: '| `browse` | User can select one item only |'
  prefs: []
  type: TYPE_TB
- en: '| `extended` | User can select multiple items |'
  prefs: []
  type: TYPE_TB
- en: In this case, we're preventing selection, so we set it to `none`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To show how we use the column names, we''ll set some headings for the columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `Treeview` heading method is for manipulating the column `heading` widget;
    it takes the column name, and then any number of attributes you want to assign
    to the column's `heading` widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'Those attributes can include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`text`: The text displayed for the heading. By default, it''s blank.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`anchor`: The alignment of the text; it can be any of eight cardinal directions
    or `center`, specified as strings or Tkinter constants.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`command`: A command to run when the heading is clicked. This might be used
    to order the rows by that column, or select all the values in the column, for
    example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`image`: An image to display in the heading.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, we pack the column into the `root` widget and expand it to fill the
    widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In addition to configuring the headers, we can configure some attributes of
    the column itself using the `Treeview.column` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we've set `stretch` to `True` in the first column, which will
    cause it to expand to fill available; and we've set the `width` value on the `size`
    column to `200` pixels.
  prefs: []
  type: TYPE_NORMAL
- en: 'The column parameters that can be set include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`stretch`: Whether or not to expand this column to fill the available space.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`width`: The width of the column in pixels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minwidth`: The minimum width to which the column can be resized, in pixels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`anchor`: The alignment of the text in the column. Can be any of eight cardinal
    directions or center, specified as strings or Tkinter constants.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the tree view configured, it now needs to be filled with data. Populating
    a `Treeview` with data is done one row at a time using the `insert` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `insert` method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The first argument specifies the `parent` item for the inserted row. This is
    not the `parent` widget, but rather the `parent` row under which the inserted
    row belongs in the hierarchical structure. The value is a string that refers to
    the `iid` of the `parent` item. For top-level items, this value should be an empty
    string.
  prefs: []
  type: TYPE_NORMAL
- en: The next argument specifies where the item should be inserted. It's either a
    numerical index or `end`, which places the item at the end of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, we specify keyword arguments, which can include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`text`: This is the value to be shown in the first column.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`values`: This is a list of values for the remaining columns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`image`: This is an image object to display in the far left of the column.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iid`: The item ID string. This will be automatically assigned if you don''t
    specify it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`open`: Whether or not the row is open (displaying child items) at the start.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tags`: A list of tag strings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To insert our paths into the `Treeview`, let''s iterate our `paths` list as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Before calling `insert`, we need to extract and prepare some data from the path
    object. `path.stat()` will give us an object containing various file information.
    `path.parent` provides us the containing path; however, we need to change the
    name of the `root` path (currently a single dot) to an empty string, which is
    how `Treeview` represents the `root` node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we add the `insert` call as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: By using the path string as the item ID, we can then specify it as a parent
    for its child objects. We use only the object `name` (without the containing path)
    as our display value, then `st_size` and `st_mtime` for populating the size and
    modification time columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run this script and you should see a simple file tree browser that looks something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1ceeffaf-50a0-4c9e-97d3-525c1026367f.png)'
  prefs: []
  type: TYPE_IMG
- en: The `Treeview` widgets doesn't offer any kind of sorting functionality by default,
    but we can add it fairly easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a sorting function by adding the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, the `sort` function takes a `Treeview` widget
    and the ID of a column in which we'll sort. It starts by getting a list of all
    the `iid` values using the `get_children()` method of `Treeview`. Next, it sorts
    the various `iid` values using the value of `col` for each item as a key; rather
    confusingly, the `set()` method of `Treeview` is used to retrieve the value of
    the column (there is no `get()` method). Finally, we iterate the list and use
    the `move()` method to move each item to a new index under its parent (which is
    retrieved using the `parent()` method).
  prefs: []
  type: TYPE_NORMAL
- en: 'To make our columns sortable, add this function as a callback to the headers
    using the `command` argument as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Implementing our record list with Treeview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we understand how to use the `Treeview` widget, let's start building
    our record list widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll begin by subclassing `tkinter.Frame`, just as we did with our record
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: To save ourselves from some repetitious code, we'll define our column properties
    and defaults in class constants. This also makes it easier to tweak them to suit
    our needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start out your class with the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Recall that we're going to be displaying `Date`, `Time`, `Lab`, and `Plot`.
    For the first default column, we'll show the CSV row number. We've also set the `width`
    and `anchor` values for some columns, and configured the `Date` field to stretch.
    We'll use these values when configuring the `Treeview` widget in `__init__()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start our `__init__()` definition as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As with other views, we're going to accept a dictionary of callback methods
    from the `Application` object, and save it as an instance property.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a Treeview widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s create our `Treeview` widget by executing the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note that we're excluding the `#0` column from our `columns` list; it should
    never be specified here since it's automatically created. We're also choosing
    the `browse` select mode, so that users can select individual rows of the CSV
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and add our `Treeview` widget to `RecordList` and make it fill
    the widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, configure the columns and headings of `Treeview` by iterating through
    the `column_defs` dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'For each set of items, let''s extract the configuration values we need as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ll use those values to configure the heading and columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Adding a scrollbar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ttk `Treeview` does not have a scrollbar by default; it *can* be scrolled,
    using the keyboard or mouse-wheel controls, but users would reasonably expect
    a scrollbar on a scrollable area to help them visualize the size of the list and
    their current position in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, ttk provides us with a `Scrollbar` object that can be connected
    to our `Treeview` widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `Scrollbar` takes the following two important arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`orient`: This argument determines whether it is a horizontal or vertical scroll'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`command`: This argument provides a callback for scrollbar move events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, we set the callback to the tree view's `yview` method, which is
    used to make the `Treeview` scroll up and down.  The other option would be `xview`,
    which would be used for horizontal scrolling.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to connect our `Treeview` back to the scrollbar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: If we don't do this, our `Scrollbar` won't know how far down the list we've
    scrolled or how long the list is, and can't set the size or location of the bar
    widget appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: With our `Scrollbar` configured, we need to place it on the widget—conventionally,
    just to the right of the widget being scrolled.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use our `grid` layout manager for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Notice we set `sticky` to north, south, and west. North and south make sure
    the scrollbar stretches the entire height of the widget, and west makes sure it's
    snug against the `Treeview` widget to the left of it.
  prefs: []
  type: TYPE_NORMAL
- en: Populating the Treeview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our `Treeview` widget, we''ll create a `populate()` method
    to populate it with data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `rows` argument will take a list of the `dict` data types, such as what
    is returned from `model`. The idea is that the controller will fetch a list from
    the model and then pass it to this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before refilling `Treeview`, we need to empty it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The   `get_children()` method of `Treeview` returns a list of every row's `iid`.
    We're iterating this list, passing each `iid` to the `Treeview.delete()` method,
    which, as you'd expect, deletes the row.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `Treeview` cleared, we can iterate through the `rows` list and populate
    the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do here is create a list of all the keys we actually want
    to fetch from each row; this is just the list of keys from `self.column_defs`
    minus the `"#0"` column.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we iterate through the rows using the `enumerate()` function to generate
    a row number. For each row, we'll create a list of values in the proper order
    using a list comprehension, then insert the list to the end of the `Treeview` widget
    with the `insert()` method. Notice that we're just using the row number (converted
    to a string) as both `iid` and `text` for the row.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do in this function is a small usability tweak. To
    make our `Treeview` keyboard friendly, we need to focus the first item so that
    keyboard users can immediately start to navigate it via the arrow keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Doing this in a `Treeview` widget actually takes three method calls as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: First, `focus_set` moves focus to `Treeview`. Next, `selection_set(0)` selects
    the first record in the list. Finally, `focus('0')` focuses the row with `iid`
    of `0`. And, of course, we only do this if there are any rows at all.
  prefs: []
  type: TYPE_NORMAL
- en: Responding to record selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The purpose of this widget is for users to select and open records; therefore,
    we need a way to do that. It would be nice to be able to trigger this from an
    event like a double-click or keyboard selection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Treeview` widget has three special events which we can use to trigger
    a callback as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Event string** | **Triggered when** |'
  prefs: []
  type: TYPE_TB
- en: '| `<<TreeviewSelect>>` | A row is selected, such as by clicking it with a mouse
    |'
  prefs: []
  type: TYPE_TB
- en: '| `<<TreeviewOpen>>` | A row is opened by a double-click or by selecting it
    and hitting *Enter* |'
  prefs: []
  type: TYPE_TB
- en: '| `<<TreeviewClose>>` | An open row is closed |'
  prefs: []
  type: TYPE_TB
- en: '`<<TreeviewOpen>>` sounds like the event we want; even though we''re not using
    a hierarchical list, the user is still conceptually opening the record, and the
    triggering action (double-click) seems intuitive. We''ll bind this event to a
    method that will open the selected record.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code at the end of `__init__()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `on_open_record()` method is quite simple; add this code to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: It's as simple as retrieving the selected ID from `Treeview`, then calling a
    function provided by our controller in the `callbacks` dictionary with the selected
    ID. It will be up to the controller to do something appropriate here.
  prefs: []
  type: TYPE_NORMAL
- en: The `RecordList` class is now complete, but some of our other view classes need
    attention.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the record form for read and update
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As long as we're editing views, we'll need to look at our `DataRecordForm` view
    and adjust it to make it capable of updating records.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a moment and consider the following changes we''ll need to make:'
  prefs: []
  type: TYPE_NORMAL
- en: The form will need some way to load in a record provided by the controller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The form will need to keep track of what record it's editing, or if it's a new
    record.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our user will need some visual indication of what record is being edited.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our Save button is currently in the application. It doesn't really make sense
    in any context other than the form, so it should probably be part of the form.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This means our form will need a callback to call when the save button is clicked.
    We'll need to provide it with a `callbacks` dictionary like we did with our other
    views.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating __init__()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start working through these with our `__init__()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We're adding a new argument, `callbacks`, and storing it as an instance property.
    This will give the controller a way to provide methods for the view to call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, our `__init__()` method should set up a variable in which to store the
    current record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We'll use `None` to indicate that no record is loaded and the form is being
    used to create a new record. Otherwise, this value will be an integer referencing
    a row in the CSV data.
  prefs: []
  type: TYPE_NORMAL
- en: We could use a Tkinter variable here, but there's no real advantage in this
    case, and we wouldn't be able to use `None` as a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the form, before the first form fields, let''s add a label that
    will keep track of which record we''re editing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We're placing this in row `0`, column `0`, but the first `LabelFrame` is also
    in that location. You'll need to go through each `LabelFrame` and increment the
    `row` value in its call to `grid`.
  prefs: []
  type: TYPE_NORMAL
- en: We'll make sure this label gets updated whenever a record is loaded into the
    form.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the very end of the widget, after the `Notes` field, let''s add our new
    Save button as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The button will call an `on_save()` method from the `callbacks` dictionary when
    clicked. We'll need to make sure to provide this method when creating `DataRecordForm`
    in `Application`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a load_record() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last thing to add in our view is a method for loading in a new record. This
    method will need to set up our form with a given row number and data dictionary
    from the controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s call it `load_record()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we should do is set the form''s `current_record` value from
    the `rownum` provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Recall that `rownum` could be `None`, indicating that this is a new record.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check for that by executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: If we're going to be inserting a new record, we simply want to reset the form,
    then set the label to indicate that this is a new record.
  prefs: []
  type: TYPE_NORMAL
- en: Note that our `if` condition here checks specifically whether `rownum` is `None`;
    we can't just check the truth value of `rownum`, since `0` is a valid `rownum`
    for updating!
  prefs: []
  type: TYPE_NORMAL
- en: 'If we do have a valid `rownum`, we''ll need it to act differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In this block, we first set the label appropriately with the row number we're
    editing.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we cycle through the keys and widgets of our `inputs` dictionary and pull
    in the matching values from the `data` dictionary. We also attempt to call the
    `trigger_focusout_validation()` method on each widget's input, since it's possible
    that the CSV file contains invalid data. If the input has no such method (that
    is, if we used a regular Tkinter widget rather than one of our custom ones, such
    as with `Checkbutton`), we just do nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the rest of the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before our changes to the form can take effect, we need to update the remaining
    portions of our application for the new functionality. Our main menu needs some
    navigation items so that users can switch between the record list and the form,
    and controller methods need to be created or updated in `Application` to bring
    together our new model and view functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Main menu changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we're already in the `views.py` file, let's start by updating our main
    menu view with some commands to switch between the record list and record form.
    We'll add a `Go` menu containing two more options to our menu that will allow
    switching between the record list and a blank record form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following lines between the `Options` and `Help` menus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: As before, we're binding these menu commands to functions in the `callbacks`
    dictionary, which we'll need to add in our `Application` class.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the pieces in Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s quickly take stock of the following changes we''re going to need to
    make in our `Application` class:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to add an instance of our `RecordList` view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll need to update our use of `CSVModel` so that we can access data from it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll need to implement or refactor several callback methods used by our views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the RecordList view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll create the `RecordList` object in `__init__()`, just after `DataRecordForm`, by
    executing the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Notice that when we call `grid()`, we're adding the `RecordList` view to the
    grid cell that already contains `DataRecordForm`. **This is intentional**. When
    we do this, Tkinter just stacks the second widget on top of the first, like laying
    one piece of paper on top of another; we'll add code in a moment to control which
    view is visible by raising one or the other to the top of the stack. Notice that
    we also stick the widget to all sides of the cell. Without this code, bits of
    one widget might be visible behind the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we need to update the `grid` call for the record form as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Moving the model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Currently, our data model object is only created in the `on_save()` method,
    and is recreated every time the user saves. Some of the other callbacks we''re
    going to write will need access to the model as well, so instead we''ll create
    a single data model instance that can be shared by all the methods when the `Application` class
    is started or whenever a new filename is chosen. Let''s take a look at the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, edit the `Application.__init__()` method right after the `default_filename`
    is created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Next, the `on_file_select()` method needs to recreate the `data_model` object
    whenever the filename is changed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the end of `on_file_select()` to the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Now, `self.data_model` will always point to a current data model and all our
    methods can use it for saving or reading data.
  prefs: []
  type: TYPE_NORMAL
- en: Populating the record list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Treeview` widget is added to our application, but we need a way to fill
    it with data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll create a method called `populate_recordlist()` by executing the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The logic is simple enough: just get all the rows from the model and send them
    to the record list''s `populate()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could write it as simply as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Remember, though, that in the event of a problem with the file, `get_all_records()`
    will raise an `Exception`; we need to catch that exception and let the user know
    things are wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the code with the `try` and `except` blocks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: In this case, if we get an exception from `get_all_records()`, we'll display
    an error dialog showing the `Exception` text.
  prefs: []
  type: TYPE_NORMAL
- en: The `RecordList` view should be repopulated any time a new model gets created;
    currently, that happens in `Application.__init__()` and `Application.on_file_select()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `__init__()` just after the record list is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Update `on_file_select()` at the very end, inside the `if filename:` block
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Adding the new callbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Looking over our view code, the following callback functions need to be added
    to our `callbacks` dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '`show_recordlist()`: This function is called when the user clicks the Record
    List option in the menu, it should cause the record list to be visible'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`new_record()`: This function is called when the user clicks New Record in
    the menu, it should show a reset `DataRecordForm`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`on_open_record()`: This function is called when a record list item is opened,
    it should show `DataRecordForm` which is populated with the ID and data of the
    record'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`on_save()`: This function is called when the Save button (now part of `DataRecordForm`)
    is clicked, it should cause the data in the record form to be updated or inserted
    in the model'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ll start with `show_recordlist()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Remember that when we laid out the main application, we stacked `recordlist`
    on top of the data entry form, so that one obscured the other. The `tkraise()`
    method can be called on any Tkinter widget to raise it to the top of a stack of
    widgets. Calling it here will raise our `RecordList` widget to the top and obscure
    the data entry form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t forget to add the following content to the `callbacks` dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Both the `new_record()` and `on_open_record()` callbacks cause `recordform`
    to be displayed; one is called without a row number, and the other is called with
    a row number. We can easily answer both of these in a single method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s call that method `open_record()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Remember that our `DataRecordForm.load_record()` method takes a row number and
    a `data` dictionary, and that if the row number is `None`, it resets the form
    for a new record. So, all we need to do is set the row number and record accordingly
    and pass them into the `load_record()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll handle `rownum` being `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Without a row number, there is no record. Easy enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if there is a row number, we need to attempt to fetch that row from the
    model and use that for `record`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Note that Tkinter may be passing in `rownum` as a string, since the `iid` values
    of `Treeview` are strings. We'll do a safety cast to `int`, since that's what
    our model expects.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that in the event of a problem reading the file, the model throws an
    `Exception`, so we should catch this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Place the call to `get_record()` inside a `try` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In the event of an `Exception`, we'll display an error dialog and return from
    the function without changing anything.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `rownum` and `record` set correctly, we can now pass them to `DataRecordForm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to raise the `form` widget so that it''s on top of the record
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can update our `callbacks` dictionary to point those keys to the new
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: You could argue that we shouldn't have the same method in here twice, and just
    have our views pull the same key; however, it makes sense to let the views refer
    to callbacks semantically—that is, in terms of what they intend to accomplish,
    rather than how it's accomplished—and then letting the controller determine which
    piece of code best meets that semantic need. If, at some point, we need to separate
    these into two methods, we'll only need to do that in `Application`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already have a method for `on_save()`, so that''s simple enough to add to
    our callbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: However, our current `on_save()` method only handles inserting new records.
    We'll need to fix that.
  prefs: []
  type: TYPE_NORMAL
- en: First, we can remove the two lines that fetch the filename and create the model,
    since we can just use the `Application` object's `data_model` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, replace the next couple of lines with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: We simply need to get the data and current record from `DataRecordForm`, then
    pass them to the model's `save_record()` method. Remember that if we send `rownum`
    of `None`, the model will insert a new record; otherwise it will update the record
    at that row number.
  prefs: []
  type: TYPE_NORMAL
- en: Because `save_record()` can throw a couple of different exceptions, it's under
    a `try` block here.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, if we try to update a row number that doesn''t exist, we''ll get `IndexError`,
    so let''s catch that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: In the event of the problem, we're going to show an error dialog and update
    the status text.
  prefs: []
  type: TYPE_NORMAL
- en: The `save_record()` method can also throw a generic `Exception`, since it calls
    the model's `get_all_records()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll catch this as well and show an appropriate error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The remaining code in this method should only be run if no exceptions were
    thrown, so move it under an `else` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Since inserting or updating records will usually cause a change in the record
    list, we should also repopulate the record list after a successful file save.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line under the `if` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we only want to reset the record form if we're inserting new files;
    if not, we should do nothing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Put the call to `recordform.reset()` under an `if` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Cleaning up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before coming out of `application.py`, make sure to remove the Save button code,
    since we've moved that piece of UI to the `DataRecordForm`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look for these lines in `__init__()` to remove them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also move the `statusbar` position up one row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Testing our program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, you should be able to run the application and load in a sample
    CSV file as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3b8b74a3-4a1c-4b7d-b269-4110be95eabf.png)'
  prefs: []
  type: TYPE_IMG
- en: Make sure to try opening a record, editing and saving it, as well as inserting
    new records and opening different files.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should also test the following error conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: Try opening a file that isn't a CSV file, or a CSV with incorrect fields. What
    happens?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open a valid CSV file, select a record for editing, then, before clicking Save,
    select a different or empty file. What happens?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open two copies of the program and point them to the saved CSV file. Try alternating
    edit or update actions between the programs. Note what happens.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have changed our program from being an append-only form to an application
    capable of loading, viewing, and updating data from existing files. You learned
    how to make a read-write model, work with the ttk `Treeview`, and modify the existing
    views and controller to read and update records.
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, we'll be learning how to modify the look and feel of our
    application. We'll learn about using widget attributes, styles, and themes, as
    well as working with bitmapped graphics.
  prefs: []
  type: TYPE_NORMAL
