- en: Chapter 7. Python Extensions in Other Languages
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。其他语言中的Python扩展
- en: 'When writing Python-based applications, you are not limited to the Python language
    alone. There are tools such as Hy, mentioned briefly in [Chapter 3](ch03.html
    "Chapter 3. Syntax Best Practices – above the Class Level"), *Syntax Best Practices
    – above the Class Level*. It allows you to write modules, packages, or even whole
    applications with some other language (dialect of Lisp) that will run in Python
    virtual machine. Although it gives you the ability to express program logic with
    completely different syntax, it is still quite the same language because it compiles
    to the same bytecode. It means that it has the same limitations as ordinary Python
    code:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写基于Python的应用程序时，您不仅限于Python语言。还有一些工具，比如Hy，在[第3章](ch03.html "第3章。语法最佳实践-类级别以上")中简要提到，*语法最佳实践-类级别以上*。它允许您使用其他语言（Lisp的方言）编写模块、包，甚至整个应用程序，这些应用程序将在Python虚拟机中运行。尽管它使您能够用完全不同的语法表达程序逻辑，但它仍然是相同的语言，因为它编译成相同的字节码。这意味着它具有与普通Python代码相同的限制：
- en: Threading usability is greatly reduced due to the existence of GIL
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于GIL的存在，线程的可用性大大降低
- en: It is not compiled
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它没有被编译
- en: It does not provide static typing and possible optimizations that come with
    it
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不提供静态类型和可能的优化
- en: The solution that helps in overcoming such core limitations are extensions that
    are entirely written in a different language and expose their interface through
    Python extension APIs.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助克服这些核心限制的解决方案是完全用不同的语言编写的扩展，并通过Python扩展API公开它们的接口。
- en: 'This chapter will discuss the main reasons for writing your own extensions
    in other languages and introduce you to the popular tools that help to create
    them. You will learn:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论使用其他语言编写自己的扩展的主要原因，并向您介绍帮助创建它们的流行工具。您将学到：
- en: How to write simple extensions in C using the Python/C API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Python/C API编写简单的C扩展
- en: How to do the same using Cython
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Cython做同样的事情
- en: What are the main challenges and problems introduced by extensions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展引入的主要挑战和问题是什么
- en: How to interface with compiled dynamic libraries without creating dedicated
    extensions and using only Python code
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何与编译的动态库进行接口，而不创建专用扩展，仅使用Python代码
- en: Different language means – C or C++
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的语言意味着-C或C++
- en: When we talk about extensions in different languages, we think almost exclusively
    about C and C++. Even tools such as Cython or Pyrex that provide Python language
    supersets only for the purpose of extensions are in fact source-to-source compilers
    that generate the C code from extended Python-like syntax.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论不同语言的扩展时，我们几乎只考虑C和C++。甚至像Cython或Pyrex这样的工具，它们提供Python语言的超集，仅用于扩展的目的，实际上是源到源编译器，从扩展的Python-like语法生成C代码。
- en: It's true that you can use dynamic/shared libraries written in any language
    in Python if only such compilation is possible and so it goes a way beyond C and
    C++. But shared libraries are intrinsically generic. They can be used in any language
    that supports their loading. So, even if you write such a library in a completely
    different language (let's say Delphi or Prolog), it is hard to name such library
    a Python extension if it does not use the Python/C API.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只有这样的编译是可能的，那么确实可以在Python中使用任何语言编写的动态/共享库，因此它远远超出了C和C++。但共享库本质上是通用的。它们可以在支持它们加载的任何语言中使用。因此，即使您用完全不同的语言（比如Delphi或Prolog）编写这样的库，很难称这样的库为Python扩展，如果它不使用Python/C
    API。
- en: 'Unfortunately, writing your own extensions only in C or C++ using the bare
    Python/C API is quite demanding. Not only because it requires a good understanding
    of one of the two languages that are relatively hard to master, but also because
    it requires exceptional amount of boilerplate. There is a lot of repetitive code
    that must be written only to provide an interface that will glue your implemented
    logic with Python and its datatypes. Anyway, it is good to know how pure C extensions
    are built because:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，仅使用裸的Python/C API在C或C++中编写自己的扩展是相当苛刻的。这不仅因为它需要对这两种相对难以掌握的语言之一有很好的理解，而且还因为它需要大量的样板文件。有很多重复的代码必须编写，只是为了提供一个接口，将您实现的逻辑与Python及其数据类型粘合在一起。无论如何，了解纯C扩展是如何构建的是很好的，因为：
- en: You will understand better how Python works in general
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您将更好地了解Python的工作原理
- en: One day you may need to debug or maintain a native C/C++ extension
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一天，您可能需要调试或维护本机C/C++扩展
- en: It helps with understanding how higher-level tools for building extensions work
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有助于理解构建扩展的高级工具的工作原理
- en: How do extensions in C or C++ work
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C或C++中的扩展是如何工作的
- en: Python interpreter is able to load extensions from dynamic/shared libraries
    if they provide an applicable interface using Python/C API. This API must be incorporated
    in source code of extension using the `Python.h` C header file that is distributed
    with Python sources. In many distributions of Linux, this header file is contained
    in a separate package (for example, `python-dev` in Debian/Ubuntu) but under Windows,
    it is distributed by default and can be found in the `includes/` directory of
    your Python installation.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Python解释器能够使用Python/C API提供适当的接口，它就能从动态/共享库中加载扩展。这个API必须被合并到扩展的源代码中，使用与Python源代码一起分发的`Python.h`
    C头文件。在许多Linux发行版中，这个头文件包含在一个单独的软件包中（例如，在Debian/Ubuntu中是`python-dev`），但在Windows下，默认情况下分发，并且可以在Python安装的`includes/`目录中找到。
- en: Python/C API traditionally changes with every release of Python. In most cases,
    these are only additions of new features to the API, so it is typically source-compatible.
    Anyway, in most cases, they are not binary compatible due to changes in the **Application
    Binary Interface** (**ABI**). This means that extensions must be built separately
    for every version of Python. Note also that different operating systems have noncompatible
    ABIs, so this makes it practically impossible to create a binary distribution
    for every possible environment. This is the reason why most Python extensions
    are distributed in source form.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Python/C API通常会随着Python的每个版本发布而改变。在大多数情况下，这些只是对API的新功能的添加，因此通常是源代码兼容的。无论如何，在大多数情况下，它们不是二进制兼容的，因为**应用程序二进制接口**（**ABI**）发生了变化。这意味着扩展必须为每个Python版本单独构建。还要注意，不同的操作系统具有不兼容的ABI，因此这几乎不可能为每种可能的环境创建二进制分发。这就是为什么大多数Python扩展以源代码形式分发的原因。
- en: Since Python 3.2, a subset of Python/C API has been defined to have stable ABIs.
    It is possible then to build extensions using this limited API (with a stable
    ABI), so extensions can be built only once and will work with any version of Python
    higher than or equal to 3.2 without the need for recompilation. Anyway, this limits
    the amount of API features and does not solve the problems of older Python versions
    or the distribution of the extension in binary form to environments using different
    operating systems. So this is a trade-off, and price of the stable ABI seems to
    be a bit high for very low gain.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 自Python 3.2以来，已经定义了Python/C API的一个子集，具有稳定的ABI。因此可以使用这个有限的API（具有稳定的ABI）构建扩展，因此扩展只需构建一次，就可以在任何高于或等于3.2的Python版本上工作，无需重新编译。无论如何，这限制了API功能的数量，并且不能解决旧版本Python或以二进制形式分发扩展到使用不同操作系统的环境的问题。因此这是一个权衡，稳定ABI的代价似乎有点高而收益很低。
- en: One thing you need to know is that Python/C API is a feature that is limited
    to CPython implementations. Some efforts were made to bring extension support
    to alternative implementations such as PyPI, Jython, or IronPython, but it seems
    that there is no viable solution for them at the moment. The only alternative
    Python implementation that should deal easily with extensions is Stackless Python
    because it is in fact only a modified version of CPython.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要知道的一件事是，Python/C API是限于CPython实现的功能。一些努力已经为PyPI、Jython或IronPython等替代实现带来了扩展支持，但目前似乎没有可行的解决方案。唯一一个应该轻松处理扩展的替代Python实现是Stackless
    Python，因为它实际上只是CPython的修改版本。
- en: 'C extensions for Python need to be compiled into shared/dynamic libraries before
    they will be available to use because obviously there is no native way to import
    C/C++ code into Python directly from sources. Fortunately, `distutils` and `setuptools`
    provide helpers to define compiled extensions as modules so compilation and distribution
    can be handled using the `setup.py` script as if they were ordinary Python packages.
    This is an example of the `setup.py` script from the official documentation that
    handles the packaging of simple packages with built extensions:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Python的C扩展需要在可用之前编译成共享/动态库，因为显然没有本地的方法可以直接从源代码将C/C++代码导入Python。幸运的是，`distutils`和`setuptools`提供了帮助，将编译的扩展定义为模块，因此可以使用`setup.py`脚本处理编译和分发，就像它们是普通的Python包一样。这是官方文档中处理带有构建扩展的简单包的`setup.py`脚本的一个示例：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once prepared that way, there is one additional step required in your distribution
    flow:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好之后，你的分发流程还需要一个额外的步骤：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will compile all your extensions provided as the `ext_modules` argument
    according to all additional compiler settings provided with the `Extension()`
    call. The compiler that will be used is the one that is default for your environment.
    This compilation step is not required if the package is going to be distributed
    with source distribution. In that case, you need to be sure that the target environment
    has all compilation prerequisites, such as a compiler, header files, and additional
    libraries that are going to be linked to the binary (if your extension needs any).
    More details of packaging the Python extensions will be explained later in the
    *Challenges* section.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这将根据`ext_modules`参数编译所有你的扩展，根据`Extension()`调用提供的所有额外编译器设置。将使用的编译器是你的环境的默认编译器。如果要分发源代码分发包，则不需要进行这个编译步骤。在这种情况下，你需要确保目标环境具有所有编译的先决条件，例如编译器、头文件和将链接到二进制文件的其他库（如果你的扩展需要）。有关打包Python扩展的更多细节将在*挑战*部分中解释。
- en: Why you might want to use extensions
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么你可能想使用扩展
- en: 'It''s not easy to say when it is a reasonable decision to write extensions
    in C/C++. The general rule of thumb could be, *never, unless you have no other
    choice*. But this is a very subjective statement that leaves a lot of room for
    interpretation of what is not doable in Python. In fact, it is hard to find a
    thing that cannot be done using pure Python code, but there are some problems
    where extensions may be especially useful:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 写C/C++扩展是否明智的决定并不容易。一般的经验法则可能是，“除非别无选择，否则永远不要”。但这是一个非常主观的说法，留下了很多解释空间，关于在Python中做不到的事情。事实上，很难找到一件事情，纯Python代码做不到，但有一些问题，扩展可能特别有用：
- en: Bypassing **GIL** (**Global Interpreter Lock**) in the Python threading model
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绕过Python线程模型中的**全局解释器锁**（**GIL**）
- en: Improving performance in critical code sections
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进关键代码部分的性能
- en: Integrating third-party dynamic libraries
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成第三方动态库
- en: Integrating source code written in different languages
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成用不同语言编写的源代码
- en: Creating custom datatypes
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义数据类型
- en: For example, the core language constraints such as GIL can easily be overcome
    with a different approach to concurrency, such as green threads or multiprocessing
    instead of a threading model.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，核心语言约束，如GIL，可以通过不同的并发方法轻松克服，例如绿色线程或多进程，而不是线程模型。
- en: Improving performance in critical code sections
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改进关键代码部分的性能
- en: Let's be honest. Python is not chosen by developers because of performance.
    It does not execute quickly, but allows you to develop quickly. Still, no matter
    how performant we are as programmers, thanks to this language, we may sometimes
    find a problem that may not be solved efficiently using pure Python.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, solving performance problems is really only about choosing proper
    algorithms and data structures and not about limiting the constant factor of language
    overhead. And it is not actually a good solution to rely on extensions in order
    to shave off some CPU cycles if the code is already written poorly or does not
    use proper algorithms. It is often possible that performance can be improved to
    an acceptable level without the need to increase the complexity of your project
    by looping in another language to the stack. And if it is possible, it should
    be done that way in the first place. Anyway, it is also very likely that even
    with *state of the art* algorithmic approach and the best suited data structures
    that are available to our disposal, we will not be able to fit some arbitrary
    technological constraints using Python alone.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'The example field that puts some well-defined limits on the application''s
    performance is the **Real Time Bidding** (**RTB**) business. In short, the whole
    RTB is about buying and selling advertisement inventory (places for ads) in a
    way similar to real auctions or stock exchanges. The trading usually takes place
    through some ad exchange service that sends information about available inventory
    to **demand-side platforms** (**DSP**) interested in buying them. And this is
    the place where things get exciting. Most ad exchanges use the OpenRTB protocol
    (which is based on HTTP) for communication with potential bidders where DSP is
    the site responsible for serving responses to its HTTP requests. And ad exchanges
    always put very limited time constraints (usually between 50 and 100 ms) on the
    whole process—from the first TPC packet received to the last byte written by the
    server. To spice things up, it is not uncommon for DSP platforms to process tens
    of thousands of requests per second. Being able to push the time of request processing
    even by a few milliseconds is the *to be or not to be* in this business. This
    means that porting even trivial code to C may be reasonable in that situation
    but only if it''s a part of some performance bottleneck and cannot be improved
    any further algorithmically. As someone once said:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '*"You can''t beat a loop written in C."*'
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Integrating existing code written in different languages
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A lot of useful libraries have been written during the short history of computer
    science. It would be a great loss to forget about all that heritage every time
    a new programming language pops out, but it is also impossible to reliably port
    any piece of software that was ever written to any available language.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: The C and C++ languages seem to be the most important languages that provide
    a lot of libraries and implementation that you would like to integrate in your
    application code without the need to port them completely to Python. Fortunately,
    CPython is already written in C, so the most natural way to integrate such code
    is precisely through custom extensions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Integrating third-party dynamic libraries
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Integration of code written using different technologies does not end with C/C++.
    A lot of libraries, especially third-party software with closed sources, are distributed
    as compiled binaries. In C, it is really easy to load such shared/dynamic libraries
    and call their functions. This means that you can use any C library as long as
    you wrap it with extensions using Python/C API.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: This, of course, is not the only solution and there are tools such as `ctypes`
    or CFFI that allow you to interact with dynamic libraries using pure Python without
    the need of writing extensions in C. Very often, the Python/C API may still be
    a better choice because it provides a better separation between the integration
    layer (written in C) and the rest of the application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不是唯一的解决方案，还有诸如`ctypes`或CFFI之类的工具，允许您使用纯Python与动态库进行交互，而无需编写C扩展。通常情况下，Python/C
    API可能仍然是更好的选择，因为它在集成层（用C编写）和应用程序的其余部分之间提供了更好的分离。
- en: Creating custom datatypes
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义数据类型
- en: Python provides a very versatile selection of built-in datatypes. Some of them
    really use state of the art internal implementations (at least in CPython) that
    are specifically tailored for usage in the Python language. The number of basic
    types and collections available out-of-the-box may look impressive for newcomers,
    but it is clear that it does not cover all of our possible needs.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了非常多样化的内置数据类型。其中一些真正使用了最先进的内部实现（至少在CPython中），专门为在Python语言中使用而量身定制。基本类型和可用的集合数量对于新手来说可能看起来令人印象深刻，但显然它并不能涵盖我们所有可能的需求。
- en: You can, of course, create many custom data structures in Python either by basing
    them completely on some built-in types or by building them from scratch as completely
    new classes. Unfortunately, for some applications that may heavily rely on such
    custom data structures, the performance might not be enough. The whole power of
    complex collections such as `dict` or `set` comes from their underlying C implementation.
    Why not do the same and implement some of your custom data structures in C too?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以通过完全基于一些内置类型或从头开始构建全新类来在Python中创建许多自定义数据结构。不幸的是，对于一些可能严重依赖这些自定义数据结构的应用程序来说，性能可能不够。像`dict`或`set`这样的复杂集合的全部功能来自它们的底层C实现。为什么不做同样的事情，也在C中实现一些自定义数据结构呢？
- en: Writing extensions
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写扩展
- en: As already said, writing extensions is not a simple task but in exchange for
    your hard work, it can give you a lot of advantages. The easiest and recommended
    approach to your own extensions is to use tools such as Cython or Pyrex or simply
    integrate the existing dynamic libraries with `ctypes` or `cffi`. These projects
    will increase your productivity and also make code easier to develop, read, and
    maintain.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，编写扩展并不是一项简单的任务，但作为您辛勤工作的回报，它可以给您带来许多优势。编写自己扩展的最简单和推荐的方法是使用诸如Cython或Pyrex的工具，或者简单地使用`ctypes`或`cffi`集成现有的动态库。这些项目将提高您的生产力，还会使代码更易于开发、阅读和维护。
- en: 'Anyway, if you are new to this topic, it is good to know that you can start
    your adventure with extensions by writing one using nothing more than bare C code
    and Python/C API. This will improve your understanding of how extensions work
    and will also help you to appreciate the advantages of alternative solutions.
    For the sake of simplicity, we will take a simple algorithmic problem as an example
    and try to implement it using three different approaches:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，如果您对这个主题还不熟悉，了解一点是好的，即您可以通过仅使用裸C代码和Python/C API编写一个扩展来开始您的扩展之旅。这将提高您对扩展工作原理的理解，并帮助您欣赏替代解决方案的优势。为了简单起见，我们将以一个简单的算法问题作为示例，并尝试使用三种不同的方法来实现它：
- en: Writing a pure C extension
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写纯C扩展
- en: Using Cython
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Cython
- en: Using Pyrex
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Pyrex
- en: 'Our problem will be finding the *nth* number of the Fibonacci sequence. It
    is very unlikely that you would like to create compiled extensions solely for
    this problem, but it is very simple so it will serve as a very good example of
    wiring any C function to Python/C APIs. Our only goals are clarity and simplicity,
    so we won''t try to provide the most efficient solution. Once we know this, our
    reference implementation of the Fibonacci function implemented in Python looks
    as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的问题将是找到斐波那契数列的第*n*个数字。很少有人会仅为了这个问题创建编译扩展，但它非常简单，因此它将作为将任何C函数连接到Python/C API的非常好的示例。我们的唯一目标是清晰和简单，因此我们不会试图提供最有效的解决方案。一旦我们知道这一点，我们在Python中实现的斐波那契函数的参考实现如下：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that this is one of the most simple implementations of the `fibonnaci()`
    function and a lot of improvements could be applied to it. We refuse to improve
    our implementation (using a memoization pattern, for instance) though because
    this is not the purpose of our example. In the same manner, we won't optimize
    our code later when discussing implementations in C or Cython even though the
    compiled code gives many more possibilities to do so.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这是`fibonnaci()`函数的最简单实现之一，可以对其进行许多改进。尽管如此，我们拒绝改进我们的实现（例如使用记忆化模式），因为这不是我们示例的目的。同样地，即使编译后的代码提供了更多的优化可能性，我们在讨论C或Cython中的实现时也不会优化我们的代码。
- en: Pure C extensions
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纯C扩展
- en: Before we fully dive into the code examples of Python extensions written in
    C, here is a huge warning. If you want to extend Python with C, you need to already
    know both of these languages well. This is especially true for C. Lack of proficiency
    with it can lead to real disasters because it can be easily mishandled.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完全深入C编写的Python扩展的代码示例之前，这里有一个重要的警告。如果您想用C扩展Python，您需要已经对这两种语言非常了解。这对于C尤其如此。对它的熟练程度不足可能会导致真正的灾难，因为它很容易被误用。
- en: If you have decided that you need to write C extension for Python, I assume
    that you already know the C language to a level that will allow you to fully understand
    the examples that are presented. Nothing other than Python/C API details will
    be explained here. This book is about Python and not any other language. If you
    don't know C at all, you should definitely not try to write your own Python extensions
    in C until you gain enough experience and skills. Leave it to others and stick
    with Cython or Pyrex because they are a lot safer from the beginner's perspective.
    This is mostly because Python/C API, despite having been crafted with great care,
    is definitely not a good introduction to C.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经决定需要为Python编写C扩展，我假设您已经对C语言有了足够的了解，可以完全理解所呈现的示例。这里将不会解释除Python/C API细节之外的任何内容。本书是关于Python而不是其他任何语言。如果您根本不懂C，那么在获得足够的经验和技能之前，绝对不应该尝试用C编写自己的Python扩展。把它留给其他人，坚持使用Cython或Pyrex，因为从初学者的角度来看，它们更安全得多。这主要是因为Python/C
    API，尽管经过精心设计，但绝对不是C的良好入门。
- en: 'As proposed earlier, we will try to port the `fibonacci()` function to C and
    expose it to Python code as an extension. The bare implementation without the
    wiring to Python/C API that is analogous to the previous Python example could
    be roughly as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将尝试将`fibonacci()`函数移植到C并将其作为扩展暴露给Python代码。没有与Python/C API连接的裸实现，类似于前面的Python示例，大致如下：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And here is the example of a complete, fully functional extension that exposes
    this single function in a compiled module:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个完整、完全功能的扩展的示例，它在编译模块中公开了这个单一函数：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding example might be a bit overwhelming at first glance because we
    had to add four times more code just to make the `fibonacci()` C function accessible
    from Python. We will discuss every bit of that code later, so don''t worry. But
    before we do that, let''s see how it can be packaged and executed in Python. The
    minimal `setuptools` configuration for our module needs to use the `setuptools.Extension`
    class in order to instruct the interpreter how our extension is compiled:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子乍一看可能有点令人不知所措，因为我们不得不添加四倍的代码才能让`fibonacci()` C函数可以从Python中访问。我们稍后会讨论代码的每一部分，所以不用担心。但在我们讨论之前，让我们看看如何将其打包并在Python中执行。我们模块的最小`setuptools`配置需要使用`setuptools.Extension`类来指示解释器如何编译我们的扩展：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The build process for the extension can be initialized with Python''s `setup.py`
    build command, but will also be automatically performed on package installation.
    The following transcript presents the result of installation in development mode
    and a simple interactive session where our compiled `fibonacci()` function is
    inspected and executed:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展的构建过程可以通过Python的`setup.py`构建命令来初始化，但也会在包安装时自动执行。以下是在开发模式下安装的结果以及一个简单的交互会话，我们在其中检查和执行我们编译的`fibonacci()`函数：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A closer look at Python/C API
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对Python/C API的更详细了解
- en: Since we know how to properly package, compile, and install custom C extensions
    and we are sure that it works as expected, now it is the right time to discuss
    our code in detail.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道如何正确地打包、编译和安装自定义C扩展，并且确信它按预期工作，现在是讨论我们的代码的正确时间。
- en: 'The extensions module starts with a single C preprocessor directive that includes
    the `Python.h` header file:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展模块以一个包含`Python.h`头文件的单个C预处理指令开始：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This pulls the whole Python/C API and is everything you need to include to be
    able to write your extensions. In more realistic cases, your code will require
    a lot more preprocessor directives to take benefit from C standard library functions
    or to integrate other source files. Our example was simple, so no more directives
    were required.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这将引入整个Python/C API，并且是您需要包含的一切，以便能够编写您的扩展。在更现实的情况下，您的代码将需要更多的预处理指令，以从C标准库函数中获益或集成其他源文件。我们的示例很简单，因此不需要更多的指令。
- en: 'Next we have the core of our module:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是我们模块的核心：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding `fibonacci()` function is the only part of our code that does
    something useful. It is pure C implementation that Python by default can't understand.
    The rest of our example will create the interface layer that will expose it through
    Python/C API.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`fibonacci()`函数是我们代码中唯一有用的部分。它是纯C实现，Python默认情况下无法理解。我们的示例的其余部分将创建接口层，通过Python/C
    API将其暴露出来。
- en: 'The first step of exposing this code to Python is the creation of the C function
    that is compatible with the CPython interpreter. In Python, everything is an object.
    This means that C functions called in Python also need to return real Python objects.
    Python/C APIs provide a `PyObject` type and every callable must return the pointer
    to it. The signature of our function is:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码暴露给Python的第一步是创建与CPython解释器兼容的C函数。在Python中，一切都是对象。这意味着在Python中调用的C函数也需要返回真正的Python对象。Python/C
    API提供了`PyObject`类型，每个可调用函数都必须返回指向它的指针。我们函数的签名是：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Note that the preceding signature does not specify the exact list of arguments
    but only `PyObject* args` that will hold the pointer to the structure that contains
    the tuple of the provided values. The actual validation of the argument list must
    be performed inside of the function body and this is exactly what `fibonacci_py()`
    does. It parses the `args` argument list assuming it is the single `unsigned int`
    type and uses that value as an argument to the `fibonacci()` function to retrieve
    the Fibonacci sequence element:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的签名并未指定确切的参数列表，而只是`PyObject* args`，它将保存指向包含提供的值元组的结构的指针。参数列表的实际验证必须在函数体内执行，这正是`fibonacci_py()`所做的。它解析`args`参数列表，假设它是单个`unsigned
    int`类型，并将该值用作`fibonacci()`函数的参数来检索斐波那契数列元素：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding example function has some serious bugs, which the eyes of an experienced
    developer should spot very easily. Try to find it as an exercise in working with
    C extensions. For now, we leave it as it is for the sake of brevity. We will try
    to fix it later when discussing details of dealing with errors in the *Exception
    handling* section.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例函数有一些严重的错误，有经验的开发人员的眼睛应该很容易发现。尝试找到它，作为使用C扩展的练习。现在，为了简洁起见，我们将它保留下来。在*异常处理*部分讨论处理错误的细节时，我们将尝试稍后修复它。
- en: The `"l"` string in the `PyArg_ParseTuple(args, "l", &n)` call means that we
    expect `args` to contain only a single `long` value. In case of failure, it will
    return `NULL` and store information about the exception in the per-thread interpreter
    state. The details of exception handling will be described a bit later in the
    *Exception handling* section.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`"l"`字符串在`PyArg_ParseTuple(args, "l", &n)`调用中意味着我们希望`args`只包含一个`long`值。如果失败，它将返回`NULL`并在每个线程的解释器状态中存储有关异常的信息。关于异常处理的详细信息将在*异常处理*部分稍后描述。'
- en: The actual signature of the parsing function is `int PyArg_ParseTuple(PyObject
    *args, const char *format, ...)` and what goes after the `format` string is a
    variable length list of arguments that represents parsed value output (as pointers).
    This is analogous to how the `scanf()` function from the C standard library works.
    If our assumption fails and the user provides an incompatible arguments list,
    then `PyArg_ParseTuple()` will raise the proper exception. This is a very convenient
    way to encode function signatures once you get used to it but has a huge downside
    when compared to plain Python code. Such Python call signatures implicitly defined
    by the `PyArg_ParseTuple()` calls cannot be easily inspected inside of the Python
    interpreter. You need to remember this fact when using code provided as extensions.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 解析函数的实际签名是`int PyArg_ParseTuple(PyObject *args, const char *format, ...)`，在`format`字符串之后的是一个可变长度的参数列表，表示解析值输出（作为指针）。这类似于C标准库中的`scanf()`函数的工作方式。如果我们的假设失败，用户提供了不兼容的参数列表，那么`PyArg_ParseTuple()`将引发适当的异常。一旦你习惯了这种方式，这是一种非常方便的编码函数签名的方式，但与纯Python代码相比，它有一个巨大的缺点。由`PyArg_ParseTuple()`调用隐式定义的这种Python调用签名在Python解释器内部不能轻松地检查。在使用作为扩展提供的代码时，您需要记住这一点。
- en: As already said, Python expects objects to be returned from callables. This
    means that we cannot return a raw `long long` value obtained from the `fibonacci()`
    function as a result of `fibonacci_py()`. Such an attempt would not even compile
    and there is no automatic casting of basic C types to Python objects. The `Py_BuildValue(*format,
    ...)` function must be used instead. It is the counterpart of `PyArg_ParseTuple()`
    and accepts a similar set of format strings. The main difference is that the list
    of arguments is not a function output but an input, so actual values must be provided
    instead of pointers.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Python期望从可调用对象返回对象。这意味着我们不能将从`fibonacci()`函数获得的`long long`值作为`fibonacci_py()`的结果返回。这样的尝试甚至不会编译，基本C类型不会自动转换为Python对象。必须使用`Py_BuildValue(*format,
    ...)`函数。它是`PyArg_ParseTuple()`的对应物，并接受类似的格式字符串集。主要区别在于参数列表不是函数输出而是输入，因此必须提供实际值而不是指针。
- en: After `fibonacci_py()` is defined, most of the heavy work is done. The last
    step is to perform module initialization and add metadata to our function that
    will make usage a bit simpler for users. This is the boilerplate part of our extension
    code that for some simple examples, such as this one, can take more place than
    actual functions that we want to expose. In most cases, it simply consists of
    some static structures and one initialization function that will be executed by
    the interpreter on module import.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了`fibonacci_py()`之后，大部分繁重的工作都已完成。最后一步是执行模块初始化并向我们的函数添加元数据，这将使用户的使用变得更简单一些。这是我们扩展代码的样板部分，对于一些简单的例子，比如这个例子，可能会占用比我们想要公开的实际函数更多的空间。在大多数情况下，它只是由一些静态结构和一个初始化函数组成，该函数将由解释器在模块导入时执行。
- en: 'At first, we create a static string that will be a content of Python docstring
    for the `fibonacci_py()` function:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个静态字符串，它将成为`fibonacci_py()`函数的Python文档字符串的内容：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that this could be *inlined* somewhere later in `fibonacci_module_methods`,
    but it is a good practice to have docstrings separated and stored in close proximity
    to the actual function definition that they refer to.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这可能会*内联*在`fibonacci_module_methods`的某个地方，但将文档字符串分开并存储在与其引用的实际函数定义的附近是一个很好的做法。
- en: 'The next part of our definition is the array of the `PyMethodDef` structures
    that define methods (functions) that will be available in our module. This structure
    contains exactly four fields:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的下一部分是`PyMethodDef`结构的数组，该数组定义了将在我们的模块中可用的方法（函数）。该结构包含四个字段：
- en: '`char* ml_name`: This is the name of the method.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char* ml_name`: 这是方法的名称。'
- en: '`PyCFunction ml_meth`: This is the pointer to the C implementation of the function.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PyCFunction ml_meth`: 这是指向函数的C实现的指针。'
- en: '`int ml_flags`: This includes the flags indicating either the calling convention
    or binding convention. The latter is applicable only for definition of class methods.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int ml_flags`: 这包括指示调用约定或绑定约定的标志。后者仅适用于定义类方法。'
- en: '`char* ml_doc`: This is the pointer to the content of method/function docstring.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char* ml_doc`: 这是指向方法/函数文档字符串内容的指针。'
- en: 'Such an array must always end with a sentinel value of `{NULL, NULL, 0, NULL}`
    that indicates its end. In our simple case, we created the `static PyMethodDef
    fibonacci_module_methods[]` array that contains only two elements (including the
    sentinel value):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的数组必须始终以`{NULL, NULL, 0, NULL}`的哨兵值结束，表示其结束。在我们的简单情况下，我们创建了`static PyMethodDef
    fibonacci_module_methods[]`数组，其中只包含两个元素（包括哨兵值）：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And this is how the first entry maps to the `PyMethodDef` structure:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是第一个条目如何映射到`PyMethodDef`结构：
- en: '`ml_name = "fibonacci"`: Here, the `fibonacci_py()` C function will be exposed
    as a Python function under the `fibonacci` name'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ml_name = "fibonacci"`: 在这里，`fibonacci_py()` C函数将以`fibonacci`名称作为Python函数公开'
- en: '`ml_meth = (PyCFunction)fibonacci_py`: Here, the casting to `PyCFunction` is
    simply required by Python/C API and is dictated by the call convention defined
    later in `ml_flags`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ml_meth = (PyCFunction)fibonacci_py`: 在这里，将`PyCFunction`转换仅仅是Python/C API所需的，并且由`ml_flags`中定义的调用约定决定'
- en: '`ml_flags = METH_VARARGS`: Here, the `METH_VARARGS` flag indicates that the
    calling convention of our function accepts a variable list of arguments and no
    keyword arguments'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ml_flags = METH_VARARGS`: 在这里，`METH_VARARGS`标志表示我们的函数的调用约定接受可变参数列表，不接受关键字参数'
- en: '`ml_doc = fibonacci_docs`: Here, the Python function will be documented with
    the content of the `fibonacci_docs` string'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ml_doc = fibonacci_docs`: 在这里，Python函数将使用`fibonacci_docs`字符串的内容进行文档化'
- en: 'When an array of function definitions is complete, we can create another structure
    that contains the definition of the whole module. It is described using the `PyModuleDef`
    type and contains multiple fields. Some of them are useful only for more complex
    scenarios, where fine-grained control over the module initialization process is
    required. Here we are interested only in the first five of them:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数定义数组完成时，我们可以创建另一个结构，其中包含整个模块的定义。它使用`PyModuleDef`类型进行描述，并包含多个字段。其中一些仅适用于需要对模块初始化过程进行细粒度控制的更复杂的情况。在这里，我们只对其中的前五个感兴趣：
- en: '`PyModuleDef_Base m_base`: This should always be initialized with `PyModuleDef_HEAD_INIT`.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PyModuleDef_Base m_base`: 这应该始终用`PyModuleDef_HEAD_INIT`进行初始化。'
- en: '`char* m_name`: This is the name of the newly created module. In our case it
    is `fibonacci`.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char* m_name`: 这是新创建模块的名称。在我们的例子中是`fibonacci`。'
- en: '`char* m_doc`: This is the pointer to the docstring content for the module.
    We usually have only a single module defined in one C source file, so it is OK
    to inline our documentation string in the whole structure.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char* m_doc`: 这是模块的文档字符串内容的指针。通常在一个C源文件中只定义一个模块，因此将我们的文档字符串内联在整个结构中是可以的。'
- en: '`Py_ssize_t m_size`: This is the size of the memory allocated to keep the module
    state. This is only used when support for multiple subinterpreters or multiphase
    initialization is required. In most cases, you don''t need that and it is gets
    the value `-1`.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Py_ssize_t m_size`: 这是分配给保持模块状态的内存的大小。只有在需要支持多个子解释器或多阶段初始化时才会使用。在大多数情况下，您不需要它，它的值为`-1`。'
- en: '`PyMethodDef* m_methods`: This is a pointer to the array containing module-level
    functions described by the `PyMethodDef` values. It could be `NULL` if the module
    does not expose any functions. In our case, it is `fibonacci_module_methods`.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PyMethodDef* m_methods`: 这是指向包含由`PyMethodDef`值描述的模块级函数的数组的指针。如果模块不公开任何函数，则可以为`NULL`。在我们的情况下，它是`fibonacci_module_methods`。'
- en: 'The other fields are explained in detail in the official Python documentation
    (refer to [https://docs.python.org/3/c-api/module.html](https://docs.python.org/3/c-api/module.html))
    but are not needed in our example extension. They should be set to `NULL` if not
    required and they will be initialized with that value implicitly when not specified.
    This is why our module description contained in the `fibonacci_module_definition`
    variable can take this simple five-element form:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 其他字段在官方Python文档中有详细解释（参考[https://docs.python.org/3/c-api/module.html](https://docs.python.org/3/c-api/module.html)），但在我们的示例扩展中不需要。如果不需要，它们应该设置为`NULL`，当未指定时，它们将隐式地初始化为该值。这就是为什么我们的模块描述包含在`fibonacci_module_definition`变量中可以采用这种简单的五元素形式的原因：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The last piece of code that crowns our work is the module initialization function.
    This must follow a very specific naming convention, so the Python interpreter
    can easily pick it when the dynamic/shared library is loaded. It should be named
    `PyInit_name`, where *name* is your module name. So it is exactly the same string
    that was used as the `m_base` field in the `PyModuleDef` definition and as the
    first argument of the `setuptools.Extension()` call. If you don''t require a complex
    initialization process for the module, it takes a very simple form, exactly like
    in our example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一段代码是我们工作的巅峰，即模块初始化函数。这必须遵循非常特定的命名约定，以便Python解释器在加载动态/共享库时可以轻松地选择它。它应该被命名为`PyInit_name`，其中*name*是您的模块名称。因此，它与在`PyModuleDef`定义中用作`m_base`字段和`setuptools.Extension()`调用的第一个参数的字符串完全相同。如果您不需要对模块进行复杂的初始化过程，它将采用与我们示例中完全相同的非常简单的形式：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `PyMODINIT_FUNC` macro is a preprocessor macro that will declare the return
    type of this initialization function as `PyObject*` and add any special linkage
    declarations if required by the platform.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`PyMODINIT_FUNC`宏是一个预处理宏，它将声明此初始化函数的返回类型为`PyObject*`，并根据平台需要添加任何特殊的链接声明。'
- en: Calling and binding conventions
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用和绑定约定
- en: 'As explained in the *A closer look at Python/C API* section, the `ml_flags`
    bitfield of the `PyMethodDef` structure contains flags for calling and binding
    conventions. **Calling convention flags** are:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如*深入了解Python/C API*部分所述，`PyMethodDef`结构的`ml_flags`位字段包含调用和绑定约定的标志。**调用约定标志**包括：
- en: '`METH_VARARGS`: This is a typical convention for the Python function or method
    that only accepts arguments as its parameters. The type provided as the `ml_meth`
    field for such a function should be `PyCFunction`. The function will be provided
    with two arguments of the `PyObject*` type. The first is either the `self` object
    (for methods) or the `module` object (for module functions). A typical signature
    for the C function with that calling convention is `PyObject* function(PyObject*
    self, PyObject* args)`.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`METH_VARARGS`: 这是Python函数或方法的典型约定，只接受参数作为其参数。对于这样的函数，`ml_meth`字段提供的类型应该是`PyCFunction`。该函数将提供两个`PyObject*`类型的参数。第一个要么是`self`对象（对于方法），要么是`module`对象（对于模块函数）。具有该调用约定的C函数的典型签名是`PyObject*
    function(PyObject* self, PyObject* args)`。'
- en: '`METH_KEYWORDS`: This is the convention for the Python function that accepts
    keyword arguments when called. Its associated C type is `PyCFunctionWithKeywords`.
    The C function must accept three arguments of the `PyObject*` type: `self`, `args`,
    and a dictionary of keyword arguments. If combined with `METH_VARARGS`, the first
    two arguments have the same meaning as for the previous calling convention, otherwise
    `args` will be `NULL`. The typical C function signature is: `PyObject* function(PyObject*
    self, PyObject* args, PyObject* keywds)`.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`METH_KEYWORDS`：这是Python函数在调用时接受关键字参数的约定。其关联的C类型是`PyCFunctionWithKeywords`。C函数必须接受三个`PyObject*`类型的参数：`self`，`args`和关键字参数的字典。如果与`METH_VARARGS`组合，前两个参数的含义与前一个调用约定相同，否则`args`将为`NULL`。典型的C函数签名是：`PyObject*
    function(PyObject* self, PyObject* args, PyObject* keywds)`。'
- en: '`METH_NOARGS`: This is the convention for Python functions that do not accept
    any other argument. The C function should be of the `PyCFunction` type, so the
    signature is the same as that of the `METH_VARARGS` convention (two `self` and
    `args` arguments). The only difference is that `args` will always be `NULL`, so
    there is no need to call `PyArg_ParseTuple()`. This cannot be combined with any
    other calling convention flag.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`METH_NOARGS`：这是Python函数不接受任何其他参数的约定。C函数应该是`PyCFunction`类型，因此签名与`METH_VARARGS`约定相同（两个`self`和`args`参数）。唯一的区别是`args`将始终为`NULL`，因此不需要调用`PyArg_ParseTuple()`。这不能与任何其他调用约定标志组合。'
- en: '`METH_O`: This is the shorthand for functions and methods accepting single
    object arguments. The type of C function is again `PyCFunction`, so it accepts
    two `PyObject*` arguments: `self` and `args`. Its difference `from METH_VARARGS`
    is that there is no need to call `PyArg_ParseTuple()` because `PyObject*` provided
    as `args` will already represent the single argument provided in the Python call
    to that function. This also cannot be combined with any other calling convention
    flag.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`METH_O`：这是接受单个对象参数的函数和方法的简写。C函数的类型再次是`PyCFunction`，因此它接受两个`PyObject*`参数：`self`和`args`。它与`METH_VARARGS`的区别在于不需要调用`PyArg_ParseTuple()`，因为作为`args`提供的`PyObject*`将已经表示在Python调用该函数时提供的单个参数。这也不能与任何其他调用约定标志组合。'
- en: 'A function that accepts keywords is described either with `METH_KEYWORDS` or
    a bitwise combination of calling convention flags in the form of `METH_VARARGS
    |` `METH_KEYWORDS`. If so, it should parse its arguments with `PyArg_ParseTupleAndKeywords()`
    instead of `PyArg_ParseTuple()` or `PyArg_UnpackTuple()`. Here is an example module
    with a single function that returns `None` and accepts two named keyword arguments
    that are printed on standard output:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接受关键字的函数可以用`METH_KEYWORDS`或者`METH_VARARGS |` `METH_KEYWORDS`的形式来描述。如果是这样，它应该使用`PyArg_ParseTupleAndKeywords()`来解析它的参数，而不是`PyArg_ParseTuple()`或者`PyArg_UnpackTuple()`。下面是一个示例模块，其中有一个返回`None`的函数，接受两个命名关键字参数，并将它们打印到标准输出：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Argument parsing in Python/C API is very elastic and is extensively described
    in the official documentation at [https://docs.python.org/3.5/c-api/arg.html](https://docs.python.org/3.5/c-api/arg.html).
    The format argument in `PyArg_ParseTuple()` and `PyArg_ParseTupleAndKeywords()`
    allows fine grained control over argument number and types. Every advanced calling
    convention known in Python can be coded in C with this API including:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Python/C API中的参数解析非常灵活，并且在官方文档中有详细描述。`PyArg_ParseTuple()`和`PyArg_ParseTupleAndKeywords()`中的格式参数允许对参数数量和类型进行精细的控制。Python中已知的每个高级调用约定都可以使用此API在C中编码，包括：
- en: Functions with default values for arguments
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有默认参数值的函数
- en: Functions with arguments specified as keyword-only
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定为关键字参数的函数
- en: Functions with a variable number of arguments
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有可变数量参数的函数
- en: The **binding convention flags** are `METH_CLASS`, `METH_STATIC`, and `METH_COEXIST`,
    are reserved for methods, and cannot be used to describe module functions. The
    first two are quite self-explanatory. They are the C counterparts of `classmethod`
    and `staticmethod` decorators and change the meaning of the `self` argument passed
    to the C function.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**绑定约定标志**是`METH_CLASS`，`METH_STATIC`和`METH_COEXIST`，它们保留给方法，并且不能用于描述模块函数。前两个相当不言自明。它们是`classmethod`和`staticmethod`装饰器的C对应物，并且改变了传递给C函数的`self`参数的含义。'
- en: '`METH_COEXIST` allows loading a method in place of the existing definition.
    It is useful very rarely. This is mostly when you would like to provide an implementation
    of the C method that would be generated automatically from the other features
    of the type that was defined. Python documentation gives an example of the `__contains__()`
    wrapper method that would be generated if the type has the `sq_contains` slot
    defined. Unfortunately, defining your own classes and types using Python/C API
    is beyond the scope of this introductory chapter. We will cover creating your
    own types in extensions later when discussing Cython because doing that in pure
    C requires way too much boilerplate code and leaves a lot of room for making mistakes.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`METH_COEXIST`允许在现有定义的位置加载一个方法。这很少有用。这主要是当您想要提供一个从已定义的类型的其他特性自动生成的C方法的实现时。Python文档给出了`__contains__()`包装器方法的示例，如果类型定义了`sq_contains`槽，它将自动生成。不幸的是，使用Python/C
    API定义自己的类和类型超出了本入门章节的范围。在讨论Cython时，我们将在以后讨论创建自己的类型，因为在纯C中这样做需要太多样板代码，并且容易出错。'
- en: Exception handling
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异常处理
- en: C, unlike Python, or even C++ does not have syntax for raising and catching
    exceptions. All error handling is usually handled with function return values
    and optional global state for storing details that can explain the cause of the
    last failure.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与Python甚至C++不同，C没有语法来引发和捕获异常。所有错误处理通常通过函数返回值和可选的全局状态来处理，用于存储可以解释最后一次失败原因的细节。
- en: 'Exception handling in Python/C API is built around that simple principle. There
    is a global per thread indicator of the last error that occurred and functioned
    in the C API. It is set to describe the cause of a problem. There is also a standardized
    way to inform the caller of a function if this state was changed during the call:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: If the function is supposed to return a pointer, it returns `NULL`
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the function is supposed to return an `int` type, it returns `-1`
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only exceptions from the preceding rules in Python/C API are the `PyArg_*()`
    functions that return `1` to indicate success and `0` to indicate failure.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this works in practice, let''s recall our `fibonacci_py()` function
    from the example in the previous sections:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Lines that somehow take part in our error handling are highlighted. It starts
    at the very beginning with the initialization of the `result` variable that is
    supposed to store the return value of our function. It is initialized with `NULL`
    that, as we already know, is an indicator of error. And this is how you will usually
    code your extensions, assuming that error is the default state of your code.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Later we have the `PyArg_ParseTuple()` call that will set error info in case
    of an exception and return `0`. This is part of the `if` statement and in that
    case we don't do anything more and return `NULL`. Whoever calls our function will
    be notified about the error.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '`Py_BuildValue()` can also raise an exception. It is supposed to return `PyObject*`
    (pointer), so in case of failure it gives `NULL`. We can simply store it as our
    result variable and pass further as a return value.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'But our job does not end with caring for exceptions raised by Python/C API
    calls. It is very probable that you will need to inform the extension user that
    some other kind of error or failure occurred. Python/C API has multiple functions
    that help you to raise an exception, but the most common one is `PyErr_SetString()`.
    It sets an error indicator with the given exception type with an additional string
    provided as the error cause explanation. The full signature of this function is:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'I have already said that implementation of our `fibonacci_py()` function has
    serious bug. Now is the right time to fix it. Fortunately, we have proper tools
    to do that. The problem lies in insecure casting of the `long` type to `unsigned
    int` in the following lines:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Thanks to the `PyArg_ParseTuple()` call, the first and only argument will be
    interpreted as a `long` type (the `"l"` specifier) and stored in the local `n`
    variable. Then it is cast to `unsigned int` so the issue will occur if the user
    calls the `fibonacci()` function from Python with a negative value. For instance,
    `-1`, as a signed 32-bit integer, will be interpreted as `4294967295` when cast
    to an unsigned 32-bit integer. Such a value will cause deep recursion and will
    result in stack overflow and a segmentation fault. Note that the same may happen
    if the user gives an arbitrarily large positive argument. We cannot fix this without
    a complete redesign of the C `fibonacci()` function, but we can at least try to
    ensure that argument that is passed meets some preconditions. Here we check if
    the value of the `n` argument is greater than or equal to zero and we raise a
    `ValueError` exception if that''s not true:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The last note is that the global error state does not clear by itself. Some
    of the errors can be handled gracefully in your C functions (same as using the
    `try ... except` clause in Python) and you need to be able to clear the error
    indicator if it is no longer valid. The function for that is `PyErr_Clear()`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Releasing GIL
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I have already mentioned that extensions can be a way to bypass Python GIL.
    There is a famous limitation of the CPython implementation stating that only one
    thread at a time can execute Python code. While multiprocessing is the suggested
    approach to circumvent this problem, it may not be a good solution for some highly
    parallelizable algorithms due to the resource overhead of running additional processes.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'Because extensions are mostly used in cases where a bigger part of the work
    is performed in pure C without any calls to Python/C API, it is possible (even
    advisable) to release GIL in some application sections. Thanks to this, you can
    still benefit from having multiple CPU cores and multithreaded application design.
    The only thing you need to do is to wrap blocks of code that are known to not
    use any of Python/C API calls or Python structures with specific macros provided
    by Python/C API. These two preprocessor macros are provided to simplify the whole
    procedure of releasing and reacquiring the Global Interpreter Lock:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '`Py_BEGIN_ALLOW_THREADS`: This declares the hidden local variable where the
    current thread state is saved and it releases GIL'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Py_END_ALLOW_THREADS`: This reacquires GIL and restores the thread state from
    the local variable declared with the previous macro'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we look carefully at our `fibonacci` extension example, we can clearly
    see that the `fibonacci()` function does not execute any Python code and does
    not touch any of the Python structures. This means that the `fibonacci_py()` function
    that simply wraps the `fibonacci(n)` execution could be updated to release GIL
    around that call:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Reference counting
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, we come to the important topic of memory management in Python. Python
    has its own garbage collector, but it is designed only to solve the issue of cyclic
    references in the **reference counting** algorithm. Reference counting is the
    primary method of managing the deallocation of objects that are no longer needed.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Python/C API documentation introduces an *ownership of references* to explain
    how it deals with deallocation of objects. Objects in Python are never owned and
    they are always shared. The actual creation of objects is managed by Python's
    memory manager. It is the component of CPython interpreter that is responsible
    for allocating and deallocating memory for objects that are stored in a private
    heap. What can be owned instead is a reference to the object.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Every object in Python that is represented by a reference (`PyObject*` pointer)
    has an associated reference count. When it goes to zero, it means that no one
    holds any valid reference to the object and the deallocator associated with its
    type can be called. Python/C API provides two macros for increasing and decreasing
    reference counts: `Py_INCREF()`, and `Py_DECREF()`. But before we discuss their
    details, we need to understand a few more terms related to reference ownership:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '**Passing of ownership**: Whenever we say that the function *passes the ownership*
    over a reference, it means that it has already increased the reference count and
    it is the responsibility of the caller to decrease the count when the reference
    to the object is no longer needed. Most of the functions that return the newly
    created objects, such as `Py_BuildValue`, do that. If that object is going to
    be returned from our function to another caller, then the ownership is passed
    again. We do not decrease the reference count in that case because it is no longer
    our responsibility. This is why the `fibonacci_py()` function does not call `Py_DECREF()`
    on the `result` variable.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Borrowed references**: The *borrowing* of references happens when the function
    receives a reference to some Python object as an argument. The reference count
    for such a reference should never be decreased in that function unless it was
    explicitly increased in its scope. In our `fibonacci_py()` function the `self`
    and `args` arguments are such borrowed references and thus we do not call `PyDECREF()`
    on them. Some of the Python/C API functions may also return borrowed references.
    The notable examples are `PyTuple_GetItem()` and `PyList_GetItem()`. It is often
    said that such references are *unprotected*. There is no need to dispose of its
    ownership unless it will be returned as a function''s return value. In most cases,
    extra care should be taken if we use such borrowed references as arguments of
    other Python/C API calls. It may be necessary in some circumstances to additionally
    protect such references with additional `Py_INCREF()` before using as argument
    to other function and then calling `Py_DECREF()` when it is no longer needed.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stolen references**: It is also possible for the Python/C API function to
    *steal* the reference instead of *borrowing* it when provided as a call argument.
    This is the case of exactly two functions: `PyTuple_SetItem()` and `PyList_SetItem()`.
    They fully take over the responsibility of the reference passed to them. They
    do not increase the reference count by themselves but will call `Py_DECREF()`
    when the reference is no longer needed.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping an eye on the reference counts is one of the hardest things when writing
    complex extensions. Some of the not-so-obvious issues may not be noticed until
    the code is run in a multithreaded setup.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'The other common problem is caused by the very nature of Python''s object model
    and the fact that some functions return borrowed references. When the reference
    count goes to zero, the deallocation function is executed. For user-defined classes,
    it is possible to define a `__del__()` method that will be called at that moment.
    This can be any Python code and it is possible that it will affect other objects
    and their reference counts. The official Python documentation gives the following
    example of code that may be affected by this problem:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It looks completely harmless, but the problem is in fact that we cannot know
    what elements the `list` object contains. When `PyList_SetItem()` sets a new value
    on the `list[1]` index, the ownership of the object that was previously stored
    at that index is disposed. If it was the only existing reference, the reference
    count will become 0 and the object will become deallocated. It is possible that
    it was some user-defined class with a custom implementation of the `__del__()`
    method. A serious issue will occur if in the result of such a `__del__()` execution
    `item[0]` will be removed from the list. Note that `PyList_GetItem()` returns
    a *borrowed* reference! It does not call `Py_INCREF()` before returning a reference.
    So in that code, it is possible that `PyObject_Print()` will be called with a
    reference to an object that no longer exists. This will cause a segmentation fault
    and crash the Python interpreter.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'The proper approach is to protect borrowed references for the whole time we
    need them because there is a possibility that any call in-between may cause deallocation
    of any other object—even if they are seemingly unrelated:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Cython
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cython is both an optimizing static compiler and the name of a programming language
    that is a superset of Python. As a compiler, it can perform *source to source*
    compilation of native Python code and its Cython dialect to Python C extensions
    using Python/C API. It allows you to combine the power of Python and C without
    the need to manually deal with Python/C API.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Cython as a source to source compiler
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For extensions created using Cython, the major advantage you will get is using
    the superset language that it provides. Anyway, it is possible to create extensions
    from plain Python code using *source to source* compilation. This is the simplest
    approach to Cython because it requires almost no changes to the code and can give
    some significant performance improvements at a very low development cost.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'Cython provides a simple `cythonize` utility function that allows you to easily
    integrate the compilation process with `distutils` or `setuptools`. Let''s assume
    that we would like to compile a pure Python implementation of our `fibonacci()`
    function to a C extension. If it is located in the `fibonacci` module, the minimal
    `setup.py` script could be as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Cython used as a source compilation tool for the Python language has another
    benefit. Source to source compilation to extensions can be a fully optional part
    of source distribution installation process. If the environment where the package
    needs to be installed does not have Cython or any other building prerequisites,
    it can be installed as a normal *pure Python* package. The user should not notice
    any functional difference in the behavior of code distributed that way.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'A common approach for distributing extensions built with Cython is to include
    both Python/Cython sources and C code that would be generated from these source
    files. This way the package can be installed in three different ways depending
    on the existence of building prerequisites:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: If the installation environment has Cython available, the extension C code is
    generated from the Python/Cython sources that are provided
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If Cython is not available but there are available building prerequisites (C
    compiler, Python/C API headers), the extension is built from distributed pre-generated
    C files
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If neither of the preceding prerequisites is available but the extension is
    created from pure Python sources, the modules are installed like ordinary Python
    code, and the compilation step is skipped
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that Cython documentation says that including generated C files as well
    as Cython sources is the recommended way of distributing Cython extensions. The
    same documentation says that Cython compilation should be disabled by default
    because the user may not have the required version of Cython in his environment
    and this may result in unexpected compilation issues. Anyway, with the advent
    of environment isolation, this seems to be a less worrying problem today. Also,
    Cython is a valid Python package that is available on PyPI, so it can easily be
    defined as your project requirement in a specific version. Including such a prerequisite
    is, of course, a decision with serious implications and should be considered very
    carefully. The safer solution is to leverage the power of the `extras_require`
    feature in the `setuptools` package and allow the user to decide whether he wants
    to use Cython with a specific environment variable:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `pip` installation tool supports the installation of packages with the
    *extras* option by adding the `[extra-name]` suffix to the package name. For the
    preceding example, the optional Cython requirement and compilation during the
    installation from local sources can be enabled using the following command:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Cython as a language
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Cython is not only a compiler but also a superset of the Python language. Superset
    means that any valid Python code is allowed and it can be further updated with
    additional features, such as support for calling C functions or declaring C types
    on variables and class attributes. So any code written in Python is also written
    in Cython. This explains why ordinary Python modules can be so easily compiled
    to C using the Cython compiler.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: But we won't stop on that simple fact. Instead of saying that our reference
    `fibonacci()` function is also code for valid extensions in this superset of Python,
    we will try to improve it a bit. This won't be any real optimization to our function
    design but some minor updates that will allow it to benefit from being written
    in Cython.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'Cython sources use a different file extension. It is `.pyx` instead of `.py`.
    Let''s assume that we still want to implement our Fibbonacci sequence. The content
    of `fibonacci.pyx` might look like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As you can see, the only thing that has really changed is the signature of
    the `fibonacci()` function. Thanks to optional static typing in Cython, we can
    declare the `n` argument as `unsigned int`, and this should slightly improve the
    way our function works. Additionally, it does a lot more than we did previously
    when writing extensions by hand. If the argument of the Cython function is declared
    with a static type, then the extension will automatically handle conversion and
    overflow errors by raising proper exceptions:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We already know that Cython compiles only *source to source* and the generated
    code uses the same Python/C API that we would use when writing C code for extensions
    by hand. Note that `fibonacci()` is a recursive function, so it calls itself very
    often. This will mean that although we declared a static type for input argument,
    during the recursive call it will treat itself like any other Python function.
    So `n-1` and `n-2` will be packed back into the Python object and then passed
    to the hidden wrapper layer of the internal `fibonacci()` implementation that
    will again bring it back to the `unsigned int` type. This will happen again and
    again until we reach the final depth of recursion. This is not necessarily a problem
    but involves a lot more argument processing than really required.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'We can cut off the overhead of Python function calls and argument processing
    by delegating more of the work to a pure C function that does not know anything
    about Python structures. We did this previously when creating C extensions with
    pure C and we can do that in Cython too. We can use the `cdef` keyword to declare
    C-style functions that accept and return only C types:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can go even further. With a plain C example, we finally showed how to release
    GIL during the call of our pure C function, so the extension was a bit nicer for
    multithreaded applications. In previous examples, we have used `Py_BEGIN_ALLOW_THREADS`
    and `Py_END_ALLOW_THREADS` preprocessor macros from Python/C API headers to mark
    section of code as free from Python calls. The Cython syntax is a lot shorter
    and easier to remember. GIL can be released around the section of code using a
    simple `with nogil` statement:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can also mark the whole C style function as safe to call without GIL:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: It is important to know that such functions cannot have Python objects as arguments
    or return types. Whenever a function marked as `nogil` needs to perform any Python/C
    API call, it must acquire GIL using the `with gil` statement.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Challenges
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be honest, I started my adventure with Python only because I was tired of
    all the difficulty of writing software in C and C++. In fact, it is very common
    that programmers start to learn Python when they realize that other languages
    do not deliver what the users need. Programming in Python, when compared to C,
    C++, or Java, is a breeze. Everything seems to be simple and well designed. You
    might think that there are no places where you can trip and there are no other
    programming languages required anymore.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: And of course nothing could be more wrong. Yes, Python is an amazing language
    with a lot of cool features and it is used in many fields. But it does not mean
    that it is perfect and does not have any downsides. It is easy to understand and
    write, but this easiness comes with a price. It is not as slow as many think,
    but will never be as fast as C. It is highly portable, but its interpreter is
    not available on as many architectures as compilers for other languages are. We
    could go with that list forever.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the solutions to that problem is to write extensions, so we can bring
    of some of the advantages of *good old C* back to Python. And in most cases, it
    works well. The question is: are we really using Python because we want to extend
    it with C? The answer is *no*. This is only an inconvenient necessity in situations
    where we don''t have any better option.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Additional complexity
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is not a secret that developing applications in many different languages
    is not an easy task. Python and C are completely different technologies and it
    is very hard to find anything that they have in common. It is also true that there
    is no application that is free of bugs. If extensions become common in your codebase,
    debugging can become painful. Not only because debugging of C code requires completely
    different workflow and tools, but also because you will need to switch context
    between two different languages very often.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: We are all humans and all have limited cognitive capabilities. There are, of
    course, people who can handle multiple layers of abstraction and technology stacks
    at the same time efficiently but they seem to be very rare specimens. No matter
    how skilled you are, there is always an additional price to pay for maintaining
    such hybrid solutions. This will either involve extra effort and time required
    to switch between C and Python, or additional stress that will make you eventually
    less efficient.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: According to the TIOBE index, C is still one of the most popular programming
    languages. Despite this fact, it is very common for Python programmers to know
    very little or almost nothing about it. Personally, I think that C should be *lingua
    franca* in the programming world, but my opinion is very unlikely to change anything
    in this matter. Python also is so seductive and easy to learn that a lot of programmers
    forget about all their previous experiences and completely switch to the new technology.
    And programming is not like riding a bike. This particular skill erodes faster
    if not used and polished sufficiently. Even programmers with strong C background
    are risking to gradually lose their previous knowledge if they decide to dive
    into Python for too long. All of the above leads to one simple conclusion—it is
    harder to find people who will be able to understand and extend your code. For
    open source packages, this means fewer voluntary contributors. In closed source,
    this means that not all of your teammates will be able to develop and maintain
    extensions without breaking things.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to failures, extensions may break, very badly. Static typing gives
    you a lot of advantages over Python and allows you to catch a lot of issues during
    the compilation step that would be hard to notice in Python without a rigorous
    testing routine and full test coverage. On the other hand, all memory management
    must be performed manually. And faulty memory management is the main reason of
    most programming errors in C. In the best case scenario, such mistakes will only
    result in some memory leaks that will gradually eat all of your environment resources.
    The best case does not mean easy to handle. Memory leaks are really tricky to
    find without using proper external tools such as Valgrind. Anyway, in most cases,
    the memory management issues in your extension's code will result in a segmentation
    fault that is unrecoverable in Python and will cause the interpreter to crash
    without raising any exception. This means that you will eventually need to arm
    up with additional tools that most Python programmers don't need to use. This
    adds complexity to your development environment and workflow.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing with dynamic libraries without extensions
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thanks to `ctypes` (a module in the standard library) or `cffi` (an external
    package), you can integrate just about every compiled dynamic/shared library in
    Python no matter in what language it was written. And you can do that in pure
    Python without any compilation steps, so this is an interesting alternative to
    writing extensions in C.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: This does not mean you don't need to know anything about C. Both solutions require
    from you a reasonable understanding of C and how dynamic libraries work in general.
    On the other hand, they remove the burden of dealing with Python reference counting
    and greatly reduce the risk of making painful mistakes. Also interfacing with
    C code through `ctypes` or `cffi` is more portable than writing and compiling
    the C extension module.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: ctypes
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ctypes` is the most popular module to call functions from dynamic or shared
    libraries without the need of writing custom C extensions. The reason for that
    is obvious. It is part of the standard library, so it is always available and
    does not require any external dependencies. It is a **foreign function interface**
    (**FFI**) library and provides an API for creating C-compatible datatypes.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Loading libraries
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are four types of dynamic library loaders available in `ctypes` and two
    conventions to use them. The classes that represent dynamic and shared libraries
    are `ctypes.CDLL`, `ctypes.PyDLL`, `ctypes.OleDLL`, and `ctypes.WinDLL`. The last
    two are only available on Windows, so we won''t discuss them here. The differences
    between `CDLL` and `PyDLL` are as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '`ctypes.CDLL`: This class represents loaded shared libraries. The functions
    in these libraries use the standard calling convention, and are assumed to return
    `int`. GIL is released during the call.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ctypes.PyDLL`: This class works like `CDLL`, but GIL is not released during
    the call. After execution, the Python error flag is checked and an exception is
    raised if it is set. It is only useful when directly calling functions from Python/C
    API.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To load a library, you can either instantiate one of the preceding classes
    with proper arguments or call the `LoadLibrary()` function from the submodule
    associated with a specific class:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '`ctypes.cdll.LoadLibrary()` for `ctypes.CDLL`'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ctypes.pydll.LoadLibrary()` for `ctypes.PyDLL`'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ctypes.windll.LoadLibrary()` for `ctypes.WinDLL`'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ctypes.oledll.LoadLibrary()` for `ctypes.OleDLL`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main challenge when loading shared libraries is how to find them in a portable
    way. Different systems use different suffixes for shared libraries (`.dll` on
    Windows, `.dylib` on OS X, `.so` on Linux) and search for them in different places.
    The main offender in this area is Windows, that does not have a predefined naming
    scheme for libraries. Because of that, we won't discuss the details of loading
    libraries with `ctypes` on this system and concentrate mainly on Linux and Mac
    OS X that deal with this problem in a consistent and similar way. If you are anyway
    interested in Windows platform, refer to the official `ctypes` documentation that
    has plenty of information about supporting that system (refer to [https://docs.python.org/3.5/library/ctypes.html](https://docs.python.org/3.5/library/ctypes.html)).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'Both library loading conventions (the `LoadLibrary()` function and specific
    library-type classes) require you to use the full library name. This means all
    the predefined library prefixes and suffixes need to be included. For example,
    to load the C standard library on Linux, you need to write the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here, for Mac OS X, this would be:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Fortunately, the `ctypes.util` submodule provides a `find_library()` function
    that allows to load a library using its name without any prefixes or suffixes
    and will work on any system that has a predefined scheme for naming shared libraries:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Calling C functions using ctypes
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When the library is successfully loaded, the common pattern is to store it
    as a module-level variable with the same name as library. The functions can be
    accessed as object attributes, so calling them is like calling a Python function
    from any other imported module:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Unfortunately, all the built-in Python types except integers, strings, and
    bytes are incompatible with C datatypes and thus must be wrapped in the corresponding
    classes provided by the `ctypes` module. Here is the full list of compatible datatypes
    that comes from the `ctypes` documentation:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '| ctypes type | C type | Python type |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
- en: '| `c_bool` | `_Bool` | `bool` (1) |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
- en: '| `c_char` | `char` | 1-character `bytes` object |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
- en: '| `c_wchar` | `wchar_t` | 1-character `string` |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
- en: '| `c_byte` | `char` | `int` |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
- en: '| `c_ubyte` | `unsigned char` | `int` |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
- en: '| `c_short` | `short` | `int` |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
- en: '| `c_ushort` | `unsigned short` | `int` |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
- en: '| `c_int` | `int` | `int` |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
- en: '| `c_uint` | `unsigned int` | `int` |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
- en: '| `c_long` | `long` | `int` |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
- en: '| `c_ulong` | `unsigned long` | `int` |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
- en: '| `c_longlong` | `__int64 or long long` | `int` |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
- en: '| `c_ulonglong` | `unsigned __int64 or unsigned long long` | `int` |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
- en: '| `c_size_t` | `size_t` | `int` |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
- en: '| `c_ssize_t` | `ssize_t or Py_ssize_t` | `int` |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
- en: '| `c_float` | `float` | `float` |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
- en: '| `c_double` | `double` | `float` |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
- en: '| `c_longdouble` | `long double` | `float` |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
- en: '| `c_char_p` | `char * (NUL terminated)` | `bytes` object or `None` |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
- en: '| `c_wchar_p` | `wchar_t * (NUL terminated)` | `string` or `None` |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
- en: '| `c_void_p` | `void *` | `int` or `None` |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
- en: 'As you can see, the preceding table does not contain dedicated types that would
    reflect any of the Python collections as C arrays. The recommended way to create
    types for C arrays is to simply use the multiplication operator with the desired
    basic `ctypes` type:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Passing Python functions as C callbacks
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is a very popular design pattern to delegate part of the work of function
    implementation to custom callbacks provided by the user. The most known function
    from the C standard library that accepts such callbacks is a `qsort()` function
    that provides a generic implementation of the **Quicksort** algorithm. It is rather
    unlikely that you would like to use this algorithm instead of the default Python
    **Timsort** that is more suited for sorting Python collections. Anyway, `qsort()`
    seems to be a canonical example of an efficient sorting algorithm and a C API
    that uses the callback mechanism that is found in many programming books. This
    is why we will try to use it as an example of passing the Python function as a
    C callback.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'The ordinary Python function type will not be compatible with the callback
    function type required by the `qsort()` specification. Here is the signature of
    `qsort()` from the BSD `man` page that also contains the type of accepted callback
    type (the `compar` argument):'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'So in order to execute `qsort()` from `libc`, you need to pass:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '`base`: This is the array that needs to be sorted as a `void*` pointer.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nel`: This is the number of elements as `size_t`.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`width`: This is the size of the single element in the array as `size_t`.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compar`: This is the pointer to the function that is supposed to return `int`
    and accepts two `void*` pointers. It points to the function that compares the
    size of two elements being sorted.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We already know from the *Calling C functions using ctypes* section how to construct
    the C array from other `ctypes` types using the multiplication operator. `nel`
    should be `size_t`, and it maps to Python `int`, so it does not require any additional
    wrapping and can be passed as `len(iterable)`. The `width` value can be obtained
    using the `ctypes.sizeof()` function once we know the type of our `base` array.
    The last thing we need to know is how to create the pointer to the Python function
    compatible with the `compar` argument.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ctypes` module contains a `CFUNTYPE()` factory function that allows us
    to wrap Python functions and represents them as C callable function pointers.
    The first argument is the C return type that the wrapped function should return.
    It is followed by the variable list of C types that the function accepts as its
    arguments. The function type compatible with the `compar` argument of `qsort()`
    will be:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`CFUNTYPE()` uses the `cdecl` calling convention, so it is compatible only
    with the `CDLL` and `PyDLL` shared libraries. The dynamic libraries on Windows
    that are loaded with `WinDLL` or `OleDLL` use the `stdcall` calling convention.
    This means that the other factory must be used to wrap Python functions as C callable
    function pointers. In `ctypes`, it is `WINFUNCTYPE()`.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'To wrap everything up, let''s assume that we want to sort a randomly shuffled
    list of integer numbers with a `qsort()` function from the standard C library.
    Here is the example script that shows how to do that using everything that we
    have learned about `ctypes` so far:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The comparison function provided as a callback has an additional `print` statement,
    so we can see how it is executed during the sorting process:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: CFFI
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CFFI is a Foreign Function Interface for Python that is an interesting alternative
    to `ctypes`. It is not a part of the standard library but is easily available
    as a `cffi` package on PyPI. It is different from `ctypes` because it puts more
    emphasis on reusing plain C declarations instead of providing extensive Python
    APIs in a single module. It is way more complex and also has a feature that also
    allows you to automatically compile some parts of your integration layer into
    extensions using C compiler. So it can be used as a hybrid solution that fills
    the gap between C extensions and `ctypes`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'Because it is a very large project, it is impossible to shortly introduce it
    in a few paragraphs. On the other hand, it would be a shame to not say something
    more about it. We have already discussed one example of integrating the `qsort()`
    function from the standard library using `ctypes`. So, the best way to show the
    main differences between these two solutions will be to re-implement the same
    example with `cffi`. I hope that one block of code is worth more than a few paragraphs
    of text:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Summary
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explained one of the most advanced topics in the book. We discussed
    the reasons and tools for building Python extensions. We started from writing
    pure C extensions that depend only on Python/C API and then re-implemented them
    with Cython to show how easy it can be if you only choose the proper tool.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: There are still some reasons for doing things *the hard way* and using nothing
    more than the pure C compiler and the `Python.h` headers. Anyway, the best recommendation
    is to use tools such as Cython or Pyrex (not featured here) because it will make
    your codebase more readable and maintainable. It will also save you from most
    of the issues caused by incautious reference counting and memory management.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Our discussion of extensions ended with the presentation of `ctypes` and CFFI
    as an alternative way to solve the problems of integrating shared libraries. Because
    they do not require writing custom extensions to call functions from compiled
    binaries, they should be your tools of choice for doing that—especially if you
    don't need to use custom C code.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: In next chapter, we will take a short rest from low-level programming techniques
    and delve into topics that are no less important—code management and version control
    systems.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
