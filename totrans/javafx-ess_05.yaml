- en: Chapter 5. Developing a JavaFX Application for iOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apple has a great market share in the mobile and PC/Laptop world, with many
    different devices, from mobile phones such as the iPhone to musical devices such
    as the iPod and tablets such as the iPad.
  prefs: []
  type: TYPE_NORMAL
- en: It has a rapidly growing application market, called the Apple Store, serving
    its community, where the number of available apps increases daily. Mobile application
    developers should be ready for such a market.
  prefs: []
  type: TYPE_NORMAL
- en: Mobile application developers targeting both iOS and Android face many challenges.
    By just comparing the native development environments of these two platforms,
    you will find that they differ substantially.
  prefs: []
  type: TYPE_NORMAL
- en: iOS development, according to Apple, is based on the **Xcode IDE (**[https://developer.apple.com/xcode/](https://developer.apple.com/xcode/)**)**
    and its programming languages. Traditionally, it was **Objetive-C** and, in June
    2014, Apple introduced **Swift** ([https://developer.apple.com/swift/](https://developer.apple.com/swift/));
    on the other hand, *Android* development, as defined by Google, is based on the
    Intellij IDEA IDE and the Java programming language.
  prefs: []
  type: TYPE_NORMAL
- en: Not many developers are proficient in both environments. In addition, these
    differences rule out any code reuse between the platforms.
  prefs: []
  type: TYPE_NORMAL
- en: JavaFX 8 is filling the gap for reusable code between the platforms, as we will
    see in this chapter, by sharing the same application in both platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some skills that you will have gained by the end of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring iOS environment tools and software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating iOS JavaFX 8 applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating and debugging JavaFX mobile applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packaging and deploying applications on iOS mobile devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using RoboVM to run JavaFX on iOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**RoboVM** is the bridge from Java to Objetive-C. Using this, it becomes easy
    to develop JavaFX 8 applications that are to be run on iOS-based devices, as the
    ultimate goal of the **RoboVM** project is to solve this problem without compromising
    on developer experience or app user experience.'
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in the previous chapter about Android, using *JavaFXPorts* to generate
    APKs was a relatively easy task due to the fact that Android is based on Java
    and the **Dalvik VM**.
  prefs: []
  type: TYPE_NORMAL
- en: On the contrary, iOS doesn't have a VM for Java, and it doesn't allow dynamic
    loading of native libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Another approach is required. The RoboVM open source project tries to close
    the gap for Java developers by creating a bridge between Java and Objective-C
    using an *ahead-of-time* compiler that translates Java bytecode into native ARM
    or x86 machine code.
  prefs: []
  type: TYPE_NORMAL
- en: Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s go through the RoboVM features:'
  prefs: []
  type: TYPE_NORMAL
- en: Brings Java and other JVM languages, such as Scala, Clojure, and Groovy, to
    iOS-based devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Translates Java bytecode into machine code ahead of time for fast execution
    directly on the CPU without any overhead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main target is iOS and the ARM processor (32- and 64-bit), but there is
    also support for Mac OS X and Linux running on x86 CPUs (both 32- and 64-bit)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does not impose any restrictions on the Java platform features accessible to
    the developer, such as reflection or file I/O
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports standard JAR files that let the developer reuse the vast ecosystem
    of third-party Java libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides access to the full native iOS APIs through a Java-to-Objective-C bridge,
    enabling the development of apps with truly native UIs and with full hardware
    access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrates with the most popular tools such as NetBeans, Eclipse, Intellij IDEA,
    Maven, and Gradle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: App Store ready, with hundreds of apps already in the store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limitations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mainly due to the restrictions of the iOS platform, there are a few limitations
    when using RoboVM:'
  prefs: []
  type: TYPE_NORMAL
- en: Loading custom bytecode at runtime is not supported. All class files comprising
    the app have to be available at compile time on the developer machine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Java Native Interface technology as used on the desktop or on servers usually
    loads native code from dynamic libraries, but Apple does not permit custom dynamic
    libraries to be shipped with an iOS app. RoboVM supports a variant of JNI based
    on static libraries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another big limitation is that RoboVM is an alpha-state project under development
    and not yet recommended for production usage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: RoboVM has full support for reflection.
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned in [Chapter 4](ch04.html "Chapter 4. Developing a JavaFX Application
    for Android"), *Developing a JavaFX Application for Android*, since February 2015
    there has been an agreement between the companies behind RoboVM and JavaFXPorts,
    and now a single plugin called jfxmobile-plugin allows us to build applications
    for three platforms—desktop, Android, and iOS—from the same codebase.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaFXMobile plugin adds a number of tasks to your Java application that
    allow you to create .ipa packages that can be submitted to the Apple Store.
  prefs: []
  type: TYPE_NORMAL
- en: Android mostly uses Java as the main development language, so it is easy to
    merge your JavaFX 8 code with it. On iOS, the situation is internally totally
    different—but with similar Gradle commands.
  prefs: []
  type: TYPE_NORMAL
- en: The plugin will download and install the RoboVM compiler, and it will use RoboVM
    compiler commands to create an iOS application in `build/javafxports/ios`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how to install the RoboVM compiler using the
    `JavaFXMobile` plugin, and make sure the tool chain works correctly by reusing
    the same application, Phone Dial version 1.0, we developed previously for the
    Android platform in [Chapter 4](ch04.html "Chapter 4. Developing a JavaFX Application
    for Android"), *Developing a JavaFX Application for Android*.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to use the RoboVM compiler to build iOS apps, the following tools
    are required:'
  prefs: []
  type: TYPE_NORMAL
- en: Oracle's Java SE JDK 8 update 45\. Refer to [Chapter 1](ch01.html "Chapter 1. Getting
    Started with JavaFX 8"), *Getting Started with JavaFX 8*, The *Installing Java
    SE 8 JDK* section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gradle 2.4 or higher is required to build applications with the `jfxmobile`
    plugin. Refer to [Chapter 4](ch04.html "Chapter 4. Developing a JavaFX Application
    for Android"), *Developing a JavaFX Application for Android*, The Installing *Gradle
    2.4* section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Mac running **Mac OS X** 10.9 or later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Xcode 6.x from the Mac App Store ([https://itunes.apple.com/us/app/xcode/id497799835?mt=12](https://itunes.apple.com/us/app/xcode/id497799835?mt=12)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first time you install **Xcode**, and every time you update to a new version,
    you have to open it once to agree to the Xcode terms.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing a project for iOS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will reuse the project we developed before in [Chapter 4](ch04.html "Chapter 4. Developing
    a JavaFX Application for Android"), *Developing a JavaFX Application for Android*,
    for the Android platform, since there is no difference in code, project structure,
    or Gradle build script when targeting iOS.
  prefs: []
  type: TYPE_NORMAL
- en: They share the same properties and features, but with different Gradle commands
    that serve iOS development, and a minor change in the Gradle build script for
    the RoboVM compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we will see the power of **WORA** *Write Once, Run Everywhere* with
    the same application.
  prefs: []
  type: TYPE_NORMAL
- en: Project structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Based on the same project structure from the Android example from [Chapter
    4](ch04.html "Chapter 4. Developing a JavaFX Application for Android"), *Developing
    a JavaFX Application for Android*, the project structure for our iOS app should
    be as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Project structure](img/B03998_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are going to reuse the same application from [Chapter 4](ch04.html "Chapter 4. Developing
    a JavaFX Application for Android"), *Developing a JavaFX Application for Android*:
    the Phone DialPad version 2.0 JavaFX 8 application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The application](img/B03998_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, reusing the same codebase is a very powerful and useful feature,
    especially when you are developing to target many mobile platforms such as iOS
    and Android at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Interoperability with low-level iOS APIs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To have the same functionality of natively calling the default iOS phone dialer
    from our application as we did with Android, we have to provide the native solution
    for iOS as the following `IosPlatform` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Gradle build files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will use the same Gradle build script file that was used in [Chapter 4](ch04.html
    "Chapter 4. Developing a JavaFX Application for Android"), *Developing a JavaFX
    Application for Android*, but with a minor change by adding the following lines
    to the end of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: All the work involved in installing and using `robovm` compilers is done by
    the `jfxmobile` plugin.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of those lines is to give the RoboVM compiler the location of the
    main application class that has to be loaded at runtime is, as it is not visible
    by default to the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: The `forceLinkClasses` property ensures that those classes are linked in during
    RoboVM compilation.
  prefs: []
  type: TYPE_NORMAL
- en: Building the application
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'After we have added the necessary configuration set to build the script for
    iOS, its time to build the application in order to deploy it to different iOS
    target devices. To do so, we have to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We should have the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We have built our application successfully; next, we need to generate the .`ipa`
    and, in the case of production, you have to test it by deploying it to as many
    iOS versions as you can.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the iOS .ipa package file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In order to generate the final .ipa iOS package for our JavaFX 8 application,
    which is necessary for the final distribution to any device or the AppStore, you
    have to run the following `gradle` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This will generate the .`ipa` file in the directory `build/javafxports/ios`.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: During development, we need to check our application GUI and final application
    prototype on iOS simulators and measure the application performance and functionality
    on different devices. These procedures are very useful, especially for testers.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how it is a very easy task to run our application on either simulators
    or on real devices.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to a simulator
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'On a simulator, you can simply run the following command to check if your application
    is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will package and launch the application in an *iPhone simulator*
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying to a simulator](img/B03998_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: DialPad2 JavaFX 8 application running on the iOS 8.3/iPhone 4s simulator
  prefs: []
  type: TYPE_NORMAL
- en: 'This command will launch the application in an iPad simulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Deploying to an Apple device
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In order to package a JavaFX 8 application and deploy it to an Apple device,
    simply run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This command will launch the JavaFX 8 application in the device that is connected
    to your desktop/laptop.
  prefs: []
  type: TYPE_NORMAL
- en: Then, once the application is launched on your device, type in any number and
    then tap Call.
  prefs: []
  type: TYPE_NORMAL
- en: 'The iPhone will ask for permission to dial using the default mobile dialer;
    tap on **Ok**. The default mobile dialer will be launched and will the number
    as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying to an Apple device](img/B03998_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Default mobile dialer
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To be able to test and deploy your apps on your devices, you will need an active
    subscription with the Apple Developer Program. Visit the Apple Developer Portal,
    [https://developer.apple.com/register/index.action](https://developer.apple.com/register/index.action),
    to sign up. You will also need to provision your device for development. You can
    find information on device provisioning in the Apple Developer Portal, or follow
    this guide: [http://www.bignerdranch.com/we-teach/how-to-prepare/ios-device-provisioning/](http://www.bignerdranch.com/we-teach/how-to-prepare/ios-device-provisioning/).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter gave us a very good understanding of how JavaFX-based applications
    can be developed and customized using RoboVM for **iOS** to make it possible to
    run your applications on Apple platforms.
  prefs: []
  type: TYPE_NORMAL
- en: You learned about RoboVM features and limitations, and how it works; you also
    gained skills that you can use for developing.
  prefs: []
  type: TYPE_NORMAL
- en: You then learned how to install the required software and tools for iOS development
    and how to enable Xcode along with the *RoboVM* compiler, to package and install
    the Phone Dial JavaFX-8-based application on OS simulators.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how we reused the same application we already developed in [Chapter
    4](ch04.html "Chapter 4. Developing a JavaFX Application for Android"), *Developing
    a JavaFX Application for Android*, proving that the Java WORA paradigm works.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we provided tips on how to run and deploy your application on real
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will open a window on the IoT development world; we are going
    to see how to buy a RaspberryPi model 2, install and configure *raspbian-wheezy*
    OS for development, and how to install the Java SE for embedded devices. We will
    then develop a JavaFX 8 application that will run on our credit-card-sized microcomputer.
  prefs: []
  type: TYPE_NORMAL
