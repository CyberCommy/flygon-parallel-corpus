- en: 15\. Extending Docker with Plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to extend the capabilities of Docker Engine
    by creating and installing plugins. You will see how to implement your advanced
    and custom requirements while using Docker containers. By the end of the chapter,
    you will be able to identify the basics of extending Docker. You will also be
    able to install and configure different Docker plugins. Moving ahead, you will
    work with the Docker plugin API to develop custom plugins and use various Docker
    plugins to extend the capabilities of volumes, networking, and authorization in
    Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, you ran multiple Docker containers with **Docker Compose**
    and **Docker Swarm**. In addition, you monitored the metrics from containers and
    collected the logs. Docker allows you to manage the complete life cycle of containers,
    including networking, volumes, and process isolations. If you want to customize
    the operations of Docker to work with your custom storage, network provider, or
    authentication server, you need to extend the capabilities of Docker.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if you have a custom cloud-based storage system and you want to
    mount it to your Docker containers, you can implement a storage plugin. Similarly,
    you can authenticate your users from your enterprise user management system using
    authorization plugins and allow them to work with Docker containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to extend Docker with its plugins. You
    will start with plugin management and APIs, followed by the most advanced and
    requested plugin types: authorization, network, and volume. The next section will
    cover the installation and operation of plugins in Docker.'
  prefs: []
  type: TYPE_NORMAL
- en: Plugin Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Plugins in Docker are external processes that run independently of Docker Engine.
    This means that Docker Engine does not rely on plugins and vice versa. We just
    need to inform Docker Engine about the plugin location and its capabilities. Docker
    provides the following CLI commands to manage the life cycle of plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker plugin create`: This command creates a new plugin and its configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker plugin enable/disable`: These commands enable or disable a plugin.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker plugin install`: This command installs a plugin.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker plugin upgrade`: This command upgrades an existing plugin to a newer
    version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker plugin rm`: This command removes plugins by removing their information
    from Docker Engine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker plugin ls`: This command lists the installed plugins.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker plugin inspect`: This command displays detailed information on plugins.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following section, you will learn how plugins are implemented in Docker
    with the plugin API.
  prefs: []
  type: TYPE_NORMAL
- en: Plugin API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker maintains a plugin API to help the community write their plugins. This
    means that anyone can develop new plugins as long as they implement it in accordance
    with the plugin API. This approach makes Docker an open and extensible platform.
    The plugin API is a **Remote Procedure Call** (**RPC**)-style JSON API that works
    over HTTP. Docker Engine sends HTTP POST requests to the plugin and uses the responses
    to continue its operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker also provides an official open-source SDK for creating new plugins and
    **helper packages** to extend Docker Engine. The helper packages are boilerplate
    templates if you want to easily create and run new plugins. Currently, there are
    only helper packages in Go since Go is the main implementation language of Docker
    Engine itself. It is located at [https://github.com/docker/go-plugins-helpers](https://github.com/docker/go-plugins-helpers)
    and provides helpers for every kind of plugin supported by Docker:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.1: Go plugin helpers'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15021_15_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.1: Go plugin helpers'
  prefs: []
  type: TYPE_NORMAL
- en: You can check each folder listed in the repository to create and run different
    types of plugins easily. In this chapter, you will explore the supported plugin
    types—namely, authorization, network, and volume plugins—through several practical
    exercises. The plugins enable Docker Engine to implement custom business requirements
    by providing additional functionalities along with the default Docker functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization Plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Docker authorization is based on two modes: **all kinds of actions are enabled**
    or **all kinds of actions are disabled**. In other words, if a user can access
    the Docker daemon, they can run any command and consume the API or Docker client
    commands. If you need more granular access control methods, you need to use authorization
    plugins in Docker. Authorization plugins enhance authentication and permission
    for Docker Engine operations. They enable more granular access to control who
    can take specific actions on Docker Engine.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Authorization plugins approve or deny the requests forwarded by Docker daemons
    using the request context. Therefore, the plugins should implement the following
    two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AuthZReq`: This method is called before the Docker daemon processes the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AuthZRes`: This method is called before the response is returned from the
    Docker daemon to the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following exercise, you will learn how to configure and install an authorization
    plugin. You will install the **policy-based authorization** plugin created and
    maintained by Open Policy Agent ([https://www.openpolicyagent.org/](https://www.openpolicyagent.org/)).
    **Policy-based access** is based on the idea of granting access to the users based
    on some rules, namely **policies**. The source code of the plugin is available
    on GitHub at [https://github.com/open-policy-agent/opa-docker-authz](https://github.com/open-policy-agent/opa-docker-authz),
    and it works with policy files similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The policy files are stored in the host system where the Docker daemon can read.
    For instance, the policy file shown here only allows `GET` as the method of the
    request. It actually makes the Docker daemon read-only by disallowing any other
    methods, such as `POST`, `DELETE`, or `UPDATE`. In the following exercise, you
    will use a policy file and configure the Docker daemon to communicate with the
    authorization plugin and limit some requests.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Plugins and the commands in the following exercises work best in Linux environments,
    considering the installation and the configuration of the Docker daemon. If you
    are using a custom or toolbox Docker installation, you may want to complete the
    exercises in this chapter using a virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Please use `touch` command to create files and `vim` command to work on the
    file using vim editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 15.01: Read-Only Docker Daemon with Authorization Plugins'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you are required to create a read-only Docker daemon. This
    is a common approach if you want to limit the access and changes to your production
    environment. To achieve this, you will install and configure the plugin with a
    policy file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the exercise, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file located at `/etc/docker/policies/authz.rego` by running the following
    commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'These commands create a file located at `/etc/docker/policies`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the file with an editor and insert the following data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can write the content into the file with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `cat` command is used to make the file content editable in the terminal.
    Unless you are running Ubuntu in headless mode, you may skip using CLI-based commands
    to edit the content of files.
  prefs: []
  type: TYPE_NORMAL
- en: The policy file only allows `GET` methods in the Docker daemon; in other words,
    it makes the Docker daemon read-only.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the plugin by running the following command in your terminal and enter
    *y* when it prompts for permissions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This command installs the plugin located at `openpolicyagent/opa-docker-authz-v2:0.5`
    with the alias `opa-docker-authz:readonly`. In addition, the policy file from
    *Step 1* is passed as `opa-args`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.2: Plugin installation'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15021_15_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.2: Plugin installation'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check for the installed plugins using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This command lists the plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.3: Plugin listing'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15021_15_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.3: Plugin listing'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the Docker daemon configuration at `/etc/docker/daemon.json` with the
    following edition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can check the contents of the file with the `cat /etc/docker/daemon.json`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reload the Docker daemon with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This command kills the process of `dockerd` by getting its process ID with
    the `pidof` command. In addition, it sends the `HUP` signal, which is the signal
    sent to Linux processes to update their configuration. In short, you are reloading
    the Docker daemon with the new authorization plugin configuration. Run the following
    listing command to check whether the listing action is allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This command lists the running containers, and it shows that the listing action
    is allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to check whether creating new containers is permitted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This command creates and runs a container; however, since the action is not
    read-only, it is not allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Check for the logs of the Docker daemon for any plugin-related lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`journalctl` is a command-line tool for displaying logs from `systemd` processes.
    `systemd` processes store the logs in binary format. `journalctl` is required
    to read the log texts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output shows that the tested actions in *Step 7* and *Step 8*
    passed through the authorization plugin with the `"Returning OPA policy decision:
    true"` and `"Returning OPA policy decision: false"` lines. It shows that our plugin
    has allowed the first action and declined the second one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.4: Plugin logs'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15021_15_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.4: Plugin logs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Stop using the plugin by removing the `authorization-plugins` part from `/etc/docker/daemon.json`
    and reload the Docker daemon similar to what was done in *Step 6*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Disable and remove the plugin with the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: These commands disable and remove the plugin from Docker by returning the names
    of the plugins.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you have configured and installed an authorization plugin
    into Docker. In the next section, you will learn more about networking plugins
    in Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Network Plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Docker supports a wide range of networking technologies with the help of Docker
    networking plugins. Although it supports container-to-container and host-to-container
    networking with full functionality, the plugins enable us to extend networking
    to further technologies. The networking plugins implement a remote driver as a
    part of different network topologies, such as virtual extensible LAN (`vxlan`)
    and MAC virtual LAN (`macvlan)`. You can install and enable networking plugins
    with the Docker plugin commands. Also, you need to specify the name of the network
    driver with `--driver` flags. For instance, if you have installed an enabled `my-new-network-technology`
    driver and want your new network to be a part of it, you need to set a `driver`
    flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This command creates a network named `mynet`, and the `my-new-network-technology`
    plugin manages all networking operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The community and third-party companies develop networking plugins. However,
    there are currently only two certified networking plugins in Docker Hub – Weave
    Net and Infoblox IPAM Plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.5: Networking plugins in Docker Hub'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15021_15_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.5: Networking plugins in Docker Hub'
  prefs: []
  type: TYPE_NORMAL
- en: '**Infoblox IPAM Plugin** focuses on providing IP address management services,
    such as writing DNS records and configuring DHCP settings. **Weave Net** focuses
    on creating resilient networking for Docker containers with encryption, service
    discovery, and multicast networking.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The official SDK provided in `go-plugin-helpers` has Go handlers to create
    network extensions for Docker. The `Driver` interface is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The complete code is available at [https://github.com/docker/go-plugins-helpers/blob/master/network/api.go](https://github.com/docker/go-plugins-helpers/blob/master/network/api.go).
  prefs: []
  type: TYPE_NORMAL
- en: When you check the interface functions, the networking plugins should provide
    operations for networking, endpoints, and external connectivity. For instance,
    a network plugin should implement a network life cycle with the `CreateNetwork`,
    `AllocateneNetwork`, `DeleteNetwork`, and `FreeNetwork` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the endpoint life cycle should be implemented by the `CreateEndpoint`,
    `DeleteEndpoint`, and `EndpointInfo` functions. In addition, there are some extension
    integration and management functions to implement, including `GetCapabilities`,
    `Leave`, and `Join`. The services also need their specific request and response
    types to work in a managed plugin environment.
  prefs: []
  type: TYPE_NORMAL
- en: In the following exercise, you will create a new network using the Weave Net
    plugin and let containers connect using the new network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 15.02: Docker Network Plugins in Action'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docker network plugins take over the network operations for specific network
    instances and implement custom technologies. In this exercise, you will install
    and configure a network plugin to create a Docker network. You will then create
    a three-replica application of a Docker image and use the plugin to connect these
    three instances. You can use the Weave Net plugin to achieve this goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the exercise, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize a Docker swarm (if you have not enabled one before) by running the
    following command in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This command creates a Docker swarm to deploy multiple instances of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.6: Swarm initialization'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15021_15_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.6: Swarm initialization'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the **Weave Net** plugin by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This command installs the plugin from the store and grants all permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.7: Plugin installation'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15021_15_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.7: Plugin installation'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new network using the driver with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This command creates a new network named `weave-custom-net` using the driver
    provided with the plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.8: Creating the network'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15021_15_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.8: Creating the network'
  prefs: []
  type: TYPE_NORMAL
- en: Following the successful creation of the network, a randomly generated network
    name will be printed as shown in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a three-replica application with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This command creates three replicas of the `onuryilmaz/hello-plain-text` image
    and uses `the weave-custom-net` network to connect the instances. In addition,
    it uses the name `workshop` and publishes to the port `80`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.9: Application creation'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15021_15_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.9: Application creation'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get the names of the containers by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'These commands list the running Docker container names and filter by `workshop`
    instances. You will need the name of the containers to test the connection between
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.10: Container names'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15021_15_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.10: Container names'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to connect the first container to the second one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This command connects the first and second containers using the `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.11: Connection between containers'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15021_15_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.11: Connection between containers'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding command is running inside the first container and the `curl` command
    reaches the second container. The output shows the server and the request information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to *Step 6*, connect the first container to the third one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, different server names and addresses are retrieved in *Step 6*
    and *Step 7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.12: Connection between containers'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15021_15_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.12: Connection between containers'
  prefs: []
  type: TYPE_NORMAL
- en: This shows that the containers created using the custom Weave Net network are
    working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can delete the application and network with the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, you have installed and used a networking plugin in Docker.
    Besides that, you have created a containerized application that connects using
    a custom network driver. In the next section, you will learn more about the volume
    plugins in Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Volume Plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker volumes are mounted to containers to allow stateful applications to run
    in containers. By default, volumes are created in the filesystem of the host machine
    and managed by Docker. In addition, while creating a volume, it is possible to
    specify a volume driver. For instance, you can mount volumes over network or storage
    providers such as **Google**, **Azure**, or **AWS**. You can also run your database
    locally in Docker containers while the data volumes are persistent in AWS storage
    services. This way, your data volumes can be reused in the future with other database
    instances running in any other location. To use different volume drivers, you
    need to enhance Docker with volume plugins.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker volume plugins control the life cycle of volumes, including the `Create`,
    `Mount`, `Unmount`, `Path`, and `Remove` functions. In the plugin SDK, the volume
    driver interface is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The complete driver code is available at [https://github.com/docker/go-plugins-helpers/blob/master/volume/api.go](https://github.com/docker/go-plugins-helpers/blob/master/volume/api.go).
  prefs: []
  type: TYPE_NORMAL
- en: The functions of the driver interface show that volume drivers focus on basic
    operations, such as `Create`, `List`, `Get`, and `Remove` operations, of the volumes.
    The plugins are responsible for mounting and unmounting volumes to and from containers.
    If you want to create a new volume driver, you need to implement this interface
    with the corresponding request and response types.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are numerous volume plugins already available from Docker Hub and the
    open-source community. For instance, there are currently 18 volume plugins categorized
    and verified on Docker Hub:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.13: Volume plugins in Docker Hub'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15021_15_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.13: Volume plugins in Docker Hub'
  prefs: []
  type: TYPE_NORMAL
- en: Most of the plugins focus on providing storage from different sources, such
    as cloud providers and storage technologies. Based on your business requirements
    and technology stack, you may consider volume plugins in your Docker setup.
  prefs: []
  type: TYPE_NORMAL
- en: In the following exercise, you will create volumes in remote systems using SSH
    connections and volumes in containers. For the volumes created and used over SSH
    connections, you will use the `open-source docker-volume-sshfs` plugin available
    at [https://github.com/vieux/docker-volume-sshfs](https://github.com/vieux/docker-volume-sshfs).
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 15.03: Volume Plugins in Action'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docker volume plugins manage the life cycle of volumes by providing storage
    from different providers and technologies. In this exercise, you will install
    and configure a volume plugin to create volumes over an SSH connection. Following
    the successful creation of the volumes, you will use them in containers and ensure
    that the files are persisted. You can use the `docker-volume-sshfs` plugin to
    achieve this goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the exercise, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `docker-volume-sshfs` plugin by running the following command in
    your terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This command installs the plugin by granting all the permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.14: Plugin installation'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15021_15_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.14: Plugin installation'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Docker container with an SSH connection to provide volumes to other
    containers with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This command creates and runs an `sshd` container named `volume_provider`. Port
    `2222` is published and will be used to connect to this container in the following
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should get an output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new volume, named `volume-over-ssh`, by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This command creates a new volume using the `vieux/sshfs` driver and the `ssh`
    connection specified with `sshcmd` and the `password` and `port` parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new file and save it in the volume created in *Step 3* by running
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This command runs a container by mounting `volume-over-ssh`. It then creates
    a file and writes into it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the contents of the file created in *Step 4* by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This command runs a container by mounting the same volume and reads the file
    from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '(Optional) Delete the volume by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, you have installed and used a volume plugin in Docker. Furthermore,
    you have created a volume and used it from multiple containers for writing and reading.
  prefs: []
  type: TYPE_NORMAL
- en: In the next activity, you will install WordPress in Docker using networking
    and volume plugins.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 15.01: Installing WordPress with Network and Volume Plugins'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You are tasked with designing and deploying a blog and its database as microservices
    in Docker using networking and volume plugins. You will be using **WordPress**
    since it is the most popular **Content Management System** (**CMS**), being used
    by more than one-third of all websites on the internet. The storage team requires
    you to use volumes over **SSH** for the WordPress content. In addition, the network
    team wants you to use **Weave Net** for networking between the containers. With
    these tools, you will create networks and volumes using Docker plugins and use
    them for WordPress and its database:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a Docker network (namely, `wp-network`) using the **Weave Net** plugin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a volume with the name `wp-content`, using the `vieux/sshfs` driver.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a container with the name `mysql` to run the `mysql:5.7` image. Ensure
    that the `MYSQL_ROOT_PASSWORD`, `MYSQL_DATABASE`, `MYSQL_USER`, and `MYSQL_PASSWORD`
    environment variables are set. In addition, the container should use `wp-network`
    from *Step 1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a container with the name `wordpress` and use the volume from *Step 2*
    mounted at `/var/www/html/wp-content`. For the configuration of WordPress, do
    not forget to set the `WORDPRESS_DB_HOST`, `WORDPRESS_DB_USER`, `WORDPRESS_DB_PASSWORD`,
    and `WORDPRESS_DB_NAME` environment variables in accordance with *Step 3*. In
    addition, you need to publish port `80` to port `8080`, reachable from the browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should have the `wordpress` and `mysql` containers running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.15: The WordPress and database containers'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15021_15_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.15: The WordPress and database containers'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, you should be able to reach the WordPress setup screen in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.16: WordPress setup screen'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15021_15_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.16: WordPress setup screen'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found via [this link](B15021_Solution_Final_SMP.xhtml#_idTextAnchor359).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focused on extending Docker with plugins. Docker operations can
    be enhanced by custom storage, network, or authorization methods by installing
    and using the Docker plugins. You first considered plugin management in Docker
    and the plugin API. With the plugin API, you are free to extend Docker by writing
    new plugins and make Docker work for you.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter then covered authorization plugins and how the Docker daemon is
    configured to work with the plugins. If you are using Docker in production or
    enterprise environments, authorization plugins are essential tools to control
    who can access your containers. You then explored network plugins and how they
    extend communication between containers.
  prefs: []
  type: TYPE_NORMAL
- en: Although basic networking is already covered by Docker, we looked at how networking
    plugins are the gateway to new networking capabilities. This led to the final
    section, in which volume plugins were presented to show how custom storage options
    are enabled in Docker. If your business environment or technology stack requires
    you to extend Docker's capabilities, it is essential to learn the plugins and
    how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: The end of this chapter also brings us to the end of this book. You began this
    journey all the way back in the first chapter learning the basics of Docker and
    running your very first containers on your system and look at how far you have
    come. Just in the course of this book, you have worked with Dockerfiles to create
    your images and learned how to publish these images using a public repository
    such as Docker Hub or to store your images on a repository running on your system.
    You have learned to use multi-stage Dockerfiles and implement your services using
    docker-compose. You have even mastered the finer details of networking and container
    storage, as well as the implementation of CI/CD pipelines as part of your projects
    and testing as part of your Docker image builds.
  prefs: []
  type: TYPE_NORMAL
- en: You practiced orchestrating your Docker environments using applications such
    as Docker Swarm and Kubernetes, before taking a closer look at Docker security
    and container best practices. Your journey then continued with real-world monitoring
    of your service metrics and container logs, before finishing up with Docker plugins
    to help extend your container service functionality. We've covered a lot of work
    to improve your skills and knowledge of Docker. Hopefully, it has taken your experience
    with the application to the next level. Please refer to the interactive version
    to learn how to troubleshoot and report issues when things do go wrong. You will
    also get to know about the current state of Docker Enterprise and the next big
    moves that will be made when it comes to the usage and development of Docker.
  prefs: []
  type: TYPE_NORMAL
