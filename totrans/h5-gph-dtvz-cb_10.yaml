- en: Chapter 10. Maps in Action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting a Twitter feed to a Google map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an advanced interactive marker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding multiple tweets into an InfoWindow bubble
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing the look and feel of markers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Final project: building a live itinerary'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter on mapping, we will tie in more deeply to our topic of data
    visualization. One of the most popular ways to visualize data these days is by
    using maps. In this chapter, we will explore a few ideas on how to integrate data
    into maps, using the Google Maps platform.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting a Twitter feed to a Google map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the start of a very fun experiment with Google Maps. The goal of the
    task is to create a link between Twitter posts and a Google map. It will take
    us a few recipes to get to our final goal. By the end of this recipe, we will
    have a Google map. This Google map will be clickable in any area of the screen.
    When the user clicks on the map, they will connect to the Twitter API and search
    for tweets in that area that have the word "HTML5" in them. When the result comes
    back, it will pop a new marker onto the area that was clicked and add the most
    recent tweet on that topic originating from that location. At this stage, it would
    just be a marker with a rollover that shows us the actual tweet without more information.
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting a Twitter feed to a Google map](img/3707OT_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you haven't read through [Chapter 9](ch09.html "Chapter 9. Using Google Maps"),
    *Using Google Maps*, you might find this chapter a little difficult, so I encourage
    you to read it before starting with this recipe. At this stage you should have
    a Google API set up (see the *Obtaining a Google API key* recipe in [Chapter 9](ch09.html
    "Chapter 9. Using Google Maps")).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create new HTML and JavaScript files and call them `10.01.socielmap.html`
    and `10.01.socielmap.js`, respectively, and then perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code in the HTML file using your own API key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let's move into the JavaScript file. As we have an `init()` function being called
    when the `onload` event triggers, we will place all of our code within a new `init`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We will start by setting our center point of the map. So far, we were extremely
    focused on my home state, New York, so let's change our focus to Europe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's create a black-and-white style for our map so it's easier to focus
    on the markers we are about to create.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Create a new Google map.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Set up the `grayStyle` styling object to be our default style.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Our next step is going to use Google's API to create a new `click` event for
    the map. When the map is clicked we want to trigger a `listener` function. When
    a click happens, we want to start our Twitter search as we will connect to the
    Twitter API and search for the submission of the keyword `html5` within a 50 kilometer
    radius from where our click on the map was. Let's create a new mouse event and
    start up the Twitter search.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When the Twitter search value is returned, it is time to show our new tweet;
    if no tweet is found, we will put in default content letting the user know that
    nothing could be found.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When you load the map again, you will find a map of Europe waiting to be clicked
    on. Each click will trigger a new Twitter search and will generate a new result
    based on the location you clicked on. To read the tweet, roll over the marker
    after it returns.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We live in an age when data about almost anything increasingly overlaps with
    geolocation data and maps. It's almost impossible to write a book about data without
    talking about maps, and it's not possible to write a book about data visualization
    without at least opening the Pandora's box of the world of mapping and its possibilities,
    either.
  prefs: []
  type: TYPE_NORMAL
- en: Twitter lately has been trying more and more to capture the location of users.
    For most of the time, the location is still void. That having been said, Twitter
    always knows the base location of users based on their information, and more so
    when users tweet through their cell phones. As such, Twitter always has a rough
    idea of where users are when they send a message, and in the coming years this
    accuracy is expected to only get better. In the future, more and more Twitter
    results will have such an accurate location for users that we will be able to
    pinpoint them directly on a map.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating the map, the first step is that, as soon as a user clicks on
    any area of the map, we start building out a search query to be used on the Twitter
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We don''t cover all the possibilities with search, but instead we are focusing
    on two main points: the search query, in our case HTML5, and the location of the
    query. We get the location information directly from the event that is passed
    into a marker. We reformat the information from our Google returned event and
    format it into a string, adding to it the range; in our case we set this to 50
    kilometers (you can choose `ml` for miles as well). As we are taking a look at
    the map of Europe now, I thought it would be appropriate to work in kilometers
    and not miles.'
  prefs: []
  type: TYPE_NORMAL
- en: We want to get our search values back as **JavaScript Object Notation** (**JSON**)
    values. JSON is a very minimal shorthand way to pass object information as strings
    between servers. For the most part, you will usually work with automatic converters
    so you will be sending objects and getting objects, but under the hood there is
    a JSON encoder and decoder that will process the request.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you don't know what JSON is, don't worry about it; it's all done in the background
    and it's not critical to understand how JSON works in order to work with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to get our data in JSON format; to do that we will send our URL parameters
    to the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://search.twitter.com/search.json](http://search.twitter.com/search.json)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Append to it our `q` values and `geocode` values. If you want to explore options
    and possibilities with the Twitter search API more deeply, visit the following
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://dev.twitter.com/docs/api/1/get/search](https://dev.twitter.com/docs/api/1/get/search)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to send our information to this service and get our results
    back. To do that, we will use the `$.getJSON` function in jQuery. This function
    will take care of all our needs: sending our request, getting it back, and then
    decoding the information into a regular JavaScript object.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The two parameters we need to send in are the search link and the return function.
    In our case, we will grab our data and send it to an external function, `showTweet`.
    We will send only the first result from the data to return and the `e.latLng`
    object information we got from our click event.
  prefs: []
  type: TYPE_NORMAL
- en: Time to create the marker. In the `showTweet` function, our first task will
    be to check whether there is actually any data in the returned first element.
    If there is no value it means Twitter didn't find anything.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If no object was returned, we will create a new object with placeholder information
    to replace the regular result information. This is a great way to avoid complexities
    in your code: by building the exceptions into the regular user experience. We
    are done; all that is left is for us to create the marker.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Although we got what we had our minds set on, the `latLng` information we have
    is for our click and not the exact location of our tweet. Currently there is a
    property called geo that is returned in the object returned from Twitter. At the
    time of writing this book, it always comes back empty. Currently it looks like
    it's a feature that is about to be released or is partially implemented, so by
    the time you read this book try to check and see if there is a value being returned
    from the `obj.geo` property and use it to make your point more accurate when this
    information is available.
  prefs: []
  type: TYPE_NORMAL
- en: Building an advanced interactive marker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step in our social map project is to add more details for our Twitter
    search result. We would like to open up an information panel automatically when
    the Twitter result comes in. In the process, we will create a subclass of Google
    Marker and extend it and add a new InfoWindow to enable us to add live HTML data
    right into our map.
  prefs: []
  type: TYPE_NORMAL
- en: '![Building an advanced interactive marker](img/3707OT_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It will be really hard to join in, if you haven't started from the start of
    this chapter. As this recipe is in continuation of the previous recipe, we will
    not create a new HTML file or a new JavaScript file but will instead continue
    from where we left off.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Grab your latest JavaScript file and let''s continue to the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the function `showTweet`, replace the new marker with a new `TwitterMarker`
    marker.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now that we are not using the regular built-in marker, it's time for us to create
    our own marker. Let's start with the constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We will want to extend our new object from the `google.maps.Marker` marker so
    we can have all the features of the regular marker.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a toggle button in our marker event listener. When the event
    is called, it will open or close our InfoWindow:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: It is time to create the Twitter message by creating an HTML string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If you reload your HTML file, you will find it interactive in any area of the
    world; if it can find a tweet, it will output it on the map within an InfoWindow.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although there are not many lines, a lot of logic is condensed into this code.
    Let's start by looking at our new marker. This is the first time in this book
    that we use inheritance. Inheritance, as its name implies, enables us to extend
    the features of an object in JavaScript without affecting the original object.
    In our case, we want to take all the features of the marker (methods, properties,
    and so on) and add to them some custom behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: The inheritance is done in JavaScript by defining a prototype. Until now, we
    have used the prototype without talking about it much, but we used it mainly to
    create new methods. If we assign a full object to the prototype, all of the properties
    and methods of that object will be copied into our new object as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Always start first with extending of the object you want to extend, before any
    other additions. This is because if you've placed any new prototype methods before
    this line of code, they will silently be deleted and thus will not work.
  prefs: []
  type: TYPE_NORMAL
- en: The `buildTwitterHTML` method takes in the Twitter object returned and converts
    some of its data into HTML. We use this method once per marker. When we create
    a new marker, we create a new `InfoWindow` object as well. We place an InfoWindow
    on top of the marker and showcase the tweet information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We are setting the width as well, to avoid having a really big panel. We send
    our newly created `strTweet` string into the `infoWindow` object.
  prefs: []
  type: TYPE_NORMAL
- en: We wanted our marker to be a toggle button that controls the InfoWindow status.
    To do that we add a newly dynamically created property called `isOpen`. Even though
    we open up the InfoWindow earlier in the constructor, we don't set the value of
    `isOpen` there. We can fix that issue in the first action we perform in our click
    event listener of the marker.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When the marker is clicked, we automatically change the state of the `isOpen`
    variable. As it was not set before, it will now be set to `true`. The `!` operator
    is a `boolean` operator that switches a value between `true` and `false`. Its
    actual meaning is `not`. In other words, we are saying:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The interesting fact here is that undefined (the value of a variable that wasn't
    defined) for the not (`!`) operator is the same as `false`, `null`, or even `0`.
    Any other value would be considered true. This way, each time the marker is clicked,
    the value of the variable `this.isOpen` switches. And *that* is the heart of the
    logic of our toggle button. All that is left is to decide whether to open or close
    the InfoWindow.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This leads us to our final step of figuring out what will be our Twitter text.
    We will edit this method in the next few recipes. You can play around with it
    and ideally personalize it to what you prefer it to look like. We have two possible
    outcomes: *no Twitter messages in the search area* and *Twitter messages in the
    search area*. If there is a message, we will use some of the returned object properties
    to build up an HTML outline that will be used inside the `infoWindow` object that
    is associated with this marker. If there isn''t a result, we will create one.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: There you go! Our social map is starting to be much more interesting. It still
    is missing some features. It would be really nice if we could see more than one
    message in the InfoWindow result. In the next recipe we will try to solve that
    issue.
  prefs: []
  type: TYPE_NORMAL
- en: Adding multiple tweets into an InfoWindow bubble
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, in our interactive social map, we added markers in each location that
    we clicked on and opened up an InfoWindow with the tweet information. Our next
    step will be to enable multiple tweets to live inside our InfoWindow by adding
    a pagination system into our window.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding multiple tweets into an InfoWindow bubble](img/3707OT_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get through this recipe you must be knee deep into our holistic chapter.
    If you dropped in just now, it would be a good idea to go back to the start of
    this chapter as we are going to continue from where we left off in the previous
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are still in our JavaScript file and we will continue to add code and adjust
    our code to get multiple Twitter posts into our social map.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by changing our Twitter search to return up to 100 values per search.
    We are doing this because there is a limit on how many times we can call the Twitter
    API. So, we will try to grab as much as we can in one hit (this code should be
    around line 30).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As we are now going to treat all the tweets that come back, we will need to
    change our references to send to our `TwitterMaker` marker the full array (changes
    highlighted in the code snippet).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We want to update the `TwitterMarker` constructor to include our array and quick
    information on it, such as the total tweets and the current tweet we are in. We
    will need a way to identify our object, and as such, we will give it an ID as
    well (more on that in a few steps).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to store, in a static array that can be accessed from any place in
    our code, all the markers created. To do that, we will add a new status array
    to our `TwitterMarker` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `buildTwitterHTML` method, we want to add in back/next links that will
    be visible to users from InfoWindow:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Let's now add the `next` and `prev` methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Load the HTML file, and you should find a working InfoWindow that can accommodate
    up to 100 tweets per click.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our first change was to change the number of results coming back from the Twitter
    search API. This change forced us to change the references in our code from referring
    directly to the first object returned to focus on the full results object and
    sending it to our `TwitterMarker` constructor. This change created a few smaller
    changes in the flow of the information within the constructor as well.
  prefs: []
  type: TYPE_NORMAL
- en: Our goals are to create two buttons that will update our InfoWindow. This is
    an issue as we need a two-way connection between our marker and its InfoWindow.
    Until now, all our communication with the InfoWindow was one way. The easiest
    way for us to solve this problem and bypass the Google interface is to create
    a static array that will store all markers and refer to our static marker when
    we trigger buttons inside the `InfoWindow` object. All we need to do is add a
    variable direction to our class name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: By adding our variable directly into the `TwitterMarker` class, we can now refer
    to it directly at any point and it will not get duplicated in our objects (as
    it's not part of the prototype). Now that we have an array, it's time for us to
    go back into our `TwitterMarker` constructor and send a new reference to this
    array each time we create a new `TwitterMarker` object. Another benefit we get
    out of doing this is that we automatically get a unique identifier (ID) for each
    marker as the returned number will always be a unique number for our needs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this one line of code, we perform all of the tasks we talked about in the
    previous paragraph. The array `push` method returns the new length of the array.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to refer to our marker and have got an identifier, it's
    time for us to go back into the `buildTwitterHTML` method and add into the rendered
    HTML two `href` buttons that will trigger the right marker when the next/previous
    selections are clicked.
  prefs: []
  type: TYPE_NORMAL
- en: Before we delve into that, we want to check and validate that we have more than
    one Twitter message that came back; if there is none, there is no point in adding
    the new logic, and we would be introducing a bug if we had next/previous logic
    for an item that has only one item.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'By the following `if` statement, we figure out whether we are currently in
    the first Twitter message, and if not we shall add the back button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This might look like a huge mess but, if we ignore the HTML and focus on the
    actual JavaScript that will be triggered when the button is pressed, this is what
    we will get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `this.id-1` parameter will be replaced with the actual current number:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As this is rendered into a string to be parsed as HTML, the value that will
    be integrated into the HTML will be hardcoded. Let''s see this in a real case
    to make it clear. The first array ID would be `0`, and as such the `prev` button
    would look like this code statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now the logic is starting to reveal itself. By grabbing the marker from the
    array that is our current element, all that is left for us to do is trigger the
    `prev` method and let it take over.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same logic happens for our other end. The only condition is that we are
    not in the last Twitter result and if not we call the `next` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: There you have it! The core of our logic is in place.
  prefs: []
  type: TYPE_NORMAL
- en: If we wanted we could have created our InfoWindow by wrapping a `<div>` tag
    with a unique ID and just called it and made direct updates to our content (try
    doing that by yourself as that would be a better solution). Instead, we are working
    with the limitations of the InfoWindow. As we cannot update the full bucket container
    while it's open, we need to close it to update it and then open it again. Thus
    our logic in both the `next` and `prev` methods is similar; both have a limitation
    on the change of the actual value that is being rendered.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: All the logic is the same and limited to the highlighted code snippet. If you
    aren't familiar with this shortcut, the `++` and `--` operators when set before
    a variable, enable us to add/subtract 1 from it and update it before its value
    is sent on. Thus in one line, we can both change the number in the variable and
    send that newly created number to continue its tasks.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the `next` method, we want to grab the next tweet, while for
    the `prev` method, we want to grab the previous tweet.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the look and feel of markers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This will be our last recipe for social mapping. In this recipe, we will revisit
    our marker itself and give it a facelift. As our marker represents Twitter messages
    in a clicked area, we will update our marker to look like a Twitter bird (hand
    made). We will not stop there; after updating our graphic, we will add another
    graphical layer to shadow our Twitter marker. It will be a shadow, and its opacity
    will range from zero to full, depending on the number of tweets (a maximum of
    hundred tweets).
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way to understand our goal is by checking out the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing the look and feel of markers](img/3707OT_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note how some tweets have no visible circle outline, while others have a very
    dark one (that is based on how many tweets are there).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this task you need to first complete all the previous recipes in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will jump right into the JavaScript file and continue from where we left
    off in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Update the `showTweet` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Create an instance of the `MarkerCounter` object in the `TweeterMarker` constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Create the `MarkerCounter` constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Create subclass, `MarkerCounter`, for the `google.maps.OverlayView` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Create an `onAdd` method. It will be called automatically when an element is
    added into the map. In this method, we will finish up all the preparatory work
    for the drawing but won't draw the elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Last but not least, it's time to override the `draw` method and draw into the
    new canvas element created in the previous step and position the `div` element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: When you run the application, you will find that now our markers look like those
    of Twitter and the larger the number of tweets that originate from a location,
    the more opaque the egg under our Twitter bird will be.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step is to swap the graphic that is the default graphic for the marker.
    As we are extending the regular marker, we have all of its default features and
    behaviors. One of these features is the ability to swap the icon. To do that,
    we pass in one of our object parameters as the icon and its path.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You might be wondering how this actually works, as we are not actually doing
    anything to the icon parameter in our code. It''s very simple. If you take a deeper
    look at the `TwitterMaker` constructor, you will find the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Passing the `setValues` method to the `opt` object is our way of letting the
    marker continue and rendering our marker with the information we just got into
    our constructor. All the things that can be done in a regular marker can be done
    in ours as well.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage we have our Twitter bird as our graphic interface for our marker.
    Unfortunately, this is as far as we can go with customizing our marker; next,
    we will need to add another visual layer. As we want to create a visual layer
    that behaves like a marker just visually (as it will be part of the marker), we
    will need to create a subclass for the `google.maps.OverlayView` object.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the marker logic, when we are ready to render our element, we want
    to call the method `setMap` (for the marker it was a different method but the
    same idea).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In our constructor, we are only storing very basic global information, such
    as our target opacity, radius, and the `options` object. We can store any information
    we want here. The most important element of information that we will need is the
    position (latitude and longitude). We will send that information into our marker,
    and it will be inside our `opt` object.
  prefs: []
  type: TYPE_NORMAL
- en: The `google.maps.OverlayView` object has an `onAdd` method. It's just like a
    listener, but in addition, we will override this method and add our processing/preparation
    work when the element is added into the map.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Most of the logic here should look familiar. We start by creating a new `div`
    element. We set its CSS attributes to make absolute the position of the `div`
    element so we can move it around easily. We follow this with creating a canvas
    element and setting its width and height to be two times the radius of our circle.
    We add the canvas into our `div` element. Last but not least it's time for us
    to add our `div` element into the map. We will do that by accessing the `getPanes`
    method. This method will return all the visual layers this element can contain.
    In our case, we will go right to our overlay layer and add our `div` element to
    it. We do this inside the `onAdd` method rather than doing it earlier because
    the overlay will not be rendered and we will not have access to the last two lines
    in the previous code.
  prefs: []
  type: TYPE_NORMAL
- en: Just as we overrode the `onAdd` method, we do the same for the `draw` method.
    This is our last critical step. For the most part, all the work in this method
    will be very familiar as we have played a lot with canvas in this book. So, let's
    explore the new steps to find where we want to position our overlay.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In the first line in the preceding code, we get the projection. The projection
    is the relative point of view of our overlay. Through this projection, we can
    extract the actual point in pixels. We call the `projection.fromLatLngToDivPixel`
    method, send to it a latitude/longitude object, and get back a point (`x`, `y`
    values). All that is left is to update the style of our `div` element and position
    it according to this information (not forgetting to subtract our radius size so
    our element is exactly in the middle of the actual point that was clicked).
  prefs: []
  type: TYPE_NORMAL
- en: Until now, we have treated our `TwitterMarker` constructor as if there are always
    tweets somewhere in the world, but the reality is that sometimes there will not
    be anything, and right now we are creating both a visualization that won't work
    and a marker that won't visualize it. Let's override our behaviors and put up
    an alternative marker if there is no result and skip all of our customizations.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/3707OT_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's sort it out. We start by removing our original error logic from the `showTweet`
    method. Instead, we will just update the `text` attribute but will not create
    a new array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In case you are not familiar with the ternary operator, it''s a very condensed
    way of creating an `if...else` statement within code. The core logic of it is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The outcome is then sent back, and we can capture it right into our variable
    as we are doing in this case.
  prefs: []
  type: TYPE_NORMAL
- en: The next area we want to change is the `TwitterMarker` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The main changes here are that we start our application by first checking if
    there are any tweets. If no tweets are around, we update the icon graphic to a
    new **X** icon. If we do have a result, all remains the same. We extracted the
    `setValues` method to be called out of the `if...else` conditions as we need to
    call it in any case.
  prefs: []
  type: TYPE_NORMAL
- en: There you go! We've completed our social map. There is much more you can do
    with this project. A couple of examples could be making it easier to change the
    search term, and comparing between two search results (that could be very interesting
    and easy). I would be interested to see around the world the number of times Flash
    versus HTML5 are mentioned, so if you get to it send me an e-mail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Final project: building a live itinerary'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although the natural next step from our previous sample would be just to add
    an extra feature to our already growing social map (which we have built throughout
    this chapter), we are taking a direction shift.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our final recipe, we will build an interactive Google map that will animate
    with the travel information of a close friend of mine in South America while I
    was working on this book. To build this application, we will animate the map by
    adding drawings and moving markers; we will integrate with an external feed of
    travel information and integrate animations and text snippets that will describe
    the journey. In the following screenshot, you can see a very small snapshot of
    the plain path:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Final project: building a live itinerary](img/3707OT_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many of the elements we will be working with in this recipe will be based on
    work we did throughout all of the chapters. As such, it will not be easy to just
    jump right in if you haven't gone through the journey together with us. There
    are no prerequisites. We will start from scratch, but we will not focus on things
    we have learned already.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the user "travels" around the world map when there is a message for the
    user in the data source, the map will fade out and the message will be displayed
    before the user can continue traveling the world:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/3707OT_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe we will be creating two files: an HTML file and a JavaScript
    file. Let''s look into them, starting with the HTML file:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the HTML file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Time to move to the JavaScript file, `10.05.travel.js`. We will start by initiating
    the visualization library and storing a global map variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'var map;     When the `init` function is triggered, the map is loaded and it triggers the loading
    of a Google spreadsheet in which we will store all of my friend''s travel information.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: When the document is loaded, it will trigger the `onTripDataReady` listener.
    When that happens, we will want to create a new `GoogleMapTraveler` object (a
    custom class for managing our experience).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The constructor method of the `GoogleMapTraveler` object will prepare our variables,
    create a new `Animator` object, a `Traveler` object and a new `google.maps.Polyline`
    object, and will trigger the creation of the first travel point by calling the
    `nextPathPoint` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `getPosition` method is a very smart, small method that enables us to create
    a new `google.maps.LatLng` object each time it's called and to create a point
    based on an average of points or based on one item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We want to be able to set the position of our traveler, and as such we will
    want to create a `setPosition` method as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In the heart of our application is the ability to automatically move from one
    step to the next. This logic is applied using our `Animator` object in combination
    with the `nextPathPoint` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: There are two callbacks that are triggered through our `Animator` object (they're
    highlighted in the preceding code snippet). It is time to create the logic that
    updates the information on our `onUpdate` callback. Let's take a peek at the `renderLine`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In the next step, when the animation is complete, it triggers our overlay logic.
    The overlay logic is very simple; if there is text in the Google document, in
    the fifth column, we will darken the screen and type it out. If there is no text,
    we will skip this step and go right to the next step that is in the `hideOverlayCopy`
    method that triggers the next travel point (the next line in the spreadsheet).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our previous method of the `GoogleMapTraveler` object is the `bind` method.
    We already created this `bind` method in the *Moving to an OOP perspective* recipe
    in [Chapter 6](ch06.html "Chapter 6. Bringing Static Things to Life"), *Bringing
    Static Things to Life*; as such, we will not elaborate on it further.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Create the `Traveler` class. The `Traveler` class will be based on the work
    we did in the *Customizing the look and feel of markers* recipe in this chapter,
    only this time it will be an animating marker.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We will grab the `Animator` class created in the *Animating independent layers*
    recipe in [Chapter 6](ch06.html "Chapter 6. Bringing Static Things to Life"),
    *Bringing Static Things to Life*, and tweak it (changes are highlighted in the
    code snippet).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: When you load the HTML file, you will find a fullscreen map that is getting
    its directions from a spreadsheet. It will animate and show you the paths my friend
    took as he traveled from Israel to South America and back.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many components in this example, but we will focus mainly on the new
    steps that we haven't covered in any other part of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first new thing we meet is right in our HTML and CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: We picked a font from the Google font library at [http://www.google.com/webfonts](http://www.google.com/webfonts)
    and integrated it into the text overlays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: It is time to travel into our JavaScript file, which we start by loading in
    the Google Visualization Library. It's the same library we were working with in
    [Chapter 8](ch08.html "Chapter 8. Playing with Google Charts"), *Playing with
    Google Charts*. Once it's loaded, the `init` function is triggered. The `init`
    function starts our map up and starts loading in the spreadsheet.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Changing data source to Google spreadsheet* recipe in [Chapter 8](ch08.html
    "Chapter 8. Playing with Google Charts"), *Playing with Google Charts*, we worked
    with Google spreadsheets for the first time. There you learned all the steps involved
    with preparing and adding a Google chart into the Google visualization. In our
    case, we created a chart that contains line by line all the areas through which
    my friend traveled.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/3707OT_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The exception in this case is that we don''t want to feed our URL into a Google
    chart, but instead we want to work with it directly. To do that we will use one
    of Google''s API interfaces, the `google.visualization.Query` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to create our `GoogleMapTraveler` object. The Google map traveler
    is a new way for us to work with Google Maps. It doesn't extend any built-in feature
    of Google maps but is instead a hub for all the other ideas we created in the
    past. It is used as a manager hub for the marker, called Traveler, that we will
    create soon and the `google.maps.Polyline` object that enables us to draw lines
    on the map.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of having a very static line appearance, let's create a reveal effect
    for new lines that are added to the Google map. To achieve that, we need a way
    to update the polyline every few milliseconds to create an animation. From the
    get go, I know the start point and the destination point as I get that information
    from the Google spreadsheet created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is very simple even though in a very complex ecosystem. The idea is
    to have an array that will store all the latitude/longitude points. This would
    then be fed into the `this.line` object every time we wanted to update our screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The heart of the logic in this application is stored within this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: It will start a recursive journey throughout all of the points in our chart.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take a deeper look at the logic behind the `GoogleMapTraveler.prototype.nextPathPoint`
    method. The first thing we do in this function is to set our map view.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The `setPosition` method does a few things that are all related to repositioning
    our map and our zoom level based on the data in the current index that is sent.
    It's a bit smarter than that as it takes in a second parameter that enables it
    to average out two points. As one travels between two points, it would be best
    if our map is at the center of the two points. That is done by sending in `2`
    as the second parameter. The internal logic of the `setPosition` method is simple.
    It will loop through as many items as it needs to, to average out the right location.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add a new point to our `this.pathPoints` array. We start by duplicating
    the same point that is already in the array, as we want our new second point to
    start from the starting point. This way, we can update the last value in our array
    each time, until it reaches the end goal (of the real next point).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: We create a few helper variables. One will point to the new object we just created
    and pushed into our `pathPoints` array. And the second is the point that we want
    to reach at the end of our animation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first variable is not a new object but a reference to the last point created,
    and the second line is a new object.
  prefs: []
  type: TYPE_NORMAL
- en: Our next step will be to start and animate the values of our `currentPoint`
    until it reaches the values in the `point` object and to update our traveler latitude/longitude
    information until it reaches its destination as well. We give a delay of 0.75
    seconds to our second animation to keep things more interesting.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Before we end this method, we want to actually animate our lines. Right now,
    we are animating two objects that are not visual. To start animating our visual
    elements, we will listen to updates till the time we complete the animations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Each time the animation happens, we update the values of our visual elements
    in the `renderLine` method.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid getting runtime errors, we added to the traveler marker an `isReady`
    Boolean to indicate to us when our element is ready to be drawn into.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: When the animation completes, we move to the `showOverlayCopy` method, where
    we take over the screen and animate the copy in the same strategy as we've done
    before. This time around, when we are done with this phase, we will trigger our
    initial function again and start the cycle all over with an updated index.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: That covers the heart of our build. It's time for us to talk briefly about the
    two other classes that will help create this application.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Traveler marker
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will not dig deeply into this class, as for the most part, it's based on
    the work we did in the previous recipe, *Customizing the look and feel of markers*.
    The biggest difference is that we added internal animation to our element and
    an `updatePosition` method that enables us to move our marker around whenever
    we want to move it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: This method gets a latitude and longitude and updates the marker's position.
  prefs: []
  type: TYPE_NORMAL
- en: As we are animating the actual `ll` object of this object in the main class,
    we added a second method, `refreshPosition`, which is called each time the animations
    are updated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: There is more to explore and find in this class, but I'll leave that for you
    to have some fun.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Animator object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We made two major updates to our `Animator` class, which was originally created
    in the *Animating independent layers* recipe in [Chapter 6](ch06.html "Chapter 6. Bringing
    Static Things to Life"), *Bringing Static Things to Life*. The first change was
    integrating callback methods. The idea of a callback is very similar to events.
    Callbacks enable us to call a function when something happens. This way of working
    enables us to only have one listener at a time. To do this, we start by creating
    the two following variables that are our callback functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: We then trigger both functions in the `Animator` class in their relevant location
    (on update or on complete). In our `GoogleMapTraveler` object, we override the
    default functions with functions that are internal to the `GoogleMapTraveler`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Our second and last major update to the `Animator` object is that we added smarter,
    more detailed logic to enable our animator to animate both to positive and negative
    areas. Our original animation didn't accommodate animating latitude/longitude
    values, and as such we tweaked the core animation logic.
  prefs: []
  type: TYPE_NORMAL
- en: This covers the major new things we explored in this recipe. This recipe is
    jam-packed with many other small things we picked up throughout the chapters.
    I truly hope you've enjoyed this journey with me, as this is the end of our book.
    Please feel free to share with me your work and insight. You can find me at [http://02geek.com](http://02geek.com)
    and my e-mail is `<[ben@02geek.com](mailto:ben@02geek.com)>`.
  prefs: []
  type: TYPE_NORMAL
