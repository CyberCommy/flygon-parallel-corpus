- en: Application Performance Optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we focused on how to profile an application to figure
    out the performance issue of an application. We also covered logging, which is
    a useful tool in identifying issues in the application. It was an essential part
    and will be part of our daily routine when we work on Spring applications.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look at what we've got in this chapter. This is a crucial chapter
    in this book; it provides you with ways to improve application performance. In this
    chapter, we will discuss the fundamental approach for application performance
    optimization, which is key for any application, including Spring-based applications.
    We'll discuss Spring's support for **Java Management Extension** (**JMX**), improvements
    in database interactions, and the performance tuning of Spring applications. By
    the end of this chapter, you will be able to identify performance bottlenecks
    in a Spring-based application and resolve them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at important aspects of application performance optimization with
    a structured approach. We''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Performance issue symptoms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance tuning life cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance tuning patterns and anti-patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The iterative performance-tuning process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring support of JMX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance issue symptoms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with performance issue symptoms. This is an obvious place to start,
    as it's like consulting a doctor where symptoms are discussed and then a diagnosis
    is made. Application performance is the behavior experienced by the end users
    in terms of speed, accuracy in delivering the content, and average response times
    under the highest load. The load is referred to by the number of transactions
    processed by the application per unit time. The response times are the times required
    for an application to respond to a user's actions at such a load.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever performance needs an improvement, the first thing that comes to mind
    is the problems that are affecting the performance of our application. To find
    the issues with performance, we need to look for certain symptoms that can lead
    us to the issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some common symptoms that can be observed in a Spring application are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Timeouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running out of worker threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Threads waiting on class loaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A major amount of time spent on loading classes even under normal load
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class loader attempts to load non-existing classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we will understand these symptoms with an example
    context. The details will help us identify the symptom when it occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Timeouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Timeouts occur in two different ways. One is the request timeout, which is represented
    by `HTTP response status code 408`. Another flavor of timeout is the gateway timeout,
    which is represented by `HTTP response status code 504`.
  prefs: []
  type: TYPE_NORMAL
- en: The request timeout indicates that the server did not receive the complete request
    from the client within the specified time. In such a case, the server chose to
    close the connection with the client. The request timeout is an error message
    directly from the server.
  prefs: []
  type: TYPE_NORMAL
- en: The gateway timeout indicates that the gateway or the proxy server timed out
    while processing the request. In most cases, this is because the proxy or gateway
    do not receive a timely response from the actual server in the upstream.
  prefs: []
  type: TYPE_NORMAL
- en: Running out of worker threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider the example of a bank; the bank has a web application with a monitoring
    system on top of it. The monitoring system keeps an eye on the strength of the
    JVMs. The parameters for measurement are memory, CPU, I/O, heap memory, and various
    other attributes. The monitoring system provides distinctive dashboards that show
    and highlight the measurements for the aforementioned attributes. There exists
    an accompanying dashboard that demonstrates the group of activities performed
    in the banking application. This dashboard also identifies the group of activities
    on which the JVM starts running low while accessing specialized application resources,
    such as threads. The application is running in multiple JVM environments. The
    following is a screenshot of a sample dashboard for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c373a988-ca43-4519-83e1-858dba4aa7e3.png)'
  prefs: []
  type: TYPE_IMG
- en: The monitoring system is configured with threshold values. For example, the
    maximum threads utilized by a JVM at a time should be no more than 250\. When
    the JVM is utilizing less than 150 threads at a time, the corresponding JVM indicator
    in the dashboard is green. At the time when the JVM starts utilizing more than
    150 threads, the monitoring system indicates that JVM in red. It is a symptom
    indicating that a failure might occur or that performance is impacted beyond normal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a timeline-based screenshot showing JVMs maxed out of worker
    threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb3eb73b-7e96-45ee-944a-f4820cc2478a.png)'
  prefs: []
  type: TYPE_IMG
- en: Threads waiting on class loaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Continuing with the same example as described in the previous section, the first
    question that arises is, what is wrong with these threads? Taking a deeper look
    into the threads and breaking down the state, it was discerned that these threads
    (approximately 242 out of 250) were looking out for the server's `CompoundClassLoader`.
    These threads were stacking extra objects and that's what they were looking out
    for the class loader. Because of the high number of threads endeavoring to get
    to that common asset—the class loader—most threads got stuck in pause.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot from the monitoring shows the number of threads waiting
    for `CompoundClassLoader`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/deab9529-89de-4cb5-acf7-2a91ed0379f6.png)'
  prefs: []
  type: TYPE_IMG
- en: Time spent on class-loading activities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another thing that came out of the analysis in the monitoring system is that
    threads spend most of their time on class-loading activities. The following is
    the monitoring system screenshot highlighting this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc724071-fc1d-43cc-8a32-b241274c1ab0.png)'
  prefs: []
  type: TYPE_IMG
- en: Looking at the previous screenshot of the monitoring system, it is clear that
    regardless of the current load, the class-loading activities take considerable
    time compared to other activities in a request-processing life cycle. This is
    an indication or symptom of a performance problem as it increases the overall
    response time. In the case of a bank, it could be confirmed by evaluating average
    response times.
  prefs: []
  type: TYPE_NORMAL
- en: Class loader trying to load non-existent classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One question arises: Is the class stacking extremely important? Digging deeper
    and looking at the requests processed, it demonstrated that each request tried
    to stack a class that did not exist. The application server was prompting a huge
    amount of the `ClassNotFoundException` class. The main driver of the issue is
    that the class could never be effectively stacked, but the application server
    continued attempting to stack it for each request. This should not be a problem
    for quick and moderate requests and features. This level of detail for each incoming
    request or feature may clutch the rare asset—the class loader—and, accordingly,
    affect the response time for requests.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ability, adaptability, and capacity of the monitoring system is to catch
    each and every request and response with the data on stacking classes to help
    recognize the symptoms. The following screenshot displays one such scenario in
    the application framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9881ec25-1c27-499d-bd7a-158e8cf8ba1d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The symptoms of a potential performance issue must be clear by now. It is specifically
    applicable to any JVM-based web application, not only a Spring-based web application.
    The following screenshot shows us the pointers that would basically help us identify
    the impact of performance issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c99527f-9e1b-4148-9ea7-f400f5f6c078.png)'
  prefs: []
  type: TYPE_IMG
- en: Poorly performing applications matter a lot to businesses, as they have seen
    dips in sales because of application performance. An application can also notice
    productivity or business loss because of performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand the business impact of performance issues with a basic illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9425db8d-afef-400b-8c3a-f2d273f73661.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can understand from the previous diagram, bad application behavior can
    impact business, which can be described in either high project costs, a decrease
    in conversion ratios, fewer repeat visits and poor customer retention, a decline
    in sales, a decline in productivity, losing customers, increases in project cost,
    and delays or declines in profit and returns on investments. Performance matters
    a lot to businesses.
  prefs: []
  type: TYPE_NORMAL
- en: What do we need to do to avoid or address performance issues? Don't wait for
    performance issues to occur. Get architecture, design, and code reviewed, and
    plan out for load testing, tuning, and benchmarking in advance. Today, in the
    world of competitive marketing, an organization's key point is to have their system
    up and running with the best performance. Any failure or downtime directly impacts
    the business and revenue; performance of an application is a factor that cannot
    be overlooked. Day by day, the mountain of data is growing because of the extensive
    use of technology in numerous ways. Due to this, the load average is going through
    the roof. For some cases, it cannot be assured that data will not exceed the limit
    or the number of users will not go out of bounds.
  prefs: []
  type: TYPE_NORMAL
- en: At any point, we can meet unexpected demands to scale. For any organization,
    it is very important for its application to provide scalability, performance,
    availability, and security. Application scalability in terms of scaling horizontally
    and vertically by spreading database to cater to different application queries
    across multiple servers, is quite feasible. It is easy to add horsepower to the
    cluster to handle the load. Cluster servers instantly handle failures and manage
    the failover part to keep your system available almost all the time. If one server
    goes down, it will redirect the user's request to another node and perform the
    requested operation. Today, in the world of competitive marketing, an organization's
    key point is to have their system up and running. Any failure or downtime directly
    impacts business and revenue; high availability is a factor that cannot be overlooked.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows us some of the common performance issues that we
    might come across:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f5deff9a-aecd-42c7-85d3-b708660ee1b5.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's move towards the phases of the performance tuning life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Performance tuning life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Speed is at the heart of every business. In this hyper-connected modern world,
    the thing that fascinates the majority of people is speed; be it the fastest car,
    fastest computer processor, or even the fastest website. Website performance has
    become the highest priority of each and every business. User's expectations are
    higher than ever. If your website doesn't respond instantly, there are high chances
    that your users will switch to your competitors.
  prefs: []
  type: TYPE_NORMAL
- en: A study by Walmart ([https://www.slideshare.net/devonauerswald/walmart-pagespeedslide](https://www.slideshare.net/devonauerswald/walmart-pagespeedslide))
    found that for every 1 second of page performance improvement, there's a 2% increase
    in conversions.
  prefs: []
  type: TYPE_NORMAL
- en: 'A study by Akamai ([https://www.akamai.com/us/en/about/news/](https://www.akamai.com/us/en/about/news/))
    found that:'
  prefs: []
  type: TYPE_NORMAL
- en: 47% of people expect a web page to load in two seconds or fewer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 40% will abandon a web page if it takes more than three seconds to load
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 52% of online shoppers say quick page loads are important for their loyalty
    to a site
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In 2007, Amazon reported that for every 100-millisecond increase in the load
    time of Amazon ([https://www.amazon.com/](https://www.amazon.com/)), their sales
    decreased by 1%.
  prefs: []
  type: TYPE_NORMAL
- en: 'With help of the following figure, we can easily understand the different phases
    of the life cycle of performance tuning:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d791f68-7d97-47f3-a077-4fc430654185.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In most of these cases, performance issues can be avoided by reviewing the
    following artifacts at the right time:'
  prefs: []
  type: TYPE_NORMAL
- en: Architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Engage expert consultants to perform application reviews at the right time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Engage any time before the development phase is completed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is strongly recommended to identify performance optimization issues beforehand,
    which can start before the completion of the architecture phase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's always better to prevent performance issues before making applications
    available to users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conduct various reviews and tests to avoid performance issues in production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The performance tuning life cycle can also be done after going to production
    or when facing performance issues in the production environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to tune the performance of a Spring application, the strategies described
    in the following sections can be pretty handy.
  prefs: []
  type: TYPE_NORMAL
- en: Connection pooling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Connection pooling** is a strategy to help an application''s execution where
    *N* connections with the database are opened and overseen in a pool. The application
    just requests a connection, utilizes it, and afterward drops it back to the pool.
    At the point when the application requests a connection, the prepared connections
    are kept accessible to be utilized as part of the pool. The pool deals with the
    connection life cycle to such an extent that the developer really doesn''t have
    to sit tight for the connection and shift through the stale ones.'
  prefs: []
  type: TYPE_NORMAL
- en: Hibernate uses its magic to identify which connection pool provider to use—based
    on the properties you configure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the properties configuration for the c3p0 connection pooling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the example connection pooling properties configuration for
    the Apache Commons DBCP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When using either of the connection pooling mechanisms, we have to place the
    JAR dependencies in the server classpath manually or by using a dependency management
    tool such as Maven.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to specify the connection provider explicitly with the `hibernate.connection.provider_class` property,
    though it is not mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we do not configure a connection pool with Hibernate, the default is used. It
    is visible in the log or console output when we start the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The default connection pool of Hibernate is a good option for the development
    environment, but when it comes to production, it is recommended to configure the
    pool based on the requirements and the use cases.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using an application server, you may wish to use the built-in pool
    (typically, a connection is obtained using the **Java Naming and Directory Interface**
    (**JNDI**)).
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the server''s built-in pool with Hibernate session using JNDI configuration,
    we need to set the following property in the Hibernate configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It is assumed that `AB_DB` is the JNDI name of the Tomcat JDBC Connection Pool
    `DataSource`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you cannot or do not wish to use your application server''s built-in connection
    pool, Hibernate supports several other connection pools, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: c3p0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proxool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After Apache DBCP, the second most preferred connection pool implementation
    is c3p0, which easily integrates with Hibernate, and is said to deliver good performance.
  prefs: []
  type: TYPE_NORMAL
- en: Hibernate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The connection pooling mechanism ensures that the application does not run out
    of database connections when it needs one badly. Hibernate is one of the finest
    ORM frameworks for Java-based applications. When used, it must be tuned for performance
    optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Transaction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hibernate does the grimy checking just when it needs to, to keep in mind the
    execution cost. The cost increments when a specific substance has a relating table
    with an expansive number of segments. To try and limit the filthy checking cost,
    it's better we help Spring by determining an exchange to be perused, which enhances
    the execution stunningly better, wiping out the requirement for any grimy checks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example use of the `@Transactional` annotation, which indicates
    that the method runs within the Hibernate transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Periodical clearing of Hibernate sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While including/adjusting information in the database, Hibernate maintains sessions.
    In the session, it stores a form of the instances which are to be held on. If
    these instances or records are altered or modified before the session is closed,
    it is known as **filthy checking. ** Nonetheless, we can keep Hibernate from holding
    the elements in its session longer than really required. So once the requirements
    are done, we will not have to keep the instances in the session any longer. For
    this situation, we can securely flush and clear the `EntityManager` to adjust
    the condition of elements in the database and expel the instances from the session.
    This will keep the application far from memory requirements and beyond any doubt
    to affect the execution on a higher side.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a piece of code that can be used to `flush()` and `clear()` the
    Hibernate session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Lazy initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In case you are using Hibernate, you should take care that the `IN` statements
    are used adequately. It lazily loads the records only when it's required. When
    such custom records are loaded into memory inefficiently, every record will be
    stacked independently with separate utilization. Consequently, if there are excessively
    numerous instances loaded in memory, the same number of queries will execute consecutively,
    which may result into a major execution hit.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor-based HQLs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In typical situations, when an application is utilizing Hibernate, we don't
    try to recover the entire substance with every one of its properties despite the
    fact that we need not bother with every one of them for a specific use case. A
    solitary substance may have 30 properties, while we may only need a couple to
    be set in our feature or shown to the client. In such a case, a huge number of
    records are retrieved with the query to the database. It adds up to a significant
    load considering the unused fields sticking with the application, which will eventually
    be a gigantic execution or performance hit.
  prefs: []
  type: TYPE_NORMAL
- en: To manage this, HQL/JPA gives us a select new constructor call, which is frequently
    utilized for detailing inquiries, which also enables the designer to choose collected
    esteems.
  prefs: []
  type: TYPE_NORMAL
- en: Entity and query caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the event that a similar inquiry is conjured each time for a specific element
    and the table information isn't subject to change for a specific availability,
    we can store the question and the elements with Hibernate.
  prefs: []
  type: TYPE_NORMAL
- en: In the event that an inquiry store is connected, at that point, no resulting
    SQL articulation is sent to the database for execution. If the inquiry store or
    first-level cache cannot find the elements based on the identifier, the stored
    element identifiers are utilized to get to Hibernate's second-level store where
    comparing real elements are reserved. This highly affects the reaction time. When
    we do this, we are likewise worried about when the reserve invigorates itself.
    We can do that effortlessly with some basic setups.
  prefs: []
  type: TYPE_NORMAL
- en: Native queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In spite of the fact that the local inquiries have a mishap, they are the fastest
    where execution is concerned. At the point when HQL changes don't resist enhancing
    the execution of your application, local questions can essentially enhance the
    execution by around 40%.
  prefs: []
  type: TYPE_NORMAL
- en: Primary key generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While indicating Hibernate comments into substance classes or composing `.hbm`
    documents, we should abstain from utilizing the auto key age methodology, which
    prompts a gigantic measure of succession calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example code for defining the key generation strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With this simple change, an improvement in the range of 10-20% can be noticed in
    insert-intensive applications, with basically no code changes.
  prefs: []
  type: TYPE_NORMAL
- en: Database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the Hibernate performance optimization life cycle is performed, the next
    step would be to perform an optimization life cycle at a database level. The following
    sections define performance improvement techniques for database components.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lists become an imperative factor if the tables included in the query have a
    large number of columns. Also, it impacts when complex database queries get terminated
    by the application. The most ideal approach to get recommendations on required
    indexes is to check the query execution plan. While analyzing the SQL queries
    for indexing, we must anticipate every one of the genuine queries separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'While working with indexes, it must be noted that:'
  prefs: []
  type: TYPE_NORMAL
- en: Indexes might slow down inserts and updates, so apply them carefully on columns
    that are frequently updated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indexes are meant to speed up search operations that use `WHERE` and `ORDER
    BY` clauses in the query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Database views are another procedure that we explore or think of when we are
    highly encompassed with longer execution time issues. Until SQL Server 2000, views
    were implied only for accommodation, and not speed. Later forms of SQL server
    included an uncommon component called recorded views that is said to monstrously
    expand the execution, however, ordered views must be made utilizing an arrangement
    of rules.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Security is one of the most important aspects for any application, especially
    those running over the internet. While Spring Security provides an application
    with a secure facade and prevents the application from unwanted access, it adds
    up to a lot of overhead if not managed properly. We will focus on Spring Security
    best practices in the sections to follow.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Security execution is one of the worries that occasionally comes into
    the picture, when the demand-handling time is seen to be on the high, and therefore
    inadmissible, side. There may be circumstances where you see that the real demand
    handling takes around 120 milliseconds, while Spring Security validation/verification
    includes another 500-600 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: LDAP custom authorities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This won't be the approach that you would need to consider, yet it does provide
    you with another option to enhance the execution of your Spring Security implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In this approach, we set the user authorities with our own custom usage, as
    opposed to confirming it from LDAP. There are a few good reasons to do this, and
    the application's execution is one of them.
  prefs: []
  type: TYPE_NORMAL
- en: Native LDAP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Security provides us with the most standard and solid usage to LDAP verification.
    With Center Spring LDAP, the approach turns somewhat terrible, yet shows signs
    of streamlined improvements. The last approach (with Center Spring LDAP) has been
    seen to radically enhance the execution of your application when contrasted with
    that of Spring Security. This is not a preferred approach, still we can consider
    it to be one of the options for development.
  prefs: []
  type: TYPE_NORMAL
- en: Multithreading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every application nowadays is multithreaded, meaning it is capable of performing
    multiple operations at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: With every conceivable streamline, the single hits to your application may look
    fulfilling. Be that as it may, the heap tests with a few simultaneous hits to
    your application begin to obstruct your application's execution. In such highly
    simultaneous situations, you may need to tune up the thread defaults on the Tomcat
    server. On the off-chance that there is high simultaneousness, the HTTP asks to
    put it on hold until the point that a thread winds up to process it. In more outrageous
    cases, the hold-up lines hoist and the solicitations time out.
  prefs: []
  type: TYPE_NORMAL
- en: The default server thread usage can be additionally supplemented with the use
    of agent structure inside your business rationale, to additionally make simultaneous
    non-concurrent calls from inside a strategy in a solitary string execution stream.
  prefs: []
  type: TYPE_NORMAL
- en: Performance tuning patterns and anti-patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Performance tuning is the change of the framework execution. Regularly in PC
    frameworks, the inspiration for such an action is known as a performance issue,
    which can be either genuine or assumed. Most frameworks will react to expanded
    load with some level of diminishing execution. A framework's capacity to acknowledge
    a higher load is called versatility, and altering a framework to deal with a higher
    load is synonymous with execution tuning.
  prefs: []
  type: TYPE_NORMAL
- en: 'The performance tuning involves the following mentioned steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The issue should be surveyed and checked against expected numeric counts for
    satisfaction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Measure the execution of the framework before alteration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Distinguish the piece of the framework that is basic for enhancing the execution.
    This is known as the **bottleneck**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alter that piece of the framework to evacuate the bottleneck.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Measure the execution of the framework after alteration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the event that the adjustment improves the execution, receive it. In the
    event that the change aggravates the execution, set it back the way it was.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Anti-patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As there are patterns, there are also anti-patterns in software development.
    Patterns help to ensure the betterment of the application in terms of performance,
    scalability, and optimized processing. On the other hand, the existence of anti-patterns
    in the code indicates that challenges exist in application execution. Anti-patterns
    impact the application with a similar degree to patterns but in a negative way.
    Performance anti-patterns mostly degrade the application's performance. We are
    discussing anti-patterns because, along with following patterns and best practices,
    we have to ensure that we do not follow or use anti-patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Architectural anti-patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many types of performance anti-patterns in architecture. The multi-layering
    anti-pattern describes an architecture that attempts to achieve high abstraction
    through as many independent, logical application layers as possible. As a developer,
    such an architecture quickly becomes recognizable by the fact that much of the
    time spent mapping and converting data is lost, and that a simple pass from the
    interface to the database is complex.
  prefs: []
  type: TYPE_NORMAL
- en: Such architectures usually arise because the application should be kept as flexible
    as possible so that, for example, GUIs can be exchanged easily and quickly, and
    the dependencies on other systems and components can be kept low. The decoupling
    of the layers leads to performance losses during the mapping and exchange of the
    data— especially if the layers are also physically separated and the data exchange
    takes place via remoting technologies, such as **Simple Object Access Protocol**
    (**SOAP**) or **Remote Method Invocation** (**RMI**), **Internet Inter-ORB Protocol**
    (**IIOP**).
  prefs: []
  type: TYPE_NORMAL
- en: The many mapping and conversion operations can also result in higher garbage
    collection activity, known as the cycling object problem. As a solution to this
    anti-pattern, the architecture drivers should be scrutinized to clarify what flexibility
    and decoupling is needed. New framework approaches, such as JBoss Seam, have addressed
    the problem and try to avoid mapping data as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Another architectural anti-pattern is the so-called **session cache**. In doing
    so, the web session of an application is misused as a large data cache, which
    severely limits the scalability of the application. Session sizes have often been
    measured to be well larger than 1 MB in tuning jobs—in most cases, no team member
    knows the exact content of the session. Large sessions cause the Java heap to
    be very busy and only a small number of parallel users are possible. Especially
    when clustering applications with session replication, depending on the technology
    used, the performance loss due to serialization and data transfer is very high.
    Some projects help to acquire new hardware and more memory, but in the long run,
    this is a very expensive and risky solution.
  prefs: []
  type: TYPE_NORMAL
- en: Session caches arise because the architecture of the application has not clearly
    defined which data is session-dependent and which is persistent, that is, recoverable
    at any time. During development, all data is quickly stored in the session, because
    this is a very convenient solution—often this data is no longer removed from the
    session. To solve this problem, you should first memory-analyze the session using
    a production heap dump and clean up the session for data that is not session-dependent.
    Caching can positively impact performance if the process of getting data is performance
    critical, for example, with database accesses. Optimally, the caching is then
    transparent to the developer within the framework. For example, Hibernate provides
    a first and second-level cache to optimize access to data, but be careful; the
    configuration and tuning of such frameworks should be done by experts, otherwise,
    you'll quickly get a new performance anti-pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing anti-patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many Java performance anti-patterns and tuning tips available, but
    the problem with these technological anti-patterns is that they are heavily dependent
    on the Java version and manufacturer, and especially on the use case. A very common
    anti-pattern is the underrated frontend. For web applications, the frontend is
    often the performance Achilles heel. HTML and JavaScript development are often
    a nuisance to real application developers and are therefore often under-optimized
    for performance. Even with the increasing use of DSL, the connection is often
    still a bottleneck, especially if it is a mobile connection via **Universal Mobile
    Telecommunications System** (**UMTS**) or **General Packet Radio Service** (**GPRS**).
    Web applications are becoming increasingly complex, driven by the Web 2.0 hype,
    and are increasingly approaching desktop applications.
  prefs: []
  type: TYPE_NORMAL
- en: This comfort leads to extended waiting times and higher server and network load
    through many server round trips and large pages. There is a whole range of solutions
    to optimize web-based interfaces. Compressing HTML pages with GZip significantly
    reduces the amount of data transferred and has been supported by all browsers
    since HTTP 1.1\. Web servers, such as Apache, have modules (`mod_ gzip`) to perform
    the compression without changing the application. However, page sizes can also
    be reduced quickly in HTML by consistently using CSS and swapping CSS and JavaScript
    sources into your own files so that they can be better cached by the browser.
    Also, AJAX can, when correctly used, improve the performance significantly, because
    the complete reloading of web pages can be saved; for example, only the contents
    of lists are retransmitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'But even in the analysis, the performance of the surfaces can be significantly
    improved by adapting the contents of the pages to the requirements of the user.
    For example, if only those fields that are needed 80% of the time appear on a
    page, the average transfer rate can be significantly reduced; the dropped fields
    are offloaded to separate pages. As an example, in many web applications, there
    are forms with more than 30 input fields. In 90% of the instances when users fill
    in those forms, they fill in values for only two fields but we display all these
    30 fields in the listing pages or reports, including all lists for the selection
    boxes. Another common anti-pattern is **phantom logging**, which can be found
    in almost all projects. Phantom logging generates log messages that do not actually
    have to be created in the active log level. The following code is an example of
    the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Although the message would not be logged in the `INFO` level, the string is
    assembled. Depending on the number and complexity of the debug and trace messages,
    this can lead to enormous performance losses, especially if objects have an over-written
    and costly `toString()` method. The solution is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the log level is first queried and the log message is only generated
    if the `DEBUG` log level is active. In order to avoid performance bottlenecks
    during development,  the used frameworks in particular should be understood correctly.
    Most commercial and open source solutions have sufficient performance documentation,
    and experts should be consulted at regular intervals to implement the solution.
    Even if profiling finds the bottleneck within a framework, it does not mean that
    the problem lies within the framework. In most cases, the problem is misuse or
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: The iterative performance-tuning process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The iterative performance-tuning process is a set of guidelines that will help
    improve application performance drastically. These guidelines can be applied in
    iterations until the desired output is achieved. These guidelines can also be
    applied to a variety of web applications, regardless of the technology used to
    build the application.
  prefs: []
  type: TYPE_NORMAL
- en: The first and most important part of any application is the rendering of static
    content. The delivery of static content is one of the most common performance
    bottlenecks. The static content includes images, logos, browser executable scripts,
    cascaded style sheets, and themes. As this content remains the same all the time,
    it is unnecessary to serve this content dynamically. Instead, the web server,
    such as Apache, should be configured to have a long browser cache time while serving
    static resources to the response. This improvement in static content delivery
    can significantly improve the application's overall performance. The web server
    must also be configured to compress static resources. Web accelerators can be
    used for caching a web resource. For content-driven public portals, it is highly
    recommended to cache whole pages through the web accelerator. Varnish is an open
    source web accelerator tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'Server resource monitoring must be included as part of iterative performance
    analysis. The reason is that as the application grows, it starts occupying more
    resources at a particular instance in time. The higher demand for server resources,
    such as CPU, memory, and disk I/O, can cause it to exceed the operating system
    limits and become prone to failure. The monitoring systems must be set up in order
    to observe resource utilization. Resource monitoring usually includes:'
  prefs: []
  type: TYPE_NORMAL
- en: Web servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processes—Maximum versus actual
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Threads—Maximum versus actual
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CPU utilization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heap memory as a separate measurement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disk I/O operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database connections—Maximum versus busy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JVM garbage collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database slow queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cache hits—Number of times the result is found from the cache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cache misses—Number of times the result is not found from the cache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to monitor the resources, the following tools can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`jconsole` and `jvisualvm` come bundled with the standard **Java Development
    Kit** (**JDK**). Using these tools, we can monitor JVM, garbage collection execution,
    cache statistics, threads, CPU usage, memory usage, and database-connection pooling
    statistics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mpstat` and `vmstat` are available on Linux-based operating systems. Both
    of these are command-line tools and are used for collecting and reporting processor-related
    statistics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ifstat` and `iostat` are useful for monitoring system input/output operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There might be a question on why we should do this iterative performance tuning
    process while we follow best practices. The goals of the iterative performance
    tuning process are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify bottlenecks in the system's performance at various levels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve the performance of the portal as per the expectations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find the solution and approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Put the solution workflow in place
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the performance pain areas of the system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define the performance strategy for the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify the performance measurement tool based on the technologies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand application key user scenarios
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Document key scenarios
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prepare sufficient data to generate considerable distributed load on all flavors
    in a single execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customize and combine load testing scripts to prepare a performance test suite
    that can be used for execution on any single flavor or on all flavors at a time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute performance scripts with different scenarios and load combinations to
    identify bottlenecks using response times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The iterative performance tuning process is followed at all stages of the application
    development life cycle. The following table demonstrates the items being reviewed
    with input and output expectations:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Review item** | **Input** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| Architecture'
  prefs: []
  type: TYPE_NORMAL
- en: High availability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search Engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| System architecture diagram | Recommendations on best practices |'
  prefs: []
  type: TYPE_TB
- en: '| User interface |'
  prefs: []
  type: TYPE_TB
- en: Frontend code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Existing technology selection criteria
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Review of the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recommendations for the change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Hardware configuration |'
  prefs: []
  type: TYPE_TB
- en: Web server details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: App server details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server type (Virtual or Physical)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number of CPU
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hard disk space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Changes recommended in hardware configuration |'
  prefs: []
  type: TYPE_TB
- en: '| Software configuration |'
  prefs: []
  type: TYPE_TB
- en: Framework configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependent modules/integrations configuration, if any
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Recommendations on configuration change |'
  prefs: []
  type: TYPE_TB
- en: '| Application server configuration |'
  prefs: []
  type: TYPE_TB
- en: App server configuration files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Recommendations on configuration change |'
  prefs: []
  type: TYPE_TB
- en: '| Web server configuration |'
  prefs: []
  type: TYPE_TB
- en: Web server configuration files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cache control settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static resource-handling settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Recommendations on configuration change |'
  prefs: []
  type: TYPE_TB
- en: '| Deployment architecture |'
  prefs: []
  type: TYPE_TB
- en: Deployment diagram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software installation details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Recommendation on deployment architecture changes |'
  prefs: []
  type: TYPE_TB
- en: '| Code and database |'
  prefs: []
  type: TYPE_TB
- en: Code review
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DB design review
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code duplication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modularization of code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any third-party libraries/APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding standard implemented
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loops and conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data normalization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indexing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Long-running queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relations between tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Code review results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recommendations for improvement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Spring support of JMX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JMX is the standard component in the Java platform. It was first released in
    J2SE 5.0\. Basically, JMX is a set of specifications defined for application and
    network management. It empowers developers to assign management attributes to
    the Java objects used in the applications. By assigning management attributes,
    it makes the Java objects capable of working with network management software
    in use. It provides a standard way for developers to manage applications, devices,
    and services.
  prefs: []
  type: TYPE_NORMAL
- en: 'JMX has a three-layer architecture. The three layers are defined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The probe or instrumentation layer**: This layer contains managed beans.
    The application resources to be managed are enabled for JMX.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The agent or MBeanServer layer**: This layer forms the core of the JMX. It
    works as an intermediary between managed beans and the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The remote management layer**: This layer enables the remote applications
    to connect to and access `MBeanServer` using connectors or adapters. The connector
    provides full access to `mBeanServer` whereas an adapter adapts the API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows the architecture of JMX:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f6d6ebb6-fe47-46b9-b712-2de301215c30.png)'
  prefs: []
  type: TYPE_IMG
- en: Source: https://www.ibm.com/support/knowledgecenter/en/SSAW57_8.5.5/com.ibm.websphere.nd.multiplatform.doc/ae/cxml_javamanagementx.html
  prefs: []
  type: TYPE_NORMAL
- en: Managed beans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The managed bean is a type of Java bean. It is used specifically in JMX technology
    and it is created using the **dependency injection** (**DI**) technique. In JMX,
    a resource is represented as a **managed bean** (**MBean**). These managed beans
    are registered with a core managed beans server. So, a managed bean can be visualized
    as a wrapper around Java services, components, or devices. As all the managed
    components are registered with the MBeans server, it is used for managing all
    of the managed beans. The managed beans server allows server components to wire
    in and find managed beans. A typical JMX agent consists of a managed beans server
    and services required to interact with managed beans.
  prefs: []
  type: TYPE_NORMAL
- en: The JMX specification describes standard connectors. These connectors are also
    known as **JMX connectors**. JMX connectors allow us to access JMX agents from
    remote management applications. The connectors can use different protocols to
    work with the same management interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the reasons why JMX should be used:'
  prefs: []
  type: TYPE_NORMAL
- en: It provides a way to manage applications on different devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides a standard way to manage Java applications and networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be used to manage JVM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides a scalable and dynamic management interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the basic understanding of JMX, let's move on to check how it is supported
    in Spring. The JMX support for Spring enables us to transform the spring application
    into JMX architecture quite easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the features provided by Spring''s JMX support:'
  prefs: []
  type: TYPE_NORMAL
- en: Automatic registration of a Spring bean as a managed bean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A flexible structure for controlling the management interface for Spring beans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A declarative approach for managed beans over remote connectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proxying of local and remote managed bean resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These features work without coupling with either of Spring or JMX's classes
    or interfaces. Spring JMX support has a class called `MBeanExporter`. This class
    is responsible for collecting Spring beans and registering them with the managed
    beans server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of a Spring bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to expose this bean and its properties as managed attributes and operations,
    the following configurations should be done in the configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: An important bean definition, from the preceding configuration, to look for
    is the exporter bean. The beans map property of the exporter bean indicates the
    Spring beans to be exposed as JMX beans to the JMX-managed beans server.
  prefs: []
  type: TYPE_NORMAL
- en: With the preceding configuration, it is assumed that the managed beans server
    must be running in the environment accessible to the Spring application. If the
    managed beans server or `MBeanServer` is running, Spring will attempt to find
    it and register all the beans. This default behavior is useful when the application
    is running inside Tomcat or IBM WebSphere that has a bundled `MBeanServer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other cases, we have to create an `MBeanServer` instance, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We have to specify the server property on the `MBeanExporter` bean to associate
    it with the `MBeanServer` that has been created.
  prefs: []
  type: TYPE_NORMAL
- en: With the inception of annotations in JDK 5.0, Spring enabled the provision for
    setting annotations to register Spring beans as JMX beans.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example `Calculator` bean defined using the `@ManagedResource`
    annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `@ManagedAttribute` and `@ManagedOperation` annotations are used to expose
    the bean properties and methods to manage the beans server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the client code that instantiates the managed beans, which
    can be monitored by tools such as JConsole or VisualVM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Once exposed as managed beans, these resources can be monitored for various
    parameters, such as the number of objects, memory occupied by the objects, and
    heap memory space occupied by the objects, using tools such as JConsole or VisualVM.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a screenshot from Java VisualVM highlighting the exposure
    of the `Calculator` as a managed bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba6700e0-0402-417d-a4ae-1bdb5413c631.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is one of the most important chapters in this book. It solely focuses on
    performance measurement and enhancement strategies. This chapter resembles a real-life
    health checkup scenario. If a person is unwell, the first step is to identify
    the symptoms in order to identify and cure the disease. Similarly, this chapter
    started by identifying the symptoms of performance degradation, moving on to the
    performance tuning life cycle. Performance tuning patterns and anti-patterns were
    described, which resemble the best practices to be followed. This was followed
    by the iterative performance tuning process and JMX support in the Spring framework.
    We saw an example of Spring beans turned into JMX-managed beans.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter focuses on fine-tuning the JVM. This will not be tuning that
    is specific to a Spring application, but is applicable to any application running
    on JVM. This chapter will do a deep dive into the inside details of JVM, which
    are not very well-known to developers. Let's get ready to dive into JVM.
  prefs: []
  type: TYPE_NORMAL
