- en: The Concept of Device Tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Device Tree** (**DT** ) is an easy to read hardware description file,
    with JSON like formatting style, which is a simple tree structure where devices
    are represented by nodes with their properties. Properties can be either empty
    (just the key, to describe boolean values), or key-value pairs where the value
    can contain an arbitrary byte stream. This chapter is a simple introduction to
    DT. Every kernel subsystem or framework has its own DT binding. We will talk about
    those specific bindings when we deal with concerned topics. The DT originated
    from OF, which is a standard endorsed by computer companies, and whose main purpose
    is defining interfaces for computer firmware systems. That said, one can find
    more on DT specification at [http://www.devicetree.org/](http://www.devicetree.org/)
    . Therefore, this chapter will cover the basics of DT, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Naming convention, as well as aliases and labeling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing data types and their APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing addressing schemes and accessing the device resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing OF match style and providing application-specific data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Device tree mechanism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'DT is enabled in the kernel by setting the option `CONFIG_OF` to `Y` . In order
    to pull the DT API from within your driver, you must add the following headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'DT supports a few data types. Let us have a look at them with a sample node
    description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are some definitions of data types used in device trees:'
  prefs: []
  type: TYPE_NORMAL
- en: Text strings are represented with double quotes. One can use commas to create
    a list of the strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cells are 32-bit unsigned integers delimited by angle brackets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean data is nothing but an empty property. The true or false value depends
    on the property being there or not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Naming convention
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every node must have a name in the form `<name>[@<address>]` , where `<name>`
    is a string that can be up to 31 characters in length, and `[@<address>]` is optional,
    depending on whether the node represents an addressable device or not. `<address>`
    should be the primary address used to access the device. An example of device
    naming is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: On the other hand, the `label` is optional. Labeling a node is useful only if
    the node is intended to be referenced from a property of another node. One can
    see a label as a pointer to node, as explained in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Aliases, labels, and phandle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is very important to understand how these three elements work. They are
    frequently used in the DT. Let us take the following DT to explain how they work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: A label is nothing but a way to tag a node, to let the node be identified by
    a unique name. In the real world, that name is converted into a unique 32-bit
    value by the DT compiler. In the preceding example, `gpio1` and `node_label` are
    both labels. Labels can then be used to refer to a node, since a label is unique
    to a node.
  prefs: []
  type: TYPE_NORMAL
- en: A **pointer handle** (**phandle** ) is a 32-bit value associated with a node
    that is used to uniquely identify that node so that the node can be referenced
    from a property in another node. Labels are used to have a pointer to the node.
    By using `<&mylabel>` , you point to the node whose label is `mylabel` .
  prefs: []
  type: TYPE_NORMAL
- en: The use of `&` is just like in the C programming language; to obtain the address
    of an element.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, `&gpio1` is converted to the phandle so that it refers
    to `gpio1` node. The same goes for the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In order not to walk through the whole tree to look for a node, the concept
    of aliases has been introduced. In the DT, the `aliases` node can be seen like
    a quick lookup table, an index of another node. One can use the function `find_node_by_alias()`
    to find a node given its alias. The aliases are not used directly in the DT source,
    but are instead deferenced by the Linux kernel.
  prefs: []
  type: TYPE_NORMAL
- en: DT compiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The DT comes in two forms: the textual form, which represents the sources also
    known as `DTS` , and the binary blob form, which represents the compiled DT, also
    known as `DTB` . Source files have the `.dts` extension. Actually, there are also
    `.dtsi` text files, which represent SoC level definitions, whereas `.dts` files
    represent board level definitions. One can see `.dtsi` as header files, that should
    be included in `.dts` one, which are source files, not the reverse, a bit like
    including header files (`.h` ) in the source file (`.c` ). On the other hand,
    binary files use the `.dtb` extension.'
  prefs: []
  type: TYPE_NORMAL
- en: There is actually a third form, which is the runtime representation of the DT
    in `/proc/device-tree` .
  prefs: []
  type: TYPE_NORMAL
- en: As its name says, the tool used to compile the device tree is called the **device
    tree compiler** (**dtc** ). From the root kernel source, one can compile either
    a standalone specific DT or all DTs for the specific architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us compile all DT (`.dts)` files for arm SoC''s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'For a standalone DT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the name of the source file is `imx6dl-sabrelite.dts`
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a compiled device tree `(.dtb` ) file, you can do the reverse operation
    and extract the source `(.dts` ) file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: For the purpose of debugging, it could be useful to expose the DT to the user
    space. The `CONFIG_PROC_DEVICETREE` configuration variable will do that for you.
    You can then explore and walk through the DT in `/proc/device-tree` .
  prefs: []
  type: TYPE_NORMAL
- en: Representing and addressing devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each device is given at least one node in the DT. Some properties are common
    to many device types, especially devices sitting on a bus known to the kernel
    (SPI, I2C, platform, MDIO, and so on). These properties are `reg` , `#address-cells`
    , and `#size-cells` . The purpose of these properties is device addressing on
    the bus they sit on. That said, the main addressing property is `reg` , which
    is a generic property and whose meaning depends on the bus the device sits on.
    The `#` (sharp) that prefixes `size-cell` and `address-cell` can be translated
    into `length` .
  prefs: []
  type: TYPE_NORMAL
- en: Each addressable device gets a `reg` property that is a list of tuples in the
    form `reg = <address0size0 [address1size1] [address2size2] ... >` , where each
    tuple represents an address range used by the device. `#size-cells` indicates
    how many 32 bit cells are used to represent size, and may be 0 if size is not
    relevant. On the other hand, `#address-cells` indicates how many 32 bit cells
    are used to represent address. In other word, the address element of each tuple
    is interpreted according to `#address-cell` ; same for the size element, which
    is interpreted according to `#size-cell` .
  prefs: []
  type: TYPE_NORMAL
- en: Actually, addressable devices inherit from `#size-cell` and `#address-cell`
    of their parent, which is the node that represents the bus controller. The presence
    of `#size-cell` and `#address-cell` in a given device does not affect the device
    itself, but its children. In other words, before interpreting the `reg` property
    of a given node, one must know the parent node's `#address-cells` and `#size-cells`
    values. The parent node is free to define whatever addressing scheme is suitable
    for device sub-nodes (children).
  prefs: []
  type: TYPE_NORMAL
- en: SPI and I2C addressing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SPI and I2C devices both belong to non-memory mapped devices, because their
    addresses are not accessible to the CPU. Instead, the parent device''s driver
    (which is the bus controller driver) would perform indirect access on behalf of
    the CPU. Each I2C/SPI device is always represented as a sub-node of the I2C/SPI
    bus node the device seats on. For nonmemory mapped device, the `#size-cells` property
    is 0, and the size element in addressing the tuple is empty. It means the `reg`
    property for this kind of device is always on cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If one looks at a SoC level file at `arch/arm/boot/dts/imx6qdl.dtsi` , one will
    notice that `#size-cells` and `#address-cells` are respectively set to `0` for
    the former, and `1` for the last, in both `i2c` and `spi` nodes, which are respectively
    parents of I2C and SPI devices enumerated in the preceding section. This helps
    us to understand their `reg` property, which is only one cell for the address
    value, and none for the size value.
  prefs: []
  type: TYPE_NORMAL
- en: I2C device's `reg` property is used to specify the device's address on the bus.
    For SPI devices, `reg` represents the index of the chip-select line assigned to
    the device among the list of chips-select the controller node has. For example,
    for the ad7606r8 ADC, the chip-select index is `1` , which corresponds to `<&gpio5
    17 0>` in `cs-gpios` , which is the list of chip-select of the controller node.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may ask why I used the I2C/SPI node''s phandle: the answer is because I2C/SPI
    devices should be declared at board level file (`.dts` ), whereas I2C/SPI buses
    controller are declared at SoC level file (`.dtsi` ).'
  prefs: []
  type: TYPE_NORMAL
- en: Platform device addressing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section address simple memory-mapped devices whose memory is accessible
    to the CPU. Here, the `reg` property still defines the device's address, which
    is a list of memory regions on which you can access the device. Each region is
    represented with a tuple of cells, where the first cell is the base address of
    the memory region, and the second tuple is the size of the region. It then has
    the form `reg = <base0 length0 [base1 length1] [address2 length2] ... >` . Each
    tuple represents an address range used by the device.
  prefs: []
  type: TYPE_NORMAL
- en: In the real world, one should not interpret the `reg` property without knowing
    the value of two other properties,`#size-cells` and `#address-cells` . `#size-cells`
    tell us how large the length field is in each child `reg` tuple. The same for
    `#address-cell` , which tell us how many cells we must use to specify an address.
  prefs: []
  type: TYPE_NORMAL
- en: 'This kind of device should be declared within a node with a special value `compatible
    = "simple-bus"` , meaning a simple memory-mapped bus with no specific handling
    nor driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, child nodes whose parent has `simple-bus` in the
    compatible property will be registered as platform devices. One can also see how
    I2C and SPI bus controllers change the addressing scheme of their children by
    setting `#size-cells = <0>;` because it is not relevant to them. A well-known
    place to look for any binding information is in the kernel device tree''s documentation:
    *Documentation/devicetree/bindings/* .'
  prefs: []
  type: TYPE_NORMAL
- en: Handling resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main purpose of a driver is to handle and manage devices, and most of the
    time, expose their functionalities to the user-space. The objective here is to
    gather the device's configuration parameters, and especially resources (memory
    region, interrupt line, DMA channel, clocks, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the device node with which we will work during this section.
    It is the i.MX6 UART device''s node, defined in `arch/arm/boot/dts/imx6qdl.dtsi`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Concept of named resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the driver expect a list of resources of a certain type, one has no guarantee
    the list is ordered in a manner the driver expects, since the guy who writes the
    board level device tree is usually not the one that wrote the driver. A driver
    may expect, for example, its device node with 2 IRQs lines, one for the Tx event
    at index 0, the other for Rx at index 1\. What happens if the order is not respected?
    The driver will have an unwanted behavior. To avoid such mismatches, the concept
    of named resources (`clock` , `irq` , `dma` , `reg` ) has been introduced. It
    consists of defining our resource list, and naming them, so that whatever their
    indexes are, a given name will always match the resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'The corresponding properties to name the resources are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`reg-names` : This is for a list of memory regions in `reg` property'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clock-names` : This is to name clocks in the `clocks` property'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`interrupt-names` : This give a name to each interrupt in the `interrupts`
    property'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dma-names` : This is for the `dma` property'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now let us create a fake device node entry to explain that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The code in the driver to extract each named resource is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This way, you are sure to map the right name to the right resource, without
    needing to play with the index anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing registers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, the driver will take ownership of the memory region and map it into the
    virtual address space. We will discuss more about this in [Chapter 11](http://post)
    , *Kernel Memory Management* .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`platform_get_resource()` will set the start and end fields of `struct res`
    according to the memory region present in the first (index 0) `reg` assignment.
    Please remember the last argument of `platform_get_resource()` represents the
    resource index. In the preceding sample, `0` indexes the first value of that resource
    type, just in case the device is assigned more than one memory region in the DT
    node. In our example, it''s `reg = <0x02020000 0x4000>` , meaning that the allocated
    region starts at physical address `0x02020000` and has the size of `0x4000` bytes.
    `platform_get_resource()` will then set `res.start = 0x02020000` and `res.end
    = 0x02023fff` .'
  prefs: []
  type: TYPE_NORMAL
- en: Handling interrupts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The interrupt interface is actually divided into two parts; the consumer side
    and the controller side. Four properties are used to describe interrupt connections
    in the DT:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The controller is the device that exposes IRQ lines to the consumer. In controller
    side, on has the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`interrupt-controller` : An empty (Boolean) property that one should define
    in order to mark the device as being an interrupt controller'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#interrupt-cells` : This is a property of interrupt controllers. It states
    how many cells are used to specify an interrupt for that interrupt controller'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The consumer is the device that generate the IRQ. Consumer binding expects
    the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`interrupt-parent` : For the device node that generates interrupt, it is a
    property that contains a pointer `phandle` to the interrupt controller node to
    which the device is attached. If omitted, the device inherits that property from
    its parent node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`interrupts` : It is the interrupt specifier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interrupt binding and interrupt specifiers are tied to the interrupt controller
    device. The number of cells used to define an interrupt input depends on the interrupt
    controller, which is the only one deciding, by mean of its `#interrupt-cells`
    property. In the case of i.MX6, the interrupt controller is a **Global Interrupt
    Controller** (**GIC** ). Its binding is well explained in *Documentation/devicetree/bindings/arm/gic.txt*
    .
  prefs: []
  type: TYPE_NORMAL
- en: The interrupt handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This consist of fetching the IRQ number from the DT, and mapping it into Linux
    IRQ, thus registering a function callback for it. The driver code to do this is
    quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `platform_get_irq()` call will return the `irq` number; this number is usable
    by `devm_request_irq()` (`irq` is then visible in `/proc/interrupts` ). The second
    argument, `0` , says that we need the first interrupt specified in the device
    node. If, there is more than one interrupt, we can change this index according
    to the interrupt we need, or just use the named resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our preceding example, the device node contains an interrupt specifier,
    which looks like as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'According to ARM GIC, the first cell informs us about interrupt type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` **: Shared peripheral interrupt** (**SPI** ), for interrupts signal shared
    among cores, which can be routed by the GIC to any core'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1` : **Private peripheral interrupt** (**PPI** ), for interrupt signal private
    to an individual core'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The documentation can be found at: [http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0407e/CCHDBEBE.html](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0407e/CCHDBEBE.html)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: The second cell holds the interrupt number. This number depends on whether the
    interrupt line is a PPI or SPI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third cell, `IRQ_TYPE_LEVEL_HIGH` in our case, represents sense level. All
    of the available sense levels are defined in `include/linux/irq.h` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interrupt controller code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `interrupt-controller` property is used to declare a device as an interrupt
    controller. The `#interrupt-cells` property defines how many cells must be used
    to define a single interrupt line. We will discuss this in detail in [Chapter
    16](http://advanced) , *Advanced IRQ* *Management* .
  prefs: []
  type: TYPE_NORMAL
- en: Extract application-specific data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Application-specific data is data beyond the common properties (neither resources
    nor GPIOs, regulator, and so on). Those are arbitrary properties and child nodes
    that can be assigned to a device. Such property names are usually prefixed with
    manufacture codes. These can be any string, Boolean, or integer values, along
    with their API defined in `drivers/of/base.c` in the Linux sources. The following
    examples we discuss are not exhaustive. Let us now reuse the node defined earlier
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Text string
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is one `string` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Back in the driver, one should use `of_property_read_string()` to read a string
    value. Its prototype is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows how you can use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Cells and unsigned 32-bit integers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are our `int` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'One should use `of_property_read_u32()` to read a cell value. Its prototype
    is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Back in the driver,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'One can use `of_property_read_u32_array` to read a list of cells. Its prototype
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `sz` is the number of array elements to read. Have a look at `drivers/of/base.c`
    to see how to interpret its return value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Boolean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One should use `of_property_read_bool()` to read the Boolean property whose
    name is given in the second argument of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Extract and parse sub-nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You are allowed to add any sub-node in your device node. Given a node representing
    a flash memory device, partitions can be represented as sub-nodes. For a device
    that handles a set of input and output GPIO, each set can be represented as a
    sub-node. The sample node is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'One can use `for_each_child_of_node()` to walk through sub-nodes of the given
    node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Platform drivers and DT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Platform drivers also work with DT. That being said, it is the recommended
    way to deal with platform devices nowadays, and there is no need to touch board
    files anymore, or even to recompile the kernel when a device''s property changes.
    If you remember, in the previous chapter we discussed OF match style, which is
    a matching mechanism based on the DT. Let us see in the following section how
    it works:'
  prefs: []
  type: TYPE_NORMAL
- en: OF match style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OF match style is the first matching mechanism performed by the platform core
    in order to match devices with their drivers. It uses the device tree's `compatible`
    property to match the device entry in `of_match_table` , which is a field of the
    `struct driver` substructure. Each device node has a `compatible` property, which
    is a string, or a list of strings. Any platform driver that declares one of the
    strings listed in the `compatible` property will trigger a match and will see
    its `probe` function executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'A DT match entry is described in the kernel as an instance of the `struct of_device_id`
    structure, which is defined in `linux/mod_devicetable.h` and looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the meaning of each element of the structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`char compatible[128]` : This is the string used to match the device node''s
    compatible property in the DT. They must be identical before a match occurs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const void *data` : This can point to any structure, which can be used as
    per-device type configuration data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since the `of_match_table` is a pointer, you can pass an array of the `struct
    of_device_id` to make your driver compatible with more than one device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have filled your array of ids, it must be passed to the `of_match_table`
    field of your platform driver, in the driver substructure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: At this step, only your driver is aware of your `of_device_id` array. To get
    the kernel informed too (so that it can store your IDs in the device list maintained
    by the platform core), your array has to be registered with `MODULE_DEVICE_TABLE`
    , as described in [Chapter 5](text00146.html) , *Platform Device Drivers:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'That is all! Our driver is DT-compatible. Back in our DT, let''s declare a
    device compatible with our driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Two compatible strings are provided here. If the first one does not match any
    driver, the core will perform the match with the second.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a match occurs, the `probe` function of your driver is called, with a
    `struct platform_device` structure as the parameter, which contains a `struct
    device dev` field, in which there is a field `struct device_node *of_node` that
    corresponds to the node associated to our device, so that one can use it to extract
    the device settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'One can check if the DT node is set to know whether the driver has been loaded
    in response to an `of_match` , or instantiated from within the board''s `init`
    file. You should then use the `of_match_device` function, in order to pick the
    `struct *of_device_id` entry that originated the match, which may contain the
    specific data you have passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Dealing with non-device tree platforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'DT support is enabled in the kernel with the `CONFIG_OF` option. One would
    probably want to avoid using the DT API when its support is not enabled in the
    kernel. The way one can achieve that is to check whether `CONFIG_OF` is set or
    not. People used to do something like as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Even if the `of_device_id` data type is always defined when device tree support
    is missing, the code wrapped into `#ifdef CONFIG_OF ... #endif` will be omitted
    during the build. This is used for conditional compilation. It is not your only
    choice; there is also the `of_match_ptr` macro, which simply returns `NULL` when
    `OF` is disabled. Everywhere you''ll need to pass your `of_match_table` as a parameter,
    it should be wrapped in the `of_match_ptr` macro, so that it returns `NULL` when
    `OF` is disabled. The macro is defined in `include/linux/of.h` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This eliminates having a `#ifdef` , returning `NULL` when `OF` is disabled.
  prefs: []
  type: TYPE_NORMAL
- en: Support multiple hardware with per device-specific data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, a driver can support different hardware, each with is specific configuration
    data. That data may be dedicated function tables, specific register values, or
    anything unique to each hardware. The following example describes a generic approach:'
  prefs: []
  type: TYPE_NORMAL
- en: Let us first remember what `struct of_device_id` looks like, in `include/linux/mod_devicetable.h`
    .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The field we are interested in is `const void *data` , so we can use it to pass
    any data for each specific device.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say we own three different devices, each with a specific private data.
    `of_device_id.data` will contain a pointer to specific parameters. This example
    is inspired by `drivers/tty/serial/imx.c` *.*
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we declare private structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we fill an array with each device-specific data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Each compatible entry is tied with a specific array index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in the `probe` function, whatever the match entry is, it will hold a pointer
    to the device-specific structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `devdata` is an element of a structure in the original
    source, and declared like `const struct imx_uart_data *devdata` ; we could have
    stored any specific parameter in the array.
  prefs: []
  type: TYPE_NORMAL
- en: Match style mixing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OF match style can be combined with any other matching mechanism. In the following
    example, we have a mix of DT and device ID match styles:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We fill an array for the device ID match style, each device having its data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We do the same for OF match style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `probe` function will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we declare our platform driver; feed all arrays defined as in the preceding
    sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Platform resources and DT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Platform devices can work with the device tree enabled system without any extra
    modification. It is what we have demonstrated in the section *Handling resources*
    . By using `platform_xxx` family function, the core also walks through the DT
    (with `of_xxx` family function) to find the requested resource. The reverse is
    not true, since `of_xxx` family function is only reserved for the DT. All resource
    data will be available to the driver in a usual way. The driver now knows whether
    this device is not initialized with hardcoded parameters in the board file or
    not. Let us take an example with an uart device node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The following excerpt describes the `probe` function of its driver. In the
    `probe` , the function `platform_get_resource()` can be used to extract any property
    which is a resource (memory region, dma, irq), or a specific function, such as
    `platform_get_irq()` , which extracts the `irq` provided by the `interrupts` property
    in the DT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'To sum up, for properties such as `dma` , `irq` and `mem` , you have nothing
    to do in the platform driver to match `dtb` . If one remembers, this data is of
    the same type as the data one can pass as a platform resource. To understand why,
    we just have to look inside these functions; we will see how each of them internally
    deals with DT functions. The following is an example of the `platform_get_irq`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'One may wonder how the `platform_xxx` functions extract resources from the
    DT. This should have been the `of_xxx` function family. You are right, but during
    the system boot, the kernel calls `of_platform_device_create_pdata()` on each
    device node, which will result in creating a platform device with the associated
    resource, on which you can call the `platform_xxx` family function. Its prototype
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Platform data versus DT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your driver expects platform data, you should check the `dev.platform_data`
    pointer. A non-null value means your driver has been instantiated the old way
    in the board configuration file, and DT does not enter into it. For drivers instantiated
    from the DT, `dev.platform_data` will be `NULL` , and your platform device will
    be given a pointer on the DT entry (node) that corresponds to your device in the
    `dev.of_node` pointer, from which one can extract the resource and use OF API
    to parse and extract application data.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s also a hybrid method that one can use to associate platform data declared
    in the C files to DT nodes, but that''s for special cases only: for DMA, IRQ,
    and memory. This method is used only when the driver expects only resources, and
    no application-specific data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One can transform a legacy declaration of an I2C controller into DT-compatible
    nodes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'And the DT node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The time to switch from hardcoded device configuration to DT has come. This
    chapter gave you all you need to handle DTs. Now you have the necessary skills
    to customize or add whatever node and property you want into the DT, and extract
    them from within your driver. In the next chapter, we will talk about the I2C
    driver, and use the DT API to enumerate and configure our I2C devices.
  prefs: []
  type: TYPE_NORMAL
