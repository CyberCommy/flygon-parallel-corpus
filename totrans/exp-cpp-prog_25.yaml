- en: STL Algorithm Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will cover the following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Copying items from containers to other containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing specific items from containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforming the contents of containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding items in ordered and unordered vectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limiting the values of a vector to a specific numeric range with `std::clamp`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locating patterns in strings with `std::search` and choosing the optimal implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sampling large vectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating permutations of input sequences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a dictionary merging tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The STL does not only contain data structures but also *algorithms*, of course.
    While data structures help *store* and *maintain* data in different ways with
    different motivations and targets, algorithms apply specific *transformations*
    to the data in such data structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at a standard task, such as summing up items from a vector.
    This can be done easily by looping over the vector and summing up all the items
    into an accumulator variable called `sum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'But because this is quite a standard task, there is also an STL algorithm for
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the handcrafted loop variant is not much longer, and it is also
    not significantly harder to read than a one-liner which says what it does: `accumulate`.
    In a lot of cases, however, it is awkward to read a 10-line code loop just to
    realize, "Did I just have to study the whole loop in order to understand that
    it does a standard task, X?", rather than seeing one line of code, which uses
    a standard algorithm whose name clearly states what it does, such as `accumulate`,
    `copy`, `move`, `transform`, or `shuffle`.'
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea is to provide a rich variety of algorithms that can be used by
    programmers on a daily basis in order to reduce the need to repeatedly reimplement
    them. This way, programmers can just use off the shelf algorithm implementations
    and concentrate on the *new* problems, instead of wasting time on problems that
    *already have been solved* by the STL. Another perspective is correctness--if
    a programmer implements the same thing again and again for a hundred times, there
    is some probability that this may introduce a slight *error* in one or the other
    attempt. This would be completely unnecessary and also very *embarrassing* if,
    for example, it is pointed out by a colleague during code review, whereas at the
    same time, a standard algorithm could have been used.
  prefs: []
  type: TYPE_NORMAL
- en: Another important point of STL algorithms is *efficiency*. Many STL algorithms
    provide multiple *specialized* implementations of the same algorithm, which do
    things differently, depending on the *iterator type* they are being used with.
    For example, if all the elements in a vector of integers should be zeroed, this
    can be done with the STL algorithm `std::fill`. Because the iterator of a vector
    can already tell the compiler that it iterates over *contiguous* memory, it can
    select the implementation of `std::fill` which uses the C procedure `memset`.
    If the programmer changes the container type from `vector` to `list`, then the
    STL algorithm cannot use `memset` any longer and has to iterate over the list
    in order to zero the items individually. In case the programmer uses `memset`
    himself, the implementation would be unnecessarily hardcoded to using vectors
    or arrays because most other data structures do not save their data in contiguous
    memory chunks. In most cases, it makes little sense to try to be smart, as the
    implementers of the STL may already have implemented the same ideas, which can
    be used for free.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s summarize the preceding points. Using STL algorithms is good for:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Maintainability**: The names of the algorithms already state in a straightforward
    manner what they do. Explicit loops are rarely both better to read and as data-structure
    agnostic as standard algorithms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Correctness**: The STL has been written and reviewed by experts, and used
    and tested by so many people that you are pretty unlikely to reach the same degree
    of correctness when reimplementing the complex parts of it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efficiency**: STL algorithms are, by default, at least as efficient as most
    handcrafted loops.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most algorithms work on *iterators*. The concept of how iterators work is already
    explained in [Chapter 20](28942573-9c26-46c7-a1de-be9e941ed82f.xhtml), *Iterators*.
    In this chapter, we'll concentrate on using STL algorithms for different problems
    in order to get a feeling of how they can be profitably put to use. Showing *all*
    STL algorithms would blow up this book to a very boring C++ reference, although
    there is already a C++ reference publicly available.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to become an STL ninja is having the C++ reference always at hand
    or, at least, saved in a browser bookmark. When solving a task, every programmer
    should have a look at it with the question back in his mind, "Is there an STL
    algorithm for my problem?", before writing code himself.
  prefs: []
  type: TYPE_NORMAL
- en: 'A very good and complete C++ reference is available for online viewing at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://cppreference.com](http://cppreference.com)'
  prefs: []
  type: TYPE_NORMAL
- en: It can also be downloaded for offline viewing.
  prefs: []
  type: TYPE_NORMAL
- en: In job interviews, good fluency with the STL algorithms is often regarded as
    an indicator of a strong knowledge of C++.
  prefs: []
  type: TYPE_NORMAL
- en: Copying items from containers to other containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most important STL data structures have iterator support. This means that
    it is at least possible to get iterators via `begin()` and `end()` functions,
    which point to the data structure's underlying payload data and allow to iterate
    over that data. The iteration always looks the same, no matter what kind of data
    structure is iterated over.
  prefs: []
  type: TYPE_NORMAL
- en: We can get iterators from vectors, lists, deques, maps, and so on. Using iterator
    adaptors, we can even get iterators as an interface to files, standard input,
    and standard output. Moreover, as we saw in the previous chapter, we can even
    wrap iterator interfaces around algorithms. Now, where we can access everything
    with iterators, we can combine them with STL algorithms, which accept iterators
    as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: A really nice way to show how iterators help abstract the nature of different
    data structures away is the `std::copy` algorithm, which just copies items from
    one set of iterators to an output iterator. Where such algorithms are used, the
    nature of the underlying data structure is not really relevant any longer. In
    order to demonstrate this, we will play a bit with `std::copy`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will use different variants of `std::copy`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first include all headers we need for the data structures we use. Additionally,
    we declare that we use the `std` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use pairs of integer and string values in the following. In order to
    nicely print them, we should first overload the `<<` stream operator for them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main` function, we fill a `vector` of integer-string pairs with some
    default values. And we declare a `map` variable, which associates integer values
    with string values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we use `std::copy_n` to copy exactly three integer-string pairs from the
    front of the vector to the map. Because vectors and maps are completely different
    data structures, we need to transform the items from the vector using the `insert_iterator`
    adapter. The `std::inserter` function produces such an adapter for us. Please
    be always aware that using algorithms like `std::copy_n` combined with insert
    iterators is the most *generic* way to copy/insert items to other data structures,
    but not the *fastest*. Using the data structure-specific member functions for
    inserting items is usually the most efficient way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s print what''s in the map afterward. Throughout the book, we have often
    been printing a container''s content using the `std::copy` function. The `std::ostream_iterator`
    helps a lot in that regard because it allows us to treat the user shell''s standard
    output as *another container* we can copy data into:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s clear the map again for the next experiment. This time, we *move* items
    from the vector to the map, and this time, it''s *all* the items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We print the new content of the map again. Moreover, as `std::move` is an algorithm
    that also alters the data *source*, we will print the source vector too. This
    way, we can see what happened to it when it acted as a move source:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compile and run the program and see what it says. The first two lines
    are simple. They reflect what the map contained after applying the `copy_n` and
    `move` algorithms. The third line is interesting because it shows that the strings
    in the vector that we used as move source are now empty. This is because the content
    of the strings has not been copied but efficiently *moved* (which means that the
    map uses the string data in heap memory that was previously referenced by the
    string objects in the vector*)*. We should usually not access items that were
    a move source before we reassigned them, but let''s ignore that for the sake of
    this experiment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As `std::copy` is one of the simplest STL algorithms, its implementation is
    very short. Let''s have a look at how it could be implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This looks exactly as one would implement the copying of items from one iterable
    range to the other by hand, naively. At this point, one could also ask, "So why
    not implementing it by hand, the loop is simple enough and I don't even need the
    return value?", which is, of course, a good question.
  prefs: []
  type: TYPE_NORMAL
- en: 'While `std::copy` is not the best example for making code significantly shorter,
    a lot of other algorithms with more complex implementations are. What is not obvious
    is the hidden automatic optimization of such STL algorithms. If we happen to use
    `std::copy` with data structures that store their items in contiguous memory (as
    `std::vector` and `std::array` do), *and* the items themselves are *trivially
    copy assignable*, then the compiler will select a completely different implementation
    (which assumes the iterator types to be pointers):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is a simplified version of how the `memmove` variant of the `std::copy`
    algorithm can look in a typical STL implementation. It is *faster* than the standard
    loop version, and *this time*, it is also not as nice to read. But nevertheless,
    `std::copy` users automatically profit from it if their argument types comply
    with the requirements of this optimization. The compiler selects the fastest implementation
    possible for the chosen algorithm, while the user code nicely expresses *what*
    the algorithm does without tainting the code with too many details of the *how*.
  prefs: []
  type: TYPE_NORMAL
- en: STL algorithms often simply provide the best trade-off between *readability*
    and *optimal implementation*.
  prefs: []
  type: TYPE_NORMAL
- en: Types are usually trivially copy assignable if they only consist of one or multiple
    (wrapped by a class/struct) scalar types or classes, which can safely be moved
    using `memcopy`/`memmove` without the need to invoke a user-defined copy assignment
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: We also used `std::move`. It works exactly like `std::copy`, but it applies
    `std::move(*it)` to the source iterator in the loop in order to cast *lvalues*
    to *rvalues*. This makes the compiler select the move assignment operator of the
    target object instead of the copy assignment operator. For a lot of complex objects,
    this *performs* better but *destroys* the source object.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sorting values is quite a standard task, and it can be done in various ways.
    Every computer science student who was tortured with having to learn a majority
    of existing sorting algorithms (together with their performance and stability
    trade-offs for exams) knows that.
  prefs: []
  type: TYPE_NORMAL
- en: Because this is a solved problem, programmers should not waste their time in
    solving it *again*, except if it is for learning purposes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to play with `std::sort` and `std::partial_sort`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we include all that''s necessary and declare that we use the `std` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We will print the state of a vector of integers multiple times, so let''s abbreviate
    this task by writing a small procedure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We begin with a vector that contains some example numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we will shuffle the vector multiple times in order to play with different
    sort functions, we need a random number generator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `std::is_sorted` function tells us if the content of a container is sorted.
    This line should print `1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'With `std::shuffle`, we shake around the content of the vector in order to
    sort it again later. The first two arguments denote the range that will be shuffled
    and the third argument is the random number generator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `is_sorted` function should now return `false` so that `0` is printed,
    and the values in the vector should be the same but in a different order. We will
    see after we have printed both again to the shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we reestablish the original item ordering by using `std::sort`. The same
    prints to the terminal should now again give us the sorted ordering from the beginning:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Another interesting function is `std::partition`. Maybe, we do not want to
    fully sort the list because it is sufficient to just have the items that are smaller
    than some value at the front. So, let''s *partition* the vector in order to move
    all the items that are smaller than `5` to the front and print it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The next sort-related function is `std::partial_sort`. We can use it to sort
    the content of a container, but only to some extent. It will put the `N` smallest
    of all vector elements in the first half of the vector in a sorted order. The
    rest will reside in the second half, which will not be sorted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'What if we want to sort a data structure that has *no* comparison operator?
    Let''s define one and make a vector of such items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `std::sort` function optionally accepts a comparison function as its third
    argument. Let''s use that and provide it with such a function. Just to show that
    this is possible, we compare them by their *second* field, `b`. This way, they
    will appear in the order of `mystruct::b` and not `mystruct::a`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step is printing the sorted vector of `mystruct` items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Let's compile and run our program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first `1` results from the `std::is_sorted` call after initializing the
    sorted vector. Then, we shuffled the vector and got a `0` from the second `is_sorted`
    call. The third line shows all the vector items after the shuffling. The next
    `1` is the result of the `is_sorted` call after sorting it again with `std::sort`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we shuffled the whole vector again and *partitioned* it using `std::partition`.
    We can see that all the items that are less than `5` are also to the left of `5`
    in the vector. All items that are greater than `5` are to its right. Apart from
    that, they seem shuffled.
  prefs: []
  type: TYPE_NORMAL
- en: The second last line shows the result of `std::partial_sort`. All items up to
    the middle appear strictly sorted but the rest do not.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the last line, we can see our vector of `mystruct` instances. They are strictly
    sorted by their *second* member values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have used different algorithms, which have to do with sorting:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Algorithm** | **Purpose** |'
  prefs: []
  type: TYPE_TB
- en: '| `std::sort` | Accepts a range as arguments and simply sorts it. |'
  prefs: []
  type: TYPE_TB
- en: '| `std::is_sorted` | Accepts a range as argument and tells *if* that range
    is sorted. |'
  prefs: []
  type: TYPE_TB
- en: '| `std::shuffle` | This is, kind of, the *reverse* operation to sorting; it
    accepts a range as arguments and *shuffles* its items around. |'
  prefs: []
  type: TYPE_TB
- en: '| `std::partial_sort` | Accepts a range as arguments and another iterator,
    which tells until where the input range should be sorted. Behind that iterator,
    the rest of the items appear unsorted. |'
  prefs: []
  type: TYPE_TB
- en: '| `std::partition` | Accepts a range and a *predicate function*. All items
    for which the predicate function returns `true` are moved to the front of the
    range. The rest is moved to the back. |'
  prefs: []
  type: TYPE_TB
- en: For objects that do not have a comparison operator `<` implementation, it is
    possible to provide custom comparison functions. These should always have a signature
    such as `bool function_name(const T &lhs, const T &rhs)` and should not have any
    side effects during execution.
  prefs: []
  type: TYPE_NORMAL
- en: There are also other algorithms such as `std::stable_sort`, which also sort
    but preserve the order of items with the same sort key and `std::stable_partition`.
  prefs: []
  type: TYPE_NORMAL
- en: '`std::sort` has different implementations for sorting. Depending on the nature
    of the iterator arguments, it is implemented as selection sort, insertion sort,
    merge sort, or completely optimized for a smaller number of items. On the user
    side, we usually do not even need to care.'
  prefs: []
  type: TYPE_NORMAL
- en: Removing specific items from containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Copying, transforming, and filtering are perhaps the most common operations
    on ranges of data. In this section, we concentrate on filtering items.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering items out of data structures, or simply removing specific ones, works
    completely differently for different data structures. In linked lists (such as
    `std::list`), for example, a node can be removed by making its predecessor point
    to its successor. After a node is removed from the link chain in this way, it
    can be given back to the allocator. In contiguously storing data structures (`std::vector`,
    `std::array`, and, to some extent, `std::deque`), items can only be removed by
    overwriting them with other items. If an item slot is marked to be removed, all
    the items that are behind it must be moved one slot further to the front in order
    to fill the gap. This sounds like a lot of hassle, but if we want to simply remove
    whitespace from a string, for example, this should be achievable without much
    code.
  prefs: []
  type: TYPE_NORMAL
- en: When having either data structure at hand, we do not really want to care *how*
    to remove an item. It should just happen. This is what `std::remove` and `std::remove_if`
    can do for us.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will transform a vector''s content by removing items in different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s import all the needed headers and declare that we use the `std` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'A short print helper function will print our vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll begin with an example vector containing some simple integer values.
    We''ll also print it, so we can see how it changes with the function we apply
    to it later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s remove all the items with the value `2` from the vector. `std::remove`
    moves the other items in a way that the one value `2` we actually have in the
    vector vanishes. Because the vector''s actual content is shorter after removing
    items, `std::remove` returns us an iterator pointing to the *new end*. The items
    between the new end iterator and the old end iterator are to be considered garbage,
    so we tell the vector to *erase* them. We surround the two removal lines with
    a new scope because the `new_end` iterator is invalidated afterward anyway, so
    it can go out of scope immediately:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s remove all the *odd* numbers. In order to do so, we implement a
    predicate, which tells us if a number is odd and feed it into the `std::remove_if`
    function, which accepts such predicates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The next algorithm we try out is `std::replace`. We use it to overwrite all
    values of `4` with the value `123`. The `std::replace` function also exists as
    `std::replace_if`, which also accepts predicate functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s pump completely new values into the vector and create two new empty
    vectors in order to do another experiment with those:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we implement a predicate for odd numbers again and another predicate
    function, which tells the opposite if a number is even:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The next two lines do exactly the same thing. They copy *even* values to the
    vectors, `v2` and `v3`. The first line does this with the `std::remove_copy_if`
    algorithm, which copies everything from a source container to another container
    which does *not* fulfill the predicate constraint. The other line uses `std::copy_if`,
    which copies everything that *does* fulfill the predicate constraint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing both the vectors should now result in the same output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Let's compile and run the program. The first output line shows the vector after
    its initialization. The second line shows it after removing all the values of
    `2`. The next line shows the result of removing all the odd numbers. Before the
    fourth line, we replaced all the values of `4` with `123`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The last two lines show vectors `v2` and `v3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have used different algorithms, which have to do with filtering:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Algorithm** | **Purpose** |'
  prefs: []
  type: TYPE_TB
- en: '| `std::remove` | Accepts a range and a value as arguments and removes any
    occurrence of the value. Returns a new end iterator of the modified range. |'
  prefs: []
  type: TYPE_TB
- en: '| `std::replace` | Accepts a range and two values as arguments and replaces
    all the occurrences of the first value with the second value. |'
  prefs: []
  type: TYPE_TB
- en: '| `std::remove_copy` | Accepts a range, an output iterator, and a value as
    arguments and copies all the values that are *not* equal to the given value from
    the range to the output iterator. |'
  prefs: []
  type: TYPE_TB
- en: '| `std::replace_copy` | Works similar to `std::replace` but analogous to `std::remove_copy`.
    The source range is not altered. |'
  prefs: []
  type: TYPE_TB
- en: '| `std::copy_if` | Works like `std::copy` but additionally accepts a predicate
    function as an argument in order to copy only the values that the predicate accepts,
    which makes it a *filter* function. |'
  prefs: []
  type: TYPE_TB
- en: For every one of the listed algorithms, there also exists an `*_if` version,
    which accepts a predicate function instead of a value, which then decides which
    values are to be removed or replaced.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming the contents of containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If `std::copy` is the simplest STL algorithm for application on ranges, `std::transform`
    is the second simplest STL algorithm. Just as `copy`, it copies items from one
    range to another but additionally accepts a transformation function. This transformation
    function can alter the value of the input type before it is assigned to an item
    in the destination range. Furthermore, it can even construct a completely different
    type, which is useful if the source range and destination range differ in their
    payload item types. It is simple to use but still very useful, which makes it
    an ordinary standard component used in portable day-to-day programs.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to use `std::transform` in order to modify the
    items of a vector while copying them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, we first need to include all the necessary headers and to spare
    us some typing, we declare that we use the `std` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'A vector with some simple integers will do the job as an example source data
    structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we copy all the items to an `ostream_iterator` adapter in order to print
    them. The `transform` function accepts a function object, which accepts items
    of the container payload type and transforms them during each copy operation.
    In this case, we calculate the *square* of each number item, so the code will
    print the squares of the items in the vector without us having to store them anywhere:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s do another transformation. From the number `3`, for example, we could
    generate a nicely readable string such as `3^2 = 9`. The following `int_to_string`
    function object does just that using the `std::stringstream` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The function we just implemented returns us string values from integer values.
    We could also say it *maps* from integers to strings. Using the `transform` function,
    we can copy all such mappings from the integer vector into a string vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'After printing those, we''re done:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compile and run the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `std::transform` function works exactly like `std::copy` but while copy-assigning
    the values from the source iterator to the destination iterator, it applies the
    user-provided transformation function to the value before assigning the result
    to the destination iterator.
  prefs: []
  type: TYPE_NORMAL
- en: Finding items in ordered and unordered vectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, we need to tell *if* some kind of item exists within some range. And
    if it does, we often also need to modify it or to access other data associated
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: There are different strategies for finding items. If the items are present in
    a sorted order, then we can do a binary search, which is faster than linearly
    going through the items one by one. If it is not sorted, we are stuck with linear
    traversal again.
  prefs: []
  type: TYPE_NORMAL
- en: The typical STL search algorithms can do both for us, so it's good to know them
    and their characteristics. This section is about the simple linear search algorithm
    `std::find`, the binary search version `std::equal_range`, and their variants.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to use linear and binary search algorithms on
    a small example data set:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first include all the necessary headers and declare that we use the `std`
    namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Our data set will consist of `city` structs, which just save a city''s name,
    and its population count:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Search algorithms need to be able to compare one item to the other, so we overload
    the `==` operator for the `city` struct instances:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We also want to print the `city` instances, so we overload the stream operator,
    `<<`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Search functions typically return iterators. These iterators point to the item
    if they found it or, otherwise, to the end iterator of the underlying container.
    In the last case, we are not allowed to access such an iterator. Because we are
    going to print our search results, we implement a function that returns us another
    function object, which encapsulates the end iterator of a data structure. When
    used for printing, it will compare its iterator argument against the end iterator
    and then print the item or, otherwise, just `<end>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We start with an example vector of some German cities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this helper, we build a city printer function, which captures the end
    iterator of our city vector `c`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We use `std::find` to find the item in the vector, which saves the city item
    of Cologne. At first, this search looks pointless because we get exactly the item
    we searched for. But we did not know its position in the vector before, and the
    `find` function returns us just that. However, we could, for example, make the
    operator `==` of the `city` struct that we overloaded only compare the city name,
    then we could search just using the city name, without even knowing its population.
    But that would not be a good design. In the next step, we will do it differently:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Without knowing the population count of a city, and also without tampering
    with its `==` operator, we can search only by comparing its name with the vector''s
    content. The `std::find_if` function accepts a predicate function object instead
    of a specific value. This way, we can search for the Cologne city item when we
    only know its name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to make searching a bit prettier and expressive, we can implement
    predicate builders. The `population_higher_than` function object accepts a population
    size and returns us a function that tells if a `city` instance has a larger population
    than the captured value. Let''s use it to search for a German city with more than
    two million inhabitants in our small example set. Within the given vector, that
    city is only Berlin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The search functions we just used, traverse our containers linearly. Thus they
    have a runtime complexity of *O(n)*. The STL also has binary search functions,
    which work within *O(log(n))*. Let''s generate a new example data set, which just
    consists of some integer values, and build another `print` function for that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The `std::binary_search` function returns boolean values and just tells us
    *if* it found an item, but it does *not* return the item itself. It is important
    that the container we are searching in is *sorted* because otherwise, binary search
    doesn''t work correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to get the items we are searching for, we need other STL functions.
    One of them is `std::equal_range`. It does not return an iterator for the item
    we found, but a *pair* of iterators. The first iterator points to the first item
    that is *not smaller* than the value we''ve been looking for. The second iterator
    points to the first item that is *larger* than it. In our range, which goes from
    `1` to `10`, the first iterator points to the actual `7`, because it is the first
    item, that is not smaller than `7`. The second iterator points to the `8` because
    it''s the first item that is larger than `7`. If we had multiple values of `7`,
    both the iterators would, in fact, represent a *subrange* of items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If we just need one iterator; we can use `std::lower_bound` or `std::upper_bound`.
    The `lower_bound` function only returns an iterator to the first item that is
    not smaller than what we searched. The `upper_bound` function returns an iterator
    to the first item that is larger than what we searched for:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compile and run the program to see if the output matches our assumptions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are the search algorithms we have used in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Algorithm** | **Purpose** |'
  prefs: []
  type: TYPE_TB
- en: '| `std::find` | Accepts a search range and a comparison value as arguments.
    Returns an iterator that points to the first item equal to the comparison value.
    Searches linearly. |'
  prefs: []
  type: TYPE_TB
- en: '| `std::find_if` | Works like `std::find` but uses a predicate function instead
    of a comparison value. |'
  prefs: []
  type: TYPE_TB
- en: '| `std::binary_search` | Accepts a search range and a comparison value as arguments.
    Performs a binary search and returns `true` if the range contains that value.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `std::lower_bound` | Accepts a search range and a comparison value, and then
    performs a binary search for the first item that is *not smaller* than the comparison
    value. Returns an iterator pointing to that item. |'
  prefs: []
  type: TYPE_TB
- en: '| `std::upper_bound` | Works like `std::lower_bound` but returns an iterator
    to the first item that is *larger* than the comparison value. |'
  prefs: []
  type: TYPE_TB
- en: '| `std::equal_range` | Accepts a search range and a comparison value and, then,
    returns a pair of iterators. The first iterator is the result of `std::lower_bound`
    and the second iterator is the result of `std::upper_bound`. |'
  prefs: []
  type: TYPE_TB
- en: All these functions accept custom comparison functions as an optional additional
    argument. This way, the search can be customized, as we did in the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a closer look at how `std::equal_range` works. Imagine that we
    have a vector, `v = {0, 1, 2, 3, 4, 5, 6, 7, 7, 7, 8}`, and call `equal_range(begin(v),
    end(v), 7);` in order to perform a binary search for the value `7`. As `equal_range`
    returns us a pair of lower bound and upper bound iterators, these should afterward
    denote the range `{7, 7, 7}`, as there are so many values of `7` in the sorted
    vector. Check out the following diagram for more clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e00c5a5-38e8-4902-95ad-566642ea317b.png)'
  prefs: []
  type: TYPE_IMG
- en: At first, `equal_range` uses the typical binary search approach until it trips
    into the range of values *not smaller* than the search value. Then, it splits
    up to a `lower_bound` call and an `upper_bound` call in order to bundle their
    return values in a pair as the return value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to get a binary search function, which just returns the first item
    that fits the requirements, we could implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This function uses `std::lower_bound` in order to find the first item not smaller
    than `value`. The resulting `potential_match` can then have three different cases
    it points to:'
  prefs: []
  type: TYPE_NORMAL
- en: No item is not smaller than `value`. In this case, it is identical to `end_it`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first item that is not smaller than `value` is also *larger* than `value`.
    Therefore we must signal that we did *not* find it by returning `end_it`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The item that `potential_match` points to is equal to `value`. So, it is not
    only a *potential* match, but it is an *actual* match. Therefore we can return
    it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If our type `T` does not support the `==` operator, it must at least support
    the `<` operator for the binary search. Then, we can rewrite the comparison to
    `!(value < *potential_match) && !(*potential_match < value)`. If it is neither
    smaller, nor larger, then it must be equal.
  prefs: []
  type: TYPE_NORMAL
- en: One potential reason why the STL does not provide such a function out of the
    box is the missing knowledge about the possibility that there are multiple hits,
    as in the diagram where we have multiple values of `7`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that data structures such as `std::map`, `std::set`, and so on have their
    *own* `find` functions. These are, of course, faster than the more general algorithms
    because they are tightly coupled with the data structure's implementation and
    data representation.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting the values of a vector to a specific numeric range with std::clamp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a lot of applications, we get numeric data from somewhere. Before we can
    plot or otherwise process it, it may need to be normalized because the values
    differ randomly far from each other.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, this would mean a little `std::transform` call over the data structure
    that holds all these values, combined with a simple *scaling* function. But if
    we *do not know* how large or small the values are, we need to go through the
    data first in order to find the right *dimensions* for the scaling function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The STL contains useful functions for this purpose: `std::minmax_element` and
    `std::clamp`. Using these and combining them with some lambda expression glue,
    we can perform such a task easily.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will normalize the values of a vector from an example numeric
    range to a normalized one in two different ways, one of them using `std::minmax_element`
    and one using `std::clamp`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, we first need to include the following headers and declare that
    we use the `std` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We implement a function for later use, which accepts the minimum and maximum
    values of a range, and a new maximum so that it can project values from the old
    range to a smaller range that we want to have. The function object takes such
    values and returns another function object, which does exactly that transformation.
    For the sake of simplicity, the new minimum is `0`, so no matter what offset the
    old data had, its normalized values will always be relative to `0`. For the sake
    of readability, we ignore the possibility that `max` and `min` could be of the
    same value, which would lead to a division by zero:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Another function object builder called `clampval` returns a function object
    that captures the `min` and `max` values and calls `std::clamp` on values with
    those values, in order to limit their values to this range:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The data we are going to normalize is a vector of varying values. This could
    be, for example, some kind of heat data, landscape height, or stock prices over
    time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to be able to normalize the data, we need the *highest* and *lowest*
    values. The `std::minmax_element` function is of a great help here. It returns
    us a pair of iterators to exactly those two values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We will copy all the values from the first vector to a second one. Let''s instantiate
    the second vector and prepare it to accept as many new items as we have in the
    first vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `std::transform`, we copy the values from the first vector to the second.
    While copying the items, they will be transformed with our normalization helper.
    The minimum and maximum values of the old vector are `0` and `1000`. The minimum
    and maximum values after normalization are `0` and `255`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we implement the other normalization strategy, we print what we have
    by now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We reuse the same normalized vector with the other helper `clampval`, which
    *clamps* the old range to the range with the minimum of `0` and the maximum of
    `255`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'After printing these values too, we''re done:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compile and run the program. Having the values reduced to values from
    `0` to `255`, we could use them as brightness values for RGB color codes, for
    example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'When we plot the data, we get the following graphs. As we can see, the approach
    where we *divide* the values by the difference between the min and max values
    is a linear transformation of the original data. The *clamped* graph loses some
    information. Both variations can be useful in different situations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f35fa700-2874-4d52-a587-32e53adebcf0.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apart from `std::transform` we used two algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::minmax_element` simply accepts the begin and end iterators of an input
    range. It loops through the range and records the largest and the smallest element
    on the way to its end. These values are returned in a pair, which we then used
    for our scaling function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `std::clamp` function, in contrast, does not operate on an iterable range.
    It accepts three values: an input value, a min value, and a max value. The output
    of this function is the input value cut-off in a way that it lies between the
    allowed minimum and maximum. We could also write `max(min_val, min(max_val, x))`
    instead of `std::clamp(x, min_val, max_val)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Locating patterns in strings with std::search and choosing the optimal implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Searching for a string in a string is a slightly different problem than finding
    *one* object in a range. On the one hand, a string is, of course, an iterable
    range (of characters) too. On the other hand, finding a string in a string means
    finding a range in *another* range. And this comes along with multiple comparisons
    per potential match position, so we need some other algorithm for that.
  prefs: []
  type: TYPE_NORMAL
- en: '`std::string` already contains a `find` function, which can do exactly what
    we are talking about; nevertheless we''ll concentrate on `std::search` in this
    section. Although `std::search` might be used on strings mostly, it works on all
    kinds of containers. The more interesting feature of `std::search` is that since
    C++17, it has a slightly different additional interface and allows for simply
    exchanging the search algorithm itself. These algorithms are optimized and can
    be freely chosen by the user, depending on what is better in which use case. Additionally,
    we could implement our own search algorithms and plug them into `std::search`
    if we ever come up with anything better than what is already provided.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the new `std::search` function with strings and try its different
    variations with searcher objects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will include all the necessary headers and declare that we use the
    `std` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We will print substrings from the positions the search algorithm returns to
    us, so let''s implement a little helper for that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'A *lorem-ipsum style* string will work as our example string, within which
    we will search a substring. In this case, this is `"elitr"`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The old `std::search` interface accepts the begin/end iterators of the string
    within which we are searching a specific substring and the begin/end iterators
    of the substring. It then returns an iterator pointing to the substring it was
    able to find. If it didn''t find the string, the returned iterator will be the
    end iterator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The C++17 version of `std::search` does not accept two pairs of iterators but
    one pair of begin/end iterators and a *searcher* object. The `std::default_searcher`
    takes the begin/end pair of iterators of the substring that we are searching for
    in the larger string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The point of this change is that it is easy to switch the search algorithm
    this way. The `std::boyer_moore_searcher` uses the *Boyer-Moore search algorithm*
    for a faster search:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The C++17 STL comes with three different searcher object implementations. The
    third one is the B*oyer-Moore-Horspool search algorithm* implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compile and run our program. We should see the same string everywhere
    if it runs correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We utilized four different ways to use `std::search` in order to get exactly
    the same result. Which one should we prefer in what situation?
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume our large string within which we search the pattern is called `s`,
    and the pattern is called `p`. Then, `std::search(begin(s), end(s), begin(p),
    end(p));` and `std::search(begin(s), end(s), default_searcher(begin(p), end(p));`
    do exactly the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other searcher function objects are implemented with more sophisticated
    search algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::default_searcher`: This redirects to legacy `std::search` implementation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::boyer_moore_searcher`: This uses the *Boyer-Moore* search algorithm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::boyer_moore_horspool_searcher`: This analogously uses the *Boyer-Moore-Horspool*
    algorithm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What makes the other algorithms so special? The Boyer-Moore algorithm was developed
    with a specific idea--the search pattern is compared with the string, beginning
    at the pattern''s *end*, from right to left. If the character in the search string
    *differs* from the character in the pattern at the overlay position and does *not
    even occur* in the pattern, then it is clear that the pattern can be shifted over
    the search string by its *full length*. Have a look at the following diagram,
    where this happens in step 1\. If the character being currently compared differs
    from the pattern''s character at this position but is *contained* by the pattern,
    then the algorithm knows by how many characters the pattern needs to be shifted
    to the right in order to correctly align to at least that character, and then,
    it starts over with the right-to-left comparison. In the diagram, this happens
    in step 2\. This way, the Boyer-Moore algorithm can omit a whole lot of *unnecessary*
    comparisons, compared with a naive search implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2cefec94-bb6d-48ce-af86-cb86df918853.png)'
  prefs: []
  type: TYPE_IMG
- en: Of course, this would have become the new default search algorithm if it hadn't
    brought its own *trade-offs*. It is faster than the default algorithm, but it
    needs fast lookup data structures in order to determine which characters are contained
    in the search pattern and at which offset they are located. The compiler will
    select differently complex implementations of those, depending on the underlying
    types of which the pattern consists (varying between hash maps for complex types
    and primitive lookup tables for types such as `char`). In the end, this means
    that the default search implementation will be faster if the search string is
    not too large. If the search itself takes some significant time, then the Boyer-Moore
    algorithm can lead to performance gains in the dimension of a *constant factor*.
  prefs: []
  type: TYPE_NORMAL
- en: The **Boyer-Moore-Horspool** algorithm is a simplification of the Boyer-Moore
    algorithm. It drops the *bad character* rule, which leads to shifts of the whole
    pattern width if a search string character that does not occur in the pattern
    string is found. The trade-off of this decision is that it is *slightly slower*
    than the unmodified version of Boyer-Moore, but it also needs *fewer data structures*
    for its operation.
  prefs: []
  type: TYPE_NORMAL
- en: Do not try to *reason* about which algorithm *should* be faster in a specific
    case. Always *measure* the performance of your code with data samples that are
    typical for your users and base your decision on the *results*.
  prefs: []
  type: TYPE_NORMAL
- en: Sampling large vectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When there are *very* large amounts of numeric data that need to be processed
    in some situations, it may not be possible to process it all in feasible time.
    In such situations, the data could be *sampled* in order to reduce the total amount
    of data for further processing, which then *speeds up* the whole program. In other
    situations, this might be done not to reduce the amount of work for processing
    but for *saving* or *transferring* the data.
  prefs: []
  type: TYPE_NORMAL
- en: A naive idea of sampling could be to only pick every *N^(th)* data point. This
    might be fine in a lot of cases, but in signal processing, for example, it *could*
    lead to a mathematical phenomenon called **aliasing**. If the distance between
    every sample is varied by a small random offset, aliasing can be reduced. Have
    a look at the following diagram, which shows an *extreme case* just to illustrate
    the point--while the original signal consists of a sine wave, the triangle points
    on the graph are sampling points that are sampled at exactly every *100th* data
    point. Unfortunately, the signal has the *same y-value* at these points! The graph
    which results from connecting the dots looks like a perfectly straight *horizontal
    line*. The square points, however, show what we get when we sample every `100
    + random(-15, +15)` points. Here, the signal still looks very different from the
    original signal, but it is at least not completely *gone* as in the fixed step
    size sampling case.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `std::sample` function does not add random alterations to sample points
    with fixed offset but chooses completely random points; therefore, it works a
    bit differently from this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f2aae52-6c69-479c-9d10-af4a807faf4e.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will sample a very large vector of random data. This random data shows a
    normal distribution. After sampling it, the resulting points should still show
    a normal distribution, which we will check:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to include everything we use and declare that we use the `std`
    namespace in order to spare us some typing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'It is easier to play around with the code if we configure specific characteristics
    of our algorithm in their own constant variables. These are the size of the large
    random vector and the number of samples that we are going to take from it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The large, randomly filled vector should get numbers from a random number generator,
    which gives out numbers from a normal distribution. Any normal distribution can
    be characterized by the mean value and the standard deviation from the mean value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we set up the random generator. First, we instantiate a random device
    and call it once to get a seed for the constructor of a random generator. Then,
    we instantiate a distribution object that applies normal distribution to the random
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we instantiate a vector of integers and fill it with a lot of random numbers.
    This is achieved using the `std::generate_n` algorithm, which will call a generator
    function object to feed its return value into our vector using a `back_inserter`
    iterator. The generator function object just wraps around the `d(gen)` expression,
    which gets a random number from the random device and feeds it into the distribution
    object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we instantiate another vector that will contain the much smaller set of
    samples:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The `std::sample` algorithm works similar to `std::copy`, but it takes two
    additional parameters: the *number of samples*, which it shall take from the input
    range, and a *random number generator* object, which it will consult to get random
    sampling positions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re already done with the sampling. The rest of the code is for displaying
    purposes. The input data has a normal distribution, and if the sampling algorithm
    works well, then the sampled vector should show a normal distribution too. To
    see how much of a normal distribution is left, we will print a *histogram* of
    the values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we loop over all the items in order to print our histogram:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'After compiling and running the program, we see that the sampled vector still
    roughly shows the characteristics of a normal distribution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/429739c2-32fd-4b71-8557-d1af399d9b7d.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `std::sample` algorithm is a new algorithm, which came with C++17\. Its
    signature looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The input range is denoted by the `first` and `last` iterators, while `out`
    is the output operator. These iterators have exactly the same function as in `std::copy`;
    items are copied from one range to the other. The `std::sample` algorithm is special
    in the regard that it will copy only a part of the input range because it samples
    only `n` items. It uses uniform distribution internally, so every data point in
    the source range gets chosen with the same probability.
  prefs: []
  type: TYPE_NORMAL
- en: Generating permutations of input sequences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When testing code that must deal with sequences of inputs where the order of
    the arguments is not important, it is beneficial to test whether it results in
    the same output for *all* possible permutations of that input. Such a test could,
    for example, check whether a self-implemented *sort* algorithm sorts correctly.
  prefs: []
  type: TYPE_NORMAL
- en: No matter for what reason we need all permutations of some value range, `std::next_permutation`
    can conveniently do it for us. We can invoke it on a modifiable range, and it
    changes the *order* of its items to the next *lexicographical permutation*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will write a program that reads multiple word strings from
    a standard input, and then we will use `std::next_permutation` to generate and
    print all the permutations of those strings:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First things first again; we include all the necessary headers and declare
    that we use the `std` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'We begin with a vector of strings, which we feed with the whole standard input.
    The next step is *sorting* the vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we print the vector''s content on the user terminal. Afterward, we call
    `std::next_permutation`. It systematically shuffles the vector to generate a permutation
    of its items, which we then print again. The `next_permutation` will return `false`
    as soon as the *last* permutation was reached:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compile and run the function with some example input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `std::next_permutation` algorithm is a bit weird to use. This is because
    it accepts only a begin/end pair of iterators and then returns `true` if it is
    able to find the next permutation. Otherwise, it returns `false`. But what does
    the *next permutation* even mean?
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm with which `std::next_permutation` finds the next lexicographical
    order of the items, works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the largest index `i` such that `v[i - 1] < v[i]`. If there is none, then
    return `false`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, find the largest index `j` such that `j >= i` and `v[j] > v[i - 1]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Swap* the items at position `j` and position `i - 1`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reverse the order of the items from position `i` to the end of the range.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The individually permuted orders we get out of this will always appear in the
    same sequence. In order to see all the possible permutations, we sorted the array
    first, because if we entered `"c b a"`, for example, the algorithm would terminate
    *immediately*, as this already *is* the last lexicographic order of the elements.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a dictionary merging tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that we have a sorted list of things, and someone else comes up with
    *another* sorted list of things, and we want to share the lists with each other.
    The best idea is to combine both the lists. The combination of both the lists
    should be sorted too, as this way, it is easy to look it up for specific items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Such an operation is also called a **merge**. In order to merge two sorted
    ranges of items, we would intuitively create a new range and feed it with items
    from both the lists. For every item transfer, we would have to compare the frontmost
    items of our input ranges in order to always select the *smallest* one from what
    is left from the input. Otherwise, the output range would not be sorted any longer.
    The following diagram illustrates it better:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6528449-cc62-4b3f-b4bd-1900646d9175.png)'
  prefs: []
  type: TYPE_IMG
- en: The `std::merge` algorithm can do exactly that for us, so we do not need to
    fiddle around too much. In this section, we will see how to use the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to build up a cheap dictionary of one-to-one mappings from English
    words to their German translations, and store them in `std::deque` structures.
    The program will read such a dictionary from a file and one from standard input,
    and print one large merged dictionary on the standard output again.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a lot of headers to include this time, and we declare that we use
    the `std` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'A dictionary entry should consist of a symmetric mapping from a string in one
    language to a string in another language:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to both print such pairs to the terminal and read them from user
    input, so we need to overload the `<<` and `>>` operators:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'A helper function that accepts any input stream object will help us in building
    a dictionary from it. It constructs `std::deque` of dictionary entry pairs, and
    they are all read from the input stream until it is empty. Before returning it,
    we sort it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'We create two individual dictionary data structures from different input streams.
    One input stream is opened from the `dict.txt` file, which we assume to exist.
    It contains word pairs, line by line. The other stream is the standard input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'As the helper function, `from_instream`, has already sorted both the dictionaries
    for us, we can feed them directly into the `std::merge` algorithm. It accepts
    two input ranges via its begin/end iterator pairs, and one output. The output
    will be the user shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'We can compile the program now, but before running it, we should create the
    `dict.txt` file with some example content. Let''s fill it with some English words
    and their translations to German:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can launch the program while piping some English-German translations
    into its standard input. The output is a merged and still sorted dictionary, which
    contains the translations of both the inputs. We could create a new dictionary
    file from that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `std::merge` algorithm accepts two pairs of begin/end iterators, which denote
    the input ranges. These ranges must be *sorted*. The fifth parameter is an output
    iterator that accepts the incoming items during the merge.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a variant called `std::inplace_merge`. This algorithm does the
    same as the other, but it does not need an output iterator because it works *in
    place*, as the name already suggests. It takes three parameters: a *begin* iterator,
    a *middle* iterator, and an *end* iterator. These iterators must all reference
    data in the same data structure. The middle iterator is at the same time the end
    iterator of the first range, and the begin iterator of the second range. This
    means that this algorithm handles a single range, which actually consists of two
    consecutive ranges, such as, for example, `{A, C, B, D}`. The first subrange is
    `{A, C}` and the second subrange is `{B, D}`. The `std::inplace_merge` algorithm
    can then merge both within the same data structure, which results in `{A, B, C,
    D}`.'
  prefs: []
  type: TYPE_NORMAL
