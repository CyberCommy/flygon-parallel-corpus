- en: Chapter 6. But I Wanna REST Mom, Now!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: REST is an architectural style that has been gaining momentum these last few
    years due to its many features and architectural constraints such as cacheability,
    stateless behavior, and its interface requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a nice overview of REST architecture, refer to [http://www.drdobbs.com/Web-development/restful-Web-services-a-tutorial/240169069](http://www.drdobbs.com/Web-development/restful-Web-services-a-tutorial/240169069)
    and [http://en.wikipedia.org/wiki/Representational_state_transfer](http://en.wikipedia.org/wiki/Representational_state_transfer).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our focus in this chapter will be on RESTful Web Services and APIs—that is,
    Web services and Web APIs following the REST architecture. Let''s start at the
    beginning: what is a Web service?'
  prefs: []
  type: TYPE_NORMAL
- en: A Web service is a Web application that can be consulted by your application
    as if it was an API, improving the user experience. If your RESTful Web service
    does not need to be called from a traditional UI interface, and may be used standalone,
    then what you have is a **RESTful Web Service API**, "RESTful API" for short,
    that works just like a regular API, but through a Web server.
  prefs: []
  type: TYPE_NORMAL
- en: A call to a Web service could, for example, start a batch process, update the
    database, or just retrieve some data. There is no restriction imposed on what
    a service may perform.
  prefs: []
  type: TYPE_NORMAL
- en: RESTful Web services should be accessible through a **URI** (like a URL) and
    may be accessed by any Web protocol, although **HTTP** is the king here. Because
    of that, we'll focus on **HTTP**. Our Web service response, also called a resource,
    may have any desired format; as TXT, XML, or JSON, but the most common format
    is JSON, as it is very simple to use. We'll also focus on JSON. When using HTTP
    with Web services, a common practice is to use the HTTP default methods (`GET`,
    `POST`, `PUT`, `DELETE`, and `OPTIONS`) to give more information to the server
    about what we want to achieve. This technique allows us to have different functionality
    within the same service.
  prefs: []
  type: TYPE_NORMAL
- en: A service call to `http://localhost:5000/age` could return the user's age through
    a `GET` request, or remove its value through a `DELETE` request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what each *usually used* method is *usually* used for:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`: This is used to retrieve a resource. You want information? No database
    update? Use GET!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`: This is used to insert new data into the server, such as adding a new
    employee in your database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`: This is used to update data on the server. You have an employee that
    decided to change his nickname in the system? Use `PUT` to do that!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: This is your best method for getting rid of data on your server!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OPTIONS`: This is used to ask a service which methods it supports.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lots of theory so far; let's put it into practice with a Flask-powered REST
    Web Service example.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install the required library for the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, on to the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we create a Web service to consult articles using
    a GET request. The `jsonify` function is introduced, as it is used to serialize
    Python objects into Flask JSON responses. We also use the marshmallow library
    to serialize SQLAlchemy results into Python dictionaries, as there is no native
    API for such.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s discuss the example, step-by-step:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we create our app and configure our SQLAlchemy extension. We then define
    the `Article` model, which will hold our article data, and an ArticleSchema, which
    allows marshmallow to serialize our articles. We have to define in the Schema
    Meta, which fields should be serialized. `article_schema` is our schema instance
    used to serialize single articles while `articles_schema` serializes article collections.
  prefs: []
  type: TYPE_NORMAL
- en: Our articles view has two routes defined, one for article listing and another
    for article detail, which returns a single article.
  prefs: []
  type: TYPE_NORMAL
- en: Inside it, if `article_id` is provided, we serialize and return the requested
    article. If `article_id` does not have a corresponding record in the database,
    we return a message with the given error and the HTTP code 404, indicating a "not
    found" status. If `article_id` is `None`, we serialize and return 10 articles.
    You might ask, Why not return all the articles in the database? If we have 10,000
    articles in the database and try to return that many, our server will certainly
    have a problem; thus, avoid returning everything from the database.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of service is usually consumed by Ajax requests made using JavaScript
    such as jQuery or PrototypeJS. When sending Ajax requests, these libraries add
    a special header that allows us to identify whether the given request is actually
    an Ajax request. In our preceding example, we serve the JSON response to all GET
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't know Ajax? Visit [http://www.w3schools.com/Ajax/ajax_intro.asp](http://www.w3schools.com/Ajax/ajax_intro.asp).
  prefs: []
  type: TYPE_NORMAL
- en: 'We could be more selective and only send JSON responses to Ajax requests. Regular
    requests will receive plain HTML responses. To do that, we would have to make
    a slight change in our view, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `request` object has an attribute called `is_xhr` that you can check to
    see if the request is actually an Ajax request. Our preceding code will probably
    look better if we have it split into a few functions, such as a function to respond
    to Ajax requests and another to respond to plain HTTP requests. Why don't you
    try refactoring the code?
  prefs: []
  type: TYPE_NORMAL
- en: 'Our last example could also have a different approach; we could render the
    HTML template without adding context variables to it but by loading all of our
    data through Ajax requests. In this scenario, the following changes to the code
    would be required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We added a new field `url` to our schema in order to access the path to the
    article page from within the JavaScript code, as we return a JSON document to
    the template, and not an SQLAlchemy object, and, therefore, cannot access the
    model methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `articles.html` file will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In our template, our article list is empty; we then populate it after calling
    our service with Ajax. If you test the full example, the Ajax request is so fast
    you might not even notice the page was loaded empty before being populated with
    Ajax.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond GET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we've had a few cozy examples with Ajax and RESTful Web services but
    we have yet to record data in our database using a service. How about trying that
    now?
  prefs: []
  type: TYPE_NORMAL
- en: Recording to the database using Web services is not much different from what
    we have done in the previous chapter. We'll receive data from an Ajax request,
    we will check which HTTP method was used in order to decide what to do, then we'll
    validate the sent data and save everything if no error was found. In [Chapter
    4](ch04.html "Chapter 4. Please Fill in This Form, Madam"), *Please Fill in This
    Form, Madam*, we talked about CSRF protection and its importance. We'll keep validating
    our data against CSRF with our Web service. The trick is to add the CSRF token
    to the form data being submitted. See the attached code provided with the eBook
    for the example HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how our view looks like with `POST`, `PUT`, and `REMOVE` method support:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Ok, it's true, we can't hide it any longer; dealing with Web services and plain
    HTML rendering in the same page can be kind of messy, as seen in the preceding
    example. Even if you split the function between other functions, by method, things
    might not look that good. The usual pattern is to have a view serving your Ajax
    requests and another serving your "normal" requests. You only mix both of them
    if convenient.
  prefs: []
  type: TYPE_NORMAL
- en: Flask-Restless
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flask-Restless is an extension capable of auto-generating a whole RESTful API
    for your SQLAlchemy models with support for `GET`, `POST`, `PUT`, and `DELETE`.
    Most Web services won't need more than that. Another advantage to using Flask-Restless
    is the chance to extend the auto-generated methods with authentication validation,
    custom behavior, and custom queries. This is a must-learn extension!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how our Web service would look with Flask-Restless. We''ll also
    have to install a new library for this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And then:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we create our model, as before; then we create a
    Flask-Restless API to hold all our model APIs; and then we create a Web service
    API for `Article` with the prefix `articles` and support for the methods `GET`,
    `POST`, `PUT`, and `DELETE`, each with the expected behavior: `GET` for consulting,
    `POST` for new records, `PUT` for updates, and `DELETE` for deletes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your console, type the following command to send a GET request to the API
    and test that your example is working:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As the Flask-Restless API is pretty extensive, we'll discuss briefly, a few
    common options that come in handy for most projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `serializer`/`deserializer` parameters for `create_api` are useful whenever
    you need custom serialization/deserialization for your models. The usage is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You could use marshmallow to generate the schema, as in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful set of options for `create_api` are `include_columns` and `exclude_columns`.
    They allow you to control how much data you want returned by your API and prevent
    sensitive data from being returned. When `include_columns` is set, only the fields
    defined in it are returned by GET requests. When `exclude_columns` is set, only
    the fields that are not defined in it are returned by `GET` requests. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned what REST is, its advantages, how to create Flask
    RESTful Web Services and APIs, and how to use Flask-RESTless to make the whole
    thing work well. We also had an overview on what jQuery is and how to use it to
    send Ajax requests to consult our services. These chapter examples were pretty
    intense. Try to code the examples yourself, to assimilate them better.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we''ll be talking about the one way in which you can assure
    software quality: tests! We''ll learn how to test our Web applications in the
    many ways that they may be tested and how to integrate these tests into our very
    coding routines. See you there!'
  prefs: []
  type: TYPE_NORMAL
