- en: Online Video Game Store with Django
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I was born in the late seventies, which means that I grew up during the birth
    of the video game industry. My first video game console was the Atari 2600, and
    it was because of that specific video game console that I decided that I wanted
    to be a programmer and make video games. I never got a job within the gaming industry,
    however, but I still love playing video games, and in, my spare time, I try to
    develop my own games.
  prefs: []
  type: TYPE_NORMAL
- en: To this day, I still go around the internet—especially eBay—buying old video
    games to bring back my nice childhood memories when all the family, my parents,
    and my sister, used to play Atari 2600 games together.
  prefs: []
  type: TYPE_NORMAL
- en: Because of my interest in vintage video games, we are going to develop a vintage
    video game online store; this will be a great way to develop something fun and
    also learn a lot about web development with the popular Django web framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Django project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Django apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the Django admin interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to create an application model and perform queries with the Django
    ORM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, as an extra, we will be using the **npm** (**Node Package Manager**) to
    download the client-side dependencies. We will also cover how to create simple
    tasks using the task runner Gulp.
  prefs: []
  type: TYPE_NORMAL
- en: To make our application prettier without a lot of effort, we are going to use
    Bootstrap.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the development environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As usual, we are going to start setting up the environment for development.
    In [Chapter 4](2223dee0-d5de-417e-9ca9-6bf4a6038cb6.xhtml), *Exchange Rates and
    the Currency Conversion Tool*, you were introduced to `pipenv`, so in this and
    the following chapters, we are going to be using `pipenv` to create our virtual
    environment and manage our dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we want to create the directory where we are going to keep our project.
    In your working directory, create a directory called `django-project` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can run `pipenv` to create our virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have Python 3 installed in another location, you can use the argument
    `--python` and specify the path where the Python executable is located. If everything
    went fine, you should see an output such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ade4540c-d7e8-469a-ac30-b921844e9030.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we can activate our virtual environment using the `pipenv` command shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Great! The only dependency that we are going to add for now is Django.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, Django 2.0 had been released. It has really
    nice features compared to its predecessor. You can see the list of new features
    at [https://docs.djangoproject.com/en/2.0/releases/2.0/](https://docs.djangoproject.com/en/2.0/releases/2.0/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s install Django in our virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Django 2.0 has dropped support for Python 2.0, so if you are planning to develop
    an application using Python 2, you should install Django 1.11.x or lower. I strongly
    recommend that you start a new project using Python 3\. Python 2 will stop being
    maintained after a couple of years, and new packages will be created for Python
    3\. Popular packages of Python 2 will migrate to Python 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'In my opinion, the best new feature of Django 2 is the new routing syntax,
    because now it is not necessary to write regular expressions. It is much cleaner
    and more readable to write something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous syntax relied more on regular expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It is much simpler this way. Another feature that I really like in Django 2.0
    is that they have improved the admin UI a little bit and made it responsive; this
    is a great feature, because I have experienced that creating a new user (while
    you are on the go with no access to a desktop) on a non-responsive site on a small
    mobile phone screen can be painful.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to web development, it is almost impossible to stay away from
    Node.js. Node.js is a project that was released back in 2009\. It is a JavaScript
    runtime that allows us to run JavaScript on the server-side. Why do we care about
    Node.js if we are developing a website using Django and Python? The reason is
    that the Node.js ecosystem has several tools that will help us to manage the client-side
    dependencies in a simple manner. One of these tools that we are going to use is
    the npm.
  prefs: []
  type: TYPE_NORMAL
- en: Think about npm as the `pip` of the JavaScript world. npm, however, has many
    more features. One of the features that we are going to use is npm scripts.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's go ahead and install Node.js. Usually, developers need to go over
    to the Node.js website and download it from there, but I find it much simpler
    to use a tool called NVM, which allows us to install and switch easily between
    different versions of Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: To install NVM in our environment, you can follow the instructions at [https://github.com/creationix/nvm](https://github.com/creationix/nvm).
  prefs: []
  type: TYPE_NORMAL
- en: We are covering installation of NVM on Unix/Linux and macOS systems. If you
    are using Windows, there's an awesome version for Windows that has been developed
    in the Go language; it can be found at [https://github.com/coreybutler/nvm-windows](https://github.com/coreybutler/nvm-windows).
  prefs: []
  type: TYPE_NORMAL
- en: 'When NVM is installed, you are ready to install the latest version of Node.js
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can verify if the installation is correct with the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: While writing this book, the latest Node.js version is v8.8.1.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also type `npm` on the terminal, where you should see an output similar
    to the output that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/36ec4dc3-0d99-4c0e-8604-c7a67979e542.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a new Django project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a new Django project, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that `django-admin` created a directory called `gamestore` that contains
    some boilerplate code for us. We will go through the files that Django created
    in a little while, but, first, we are going to create our first Django application.
    In the Django world, you have the project and the application, and according to
    the Django documentation, the project describes the web application itself, and
    the application is a Python package that provides some kind of feature; these
    applications contain their own set of routes, views, static files and can be reused
    across different Django projects.
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry if you don't understand it completely; you will learn more as we
    progress.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that said, let''s create the project''s initial application. Run `cd gamestore`,
    and once you are inside the `gamestore` directory, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If you list the contents of the `gamestore` directory, you should see a new
    directory named `main`; that's the directory of the Django application that we
    are going to create.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without writing any code at all, you already have a totally functional web
    application. To run the application and see the results, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Open your favorite web browser, and go to `http://127.0.0.1:8000`, where you
    will see the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/91704c14-da95-48eb-9d06-64970b558e88.png)'
  prefs: []
  type: TYPE_IMG
- en: 'One thing to note when we start the application for the first time is the following
    warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that the apps that are registered by default on a Django project,
    `admin`, `auth`, `contenttypes`, and `sessions` have migrations (database changes)
    that haven''t been applied to this project. We can run these migrations with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here Django created all the tables in a SQLite database, you will find the SQLite
    database file in the application's `root` directory.
  prefs: []
  type: TYPE_NORMAL
- en: The `db.sqlite3` file is the database file that contains the tables for our
    application. The choice of SQLite is just to make the application simpler for
    this chapter. Django supports a large set of databases; the most popular databases,
    such as, Postgres, Oracle, and even MSSQL are supported.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the `runserver` command again, there should not be any migration
    warnings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now there's only one thing that we need to do to wrap this section up; we need
    to create an administrator user so we can log in to the Django admin UI and administrate
    our web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with everything else in Django, this is very simple. Just run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You will be asked to enter a username and email and to set the password, that
    is all you have to do to set an administrator account.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to have a closer look at the files that the
    Django created for us.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Django project's structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you look at the Django website, it says *Django: The Web framework for perfectionists
    with deadlines,* and I could not agree more with this statement. So far, we haven''t
    written any lines of code, and we already have a site up and running. In just
    a few commands, we can create a new project with the same directory structure
    and boilerplate code. Let''s start with the development.'
  prefs: []
  type: TYPE_NORMAL
- en: We can set up a new database and create a superuser, and, on the top of that,
    Django comes with a very nice and useful admin UI, where you can visualize our
    data, , and users.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to explore the code that Django created for us
    when starting a new project so that we can get familiar with the structure. Let's
    go ahead and start adding the other components of our project.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a look inside of the project's root directory, you will find a file
    called `db.sqlite3`, another file called `manage.py`, and, lastly, a directory
    with the same name as the project, in our case `gamestore`. The `db.sqlite3` file,
    as the name suggests, is the database file; this file is created here on the project's
    root folder because we are working with SQLite. You can explore this file directly
    from the command line; we are going to demonstrate how to do that shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The second file is `manage.py`. This file is created automatically by the `django-admin`
    in every Django project. It basically does the same things as `django-admin`,
    plus two extra things; it will set the `DJANGO_SETTINGS_MODULE` to point to the
    project's setting file and also put the project's package on the `sys.path`. If
    you execute `manage.py` without any arguments, you can see the help with all the
    commands available.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see with `manage.py`, you have many options, such as manage passwords,
    create a superuser, manage the database, create and execute database migrations,
    start new apps and projects, and a very important option in `runserver`, which,
    as the name says, will start the Django development server for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have learned about `manage.py` and how to execute its commands,
    we are going to take a step back and learn how to inspect the database that we
    just created. The command to do that is `dbshell`; let''s give it a go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Diving into the SQLite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You should get into the SQLite3 command prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to get a list of all the database''s tables, you can use the command
    `.tables`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here you can see that we have all the tables that we created through the `migrate`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'To look at every table structure, you can use the command `.schema`, and we
    can use the option `--indent`, so the output will be displayed in a more readable
    manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: These are the commands that I use the most when working with SQLite3 databases,
    but the command-line interface offers a variety of commands. You can use the `.help` command
    to get a list of all available commands.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite3 databases are very useful when creating prototypes, creating proof of
    concept projects, or for creating really small projects. If our project does not
    fall in any of these categories, I would recommend using other SQL databases,
    such as MySQL, Postgres, and Oracle. There are also non-SQL databases, such as
    MongoDB. With Django, you can use any of these databases without any problem;
    if you are using the Django **ORM** (**Object relation model**), most of the time
    you can switch between databases, and the application will continue to work perfectly.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the project's package directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, let's have a look at the project's package directory. There, you will
    find a bunch of files. The first file you will see is `settings.py`, which is
    a very important file, as it is where you are going to put all the settings of
    our application. In this settings file, you can specify which apps and database
    you will use, and you can also tell Django where to search for static files and
    templates, middlewares, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then you have the `urls.py`; this file is where you specify the URLs that will
    be available on your application. You can setup URLs on the project level but
    also for every Django app. If you examine the contents of this `urls.py` file,
    you won''t find much detail. Basically, you will see text explaining how to add
    new URLs, but Django has defined (out of the box) a URL to the Django admin site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We are going to go through the process of adding new URLs to the project, but
    we can explain this file anyway; remember when I mentioned that in Django you
    can have diverse apps? So `django.contrib.admin` is also an app, and an app has
    its own set of URLs, views, templates. So what it is doing here? When we import
    the admin app and then define a list called `urlpatterns`, in this list we use
    a function path where the first argument is the URL, and the second argument here
    can be a view that is going to be executed. But in this case, it is passing the
    URLs of the `admin.site` app, which means that `admin/` will be the base URL,
    and all the URLs defined in `admin.site.urls` will be created under it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if in `admin.site.url`, I have defined two URLs, `users/` and
    `groups/`, when I have `path(''admin/'', admin.site.urls)`, I will be actually
    creating two URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`admin/users/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`admin/groups/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, we have the `wsgi.py`, which is a simple WSGI configuration that Django
    creates for us when creating a new project.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are a bit more familiar with the Django's project structure, it
    is time to create our project's first app.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the project's main app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to create our first Django app. One Django project
    can contain multiple apps. Splitting the project into apps is a good practice
    for many reasons; the most obvious is that you can reuse the same app across different
    projects. Another reason to split the project into multiple apps is that it enforces
    separation of concerns. Your project will be more organized, easier to reason,
    and our colleagues will thank you because it will be much easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and run the command `startapp`, and, as shown before, you can
    either use the `django-admin` command or use `manager.py`. As we created the project
    using the `django-admin` command, it is a good opportunity to test the `manager.py`
    command. To create a new Django app, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are going to create an app named `main`. Don't worry that no output
    is displayed, Django creates the project and the app silently. If you get a list
    of the directory contents now, you will see that there is a directory named `main`,
    and inside the `main` directory you will find some files; we are going to explain
    every file while we are adding changes to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the first thing we want to do is to add a landing page to our application.
    To do that, we have to do three things:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we add a new URL to tell Django that when a user of our site browses
    to the root, it should go the site `/` and display some content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second step is to add a view that will be executed when the user browses
    to the site's root ``/``
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last step is to add an HTML template with the content that we want to display
    to the users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With that said, we need to include a new file called `urls.py` inside of the
    `main` app directory. First, we add some imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we imported the function path from `django.urls`. The
    path function will return an element to be included in the `urlpatterns` list,
    and we also import the views file in the same directory; we want to import this
    view because it is there that we are going to define functions that will be executed
    when a specific route is accessed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Then we use the path function to define a new route. The first argument of the
    function path is a string that contains the URL pattern that we wish to make available
    in our application. This pattern may contain angle brackets (for example, `<int:user_id>`)
    to capture parameters passed on the URL, but, at this point, we are not going
    use it; we just want to add a URL for the application's root, so we add an empty
    string `''`. The second argument is the function that is going to be executed,
    and, optionally, you can add the keyword argument `name`, which sets the URL's
    name. We will see why this is useful in a short while.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part is to define the function called `index` in the `views.py`
    file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As there are not too many things going on at this point, we first import the
    render function from `django.shortcuts`. Django has its own template engine that
    is built into the framework, and it is possible to change the default template
    engine to other template engines you like (such as Jinja2, which is one of the
    most popular template engines in the Python ecosystem), but, for simplicity, we
    are going to use the default engine. The `render` function gets the request object,
    the template, and a context object; the latter is an object that contains data
    to be displayed in the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing we need to do is to add a template that will contain the content
    that we want to display when the user browses to our application. Now, most of
    the web application''s pages contain parts that never change, such as a top menu
    bar or a page''s footer, and these parts can be put into a separate template that
    can be reused by other templates. Luckily, the Django template engine has this
    feature. In fact, we can not only inject sub-templates inside a template, but
    also we can have a base template that will contain the HTML that will be shared
    between all of the pages. With that said, we are going to create a file called
    `base.html` inside the `gamestore/templates` directory that has the following
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We are not going to go through all the HTML parts, just the parts that are
    the specific syntax of Django''s template engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing to note here is `{% load static %}`, which will tell Django''s
    template engine that we want to load the static template tag. The static template
    tag is used to link static files. These files can be images, JavaScript, or Stylesheet
    files. How does Django find those files, you may ask, and the answer is simple:
    by magic! No, just kidding; the static template tag will look for the files in
    the directory specified in the `STATIC_ROOT` variable in the `settings.py` file;
    in our case we defined `STATIC_ROOT = ''/static/''`, so when using the tag `{%
    static ''styles/site.css'' %}` the link `/static/styles/site.css` will be returned.'
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering, why not just write `/static/styles/site.css` instead of
    using the tag? The reason for this is that the tag gives us much more flexibility
    for change in case we need to update the path where we serve our static files.
    Imagine a situation where you have a large application with hundreds of templates,
    and in all of them, you hardcode `/static/` and then decide to change that path
    (and you don't have a team). You would need to change every single file to perform
    this change. If you use the static tag, you can simply move the files to a different
    location, and the tag changes the value of the `STATIC_ROOT` variable in the settings
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another tag that we are using in this template is the `block` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `block` tag is very simple; it defines an area in the base template that
    can be used by children templates to inject content in that area. We are going
    to see exactly how this works when we create the next template file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part is to add the template. The `index` function is going to render
    a template stored at `main/index.html`, which means that it will leave it in the
    directory `main/templates/main/`. Let''s go ahead and create the folder `main/templates`
    and then `main/templates/main`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `index.html`  in the directory `main/templates/main/`,
    with the contents as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, here, we start off by extending the base template, which means
    that all the content of the `base.html` file will be used by the Django template
    engine to build the HTML that will be provided back to the browser when the user
    browses to `/`. Now, we also use the `block` tag; in this context, it means that
    the engine will search for a block tag named `'content'` in the `base.html` file,
    and, if it finds it, the engine will insert the `h1 html` tab inside the `'content'`
    block.
  prefs: []
  type: TYPE_NORMAL
- en: This is all about reusability and maintainability of code, because you don't
    need to insert the menu markup and tags to load JavaScript and CSS files in every
    single template of our application; you just need to insert them in the base template
    and use the `block` tag here. The content will change. A second reason to use
    base templates is that, again, imagine a situation where you need to change something—let's
    say the top menu that we defined in the `base.html` file, as the menu is only
    defined in the `base.html` file. All you need to do to perform changes is to change
    the markup in the `base.html`, and all the other templates will inherit the changes.
  prefs: []
  type: TYPE_NORMAL
- en: We are almost ready to run our code and see how the application is looking so
    far, but, first, we need to install some client-side dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Installing client-side dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have NodeJS installed, we can install the project''s client-side
    dependencies. As the focus of this chapter is Django and Python, we don''t want
    to spend too much time styling our application and going through huge CSS files.
    However, we do want our application to look great, and for this reason we are
    going to install two things: Bootstrap and Font Awesome.'
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap is a very well-known toolkit that has been around for many years.
    It has a very nice set of components, a grid system, and plugins that will help
    us make our application look great for our users when they are browsing the application
    on a desktop, or even a mobile device.
  prefs: []
  type: TYPE_NORMAL
- en: Font Awesome is another project that has been around for a while, and it is
    a font and icons framework.
  prefs: []
  type: TYPE_NORMAL
- en: To install these dependencies, we could just run the npm's install command.
    However, we are going to do better. Similar to `pipenv`, which creates a file
    for our Python dependencies, `npm` has something similar. This file is called
    `package.json`, and it contains not only the project's dependencies but also scripts
    and meta information about the package.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s go ahead and add the `package.json` file to the `gamestore/` directory,
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! Save the file, and run this command on the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If everything goes well, you should see a message saying that two packages have
    been installed.
  prefs: []
  type: TYPE_NORMAL
- en: If you list the contents of the `gamestore` directory, you will see that `npm`
    created a new directory called `node_modules`, and it is there that `npm` installed
    Bootstrap and Font Awesome.
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity, we are going to just copy the CSS files and fonts that we need
    to the `static` folder. However, when building an application, I would recommend
    using tools such as `webpack`, which will bundle all our client-side dependencies
    and set up a `webpack` dev server to serve the files for your Django application.
    Since we want to focus on Python and Django we can just go ahead and copy the
    files manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we can create the directory of the CSS files as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need to copy the bootstrap files. First, the minified CSS file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to copy the Font Awesome files, starting with the minified CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'And the fonts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to add another CSS file that will contain some custom CSS that
    we may add to the application to give a personal touch to the application. Add
    a file called `site.css` in the `gamestore/static/styles` directory with the following
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few things we need to do to run our application for the first time;
    first, we need to add the main app that we created to the `INSTALLED_APPS` list
    in the `settings.py` file in the `gamestore/gamestore` directory. It should look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same settings file you will find the list `TEMPLATES`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of `DIRS` is an empty list. We need to change it to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: That will tell Django to search for templates in the `templates` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, at the end of the `settings.py` file, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This will tell Django to search for static files in the `gamestore/static` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to tell Django to register the URLs that we have defined in the
    `main` app. So, let''s go ahead and open the file `urls.py` in the `gamestore/gamestore`
    directory. We need to include  `"main.urls"` in the `urlpatterns` list. After
    the changes, the `urls.py` file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note that we also need to import the `include` function of the `django.urls`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Great! Now we have all the client-site dependencies in place and ready to be
    used by our application, and we can start the application for the first time to
    see the changes that we have implemented so far. Open the terminal, and use the
    command `runserver` to start Django''s development server, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Browse to `http://localhost:8000`; you should see a page like the one shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b2034c76-688d-456c-9e99-41b3b0429427.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding login and logout views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every online store needs some sort of user management. Our application's users
    should be able to create an account, change their account details, obviously log
    in to our application so they can place orders, and also log out from the application.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to start adding the login and logout functionality. The good news
    is that it is super easy to implement in Django.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to add a Django form to our login page. Django has a built-in
    form of authentication; however, we want to customize it, so we are going to create
    another class that inherits from the Django built-in `AuthenticationForm` and
    add our changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `forms.py` in `gamestore/main/` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This class is quite simple. First, we import `forms` from the `django` module
    and the `AuthenticationForm` from `django.contrib.auth.forms`, and then we create
    another class, also called `AuthenticationForm`, which inherits from Django''s
    `AuthenticationForm`. Then we define two properties, the username and the password.
    We define the username as an instance of `CharField` , and there are some keyword
    arguments that we pass in its constructor. They are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`max_length`, which, as the name suggests limits the size of the string to
    `50` characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also use the `widget` argument, which specifies how this property will be
    rendered on the page. In this case, we want to render it as an input text element,
    so we pass an instance to `TextInput`. It is possible to pass some options to
    the `widget`; in our case, here we pass `'class'`, which is the CSS class and
    the placeholder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these options will be used when the template engine renders this property
    on the page.
  prefs: []
  type: TYPE_NORMAL
- en: The second property that we define here is the password. We also define it as
    a `CharField`, and, instead of passing `max_length`, this time we set the label
    to `'Password'`. The `widget` we set to `PasswordInput` so the template engine
    will render the field on the page as input with a type equal to the password,
    and, lastly, we define the same settings for this field class and placeholder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can start registering the new URLs for logging in and out. Open the
    file `gamestore/main/urls.py`. To start, we are going to add some `import` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'After the `import` statements, we can start registering the authentication
    URLs. At the end of the `urlpattens` list, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: So, here we are creating a new URL, `'accounts/login'`, and when requesting
    this URL the function view `login` will be executed. The third argument for the
    path function is a dictionary with some options, and the `template_name` specifies
    the template that will be rendered on the page when browsing to the underlying
    URL. We also define the `authetication_form` with the `AuthenticationForm` value
    that we just created. Lastly, we set the keyword argument `name` to `login`; naming
    the URL is very helpful when we need to create a link for this URL and also improves
    maintainability, because changes in the URL itself won't require changes in the
    templates as the templates reference the URL by its name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the login is in place, let''s add the logout URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the login URL, in the logout URL we use the path function passing
    first the URL itself (`accounts/logout`); we pass the function logout that we
    imported from the Django built-in authentication views, and, as an option, we
    set `next_page` to `/`. This means that when the user logs out, we redirect the
    user to the application's root page. Lastly, we also name the URL as logout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Great. Now it is time to add the templates. The first template that we are
    going to add is the login template. Create a file named `login.html` at `gamestore/templates/` with
    the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In this template, we also extend the base template, and we add the content of
    the login template with the content block that has been defined in the base template.
  prefs: []
  type: TYPE_NORMAL
- en: First, we create a `form` tag and set the method to `POST`. Then, we add the
    `csrf_token` tag. The reason we add this tag is to prevent cross-site request
    attacks, where a malicious site performs a request to our site on behalf of the
    current logged in user.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to know more about this type of attack, you can visit the site at [https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).
  prefs: []
  type: TYPE_NORMAL
- en: 'After the Cross-Site Request Forgery tag, we add the two fields we need: username
    and password.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we have the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This is where we are going to display possible authentication errors. The forms
    object has a property called `non_field_error`, which contains errors that are
    not related to field validation. For example, if your user types the wrong username
    or password, then the error will be added the to `non_field_error` list.
  prefs: []
  type: TYPE_NORMAL
- en: We create a `ul` element (unordered list) and loop through the `non_field_errors`
    list adding `li` elements (list items) with the error text.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now the login in place, and we need to just include it to the page—more
    specifically, to the `base.html` template. But, first, we need to create a little
    partial template that will display the login and logout links on the page. Go
    ahead and add a file called `_loginpartial.html` to the `gamestore/templates`
    directory that has the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This partial template will render two different contents depending on whether
    the user is authenticated or not. If the user is authenticated, it will render
    the logout form. Note that the action of the form makes use of the named URL;
    we don't set it to `/accounts/logout` but to `{% url 'logout' %}`.Django's URL
    tag will replace the URL name with the URL. Again, we need to add the `csrf_token`
    tag to prevent Cross-Site Request Forgery attacks, and, finally, we define an
    unordered list with two items; the first item will display the text `Logged as:`
    and the user's username, and the second item on the list will show the logout
    button.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we added an anchor tag inside of the list item element, and that the
    `href` property has some JavaScript code in it. That code is pretty simple; it
    uses the function `getElementById` to get the form and then call the form's submit
    function to submit to the server the request to `/accounts/logout`.
  prefs: []
  type: TYPE_NORMAL
- en: This is just a preference for implementation; you could easily have skipped
    this JavaScript code and added a submit button instead. It would have the same
    effect.
  prefs: []
  type: TYPE_NORMAL
- en: In case the user is not authenticated, we only show the `login` link. The `login`
    link also uses the URL tag that will replace the name `login` with the URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Great! Let''s add the login partial template to the base template. Open the
    file `base.html` at `gamestore/templates`, and locate the unordered list, shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to add the `_loginpartial.html` template using the `include` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The include tag will inject the content of the `_loginpartial.html` template
    in this position in the markup.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final touch here is to add some styling, so the login page looks nice like
    the rest of the application. Open the file `site.css` in the `gamestore/static/styles` directory,
    and include the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Testing the login/logout forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we try this out, let''s open the file `settings.py` in the `gamestore/gamestore`
    directory, and at the end of the file add the following setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This will tell Django that, after the login, the user will be redirected to
    "`/`".
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are ready to test the login and logout functionality, although you probably
    don''t have any users in the database. However, we created the superuser while
    we were setting up our Django project, so go ahead and try logging in with that
    user. Run the command `runserver` to start the Django development server again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Browse to `http://localhost:8000` and note that you now have the login link
    in the top right corner of the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6d74e76d-f481-4eec-9dc9-d8ad6b061fa5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you click that, you will be redirected to `/accounts/login`, and the login
    page template that we created will be rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3025a9a4-9ae4-4eed-b361-54290b3e87a9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'First, try typing the wrong password or username so we can verify that the
    error message is being displayed correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ff28669a-804e-448a-9452-632421a24126.png)'
  prefs: []
  type: TYPE_IMG
- en: Great! It works!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now log in with the superuser, and if everything works fine, you should be
    redirected to the application root''s URL. It says, Logged as with your username,
    and right after it there is a logout link. Give it a go, and click on the link
    Log off:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6490f579-a5ca-4bcb-9106-699f74da2029.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating new users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we are able to log in and log out of our application, we need to add
    another page so the users can create accounts on our application and place orders.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some rules that we want to enforce when creating a new account. The
    rules are:'
  prefs: []
  type: TYPE_NORMAL
- en: The username field is required, and it has to be unique to our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The email field is required, and it has to be unique to our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last and first name are required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both password fields are required, and they must match
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If any of these rules are not followed, we will not create the user account,
    and an error should be returned to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that said, let''s add a small helper function that will verify whether
    a field has a value that already exists in the database. Open the file `forms.py` in `gamestore/main`.
    First, we need to import the User model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the `validate_unique_user` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This function gets an error message and keyword arguments that will be used
    as a criterion to search for items matching a specific value. We create a variable
    called `existent_user`, and filter the user models passing the criteria. If the
    value of the variable `existent_user` is different to `None`, it means that we
    have found a user who matches our criterion. We then raise a `ValidationError`
    exception with the error message that we passed to the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nice. Now we can start adding a form that will contain all the fields that
    we want the user to fill out when creating an account. In the same file, `forms.py` in
    the `gamestore/main` directory, add the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: So, we start by creating a class called `SignupForm` that will inherit from
    `Form`, we define a property for every field that is going to be necessary for
    creating a new account, and we add a username, a first and a last name, an email,
    and then two password fields. Note that in the password fields we set the min
    and max length for a password to `6` and `10`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing in the same class, `SignupForm`, let''s add a method called `clean_username`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The prefix `clean` in the name of this method will make Django automatically
    call this method when parsing the posted data for the field; in this case, it
    will execute when parsing the field username.
  prefs: []
  type: TYPE_NORMAL
- en: So, we get the username value, and then call the method `validate_unique_user`,
    passing a default error message and a keyword argument username that will be used
    as a filter criterion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another field that we need to verify for uniqueness is the email ID, so let''s
    implement the `clean_email` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: It is basically the same as the clean username. First, we get the email from
    the request and pass it to the `validate_unique_user` function. The first argument
    is the error message, and the second argument is the email that will be used as
    the filter criteria.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another rule that we defined for our create account page is that the password
    and (repeat) password fields must match, otherwise an error will be displayed
    to the user. So let''s add the same and implement the clean method, but this time
    we want to validate the `repeat_password` field and not `password`. The reason
    for that is that if we implement a `clean_password` function, at that point `repeat_password`
    won''t be available in the `cleaned_data` dictionary yet, because the data is
    parsed in the same order as they were defined in the class. So, to ensure that
    we will have both values we implement `clean_repeat_password`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Great. So here we first define two variables; `password1`, which is the request
    value for the `password` field, and `password2`, the request value for the field
    `repeat_password`. After that, we just compare if the values are different; if
    they are, we raise a `ValidationError` exception with the error message to inform
    the user that the password didn't match and the account will not be created.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the views of the user creation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the form and validation in place, we can now add the view that will handle
    the request to create a new account. Open the file `views.py` at `gamestore/main`,
    and start by adding some `import` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: As we will be receiving data from a `POST` request, it is a good idea to add
    Cross-Site Request Forgery checkings, so we need to import the `csrf_protect`
    decorator.
  prefs: []
  type: TYPE_NORMAL
- en: We also import the `SignupForm` that we just created so we can pass it to the
    view or use it to parse the request data. Lastly, we import the `User` model.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s create the `signup` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: We start by decorating the `signup` function with the `csrf_protect` decorator.
    The function starts by checking whether the request's HTTP method is equal to
    `POST`; in that case, it will create an instance of the `SignupForm` passing as
    an argument the `POST` data. Then we call the function `is_valid()` on the form,
    which will return true if the form is valid; otherwise it will return  false.
    If the form is valid, we create a new user and call the `save` function, and,
    finally, we render the `create_account_success.html`.
  prefs: []
  type: TYPE_NORMAL
- en: If the request `HTTP` method is a `GET`, the only thing we do is create an instance
    of a `SignupForm` without any argument. After that, we call the `render` function,
    passing as a first argument the `request` object, then the template that we are
    going to render, and, finally, the last argument is the instance of the `SignupForm`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to create both templates referenced in this function in a short
    while, but, first, we need to create a new URL in the `url.py` file at `gamestore/main`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This new URL can be added right at the end of the `urlpatterns` list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to create the templates. We start with the `signup` template;
    create a file called `signup.html` at `gamestore/main/templates/main` with the
    following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This template is again very similar to the template that we created before,
    in that it extends the base template and injects some data into the base template's
    content block. We add an `h1` tag with the header text and a form with the action
    set to `{% url 'signup' %}`, which the `url` tag will change to `/accounts/signup`,
    and we set the method to `POST`.
  prefs: []
  type: TYPE_NORMAL
- en: As is usual in forms, we use the `csrf_token` tag that will work together with
    the `@csrf_protect` decorator in the `signup` function in the `views` file to
    protect against Cross-Site Request Forgery.
  prefs: []
  type: TYPE_NORMAL
- en: Then we just call `{{ form }}`, which will render the entire form in this area,
    and, right after the fields, we add a button to submit the form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we create a template for showing that the account has been successfully
    created. Add a file called `create_account_success.html` to the `gamestore/main/templates/main`
    directory with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! To make it look great, we are going to include some CSS code in the
    file `site.css` in the `gamestore/static` directory. Add the content shown as
    follows, at the end of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all for the create a user page; let''s give it a go! Start the Django
    developer server again, and browse to `http://localhost:8000/accounts/signup`,
    where you should see the create user form, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ca34bdb6-e35e-4b9b-9425-9652ba21ef52.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After you fill up all the fields, you should be redirected to a confirmation
    page, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/82ffe42c-8485-4150-8cb8-ec480a29ddd4.png)'
  prefs: []
  type: TYPE_IMG
- en: Perform some tests yourself! Try adding invalid passwords, just to verify that
    the validations we implemented are working properly.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the game data model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Alright, we can log into our application, we can create new users, and we also
    added the front page template, which is currently blank, but we are going to fix
    that. We have got to the core of this chapter; we are going to start adding models
    that will represent the items that we can buy at the store.
  prefs: []
  type: TYPE_NORMAL
- en: 'The requirements for the game''s model that we are going to have on the site
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: The store is going to sell games for different gaming platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There will be a section on the first page that will list highlighted games
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The users of the store should be able to go to the game's details page and see
    more information about the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The games should be discoverable by different criteria, for example, developer,
    publisher, release date, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The administrator of the store should be able to change product details using
    the Django admin UI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The product's picture can be changed, and if not found, it should show a default
    image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With that said, let''s start adding our first model class. Open the file `models.py`
    in `gamestore/main/`, and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have added the class `GamePlatform`, and it will represent the gaming
    platforms that will be available at the store. The class is super simple; we just
    create a class inheriting from the `Model` class, and we define just one property
    called `name`. The name property is defined as a `CharField` of a maximum length
    of 100 characters. Django provides a large variety of data types; you can see
    the complete list at [https://docs.djangoproject.com/en/2.0/ref/models/fields/](https://docs.djangoproject.com/en/2.0/ref/models/fields/).
  prefs: []
  type: TYPE_NORMAL
- en: Then we override the method `__str__`. This method will dictate how an instance
    of `GamePlatform` will be displayed when being printed out. The reason that I
    am overriding this method is that I want to display the name of `GamePlatform`
    in the list of `GamePlatform` in the Django admin UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second model class that we are going to add here is the `Game` model. In
    the same file, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Like the previous model class that we created, the `Game` class also inherits
    from `Model` and we define all the fields that we need according to the specifications.
    There are some things to note here that are new; the property `release_year` is
    defined as an integer field, and we set the property `null=True`, which means
    that this field will not be required.
  prefs: []
  type: TYPE_NORMAL
- en: Another property that used a different type is the image property, which is
    defined as an `ImageField`, and that will allow us to provide the application's
    administrators the possibility of changing the game's image. This type inherits
    from `FileField`, and in the Django Administration UI the field will be rendered
    as a file picker. The `ImageFile` argument `upload_to` specifies where the image
    will be stored, and the default is the default image that will be rendered if
    the game does not have an image. The last argument that we specify here is `max_length`,
    which is the image path's maximum length.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we define a `ForeignKey`. If you don't know what it is, a foreign key
    is basically a file that identifies a row in another table. In our case, here
    we want the game platform to be associated with multiple games. There are a few
    keyword arguments that we are passing to the definition of the primary key; first
    we pass the foreign key type, the `null` argument is set to `False`, meaning that
    the field is required, and, lastly we set the deletion rule to `CASCADE`, so if
    the application's admin deletes a gaming platform, that operation will cascade
    and delete all the games associated with that specific gaming platform.
  prefs: []
  type: TYPE_NORMAL
- en: The last property that we define is the `highlighted` property. Do you remember
    that one of the requirements was to be able to highlight some products and also
    have them in a more visible area so the users can find them easily? This property
    does just that. It is a property type Boolean that has the default value set to
    `False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another detail, that I was saving for last is this: have you noticed that we
    have a class named `Meta` inside the model class? This is the way that we can
    add meta information about the model. In this example we are setting a property
    called `ordering` with the value as an array of strings, where each item represents
    a property of the `Game` model, so we have first `-highlighted` - the dash sign
    in front of the property name means descending order—and then we also have the
    name, which will appear in ascending order.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue adding more code to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have two things. First, we assign an instance of a class called `GameManager`,
    which I will go into in more detail in a short while, and we also define the special
    method `__str__`, which defines that when printing an instance of the `Game` object,
    it will display the gaming platform and a symbol dash, followed by the name of
    the name itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before the definition of the `Game`class, let''s add another class called `GameManager`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Before we get into the details of this implementation, I just want to say a
    few words about `Manager` objects in Django. The `Manager` is the interface between
    the database and the model classes in Django. By default, every model class has
    a `Manager`, and it is accessed through the property objects, so why define our
    own manager? The reason that I implemented a `Manager` for this `models` class
    is that I wanted to leave all the code concerning database operations within the
    model, as it makes the code cleaner and more testable.
  prefs: []
  type: TYPE_NORMAL
- en: So, here I defined another class, `GameManager`, that inherits from `Manager`,
    and so far we defined three methods—`get_highlighted`, which get all games that
    have the highlighted flag set to `True`, `get_not_highlighted`, which gets all
    games that highlighted flag is set to `False`, and `get_by_platform`, which gets
    all the games given a gaming platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'About the two first methods in this class: I could have just used the filter
    function and passed an argument where `highlighted` equals `True` or `False`,
    but, as I mentioned previously, it is much cleaner to have all these methods inside
    the manager.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are ready to create the database. In the terminal, run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will create a migration file with the changes that we just implemented
    in the model. When the migrations are created, we can run the command `migrate` and
    then apply the changes to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Great! Next up, we are going to create a model to store the game's prices.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the price list data model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another feature that we want to have in our application is the ability to change
    the prices of the products as well as knowing when a price was added and, most
    importantly, when it was last updated. To achieve this, we are going to create
    another model class, called `PriceList`*, *in the `models.py` file in the `gamestore/main/`
    directory, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: As you can see here, you have two datetime fields. The first one is `added_at`,
    and it has a property `auto_now_add` equals `True`. What it does is get Django
    to automatically add the current date when we add this price to the table. The
    `last_update` field is defined with another argument, the `auto_now` equals `True`;
    this tells Django to set the current date every time an update occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we have a field for the price called `price_per_unit`, which is defined
    as a `DecimalField` with a maximum of `9` digits and `2` decimal places. This
    field is not required, and it will always `default` to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a `OneToOneField` to create a link between the `PriceList` and
    the `Game` object. We define that when a game is deleted, the related row in the
    `PriceList` table will also be removed, and we define this field as the primary
    key.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we override the `__str__` method so that it returns the game's name.
    This will be helpful when updating prices using the Django admin UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can make the migration files again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the changes with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Perfect! Now we are ready to start adding the views and the templates to display
    our games on the page.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the game list and details page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After creating the model for the games and the prices, we have reached the fun
    part of this section, which is to create the views and templates that will display
    the games on the page. Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we have created a template called `index.html` in `main/templates/main`,
    but we are not displaying anything on it. To make that page more interesting,
    we are going to add two things:'
  prefs: []
  type: TYPE_NORMAL
- en: A section on the top of the page that will display the games that we want to
    highlight. It could be a new game that arrived at the store, a very popular game,
    or some game that has a good price for the moment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Following the section with the highlighted games, we are going to list all the
    other games.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first template that we are going to add is a partial view that will be
    used to list games. This partial view will be shared to all the templates that
    we want to display a list of games. This partial view will receive two arguments:
    `gameslist` and `highlight_games`. Let''s go ahead and add a file called `games-list.html`
    at `gamestore/main/templates/main/` with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: One thing to note here is that we added at the top of the page `{% load humanize
    %}`; this is a set of template filters that are built into the Django framework,
    which we are going to use to format the game price properly. To make use of these
    filters we need to edit the `settings.py` file in the `gamestore/gamestore` directory
    and add `django.contrib.humanize` to the `INSTALLED_APPS` setting.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code will create a container with some boxes containing the game image,
    details, and an add-to-cart button, similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a90a8c0b-9daf-4a99-adb3-1a56365aec9d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we want to modify the `index.html` at `gamestore/main/templates/main`.
    We can replace the whole content of the `index.html` file with the code, shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! The interesting code is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we are including the partial view and passing two parameters:
    `gameslist` and `highlight_games`. The `gameslist` is obviously a list of games
    that we want the partial view to render, while `highlight_games` will be used
    when we want to show the promoted games with a different color so they can be
    easily identified. In the index page, the `highlight_games` parameter is not used,
    but when we create a view to list all the games regardless of the fact that it
    is promoted or not, it may be interesting to change the color of the promoted
    ones.'
  prefs: []
  type: TYPE_NORMAL
- en: Below the promoted games section, we have a section with a list of games that
    are not promoted, which also makes use of the partial view `games-list.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last touch on the frontend side is to include the related CSS code, so
    let''s edit the file `site.css` at `gamestore/static/styles/` and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to modify the `index` view, so edit the `views.py` file at `gamestore/main/`
    and perform these changes in the `index` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Here, we first define how many items of each category of games we want to show;
    for promoted games, it will be three games, and the non-promoted category will
    show a maximum of nine games.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we fetch the promoted and non-promoted games, and we create two variables, `show_more_link_promoted`
    and `show_more_link_games`, which will be set to `True` in case there are more
    games in the database than the maximum number we defined previously.
  prefs: []
  type: TYPE_NORMAL
- en: We create a context variable that will contain all the data that we want to
    render in the template, and, lastly, we call the `render` function and pass the
    `request` to the template we want to render, along with the context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we make use of the `Game` model, we have to import it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to see the results on the page, but, first, we need to create
    some games. To do that, we first need to register the models in the admin. To
    do that, edit the `admin.py` file and include the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Registering the models within the Django admin site will allow us to add, edit,
    and remove games, games platforms, and items in the price list. Because we will
    be adding images to our games, we need to configure the location where Django
    should save the images that we upload through the administration site. So, let''s
    go ahead and open the file `settings.py` in the `gamestore/gamestore` directory,
    and just below the `STATIC_DIRS` setting, add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, start the site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Browse to `http://localhost:8000/admin`, and log in as the superuser account
    that we created. You should see the models listed on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/67a5e1f4-ea27-49db-baa6-d720c8b35235.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you click first in `Game` platforms, you will see an empty list. Click on
    the button ADD on the Game platforms row on the top right-hand side of the page,
    and the following form will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dd1567e5-3c9c-4428-b68d-5fb26bd0bef2.png)'
  prefs: []
  type: TYPE_IMG
- en: Just type any name you like, and click on the SAVE button to save your changes.
  prefs: []
  type: TYPE_NORMAL
- en: Before we add the games, we need to find a default image and place it at `gamestore/static/images/`.
    The image should be named `placeholder.png`.
  prefs: []
  type: TYPE_NORMAL
- en: The layout that we build will work better with images that are of the size 130x180\.
    To make it simpler, when I am creating prototypes, and I don't want to spend too
    much time looking for the perfect image, I go to the site [https://placeholder.com/](https://placeholder.com/).
    Here, you can build a placeholder image of any size you want. To get the correct
    size for our application you can go directly to [http://via.placeholder.com/130x180](http://via.placeholder.com/130x180).
  prefs: []
  type: TYPE_NORMAL
- en: When you have the default image in place, you can start adding games the same
    way you added the game platforms and just repeat the process multiple times to
    add a few games that are set as promoted as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding the games, and going to the site again, you should see the list
    of games on the index page, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8e40b7bf-7333-4410-926c-c4b2bc5af4a3.png)'
  prefs: []
  type: TYPE_IMG
- en: On my project, I added four promoted games. Notice that because we only show
    three promoted games on the first page, we render the link See more items.
  prefs: []
  type: TYPE_NORMAL
- en: Adding list games views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we are not displaying all the items on the first page, we need to build pages
    that will display all the items if the user clicks on See more items link. This
    should be fairly simple, as we already have a partial view that lists the games
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create two more URLs in the `url.py` file of the `main` app, and let''s
    add these two to the `urlpatterns` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Perfect! Now we need to add one template to list all the games. Create a file
    called `all_games.html` at `gamestore/main/templates/main` with the following
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Add another file in the same folder called `highlighted.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: There is nothing here that we haven't seen before. This template will receive
    a list of games, and it will pass it down to the `games-list.html` partial view
    that will do all the work of rendering the games for us. There is an `if` statement
    here that checks if there are games on the list. If the list is empty, it will
    display a message that there are no games available at the moment. Otherwise,
    it will render the content.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing now is to add the views. Open the `views.py` file at `gamestore/main/`,
    and add the following two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: These functions are very similar; one gets a list of all games and the other
    one gets a list of only promoted games
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open the application again. As we have more promoted items in the database,
    let''s click on the link See more items in the Highlighted games section of the
    page. You should land on the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/28d8b456-325c-42cc-86eb-94cfb4fb8e20.png)'
  prefs: []
  type: TYPE_IMG
- en: Perfect! It worked just as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we are going to add functionality to the buttons so we can add those
    items to the cart.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the shopping cart model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It seems like now we have an application up and running, we can display our
    games, but there's a big issue here. Can you guess what? Okay, this question wasn't
    so hard, I gave the answer for that in the title of the section. Anyway, our users
    cannot buy the games—we need to implement a shopping cart so we can start making
    our users happy!
  prefs: []
  type: TYPE_NORMAL
- en: Now, there are many ways you can implement a shopping cart on an application,
    but we are going to do it by simply saving the cart items on the database instead
    of doing an implementation based in the user session.
  prefs: []
  type: TYPE_NORMAL
- en: 'The requirements for the shopping cart are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The users can add as many items they wish
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The users should be able to change the items in the shopping cart; for example,
    they should be able to change the quantity of an item
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removal of items should be possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There should be an option to empty the shopping cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the data should be validated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the user owning that shopping cart is removed, the shopping cart and its
    items should also be removed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With that said, open the file `models.py` in the `gamestore/main` directory,
    and let''s add our first class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: The same way we created a custom `Manager` for the `Game` object, we are also
    going to create a `Manager` for the `ShoppingCart`. We are going to add three
    methods. The first one is `get_by_id`, which, as the name says, retrieves a shopping
    cart, given an ID. The second method is `get_by_user`, which receives as a parameter
    an instance of `django.contrib.auth.models.User`, and it will return the cart
    given a user instance. The last method is `create_cart`; this method will be called
    when the user creates an account
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the manager with the methods that we need, let''s add the
    `ShoppingCart` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: This class is super simple. As always, we inherit from `Model`, and we define
    one foreign key for the type `User`. This foreign key is required, and if the
    user is deleted it will also delete the shopping cart.
  prefs: []
  type: TYPE_NORMAL
- en: After the foreign key, we assign our custom `Manager` to the object's property,
    and we also implement the special method `__str__` so the shopping carts are displayed
    in a nicer way in the Django admin UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s add a manager class for the `ShoppingCartItem` model, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we only define one method, called `get_items`, which receives a cart
    object and returns a list of items for the underlying shopping cart. After the
    `Manager` class, we can create the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by defining two properties: quantity, which is an integer value, and
    the price per item, which is defined as a decimal value. We have `price_per_item`
    in this model as well, because when a user adds an item to the shopping cart and
    if the administrator changes the price for a product, we don''t want that change
    in the price to be reflected on the items already added to the cart. The price
    should be the same price as when the user first added the product to the cart.'
  prefs: []
  type: TYPE_NORMAL
- en: In case the user removes the item entirely and re-adds them, the new price should
    be reflected. After those two properties, we define two foreign keys, one for
    the type `ShoppingCart` and another one for `Game`.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we set the `ShoppingCartItemManager` to the object's property.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to import the User model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we try to verify that everything is working, we should create and apply
    the migrations. On the terminal, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'As we did before, we need to run the migrate command to apply the migrations
    to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Creating the shopping cart form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now have the models in place. Let''s add a new form that will display the
    cart data on a page for editing. Open the `forms.py` file at `gamestore/main/`,
    and at the end of the file add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create an inline `formset` using the function `inlineformset_factory`.
    Inline `formset`s are suitable when we want to work with related objects via a
    foreign key. This is very convenient in the case we have here; we have a model
    `ShoppingCart` that relates to the `ShoppingCartItem`.
  prefs: []
  type: TYPE_NORMAL
- en: So, we pass a few arguments to the `inlineformset_factory` function. First is
    the parent model (`ShoppingCart`), then it's the model (`ShoppingCartItems`).
    Because in the shopping cart we just want to edit the quantities and also remove
    items from the cart, we add a tuple containing the fields from the `ShoppingCartItem`
    that we want to render on the page—in this case, the `quantity` and `price_per_unit`.
    The next argument, `extra`, specifies whether the form should render any empty
    extra rows on the form; in our case, we don't need that, as we don't want to add
    extra items in the shopping cart to the shopping cart view.
  prefs: []
  type: TYPE_NORMAL
- en: In the last argument, `widgets`, we can specify how the fields should be rendered
    in the form. The quantity field will be rendered as a text input, and we don't
    want `price_per_unit` to be visible, so we define it as a hidden input so it is
    sent back to the server when we submit the form to the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, in the same file, let''s add some necessary imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `views.py` file, and let''s add a class-based view. First, we need
    to add some import statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can create the class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: This is slightly different than the view that we created so far, as this is
    a class-based view that inherits from an `UpdateView`. In reality, views in Django
    are callable objects, and when using classes instead of functions, we can take
    advantage of inheritance and mixins. In our case, we use `UpdateView` because
    it is a view to display forms that will edit an existing object.
  prefs: []
  type: TYPE_NORMAL
- en: This class view starts off by defining a few properties, such as the model,
    which is the model that we are going to be editing in the form. The `form_class`
    is the form that is going to be used for editing the data. Lastly, we have the
    template that will be used to render the form.
  prefs: []
  type: TYPE_NORMAL
- en: We override the `get_context_data` because we include some extra data in the
    form context. So, first, we call the `get_context_data` on the base class so as
    to build the context, then we get the list of items of the current cart so we
    can determine whether the cart is empty. We set this value to the context item
    called `is_cart_empty`, which can be accessed from the template.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we want to calculate the total value of the items that are currently
    in the cart. To do that, we need to first calculate the total price for each item
    by doing (price * quantity), and then sum the results. In Django, it is possible
    to aggregate the values of a `QuerySet`; we have already the `QuerySet` that contains
    the list of items in a cart, so all we have to do is to use the `aggregate` function.
    In our case, we are passing two arguments to the `aggregate` function. First,
    we get the sum of the field `price_per_unit` multiplied by the quantity, and the
    results will be stored in a property called `total_order`. The second argument
    of the `aggregate` function defines the output data type, which we want to be
    a decimal value.
  prefs: []
  type: TYPE_NORMAL
- en: When we get the results of the aggregation, we create a new item in the context
    dictionary called `total_order` and assign the results to it. Finally, we return
    the context.
  prefs: []
  type: TYPE_NORMAL
- en: We also override the `get_object` method. In this method, we try to get the
    shopping cart for the requesting user. If the shopping cart does not exist, an
    exception `ShoppingCart.DoesNotExist` will be raised. In that case, we create
    a shopping cart for the user and return it.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we also implement the `form_valid` method, which only saves the form
    and redirects the user back to the cart page.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the shopping cart view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it is time to create the shopping cart views. This view will render the
    form that we just created, and the users should be able to change the quantities
    for every item on the cart, as well as remove items. If the shopping cart is empty,
    we should show a message saying that the cart is empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the view, let''s go ahead and open the `urls.py` file in `gamestore/main/`
    and add the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define a new URL, `'cart/'`, and, when accessed, it will execute the
    class-based view `ShoppingCartEditView`. We also define a name for the URL for
    simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to create a new file called `cart.html` at `gamestore/main/templates/main`,
    with the contents as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: The template is quite simple; we just loop through the forms and render each
    one of them. One thing to note here in that we are loading `humanize` in the beginning
    of the template.
  prefs: []
  type: TYPE_NORMAL
- en: '`humanize` is a set of template filters that we can use to format data in the
    template.'
  prefs: []
  type: TYPE_NORMAL
- en: We use the `intcomma` filter from `humanize` to format the sum of all items
    in the shopping cart. The `intcomma` filter will convert an integer or float value
    to a string and add a comma every three digits.
  prefs: []
  type: TYPE_NORMAL
- en: You can try it out on the new view. However, the cart will be empty and no data
    will be displayed. Next, we are going to add functionality to include items in
    the cart.
  prefs: []
  type: TYPE_NORMAL
- en: Adding items to the cart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are getting close to finishing up the shopping cart. Now we are going to
    implement a view that will include items in the cart.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is create a new URL. Open the file `url.py` in
    the directory `gamestore/main/`, and add this URL to the `urlpatterns` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Perfect. In this URL, we can pass the game ID, and it will execute a view called
    `add_to_cart`. Let''s add this new view. Open the file `views.py` in `gamestore/main`.
    First, we add import statements, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need a way to know if a specific item has been already added to the
    cart, so we go over to the `models.py` in `gametore/main` and add a new method
    to the `ShoppingCartItemManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '`get_existing_item` searches for a `ShoppingCartItem` object using as criteria
    the `cart id` and the `game id`. If the item is not found in the cart, it returns
    `None`; otherwise, it will return the cart item.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we add the view to the `views.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: This function gets a request and the game ID, and we start by getting the game
    and the current user's shopping cart. We then pass the cart and the game to the
    `get_existing` function that we just created. If we don't have that specific item
    in the shopping cart, we create a new `ShoppingCartItem`; otherwise, we just update
    the quantity and save.
  prefs: []
  type: TYPE_NORMAL
- en: We also add a message to inform the user that the item has been added to the
    shopping cart.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we redirect the user to the shopping cart page.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a final touch, let''s open the `site.css` file in the `gamestore/static/styles`
    and add the styling to our shopping cart''s view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we try this out, we need to add the link to the cart view on the top
    menu. Open the file `base.html` in `gamestore/templates`, locate where we do the
    include of the `_loginpartial.html` file, and include the following code right
    before it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we should be ready to test it out. Go to the first page, and try adding
    some games to the cart. You should be redirected to the cart page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/88194946-e679-46f9-a81a-b3b782e05424.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It has been a long journey, and we have covered a lot of ground in this chapter.
    In this chapter, you have seen how easy it is to build an application with Django.
    The framework really honors the phrase *Framework for perfectionists with deadlines*.
  prefs: []
  type: TYPE_NORMAL
- en: You have learned how to create a new Django project and applications, with a
    short walkthrough of the boilerplate code that Django generates for us when we
    start a new project. We learned how to create models and use migrations to apply
    changes to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Django forms was also a subject that we covered a lot in this chapter, and you
    should be able to create complex forms for your projects.
  prefs: []
  type: TYPE_NORMAL
- en: As a bonus, we learned how to install and use **NodeJS Version Manager** (**NVM**)
    to install Node.js, so as to install project dependencies using the npm.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](332eca24-e97d-470d-a00f-882dbf2092aa.xhtml), *Building a Web
    Messenger with Microservices*, we are going to extend this application and create
    services that will handle the store inventory.
  prefs: []
  type: TYPE_NORMAL
