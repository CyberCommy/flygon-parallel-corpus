- en: Online Video Game Store with Django
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I was born in the late seventies, which means that I grew up during the birth
    of the video game industry. My first video game console was the Atari 2600, and
    it was because of that specific video game console that I decided that I wanted
    to be a programmer and make video games. I never got a job within the gaming industry,
    however, but I still love playing video games, and in, my spare time, I try to
    develop my own games.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: To this day, I still go around the internet—especially eBay—buying old video
    games to bring back my nice childhood memories when all the family, my parents,
    and my sister, used to play Atari 2600 games together.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Because of my interest in vintage video games, we are going to develop a vintage
    video game online store; this will be a great way to develop something fun and
    also learn a lot about web development with the popular Django web framework.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the environment
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Django project
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Django apps
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the Django admin interface
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to create an application model and perform queries with the Django
    ORM
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, as an extra, we will be using the **npm** (**Node Package Manager**) to
    download the client-side dependencies. We will also cover how to create simple
    tasks using the task runner Gulp.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: To make our application prettier without a lot of effort, we are going to use
    Bootstrap.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: So, let's get started!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the development environment
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As usual, we are going to start setting up the environment for development.
    In [Chapter 4](2223dee0-d5de-417e-9ca9-6bf4a6038cb6.xhtml), *Exchange Rates and
    the Currency Conversion Tool*, you were introduced to `pipenv`, so in this and
    the following chapters, we are going to be using `pipenv` to create our virtual
    environment and manage our dependencies.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we want to create the directory where we are going to keep our project.
    In your working directory, create a directory called `django-project` as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now we can run `pipenv` to create our virtual environment:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you have Python 3 installed in another location, you can use the argument
    `--python` and specify the path where the Python executable is located. If everything
    went fine, you should see an output such as the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ade4540c-d7e8-469a-ac30-b921844e9030.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: 'Now we can activate our virtual environment using the `pipenv` command shell:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Great! The only dependency that we are going to add for now is Django.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, Django 2.0 had been released. It has really
    nice features compared to its predecessor. You can see the list of new features
    at [https://docs.djangoproject.com/en/2.0/releases/2.0/](https://docs.djangoproject.com/en/2.0/releases/2.0/).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s install Django in our virtual environment:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Django 2.0 has dropped support for Python 2.0, so if you are planning to develop
    an application using Python 2, you should install Django 1.11.x or lower. I strongly
    recommend that you start a new project using Python 3\. Python 2 will stop being
    maintained after a couple of years, and new packages will be created for Python
    3\. Popular packages of Python 2 will migrate to Python 3.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'In my opinion, the best new feature of Django 2 is the new routing syntax,
    because now it is not necessary to write regular expressions. It is much cleaner
    and more readable to write something like the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The previous syntax relied more on regular expressions:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It is much simpler this way. Another feature that I really like in Django 2.0
    is that they have improved the admin UI a little bit and made it responsive; this
    is a great feature, because I have experienced that creating a new user (while
    you are on the go with no access to a desktop) on a non-responsive site on a small
    mobile phone screen can be painful.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Installing Node.js
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to web development, it is almost impossible to stay away from
    Node.js. Node.js is a project that was released back in 2009\. It is a JavaScript
    runtime that allows us to run JavaScript on the server-side. Why do we care about
    Node.js if we are developing a website using Django and Python? The reason is
    that the Node.js ecosystem has several tools that will help us to manage the client-side
    dependencies in a simple manner. One of these tools that we are going to use is
    the npm.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Think about npm as the `pip` of the JavaScript world. npm, however, has many
    more features. One of the features that we are going to use is npm scripts.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: So, let's go ahead and install Node.js. Usually, developers need to go over
    to the Node.js website and download it from there, but I find it much simpler
    to use a tool called NVM, which allows us to install and switch easily between
    different versions of Node.js.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: To install NVM in our environment, you can follow the instructions at [https://github.com/creationix/nvm](https://github.com/creationix/nvm).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: We are covering installation of NVM on Unix/Linux and macOS systems. If you
    are using Windows, there's an awesome version for Windows that has been developed
    in the Go language; it can be found at [https://github.com/coreybutler/nvm-windows](https://github.com/coreybutler/nvm-windows).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'When NVM is installed, you are ready to install the latest version of Node.js
    with the following command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can verify if the installation is correct with the command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: While writing this book, the latest Node.js version is v8.8.1.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also type `npm` on the terminal, where you should see an output similar
    to the output that follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/36ec4dc3-0d99-4c0e-8604-c7a67979e542.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
- en: Creating a new Django project
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a new Django project, run the following command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that `django-admin` created a directory called `gamestore` that contains
    some boilerplate code for us. We will go through the files that Django created
    in a little while, but, first, we are going to create our first Django application.
    In the Django world, you have the project and the application, and according to
    the Django documentation, the project describes the web application itself, and
    the application is a Python package that provides some kind of feature; these
    applications contain their own set of routes, views, static files and can be reused
    across different Django projects.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry if you don't understand it completely; you will learn more as we
    progress.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'With that said, let''s create the project''s initial application. Run `cd gamestore`,
    and once you are inside the `gamestore` directory, execute the following command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you list the contents of the `gamestore` directory, you should see a new
    directory named `main`; that's the directory of the Django application that we
    are going to create.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'Without writing any code at all, you already have a totally functional web
    application. To run the application and see the results, run the following command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You should see the following output:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Open your favorite web browser, and go to `http://127.0.0.1:8000`, where you
    will see the following page:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/91704c14-da95-48eb-9d06-64970b558e88.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
- en: 'One thing to note when we start the application for the first time is the following
    warning:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This means that the apps that are registered by default on a Django project,
    `admin`, `auth`, `contenttypes`, and `sessions` have migrations (database changes)
    that haven''t been applied to this project. We can run these migrations with the
    following command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here Django created all the tables in a SQLite database, you will find the SQLite
    database file in the application's `root` directory.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: The `db.sqlite3` file is the database file that contains the tables for our
    application. The choice of SQLite is just to make the application simpler for
    this chapter. Django supports a large set of databases; the most popular databases,
    such as, Postgres, Oracle, and even MSSQL are supported.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the `runserver` command again, there should not be any migration
    warnings:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果再次运行`runserver`命令，就不应该有任何迁移警告了：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now there's only one thing that we need to do to wrap this section up; we need
    to create an administrator user so we can log in to the Django admin UI and administrate
    our web application.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要做一件事来结束这一部分；我们需要创建一个管理员用户，这样我们就可以登录到Django管理界面并管理我们的Web应用程序。
- en: 'As with everything else in Django, this is very simple. Just run the following
    command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 与Django中的其他一切一样，这非常简单。只需运行以下命令：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You will be asked to enter a username and email and to set the password, that
    is all you have to do to set an administrator account.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你将被要求输入用户名和电子邮件，并设置密码，这就是你设置管理员帐户所需要做的一切。
- en: In the next section, we are going to have a closer look at the files that the
    Django created for us.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将更仔细地查看Django为我们创建的文件。
- en: Exploring the Django project's structure
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Django项目的结构
- en: 'If you look at the Django website, it says *Django: The Web framework for perfectionists
    with deadlines,* and I could not agree more with this statement. So far, we haven''t
    written any lines of code, and we already have a site up and running. In just
    a few commands, we can create a new project with the same directory structure
    and boilerplate code. Let''s start with the development.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看一下Django的网站，它说*Django：完美主义者的网络框架，有截止日期*，我完全同意这个说法。到目前为止，我们还没有写任何代码，我们已经有了一个正在运行的网站。只需几个命令，我们就可以创建一个具有相同目录结构和样板代码的新项目。让我们开始开发。
- en: We can set up a new database and create a superuser, and, on the top of that,
    Django comes with a very nice and useful admin UI, where you can visualize our
    data, , and users.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以设置一个新的数据库并创建一个超级用户，而且，Django还带有一个非常好用和有用的管理界面，你可以在其中查看我们的数据和用户。
- en: In this section, we are going to explore the code that Django created for us
    when starting a new project so that we can get familiar with the structure. Let's
    go ahead and start adding the other components of our project.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将探索Django在启动新项目时为我们创建的代码，以便我们熟悉结构。让我们继续添加项目的其他组件。
- en: If you have a look inside of the project's root directory, you will find a file
    called `db.sqlite3`, another file called `manage.py`, and, lastly, a directory
    with the same name as the project, in our case `gamestore`. The `db.sqlite3` file,
    as the name suggests, is the database file; this file is created here on the project's
    root folder because we are working with SQLite. You can explore this file directly
    from the command line; we are going to demonstrate how to do that shortly.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看项目的根目录，你会发现一个名为`db.sqlite3`的文件，另一个名为`manage.py`的文件，最后，还有一个与项目同名的目录，在我们的例子中是`gamestore`。`db.sqlite3`文件，顾名思义，是数据库文件；这个文件是在项目的根文件夹中创建的，因为我们正在使用SQLite。你可以直接从命令行探索这个文件；我们很快会演示如何做到这一点。
- en: The second file is `manage.py`. This file is created automatically by the `django-admin`
    in every Django project. It basically does the same things as `django-admin`,
    plus two extra things; it will set the `DJANGO_SETTINGS_MODULE` to point to the
    project's setting file and also put the project's package on the `sys.path`. If
    you execute `manage.py` without any arguments, you can see the help with all the
    commands available.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个文件是`manage.py`。这个文件是由`django-admin`在每个Django项目中自动创建的。它基本上做的事情和`django-admin`一样，再加上两件额外的事情；它会将`DJANGO_SETTINGS_MODULE`设置为指向项目的设置文件，并将项目的包放在`sys.path`上。如果你执行`manage.py`而没有任何参数，你可以看到所有可用命令的帮助。
- en: As you can see with `manage.py`, you have many options, such as manage passwords,
    create a superuser, manage the database, create and execute database migrations,
    start new apps and projects, and a very important option in `runserver`, which,
    as the name says, will start the Django development server for you.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`manage.py`有许多选项，比如管理密码，创建超级用户，管理数据库，创建和执行数据库迁移，启动新应用和项目，以及一个非常重要的选项`runserver`，正如其名字所示，它将为你启动Django开发服务器。
- en: 'Now that we have learned about `manage.py` and how to execute its commands,
    we are going to take a step back and learn how to inspect the database that we
    just created. The command to do that is `dbshell`; let''s give it a go:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了`manage.py`以及如何执行它的命令，我们将退一步，学习如何检查我们刚刚创建的数据库。做到这一点的命令是`dbshell`；让我们试一试：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Diving into the SQLite
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入SQLite
- en: 'You should get into the SQLite3 command prompt:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该进入SQLite3命令提示符：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you want to get a list of all the database''s tables, you can use the command
    `.tables`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想获取数据库的所有表的列表，可以使用命令`.tables`：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here you can see that we have all the tables that we created through the `migrate`
    command.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里你可以看到，我们通过`migrate`命令创建的所有表。
- en: 'To look at every table structure, you can use the command `.schema`, and we
    can use the option `--indent`, so the output will be displayed in a more readable
    manner:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看每个表的结构，可以使用命令`.schema`，我们可以使用选项`--indent`，这样输出将以更可读的方式显示：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: These are the commands that I use the most when working with SQLite3 databases,
    but the command-line interface offers a variety of commands. You can use the `.help` command
    to get a list of all available commands.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我在使用SQLite3数据库时最常用的命令，但命令行界面提供了各种命令。你可以使用`.help`命令获取所有可用命令的列表。
- en: SQLite3 databases are very useful when creating prototypes, creating proof of
    concept projects, or for creating really small projects. If our project does not
    fall in any of these categories, I would recommend using other SQL databases,
    such as MySQL, Postgres, and Oracle. There are also non-SQL databases, such as
    MongoDB. With Django, you can use any of these databases without any problem;
    if you are using the Django **ORM** (**Object relation model**), most of the time
    you can switch between databases, and the application will continue to work perfectly.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建原型、概念验证项目或者创建非常小的项目时，SQLite3数据库非常有用。如果我们的项目不属于这些类别中的任何一种，我建议使用其他SQL数据库，比如MySQL、Postgres和Oracle。还有非SQL数据库，比如MongoDB。使用Django，你可以毫无问题地使用这些数据库；如果你使用Django的ORM（对象关系模型），大部分时间你可以在不同的数据库之间切换，应用程序仍然可以完美地工作。
- en: Looking at the project's package directory
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看项目的包目录
- en: Next, let's have a look at the project's package directory. There, you will
    find a bunch of files. The first file you will see is `settings.py`, which is
    a very important file, as it is where you are going to put all the settings of
    our application. In this settings file, you can specify which apps and database
    you will use, and you can also tell Django where to search for static files and
    templates, middlewares, and more.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看项目的包目录。在那里，你会找到一堆文件。你会看到的第一个文件是`settings.py`，这是一个非常重要的文件，因为你将在这里放置我们应用程序的所有设置。在这个设置文件中，你可以指定将使用哪些应用程序和数据库，你还可以告诉Django在哪里搜索静态文件和模板、中间件等。
- en: 'Then you have the `urls.py`; this file is where you specify the URLs that will
    be available on your application. You can setup URLs on the project level but
    also for every Django app. If you examine the contents of this `urls.py` file,
    you won''t find much detail. Basically, you will see text explaining how to add
    new URLs, but Django has defined (out of the box) a URL to the Django admin site:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你有`urls.py`；这个文件是你指定应用程序可用的URL的地方。你可以在项目级别设置URL，也可以为每个Django应用程序设置URL。如果你检查这个`urls.py`文件的内容，你不会找到太多细节。基本上，你会看到一些解释如何添加新的URL的文本，但Django已经定义了（开箱即用）一个URL到Django管理站点：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We are going to go through the process of adding new URLs to the project, but
    we can explain this file anyway; remember when I mentioned that in Django you
    can have diverse apps? So `django.contrib.admin` is also an app, and an app has
    its own set of URLs, views, templates. So what it is doing here? When we import
    the admin app and then define a list called `urlpatterns`, in this list we use
    a function path where the first argument is the URL, and the second argument here
    can be a view that is going to be executed. But in this case, it is passing the
    URLs of the `admin.site` app, which means that `admin/` will be the base URL,
    and all the URLs defined in `admin.site.urls` will be created under it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐步介绍如何向项目添加新的URL，但无论如何我们都可以解释这个文件；还记得我提到过在Django中可以有不同的应用吗？所以`django.contrib.admin`也是一个应用，而一个应用有自己的一组URL、视图、模板。那么它在这里做什么？当我们导入admin应用然后定义一个名为`urlpatterns`的列表时，在这个列表中我们使用一个名为path的函数，第一个参数是URL，第二个参数可以是一个将要执行的视图。但在这种情况下，它传递了`admin.site`应用的URL，这意味着`admin/`将是基本URL，而`admin.site.urls`中定义的所有URL将在其下创建。
- en: 'For example, if in `admin.site.url`, I have defined two URLs, `users/` and
    `groups/`, when I have `path(''admin/'', admin.site.urls)`, I will be actually
    creating two URLs:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果在`admin.site.url`中，我定义了两个URL，`users/`和`groups/`，当我有`path('admin/', admin.site.urls)`时，我实际上将创建两个URL：
- en: '`admin/users/`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`admin/users/`'
- en: '`admin/groups/`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`admin/groups/`'
- en: Lastly, we have the `wsgi.py`, which is a simple WSGI configuration that Django
    creates for us when creating a new project.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`wsgi.py`，这是Django在创建新项目时为我们创建的一个简单的WSGI配置。
- en: Now that we are a bit more familiar with the Django's project structure, it
    is time to create our project's first app.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对Django项目的结构有了一些了解，是时候创建我们项目的第一个应用了。
- en: Creating the project's main app
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建项目的主要应用
- en: In this section, we are going to create our first Django app. One Django project
    can contain multiple apps. Splitting the project into apps is a good practice
    for many reasons; the most obvious is that you can reuse the same app across different
    projects. Another reason to split the project into multiple apps is that it enforces
    separation of concerns. Your project will be more organized, easier to reason,
    and our colleagues will thank you because it will be much easier to maintain.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将创建我们的第一个Django应用程序。一个Django项目可以包含多个应用程序。将项目拆分为应用程序是一个很好的做法，原因有很多；最明显的是你可以在不同的项目中重用相同的应用程序。将项目拆分为多个应用程序的另一个原因是它强制实现关注点的分离。你的项目将更有组织，更容易理解，我们的同事会感谢你，因为这样维护起来会更容易。
- en: 'Let''s go ahead and run the command `startapp`, and, as shown before, you can
    either use the `django-admin` command or use `manager.py`. As we created the project
    using the `django-admin` command, it is a good opportunity to test the `manager.py`
    command. To create a new Django app, run the following command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续运行`startapp`命令，并且，如前所示，你可以使用`django-admin`命令或者使用`manager.py`。由于我们使用`django-admin`命令创建了项目，现在是一个很好的机会来测试`manager.py`命令。要创建一个新的Django应用程序，请运行以下命令：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we are going to create an app named `main`. Don't worry that no output
    is displayed, Django creates the project and the app silently. If you get a list
    of the directory contents now, you will see that there is a directory named `main`,
    and inside the `main` directory you will find some files; we are going to explain
    every file while we are adding changes to it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建一个名为`main`的应用程序。不要担心没有显示任何输出，Django会悄悄地创建项目和应用程序。如果你现在列出目录内容，你会看到一个名为`main`的目录，而在`main`目录中你会找到一些文件；我们将在添加更改时解释每个文件。
- en: 'So, the first thing we want to do is to add a landing page to our application.
    To do that, we have to do three things:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们想要做的第一件事是为我们的应用程序添加一个登陆页面。为此，我们需要做三件事：
- en: First, we add a new URL to tell Django that when a user of our site browses
    to the root, it should go the site `/` and display some content
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们添加一个新的URL，告诉Django当我们网站的用户浏览到根目录时，它应该转到站点`/`并显示一些内容
- en: The second step is to add a view that will be executed when the user browses
    to the site's root ``/``
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二步是添加一个视图，当用户浏览到站点的根目录``/``时将执行该视图
- en: The last step is to add an HTML template with the content that we want to display
    to the users
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一步是添加一个包含我们希望向用户显示的内容的HTML模板
- en: 'With that said, we need to include a new file called `urls.py` inside of the
    `main` app directory. First, we add some imports:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这一点，我们需要在`main`应用程序目录中包含一个名为`urls.py`的新文件。首先，我们添加一些导入：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the preceding code, we imported the function path from `django.urls`. The
    path function will return an element to be included in the `urlpatterns` list,
    and we also import the views file in the same directory; we want to import this
    view because it is there that we are going to define functions that will be executed
    when a specific route is accessed:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们从`django.urls`中导入了path函数。path函数将返回一个要包含在`urlpatterns`列表中的元素，我们还在同一目录中导入了views文件；我们想要导入这个视图，因为我们将在那里定义在访问特定路由时将执行的函数：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Then we use the path function to define a new route. The first argument of the
    function path is a string that contains the URL pattern that we wish to make available
    in our application. This pattern may contain angle brackets (for example, `<int:user_id>`)
    to capture parameters passed on the URL, but, at this point, we are not going
    use it; we just want to add a URL for the application's root, so we add an empty
    string `''`. The second argument is the function that is going to be executed,
    and, optionally, you can add the keyword argument `name`, which sets the URL's
    name. We will see why this is useful in a short while.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用path函数来定义一个新的路由。函数path的第一个参数是一个包含我们希望在应用程序中提供的URL模式的字符串。这个模式可能包含尖括号（例如`<int:user_id>`）来捕获URL上传递的参数，但是在这一点上，我们不打算使用它；我们只是想为应用程序的根添加一个URL，所以我们添加一个空字符串`''`。第二个参数是将要执行的函数，可选地，您可以添加关键字参数`name`，它设置URL的名称。我们很快就会看到为什么这很有用。
- en: 'The second part is to define the function called `index` in the `views.py`
    file, as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分是在`views.py`文件中定义名为`index`的函数，如下所示：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As there are not too many things going on at this point, we first import the
    render function from `django.shortcuts`. Django has its own template engine that
    is built into the framework, and it is possible to change the default template
    engine to other template engines you like (such as Jinja2, which is one of the
    most popular template engines in the Python ecosystem), but, for simplicity, we
    are going to use the default engine. The `render` function gets the request object,
    the template, and a context object; the latter is an object that contains data
    to be displayed in the template.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此时没有太多事情要做，我们首先从`django.shortcuts`中导入render函数。Django有自己的模板引擎，内置在框架中，可以将默认模板引擎更改为您喜欢的其他模板引擎（例如Jinja2，这是Python生态系统中最受欢迎的模板引擎之一），但是为了简单起见，我们将使用默认引擎。`render`函数获取请求对象、模板和上下文对象；后者是一个包含要在模板中显示的数据的对象。
- en: 'The next thing we need to do is to add a template that will contain the content
    that we want to display when the user browses to our application. Now, most of
    the web application''s pages contain parts that never change, such as a top menu
    bar or a page''s footer, and these parts can be put into a separate template that
    can be reused by other templates. Luckily, the Django template engine has this
    feature. In fact, we can not only inject sub-templates inside a template, but
    also we can have a base template that will contain the HTML that will be shared
    between all of the pages. With that said, we are going to create a file called
    `base.html` inside the `gamestore/templates` directory that has the following
    contents:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的下一件事是添加一个模板，该模板将包含我们希望在用户浏览我们的应用程序时显示的内容。现在，大多数Web应用程序的页面包含永远不会改变的部分，例如顶部菜单栏或页面页脚，这些部分可以放入一个单独的模板中，可以被其他模板重用。幸运的是，Django模板引擎具有这个功能。事实上，我们不仅可以在模板中注入子模板，还可以有一个基本模板，其中包含将在所有页面之间共享的HTML。说到这一点，我们将在`gamestore/templates`目录中创建一个名为`base.html`的文件，其中包含以下内容：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We are not going to go through all the HTML parts, just the parts that are
    the specific syntax of Django''s template engine:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不打算逐个讨论所有HTML部分，只讨论Django模板引擎的特定语法部分：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The first thing to note here is `{% load static %}`, which will tell Django''s
    template engine that we want to load the static template tag. The static template
    tag is used to link static files. These files can be images, JavaScript, or Stylesheet
    files. How does Django find those files, you may ask, and the answer is simple:
    by magic! No, just kidding; the static template tag will look for the files in
    the directory specified in the `STATIC_ROOT` variable in the `settings.py` file;
    in our case we defined `STATIC_ROOT = ''/static/''`, so when using the tag `{%
    static ''styles/site.css'' %}` the link `/static/styles/site.css` will be returned.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的第一件事是`{% load static %}`，它将告诉Django的模板引擎我们要加载静态模板标签。静态模板标签用于链接静态文件。这些文件可以是图像、JavaScript或样式表文件。你可能会问，Django是如何找到这些文件的呢，答案很简单：通过魔法！不，开玩笑；静态模板标签将在`settings.py`文件中的`STATIC_ROOT`变量指定的目录中查找文件；在我们的情况下，我们定义了`STATIC_ROOT
    = '/static/'`，所以当使用标签`{% static 'styles/site.css' %}`时，链接`/static/styles/site.css`将被返回。
- en: You may be wondering, why not just write `/static/styles/site.css` instead of
    using the tag? The reason for this is that the tag gives us much more flexibility
    for change in case we need to update the path where we serve our static files.
    Imagine a situation where you have a large application with hundreds of templates,
    and in all of them, you hardcode `/static/` and then decide to change that path
    (and you don't have a team). You would need to change every single file to perform
    this change. If you use the static tag, you can simply move the files to a different
    location, and the tag changes the value of the `STATIC_ROOT` variable in the settings
    files.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，为什么不只写`/static/styles/site.css`而不使用标签？这样做的原因是，标签为我们提供了更多的灵活性，以便在需要更新我们提供静态文件的路径时进行更改。想象一种情况，你有一个包含数百个模板的大型应用程序，在所有这些模板中，你都硬编码了`/static/`，然后决定更改该路径（而且你没有团队）。你需要更改每个文件来执行此更改。如果你使用静态标签，你只需将文件移动到不同的位置，标签就会更改`STATIC_ROOT`变量在设置文件中的值。
- en: 'Another tag that we are using in this template is the `block` tag:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个模板中使用的另一个标签是`block`标签：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `block` tag is very simple; it defines an area in the base template that
    can be used by children templates to inject content in that area. We are going
    to see exactly how this works when we create the next template file.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`block`标签非常简单；它定义了基本模板中可以被子模板用来在该区域注入内容的区域。当我们创建下一个模板文件时，我们将看到这是如何工作的。'
- en: 'The third part is to add the template. The `index` function is going to render
    a template stored at `main/index.html`, which means that it will leave it in the
    directory `main/templates/main/`. Let''s go ahead and create the folder `main/templates`
    and then `main/templates/main`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 第三部分是添加模板。`index`函数将呈现存储在`main/index.html`的模板，这意味着它将留在`main/templates/main/`目录中。让我们继续创建文件夹`main/templates`，然后`main/templates/main`：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create a file called `index.html`  in the directory `main/templates/main/`,
    with the contents as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main/templates/main/`目录中创建一个名为`index.html`的文件，内容如下：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, here, we start off by extending the base template, which means
    that all the content of the `base.html` file will be used by the Django template
    engine to build the HTML that will be provided back to the browser when the user
    browses to `/`. Now, we also use the `block` tag; in this context, it means that
    the engine will search for a block tag named `'content'` in the `base.html` file,
    and, if it finds it, the engine will insert the `h1 html` tab inside the `'content'`
    block.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这里看到的，我们首先扩展了基本模板，这意味着`base.html`文件的所有内容将被Django模板引擎用来构建HTML，当用户浏览到`/`时，将提供给浏览器。现在，我们还使用了`block`标签；在这种情况下，它意味着引擎将在`base.html`文件中搜索名为`'content'`的块标签，如果找到，引擎将在`'content'`块中插入`h1
    html`标签。
- en: This is all about reusability and maintainability of code, because you don't
    need to insert the menu markup and tags to load JavaScript and CSS files in every
    single template of our application; you just need to insert them in the base template
    and use the `block` tag here. The content will change. A second reason to use
    base templates is that, again, imagine a situation where you need to change something—let's
    say the top menu that we defined in the `base.html` file, as the menu is only
    defined in the `base.html` file. All you need to do to perform changes is to change
    the markup in the `base.html`, and all the other templates will inherit the changes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都是关于代码的可重用性和可维护性，因为你不需要在我们应用程序的每个单个模板中插入菜单标记和加载JavaScript和CSS文件的标记；你只需要在基本模板中插入它们并在这里使用`block`标签。内容会改变。使用基本模板的第二个原因是，再次想象一种情况，你需要改变一些东西——比如我们在`base.html`文件中定义的顶部菜单，因为菜单只在`base.html`文件中定义。要执行更改，你只需要在`base.html`中更改标记，所有其他模板将继承更改。
- en: We are almost ready to run our code and see how the application is looking so
    far, but, first, we need to install some client-side dependencies.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎准备好运行我们的代码并查看应用程序目前的外观了，但首先，我们需要安装一些客户端依赖项。
- en: Installing client-side dependencies
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装客户端依赖项
- en: 'Now that we have NodeJS installed, we can install the project''s client-side
    dependencies. As the focus of this chapter is Django and Python, we don''t want
    to spend too much time styling our application and going through huge CSS files.
    However, we do want our application to look great, and for this reason we are
    going to install two things: Bootstrap and Font Awesome.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了NodeJS，我们可以安装项目的客户端依赖项。由于本章的重点是Django和Python，我们不想花太多时间来设计我们的应用程序并浏览庞大的CSS文件。然而，我们希望我们的应用程序看起来很棒，因此我们将安装两样东西：Bootstrap和Font
    Awesome。
- en: Bootstrap is a very well-known toolkit that has been around for many years.
    It has a very nice set of components, a grid system, and plugins that will help
    us make our application look great for our users when they are browsing the application
    on a desktop, or even a mobile device.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap是一个非常著名的工具包，已经存在多年了。它有一套非常好的组件、网格系统和插件，将帮助我们使我们的应用程序在用户在桌面上浏览应用程序或者甚至移动设备上浏览应用程序时看起来很棒。
- en: Font Awesome is another project that has been around for a while, and it is
    a font and icons framework.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Font Awesome是另一个存在已久的项目，它是一个字体和图标框架。
- en: To install these dependencies, we could just run the npm's install command.
    However, we are going to do better. Similar to `pipenv`, which creates a file
    for our Python dependencies, `npm` has something similar. This file is called
    `package.json`, and it contains not only the project's dependencies but also scripts
    and meta information about the package.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装这些依赖项，我们可以直接运行npm的安装命令。然而，我们要做得更好。类似于`pipenv`，它为我们的Python依赖项创建一个文件，`npm`也有类似的东西。这个文件叫做`package.json`，它不仅包含了项目的依赖项，还包含了关于包的脚本和元信息。
- en: 'So let''s go ahead and add the `package.json` file to the `gamestore/` directory,
    with the following content:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续将`package.json`文件添加到`gamestore/`目录中，内容如下：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Great! Save the file, and run this command on the terminal:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！保存文件，并在终端上运行以下命令：
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If everything goes well, you should see a message saying that two packages have
    been installed.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您应该会看到一条消息，说明已安装了两个软件包。
- en: If you list the contents of the `gamestore` directory, you will see that `npm`
    created a new directory called `node_modules`, and it is there that `npm` installed
    Bootstrap and Font Awesome.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列出`gamestore`目录的内容，您将看到`npm`创建了一个名为`node_modules`的新目录，`npm`安装了Bootstrap和Font
    Awesome。
- en: For simplicity, we are going to just copy the CSS files and fonts that we need
    to the `static` folder. However, when building an application, I would recommend
    using tools such as `webpack`, which will bundle all our client-side dependencies
    and set up a `webpack` dev server to serve the files for your Django application.
    Since we want to focus on Python and Django we can just go ahead and copy the
    files manually.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为简单起见，我们将只复制我们需要的CSS文件和字体到`static`文件夹。 但是，在构建应用程序时，我建议使用诸如`webpack`之类的工具，它将捆绑所有我们的客户端依赖项，并设置`webpack`开发服务器来为您的Django应用程序提供文件。
    由于我们想专注于Python和Django，我们可以继续手动复制文件。
- en: 'First, we can create the directory of the CSS files as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以按以下方式创建CSS文件的目录：
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then we need to copy the bootstrap files. First, the minified CSS file:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要复制bootstrap文件。 首先是最小化的CSS文件：
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we need to copy the Font Awesome files, starting with the minified CSS:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要复制Font Awesome文件，从最小化的CSS开始：
- en: '[PRE34]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And the fonts:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 和字体：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We are going to add another CSS file that will contain some custom CSS that
    we may add to the application to give a personal touch to the application. Add
    a file called `site.css` in the `gamestore/static/styles` directory with the following
    contents:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加另一个CSS文件，其中将包含我们可能添加到应用程序中的一些自定义CSS，以赋予应用程序个性化的外观。 在`gamestore/static/styles`目录中添加一个名为`site.css`的文件，内容如下：
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'There are a few things we need to do to run our application for the first time;
    first, we need to add the main app that we created to the `INSTALLED_APPS` list
    in the `settings.py` file in the `gamestore/gamestore` directory. It should look
    like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做一些事情来第一次运行我们的应用程序； 首先，我们需要将我们创建的主应用程序添加到`gamestore/gamestore`目录中的`settings.py`文件的`INSTALLED_APPS`列表中。
    它应如下所示：
- en: '[PRE37]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the same settings file you will find the list `TEMPLATES`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一设置文件中，您将找到列表`TEMPLATES`：
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The value of `DIRS` is an empty list. We need to change it to:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`DIRS`的值是一个空列表。 我们需要将其更改为：'
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: That will tell Django to search for templates in the `templates` directory.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉Django在`templates`目录中搜索模板。
- en: 'Then, at the end of the `settings.py` file, add the following line:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`settings.py`文件的末尾添加以下行：
- en: '[PRE40]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This will tell Django to search for static files in the `gamestore/static` directory.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉Django在`gamestore/static`目录中搜索静态文件。
- en: 'Now we need to tell Django to register the URLs that we have defined in the
    `main` app. So, let''s go ahead and open the file `urls.py` in the `gamestore/gamestore`
    directory. We need to include  `"main.urls"` in the `urlpatterns` list. After
    the changes, the `urls.py` file should look like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要告诉Django注册我们在`main`应用程序中定义的URL。 因此，让我们继续打开`gamestore/gamestore`目录中的文件`urls.py`。
    我们需要在`urlpatterns`列表中包含`"main.urls"`。 更改后，`urls.py`文件应如下所示：
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note that we also need to import the `include` function of the `django.urls`
    module.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还需要导入`django.urls`模块的`include`函数。
- en: 'Great! Now we have all the client-site dependencies in place and ready to be
    used by our application, and we can start the application for the first time to
    see the changes that we have implemented so far. Open the terminal, and use the
    command `runserver` to start Django''s development server, like so:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！ 现在我们已经准备好使用我们的应用程序中的所有客户端依赖项，并且可以第一次启动应用程序以查看我们迄今为止实施的更改。 打开终端，并使用`runserver`命令启动Django的开发服务器，如下所示：
- en: '[PRE42]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Browse to `http://localhost:8000`; you should see a page like the one shown
    in the following screenshot:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览到`http://localhost:8000`； 您应该看到一个页面，类似于以下截图所示的页面：
- en: '![](assets/b2034c76-688d-456c-9e99-41b3b0429427.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b2034c76-688d-456c-9e99-41b3b0429427.png)'
- en: Adding login and logout views
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加登录和注销视图
- en: Every online store needs some sort of user management. Our application's users
    should be able to create an account, change their account details, obviously log
    in to our application so they can place orders, and also log out from the application.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 每个在线商店都需要某种用户管理。 我们应用的用户应该能够创建帐户，更改其帐户详细信息，显然登录到我们的应用程序，以便他们可以下订单，还可以从应用程序注销。
- en: We are going to start adding the login and logout functionality. The good news
    is that it is super easy to implement in Django.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始添加登录和注销功能。 好消息是，在Django中实现这一点非常容易。
- en: First, we need to add a Django form to our login page. Django has a built-in
    form of authentication; however, we want to customize it, so we are going to create
    another class that inherits from the Django built-in `AuthenticationForm` and
    add our changes.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在我们的登录页面上添加一个Django表单。 Django有一个内置的身份验证表单； 但是，我们想要自定义它，所以我们将创建另一个类，该类继承自Django内置的`AuthenticationForm`并添加我们的更改。
- en: 'Create a file called `forms.py` in `gamestore/main/` with the following content:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在`gamestore/main/`中创建一个名为`forms.py`的文件，内容如下：
- en: '[PRE43]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This class is quite simple. First, we import `forms` from the `django` module
    and the `AuthenticationForm` from `django.contrib.auth.forms`, and then we create
    another class, also called `AuthenticationForm`, which inherits from Django''s
    `AuthenticationForm`. Then we define two properties, the username and the password.
    We define the username as an instance of `CharField` , and there are some keyword
    arguments that we pass in its constructor. They are:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类非常简单。 首先，我们从`django`模块导入`forms`和从`django.contrib.auth.forms`导入`AuthenticationForm`，然后我们创建另一个类，也称为`AuthenticationForm`，它继承自Django的`AuthenticationForm`。
    然后我们定义两个属性，用户名和密码。 我们将用户名定义为`CharField`的一个实例，并在其构造函数中传递一些关键字参数。 它们是：
- en: '`max_length`, which, as the name suggests limits the size of the string to
    `50` characters.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max_length`，顾名思义，限制字符串的大小为`50`个字符。'
- en: We also use the `widget` argument, which specifies how this property will be
    rendered on the page. In this case, we want to render it as an input text element,
    so we pass an instance to `TextInput`. It is possible to pass some options to
    the `widget`; in our case, here we pass `'class'`, which is the CSS class and
    the placeholder.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还使用了`widget`参数，指定了如何在页面上呈现此属性。在这种情况下，我们希望将其呈现为输入文本元素，因此我们传递了一个`TextInput`实例。可以向`widget`传递一些选项；在我们的情况下，这里我们传递了`'class'`，这是CSS类和占位符。
- en: All these options will be used when the template engine renders this property
    on the page.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当模板引擎在页面上呈现此属性时，所有这些选项都将被使用。
- en: The second property that we define here is the password. We also define it as
    a `CharField`, and, instead of passing `max_length`, this time we set the label
    to `'Password'`. The `widget` we set to `PasswordInput` so the template engine
    will render the field on the page as input with a type equal to the password,
    and, lastly, we define the same settings for this field class and placeholder.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里定义的第二个属性是密码。我们还将其定义为`CharField`，而不是传递`max_length`，这次我们将标签设置为`'Password'`。我们将`widget`设置为`PasswordInput`，这样模板引擎将在页面上将字段呈现为类型等于密码的输入，并且最后，我们为此字段类和占位符定义了相同的设置。
- en: 'Now we can start registering the new URLs for logging in and out. Open the
    file `gamestore/main/urls.py`. To start, we are going to add some `import` statements:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始注册新的登录和注销URL。打开文件`gamestore/main/urls.py`。首先，我们将添加一些`import`语句：
- en: '[PRE44]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'After the `import` statements, we can start registering the authentication
    URLs. At the end of the `urlpattens` list, add the following code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在`import`语句之后，我们可以开始注册身份验证URL。在`urlpattens`列表的末尾，添加以下代码：
- en: '[PRE45]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: So, here we are creating a new URL, `'accounts/login'`, and when requesting
    this URL the function view `login` will be executed. The third argument for the
    path function is a dictionary with some options, and the `template_name` specifies
    the template that will be rendered on the page when browsing to the underlying
    URL. We also define the `authetication_form` with the `AuthenticationForm` value
    that we just created. Lastly, we set the keyword argument `name` to `login`; naming
    the URL is very helpful when we need to create a link for this URL and also improves
    maintainability, because changes in the URL itself won't require changes in the
    templates as the templates reference the URL by its name.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这里我们创建了一个新的URL，`'accounts/login'`，当请求这个URL时，视图函数`login`将被执行。路径函数的第三个参数是一个带有一些选项的字典，`template_name`指定了浏览到底层URL时将呈现在页面上的模板。我们还使用`AuthenticationForm`值定义了`authetication_form`。最后，我们将关键字参数`name`设置为`login`；为这个URL命名在需要创建此URL的链接时非常有帮助，也提高了可维护性，因为URL本身的更改不会要求模板的更改，因为模板通过名称引用URL。
- en: 'Now that the login is in place, let''s add the logout URL:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在登录已经就位，让我们添加注销URL：
- en: '[PRE46]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Similar to the login URL, in the logout URL we use the path function passing
    first the URL itself (`accounts/logout`); we pass the function logout that we
    imported from the Django built-in authentication views, and, as an option, we
    set `next_page` to `/`. This means that when the user logs out, we redirect the
    user to the application's root page. Lastly, we also name the URL as logout.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 与登录URL类似，在注销URL中，我们使用路径函数首先传递URL本身(`accounts/logout`)；我们传递了从Django内置认证视图中导入的函数logout，并且作为一个选项，我们将`next_page`设置为`/`。这意味着当用户注销时，我们将用户重定向到应用程序的根页面。最后，我们还将URL命名为logout。
- en: 'Great. Now it is time to add the templates. The first template that we are
    going to add is the login template. Create a file named `login.html` at `gamestore/templates/` with
    the following contents:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。现在是时候添加模板了。我们要添加的第一个模板是登录模板。在`gamestore/templates/`下创建一个名为`login.html`的文件，内容如下：
- en: '[PRE47]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this template, we also extend the base template, and we add the content of
    the login template with the content block that has been defined in the base template.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模板中，我们还扩展了基本模板，并且我们添加了登录模板的内容，其中包含在基本模板中定义的内容块。
- en: First, we create a `form` tag and set the method to `POST`. Then, we add the
    `csrf_token` tag. The reason we add this tag is to prevent cross-site request
    attacks, where a malicious site performs a request to our site on behalf of the
    current logged in user.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个`form`标签，并将方法设置为`POST`。然后，我们添加`csrf_token`标签。我们添加此标签的原因是为了防止跨站点请求攻击，其中恶意站点代表当前登录用户执行请求到我们的站点。
- en: If you want to know more about this type of attack, you can visit the site at [https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于这种类型的攻击，您可以访问网站[https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF))。
- en: 'After the Cross-Site Request Forgery tag, we add the two fields we need: username
    and password.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在跨站点请求伪造标记之后，我们添加了我们需要的两个字段：用户名和密码。
- en: 'Then we have the following markup:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有以下标记：
- en: '[PRE48]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This is where we are going to display possible authentication errors. The forms
    object has a property called `non_field_error`, which contains errors that are
    not related to field validation. For example, if your user types the wrong username
    or password, then the error will be added the to `non_field_error` list.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将显示可能的身份验证错误的地方。表单对象有一个名为`non_field_error`的属性，其中包含与字段验证无关的错误。例如，如果您的用户输入了错误的用户名或密码，那么错误将被添加到`non_field_error`列表中。
- en: We create a `ul` element (unordered list) and loop through the `non_field_errors`
    list adding `li` elements (list items) with the error text.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个`ul`元素（无序列表）并循环遍历`non_field_errors`列表，添加带有错误文本的`li`元素（列表项）。
- en: 'We have now the login in place, and we need to just include it to the page—more
    specifically, to the `base.html` template. But, first, we need to create a little
    partial template that will display the login and logout links on the page. Go
    ahead and add a file called `_loginpartial.html` to the `gamestore/templates`
    directory that has the following contents:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This partial template will render two different contents depending on whether
    the user is authenticated or not. If the user is authenticated, it will render
    the logout form. Note that the action of the form makes use of the named URL;
    we don't set it to `/accounts/logout` but to `{% url 'logout' %}`.Django's URL
    tag will replace the URL name with the URL. Again, we need to add the `csrf_token`
    tag to prevent Cross-Site Request Forgery attacks, and, finally, we define an
    unordered list with two items; the first item will display the text `Logged as:`
    and the user's username, and the second item on the list will show the logout
    button.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Note that we added an anchor tag inside of the list item element, and that the
    `href` property has some JavaScript code in it. That code is pretty simple; it
    uses the function `getElementById` to get the form and then call the form's submit
    function to submit to the server the request to `/accounts/logout`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: This is just a preference for implementation; you could easily have skipped
    this JavaScript code and added a submit button instead. It would have the same
    effect.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: In case the user is not authenticated, we only show the `login` link. The `login`
    link also uses the URL tag that will replace the name `login` with the URL.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'Great! Let''s add the login partial template to the base template. Open the
    file `base.html` at `gamestore/templates`, and locate the unordered list, shown
    as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We are going to add the `_loginpartial.html` template using the `include` tag:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The include tag will inject the content of the `_loginpartial.html` template
    in this position in the markup.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'The final touch here is to add some styling, so the login page looks nice like
    the rest of the application. Open the file `site.css` in the `gamestore/static/styles` directory,
    and include the following contents:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Testing the login/logout forms
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we try this out, let''s open the file `settings.py` in the `gamestore/gamestore`
    directory, and at the end of the file add the following setting:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This will tell Django that, after the login, the user will be redirected to
    "`/`".
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are ready to test the login and logout functionality, although you probably
    don''t have any users in the database. However, we created the superuser while
    we were setting up our Django project, so go ahead and try logging in with that
    user. Run the command `runserver` to start the Django development server again:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Browse to `http://localhost:8000` and note that you now have the login link
    in the top right corner of the page:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6d74e76d-f481-4eec-9dc9-d8ad6b061fa5.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
- en: 'If you click that, you will be redirected to `/accounts/login`, and the login
    page template that we created will be rendered:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3025a9a4-9ae4-4eed-b361-54290b3e87a9.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
- en: 'First, try typing the wrong password or username so we can verify that the
    error message is being displayed correctly:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ff28669a-804e-448a-9452-632421a24126.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
- en: Great! It works!
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'Now log in with the superuser, and if everything works fine, you should be
    redirected to the application root''s URL. It says, Logged as with your username,
    and right after it there is a logout link. Give it a go, and click on the link
    Log off:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6490f579-a5ca-4bcb-9106-699f74da2029.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
- en: Creating new users
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we are able to log in and log out of our application, we need to add
    another page so the users can create accounts on our application and place orders.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some rules that we want to enforce when creating a new account. The
    rules are:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: The username field is required, and it has to be unique to our application
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The email field is required, and it has to be unique to our application
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last and first name are required
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both password fields are required, and they must match
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If any of these rules are not followed, we will not create the user account,
    and an error should be returned to the user.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'With that said, let''s add a small helper function that will verify whether
    a field has a value that already exists in the database. Open the file `forms.py` in `gamestore/main`.
    First, we need to import the User model:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then, add the `validate_unique_user` function:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This function gets an error message and keyword arguments that will be used
    as a criterion to search for items matching a specific value. We create a variable
    called `existent_user`, and filter the user models passing the criteria. If the
    value of the variable `existent_user` is different to `None`, it means that we
    have found a user who matches our criterion. We then raise a `ValidationError`
    exception with the error message that we passed to the function.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'Nice. Now we can start adding a form that will contain all the fields that
    we want the user to fill out when creating an account. In the same file, `forms.py` in
    the `gamestore/main` directory, add the following class:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: So, we start by creating a class called `SignupForm` that will inherit from
    `Form`, we define a property for every field that is going to be necessary for
    creating a new account, and we add a username, a first and a last name, an email,
    and then two password fields. Note that in the password fields we set the min
    and max length for a password to `6` and `10`, respectively.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing in the same class, `SignupForm`, let''s add a method called `clean_username`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The prefix `clean` in the name of this method will make Django automatically
    call this method when parsing the posted data for the field; in this case, it
    will execute when parsing the field username.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: So, we get the username value, and then call the method `validate_unique_user`,
    passing a default error message and a keyword argument username that will be used
    as a filter criterion.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Another field that we need to verify for uniqueness is the email ID, so let''s
    implement the `clean_email` method, as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: It is basically the same as the clean username. First, we get the email from
    the request and pass it to the `validate_unique_user` function. The first argument
    is the error message, and the second argument is the email that will be used as
    the filter criteria.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'Another rule that we defined for our create account page is that the password
    and (repeat) password fields must match, otherwise an error will be displayed
    to the user. So let''s add the same and implement the clean method, but this time
    we want to validate the `repeat_password` field and not `password`. The reason
    for that is that if we implement a `clean_password` function, at that point `repeat_password`
    won''t be available in the `cleaned_data` dictionary yet, because the data is
    parsed in the same order as they were defined in the class. So, to ensure that
    we will have both values we implement `clean_repeat_password`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Great. So here we first define two variables; `password1`, which is the request
    value for the `password` field, and `password2`, the request value for the field
    `repeat_password`. After that, we just compare if the values are different; if
    they are, we raise a `ValidationError` exception with the error message to inform
    the user that the password didn't match and the account will not be created.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Creating the views of the user creation
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the form and validation in place, we can now add the view that will handle
    the request to create a new account. Open the file `views.py` at `gamestore/main`,
    and start by adding some `import` statements:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: As we will be receiving data from a `POST` request, it is a good idea to add
    Cross-Site Request Forgery checkings, so we need to import the `csrf_protect`
    decorator.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: We also import the `SignupForm` that we just created so we can pass it to the
    view or use it to parse the request data. Lastly, we import the `User` model.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s create the `signup` function:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We start by decorating the `signup` function with the `csrf_protect` decorator.
    The function starts by checking whether the request's HTTP method is equal to
    `POST`; in that case, it will create an instance of the `SignupForm` passing as
    an argument the `POST` data. Then we call the function `is_valid()` on the form,
    which will return true if the form is valid; otherwise it will return  false.
    If the form is valid, we create a new user and call the `save` function, and,
    finally, we render the `create_account_success.html`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: If the request `HTTP` method is a `GET`, the only thing we do is create an instance
    of a `SignupForm` without any argument. After that, we call the `render` function,
    passing as a first argument the `request` object, then the template that we are
    going to render, and, finally, the last argument is the instance of the `SignupForm`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to create both templates referenced in this function in a short
    while, but, first, we need to create a new URL in the `url.py` file at `gamestore/main`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This new URL can be added right at the end of the `urlpatterns` list.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to create the templates. We start with the `signup` template;
    create a file called `signup.html` at `gamestore/main/templates/main` with the
    following contents:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This template is again very similar to the template that we created before,
    in that it extends the base template and injects some data into the base template's
    content block. We add an `h1` tag with the header text and a form with the action
    set to `{% url 'signup' %}`, which the `url` tag will change to `/accounts/signup`,
    and we set the method to `POST`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: As is usual in forms, we use the `csrf_token` tag that will work together with
    the `@csrf_protect` decorator in the `signup` function in the `views` file to
    protect against Cross-Site Request Forgery.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Then we just call `{{ form }}`, which will render the entire form in this area,
    and, right after the fields, we add a button to submit the form.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we create a template for showing that the account has been successfully
    created. Add a file called `create_account_success.html` to the `gamestore/main/templates/main`
    directory with the following contents:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Great! To make it look great, we are going to include some CSS code in the
    file `site.css` in the `gamestore/static` directory. Add the content shown as
    follows, at the end of the file:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'That''s all for the create a user page; let''s give it a go! Start the Django
    developer server again, and browse to `http://localhost:8000/accounts/signup`,
    where you should see the create user form, as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ca34bdb6-e35e-4b9b-9425-9652ba21ef52.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
- en: 'After you fill up all the fields, you should be redirected to a confirmation
    page, like this:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/82ffe42c-8485-4150-8cb8-ec480a29ddd4.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
- en: Perform some tests yourself! Try adding invalid passwords, just to verify that
    the validations we implemented are working properly.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Creating the game data model
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Alright, we can log into our application, we can create new users, and we also
    added the front page template, which is currently blank, but we are going to fix
    that. We have got to the core of this chapter; we are going to start adding models
    that will represent the items that we can buy at the store.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'The requirements for the game''s model that we are going to have on the site
    is:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: The store is going to sell games for different gaming platforms
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There will be a section on the first page that will list highlighted games
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The users of the store should be able to go to the game's details page and see
    more information about the game
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The games should be discoverable by different criteria, for example, developer,
    publisher, release date, and so on
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The administrator of the store should be able to change product details using
    the Django admin UI.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The product's picture can be changed, and if not found, it should show a default
    image
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品的图片可以更改，如果找不到，应该显示默认图片
- en: 'With that said, let''s start adding our first model class. Open the file `models.py`
    in `gamestore/main/`, and add the following code:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们开始添加我们的第一个模型类。在`gamestore/main/`中打开文件`models.py`，并添加以下代码：
- en: '[PRE67]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Here, we have added the class `GamePlatform`, and it will represent the gaming
    platforms that will be available at the store. The class is super simple; we just
    create a class inheriting from the `Model` class, and we define just one property
    called `name`. The name property is defined as a `CharField` of a maximum length
    of 100 characters. Django provides a large variety of data types; you can see
    the complete list at [https://docs.djangoproject.com/en/2.0/ref/models/fields/](https://docs.djangoproject.com/en/2.0/ref/models/fields/).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了`GamePlatform`类，它将代表商店中可用的游戏平台。这个类非常简单；我们只需创建一个从`Model`类继承的类，并且我们只定义了一个名为`name`的属性。`name`属性被定义为最大长度为100个字符的`CharField`。Django提供了各种各样的数据类型；你可以在[https://docs.djangoproject.com/en/2.0/ref/models/fields/](https://docs.djangoproject.com/en/2.0/ref/models/fields/)上看到完整的列表。
- en: Then we override the method `__str__`. This method will dictate how an instance
    of `GamePlatform` will be displayed when being printed out. The reason that I
    am overriding this method is that I want to display the name of `GamePlatform`
    in the list of `GamePlatform` in the Django admin UI.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们重写了`__str__`方法。这个方法将决定`GamePlatform`的实例在被打印出来时如何显示。我重写这个方法的原因是我想在Django管理界面的`GamePlatform`列表中显示`GamePlatform`的名称。
- en: 'The second model class that we are going to add here is the `Game` model. In
    the same file, add the following code:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要添加的第二个模型类是`Game`模型。在同一个文件中，添加以下代码：
- en: '[PRE68]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Like the previous model class that we created, the `Game` class also inherits
    from `Model` and we define all the fields that we need according to the specifications.
    There are some things to note here that are new; the property `release_year` is
    defined as an integer field, and we set the property `null=True`, which means
    that this field will not be required.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前创建的模型类一样，`Game`类也继承自`Model`，我们根据规格定义了所有需要的字段。这里有一些新的需要注意的地方；`release_year`属性被定义为整数字段，并且我们设置了`null=True`属性，这意味着这个字段不是必需的。
- en: Another property that used a different type is the image property, which is
    defined as an `ImageField`, and that will allow us to provide the application's
    administrators the possibility of changing the game's image. This type inherits
    from `FileField`, and in the Django Administration UI the field will be rendered
    as a file picker. The `ImageFile` argument `upload_to` specifies where the image
    will be stored, and the default is the default image that will be rendered if
    the game does not have an image. The last argument that we specify here is `max_length`,
    which is the image path's maximum length.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个使用不同类型的属性是图片属性，它被定义为`ImageField`，这将允许我们为应用程序的管理员提供更改游戏图片的可能性。这种类型继承自`FileField`，在Django管理界面中，该字段将被呈现为文件选择器。`ImageFile`参数`upload_to`指定了图片将被存储的位置，默认是游戏没有图片时将呈现的默认图片。我们在这里指定的最后一个参数是`max_length`，这是图片路径的最大长度。
- en: Then, we define a `ForeignKey`. If you don't know what it is, a foreign key
    is basically a file that identifies a row in another table. In our case, here
    we want the game platform to be associated with multiple games. There are a few
    keyword arguments that we are passing to the definition of the primary key; first
    we pass the foreign key type, the `null` argument is set to `False`, meaning that
    the field is required, and, lastly we set the deletion rule to `CASCADE`, so if
    the application's admin deletes a gaming platform, that operation will cascade
    and delete all the games associated with that specific gaming platform.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义了一个`ForeignKey`。如果你不知道它是什么，外键基本上是一个标识另一个表中行的字段。在我们的例子中，这里我们希望游戏平台与多个游戏相关联。我们传递给主键定义的一些关键字参数；首先我们传递了外键类型，`null`参数设置为`False`，这意味着这个字段是必需的，最后我们将删除规则设置为`CASCADE`，所以如果应用程序的管理员删除了一个游戏平台，该操作将级联并删除与该特定游戏平台相关联的所有游戏。
- en: The last property that we define is the `highlighted` property. Do you remember
    that one of the requirements was to be able to highlight some products and also
    have them in a more visible area so the users can find them easily? This property
    does just that. It is a property type Boolean that has the default value set to
    `False`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的最后一个属性是`highlighted`属性。你还记得我们的一个要求是能够突出一些产品，并且让它们出现在更显眼的区域，以便用户能够轻松找到它们吗？这个属性就是做这个的。它是一个布尔类型的属性，其默认值设置为`False`。
- en: 'Another detail, that I was saving for last is this: have you noticed that we
    have a class named `Meta` inside the model class? This is the way that we can
    add meta information about the model. In this example we are setting a property
    called `ordering` with the value as an array of strings, where each item represents
    a property of the `Game` model, so we have first `-highlighted` - the dash sign
    in front of the property name means descending order—and then we also have the
    name, which will appear in ascending order.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个细节，我留到最后的是：你有没有注意到我们的模型类里有一个名为`Meta`的类？这是我们可以添加关于模型的元信息的方式。在这个例子中，我们设置了一个名为`ordering`的属性，其值是一个字符串数组，其中每个项代表`Game`模型的一个属性，所以我们首先有`-highlighted`，横杠符号表示降序排列，然后我们还有名称，它将以升序排列出现。
- en: 'Let''s continue adding more code to the class:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续向类中添加更多代码：
- en: '[PRE69]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Here, we have two things. First, we assign an instance of a class called `GameManager`,
    which I will go into in more detail in a short while, and we also define the special
    method `__str__`, which defines that when printing an instance of the `Game` object,
    it will display the gaming platform and a symbol dash, followed by the name of
    the name itself.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: 'Before the definition of the `Game`class, let''s add another class called `GameManager`:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Before we get into the details of this implementation, I just want to say a
    few words about `Manager` objects in Django. The `Manager` is the interface between
    the database and the model classes in Django. By default, every model class has
    a `Manager`, and it is accessed through the property objects, so why define our
    own manager? The reason that I implemented a `Manager` for this `models` class
    is that I wanted to leave all the code concerning database operations within the
    model, as it makes the code cleaner and more testable.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: So, here I defined another class, `GameManager`, that inherits from `Manager`,
    and so far we defined three methods—`get_highlighted`, which get all games that
    have the highlighted flag set to `True`, `get_not_highlighted`, which gets all
    games that highlighted flag is set to `False`, and `get_by_platform`, which gets
    all the games given a gaming platform.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'About the two first methods in this class: I could have just used the filter
    function and passed an argument where `highlighted` equals `True` or `False`,
    but, as I mentioned previously, it is much cleaner to have all these methods inside
    the manager.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are ready to create the database. In the terminal, run the following
    command:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'This command will create a migration file with the changes that we just implemented
    in the model. When the migrations are created, we can run the command `migrate` and
    then apply the changes to the database:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Great! Next up, we are going to create a model to store the game's prices.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Creating the price list data model
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another feature that we want to have in our application is the ability to change
    the prices of the products as well as knowing when a price was added and, most
    importantly, when it was last updated. To achieve this, we are going to create
    another model class, called `PriceList`*, *in the `models.py` file in the `gamestore/main/`
    directory, using the following code:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: As you can see here, you have two datetime fields. The first one is `added_at`,
    and it has a property `auto_now_add` equals `True`. What it does is get Django
    to automatically add the current date when we add this price to the table. The
    `last_update` field is defined with another argument, the `auto_now` equals `True`;
    this tells Django to set the current date every time an update occurs.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Then, we have a field for the price called `price_per_unit`, which is defined
    as a `DecimalField` with a maximum of `9` digits and `2` decimal places. This
    field is not required, and it will always `default` to `0`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a `OneToOneField` to create a link between the `PriceList` and
    the `Game` object. We define that when a game is deleted, the related row in the
    `PriceList` table will also be removed, and we define this field as the primary
    key.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we override the `__str__` method so that it returns the game's name.
    This will be helpful when updating prices using the Django admin UI.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can make the migration files again:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Apply the changes with the following command:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Perfect! Now we are ready to start adding the views and the templates to display
    our games on the page.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Creating the game list and details page
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After creating the model for the games and the prices, we have reached the fun
    part of this section, which is to create the views and templates that will display
    the games on the page. Let's get started!
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we have created a template called `index.html` in `main/templates/main`,
    but we are not displaying anything on it. To make that page more interesting,
    we are going to add two things:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: A section on the top of the page that will display the games that we want to
    highlight. It could be a new game that arrived at the store, a very popular game,
    or some game that has a good price for the moment.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Following the section with the highlighted games, we are going to list all the
    other games.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first template that we are going to add is a partial view that will be
    used to list games. This partial view will be shared to all the templates that
    we want to display a list of games. This partial view will receive two arguments:
    `gameslist` and `highlight_games`. Let''s go ahead and add a file called `games-list.html`
    at `gamestore/main/templates/main/` with the following contents:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: One thing to note here is that we added at the top of the page `{% load humanize
    %}`; this is a set of template filters that are built into the Django framework,
    which we are going to use to format the game price properly. To make use of these
    filters we need to edit the `settings.py` file in the `gamestore/gamestore` directory
    and add `django.contrib.humanize` to the `INSTALLED_APPS` setting.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'This code will create a container with some boxes containing the game image,
    details, and an add-to-cart button, similar to the following:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a90a8c0b-9daf-4a99-adb3-1a56365aec9d.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
- en: 'Now we want to modify the `index.html` at `gamestore/main/templates/main`.
    We can replace the whole content of the `index.html` file with the code, shown
    as follows:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Great! The interesting code is:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'As you can see, we are including the partial view and passing two parameters:
    `gameslist` and `highlight_games`. The `gameslist` is obviously a list of games
    that we want the partial view to render, while `highlight_games` will be used
    when we want to show the promoted games with a different color so they can be
    easily identified. In the index page, the `highlight_games` parameter is not used,
    but when we create a view to list all the games regardless of the fact that it
    is promoted or not, it may be interesting to change the color of the promoted
    ones.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: Below the promoted games section, we have a section with a list of games that
    are not promoted, which also makes use of the partial view `games-list.html`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'The last touch on the frontend side is to include the related CSS code, so
    let''s edit the file `site.css` at `gamestore/static/styles/` and add the following
    code:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now we need to modify the `index` view, so edit the `views.py` file at `gamestore/main/`
    and perform these changes in the `index` function:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Here, we first define how many items of each category of games we want to show;
    for promoted games, it will be three games, and the non-promoted category will
    show a maximum of nine games.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: Then, we fetch the promoted and non-promoted games, and we create two variables, `show_more_link_promoted`
    and `show_more_link_games`, which will be set to `True` in case there are more
    games in the database than the maximum number we defined previously.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: We create a context variable that will contain all the data that we want to
    render in the template, and, lastly, we call the `render` function and pass the
    `request` to the template we want to render, along with the context.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we make use of the `Game` model, we have to import it:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now we are ready to see the results on the page, but, first, we need to create
    some games. To do that, we first need to register the models in the admin. To
    do that, edit the `admin.py` file and include the following code:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Registering the models within the Django admin site will allow us to add, edit,
    and remove games, games platforms, and items in the price list. Because we will
    be adding images to our games, we need to configure the location where Django
    should save the images that we upload through the administration site. So, let''s
    go ahead and open the file `settings.py` in the `gamestore/gamestore` directory,
    and just below the `STATIC_DIRS` setting, add this line:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now, start the site:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Browse to `http://localhost:8000/admin`, and log in as the superuser account
    that we created. You should see the models listed on the page:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/67a5e1f4-ea27-49db-baa6-d720c8b35235.png)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
- en: 'If you click first in `Game` platforms, you will see an empty list. Click on
    the button ADD on the Game platforms row on the top right-hand side of the page,
    and the following form will be displayed:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dd1567e5-3c9c-4428-b68d-5fb26bd0bef2.png)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
- en: Just type any name you like, and click on the SAVE button to save your changes.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Before we add the games, we need to find a default image and place it at `gamestore/static/images/`.
    The image should be named `placeholder.png`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: The layout that we build will work better with images that are of the size 130x180\.
    To make it simpler, when I am creating prototypes, and I don't want to spend too
    much time looking for the perfect image, I go to the site [https://placeholder.com/](https://placeholder.com/).
    Here, you can build a placeholder image of any size you want. To get the correct
    size for our application you can go directly to [http://via.placeholder.com/130x180](http://via.placeholder.com/130x180).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: When you have the default image in place, you can start adding games the same
    way you added the game platforms and just repeat the process multiple times to
    add a few games that are set as promoted as well.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding the games, and going to the site again, you should see the list
    of games on the index page, as follows:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8e40b7bf-7333-4410-926c-c4b2bc5af4a3.png)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
- en: On my project, I added four promoted games. Notice that because we only show
    three promoted games on the first page, we render the link See more items.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Adding list games views
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we are not displaying all the items on the first page, we need to build pages
    that will display all the items if the user clicks on See more items link. This
    should be fairly simple, as we already have a partial view that lists the games
    for us.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create two more URLs in the `url.py` file of the `main` app, and let''s
    add these two to the `urlpatterns` list:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Perfect! Now we need to add one template to list all the games. Create a file
    called `all_games.html` at `gamestore/main/templates/main` with the following
    contents:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Add another file in the same folder called `highlighted.html`:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: There is nothing here that we haven't seen before. This template will receive
    a list of games, and it will pass it down to the `games-list.html` partial view
    that will do all the work of rendering the games for us. There is an `if` statement
    here that checks if there are games on the list. If the list is empty, it will
    display a message that there are no games available at the moment. Otherwise,
    it will render the content.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing now is to add the views. Open the `views.py` file at `gamestore/main/`,
    and add the following two functions:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: These functions are very similar; one gets a list of all games and the other
    one gets a list of only promoted games
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open the application again. As we have more promoted items in the database,
    let''s click on the link See more items in the Highlighted games section of the
    page. You should land on the following page:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/28d8b456-325c-42cc-86eb-94cfb4fb8e20.png)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
- en: Perfect! It worked just as expected.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we are going to add functionality to the buttons so we can add those
    items to the cart.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Creating the shopping cart model
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It seems like now we have an application up and running, we can display our
    games, but there's a big issue here. Can you guess what? Okay, this question wasn't
    so hard, I gave the answer for that in the title of the section. Anyway, our users
    cannot buy the games—we need to implement a shopping cart so we can start making
    our users happy!
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Now, there are many ways you can implement a shopping cart on an application,
    but we are going to do it by simply saving the cart items on the database instead
    of doing an implementation based in the user session.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: 'The requirements for the shopping cart are as follows:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: The users can add as many items they wish
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The users should be able to change the items in the shopping cart; for example,
    they should be able to change the quantity of an item
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removal of items should be possible
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There should be an option to empty the shopping cart
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the data should be validated
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the user owning that shopping cart is removed, the shopping cart and its
    items should also be removed
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With that said, open the file `models.py` in the `gamestore/main` directory,
    and let''s add our first class:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The same way we created a custom `Manager` for the `Game` object, we are also
    going to create a `Manager` for the `ShoppingCart`. We are going to add three
    methods. The first one is `get_by_id`, which, as the name says, retrieves a shopping
    cart, given an ID. The second method is `get_by_user`, which receives as a parameter
    an instance of `django.contrib.auth.models.User`, and it will return the cart
    given a user instance. The last method is `create_cart`; this method will be called
    when the user creates an account
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the manager with the methods that we need, let''s add the
    `ShoppingCart` class:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: This class is super simple. As always, we inherit from `Model`, and we define
    one foreign key for the type `User`. This foreign key is required, and if the
    user is deleted it will also delete the shopping cart.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: After the foreign key, we assign our custom `Manager` to the object's property,
    and we also implement the special method `__str__` so the shopping carts are displayed
    in a nicer way in the Django admin UI.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s add a manager class for the `ShoppingCartItem` model, as follows:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Here, we only define one method, called `get_items`, which receives a cart
    object and returns a list of items for the underlying shopping cart. After the
    `Manager` class, we can create the model:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'We start by defining two properties: quantity, which is an integer value, and
    the price per item, which is defined as a decimal value. We have `price_per_item`
    in this model as well, because when a user adds an item to the shopping cart and
    if the administrator changes the price for a product, we don''t want that change
    in the price to be reflected on the items already added to the cart. The price
    should be the same price as when the user first added the product to the cart.'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: In case the user removes the item entirely and re-adds them, the new price should
    be reflected. After those two properties, we define two foreign keys, one for
    the type `ShoppingCart` and another one for `Game`.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we set the `ShoppingCartItemManager` to the object's property.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to import the User model:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Before we try to verify that everything is working, we should create and apply
    the migrations. On the terminal, run the following command:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'As we did before, we need to run the migrate command to apply the migrations
    to the database:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Creating the shopping cart form
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now have the models in place. Let''s add a new form that will display the
    cart data on a page for editing. Open the `forms.py` file at `gamestore/main/`,
    and at the end of the file add the following code:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Here, we create an inline `formset` using the function `inlineformset_factory`.
    Inline `formset`s are suitable when we want to work with related objects via a
    foreign key. This is very convenient in the case we have here; we have a model
    `ShoppingCart` that relates to the `ShoppingCartItem`.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: So, we pass a few arguments to the `inlineformset_factory` function. First is
    the parent model (`ShoppingCart`), then it's the model (`ShoppingCartItems`).
    Because in the shopping cart we just want to edit the quantities and also remove
    items from the cart, we add a tuple containing the fields from the `ShoppingCartItem`
    that we want to render on the page—in this case, the `quantity` and `price_per_unit`.
    The next argument, `extra`, specifies whether the form should render any empty
    extra rows on the form; in our case, we don't need that, as we don't want to add
    extra items in the shopping cart to the shopping cart view.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: In the last argument, `widgets`, we can specify how the fields should be rendered
    in the form. The quantity field will be rendered as a text input, and we don't
    want `price_per_unit` to be visible, so we define it as a hidden input so it is
    sent back to the server when we submit the form to the server.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, in the same file, let''s add some necessary imports:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Open the `views.py` file, and let''s add a class-based view. First, we need
    to add some import statements:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Then, we can create the class, as follows:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: This is slightly different than the view that we created so far, as this is
    a class-based view that inherits from an `UpdateView`. In reality, views in Django
    are callable objects, and when using classes instead of functions, we can take
    advantage of inheritance and mixins. In our case, we use `UpdateView` because
    it is a view to display forms that will edit an existing object.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: This class view starts off by defining a few properties, such as the model,
    which is the model that we are going to be editing in the form. The `form_class`
    is the form that is going to be used for editing the data. Lastly, we have the
    template that will be used to render the form.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: We override the `get_context_data` because we include some extra data in the
    form context. So, first, we call the `get_context_data` on the base class so as
    to build the context, then we get the list of items of the current cart so we
    can determine whether the cart is empty. We set this value to the context item
    called `is_cart_empty`, which can be accessed from the template.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: After that, we want to calculate the total value of the items that are currently
    in the cart. To do that, we need to first calculate the total price for each item
    by doing (price * quantity), and then sum the results. In Django, it is possible
    to aggregate the values of a `QuerySet`; we have already the `QuerySet` that contains
    the list of items in a cart, so all we have to do is to use the `aggregate` function.
    In our case, we are passing two arguments to the `aggregate` function. First,
    we get the sum of the field `price_per_unit` multiplied by the quantity, and the
    results will be stored in a property called `total_order`. The second argument
    of the `aggregate` function defines the output data type, which we want to be
    a decimal value.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: When we get the results of the aggregation, we create a new item in the context
    dictionary called `total_order` and assign the results to it. Finally, we return
    the context.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: We also override the `get_object` method. In this method, we try to get the
    shopping cart for the requesting user. If the shopping cart does not exist, an
    exception `ShoppingCart.DoesNotExist` will be raised. In that case, we create
    a shopping cart for the user and return it.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we also implement the `form_valid` method, which only saves the form
    and redirects the user back to the cart page.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: Creating the shopping cart view
  id: totrans-435
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it is time to create the shopping cart views. This view will render the
    form that we just created, and the users should be able to change the quantities
    for every item on the cart, as well as remove items. If the shopping cart is empty,
    we should show a message saying that the cart is empty.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the view, let''s go ahead and open the `urls.py` file in `gamestore/main/`
    and add the following URL:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Here, we define a new URL, `'cart/'`, and, when accessed, it will execute the
    class-based view `ShoppingCartEditView`. We also define a name for the URL for
    simplicity.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to create a new file called `cart.html` at `gamestore/main/templates/main`,
    with the contents as follows:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The template is quite simple; we just loop through the forms and render each
    one of them. One thing to note here in that we are loading `humanize` in the beginning
    of the template.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '`humanize` is a set of template filters that we can use to format data in the
    template.'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: We use the `intcomma` filter from `humanize` to format the sum of all items
    in the shopping cart. The `intcomma` filter will convert an integer or float value
    to a string and add a comma every three digits.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: You can try it out on the new view. However, the cart will be empty and no data
    will be displayed. Next, we are going to add functionality to include items in
    the cart.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: Adding items to the cart
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are getting close to finishing up the shopping cart. Now we are going to
    implement a view that will include items in the cart.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is create a new URL. Open the file `url.py` in
    the directory `gamestore/main/`, and add this URL to the `urlpatterns` list:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Perfect. In this URL, we can pass the game ID, and it will execute a view called
    `add_to_cart`. Let''s add this new view. Open the file `views.py` in `gamestore/main`.
    First, we add import statements, shown as follows:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Now, we need a way to know if a specific item has been already added to the
    cart, so we go over to the `models.py` in `gametore/main` and add a new method
    to the `ShoppingCartItemManager` class:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '`get_existing_item` searches for a `ShoppingCartItem` object using as criteria
    the `cart id` and the `game id`. If the item is not found in the cart, it returns
    `None`; otherwise, it will return the cart item.'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we add the view to the `views.py` file:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: This function gets a request and the game ID, and we start by getting the game
    and the current user's shopping cart. We then pass the cart and the game to the
    `get_existing` function that we just created. If we don't have that specific item
    in the shopping cart, we create a new `ShoppingCartItem`; otherwise, we just update
    the quantity and save.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: We also add a message to inform the user that the item has been added to the
    shopping cart.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we redirect the user to the shopping cart page.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: 'As a final touch, let''s open the `site.css` file in the `gamestore/static/styles`
    and add the styling to our shopping cart''s view:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Before we try this out, we need to add the link to the cart view on the top
    menu. Open the file `base.html` in `gamestore/templates`, locate where we do the
    include of the `_loginpartial.html` file, and include the following code right
    before it:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Now we should be ready to test it out. Go to the first page, and try adding
    some games to the cart. You should be redirected to the cart page:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/88194946-e679-46f9-a81a-b3b782e05424.png)'
  id: totrans-465
  prefs: []
  type: TYPE_IMG
- en: Summary
  id: totrans-466
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It has been a long journey, and we have covered a lot of ground in this chapter.
    In this chapter, you have seen how easy it is to build an application with Django.
    The framework really honors the phrase *Framework for perfectionists with deadlines*.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: You have learned how to create a new Django project and applications, with a
    short walkthrough of the boilerplate code that Django generates for us when we
    start a new project. We learned how to create models and use migrations to apply
    changes to the database.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: Django forms was also a subject that we covered a lot in this chapter, and you
    should be able to create complex forms for your projects.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: As a bonus, we learned how to install and use **NodeJS Version Manager** (**NVM**)
    to install Node.js, so as to install project dependencies using the npm.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](332eca24-e97d-470d-a00f-882dbf2092aa.xhtml), *Building a Web
    Messenger with Microservices*, we are going to extend this application and create
    services that will handle the store inventory.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
