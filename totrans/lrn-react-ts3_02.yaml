- en: What is New in TypeScript 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In its six years of existence, TypeScript has continued to move forward and
    mature nicely. Is TypeScript 3 a significant release for React developers? What
    exactly are the new features that we have to add to our toolkit in TypeScript
    3? These questions will be answered in this chapter, starting with the `tuple`
    type and how it can now be successfully used with the **rest** and **spread**
    JavaScript syntax, which is very popular in the React community. We'll then move
    on to the new `unknown` type and how it can be used as an alternative to the `any`
    type. Further more, we'll break TypeScript projects up into smaller projects with
    the new project references in TypeScript. Finally, we'll go about defining default
    properties in a strongly-typed React component that has improved in TypeScript
    3.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of the chapter, we''ll be ready to start learning how you can use
    TypeScript 3 to build frontends with React. In this chapter, we''ll cover the
    following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The unknown type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default JSX properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will use the same technologies as in [Chapter 1](372b9509-9775-47b7-88eb-dc68c8a6271f.xhtml),
    *TypeScript Basics*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**TypeScript playground**: This is a website at [https://www.typescriptlang.org/play/](https://www.typescriptlang.org/play/),
    which allows us to play around with and understand the features in TypeScript
    without installing it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node.js and** `npm`: TypeScript and React are dependent on these. You can
    install them from [https://nodejs.org/en/download/](https://nodejs.org/en/download/).
    If you already have these installed, make sure `npm` is at least version 5.2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TypeScript**: This can be installed via `npm`, entering the following command
    in a terminal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important that we are using TypeScript 3 in this chapter. You can check
    your TypeScript version by using the following command in a terminal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to upgrade to the latest version, you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Visual Studio Code**: We''ll need an editor to write our React and TypeScript
    code. This one can be installed from [https://code.visualstudio.com/](https://code.visualstudio.com/).
    We will also need the TSLint (by egamma) and Prettier (by Estben Petersen) extensions
    installed in Visual Studio Code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the code snippets in this chapter can be found at [https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/02-WhatsNewInTS3](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/02-WhatsNewInTS3).
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tuples have had a few enhancements in TypeScript 3, so that they can be used
    with the popular `rest` and `spread` JavaScript syntax. Before we get into the
    specific enhancements, we'll go through what tuples are, along with what the `rest`
    and `spread` syntax is. A tuple is like an array but the number of elements are
    fixed. It's a simple way to structure data and use some type safety.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a play with tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the TypeScript playground, let''s enter the following example of a tuple
    variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We've initialized a `product` variable to a tuple type with two elements. The
    first element is a string and the second a number.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can store a product name and its unit price in the `product` variable on
    the next line, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try to store the product name and unit price the other way around:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Not surprisingly, we get a compilation error. If we hover over `500`, the compiler
    quite rightly complains that it was expecting a string. If we hover over `"Table"`,
    the compiler complains that it expects a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c39e7280-3add-4c88-99aa-2b32c1f5ce50.png)'
  prefs: []
  type: TYPE_IMG
- en: So, we do get type safety, but tuples tell us nothing about what should be in
    the elements. So, they are nice for small structures or structures where the elements
    are obvious.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following examples are arguably fairly readable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the following example is not so readable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: What exactly do those last two numbers represent?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can access items in a tuple in the same way as an array, by using the element''s
    index. So, let''s access the product name and unit price in our `product` variable
    in the TypeScript playground:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If we run the program, we'll get "Table" and 500 output to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can iterate through elements in a tuple like we can an array, using a `for` loop
    or the array `forEach` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Running the program, will output `Table `and `500` to the console twice. Notice
    that we don't need to add a type annotation to the `element` variable because
    the TypeScript compiler cleverly infers this.
  prefs: []
  type: TYPE_NORMAL
- en: So, that's the tuple type, but's what's new in TypeScript 3? The enhancements
    have been largely driven by the popularity of JavaScript's `rest` and `spread`
    syntax, so let's briefly cover this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript rest and spread syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In JavaScript, a `rest` parameter collects multiple arguments and condenses
    them into a single argument. It is called `rest` because it collects the `rest`
    of the arguments into a single argument.
  prefs: []
  type: TYPE_NORMAL
- en: A `rest` parameter has nothing to do with **Representational state transfer
    protocol** (**REST**).
  prefs: []
  type: TYPE_NORMAL
- en: This syntax was introduced in ES6 and allows us to nicely implement functions
    that have an indefinite number of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: We define a `rest` parameter with three dots preceding the parameter name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through a quick example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `logScores` function that takes in a `scores rest` parameter
    that just outputs the parameter to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is pure JavaScript - we'll introduce types to `rest` parameters when we
    look at the new features in TypeScript 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can call `logScores` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If we run this, we'll get an array of the three elements we passed in as parameters
    output to the console. So, our `scores` parameter has collected all the arguments
    into an array.
  prefs: []
  type: TYPE_NORMAL
- en: The `spread` syntax is the opposite of `rest` parameters. It allows an iterable,
    such as `array`, to be expanded into function arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s redefine our `logScore` function with specific parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note that this is still pure JavaScript – no types just yet!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define a `scores` array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s use the `spread` syntax to pass our `scores` variable into
    our `logScore` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If you are using the TypeScript playground, you'll get the compilation error, `expected
    3 arguments, but got 0 or more`. The program still runs though, because this is
    perfectly valid JavaScript. `75, 65, 80` will be output to the console if we do
    run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we'll see how the new features in TypeScript 3 help
    us help the compiler to better understand what we are trying to do when using
    `rest` and `spread`. This will allow us to resolve the compilation errors seen
    in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: Open-ended tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before TypeScript 3, tuples had to have a fixed amount of elements. TypeScript
    3 gives us a little more flexibility with `rest` elements. `rest` elements are
    similar to `rest` parameters, described in the last section, but they work with
    tuple element types. A `rest` element allows us to define an open-ended tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time to go through an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the TypeScript playground, let''s create a tuple with the first element
    being a string and subsequent elements being numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We should be able to use this structure to store someone''s name with an infinite
    amount of scores. Let''s give this a go for `Billy` and three scores:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s move on to try `Sally` and four scores:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Both these variables compile fine, as we would expect, because we have defined
    the numbers as open-ended.
  prefs: []
  type: TYPE_NORMAL
- en: Tuple function parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tuple `function` parameters in TypeScript 3 allow us to create strongly-typed
    `rest` parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we first looked at `rest` parameters, we created a pure JavaScript version
    of `logScores` that collected an unlimited amount of arguments in a `scores` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In TypeScript 3, we can now make this example strongly-typed with a tuple `rest`
    parameter. Let''s give this a try in the TypeScript playground:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s call our function with some scores:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We don't get a compiler error, and if we run the program, we get an array containing
    `50, 85, 75` output in the console.
  prefs: []
  type: TYPE_NORMAL
- en: We can create an enhanced version of our function that uses the `Scores` type
    from the *Open-ended tuples* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `function` will take in the name, as well as an unlimited set of scores:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try to call our function with some scores from `Sally`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If we run the program, `Sally `and her array of scores will be output to the
    console.
  prefs: []
  type: TYPE_NORMAL
- en: Spread expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript 3 allows us to use tuples with spread expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to the problematic pure JavaScript example we looked at for
    using the `spread` syntax:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The TypeScript compiler raised the error `Expected 3 arguments, but got 0 or
    more`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s resolve this now with enhanced tuples in TypeScript 3. We''ll start
    by adding types to the `function` parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: There's nothing new yet, and we're still getting the compilation error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change the `scores` variable into a fixed tuple:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: That's it – the compilation error has gone! All we needed to do was tell the
    compiler how many items were in `scores` for it to successfully spread into the **`logScore` **function.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in TypeScript 3, we can spread into fixed tuples. What about open-ended
    tuples? Let''s give that a try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, the compiler is not yet quite clever enough to let us do this.
    We get the compilation error Expected 3 arguments, but got 0 or more.:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5c4e907c-3880-4b97-b6d6-32438cc19391.png)'
  prefs: []
  type: TYPE_IMG
- en: Empty tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In TypeScript 3, we can now define an empty tuple type. Let''s have a little
    play with this in the TypeScript playground:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the following type alias for an empty tuple:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s declare a variable of this type and assign it to an empty array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try to declare a variable of this type and assign it to a non-empty
    array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, we get a compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f68dd6b5-dfa3-4b38-a87b-1623220e2e27.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Why is an empty tuple type useful, though? On its own, it perhaps is not that
    useful, but it can be used as part of a union type, which we''ll cover in detail
    later in the book. As a quick example for now, we can create a type for no more
    than three scores, where no scores is also acceptable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: All the scores are valid except Sarah's, because four scores aren't allowed
    in the `Scores` type.
  prefs: []
  type: TYPE_NORMAL
- en: Optional tuple elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final tuple enhancement in TypeScript 3 is the ability to have optional
    elements. Optional elements are specified using a `?` at the end of the element
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at another example using our scores theme:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a type for between one and three scores:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we should be able to create variables to hold between one and three scores:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As expected, this compiles just fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'What about four elements? Let''s give this a go:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We get a compilation error, as we would expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/587ab6a8-0ad2-4330-8dc5-8ece784f3482.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we try no elements, we again get a compilation error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'When defining optional elements in a tuple, they are restricted to the end
    of the tuple. Let''s try to define a required element after an optional element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We get a compilation error, as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/744f0d4a-3779-441d-bc7f-debd800ec400.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Optional elements also work in a function `rest` parameter. Let''s try this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use our `scores` type in our `logScores` function we worked with in
    earlier sections:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to pass in two scores, the code will compile just fine, because the
    last parameter is optional:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, if we pass in four scores, we receive `Expected 1-3 arguments,
    but got 4`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'When we have optional parameters, it is likely our function''s implementation
    will need to know which arguments have been passed. We can use the tuple''s `length` property
    to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an enhanced version of our scores logger, called `logScoresEnhanced`,
    which thanks us if we log all `3` scores:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s call this function with various parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: If we run the program, we only get thanked after the first call when we pass
    all three scores.
  prefs: []
  type: TYPE_NORMAL
- en: All the enhancements to tuples in TypeScript 3 allow us to use the `rest` and
    `spread` syntax in a strongly-typed fashion. We'll make use of this feature later
    in the book, when we work with React components.
  prefs: []
  type: TYPE_NORMAL
- en: The unknown type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`unknown` is a new type that has been added in TypeScript 3\. Before TypeScript
    3, we may have used the `any` type when we weren''t sure of all the properties
    and methods in an object from a third-party library. However, when we declare
    a variable with the `any` type, the TypeScript compiler won''t do any type checking
    on it. The `unknown` type can be used in these situations to make our code more
    type-safe. This is because `unknown` types are type-checked. So, `unknown` can
    often be used as an alternative to `any`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the TypeScript playground, let''s go through an example of a function using
    `any` and an improved version using `unknown`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a `logScores` function that takes in a parameter of type `any`.
    It logs out the `name` and `scores` properties from the argument to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s call this function with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: If we run the program, we get `undefined` followed by `[60, 70, 75]` in the
    console. We passed in a correct object parameter, but our function logs `firstName`
    instead of `name` to the console. The program compiled just fine and didn't produce
    an error at runtime, but didn't give the result we wanted. This is all because
    we told the compiler not to check any types with the `any` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start to create a better version of this function with the `unknown`
    type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We immediately get compiler warnings where we reference the properties in `scores`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bd79710f-d16d-4c47-bece-5380676517ca.png)'
  prefs: []
  type: TYPE_IMG
- en: So, the compiler is checking our `scores` variable now, which is great, and
    is even warning us about the `firstName` property. However, the `scores` property
    is also giving a complication error but is valid. So, how do we tell the compiler this? We
    need to explicitly do some type checking ourselves in our code. We'll cover a
    couple of ways of doing this in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Type checking with a type predicate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One way we can perform type checking in a function is with another function
    that has a return type as a type predicate. Let''s explore this and eventually
    create a new version of our `logScores` function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll define a new function called `scoresCheck` to do the necessary
    type checking:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This takes in a `scores` parameter that has a type predicate,`scores is { name:
    string; scores: number[] }`, ensuring it contains the correctly typed `name` and
    `scores` properties. The function simply returns whether the `scores` parameter contains
    the `name` and `scores` properties.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use this function in our `logScores` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We immediately get the compilation error we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/321c0859-294f-4e12-b3ef-a1475a9e95fb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The type predicate, `scores is { name: string, scores: number[] }`, allows
    the TypeScript compiler to narrow down the type in the `if` block that logs the
    properties to the console. This results in `scores.scores` compiling fine, but
    `scores.firstName` is giving an error, which is just what we want.'
  prefs: []
  type: TYPE_NORMAL
- en: The type predicate is the key bit. Without it, the TypeScript compiler will
    still throw errors on the valid `scores.scores` reference. Try removing the type
    predicate and see for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we can make the predicate a little more readable with a type alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Using a type predicate in this way is called a type guard. There are other ways
    of implementing type guards, which we'll cover later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Type narrowing with a type assertion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The other way of performing type checking we are going to look at when using `unknown` is
    to use type assertion. Type assertion lets us tell the compiler what the type
    is with the `as` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create yet another version of our `logScores` function as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a type alias for the structure we want the function parameter
    to be:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `logScores` function, we can now use the `as` keyword to tell the compiler
    what type to expect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s enough information for the compiler to pinpoint the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/053bc758-8be0-4a1c-95be-b16a14e59b76.png)'
  prefs: []
  type: TYPE_IMG
- en: The `unknown` type allows us to reduce our use of the `any` type and create
    more strongly-typed and robust TypeScript programs. We do have to write more code,
    though, when referencing `unknown` types. The additional code we need to write
    needs to check the type of the `unknown` variable so that the TypeScript compiler
    can be sure we are accessing valid members within it.
  prefs: []
  type: TYPE_NORMAL
- en: Project references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript 3 allows TypeScript projects to depend on other TypeScript projects
    by allowing `tsconfig.json` to reference other `tsconfig.json` files.
  prefs: []
  type: TYPE_NORMAL
- en: This makes it easier to split our code up into smaller projects. Our frontend
    code might be in TypeScript, in addition to having our backend in TypeScript.
    With TypeScript 3, we can have a frontend TypeScript project, a backend TypeScript
    project, and a shared TypeScript project that contains code that is used in both
    the frontend and backend. Splitting our code up into smaller projects can also
    can give us faster builds, because they can work incrementally.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to explore this, we are going to work through an example of a TypeScript
    project referencing another project in Visual Studio Code:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, let's create a new folder called `Shared`. This is going to be the
    project for shared code that could potentially be used in many other projects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our `Shared` folder, let''s create the following `tsconfig.json` as a starting
    point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create an `src` folder containing a TypeScript file called `utils.ts`
    with the following function, `randomString`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This is a function that creates a random string of characters, as the name suggests.
    We are going to use this function in another project.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start to create our second project now, so go back up to the root of our
    solution, and create a folder called `ProjectA`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside `ProjectA`, let''s create the following `tsconfig.json` as a starting
    point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also create a folder called `src` in `ProjectA`, containing a TypeScript
    file called `person.ts`, with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The code defines a simple class of information about a person. The unique identifier
    of the person is set to a random string in the constructor using the `randomString`
    function from our `Shared` project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open up the terminal, go to our `Shared` folder, and compile our `Shared`
    project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The `Shared` project compiles just fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to compile `ProjectA` now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We get a compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: So, we created two dependent projects, but they don't properly understand each
    other yet, which is why we are getting the error. We'll resolve this in the following
    sections, using TypeScript 3's new features for multiple projects.
  prefs: []
  type: TYPE_NORMAL
- en: Referencing projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step in setting up TypeScript 3's multiple projects feature is to
    reference projects using a new field called `references` in `tsconfig.json`. This
    field is an array of objects that specify projects to reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our working example, let''s make `ProjectA` start to understand the `Shared`
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change the `tsconfig.json` in `ProjectA` to reference the `Shared` project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: If we want the dependent project's generated JavaScript code to be included
    in the same file as the current project, we can set `prepend` to `true` on the
    dependency.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We're not going to use `prepend` in our example though.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we compile `ProjectA` again, a different error is raised:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The error gives a great clue as to what is wrong. We'll resolve this problem
    with the missing `composite` setting in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Additions to compiler options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just referencing another project isn't enough for the TypeScript compiler to
    properly handle multiple projects. We need to add some additional compiler options
    in the dependent project.
  prefs: []
  type: TYPE_NORMAL
- en: The `compilerOptions` field has a new field called `composite`, which must be
    set to `true` if we are using multiple projects. This ensures certain options
    are enabled so that this project can be referenced and built incrementally for
    any project that depends on it.
  prefs: []
  type: TYPE_NORMAL
- en: When `composite` is `true`, `declaration` must also be set to `true`, forcing
    the corresponding `.d.ts` file to be generated, containing the project's types.
    This allows TypeScript to only build dependent projects when types are changed
    and not rebuild all the dependent projects all the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make the following changes to our working example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open up `tsconfig.json` in the `Shared` project and make the following
    changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'In the terminal, let''s go to the `Shared` project directory and compile our
    `Shared` project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The project compiles okay. Let''s now try to compile `ProjectA` again in the
    terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This time, `ProjectA` compiles just fine.
  prefs: []
  type: TYPE_NORMAL
- en: So, we have successfully tied together two projects using TypeScript 3's multiple
    projects feature. In the next section, we'll improve the setup of our projects
    even more.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-project Go to Definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order for the Go to Definition feature in Visual Studio Code to work across
    projects, we need to set the `declarationMap` setting in `tsconfig.json`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue with our multiple project example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open `person.ts` in `ProjectA`, right-click on the `randomString` reference,
    and select Go to Definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/edb5b391-b705-4e09-818f-de7f14996be7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We are taken to the declaration file rather than the source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c0818d4d-a9b2-47ae-887b-100a74071afa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can resolve that by setting `declarationMap` in `tsconfig.json` in the `Shared`
    project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: If we compile the `Shared` project and try the Go to Definition feature again,
    we are taken to the source file, as we would want.
  prefs: []
  type: TYPE_NORMAL
- en: So, by setting `declarationMap` to `true` in the dependent project, along with
    `composite` and `declaration`, we get great support for multiple TypeScript projects.
  prefs: []
  type: TYPE_NORMAL
- en: Build mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The TypeScript 3 compiler includes the ability to perform smart incremental
    builds using the `--build` flag. Let''s give this a try in our example multiple
    project solution:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s go to the root of the solution, open the terminal, and enter
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The `--verbose` flag tells the compiler to tell us the details of what it''s
    doing. The messages confirm to us that it has picked up the `Shared` project as
    well as `ProjectA`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler then checks each project to see if it''s up to date. If the project
    is up to date, we get something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Let's make a change in the `utils.ts` file in the `Shared` project by adding
    a space somewhere, removing it, and then saving the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s build `ProjectA` again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, we get a message to indicate that the `Shared` project is out
    of date and will be rebuilt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to force a rebuild, even if projects are up to date, we can use
    the `--force` flag. Let''s give this a try:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: When we do this, the compiler will still check whether projects are up to date
    (and tell us), but then it goes on to build each project.
  prefs: []
  type: TYPE_NORMAL
- en: So, in addition to great multiple-project support, we can speed up solution
    builds using the `--build` flag. As the solution grows over time, this becomes
    increasingly valuable. If ever we want to force a rebuild of a project, we can
    use the `--force` flag along with `--build`.
  prefs: []
  type: TYPE_NORMAL
- en: Default JSX properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript 3 has also improved how we can set default properties on React components
    with `--strictNullChecks`. Before TypeScript 3, we had to set properties that
    had default values as optional and perform `null` checks when referencing them.
    We haven't introduced React yet in this book, so we'll only touch on this briefly
    at this point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look through an example to get a feel for the improvement:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a React component with some default properties in TypeScript
    2.9\. The component is called `SplitText` and it takes in some text, splits it,
    and renders the bits that have been split in a list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The component has a `delimiter` property that defaults to `","`. In TypeScript
    2.9, we need to make `delimiter` an optional property, otherwise we get a compiler
    error if we don't specify it in the calling component (even though there is a
    `default`).
  prefs: []
  type: TYPE_NORMAL
- en: Also notice that we need to put a `!` after we reference `delimiter` in the `bits` variable
    declaration. This is to tell the compiler that this will never be undefined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the component that calls `SplitText`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what it looks like when rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b76dc251-9f55-401f-bbf1-cf92f46f939e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s look at the component in TypeScript 3:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we didn't need to make the `delimiter` property optional. Also notice
    that we didn't need to tell the compiler that `this.props.delimiter` can't be
    undefined.
  prefs: []
  type: TYPE_NORMAL
- en: So, in summary, we don't have to fiddle around to make default properties work
    nicely in TypeScript 3!
  prefs: []
  type: TYPE_NORMAL
- en: This is our first taste of React. Don't worry if the code examples don't make
    much sense at this point. We'll start to learn about React components in [Chapter
    3](6938e951-47cf-4751-9cfc-c5afcdd73c9e.xhtml), *Getting Started with React and
    TypeScript*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the `rest` and `spread` syntax is very common nowadays, particularly when
    building React apps. We've seen how TypeScript 3, with the enhancement of tuples,
    allows us to use `rest` and `spread` in a strongly-typed fashion.
  prefs: []
  type: TYPE_NORMAL
- en: We've also seen how we can use the `unknown` type to reduce our use of the `any`
    type. The `unknown` type does require us to write more code, but it also allows
    us to create a more strongly-typed, more maintainable code base.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript has always made working with large code bases easier. With the introduction
    of project references, we can now split our solution into smaller projects more
    easily. This approach makes large solutions even more maintainable and flexible,
    and also yields faster build times with the new `--build` flag.
  prefs: []
  type: TYPE_NORMAL
- en: We briefly went through how using `defaultprops`in a React component has improved.
    We'll be using this frequently as we start to learn how to build strongly-typed
    React components in subsequent chapters.
  prefs: []
  type: TYPE_NORMAL
- en: So, now that we are starting to get comfortable with TypeScript, in the next
    chapter, we'll get started with React. We'll start by learning how to create a
    React and TypeScript project, and then move on to how to create React and TypeScript
    components.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to cement what we have learned about TypeScript 3, have a go at the
    following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the following function, which draws a point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have the following `point` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: How can we call the `drawPoint` function in a terse manner?
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create another version of the `drawPoint` function, where we can
    call it by passing the *x*, *y*, and *z* point values as parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Internally, in the implementation of `drawPoint`, we draw the point from a tuple
    type `[number, number, number]`. How can we define the method parameter(s) with
    the required tuple?
  prefs: []
  type: TYPE_NORMAL
- en: In your implementation of `drawPoint`, how can you make `z` in the point optional?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have a function called `getData`, which calls a web API to get some data. The
    number of different API resources is still growing, so we''ve chosen to use `any` as
    the return type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: How can we make `getData` more type-safe by leveraging the `unknown` type?
  prefs: []
  type: TYPE_NORMAL
- en: What `build` flag can we use to determine which projects are out of date and
    need to be rebuilt without doing a rebuild?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following links are good resources for further information on TypeScript
    3.0:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Microsoft blog post that announced the TypeScript 3.0 release is worth
    a read: [https://blogs.msdn.microsoft.com/typescript/2018/07/30/announcing-typescript-3-0/](https://blogs.msdn.microsoft.com/typescript/2018/07/30/announcing-typescript-3-0/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The TypeScript documentation has got good information on project references,
    which is worth looking at: [https://www.typescriptlang.org/docs/handbook/project-references.html](https://www.typescriptlang.org/docs/handbook/project-references.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
