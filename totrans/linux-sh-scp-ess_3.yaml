- en: Chapter 3. Effective Script Writing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To write an effective script in shell, it is very important to know about the
    different utilities that shell provides. Similar to other programming languages,
    shell programming also requires a way to specify skipping or running certain commands
    under certain conditions. To perform a certain task on the list of elements, looping
    constructs are needed in shell as well.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover topics such as `if`, `else`, `case`, and `select`
    that can be used to run a certain block of commands according to the condition.
    We will see the `for`, `while`, and `until` constructs, which are used to loop
    over a certain block of commands in a script. We will see how the exit code, after
    the execution of a command or script, plays an important role in knowing whether
    a command was executed successfully or not. We will also see how a function can
    be defined in shell, which will allow us to write modular and reusable code from
    now on.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: Exiting from scripts and exit codes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing expressions with a test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using conditional statements with `if` and `else`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indexed arrays and associative arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looping around with `for`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `select`, `while`, and `until` loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Switching to your choice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using functions and positional parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing `stdout` as a parameter using `xargs`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aliases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pushd` and `popd`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exiting from scripts and exit codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now well familiar with shell script files, commands, and running them
    in `bash` to get the desired output. Until now, whatever shell script examples
    we have seen, they run line by line until the end of the file. While writing real-world
    shell scripts, it may not always be the case. We may need to exit a script in
    between, for example, when some error occurs, doesn't satisfy a certain condition,
    and so on. To exit from the script, the `exit` shell builtin is used with an optional
    return value. The return value tells the exit code, which is also known as return
    status or exit status.
  prefs: []
  type: TYPE_NORMAL
- en: Exit codes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every command returns an exit code when it gets executed. Exit code is one of
    the ways to know whether a command is executed successfully or if some error has
    occurred. As per the **POSIX** (**Portable Operating System Interface**) standard
    convention, a command or program with successful execution returns `0`, and `1`
    or a higher value for failed execution.
  prefs: []
  type: TYPE_NORMAL
- en: In bash, to see the exit status of the last command executed, we can use "`$?`".
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows the exit code of the successful command execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to see the exit code of the last executed command, that is, `ls /home`,
    we will run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We see that the exit status of the `ls` command execution is `0`, which means
    it has executed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example showing the exit code of the unsuccessful command execution
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The exit status code is `2`, which is higher than `0`, representing unsuccessful
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: Exit codes with a special meaning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In different situations, a different exit code is returned by a script or command.
    Knowing the meaning of the exit code is useful while debugging a script or command.
    The following table explains which exit code is conventionally returned in different
    conditions of command or script execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Exit code | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | Successful execution |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | General error |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Error when using shell builtin commands |'
  prefs: []
  type: TYPE_TB
- en: '| 126 | Permission issues while executing a command; we can''t invoke the requested
    command |'
  prefs: []
  type: TYPE_TB
- en: '| 127 | Could not invoke requested command |'
  prefs: []
  type: TYPE_TB
- en: '| 128 | Specifying invalid argument to exit in script. Only value from 0 to
    255 is valid exit code |'
  prefs: []
  type: TYPE_TB
- en: '| 128+n | Fatal error with the signal ''n'' |'
  prefs: []
  type: TYPE_TB
- en: '| 130 | Terminating script using Ctl + C |'
  prefs: []
  type: TYPE_TB
- en: '| 255* | Out of the range exit code |'
  prefs: []
  type: TYPE_TB
- en: Exit codes 0, 1, 126-165, and 255 are reserved and we should use other than
    these numbers when we return the exit code in script files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following examples show the different exit codes returned by commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exit code 0**: The following is the successful execution of the `echo` command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Exit code 1**: Copying files from `/root` have no permissions as shown:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Exit code 2**: Use read shell builtin with an invalid parameter as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**Exit code 126**: Run a `/usr/bin` directory as a command that is actually
    not a command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**Exit code 127**: Run a command named `foo` that is not actually present in
    the system:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**Exit code 128+n**: Terminate a script by pressing *Ctrl* + *C*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, *Ctrl* + *C* sends the `SIGQUIT` signal whose value is `2`. So, the exit
    code is `130` (128 + 2).
  prefs: []
  type: TYPE_NORMAL
- en: Script with exit codes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can also exit shell builtin along with an exit code to know whether a script
    ran successfully or it encountered any error. Different error codes can be used
    to know the actual reason of an error while debugging your own script.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we don''t provide any exit code in a script, the exit code of the script
    is determined by the last executed command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding script doesn''t specify any exit code; running this script will
    give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The exit code of this script is `1` because we didn't specify any exit code
    and the last executed command was `cd /root`, which failed due to a permission
    issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking the next example that returns the exit code `0`, irrespective of any
    error that occurs—that is, script ran successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this script will give the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, the script file returns the exit code as `0`. We now know what a difference
    adding an exit code in script can make.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example with the exit status code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output after running this script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If no exit code is specified in a script, the exit code will be the exit status
    of the last command ran in the script.
  prefs: []
  type: TYPE_NORMAL
- en: Testing expressions with a test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The shell builtin command `test` can be used to check file types and compare
    expressions value. The syntax is `test EXPRESSION` or the `test` command is also
    equivalent to **[ EXPRESSION ]**.
  prefs: []
  type: TYPE_NORMAL
- en: It returns the exit code `1` (`false`) if the `EXPRESSION` result is `0`, and
    `0` (`true`) for a non-zero `EXPRESSION` result.
  prefs: []
  type: TYPE_NORMAL
- en: If no `EXPRESSION` is provided, the exit status is set to `1` (false).
  prefs: []
  type: TYPE_NORMAL
- en: File checks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Different kinds of checks can be done on the file using the `test` command;
    for example, file existence test, directory test, regular file check, symbolic
    link check, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The options available to do various checks on a file are explained in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| -e | fileChecks whether the file exists |'
  prefs: []
  type: TYPE_TB
- en: '| -f file | The file is a regular fil |'
  prefs: []
  type: TYPE_TB
- en: '| -d file | The file exists and is a directory |'
  prefs: []
  type: TYPE_TB
- en: '| -h, -L file | The file is a symbolic link |'
  prefs: []
  type: TYPE_TB
- en: '| -b file | The file is block special |'
  prefs: []
  type: TYPE_TB
- en: '| -c file | The file is character special |'
  prefs: []
  type: TYPE_TB
- en: '| -S file | The file is a socket |'
  prefs: []
  type: TYPE_TB
- en: '| -p file | The file is a named pipe |'
  prefs: []
  type: TYPE_TB
- en: '| -k file | Sticky bit of the file is set |'
  prefs: []
  type: TYPE_TB
- en: '| -g file | set-group-ID (sgid) bit of the file is set |'
  prefs: []
  type: TYPE_TB
- en: '| -u file | set-user-id (suid) bit of the file is set |'
  prefs: []
  type: TYPE_TB
- en: '| -r file | Read permission on the file exists |'
  prefs: []
  type: TYPE_TB
- en: '| -w file | Write permission on the file exists |'
  prefs: []
  type: TYPE_TB
- en: '| -x file | Execute permission on the file exists |'
  prefs: []
  type: TYPE_TB
- en: '| -t fd | File descriptor fd is open on terminal |'
  prefs: []
  type: TYPE_TB
- en: '| file1 -ef file2 | file1 is hard link to file2 |'
  prefs: []
  type: TYPE_TB
- en: '| file1 -nt file2 | file1 is more recent compared to file2 |'
  prefs: []
  type: TYPE_TB
- en: '| file1 -ot file2 | The modification time of file1 is older than file2 |'
  prefs: []
  type: TYPE_TB
- en: 'Shell script performs different checks on the files as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of running this script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In our output, `0` and `1` are the `exist` status after running a test command
    on files. The output `1` means the test failed and `0` means the test was successfully
    passed.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic checks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can also perform arithmetic checks between integer numbers. Comparison possible
    on integers is explained to following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Comparison | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `INTEGER1 -eq INTEGER2` | INTEGER1 is equal to INTEGER2 |'
  prefs: []
  type: TYPE_TB
- en: '| `INTEGER1 -ne INTEGER2` | INTEGER1 is not equal to INTEGER2 |'
  prefs: []
  type: TYPE_TB
- en: '| `INTEGER1 -gt INTEGER2` | INTEGER1 is greater than INTEGER2 |'
  prefs: []
  type: TYPE_TB
- en: '| `INTEGER1 -ge INTEGER2` | INTEGER1 is greater than or equal to INTEGER2 |'
  prefs: []
  type: TYPE_TB
- en: '| `INTEGER1 -lt INTEGER2` | INTEGER1 is lesser than INTEGER2 |'
  prefs: []
  type: TYPE_TB
- en: '| `INTEGER1 -le INTEGER2` | INTEGER1 is lesser than or equal to INTEGER2 |'
  prefs: []
  type: TYPE_TB
- en: 'Shell script shows various arithmetic checks between two integers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of running this script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Also, here the test returns the exit status after running a comparison test
    between integers, and returns `0` (true) on success and `1` (false) if the test
    fails.
  prefs: []
  type: TYPE_NORMAL
- en: String checks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A command test also allows you to perform checks on and between strings. The
    possible checks are described in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Comparison | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-z STRING` | The length of the string is zero |'
  prefs: []
  type: TYPE_TB
- en: '| `-n STRING` | The length of the string is non-zero |'
  prefs: []
  type: TYPE_TB
- en: '| `STRING1 = STRING2` | STRING1 and STRING2 are equal |'
  prefs: []
  type: TYPE_TB
- en: '| `SRING1 != STRING2` | STRING1 and STRING2 are not equal |'
  prefs: []
  type: TYPE_TB
- en: 'Shell script shows various string checks on and between strings as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of running this script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, the test returns `0` exit status if the string checks are true, else returns
    `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Expression checks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `test` command also allows you to perform checks on and between expressions.
    An expression itself can contain multiple expressions to evaluate as well. The
    possible checks done are explained in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Comparison | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `( EXPRESSION )` | This EXPRESSION is true |'
  prefs: []
  type: TYPE_TB
- en: '| `! EXPRESSION` | This EXPRESSION is false |'
  prefs: []
  type: TYPE_TB
- en: '| `EXPRESSION1 -a EXPRESSION2` | Both the expressions are true (the AND operation)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `EXPRESSION1 -o EXPRESSION2` | Either one of the expressions is true (the
    OR operation) |'
  prefs: []
  type: TYPE_TB
- en: 'Shell script shows various string checks on and between strings as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of running this script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Similar to other checks with the `test` command, the `0` exit code means the
    expression evaluated is true and `1` means false evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: Using conditional statements with if and else
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shell provides `if` and `else` to run conditional statements depending upon
    whether the evaluation is `true` or `false`. It is useful if we want to perform
    certain tasks only if a certain condition is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: The test condition to if can be given using a test condition or [condition].
    We have already learned multiple use cases and examples of testing an expression
    in the previous section, *Testing expressions with a test*.
  prefs: []
  type: TYPE_NORMAL
- en: Simple if and else
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The syntax of the `if` condition is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If `conditional_expression` is `true`—that is, the exit status is `0`—then the
    statements inside it get executed. If not, then it will be just be ignored and
    the next line after `fi` will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of `if` and `else` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, when a condition is not true, we might want to execute some statements.
    In such cases, use `if` and `else`. Here, if `conditional_statement` is true,
    statements within if get executed. Otherwise, statements within else will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shell script prints the message if a file exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The output after running the script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example shows the greater one among two integers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output after running the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The if, elif, and else statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In some cases, more than two choices exist, of which only one needs to be executed.
    The `elif` allows you to use another `if` condition instead of using `else` if
    a condition is not true. The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following shell script will make the `elif` usage more clear. This script
    asks a user to input a valid file or directory name with the absolute path. On
    a valid regular file or directory, it displays the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The output after running the script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Nested if
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In many cases, multiple `if` conditions are required because the execution
    of a condition depends upon the result of another condition. The syntax will be
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The following script example explains the nested `if` in more detail. In this
    script, we will see how to find the greatest one of the three integer values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The output after running the script will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Indexed arrays and associative arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bash provides a feature to declare a list (or array) of variables in a one-dimensional
    array that can be an indexed array or associative array. The size of an array
    can be `0` or more.
  prefs: []
  type: TYPE_NORMAL
- en: Indexed arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An indexed array contains variables that may or may not have been initialized
    continuously. Indices of an indexed array start from `0`. This means that the
    first element of an array will start at an index `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Array declaration and value assignment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An indexed array can be declared by just initializing any index as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`array_name[index]=value`'
  prefs: []
  type: TYPE_NORMAL
- en: Here, an index can be any positive integer or an expression must be evaluated
    to a positive integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way of declaring is by using the `declare` shell built in as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`declare -a array_name`'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also initialize an array with values during a declaration. Values are
    enclosed within parentheses and each value is separated with a blank space as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`declare -a array_name=(value1 value2 value3 …)`'
  prefs: []
  type: TYPE_NORMAL
- en: Operations on arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Initializing and declaring values to a variable is not sufficient. The actual
    usage of an array is when we perform different operations on it to get the desired
    result.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following operations can be done on an indexed array:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Accessing an array element by an index: An element of an array can be accessed
    by referring to its index value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the array''s contents: The contents of an array can be printed if
    an index of an array is given as `@` or `*`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Obtaining the length of an array: The length of an array can be obtained using
    `$#` with the array variable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Obtaining the length of an array element: The length of an array element can
    be obtained using `$#` on nth index:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Deleting an element or an entire array: An element can be removed from an array
    using the `unset` keyword:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The following shell script demonstrates the different operations on an indexed
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The output after executing this script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The associative array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The associative array contains a list of elements in which each element has
    a key-value pair. The elements of an associative array are not referred by using
    an integer value `0` to `N`. It is referred by providing a key name that contains
    a corresponding value. Each key name should be unique.
  prefs: []
  type: TYPE_NORMAL
- en: The declaration and value assignment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The declaration of an associative array is done by using the `-A` option with
    the `declare` shell builtin as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'An associate array uses a key instead of an index within a square bracket in
    order to initialize a value as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiple values can be initialized in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Operations on arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A few operations on an associative array can be done similar to how an indexed
    array does, such as printing the length and content of an array. The operations
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Accessing an array element by the key name; to access an element of an associative
    array, use a unique key as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing associative array content: The following syntax is used to print an
    associative array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Getting the value and length of a given key:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding a new element; to add a new element in an associative array, use the
    `+=` operator as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Deleting an element of an associative array with the `k` key as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Deleting an associative array `array_name` as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The following shell script demonstrates the different operations on an associative
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The output after executing this script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Looping around with for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `for` loop can be used to iterate over the items in a list or till the condition
    is true.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of using the `for` loop in bash is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way of writing the `for` loop is the way C does, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Here, `expr1` is initialization, `expr2` is condition, and `expr3` is increment.
  prefs: []
  type: TYPE_NORMAL
- en: Simple iteration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following shell script explains how we can use the `for` loop to print
    the values of a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Iterating over a command output
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We know that a lot of commands give multiline output such as `ls`, `cat`, `grep`,
    and so on. In many cases, it makes sense to loop over each line of output and
    do further processing on them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example loops over the content of ''`/`'' and prints directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The output after running this script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Specifying a range to the for loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can also specify a range of integers in the `for` loop with an optional
    increment value for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The output after running this script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Small and sweet for loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some cases, we don't want to write a script and then execute it; rather,
    we prefer to do a job in shell itself. In such cases, it is very useful and handy
    to write the complete for loop in one line, rather than making it multiline.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, printing the multiples of 3 between 3 to 20 numbers can be done
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The select, while, and until loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `select`, `while` and `until` loops are also used to loop and iterate over
    each item in a list or till the condition is true with slight variations in syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Loop using select
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The select loop helps in creating a numbered menu in an easy format from which
    a user can select one or more options.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of the `select` loop is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The `list` can be pre-generated or specified while using the `select` loop in
    the form `[item1 item2 item3 …]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider a simple menu listing the contents of ''`/`'' and asking
    a user to enter an option for which you want to know whether it is a directory
    or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the screenshot of the output after running the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Loop using select](img/4335_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To exit from the script, press *Ctrl* + *C*.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `while` loop allows you to do repetitive tasks until the condition is true.
    The syntax is very similar to what we have in the C and C++ programming language,
    which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, read the name of the application and display pids of all the running
    instances of that application, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The output after running this script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: To exit from the script, press *Ctrl* + *C*.
  prefs: []
  type: TYPE_NORMAL
- en: The until loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `until` loop is very similar to the `while` loop, but the only difference
    is that it executes code block until the condition executes to false. The syntax
    of `until` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: For example, consider that we are interested in knowing `pid` of an application
    whenever any instance of it is running. For this, we can use `until` and check
    `pidof` of an application at a certain interval using `sleep`. When we find `pid`,
    we can exit from the `until` loop and print `pid` of the running instance of the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shell script demonstrates the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The output after executing this script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Switch to my choice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Switch is used to jump and run a certain case as per the result of the condition
    or expression is evaluated. It acts as an alternative to using multiple **if**
    in bash and keeps bash script much clear and readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of `switch` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: In syntax, `$variable` is the expression or value that needs to be matched among
    the list of choices provided.
  prefs: []
  type: TYPE_NORMAL
- en: In each choice, a pattern or a combination of patterns can be specified. The
    `;;` tells bash that end of given choice block. The `esac` keyword specify end
    of case block.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example to count the number of files and directories in
    a given path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The output after running this script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we first read an input path from a user using the `read` shell
    builtin. Then, we initialize the counter variable of files and directories count
    to `0`. Furthermore, we use `ls -l $path | cut -d ' ' -f1` to get a long list
    of file attributes of the path content and then retrieve its first column. We
    know that the first character of the first column of `ls -l` tells the type of
    the file. If it is `d`, then it is a directory, and `-` represents a regular file.
    The `dirs_count` or `files_count` variables get incremented accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Passing stdout as a parameter using xargs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `xargs` command is used to build and execute a command line from a standard
    input. Commands such as `cp`, `echo`, `rm`, `wc`, and so on, don''t take input
    from a standard input or redirected output from another command. In such commands,
    we can use `xargs` to provide an input as an output of another command. The syntax
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`xargs [option]`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of options are explained in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| -`a` file | This reads items from a file instead of stdin |'
  prefs: []
  type: TYPE_TB
- en: '| `-0`, `--null` | Inputs are null-terminated instead of whitespace |'
  prefs: []
  type: TYPE_TB
- en: '| `-t`, `--verbose` | Prints a command line on a standard output before executing
    |'
  prefs: []
  type: TYPE_TB
- en: '| `--show-limits` | This displays the limit on the length of the command line
    imposed by OS |'
  prefs: []
  type: TYPE_TB
- en: '| `-P max-procs` | Runs upto the max-procs processes one at a time |'
  prefs: []
  type: TYPE_TB
- en: '| `-n max-args` | This at most uses the max-args argument per command line
    |'
  prefs: []
  type: TYPE_TB
- en: Basic operations with xargs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `xargs` command can be used without any option. It allows you to enter
    an input from stdin, and when `ctrl + d` is called, it prints whatever was typed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The `--show-limits` option can be used to know the limit of the command line
    length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Using xargs to find a file with the maximum size
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following shell script will explain how `xargs` can be used to get a file
    with the maximum size in a given directory recursively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The output after running this script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are using `xargs` to pass each regular file obtained from
    the `find` command for size calculation. Furthermore, the output of `du` is redirected
    to the `sort` command for a human-numeric sort and then we can print the last
    line or sort to get the file with a maximum size.
  prefs: []
  type: TYPE_NORMAL
- en: Archiving files with a given pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another useful example of using `xargs` is to archive all the files that we
    are interested in, and these files can be kept as back files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shell script finds all the shell script in a specified directory
    and creates `tar` of it for further reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The output after running the script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: In this example, all the files with an extension `.sh` are searched and passed
    as parameters to the `tar` command to create an archive. The file `scripts.tar`
    is created in the directory from where the scripts are being called.
  prefs: []
  type: TYPE_NORMAL
- en: Using functions and positional parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to other programming languages, function is a way to write a set of
    actions once and use it multiple times. It makes the code modular and reusable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of writing a function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `function` is a keyword to specify a function and `function_name` is
    the name of the function; we can also define a function in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The actions written within curly braces are executed whenever a particular function
    is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Calling a function in bash
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the following shell script that defines the `my_func()`function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'To call `my_func()` in shell script, we just have to write a function''s name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The `my_func` function has a return value as 3\. The return value of a function
    is the exit status of a function. In the preceding example, the exit status of
    the `my_func` function is assigned to the `return_value` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of running the preceding script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The return value of a function is what the return shell builtin is specified
    in its argument. If no `return` is used, then the exit code of the last command
    is executed in the function. In this example, the exit code will be the exit code
    of the `echo` command.
  prefs: []
  type: TYPE_NORMAL
- en: Passing parameters to functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An argument to a function can be provided by specifying the first name of the
    function followed by space-separated arguments. A function in shell doesn't use
    parameters by its name but by positions; we can also say that the shell function
    takes positional parameters. Positional parameters are accessed by the variable
    names `$1`, `$2`, `$3`, `$n`, and so on, inside a function.
  prefs: []
  type: TYPE_NORMAL
- en: The length of arguments can be obtained using `$#`, a list of arguments passed
    can be fetched together using `$@` or `$*`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shell script explains how parameters are passed to the function
    in bash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding shell script example, we called the `upper_case()` method twice
    with the `hello` and `Linux shell scripting` parameters. Both of them get converted
    to uppercase. In a similar way, other functions can be written to avoid writing
    repetitive work again and again.
  prefs: []
  type: TYPE_NORMAL
- en: Alias
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Alias in shell refers to giving another name to a command or group of commands.
    It is very useful when a name of a command is long. With the help of alias, we
    can avoid typing a bigger name and invoke a command by a name as per your convenience.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an alias, alias shell builtin command is used. The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`alias alias_name="Commands to be aliased"`'
  prefs: []
  type: TYPE_NORMAL
- en: Creating alias
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To print a disk space in a human-readable format, we use the `df` command with
    the `-h` option. By making alias of `df -h` to `df`, we can avoid typing again
    and again `df -h`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the `df` command before aliasing it to `df -h` is shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '![Creating alias](img/4335_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, to create alias for df -h to df, we will execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The output obtained is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating alias](img/4335_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We see that after creating alias of `df -h` to `df`, a default disk space is
    printed in a human-readable format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful example can be aliasing the `rm` command to `rm -i`. Using `rm`
    with the `-i` option asks the user for a confirmation before deleting them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The output after executing the preceding script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: We can see that after alias creation, `rm` asks for a confirmation before deleting
    the `/tmp/file.txt` file.
  prefs: []
  type: TYPE_NORMAL
- en: Listing all aliases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To see the aliases that are already set for the current shell, use an alias
    without any argument or with the `–p` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the `df` alias that we created still exists, along with the
    already other existing aliases.
  prefs: []
  type: TYPE_NORMAL
- en: Removing an alias
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To remove an already existing alias, we can use the `unalias` shell builtin
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that the `df` alias has been removed. To remove all aliases, use `unalias`
    with the `a` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: We can see that all aliases have now been deleted.
  prefs: []
  type: TYPE_NORMAL
- en: pushd and popd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both `pushd` and `popd` are shell builtin commands. The `pushd` command is used
    to save the current directory into a stack and move to a new directory. Furthermore,
    `popd` can be used to return back to the previous directory that is on top of
    the stack.
  prefs: []
  type: TYPE_NORMAL
- en: It is very useful when we have to switch between two directories frequently.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of using `pushd` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pushd [directory]`'
  prefs: []
  type: TYPE_NORMAL
- en: If no directory is specified, `pushd` changes the directory to whatever is on
    the top of the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of using `popd` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`popd`'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `popd` switch, we can go back to the previous directory that is on
    top of the stack and pop that directory from stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example counts the number of files or directories in a specified
    directory until one level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The output after running the preceding script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading this chapter, you should now be confident enough to write an effective
    shell script by using conditional statements, loops, and so on. Now, you can also
    write a modular and reusable code using the function in shell. Having the knowledge
    of exit code will help in knowing whether the command was executed successfully
    or not. You should also know a few more useful shell builtins such as `alias`,
    `pushd`, and `popd`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn more about modularizing our script by knowing
    how to write a reusable shell script itself, which can be used in shell scripts.
    We will also see how we can debug our shell scripts to fix problems.
  prefs: []
  type: TYPE_NORMAL
