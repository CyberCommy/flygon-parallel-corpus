- en: Chapter 8. Network Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore the support that Java provides to secure communications
    between applications. We will examine several topics, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The basic encryption process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a keystore to store keys and certificates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding encryption to a simple server/client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secure client/server communications using TLS\SSL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secure hashing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many security related terms whose meaning and purpose can be daunting
    when they are first encountered. Most of these terms are applicable to network
    applications. We will start with a brief overview of many of these terms. In later
    sections of this chapter, we will go into more details about the ones that are
    relevant to our discussion.
  prefs: []
  type: TYPE_NORMAL
- en: Central to most security related issues is encryption. This is the process of
    converting information that needs to be protected to an encrypted form using a
    key or a set of keys. The receiver of the encrypted information can use a key
    or set of keys to decrypt the information and revert it to its original form.
    This technique will prevent unauthorized access to the information.
  prefs: []
  type: TYPE_NORMAL
- en: We will demonstrate the use of both **symmetric** and asymmetric encryption
    techniques. Symmetric encryption uses a single key to encrypt and decrypt messages.
    Asymmetric encryption uses a pair of keys. These keys are frequently stored in
    a file called a **keystore**, which we will demonstrate.
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric encryption is usually faster but requires the sender and receiver
    of the encrypted data to share their keys in a safe and secure manner. For parties
    that are remotely dispersed, this can be a problem. Asymmetric encryption is slower,
    but it uses a public and private key pair that, as we will see, simplifies the
    sharing of keys. Asymmetric encryption is an enabling technology for digital certificates
    that provides a means of verifying the authenticity of documents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Secure commerce is common and is essential for online transactions that take
    place globally every day. The **Transport Layer Security** (**TLS**) and **Secure
    Sockets Layer** (**SSL**) are protocols that allow secure and reliable communication
    across the Internet. It is the basis for **Hyper Text Transfer Protocol Secure**
    (**HTTPS**) that is used to conduct most transactions on the Internet. This protocol
    supports the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Server and client authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data encryption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data integrity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secure hashing is a technique that is used to create certificates. A **certificate**
    is used to verify the authenticity of data, and it uses a hash value. Java provides
    support for this process, which we will demonstrate.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with a brief introduction of common network security terms to provide
    a high-level perspective of the chapter. Specific terms are explored in more detail
    in subsequent sections.
  prefs: []
  type: TYPE_NORMAL
- en: Secure communication terminology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several terms that are used when working with secure communications.
    These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication**: This is the process of verifying a user or system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization**: This is the process of allowing access to protected resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encryption**: This is the process of encoding and subsequently decoding information
    to protect it from unauthorized individuals'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hashing algorithms**: These provide a way of producing a unique value for
    a document, and they are used in support of other security techniques'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Digital signatures**: These provide a way of digitally authenticating a document'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Certificates**: These are normally used as a chain, and they support the
    confirmation of the identity of principals and other actors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication and authorization are related. Authentication is the process
    of determining whether a person or system is who they claim to be. This is commonly
    achieved using an ID and a password. However, there are other authentication techniques,
    such as smart cards, and biometric signatures, such as fingerprint, or iris scans.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization is the process of determining what resources an individual or
    system has access to. It is one thing to verify that an individual is who they
    say they are. It is another thing to ensure that the user can only access authorized
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: Encryption has evolved and will continue to improve. Java supports symmetric
    and asymmetric encryption techniques. The process starts with the generation of
    keys, which are normally stored in a keystore. Applications that need to encrypt
    or decrypt data will access a keystore to retrieve the appropriate keys. The keystore
    itself needs to be protected so that it cannot be tampered with or otherwise compromised.
  prefs: []
  type: TYPE_NORMAL
- en: Hashing is the process of taking data and returning a number that represents
    the data. A hash algorithm performs this operation, and it must be fast. However,
    it is extremely difficult, if not impossible, to derive the original data when
    given only the hash value. This is called a one-way hash function.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of this technique is that the data can be sent along with the
    hash value to a receiver. The data is not encrypted, but the hash value is encrypted
    using a set of asymmetric keys. The receiver can then use the original hash algorithm
    to compute a hash value for the received data. If this new hash value matches
    the hash value that was sent, then the receiver can be assured that the data has
    not been modified or corrupted in the transmission. This provides a more reliable
    means of transferring data that does not need to be encrypted, but where some
    assurance that it has not been modified can be given.
  prefs: []
  type: TYPE_NORMAL
- en: A certificate is part of the previous process and it uses a hash function and
    asymmetric keys. A **certificate chain** provides a means of verifying that a
    certificate is valid, assuming that the root of the chain can be trusted.
  prefs: []
  type: TYPE_NORMAL
- en: Encryption basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will examine how Java supports symmetric and asymmetric
    encryption. As we will see, there are various encryption algorithms that are available
    for both of these techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric encryption techniques
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Symmetric encryption uses a single key to encrypt and decrypt a message. This
    type of encryption is classified as either stream ciphers or block ciphers. More
    details about these algorithms can be found at [https://en.wikipedia.org/wiki/Symmetric-key_algorithm](https://en.wikipedia.org/wiki/Symmetric-key_algorithm).
    A provider provides an implementation of an encryption algorithm, and we often
    choose between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Symmetric algorithms that are supported by Java include the following ones
    where the key size in bits is enclosed in parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: AES (128)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DES (56)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DESede (168)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HmacSHA1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HmacSHA256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Varying lengths of data may be encrypted. Block cipher algorithms are used
    to handle large blocks of data. There are several block cipher modes of operations,
    as listed next. We will not detail how these modes work here, but additional information
    can be found at [https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation):'
  prefs: []
  type: TYPE_NORMAL
- en: ECB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CBC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CFB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OFB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PCBC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we can encrypt or decrypt data, we need a key.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a key
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A common way of generating a key is using the `KeyGenerator` class. There are
    no public constructors for the class but an overloaded `getInstance` method will
    return a `KeyGenerator` instance. The following example uses the AES algorithm
    with the default provider. Other versions of this method allow selection of the
    provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `generateKey` method returns an instance of an object that implements the
    `SecretKey` interface that is shown next. This is the key that is used to support
    symmetric encryption and decryption:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: With a key, we can now encrypt data.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting text using a symmetric key
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will use the following `encrypt` method in later sections. This method is
    passed the text to encrypt and a secret key. The term **plain text** is frequently
    used to refer to the unencrypted data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Cipher` class provides the framework for the encryption process. The `getInstance`
    method returns an instance of the class where the AES algorithm is used. The `Cipher`
    instance is initialized for encryption using `Cipher.ENCRYPT_MODE` as the first
    argument, and the secret key as the second argument. The `doFinal` method encrypts
    the plain text byte array and returns an encrypted byte array. The `Base64` class''s
    `getEncoder` returns an encoder that encodes the encrypted bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Encoding an encrypted byte array is used to convert it to a string so that we
    can use it later. Encoding strings can be a useful security technique, as explained
    in [http://javarevisited.blogspot.sg/2012/03/why-character-array-is-better-than.html](http://javarevisited.blogspot.sg/2012/03/why-character-array-is-better-than.html).
  prefs: []
  type: TYPE_NORMAL
- en: Decrypting text
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The process of decrypting text is illustrated in the decrypt method that is
    shown next. It uses a reverse process where the encrypted bytes are decoded and
    the `Cipher` class''s `init` method is initialized to decrypt the bytes using
    a secret key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We will use these methods in the echo client/server applications illustrated
    in the *Symmetric encryption client/server* section.
  prefs: []
  type: TYPE_NORMAL
- en: Asymmetric encryption techniques
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Asymmetric encryption uses a public and private key. The private key is held
    by one entity. The public key is made available to everyone. Data can be encrypted
    using either key:'
  prefs: []
  type: TYPE_NORMAL
- en: If the data is encrypted using the private key, then it can be decrypted using
    the public key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the data is encrypted using the public key, then it can be decrypted using
    the private key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the owner of the private key sends out a message that is encrypted with the
    private key, then recipients of this message can decrypt it with the public key.
    They can all read the message, but they know that only the private key owner could
    have sent this message.
  prefs: []
  type: TYPE_NORMAL
- en: If someone else encrypts a message with the public key, then only the private
    key owner can read that message. However, the owner cannot be sure who actually
    sent the message. It could be an impostor.
  prefs: []
  type: TYPE_NORMAL
- en: However, if both the parties have their own set of public/private keys, we can
    guarantee that only the sender and the recipient can see its content. We can also
    guarantee that the sender is who they say they are.
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume that Sue wants to send a message to Bob. Sue will encrypt the message,
    M, using her private key. Let's call this message M1\. She will then encrypt M1
    using Bob's public key giving us M2\. The message, M2, is then sent to Bob. Now,
    only Bob can decrypt this message using his private key. This will return M1\.
    Bob can now use Sue's public key to decrypt M1 to get the original message, M.
    He knows that this is from Sue because only Sue's public key will work.
  prefs: []
  type: TYPE_NORMAL
- en: This process to send messages requires that both participants possess their
    own public/private keys. In addition to this, it is not as efficient as using
    a symmetric key. Another approach is to use asymmetric keys to transfer a secret
    key to the participants. The secret key can then be used for the actual message
    transfer. This is the technique that is used with SSL.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several asymmetric algorithms. Java supports the following encryption
    algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: RSA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Diffie-Hellman
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DSA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will demonstrate asymmetric encryption/decryption using a utility class
    called `AsymmetricKeyUtility` that is declared next. This class encapsulates methods
    to create, save, load, and retrieve public and private keys. We will explain how
    these methods work here and use them later with the asymmetric echo client/server
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Generating and saving asymmetric keys
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `main` method will create the keys, save them, and then test them to see
    whether they work correctly. The `KeyPairGenerator` method will generate the keys.
    To use asymmetric encryption, we get an instance of the class using the RSA algorithm.
    The `initialize` method specifies that the key uses 1,024 bits. The `generateKeyPair`
    method generates the keys, and the `getPrivate` and `getPublic` methods return
    the private and public keys, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use a set of methods to save and retrieve these keys to separate files.
    This approach is not the most secure, but it will simplify the use of the echo
    client/server. The next statements invoke the save methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The methods that are used to retrieve the keys are invoked here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The next code sequence tests the encryption/decryption process. A message is
    created and passed to the `encrypt` method using the public key. The `decrypt`
    method is invoked to decrypt the message. The `encodedData` variable references
    the encrypted data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Message: The message**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Decrypted Message: The message**'
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we can use the private key for encryption and the public key for decryption
    to achieve the same results.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting/decrypting text using an asymmetric key
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let''s examine the specifics of the `encrypt` and `decrypt` methods. The
    `encrypt` method uses `getInstance` to get an instance of the RSA algorithm. The
    `init` method specifies that the `Cipher` object will encrypt a message using
    a public key. The `doFinal` method performs the actual encryption and returns
    a byte array containing the encrypted message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `decrypt` method is described next. It specifies that the `Cipher` instance
    will decrypt a message using the private key. The encrypted message that is passed
    to it must be decoded before the `doFinal` method can decrypt it. The decrypted
    string is then returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Both of these methods catch a number of exceptions that can occur in the encryption/decryption
    process. We will not address these exceptions here.
  prefs: []
  type: TYPE_NORMAL
- en: Saving asymmetric keys to a file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next two methods illustrate one technique to save and retrieve a private
    key. The `PKCS8EncodedKeySpec` class supports the encoding of a private key. The
    encoded key is saved to the `private.key` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getPrivateKey` method, that is described next, returns a private key from
    the file. The `KeyFactory` class''s `generatePrivate` method creates the key based
    on the `PKCS8EncodedKeySpec` specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The public key''s save and get methods are described next. They differ in the
    file that they use, and the use of the `X509EncodedKeySpec` class. This class
    represents public keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The standard cryptographic algorithm names are found at [https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html](https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html).
    A performance comparison of symmetric algorithms is available at [http://www.javamex.com/tutorials/cryptography/ciphers.shtml](http://www.javamex.com/tutorials/cryptography/ciphers.shtml).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a keystore
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A keystore stores cryptographic keys and certificates and is frequently used
    in conjunction with servers and clients. A keystore is usually a file, but it
    can be a hardware device. Java supports the following types of keystore entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '**PrivateKey**: This is used in asymmetric cryptography'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Certificate**: This contains a public key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SecretKey**: This is used in symmetric cryptography'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are five different types of keystores that are supported by Java 8: JKS,
    JCEKS, PKCS12, PKCS11, and DKS:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JKS**: This is the **Java KeyStore** (**JKS**) that usually has an extension
    of `jks`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JCEKS**: This is the **Java Cryptography Extension KeyStore** (**JCE**).
    It can store all three keystore entity types, provides stronger protection for
    keys, and uses a `jceks` extension.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PKCS12**: In contrast to JKS and JCEKS, this keystore can be used with other
    languages. It can store all three keystore entity types, and it uses an extension
    of `p12` or `pfx`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PKCS11**: This is a hardware keystore type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DKS**: This is the **Domain KeyStore** (**DKS**) that holds a collection
    of other keystores.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default keystore type in Java is JKS. Keystores can be created and maintained
    using the `keytool` command line tool or with Java code. We will demonstrate `keytool`
    first.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and maintaining a keystore with keytool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The keytool is a command line program that is used to create keystores. The
    full documentation of its use is found at [https://docs.oracle.com/javase/8/docs/technotes/tools/unix/keytool.html](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/keytool.html).
    There are several GUI tools that are used to maintain keystores that are easier
    to use than keytool. One of these is IKEYMAN found at [http://www-01.ibm.com/software/webservers/httpservers/doc/v1312/ibm/9atikeyu.htm](http://www-01.ibm.com/software/webservers/httpservers/doc/v1312/ibm/9atikeyu.htm).
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the keytool with Windows at the command prompt, you will need to configure
    the PATH environmental variable to locate its containing directory. Use a command
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use the keytool to create a keystore. At the command prompt, enter the
    following command. This will start the process of creating a keystore in a file
    named `keystore.jks`. The alias is another name that you can use to reference
    the keystore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You will then be prompted for several pieces of information as follows. Respond
    to the prompts as appropriate. The passwords that you enter will not be displayed.
    For the examples in this chapter, we used a password of `password`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You will then be prompted to confirm the input as follows. Respond with `yes`
    if the values are correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can assign a separate password for the key, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The keystore is then created. The contents of a keystore can be displayed using
    the `–list` argument, as shown next. The `–v` option produces verbose output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This will display the following output. The keystore password needs to be entered
    along with the alias name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Keytool command-line arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Entering the information for a keystore can be tedious. One way of simplifying
    this process is to use command line arguments. The following command will create
    the previous keystore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You will note that there is not a matching double quote at the end of the command
    line. It is not needed. The command-line arguments are documented at the keytool
    website that was listed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: This tool can create both symmetric and asymmetric keys along with certificates.
    The following series of commands demonstrate several of these types of operations.
    We will create a keystore for a pair of asymmetric keys. A pair of certificates
    will then be exported that can be used with a server and client application.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command will create the `serverkeystore.jck` keystore file using the RSA
    algorithm with a key size of 1,024 bits and an expiration date of 365 days:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This command generates a `clientkeystore.jck` keystore to be used by the client
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'A certificate file for the client is created next and is placed in the `client.crt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The server''s certificate is exported here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: A trust store is a file that is used to verify credentials, while a keystore
    will produce credentials. Credentials usually take the form of a certificate.
    Trust stores typically hold certificates from a trusted third party to form a
    certificate chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command creates `the clienttruststore.jck` file, which is the
    trust store for the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This command generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The trust store for the server is created with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Its output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We will now demonstrate how we can perform similar operations in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and maintaining a keystore with Java
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Keystores, their keys, and certificates can be created directly with Java code.
    In this section, we will demonstrate how to create a keystore that contains a
    secret key. We will use this class in the *Symmetric encryption client/server*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SymmetricKeyStoreCreation` class is declared as follows. The `SymmetricKeyStoreCreation`
    method creates a keystore, while the `main` method generates and stores the secret
    key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `createKeyStore` method is described next. It is passed the keystore''s
    file name and a password. A `KeyStore` instance is created, which specifies a
    JCEKS keystore. If the keystore already exists, it will return that keystore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main` method, a `KeyGenerator` instance is created using the AES algorithm.
    The `generateKey` method will create the `SecretKey` instance, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `KeyStore.SecretKeyEntry` class represents an entry in a keystore. We need
    this and an instance of the `KeyStore.PasswordProtection` class, which represents
    the password, to store the secret key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setEntry` method uses a string alias, the keystore entry object, and the
    password to store the entry, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This entry is then written to the keystore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Other keystore operations are possible using Java.
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric encryption client/server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section demonstrates how to use symmetric encryption/decryption in a client/server
    application. The following example implements a simple echo client/server allowing
    us to focus on the basic process without digressing into specific client/server
    issues. The server is implemented with the `SymmetricEchoServer` class and client
    using the `SymmetricEchoClient` class.
  prefs: []
  type: TYPE_NORMAL
- en: The client will encrypt a message and send it to the server. The server will
    then decrypt the message and send it back in plain text. The response can easily
    be encrypted if needed. This one-way encryption is sufficient to illustrate the
    basic process.
  prefs: []
  type: TYPE_NORMAL
- en: 'When running the applications that are discussed in this chapter in Windows,
    you may encounter the following dialog box. Select the **Allow access** button
    to allow the applications to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Symmetric encryption client/server](img/B04915_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will also use the `SymmetricKeyStoreCreation` class that was developed in
    symmetric encryption techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric server application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The symmetric server is declared next. It possesses a `main`, `decrypt`, and
    `getSecretKey` methods. The `decrypt` method takes the encrypted message from
    the client and decrypts it. The `getSecretKey` method will extract the secret
    key from the keystore that was created in symmetric encryption techniques. The
    `main` method contains the basic socket and streams that are used to communicate
    with the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `decrypt` method is the same one that was developed in symmetric encryption
    techniques, so it will not be repeated here. The `getSecretKey` method is described
    next. The `secretkeystore.jks` file that was created in symmetric encryption techniques
    holds the secret key. This method uses many of the same classes that are used
    in the `main` method of the `SymmetricKeyStoreCreation` class. An instance of
    the `KeyStore.PasswordProtection` class is used to extract the secret key from
    the keystore. The keystore password, `keystorepassword`, is hardcoded into the
    application. This is not the best practice, but it simplifies the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main` method is very similar to the server that was developed in [Chapter
    1](ch01.html "Chapter 1. Getting Started with Network Programming"), *Getting
    Started with Network Programming*. The main difference is within the while loop.
    Input from the client is passed to the `decrypt` method along with the secret
    key, as shown next. The decrypted text is then displayed and returned to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main` method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's examine the client application.
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric client application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The client application is described next and is very similar to the client
    application that was developed in [Chapter 1](ch01.html "Chapter 1. Getting Started
    with Network Programming"), *Getting Started with Network Programming*. It uses
    the same `getSecretKey` method that is used in the server. The `encrypt` method
    that was explained in symmetric encryption techniques is used to encrypt the user''s
    message. Both of these methods are not duplicated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main` method differs from the version in the while loop in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with Network Programming"), *Getting Started with
    Network Programming*. The following statement encrypts the user message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main` method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to see how the client and server interact.
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric client/server in action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The applications behave the same way that they did in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with Network Programming"), *Getting Started with
    Network Programming*. The only difference is that the message sent to the server
    is encrypted. This encryption is not visible in the application''s output other
    than the display of the encrypted text on the client side. One possible interaction
    is as follows. The server output is shown first:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple Echo Server**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Waiting for connection.....**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connected to client**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client request: The first message**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client request: The second message**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple Echo Server Terminating**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the client''s application output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple Echo Client**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connected to server**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enter text: The first message**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Encrypted Text After Encryption: drkvP3bhnfMXrZluFiqKb0RgjoDqFIJMCo97YqqgNuM=**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Server response: drkvP3bhnfMXrZluFiqKb0RgjoDqFIJMCo97YqqgNuM=**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enter text: The second message**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Encrypted Text After Encryption: fp9g+AqsVqZpxKMVNx8IkNdDcr9IGHb/qv0qrFinmYs=**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Server response: fp9g+AqsVqZpxKMVNx8IkNdDcr9IGHb/qv0qrFinmYs=**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enter text: quit**'
  prefs: []
  type: TYPE_NORMAL
- en: We will now duplicate this functionality using asymmetric keys.
  prefs: []
  type: TYPE_NORMAL
- en: Asymmetric encryption client/server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `AsymmetricKeyUtility` class developed in asymmetric encryption techniques
    is used to support the client and server applications. We will use it's `encrypt`
    and `decrypt` methods. The structure of the client and server applications is
    similar to what was used in previous sections. The client will send the server
    an encrypted message, which the server will decrypt and then respond to with plain
    text.
  prefs: []
  type: TYPE_NORMAL
- en: Asymmetric server application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `AsymmetricEchoServer` class, as declared next, is used for the server.
    The `main` method is its only method. A server socket is created, which blocks
    at the `accept` method waiting for client request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon the acceptance of a client connection IO, streams are established and
    an `inputLine` byte array is instantiated with a size of `171`. This is the size
    of the message that is being sent, and using this value will avoid various exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'To perform the decryption, we need a private key. This is obtained using the
    `getPrivateKey` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'A while loop will read in an encrypted message from the client. The `decrypt`
    method is called with the message and the private key. The decrypted message is
    then displayed and sent back to the client. If the message was `quit`, then the
    server terminates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's examine the client application.
  prefs: []
  type: TYPE_NORMAL
- en: Asymmetric client application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The client application is found in the `AsymmetricEchoClient` class, as shown
    next. It also possesses only a single `main` method. Once the server connection
    has been made, IO streams are established:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Scanner` class is used to get user input. A public key is used to encrypt
    the user messages and is obtained using the `AsymmetricKeyUtility` class''s `getPublicKey`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following while loop, the user is prompted for a message, which is encrypted
    using the `encrypt` method. The encrypted message is then sent to the server.
    If the message was `quit`, then the program terminates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can use these applications together.
  prefs: []
  type: TYPE_NORMAL
- en: Asymmetric client/server in action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start the server and then the client. The client will prompt for a series of
    messages. The following shows the output of one possible interchange. The server
    side is shown first:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple Echo Server**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Waiting for connection.....**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connected to client**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client request: The first message**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client request: The second message**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client request: quit**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple Echo Server Terminating**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows the client interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple Echo Client**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connected to server**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enter text: The first message**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[B@6bc168e5**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Server response: The first message**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enter text: The second message**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[B@7b3300e5**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Server response: The second message**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enter text: quit**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[B@2e5c649**'
  prefs: []
  type: TYPE_NORMAL
- en: TLS/SSL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TLS/SSL is a set of protocols that is used to secure many servers on the Internet.
    SSL is the successor to TLS. However, they are not always interchangeable. SSL
    uses the **Message Authentication Code** (**MAC**) algorithm, while TLS uses the
    **Hashing for Message Authentication Code** (**HMAC**) algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: SSL is often used with a number of other protocols, including **File Transfer
    Protocol** (**FTP**), Telnet, **Net News Transfer Protocol** (**NNTP**), **Lightweight
    Directory Access Protocol** (**LDAP**), and **Interactive Message Access Protocol**
    (**IMAP**).
  prefs: []
  type: TYPE_NORMAL
- en: TLS/SSL does incur a performance hit in providing these capabilities. However,
    as internet speeds increase, the hit is not usually significant.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the HTTPS protocol is used, a user will know because the protocol is normally
    present in the address field of a browser. It is even used in places where you
    may not expect it, such as in the following Google URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![TLS/SSL](img/B04915_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will not delve into the details of how the SSL protocol works. However, a
    brief discussion of this protocol can be found at [http://www.javacodegeeks.com/2013/04/understanding-transport-layer-security-secure-socket-layer.html](http://www.javacodegeeks.com/2013/04/understanding-transport-layer-security-secure-socket-layer.html).
    In this section, we will illustrate how to create and use an SSL server and the
    Java classes that are used to support this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: To simplify the applications, the client sends a message to the server, which
    then displays it. No response is sent back to the client. The client connects
    to and communicates with the server using SSL. Returning the message to the client
    using SSL is left as an exercise for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: SSL server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The server is implemented in the following `SSLServer` class. All of the code
    is found in the `main` method. We will use the `keystore.jks` keystore to access
    a secret key that was created in symmetric encryption techniques. To provide access
    to the keystore, a `Provider` instance is used to specify the keystore and its
    password. Hardcoding the password in code is not a good idea, but it is used to
    simplify this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'An instance of the `SSLServerSocket` class is used to establish communications
    between a client and a server. This instance is created using the `SSLServerSocketFactory`
    class''s `getDefault` method. Similar to previous server sockets, the `accept`
    method blocks until a client connection is established:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'A `BufferedReader` instance is then created from the socket''s output stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The following while loop reads the client request and displays it. If the message
    is `quit`, then the server terminates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The SSL socket automatically handles encryption and decryption.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On a Mac, the server may throw exceptions when executed. This can be avoided
    by creating a PKCS12 keystore and using the `-Djavax.net.ssl.keyStoreType=pkcs12
    VM` option.
  prefs: []
  type: TYPE_NORMAL
- en: SSL client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `SSLClient` class implements the client application, as shown next. It
    uses essentially the same process as the server. The while loop handles user input
    in the same way that was performed in previous client applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Let's see how they interact.
  prefs: []
  type: TYPE_NORMAL
- en: SSL client/server in action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start the server and then the client. In the following output, three messages
    are sent to the server and then displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SSL Server Started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Waiting for a connection**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connection established**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Receiving: The first message**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Receiving: The second message**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The client input is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SSL Client Started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connection to SSL Server Established**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enter a message: The first message**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sending: The first message**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enter a message: The second message**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sending: The second message**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enter a message: quit**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sending: quit**'
  prefs: []
  type: TYPE_NORMAL
- en: The `SSLServerSocket` class provides a simple way of implementing SSL-enabled
    servers.
  prefs: []
  type: TYPE_NORMAL
- en: Secure hash functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A secure hash function will generate a large number, called the hash value,
    when given a document of some sort. This document can be of almost any type. We
    will be using simple strings in our examples.
  prefs: []
  type: TYPE_NORMAL
- en: The function is a one-way hash function, which means that it is effectively
    impossible to recreate the document when given a hash value. When used in conjunction
    with asymmetric keys, it allows the transmission of a document with the guarantee
    that the document has not been altered.
  prefs: []
  type: TYPE_NORMAL
- en: The sender of a document will use a secure hash function to generate the hash
    value for a document. The sender will encrypt this hash value with their private
    key. The document and the key are then combined and sent to a receiver. The document
    is not encrypted.
  prefs: []
  type: TYPE_NORMAL
- en: Upon receiving the document, the receiver will use the sender's public key to
    decrypt the hash value. The receiver will then use the same secure hash function
    against the document to obtain a hash value. If this hash value matches the decrypted
    hash value, then the receiver is guaranteed that the document has not been modified.
  prefs: []
  type: TYPE_NORMAL
- en: The intent is not to encrypt the document. While possible, this approach is
    useful when it is not important to hide the document from third parties but to
    only provide a guarantee that the document has not been modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java supports the following hashing algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: '**MD5**: The default size is 64 bytes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SHA1**: The default size is 64 bytes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will use the SHA hash function for our examples. This series of functions
    was developed by the **National Security Agency** (**NSA**). There are three versions
    of this hash function: SHA-0, SHA-1, and SHA-2\. The SHA-2 is the more secure
    algorithm and uses variable digest sizes: SHA-224, SHA-256, SHA-384, and SHA-512.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MessageDigest` class works with arbitrary-sized data producing a fixed
    size hash value. There are no public constructors for this class. The `getInstance`
    method returns an instance of the class when given the name of the algorithm.
    Valid names are found at [http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#MessageDigest](http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#MessageDigest).
    In this example, we use `SHA-256`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete example, which is adapted from [http://www.mkyong.com/java/java-sha-hashing-example/](http://www.mkyong.com/java/java-sha-hashing-example/),
    is shown next. The `displayHashValue` method extracts individual hash value bytes
    and converts them to a printable format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the program. This will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hash Value: 83c660972991049c25e6cad7a5600fc4d7c062c097b9a75c1c4f13238375c26c**'
  prefs: []
  type: TYPE_NORMAL
- en: A more detailed examination of secure hashing functions that are implemented
    in Java can be found at [http://howtodoinjava.com/2013/07/22/how-to-generate-secure-password-hash-md5-sha-pbkdf2-bcrypt-examples/](http://howtodoinjava.com/2013/07/22/how-to-generate-secure-password-hash-md5-sha-pbkdf2-bcrypt-examples/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced several Java approaches to secure communications
    between applications. We started with a brief introduction to security-related
    terms and followed the introduction with a more detailed discussion later.
  prefs: []
  type: TYPE_NORMAL
- en: There are two common encryption/decryption approaches that are used today. The
    first is symmetric key encryption, which uses a single key that is shared between
    the applications. This approach requires that the key be transmitted between the
    applications in a secure fashion.
  prefs: []
  type: TYPE_NORMAL
- en: The second approach uses asymmetric encryption. This technique uses a private
    and a public key. A message encrypted with one of these keys can be decrypted
    with the other key. Normally, the public key is distributed using a certificate
    from a trusted source. The holder of the private key needs to secure it so that
    no one else has access to it. The public key is freely shared with anyone who
    needs it.
  prefs: []
  type: TYPE_NORMAL
- en: Cryptographic keys are usually stored in a keystore that permit programmatic
    access to the keys. The keystore is created and maintained with the keytool application.
    We demonstrated the creation and use of a keystore in several of our applications.
    In addition, we used both a symmetric key and an asymmetric key pair to support
    an echo client/server application.
  prefs: []
  type: TYPE_NORMAL
- en: A more common way of creating secure clients and servers uses the `SSLServerSocket`
    class. This performs the automatic encryption and decryption of data based on
    a secret key found in a keystore. We demonstrated how the class can be used in
    a server and client application.
  prefs: []
  type: TYPE_NORMAL
- en: We also examined the use of secure hash functions. This technique allows unencrypted
    data to be transferred and guarantees that it has not been modified. An asymmetric
    key pair is used to encrypt the hash value. We provided a simple example of this
    process.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will investigate the various factors that affect the
    interaction between distributed applications.
  prefs: []
  type: TYPE_NORMAL
