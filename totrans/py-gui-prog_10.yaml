- en: Improving Data Storage with SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As weeks have passed by, there is a growing problem at the lab: the CSV files
    are everywhere! Conflicting copies, missing files, records getting changed by
    non-data entry staff, and other CSV-related frustrations are plaguing the project.
    It''s clear that individual CSV files are not working out as a way to store data
    for the experiments. Something better is needed.'
  prefs: []
  type: TYPE_NORMAL
- en: The facility has an older Linux server with a PostgreSQL database installed.
    You've been asked to update your program so that it stores data in the PostgreSQL
    database rather than in the CSV files. This promises to be a major update to your
    application!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you''ll learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring the PostgreSQL database system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structuring data in a database for good performance and reliability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basics of SQL queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `psycopg2` library to connect your program to PostgreSQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PostgreSQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PostgreSQL (usually pronounced post-gress) is a free, open source, cross-platform
    relational database system. It runs as a network service with which you can communicate
    using client programs or software libraries. At the time of writing, the project
    has just released version 10.0.
  prefs: []
  type: TYPE_NORMAL
- en: Although ABQ has provided a PostgreSQL server which is already installed and
    configured, you'll need to download and install the software on your workstation
    for development purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Shared production resources such as databases and web services should never
    be used for testing or development. Always set up a separate development copy
    of these resources on your own workstation or a separate server machine.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring PostgreSQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To download PostgreSQL, visit [https://www.postgresql.org/download/](https://www.postgresql.org/download/).
    Installers are provided for Windows, macOS, and Linux by the EnterpriseDB company,
    a commercial entity that provides paid support for PostgreSQL. These packages
    include the server, command-line client, and pgAdmin graphical client all in one
    package.
  prefs: []
  type: TYPE_NORMAL
- en: To install the software, launch the installer using an account with administrative
    rights and follow the screens in the installation wizard.
  prefs: []
  type: TYPE_NORMAL
- en: Once installed, launch pgAdmin and create a new admin user for yourself by selecting Object |
    Create | Login/Group Role. Make sure to visit the Privileges tab to check Superuser,
    and the Definition tab to set a password. Then, create a database by selecting
    Object | Create | Database. Make sure to set your user as an owner. To run SQL
    commands on your database, select your database and click Tools | Query Tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'MacOS or Linux users who prefer the command line can also use the following
    these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Although Enterprise DB provides binary installers for Linux, most Linux users
    will prefer to use packages supplied by their distribution. You may end up with
    a slightly older version of PostgreSQL, but that won't matter for most basic use
    cases. Be aware that pgAdmin is usually part of a separate package, and that the
    latest version (pgAdmin 4) may not be available. Regardless, you should have no
    trouble following this chapter with the older version.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting with psycopg2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make SQL queries from our application, we'll need to install a Python library
    that can talk directly to our database. The most popular choice is `psycopg2`.
    The `psycopg2` library is not a part of the Python standard library. You can find
    the most current installation instructions at [http://initd.org/psycopg/docs/install.html](http://initd.org/psycopg/docs/install.html);
    however, the preferred method is to use `pip`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Windows, macOS, and Linux, the following command should work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If that doesn't work, or if you'd rather install it from the source, check the
    requirements on the website. The `psycopg2` library is written in C, not Python,
    so it requires a C compiler and a few other development packages. Linux users
    can usually install `psycopg2` from their distribution's package management system.
    We'll get in-depth with the use of `psycopg2` later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: SQL and relational database basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can start using PostgreSQL with Python, you'll need to have at least
    a basic understanding of SQL. If you already have one, you can skip to the next
    section; otherwise, brace yourself for a super-short crash course on relational
    databases and SQL.
  prefs: []
  type: TYPE_NORMAL
- en: For over three decades, relational database systems have remained a de-facto
    standard for storing business data. They are more commonly known as **SQL databases**,
    after the **Structured Query Language** (**SQL**) used to interact with them.
  prefs: []
  type: TYPE_NORMAL
- en: SQL databases are made up of tables. A table is something like our CSV file,
    in that it has rows representing individual items and columns representing data
    values associated with each item. A SQL table has some important differences from
    our CSV file. First, each column in the table is assigned a data type which is
    strictly enforced; just as Python will produce an error when you try to use `abcd`
    as an `int`, a SQL database will complain if you try to insert letters into a
    numeric or other non-string column. SQL databases typically support data types
    for text, numbers, dates and times, boolean values, binary data, and more.
  prefs: []
  type: TYPE_NORMAL
- en: SQL tables can also have constraints, which further enforce the validity of
    data inserted into the table. For example, a column can be given a unique constraint,
    which prevents two rows having the same value, or a not null constraint, which
    means that every row must have a value.
  prefs: []
  type: TYPE_NORMAL
- en: SQL databases commonly contain many tables; these tables can be joined together
    to represent much more complicated data structures. By breaking data into multiple
    linked tables, it can be stored in a way that is much more efficient and resilient
    than our two-dimensional plaintext CSV files.
  prefs: []
  type: TYPE_NORMAL
- en: Basic SQL operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQL is a powerful and expressive language for doing mass manipulations of tabular
    data, but the basics can be grasped quickly. SQL is executed as individual queries
    which either define or manipulate data in the database. SQL dialects vary somewhat
    between different relational database products, but most of them support ANSI/ISO-standard
    SQL for core operations. While we'll be using PostgreSQL in this chapter, most
    of the SQL statements we write will be portable to different databases.
  prefs: []
  type: TYPE_NORMAL
- en: To follow this section, connect to an empty database on your PostgreSQL database
    server, either using the `psql` command-line tool, the pgAdmin 4 graphical tool,
    or another database client software of your choosing.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax differences from Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've only ever programmed in Python, SQL may feel odd at first, as the
    rules and syntax are very different.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll be going over the individual commands and keywords, but the following
    are some general differences from Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SQL is (mostly) case-insensitive**: Although it''s conventional for readability
    purposes to type the SQL keywords in all-caps, most SQL implementations are not
    case-sensitive. There are a few small exceptions here and there, but, for the
    most part, you can type SQL in whatever case is easiest for you.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Whitespace is not significant**: In Python, new lines and indentation can
    change the meaning of a piece of code. In SQL, whitespace is not significant and
    statements are terminated with a semicolon. Indents and new lines in a query are
    only there for readability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SQL is declarative**: Python could be described as an imperative programming
    language: we tell Python what we want it to do by telling it how to do it. SQL
    is more of a declarative language: we describe what we want, and the SQL engine
    figures out how to do it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll encounter additional syntax differences as we look at specific SQL code
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: Defining tables and inserting data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SQL tables are created using the `CREATE TABLE` command as shown in the following
    SQL query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we're creating a table called `musicians`. After the name,
    we specify a list of column definitions. Each column definition follows the format
    `column_name data_type constraints`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we have the following four columns:'
  prefs: []
  type: TYPE_NORMAL
- en: The `id` column will be an arbitrary row ID. It's type is `SERIAL`, which means
    it will be an autoincrementing integer field, and its constraint is `PRIMARY KEY`,
    which means it will be used as the unique identifier for the row.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `name` field is of type `TEXT`, so it can hold a string of any length. Its
    constraint of `NOT NULL` means that the `NULL` values are not allowed in this
    field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `born` and `died` fields are the `DATE` fields, so they can only hold a
    date value. The `born` field has no constraints, but `died` has a `CHECK` constraint
    enforcing that its value must be greater than the value of `born` for any given
    row.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although it's not required, it's a good practice to specify a primary key for
    each table. Primary keys can be one field, or a combination of fields, but the
    value must be unique for any given row. For example, if we made `name` the primary
    key field, we couldn't have two musicians with the same name in our table.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add rows of data to this table, we use the `INSERT INTO` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `INSERT INTO` command takes a table name and an optional list specifying
    the fields to receive data; other fields will receive their default value (`NULL`
    if not otherwise specified in the `CREATE` statement). The `VALUES` keyword indicates
    that a list of data values to be followed, formatted as a comma-separated list
    of tuples. Each tuple corresponds to one table row and must match the field list
    specified after the table name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that strings are delimited by the single quote character. Unlike Python,
    single quotes and double quotes have different meanings in SQL: a single quote
    indicates a string literal, while double quotes are used for object names that
    include spaces or need to preserve case. Had we used double quotes here, it would
    have resulted in an error.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create and populate an `instruments` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `VALUES` lists must always use parentheses around each row, even
    if there's only one value per row.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tables can be changed after they are created using the `ALTER TABLE` command
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `ALTER TABLE` command takes a table name, then a command altering some aspect
    of the table. In this case, we're adding a new column called `main_instrument`,
    which will be an integer. The `REFERENCES` constraint we've specified is known
    as a **foreign key** constraint; it limits the possible values of `main_instrument`
    to existing ID numbers in the `instruments` table.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving data from tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To retrieve data from tables, we use the `SELECT` statement as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `SELECT` command takes a column or comma-separated list of columns followed
    by a `FROM` clause, which specifies the table or tables containing the specified
    columns. This query asks for the `name` column from the `musicians` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Its output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `name` |'
  prefs: []
  type: TYPE_TB
- en: '| `Bill Bruford` |'
  prefs: []
  type: TYPE_TB
- en: '| `Keith Emerson` |'
  prefs: []
  type: TYPE_TB
- en: '| `Greg Lake` |'
  prefs: []
  type: TYPE_TB
- en: '| `Robert Fripp` |'
  prefs: []
  type: TYPE_TB
- en: '| `David Gilmour` |'
  prefs: []
  type: TYPE_TB
- en: 'Instead of a list of columns, we can also specify an asterisk, which means
    all columns as shown in the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The  preceding SQL query returns a following table of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `ID` | `name` | `born` | `died` | `main_instrument` |'
  prefs: []
  type: TYPE_TB
- en: '| `4` | `Bill Bruford` | `1949-05-17` |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `2` | `Keith Emerson` | `1944-11-02` | `2016-03-11` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `3` | `Greg Lake` | `1947-11-10` | `2016-12-07` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `Robert Fripp` | `1946-05-16` |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `5` | `David Gilmour` | `1946-03-06` |  |  |'
  prefs: []
  type: TYPE_TB
- en: 'To filter out rows we don''t want, we can specify a `WHERE` clause as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `WHERE` command must be followed by a conditional statement; rows that satisfy
    the condition are shown, while rows that do not are left out. In this case, we
    have asked for the names of musicians who do not have a date of death.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can specify complex conditions with the `AND` and `OR` operators as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we would only get musicians born before 1945 who have not died.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SELECT` command can also do operations on fields, or re-order the results
    by certain columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we're using the `age()` function to determine the age of the
    musicians from their birth dates. We're also doing math on the `died` and `born`
    dates to determine the age at death for those who have passed. Notice that we're
    using the `AS` keyword to rename, or alias, the generated column.
  prefs: []
  type: TYPE_NORMAL
- en: When you run this query, notice that `age at death` is `NULL` for those without
    a date of death. Mathematical or logical operations on a `NULL` value always return
    an answer of `NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: The `ORDER BY` clause specifies a column or list of columns by which the results
    should be ordered. It also takes an argument of `DESC` or `ASC` to specify descending
    or ascending order. We have ordered the output here by date of birth in descending
    order. Note that each data type has its own rules for sorting data, just like
    in Python. Dates are ordered by their calendar position, strings by alphabetical
    order, and numbers by their numeric value.
  prefs: []
  type: TYPE_NORMAL
- en: Updating rows, deleting rows, and more WHERE clauses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To update or delete existing rows, we use the `UPDATE` and `DELETE FROM` keywords
    in conjunction with a `WHERE` clause to select the affected rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deleting is fairly simple looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DELETE FROM` command will delete any rows that match the `WHERE` conditions.
    In this case, we match the primary key to ensure only one row is deleted. If no
    rows match the `WHERE` conditions, no rows will be deleted. Note, however, that
    the `WHERE` clause is technically optional: `DELETE FROM instruments` will simply
    delete all rows in the table.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Updating is similar, except it includes a `SET` clause to specify new column
    values as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are setting `main_instrument` to the corresponding `instruments` primary
    key value for two musicians. We can select our musician records to update by primary
    key, name, or any valid set of conditions. Like `DELETE`, omitting the `WHERE`
    clause would affect all rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any number of columns can be updated in the `SET` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Additional column updates are just separated by commas. Note that we''ve also
    matched the record using the `LIKE` operator in tandem with the `%` wildcard character.
    `LIKE` can be used with text and string data types to match partial values. Standard
    SQL supports two wildcard characters: `%`, which matches any number of characters,
    and `_`, which matches a single character.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also match against transformed column values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've used the `LOWER` function to match our string against the lowercase
    version of the column value. This doesn't permanently change the data in the table;
    it just temporarily changes the value for the check.
  prefs: []
  type: TYPE_NORMAL
- en: Standard SQL specifies that `LIKE` is a case-sensitive match. PostgreSQL offers
    an `ILIKE` operator which does case-insensitive matching as well as a `SIMILAR
    TO` operator that matches using more advanced regular expression syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Subqueries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rather than using the raw primary key values of our `instruments` table each
    time, we can use a subquery as shown in the following SQL query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: A subquery is a SQL query within a SQL query. If your subquery can be guaranteed
    to return a single value, it can be used anywhere you would use a literal value.
    In this case, we're letting our database do the work of figuring out what the
    primary key of `guitar` is, and inserting that for our `main_instrument` value.
  prefs: []
  type: TYPE_NORMAL
- en: In the `WHERE` clause, we've also used the `IN` operator to match against a
    list of values. This allows us to match against a list of values.
  prefs: []
  type: TYPE_NORMAL
- en: '`IN` can be used with a subquery as well as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Since `IN` is meant to be used with a list of values, any query that returns
    a single column with any number of rows is valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Subqueries that return multiple rows and multiple columns can be used anywhere
    a table can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note that subqueries in a `FROM` clause require an alias; we've aliased the
    subquery as `living_musicians`.
  prefs: []
  type: TYPE_NORMAL
- en: Joining tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Subqueries are one way of using multiple tables together, but a more flexible
    and powerful way is to use `JOIN`.
  prefs: []
  type: TYPE_NORMAL
- en: '`JOIN` is used in the `FROM` clause of an SQL statement as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: A `JOIN` statement requires an `ON` clause that specifies the conditions used
    to match rows in each table. The `ON` clause acts like a filter, much like the
    `WHERE` clause does; you can imagine that the `JOIN` creates a new table containing
    every possible combination of rows from both tables, then filters out the ones
    that don't match the `ON` conditions. Tables are typically joined by matching
    the values in common fields, such as those specified in a foreign key constraint.
    In this case, our `musicians.main_instrument` column contains the `id` values
    from the `instrument` table, so we can join the two tables based on this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Joins are used to implement the following four types of table relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: One-to-one joins match exactly one row in the first table to exactly one row
    in the second.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many-to-one joins match multiple rows in the first table to exactly one row
    in the second.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One-to-many joins match one row in the first table to multiple rows in the second.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many-to-many joins match multiple rows in both tables. This kind of join requires
    the use of an intermediary table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The earlier query shows a many-to-one join, since many musicians can have the
    same main instrument. Many-to-one joins are often used when a column's value should
    be limited to a set of options, such as fields that our GUI might represent with
    a `ComboBox` widget. The table joined is called a **lookup table**.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to reverse it, it would be one-to-many:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: One-to-many joins are commonly used when a record has a list of sub-records
    associated with it; in this case, each instrument has a list of musicians who
    consider it their main instrument. The joined table is often called a **detail
    table**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding SQL query will give you the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `instrument` | `musician` |'
  prefs: []
  type: TYPE_TB
- en: '| `drums` | `Bill Bruford` |'
  prefs: []
  type: TYPE_TB
- en: '| `keyboards` | `Keith Emerson` |'
  prefs: []
  type: TYPE_TB
- en: '| `bass` | `Greg Lake` |'
  prefs: []
  type: TYPE_TB
- en: '| `guitar` | `Robert Fripp` |'
  prefs: []
  type: TYPE_TB
- en: '| `guitar` | `David Gilmour` |'
  prefs: []
  type: TYPE_TB
- en: Notice that `guitar` is duplicated in the instrument list. When two tables are
    joined, the rows of the result no longer refer to the same type of object. One
    row in the instrument table represents an instrument. One row in the `musician`
    table represents one musician. One row in this table represents an `instrument`-`musician`
    relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'But suppose we wanted to keep the output such that one row represented one
    instrument but could still include information about associated musicians in each
    row. To do this, we''ll need to aggregate the matched musician rows using an aggregate
    function and the `GROUP BY` clause as shown in the following SQL query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `GROUP BY` clause specifies which column or columns describe what each row
    in the output table represents. Output columns not in the `GROUP BY` clause must
    then be reduced to single values using an aggregate function. In this case, we're
    using the `count()` function to count the total number of musician records associated
    with each instrument. Standard SQL contains several more aggregate functions,
    such as `min()`, `max()`, and `sum()`, and most SQL implementations extend this
    with their own functions as well.
  prefs: []
  type: TYPE_NORMAL
- en: Many-to-one and one-to-many joins don't quite cover every possible situation
    that databases need to model; quite often, a many-to-many relationship is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate a many-to-many join, let''s create a new table called `bands` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: A band has multiple musicians, and musicians can be part of multiple bands.
    How can we create a relationship between musicians and bands? If we added a `band`
    field to the `musicians` table, this would limit each musician to one band. If
    we added a `musician` field to the `band` table, this would limit each band to
    one musician. To make the connection, we need to create a **junction table**,
    in which each row represents a musician's membership in a band.
  prefs: []
  type: TYPE_NORMAL
- en: 'By convention, we call this `musicians_bands`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `musicians_bands` table simply contains two foreign key fields, one to
    point to a musician''s ID and one to point to the band''s ID. Notice that instead
    of creating or specifying one field as the primary key, we use the combination
    of both fields as the primary key. It wouldn''t make sense to have multiple rows
    with the same two values in them, so the combination makes an acceptable primary
    key. To write a query that uses this relationship, our `FROM` clause needs to
    specify two `JOIN` statements: one from `musicians` to `musicians_bands` and one
    from `bands` to `musicians_bands`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s get the names of the bands each musician has been in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This query ties `musicians` to `bands` using the junction table, then displays
    musician names next to an aggregated list of the bands they've been in, and orders
    it by the musician's name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding SQL query gives you the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `name` | `bands` |'
  prefs: []
  type: TYPE_TB
- en: '| `Bill Bruford` | `{ABWH,"King Crimson",Yes}` |'
  prefs: []
  type: TYPE_TB
- en: '| `David Gilmour` | `{"Pink Floyd"}` |'
  prefs: []
  type: TYPE_TB
- en: '| `Greg Lake` | `{ELP,"King Crimson"}` |'
  prefs: []
  type: TYPE_TB
- en: '| `Keith Emerson` | `{ELP}` |'
  prefs: []
  type: TYPE_TB
- en: '| `Robert Fripp` | ``{"King Crimson"}`` |'
  prefs: []
  type: TYPE_TB
- en: The `array_agg()` function used here aggregates string values into an array
    structure. This method and the `ARRAY` data type are specific to PostgreSQL. There
    is no SQL standard function for aggregating string values, but most SQL implementations
    have a solution for it.
  prefs: []
  type: TYPE_NORMAL
- en: Learning more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This has been a quick overview of SQL concepts and syntax; we've covered most
    of what you need to know to write a simple database application, but there's much
    more to learn. The PostgreSQL manual, available at [https://www.postgresql.org/docs/manuals/](https://www.postgresql.org/docs/manuals/),
    is a great resource and reference for SQL syntax and the specific features of
    PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling relational data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application currently stores data in a single CSV file; a file like this
    is often called a **flat file**, because the data has been flattened to two dimensions.
    While this format works acceptably for our application and could be translated
    directly to an SQL table, a more accurate and useful data model requires more
    complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Normalization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of breaking out a flat data file into multiple tables is called
    **normalization**. Normalization is a process involving a series of levels called
    **normal forms** which progressively remove duplication and create a more precise
    model of the data we're storing. Although there are many normal forms, most issues
    encountered in common business data can be handled by conforming to the first
    three.
  prefs: []
  type: TYPE_NORMAL
- en: 'Roughly speaking, that requires the following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: The **first normal form** requires that each field contains only one value,
    and that repeating columns must be eliminated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **second normal form**additionally requires that every value must be dependent
    on the entire primary key. In other words, if a table has primary key fields `A`,
    `B`, and `C`, and the value of column of `X` depends solely on the value of column
    `A` without respect to `B` or `C`, the table violates the second normal form.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **third normal form** additionally requires every value in the tableto be
    dependent only on the primary key. In other words, given a table with primary
    key `A`, and data fields `X` and `Y`, the value of `Y` can't depend on the value
    of `X`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conforming data to these forms eliminates the potential for redundant, conflicting,
    or undefined data situations.
  prefs: []
  type: TYPE_NORMAL
- en: The entity-relationship diagrams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One effective way to help normalize our data and prepare it for a relational
    database is to analyze it and create an **entity-relationship diagram**, or **ERD**.
    An ERD is a way of diagramming the things which our database is storing information
    about and the relationships between those things.
  prefs: []
  type: TYPE_NORMAL
- en: Those things are called **entities**. An **entity** is a uniquely identifiable
    object; it corresponds to a single row of a single table. Entities have attributes,
    which correspond to the columns of its table. Entities have relationships with
    other entities, which correspond to the foreign key relationships we define in
    SQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the entities in our lab scenario with their attributes and
    relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: There are labs. Each lab has a name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are plots. Each plot belongs to a lab and has a number. A seed sample
    is planted in the plot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are lab technicians, who each have a name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are lab checks, which are performed by a lab tech at a given lab. Each
    one has a date and time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are plot checks, which is the data gathered at a plot during a lab check.
    Each plot check has various plant and environmental data recorded on it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram of these entities and relationships is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7fd91062-81f2-4025-a39e-26abb3216732.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding diagram, the entities are represented by rectangles. We have
    five entities: **Lab**, **Plot**, **Lab Tech**, **Lab Check**, and **Plot Check**.
    Each entity has attributes, represented by the ovals. The relationships are represented
    by diamonds, with the words describing the left-to-right relationship. For example,
    **Lab Tech** performs **Lab Check**, and **Lab Check** is performed in **Lab**.
    Note the small **1** and **n** characters around the relationship: these show
    whether a relationship is one-to-many, many-to-one, or many-to-many.'
  prefs: []
  type: TYPE_NORMAL
- en: This diagram represents a reasonably normalized structure for our data. To implement
    it in SQL, we'd just make a table for each entity, a column for each attribute,
    and a foreign key relationship (possibly including an intermediate table) for
    each relationship. Before we can do that, let's consider SQL data types.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Standard SQL defines 16 data types, including types for integers and floating-point
    numbers of various sizes, ASCII or Unicode strings of either fixed or variable
    sizes, date and time types, and bit types. Nearly every SQL engine extends this
    with yet more types to accommodate binary data, special types of strings or numbers,
    and more. Many data types seem a little redundant, and several have aliases that
    may be different between implementations. Choosing data types for your columns
    can be surprisingly confusing!
  prefs: []
  type: TYPE_NORMAL
- en: 'For PostgreSQL, the following chart provides some reasonable choices:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Data being stored** | **Recommended type** | **Notes** |'
  prefs: []
  type: TYPE_TB
- en: '| Fixed-length strings | `CHAR` | Requires a length. |'
  prefs: []
  type: TYPE_TB
- en: '| Short-to-medium strings | `VARCHAR` | Requires a max length argument, for
    example, `VARCHAR(256)`. |'
  prefs: []
  type: TYPE_TB
- en: '| Long, freeform text | `TEXT` | Unlimited length, slower performance. |'
  prefs: []
  type: TYPE_TB
- en: '| Smaller Integers | `SMALLINT` | Up to ±32,767. |'
  prefs: []
  type: TYPE_TB
- en: '| Most Integers | `INT` | Up to around ±2.1 billion. |'
  prefs: []
  type: TYPE_TB
- en: '| Larger Integers | `BIGINT` | Up to around ±922 quadrillion. |'
  prefs: []
  type: TYPE_TB
- en: '| Decimals numbers | `NUMERIC` | Takes optional length and precision arguments.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Integer Primary Key | `SERIAL`, `BIGSERIAL` | Autoincrementing integer or
    big integers. |'
  prefs: []
  type: TYPE_TB
- en: '| Boolean | `BOOLEAN` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Date and time | `TIMESTAMP WITH TIMEZONE` | Stores date, time, and timezone.
    Accurate to 1 µs. |'
  prefs: []
  type: TYPE_TB
- en: '| Date without time | `DATE` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Time without date | `TIME` | Can be with or without time zone. |'
  prefs: []
  type: TYPE_TB
- en: These types will probably meet the vast majority of your needs in most applications,
    and we'll be using a subset of these for our ABQ database. As we create our tables,
    we'll refer to our data dictionary and choose appropriate data types for our columns.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful not to choose overly specific or restrictive data types. Any data
    can ultimately be stored in a `TEXT` field; the purpose of choosing more specific
    types is mainly to enable the use of operators, functions, or sorting specific
    to that type. If those aren't required, consider a more generic type. For example,
    phone numbers and U.S. Social Security numbers can be represented purely with
    digits, but that's no reason to make them `INTEGER` or `NUMERIC` fields; after
    all, you wouldn't do arithmetic with them!
  prefs: []
  type: TYPE_NORMAL
- en: Creating the ABQ database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've modeled our data and gotten a feel for the data types available,
    it's time to build our database. To begin, create a database on your SQL server
    called `abq` and make yourself the owner.
  prefs: []
  type: TYPE_NORMAL
- en: Next, under your project root folder, create a new directory called `sql`. Inside
    the `sql` folder, create a file called `create_db.sql`. We'll start writing our
    database creation code in this file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The order in which we create our tables is significant. Any table referred to
    in a foreign key relationship will need to exist before the relationship is defined.
    Because of this, it's best to start with your lookup tables and follow the chain
    of one-to-many relationships until all the tables are created. In our ERD, that
    takes us from roughly the upper-left to the lower-right.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the lookup tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to create the following three lookup tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`labs`: This lookup table will contain the ID strings for our laboratories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lab_techs`: This lookup table will have the names of the lab technicians,
    identified by their employee ID numbers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`plots`: This lookup table will have one row for each physical plot, identified
    by lab and plot numbers. It will also keep track of the current seed sample planted
    in the plot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add the SQL query for creating these tables to `create_db.sql` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we can use our database, the lookup tables will need to be populated:'
  prefs: []
  type: TYPE_NORMAL
- en: '`labs` should have values `A` through `E` for the five labs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lab_techs` needs the name and ID number for our four lab technicians: `J Simms`
    (`4291`), `P Taylor` (`4319`), `Q Murphy` (`4478`), and `L Taniff` (`5607`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`plots` needs all 100 of the plots, numbers `1` through `20` for each lab.
    The seed sample rotates between four values such as `AXM477`, `AXM478`, `AXM479`,
    and `AXM480`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can populate these tables by hand using pgAdmin, or using the `db_populate.sql`
    script included with the example code.
  prefs: []
  type: TYPE_NORMAL
- en: The lab_checks table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `lab_check` table is an instance of a technician checking all the plots
    of a lab at a given time on a given date as shown in the following SQL query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `date`, `time`, and `lab_id` columns together uniquely identify a lab check,
    and so we designate them the primary key columns. The ID of the lab technician
    performing the check is the lone attribute in this table.
  prefs: []
  type: TYPE_NORMAL
- en: The plot_checks table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Plot checks are the actual data records collected at individual plots. These
    are part of a lab check, and so must refer back to an existing lab check.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll begin with the primary key columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the primary key of a `lab_check` table plus a `plot` number; its key
    constraints look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can add the attribute columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Notice our use of data types and the `CHECK` constraint to duplicate the limits
    from our `data` dictionary. Using these, we've leveraged the power of the database
    to safeguard against invalid data.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we finish our database design, we're going to create a view that will
    simplify access to our data. A view behaves like a table in most respects, but
    contains no actual data; it's really just a stored `SELECT` query. Our view will
    format our data for easier interaction with the GUI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Views are created using the `CREATE VIEW` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the parentheses, we put the `SELECT` query that will return the table
    data for our view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We're selecting the `plot_checks` table, and joining it to `lab_checks` and
    `lab_techs` by way of our foreign key relationships. Notice that we've aliased
    these tables by using the `AS` keyword. Short aliases like this can help make
    a large query more readable. We're also aliasing each field to the name used in
    the application's data structures. These must be enclosed in double quotes to
    allow for the use of spaces and to preserve case. By making the column names match
    the `data` dictionary keys in our application, we won't need to translate field
    names in our application code.
  prefs: []
  type: TYPE_NORMAL
- en: SQL database engines such as PostgreSQL are highly efficient at joining and
    transforming tabular data. Whenever possible, leverage this power and make the
    database do the work of formatting the data for the convenience of your application.
  prefs: []
  type: TYPE_NORMAL
- en: This completes our database creation script. Run this script in your PostgreSQL
    client and verify that the four tables and the view have been created.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating SQL into our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Converting our application to a SQL backend will be no small task. The application
    was built around the assumption of the CSV files, and although we've taken care
    to separate our concerns, many things are going to need to change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s break down the steps we''ll need to take:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll need to write a SQL model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our `Application` class will need to use the SQL model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The record form will need to be reordered to prioritize our keys, use the new
    lookups, and autopopulate using the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The record list will need to be adjusted to work with the new data model and
    primary keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Along the way, we'll need to fix other bugs or implement some new UI elements
    as needed. Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start in `models.py` by importing `psycopg2` and `DictCursor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`DictCursor` will allow us to fetch results in Python dictionary rather than
    the default tuples, which is easier to work with in our application.'
  prefs: []
  type: TYPE_NORMAL
- en: Begin a new model class called `SQLModel` and copy over the `fields` property
    from the `CSVModel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by clearing the value lists from `Technician`, `Lab`, and `Plot`, and
    making `Technician` an `FT.string_list` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: These lists will be populated from our lookup tables rather than hardcoded into
    the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll do that in the `__init__()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`__init__()` takes our basic database connection details and establishes a
    connection to the database using `psycopg2.connect()`. Because we passed in `DictCursor`
    as the `cursor_factory`, this connection will return lists of dictionaries for
    all data queries.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, we query the database for the pertinent columns in our three lookup tables
    and use a list comprehension to flatten the results of each query for the `values`
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `query` method used here is a wrapper that we need to write next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Querying a database using `psycopg2` involves generating a `cursor` object from
    the connection, then calling its `execute()` method with the query string and
    optional parameter data. By default, all queries are executed in a transaction,
    meaning they don't take effect until we commit the changes. If the query raises
    an exception for any reason (SQL syntax error, constraint violation, connection
    issue, and so on) the transaction enters a corrupt state and must be rolled back
    (reverted to the beginning state of the transaction) before we can use our connection
    again. Therefore, we will execute our queries in a `try` block and rollback the
    transaction using `connection.rollback()` in the event of any `psycopg2`-related
    exceptions (which all descend from `pg.Error`).
  prefs: []
  type: TYPE_NORMAL
- en: 'To retrieve data from a cursor after the query is executed, we''re using the
    `fetchall()` method, which retrieves all results as a list. However, if the query
    wasn''t a data-returning query (such as `INSERT`, for example), `fetchall()` will
    throw an exception. To avoid this, we first check `cursor.description`: if the
    query returned data (even an empty set of data), `cursor.description` will contain
    metadata about the returned table (column names, for example). If not, it will
    be `None`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test our `query()` method by writing the `get_all_records()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Since our users are used to working with only the current day's data, we'll
    only show that data by default, but add an optional flag should we ever need to
    retrieve all data. We can get the current date in most SQL implementations using
    the `CURRENT_DATE` constant, which we've used here. To use our `all_dates` flag,
    we're employing a prepared query.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax `%(all_dates)s` defines a parameter; it tells `psycopg2` to check
    the included parameter dictionary for the key `all_dates` and substitute its value
    into the query. The `psycopg2` library will automatically do this in a way that's
    both safe and works correctly with various data types like `None` or Boolean values.
  prefs: []
  type: TYPE_NORMAL
- en: Always use prepared queries to pass data into a SQL query. Never use string
    formatting or concatenation! Not only is it harder than you think to get it right,
    it can leave you open to accidental or malicious database corruption.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s create `get_record()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We're no longer dealing in row numbers like our `CSVModel` did, so this method
    needs all four key fields to retrieve a record. Once again, we're using a prepared
    query, specifying parameters for the four fields. Take note of the `s` after the
    closing parenthesis of the parameter; this is a required format specifier, and
    should always be `s`.
  prefs: []
  type: TYPE_NORMAL
- en: Even with a single row, `query()` is going to return results in a list. Our
    application expects a single row dictionary from `get_record()`, so our `return`
    statement extracts the first item in `result` if the list is not empty, or an
    empty `dict` if it is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Retrieving a lab check record is very similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In this query, we're using a join to make sure we have the technician name available
    and not just the ID. This method will come in handy in our `save_record()` method
    and form data autofill methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `save_record()` method will need four queries: an `INSERT` and `UPDATE`
    query for each of `lab_checks` and `plot_checks`. To keep the method reasonably
    concise, let''s create the query strings as class properties.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with the lab check queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: These queries are fairly straightforward, though note our use of a subquery
    to populate `lab_tech_id` in each case. Our application will have no idea what
    a lab tech's ID is, so we'll need to look the ID up by name. Also, take note that
    our parameter names match the names used in our application's fields. This will
    save us having to reformat the record data acquired from our form.
  prefs: []
  type: TYPE_NORMAL
- en: 'The plot check queries are longer but no more complicated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'With the queries in place, we can start the `save_record()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `CSVModel.save_record()` method took a `record` dictionary and a `rownum`,
    but we no longer need the `rownum` since it's meaningless. All our key information
    is already in the record. For convenience, we'll extract those four fields and
    assign them local variable names.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three possibilities when we try to save a record in this database:'
  prefs: []
  type: TYPE_NORMAL
- en: Neither a lab check or plot check record exists. Both will need to be created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lab check exists but the plot check does not. The lab check will need to
    be updated, in case the user wants to correct the technician value, and the plot
    check will need to be added.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both the lab check and plot check exist. Both will need to be updated with the
    submitted values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To determine which possibility is true, we''ll make use of our `get_` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: For both the lab check and plot check, we attempt to retrieve a record from
    the respective table using our key values. If one is found, we'll use our update
    queries; otherwise, we'll use our insert queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we just run those queries with `record` as the parameter list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note that `psycopg2` has no problem with us passing a dictionary with extra
    parameters that aren't referenced in the query, so we don't need to bother with
    filtering unneeded items from `record`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more thing we need to do here: remember that our `Application`
    needs to keep track of updated and inserted rows. Since we are no longer dealing
    with row numbers, only the database model knows whether an insert or update was
    performed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an instance property to share that information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now `Application` can check the value of `last_write` after calling `save_record()`
    to determine which operation was done.
  prefs: []
  type: TYPE_NORMAL
- en: There is one last method this model needs; since our database knows what seed
    sample is currently in each plot, we want our form to populate this automatically
    for the user. We'll need a method that takes a `lab` and `plot_id` and returns
    the seed sample name.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll call it `get_current_seed_sample()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This time, our `return` statement is not just extracting the first row of results,
    but the value of the `current_seed_sample` column from that first row. If there's
    no `result`, we return an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: That completes our model class; now let's incorporate it into the application.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting the Application class for the SQL backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing the `Application` class will need is the database connection
    information to pass to the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the host and database name, we can just add settings to our `SettingsModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: These can be saved in our JSON `config` file, which can be edited to switch
    from development to production, but our username and password will need to be
    entered by the user. For that, we'll need to build a login dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Building a login window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tkinter does not provide us with a ready-made login dialog, but it does provide
    us with a generic `Dialog` class which can be subclassed to create custom dialogs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Import this class from `tkinter.simpledialog` into our `views.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start with our class declaration and `__init__()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Our class will take a `parent` as usual, a window `title`, and an optional `error`,
    which will be used in case we need to re-display the dialog with an `error` message
    (for example, if the password is wrong). The rest of `__init__()` sets up some
    Tkinter variables for the password, username, and `error` string; then, it finishes
    with the customary call to `super()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The form itself is not defined in `__init__()`; instead, we need to override
    the `body()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do is make a frame and add a title label to the first row
    using a large font.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll check for an `error` string and, if there is one, display it in
    an appropriate style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''ll add the username and password fields and `pack` our frame into the
    dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Notice our use of the `show` option in the password entry, which replaces any
    typed text with the character we specify, to create a hidden text field. Also,
    note that we return the username input widget from the method. `Dialog` will focus
    whichever widget is returned here when it's displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '`Dialog` automatically supplies the OK and Cancel buttons; we''ll want to know
    which button was clicked, and if it was the OK button, retrieve the entered information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking OK calls the `apply()` method, so we can override it to set up a `result`
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '`Dialog` creates a property by default called `result` which is set to `None`.
    But now, if our user clicks OK, `result` will be a tuple containing a username
    and password. We''ll use this property to determine what was clicked and what
    was entered.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the login window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use the dialog, our application needs a method that will display the dialog
    in an infinite loop until either the user clicks Cancel or the provided credentials
    successfully authenticate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a new `database_login()` method in `Application`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We begin by setting up an empty `error` string and a `title` string to pass
    to our `LoginDialog` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we''ll start the infinite loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Inside the loop, we create a `LoginDialog`, which will block until the user
    clicks one button or the other. After the dialog returns, if `login.result` is
    `None`, the user has clicked Cancel, so we break out of the loop and exit the
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have a non-`None` `login.result`, we''ll attempt to log in with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: After extracting the `username` and `password` from the `result` tuple, we try
    to create a `SQLModel` instance with it. If the credentials fail, `psycopg2.connect`
    will raise an `OperationalError`, in which case we'll simply populate our `error`
    string and let the infinite loop iterate again.
  prefs: []
  type: TYPE_NORMAL
- en: If the data model creation succeeded, we simply break out of the loop and exit
    the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in `__init__()`, just after setting up our settings, let''s put `database_login()`
    to work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: After our call to `self.database_login()`, `Application` either has a `data_model`
    attribute (because the login succeeded) or doesn't (because the user clicked Cancel).
    If it doesn't, we'll quit the application by destroying the main window and returning
    immediately from `__init__()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, before this logic will work, we need to delete the creation of the
    `CSVModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Fixing some model incompatibilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In theory, we should be able to swap in a new model with the same method calls
    and our application object will just work, but this isn't quite the case. There
    are a few small fixes we need to make to get `Application` working with our new
    model.
  prefs: []
  type: TYPE_NORMAL
- en: DataRecordForm creation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s fix our `DataRecordForm` instantiation in `Application.__init__()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Previously, we'd pulled the `fields` argument from the static class property
    of `CSVModel`. We need to pull it from our data model instance instead, since
    the instance is setting up some values.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the open_record() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we need to fix our `open_record()` method. It takes a `rownum` currently,
    but we no longer have row numbers; we have `date`, `time`, `lab`, and `plot`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To reflect this, replace all instances of `rownum` with `rowkey`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, expand `rowkey` in the `get_record()` call, since it expects four
    positional arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Fixing the on_save() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The error handling portion of `on_save()` is fine, but after the `if errors:`
    block, we''ll start changing things:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We no longer need to extract the row number or pass it into `save_record()`,
    and we can delete the handling of `IndexError` since `SQLModel` will not raise
    that exception. We also need to rewrite the updating of `inserted_rows` and `updated_rows`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove all the code in this method after the call to `self.status.set()`, and
    replace it with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: After building the primary key tuple from `data` passed into the method, we
    use the value of `last_write` to append it to the proper list. Finally, we reset
    the record form in the case of an insert.
  prefs: []
  type: TYPE_NORMAL
- en: Creating new callbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two callbacks we want to have for our record form. When the user enters
    a `lab` and `plot` value, we want to automatically populate the correct `seed`
    value that is currently planted in that `plot`. Also, when the `date`, `time`,
    and `lab` values have been entered, and we have an existing lab check that matches,
    we should populate the name of the lab tech who did that check.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if our user prefers not to have data autofilled, we shouldn't do
    either of these things.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the `get_current_seed_sample()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: We begin by checking whether we have a record form object created, and whether
    the user wants data autofilled. If not, we exit the method. Next, we fetch the
    `plot` and `lab` from the form's current data. If we have both, we use them to
    fetch the `seed` sample value from the model and set the form's `Seed sample`
    value accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll do something similar with the lab tech value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This time, we need the `date`, `time`, and `lab` arguments to fetch the lab
    check record. Because we can't be sure if a check matching the values exists,
    we'll set `tech` to a blank string if we can't find a matching lab check.
  prefs: []
  type: TYPE_NORMAL
- en: Add these two methods to the `callbacks` dictionary and the `Application` class
    should be ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: Updating our views for the SQL backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s review the changes we need to make in our views:'
  prefs: []
  type: TYPE_NORMAL
- en: Re-arrange our fields to put all the primary keys upfront
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fix our form's `load_record()` method to work with the new key structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add triggers to our form to populate `Technician` and `Seed sample`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fix our record list to work with the new keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with our record form.
  prefs: []
  type: TYPE_NORMAL
- en: The data record form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first task we have is to move the fields around. This is really just a
    matter of cutting and pasting code and then fixing our `grid()` arguments. Place
    them in the proper key order: Date, Time, Lab, Plot. Then, leave Technician and
    Seed sample at the end of the Record Information section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c9aa7446-02f5-4cf4-b810-7b805ae2dd1b.png)'
  prefs: []
  type: TYPE_IMG
- en: The reason for this change is so that all the fields which could trigger autofilling
    of Technician or Seed sample will come before those fields. If any of them came
    after, we'd be uselessly autofilling a field the user had already filled.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of `__init__()`, let''s add our triggers to populate Technician
    and Seed sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: We're putting a trace on the key variables for lab check and plot; should any
    of them change, we'll call the appropriate callback to auto-populate the form.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `load_record()`, replace `rownum` with `rowkey` for clarity, then fix the
    label `text` so that it makes sense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The last change of all for `DataRecordForm` deals with a small usability issue.
    As we auto-populate the form, it gets more and more confusing to determine which
    field we need to focus next. We're going to address this by creating a method
    that finds and focuses the first empty field in the form.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll call it `focus_next_empty()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: In this method, we're just iterating all the inputs and checking their current
    value. When we find one returns an empty string, we focus it, then break through
    the loop so that no more are checked. We can remove any calls to focus fields
    from `DataRecordForm.reset()` and replace them with a call to this method. You
    can also add it to our application's autofill methods, `get_current_seed_sample()`
    and `get_tech_for_lab_check()`.
  prefs: []
  type: TYPE_NORMAL
- en: The record list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In `RecordList`, the `Row` column no longer contains useful information we wish
    to display.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can''t remove it, but we can hide it with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The `show` configuration option takes any or both of two values: `tree` and
    `headings`. The `tree` argument represents the `#0` column since it''s used to
    expand `tree`. The `headings` argument represents the remaining columns. By specifying
    only `headings` here, the `#0` column is hidden.'
  prefs: []
  type: TYPE_NORMAL
- en: We also need to deal with our `populate()` method, which relies heavily on `rownum`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by changing the `for` loop that populates the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: We can remove the `enumerate()` call and just deal with the row data, extracting
    the `rowkey` tuple from it by getting `Date`, `Time`, `Lab`, and `Plot`. These
    need to be cast to string, because they come out of the database as Python objects
    like `date` and `int`, and we need to match them against the keys in `inserted`
    and `updated` which are all string values (since they were pulled from our form).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do that comparison and set our row tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Now, we need to decide how to handle our row's `iid` value. The `iid` values
    must be strings; this wasn't a problem when our primary key was an integer (easily
    castable to and from a string), but our tuple must be serialized in some way that
    we can easily reverse.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple way to address this is to turn our tuple into a delimited string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Any character that isn't going to appear in the data will work fine as a delimiter;
    we've chosen to use the pipe character in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can use the string version of the key in `treeview`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The last part of this method focuses the first row for keyboard users. To focus
    the first row before, we relied on the fact that the first `iid` was always `0`.
    Now it will be some data-dependent tuple, so we'll have to retrieve the first
    `iid` before we can set the selection and focus.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this by using the `Treeview.identify_row()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The `identify_row()` method takes a row number and returns the `iid` of that
    row. Once we have that, we can pass it to `selection_set()` and `focus()`.
  prefs: []
  type: TYPE_NORMAL
- en: Our final change is to the `on_open_record()` method. Since we've used our serialized
    tuple as an `iid` value, we obviously need to translate this back to a tuple that
    can be passed back to the `on_open_record()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is as easy as calling `split()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: That fixes all our view code, and our program is ready to run!
  prefs: []
  type: TYPE_NORMAL
- en: Last changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Phew! That was quite a journey, but you're not quite done yet. As homework,
    you'll need to update your unit tests to accommodate the database and login. The
    best approach would be to mock out the database and login dialog.
  prefs: []
  type: TYPE_NORMAL
- en: There are also still some remnants of the CSV backend sitting around, such as
    the Select target… item in the file menu. You can delete those UI elements, but
    leave the backend code as it may come in handy in the near future.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about relational databases and SQL, the language
    used to work with them. You learned to model and normalize data to reduce the
    possibility of inconsistencies, and how to convert flat files into relational
    data. You learned how to work with the `psycopg2` library, and went through the
    arduous task of converting the application to use a SQL backend.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll be reaching out to the cloud. We'll need to contact
    some remote servers using different networking protocols to exchange data. You'll
    learn about the Python standard library's modules for working with HTTP and FTP,
    and use them to download and upload data.
  prefs: []
  type: TYPE_NORMAL
