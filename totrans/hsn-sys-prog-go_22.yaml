- en: Assessments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chapter 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What is the difference between application and system programming?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Application programming focuses on solving a problem for the final user, while
    system programming is about creating software used by other software.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is an API? Why are APIs so important?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An API is an interface that the software exposes to control the access to the
    resources it controls. It is a description of how other applications should communicate
    with the software.
  prefs: []
  type: TYPE_NORMAL
- en: '**Could you explain how protection rings work?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Protection rings are a system used to prevent failures and increase security.
    They arrange security in hierarchical levels with growing limitations and allow
    a mediate access to the features of the more powerful levels by using specific
    gateways.
  prefs: []
  type: TYPE_NORMAL
- en: '**Can you provide some examples of what cannot be undertaken in user space?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An application in user space cannot change its current space to kernel, cannot
    access the hard drive ignoring the filesystem, and cannot change the page tables.
  prefs: []
  type: TYPE_NORMAL
- en: '**What''s a system call?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: System calls are the API provided by the operating system to access the machine's
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: '**Which calls are used in Unix to manage a process?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The calls that Unix uses to manage a process are as follows: `fork`, `exit`,
    and `wait`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Why is POSIX useful?** The various POSIX standards define process controls,
    signals, segmentation, illegal instructions, file and directory operations, pipes,
    I/O control and the C library, shells and utilities, and real-time and multithreaded
    extensions. It is extremely useful for a developer when building applications,
    because it aids in building an application that works with different operating
    systems sharing this standard.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Is Windows POSIX-compliant?** Windows is not POSIX-compliant, but an attempt
    is being made to offer a POSIX framework, such as the Windows Linux subsystem.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '** Which filesystem is used by modern operating systems?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modern operating systems use different filesystems: Windows and macOS use their
    respective proprietary formats, NTFS and APFS, while Linux systems mainly use
    EXT4.'
  prefs: []
  type: TYPE_NORMAL
- en: '**What is an inode? What is inode** `0` **in Unix?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An inode is a filesystem data structure representing a file. It stores information
    about a file, excluding the name and data.
  prefs: []
  type: TYPE_NORMAL
- en: The inode `0` is reserved for the `/` folder.
  prefs: []
  type: TYPE_NORMAL
- en: '**What''s the difference between PID and PPID?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: PID is the unique identifier for an existing process, while PPID is the identifier
    of the parent process. When an existing process creates another, the new process
    has a PPID equal to the existing process's PID.
  prefs: []
  type: TYPE_NORMAL
- en: '**How do you terminate a process running in the background?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While a `SIGINT` signal can be sent to a foreground process by pressing *Ctrl*
    + *C*, for a background process, the signal needs to be sent with the `kill` command,
    in this case, `kill -2 PID`.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the difference between a user and a group?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A user identifies an account that can own files and processes, while a group
    is a mechanism to share permissions on a file.
  prefs: []
  type: TYPE_NORMAL
- en: '**What''s the scope of the Unix permission model?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Unix permission model enables the restriction of access to a file with
    three different levels of power: owner, group, and all other users.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Can you explain the difference between signals and exit codes?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Signals and exit codes are both methods of communication between processes,
    but whereas a signal is from any process to another, exit codes are used to communicate
    from a child to its parent.
  prefs: []
  type: TYPE_NORMAL
- en: '**What''s a swap file?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A swap file is an extension of the physical memory that is used to store pages
    that are not required in order to free up the main memory.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What''s the difference between an exported and an unexported symbol?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exported symbols can be used by other packages, whereas unexported symbols cannot.
    The first group has an identifier that starts with a capital letter, while the
    second group does not.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why are custom types important?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Custom types allow methods to be defined and interfaces to be used effectively,
    or the data structure of another type to be inherited, but getting rid of its
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the main limit of a short declaration?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Short declarations do not allow the variable type inferred by the value to be
    defined. A type casting of the value enables this limitation to be overcome.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is scope and how does it affect variable shadowing?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The scope of a variable represents its lifetime and visibility that can be package,
    function, or blocked. Shadowing is when the same identifier gets used in an inner
    scope, preventing access to the symbol that shares that identifier by an outer
    scope.
  prefs: []
  type: TYPE_NORMAL
- en: '**How can you access a method?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Methods are special types of functions that have a namespace linked to the type
    they belong to. They can be accessed as a property of an instance of their type,
    or as a property of the type itself, passing the instance as a first argument.
  prefs: []
  type: TYPE_NORMAL
- en: '**Explain the difference between a series of** `if`/`else` **statements** **and
    a** `switch` **statement**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A series of `if` and `else` statements allow the execution of a short declaration
    for each `if` statement and will execute only one of the cases, skipping the following
    declarations. A `switch` statement allows only one declaration, and can modify
    the flow using `continue` and `break` statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**In a typical use case, who is generally responsible for closing a channel?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Channels should always be closed by the sender, because that party is responsible
    for communicating that there is no more information to send. Also, sending to
    a closed channel throws a panic, while receiving from it is a non-blocking operation.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is escape analysis?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Escape analysis is an optimization process performed by the Go compiler that
    attempts to reduce the variables allocated in the heap by verifying whether they
    outlive the function where they are defined.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What''s the difference between absolute and relative paths?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An absolute path starts with the `/` (root) path, while a relative path does
    not. To obtain an absolute path from a relative one, it must be joined to the
    current working directory.
  prefs: []
  type: TYPE_NORMAL
- en: '**How do you obtain or change the current working directory?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To find out the current working directory, the `os` package offers the `Getwd` function,
    which returns the current working directory. To change the current working directory,
    the `Chdir` function must be used. It accepts both relative and absolute paths.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are the advantages and downfalls of using `ioutil.ReadAll`?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `ioutil.ReadAll` function places the entire file contents in a byte slice,
    so the size of file influences the amount of memory allocated, and then released.
    Since there is no recycling of the memory allocated this way, these slices get
    garbage-collected when they are no longer used.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why are buffers important for reading operations?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Byte buffers limit the amount of memory allocated by the reading operations,
    but they also require a certain number of read operations, each one with a little
    overhead that impacts speed and performance.
  prefs: []
  type: TYPE_NORMAL
- en: '**When should you use `ioutil.WriteFile`?** The `ioutil.WriteFile` function can
    be used if the size of the content is not too big, because the entire content
    needs to be in memory. It is also preferable to use it in short-lived applications
    and avoid it for recurrent writing operations.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Which operations are available when using a buffered reader that allows peeking?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The peeking operation allows the content of the next bytes to be checked without
    advancing the cursor of the current reader, and this enables us to have contextual
    operations, such as read word, read line, or any custom token-based operation.
  prefs: []
  type: TYPE_NORMAL
- en: '**When is it better to read content using a byte buffer?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a reading buffer is a way of lowering the memory usage of your application.
    It can be used when there's no need to have all the content at once.
  prefs: []
  type: TYPE_NORMAL
- en: '**How can buffers be used for writing? What''s the advantage of using them?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In writing operations, the application already handles the bytes that are about
    to be written, so an underlying buffer is used to optimize the number of system
    calls, only when the buffer is full, so as to avoid the addition of system call
    overheads when the data passed to the writer is not enough.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What''s a stream?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A stream is an abstraction that represents a generic flow of incoming or outgoing
    data.
  prefs: []
  type: TYPE_NORMAL
- en: '**What interfaces abstract the incoming streams?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `io.Reader` interface is an abstraction for incoming streams.
  prefs: []
  type: TYPE_NORMAL
- en: '**Which interface represents the outgoing streams?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `io.Writer` interface is an abstraction for outgoing streams.
  prefs: []
  type: TYPE_NORMAL
- en: '**When should a byte reader be used? When should a string reader be used instead?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A byte reader should be used when the raw data is a slice of bytes, while a
    string reader should be used with strings. Converting from one type of data to
    another causes a copy and is inconvenient.
  prefs: []
  type: TYPE_NORMAL
- en: '**What''s the difference between a string builder and a byte buffer?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A byte buffer can be reused and overwritten. A string builder is used to create
    a string without a copy, so it uses a byte slice and converts it to a string without
    copying, using the `unsafe` package.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why should reader and writer implementations accept an interface as input?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accepting an interface as an input means to be open to different types with
    the same behavior. This enables existing readers and writers, such as buffers
    and files, to be used.
  prefs: []
  type: TYPE_NORMAL
- en: '**How does a pipe differ from** `TeeReader`**?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A pipe connects a writer to a reader. Whatever gets written in the writer gets
    read by the reader. A `TeeReader` does the opposite, connecting a reader to a
    writer, so what gets read is also written somewhere else.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What is a Terminal, and what is a pseudo-terminal?** A terminal is an application
    that behaves like a teletype, by displaying a 2 x 2 matrix of characters. Pseudo
    terminals are applications that run under a terminal and emulate its behavior
    by being interactive.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**What should a pseudo terminal be able to do?** A pseudo terminal application
    should be able to receive input from a user, execute an action according to the
    instruction received, and display the result back to the user.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**What Go tools did we use in order to emulate a terminal?** To manage user
    input, we used a buffered scanner in standard input, which will read user input
    line by line. Each command has been implemented using the same interface. To understand
    the command invoked, we used a comparison between the first argument and the commands
    available. A writer is passed to command to print their output.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**How can my application get instructions from the standard input?** The application
    can use the standard input combined with a scanner that will return a new token
    each time it encounters a new line.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**What is the advantage of using interfaces for commands?** Using interfaces
    for commands allows us and the user of our package to expand the behavior by implementing
    their own version of the interface.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**What is the Levenshtein distance? Why can it be useful in pseudo-terminals?**
    The Levenshtein distance is the number of changes required to transform a string
    into another. It can useful for suggesting other commands to the user when they
    specify a non-existing one.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What applications are available for the current process inside a Go application?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The applications available for a process are PID (process ID), PPID (parent
    PID), UID and GID (user and group ID), and the working directory.
  prefs: []
  type: TYPE_NORMAL
- en: '**How do you create a child process?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `exec.Cmd` data structure can be used to define a child process. The process
    gets created when one of the `Run`, `Start`, `Output`, and `CombinedOutput` methods gets
    called.
  prefs: []
  type: TYPE_NORMAL
- en: '**How do you ensure that a child process survives its parent?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default in Unix systems, a child survives if the parent terminates. Additionally,
    you can change the process group and session ID of the child in order to ensure
    that it survives the parent.
  prefs: []
  type: TYPE_NORMAL
- en: '**Can you access child properties? How can they be used?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One of the biggest advantages is to access the child PID to persist it somewhere,
    such as on the disk. This will allow another instance of the application, or any
    other application, to know which is the identifier of the child and verify whether
    it's still running.
  prefs: []
  type: TYPE_NORMAL
- en: '**What''s a daemon in Linux and how are they handled?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A daemon in Linux is a process that is running in the background. In order to
    create a daemon, a process can create a fork of itself and terminate, set the
    `init` process to be the parent of the fork, set the current working directory
    to root for the fork, setting the input of the child to `null`, and use log files
    for output and error.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What''s an exit code? Who makes use of it?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The exit code is an integer value passed from a process to is parent to signal
    when the process ends. It represents the outcome of the process, and it is `0`
    if there have been no errors. The parent process can use this value to decide
    what to do next, such as running the process again if there is an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**What happens when an application panics? What exit code is returned?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If  `panic` is not recovered, the application will execute all the deferred
    functions and will exit with a status of `2`.
  prefs: []
  type: TYPE_NORMAL
- en: '**What''s the default behavior of a Go application when receiving all signals?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The default behavior of a Go application with signals is an early exit.
  prefs: []
  type: TYPE_NORMAL
- en: '**How do you intercept signals and decide how the application must behave?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The signals received can be intercepted using the `signal.Notify` method on
    a channel, specifying the type of signals that you want to handle. The values
    received by the channel can be compared to signal values, and the application
    can behave accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Can you send signals to other processes? If so, how?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is possible to send signals to another process inside a Go application. In
    order to do so, the application needs to acquire an instance of the `os.Process`
    structure using a lookup function, and then it can use the `Signal` method of
    the structure to send a signal.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are pipes and why are they important?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pipes are two streams, one of output and the other of input, connected together.
    What's written in the output is available to the input, and this facilitates the
    connection of one process output to another process input.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What''s the advantage of using communication models?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Communication models allow you to abstract the type of data handled with your
    model, making the communications between different endpoints easy.
  prefs: []
  type: TYPE_NORMAL
- en: '**What''s the difference between a TCP and a UDP connection?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: TCP is connection oriented—this makes it reliable because it verifies that the
    destination receives data correctly before sending new data. A UDP connection
    sends data continuously, without acknowledging that the destination received the
    package. This can cause package loss, but it makes the connection faster and does
    not accumulate latency.
  prefs: []
  type: TYPE_NORMAL
- en: '**Who closes the request body when sending requests?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Closing the request when making an HTTP call is the responsibility of the application.
  prefs: []
  type: TYPE_NORMAL
- en: '**Who closes the body when receiving requests in the server?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The request body is closed automatically when the connection is closed, but
    the server can close it even earlier if it so desires.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What''s the trade-off between text and binary encodings?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Text-based encodings are easier to read for a human, as well as easier to debug
    and write, but they take more space because of it. Binary encodings are difficult
    to write, read, and debug for a human, but smaller in size.
  prefs: []
  type: TYPE_NORMAL
- en: '**How does Go behave with a data structure by default when encoding?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The default behavior of Go is to use reflection in order to read the fields
    and their values.
  prefs: []
  type: TYPE_NORMAL
- en: '**How can this behavior be changed?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This behavior can be changed by implementing the marshaller interface of the
    encoding you are using, such as `json.Marshaller` for JSON.
  prefs: []
  type: TYPE_NORMAL
- en: '**How does a structure field get encoded in an XML attribute?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The struct field needs to specify the `,attr` value in its tag.
  prefs: []
  type: TYPE_NORMAL
- en: '**What operation is required to decode a** `gob` **interface value?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The data types that implement the interface need to be registered in the `gob`
    package using the `gob.Register` function.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the protocol buffer encoding?** The protocol buffer is an encoding
    protocol made by Google that uses a definition file for data structures and services.
    The file is used to generate data models, clients, and server stubs, leaving only
    the implementation of the server to the developer.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What is a thread and who is responsible for it?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A thread is a part of a process that can be assigned by a specific core or CPU.
    It carries information about the state of the application, like a process does,
    and is managed by the operating system scheduler.
  prefs: []
  type: TYPE_NORMAL
- en: '**How do goroutines differ from threads?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Goroutines are tiny in size compared to threads, with a 1 to 100 ratio, and
    they are not managed by the operating system. The Go runtime takes care of the
    scheduling of goroutines.
  prefs: []
  type: TYPE_NORMAL
- en: '**When are arguments evaluated when launching a goroutine?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All the arguments passed to the function that starts the goroutine are evaluated
    when the goroutine is created. This means that if the value of the argument changes
    before the goroutine actually gets picked up by the scheduler and starts, the
    change is not going to be reflected in the goroutine.
  prefs: []
  type: TYPE_NORMAL
- en: '**How do buffered and non-buffered channels differ?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A non-buffered channel is created by the `make` function if no capacity is specified,
    or if it's `0`. Each send operation to such a channel will block the current goroutine,
    until a receive operation is performed by another goroutine. A buffered channel
    can support a number of non-blocking send operations equal to its capacity. This
    means that if a channel has a capacity of `n`, the first `n-1` send operations
    that are not matched by any receive operation will not be blocking.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why are one-way channels useful?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They allow just a subset of operations, making clear to the user what the scope
    of the channel is. A receive-only channel does not allow data to be sent, or to
    close it, and that makes perfect sense because it is not the responsibility of
    the receiver. A send-only channel does not allow the receipt of data, but allows
    it to be sent and to close the channel, with an implicit statement that it is
    up to the sender to close the channel to signal that there is no more data.
  prefs: []
  type: TYPE_NORMAL
- en: '**What happens when operations are executed on** `nil` **or closed channels?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sending to, or receiving from, a `nil` channel blocks forever, and closing it
    creates panics. Receiving from a closed channel returns a zero value immediately,
    and `false`, while sending to a closed channel raises a panic and the same thing
    happens if we try to close it again.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are timers and tickers used for?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Timers and tickers both create a receive-only channel. Timers can be used in
    a loop with a `select` statement, instead of using `default`, in order to reduce
    the frequency of the selection and lower the CPU usage of the application when
    it is idle. Tickers are very useful for executing an operation every fixed period
    of time, while one practical usage is a rate limiter, which limits the number
    of executions over a set period of time in a certain segment of an application.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What''s a race condition?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A race condition is a situation where an application tries to execute two operations
    on the same resource at the same time, and the nature of the resource only allows
    one operation at time.
  prefs: []
  type: TYPE_NORMAL
- en: '**What happens when you try to execute read and write operations concurrently
    with a map?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When reading and writing operations on a map happen simultaneously, this causes
    a runtime error: `concurrent map writes`.
  prefs: []
  type: TYPE_NORMAL
- en: '**What''s the difference between** `Mutex` **and** `RWMutex`**?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A regular mutex allows a resource to be locked and unlocked, and each operation
    has the same priority. A read/write mutex has two types of locks, one for each
    operation (read/write). The read lock allows more than one operation at time,
    while it is exclusive. Write locks could be subject to a delay if there are many
    continuous read operations on the resource. This is known as write starvation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why are wait groups useful?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait groups are the perfect tool to synchronize with the execution of different
    goroutines. This enables a clean and elegant solution to the classic setting,
    where there are several concurrent operations, and a main goroutine has to wait
    for them to end before moving on.
  prefs: []
  type: TYPE_NORMAL
- en: '**What''s the main use of** `sync.Once`**?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sync.Once` can be used to execute a concurrent operation on one occasion.
    It can be used to close a channel once and avoid panics, for instance. Another
    use case is the lazy initialization of a variable to implement a thread-safe version
    of the singleton design pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: '**How can you use a pool?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A pool allows short-lived items to be reused. A good use case for pools is byte
    slices and byte buffers, because the pool will prevent this resource from being
    recycled by the garbage collector, while preventing the allocation of new pools.
  prefs: []
  type: TYPE_NORMAL
- en: '**What''s the advantage of using atomic operations?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a mutex for numeric variables has a lot of overhead. Atomic operations
    allow such overheads to be reduced and thread-safe operations to be executed on
    numeric variables. Its main use is for integer numbers, but, with some transformation,
    we can do the same for other types, such as Booleans and floats.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What is context in Go?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Context is a package that contains a generic interface and some auxiliary functions
    to return context instances. It is used to synchronize operations between various
    parts of the application and to carry values.
  prefs: []
  type: TYPE_NORMAL
- en: '**What''s the difference between cancellation, deadline, and timeout?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are three different types of expiration for a context—cancellation is
    an explicit call to a cancellation function by the application, deadline is when
    the context goes over a specified time, and timeout is when the context survives
    a specific duration.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are the best practices when passing values with a context?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Values passed around with context should be relative to the current scope or
    request. They should not be used as a way of passing around optional function
    parameters or variables that are essential to the application. It is also a good
    idea to use custom private types as keys, because built-in values can be overridden
    by other packages. Pointers to values are also a solution to such a problem.
  prefs: []
  type: TYPE_NORMAL
- en: '**Which standard packages already use context?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are different packages that use context. The most notable are `net/http` ,
    which uses context for requests and for server shutdown; `net`, which uses context
    for functions such as `Dial` or `Listen`; and `database/sql`, which uses the context
    as a way to cancel operations such as queries.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What is a generator? What are its responsibilities?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A generator is a tool that returns a series of values—it returns the next value
    in the series each time it is called. It's responsible for generating values in
    the sequence on demand. In Go, this can be done by using a channel to receive
    the values that are sent through by a goroutine that creates them.
  prefs: []
  type: TYPE_NORMAL
- en: '**How would you describe a pipeline?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A pipeline is a type of application flow that splits the execution into different
    stages. These stages communicate with one another by using a certain means of
    communication, such as networks, or runtime internals, such as channels.
  prefs: []
  type: TYPE_NORMAL
- en: '**What type of stage gets a channel and returns one?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An intermediate stage will receive from a receive-only channel and return another
    receive-only channel.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the difference between fan-in and fan-out?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fan-in is also known as demultiplexing, and entails gathering messages from
    different sources into one. Fan-out, or multiplexing, is the opposite—it entails
    splitting a single source of a message to more receivers.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What''s the memory representation of an interface in Go?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An interface in Go is represented by two values—the first one is the interface
    concrete type, while the second is the value for such a type.
  prefs: []
  type: TYPE_NORMAL
- en: '**What happens when an interface type is casted to another one?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since interface values need to be a concrete value, and cannot be another interface,
    a new interface is created with a different type and the same concrete value.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are** `Value`**,** `Type`**, and** `Kind` **in reflection?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `Value`, as the name suggests, represents the content of a variable; a `Type`
    represents the Go type of a variable; and `Kind` is the memory representation
    of a `Type` and refers only to built-in types.
  prefs: []
  type: TYPE_NORMAL
- en: '**What does it mean that a value is addressable?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An addressable value is a value that can be edited because it has been obtained
    by a pointer.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why are structure field tags important in Go?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Structure field tags are an easy way to add extra information about a structure
    field that is easy to read, using the reflection `Type` interface.
  prefs: []
  type: TYPE_NORMAL
- en: '**What''s the general trade-off of reflection?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reflection allows your code to deal with unknown types of data and make your
    package or application generic, but it comes with an overhead that has a performance
    cost. It also makes code more obscure and less maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: '**Could you describe a good approach when using reflection?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The best approach to reflection is the one that we find in many different parts
    of the standard library; for instance, in the `encoding` packages. They use reflection
    as a last resort, and they do so by providing interfaces for encoding and decoding
    operations. If these interfaces are satisfied by a type, the package will use
    the respective methods instead of relying on reflection.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**What is CGO?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: CGO is a powerful Go tool that handles communication between C code and Go code.
    This allows C code to be used in a Go application and to leverage the huge amount
    of existing C libraries.
  prefs: []
  type: TYPE_NORMAL
- en: '**How can you call C code from Go?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go offers a pseudo package called `C` that exposed C types, such as `C.int`,
    and some functions that will convert Go strings and bytes into `C` character arrays,
    and vice versa. The comment that comes before the import `C` package will be interpreted
    as C code, and all the functions defined in it ( be it directly, or by importing
    files), will be available in Go as functions of the `C` package.
  prefs: []
  type: TYPE_NORMAL
- en: '**How can you use Go code in C?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a Go function is preceded by a special comment, `//export`, this function
    will be available to the C code. It will also have to be defined as an external
    function in C.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are the differences in data types between Go and C?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Even if they have different data types, C and Go share most of their built-in
    numeric types. Strings in Go are a built-in immutable type, but in C, they are
    just a character array terminated by a `\0` value.
  prefs: []
  type: TYPE_NORMAL
- en: '**How can you edit Go values inside C code?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `unsafe` package, you can convert data types with the same memory
    representation in both C and Go. You need to convert the pointer to a value in
    its C counterpart, and this will allow you to edit the pointer content from the
    `C` part of the application.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the main problem associated with packed data structures?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Packed data structures save space in memory, but their fields can be unaligned,
    meaning that they are split between multiple memory zones. This means that read
    and write operations take twice as long. There is also another inconvenience—some
    of the packed fields are not directly accessible from Go.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are the main downfalls of CGO?**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Even if it is a very powerful tool, CGO has many downsides—the performance cost
    of passing from C to Go, and vice versa; the fact that the compiling time increases
    because the C compiler gets involved in the process; and that your Go code is
    reliant on your C code to work, which could be harder to maintain and debug.
  prefs: []
  type: TYPE_NORMAL
