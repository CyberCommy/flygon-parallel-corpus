- en: Introduction to the ACME Registration Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will introduce a small but fake service called the ***ACME
    registration service***. The code for this service will serve as the basis for
    most of the examples in the rest of the book. We will examine the business environment
    in which this service lives, discuss the goals for the service and the code, and
    finally, we will look at some examples of the problems that we can fix by applying
    **dependency injection** (**DI**).
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you should have enough knowledge to join the team
    as we work our way through the improvements we will make in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Goals for our system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to our system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Known issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we are learning about the system that we are going to use for the rest of
    the book, I would strongly recommend downloading the source code and running it
    in your favorite IDE.
  prefs: []
  type: TYPE_NORMAL
- en: All of the code in this chapter is available at [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch04](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch04).
  prefs: []
  type: TYPE_NORMAL
- en: Instructions on how to obtain the code and configure the sample service are
    available in the README file, found at [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/).
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code for the service in the `ch04/acme `file.
  prefs: []
  type: TYPE_NORMAL
- en: Goals for our system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have you ever tried to grow your own vegetables from seed? It's a long, slow,
    but gratifying experience. Building great code is no different. In gardening,
    it's perhaps more common to skip the first step and buy plants as seedlings from
    the nursery, and programming is much the same. Most of the time, when we join
    a project, the code already exists; sometimes it's happy and healthy, but often
    it's sick and dying.
  prefs: []
  type: TYPE_NORMAL
- en: In this situation, we are adopting a system. It works, but has a few thorns—Ok,
    maybe more than a few. With some tender loving care, we will turn this system
    into something healthy and thriving.
  prefs: []
  type: TYPE_NORMAL
- en: So, how do we define a healthy system? The system we have works; it does what
    the business needs it to do. That's enough, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'Absolutely not! We might explicitly be paid to deliver a certain amount of
    features, but we are implicitly paid to provide code that can be maintained and
    extended. Beyond considering why we are paid, let''s take a more selfish view:
    do you want your work tomorrow to be easier or harder than it is today?'
  prefs: []
  type: TYPE_NORMAL
- en: 'A healthy code base has the following key features:'
  prefs: []
  type: TYPE_NORMAL
- en: High readability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High testability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Low coupling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have talked about or alluded to all of these asks in part 1, but their importance
    means that we will go over them one more time.
  prefs: []
  type: TYPE_NORMAL
- en: High readability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Simply put, high readability means being able to read the code and understand
    it. Code that is not readable will slow you down and could lead to mistakes, where
    you assume it does one thing but in fact it does something else.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example, shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the code has a problem with its naming. Short variable names
    seem like a win; less typing means less work, right? In the short term, yes, but
    in the long run, they are hard to understand. You are forced to read the code
    to determine what the variable means and then re-read the code within that context,
    whereas a good name would have saved us from the first step. This does not indicate
    that super-long names are right either; they also add to the mental burden and
    waste screen real estate. A good variable is typically one word, with a commonly
    understood meaning or purpose.
  prefs: []
  type: TYPE_NORMAL
- en: There are two situations in which the aforementioned principles should not be
    followed. The first is methods. Perhaps it's because of my time using C++ and
    Java and the lack of a `this` operator in Go, but I find short method receivers
    to be useful, probably because of the fact that they are consistent throughout
    the struct, and only the short variable differentiates them from all the others.
  prefs: []
  type: TYPE_NORMAL
- en: The second situation is when we are working with test names. Tests are essentially
    mini stories; in this case, long names are often entirely appropriate. Comments
    would work too, but less effectively, as the test runner outputs the test's name
    when it fails and not the comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update the preceding example with these ideas in mind and see if it''s
    any better, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For more on readability, flip back to the *Optimizing for humans *section in
    [Chapter 3](26893ac5-a588-4954-943e-0eaf690feb34.xhtml), *Coding for User Experience*.
  prefs: []
  type: TYPE_NORMAL
- en: High testability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Writing automated tests can feel like *extra work*, something that takes time
    away from our real purpose of writing features. In fact, the primary goal of automated
    tests is to ensure that code performs as expected, and continues to do so despite
    any changes or additions we might make to the code base as a whole. Automated
    tests do, however, have a cost: you have to write and maintain them. Therefore,
    if our code is easy to test, we will be less inclined to skimp on the tests and
    rush on to that exciting next feature.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: So what's wrong with the example? The simplest answer is that it knows too much,
    or if I was being more selfish, it makes me know too much.
  prefs: []
  type: TYPE_NORMAL
- en: 'It contains boundary-layer (HTTP and database) logic, and it also contains
    business logic. It is rather long, meaning that I have to keep more context in
    my head. It''s basically one massive violation of the **single responsibility
    principle** (**SRP**). There are many reasons it could change. The input format
    could change. The database format could change. The business rules could change.
    Any such change would mean that every test for this code would likely also need
    to change. Let''s look at what a test for the preceding code might look like,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the test is verbose and unwieldy. Perhaps worst of all, any
    other tests for this method will involve copying this test and making minor changes.
    This sounds effective, but there are two issues. The small differences will likely
    be hard to spot among all this boilerplate code, and any change to the feature
    we are testing will need to be made to all these tests as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'While there are many ways to fix the testability of our example, perhaps the
    simplest option is to separate the different concerns and then do the bulk of
    our testing one method at a time, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For more on what unit testing can do for you, flip back to the *A security blanket
    named unit tests* section in [Chapter 3](26893ac5-a588-4954-943e-0eaf690feb34.xhtml),
    *Coding for User Experience*.
  prefs: []
  type: TYPE_NORMAL
- en: Low coupling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Coupling is a measure of how an object or package relates to others. An object
    is considered to have high coupling if changes to it will likely result in changes
    to other objects, or vice versa. Conversely, when an object has low coupling,
    it is independent of other objects or packages. In Go, low coupling is best achieved
    through implicit interfaces and stable and minimal exported APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Low coupling is desirable as it leads to code where changes are localized.
    In the following example, by using an implicit interface to define our requirements
    we are able to insulate ourselves from changes to our dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a89adf8d-2d89-403c-85e4-14f073fe2245.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the preceding example, we no longer depend on the FileManager
    Package, and this helps us in other ways. This lack of dependence also means that
    we have less context to remember when reading the code and fewer dependencies
    when writing our tests.
  prefs: []
  type: TYPE_NORMAL
- en: For more on how to achieve low coupling, flip back to the SOLID principles covered
    in [Chapter 2](53a15217-38a7-4622-9242-a57fe46335ec.xhtml), *SOLID Design Principles
    for Go*.
  prefs: []
  type: TYPE_NORMAL
- en: Final thoughts on goals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you might be seeing a pattern. All of these goals will lead to code
    that is easy to read, understand, test, and extend—that is to say, code that is
    maintainable. While these may seem like selfish or perfectionist goals, I would
    argue that it is imperative for the business in the long term. In the short term,
    delivering value to the users, typically in the form of features, is essential.
    But when this is done poorly, the rate at which features can be added, the number
    of programmers required to add features, and the number of bugs that are introduced
    because of changes will all increase and cost the business more than the cost
    of developing good code.
  prefs: []
  type: TYPE_NORMAL
- en: So now that we have defined the goals that we have for our service, let's take
    a look at its current state.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to our system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the project! So what do you need to know to join the team? As with
    any project, the first thing you want to know is what it does, its users, and
    the business environment in which it is deployed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The system we are working on is an HTTP-based event registration service. It
    is designed to be called by our web application or native mobile applications.
    The following diagram shows how it fits into our network:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f6f650d4-a5f0-4ddf-8df7-9eb76718354a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Currently, there are three endpoints, listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Register**: This will create a new registration record'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Get**: This will return the full details of an existing registration record'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**List**: This will return a list of all the registrations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All request and response payloads are in JSON. The data is stored in a MySQL
    database.
  prefs: []
  type: TYPE_NORMAL
- en: We also have an upstream currency conversion service—which we call during registration—to
    convert the registration price of 100 euros to the requested currency of the user.
  prefs: []
  type: TYPE_NORMAL
- en: If you wish to run the service or the tests locally, please refer to the `ch04/README.md`
    file for instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Software architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Conceptually, our code has three layers, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b9bd6944-d7c7-40ee-b32d-b3ad0dfe40ce.png)'
  prefs: []
  type: TYPE_IMG
- en: 'These layers are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'REST: This package accepts the HTTP requests and converts them into function
    calls in the business logic. It then converts the business logic response back
    into HTTP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Business Logic: This is where the magic happens. This layer uses the external
    service and data layer to perform the business functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'External Services and Data: This layer consists of code that accesses the database
    and the upstream services that provides the currency exchange rates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I used the word *conceptually* at the beginning of this section because our
    import graph shows a slightly different story:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c796c74-08f7-49c5-acce-06f2aca8863b.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we have a quasi-fourth layer with the config and logging packages,
    and what's worse, everything seems to depend on them. This is likely going to
    cause us problems somewhere down the road.
  prefs: []
  type: TYPE_NORMAL
- en: There is one less obvious problem that is shown here. See the link between the
    rest and data packages? This indicates that our HTTP layer depends on the data
    layer. This is risky because they have different life cycles and different reasons
    to change. We will look at this and some other nasty surprises in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Known issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every system has its skeletons, parts of the code we are not proud of. Sometimes,
    they are parts of the code that we would have done better if we'd just had more
    time. This project is no different. Let's examine the issues that we currently
    know about.
  prefs: []
  type: TYPE_NORMAL
- en: Testability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Despite being a small and working service, we have quite a few issues, perhaps
    the most egregious of which is its difficulty to test. Now, we don''t want to
    start introducing test-induced damage, but we do want to have a system that we
    are confident in. To achieve this, we are going to need to reduce the complexity
    and verbosity of the tests. Take a look at the following test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This test is for our most straightforward endpoint, `Get`. Ask yourself, how
    could this test break? What changes, technical or business-related, would cause
    this test to need to be updated? What parts of the system must be working correctly
    for this test to pass?
  prefs: []
  type: TYPE_NORMAL
- en: 'Some potential answers to these questions include following:'
  prefs: []
  type: TYPE_NORMAL
- en: If the URL path changed, this test would break
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the output format changed, this test would break
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `config` file wasn't configured correctly, this test would break
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the database wasn't working, this test would break
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the record ID 1 were missing from the database, this test would break
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the business logic layer had a bug, this test would break
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the database layer had a bug, this test would break
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This list is rather nasty for a simple endpoint. The fact that this test can
    break in so many ways means it's a brittle test. Brittle tests are exhausting
    to maintain and often exhausting to write as well.
  prefs: []
  type: TYPE_NORMAL
- en: Duplication of effort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s examine the test for the `Get` endpoint in the business layer, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This test is almost the same as the one in the previous section. Perhaps this
    is logical, given that it's the same endpoint. But let's take a selfish view—what
    does this test give us, other than better unit test coverage, that the previous
    one did not?
  prefs: []
  type: TYPE_NORMAL
- en: Nothing. Because the previous test was effectively an integration test, it tested
    the entire stack. This test is also an integration test, but one layer down. Because
    it tests code that was tested by the previous example, we have performed double
    the work, have double the amount of tests to maintain, and have gained nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Lack of isolation in tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The lack of isolation shown in our preceding code is a symptom of high coupling
    between the layers. In the following section, we will be applying DI and the **dependency
    inversion principle** (**DIP**) to fix this.
  prefs: []
  type: TYPE_NORMAL
- en: High coupling between the data and REST packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our `REST` package is using the `Person` struct defined in the `data` package.
    On the surface, this makes some sense. Less code means less work to write and
    maintain that code; however, this means that the output format and the data format
    are tied to each other. Consider what happens if we start storing private information
    relating to the customer, such as a password or IP address. This information might
    be necessary for some functions, but it is very unlikely that it should need to
    be published via the `Get` or `List` endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: There is another consideration that we should bear in mind. As the volume of
    data that is stored or the amount of usage grows, it might be necessary to change
    the format of the data. Any such change to this struct would break the API contract
    and, therefore, our users.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the most significant risk here is simply human error; if you are working
    on the `data` package, you may not remember that the `REST` package uses that
    struct, or how. Let's say that we added the ability for users to log in to our
    system. The most straightforward implementation of this would be to add a password
    field to the database. What happens if our `Get` endpoint was building its output
    as shown in the following code?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Our `Get` endpoint payload would now include the password. Whoops!
  prefs: []
  type: TYPE_NORMAL
- en: This issue is an SRP violation, and the fix for this is to ensure that these
    two use cases are decoupled and allowed to evolve separately.
  prefs: []
  type: TYPE_NORMAL
- en: High coupling with the config package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in our dependency graph, just about everything depends on the `config`
    package. The primary cause of this is code that directly references a public global
    variable to configure itself. The first issue with this is how it affects the
    tests. All tests now pretty much make sure that the config global has been properly
    initialized before being run. Because all of the tests are using the same global
    variable, we are forced to choose between not changing the config, which hampers
    our ability to test, or running the tests in serial, which wastes our time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we are starting our REST server and passing it the address (host
    and port) to bind to. If we decided that we wanted to start multiple servers to
    test different things in isolation, then we would have to change the value stored
    in `config.App.Address`. However, by doing so in one test, we could accidentally
    influence a different test.
  prefs: []
  type: TYPE_NORMAL
- en: The second issue doesn't appear as often, but this coupling also means that
    this code cannot be easily used by other projects, packages, or use cases beyond
    its original intent.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final issue is perhaps the most annoying: you cannot use custom data types,
    defined outside of the `Config` package, in your config as a result of a circular
    dependency issue.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Say that your config included the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this case, any attempt to use the config package in the same package as our
    `Currency` type would be prevented.
  prefs: []
  type: TYPE_NORMAL
- en: Downstream currency service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The exchange package makes HTTP calls to an external service for exchange rates.
    Currently, when the tests are run, it will make calls to that service. This means
    that our tests have the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: They require an internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are dependent on the downstream service being accessible and working properly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They require proper credentials and quotas from the downstream service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these factors are either out of our control or otherwise wholly unrelated
    to our service. If we take the perspective that the reliability of our tests is
    a measure of the quality of our work, then our quality is now dependent on things
    we cannot control. This is far from ideal.
  prefs: []
  type: TYPE_NORMAL
- en: We could create a fake currency service and change our config to point to that,
    and when testing the exchange package, I would likely do just that. But having
    to do this in other places is annoying and prone to error.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced a small service that is in pretty rough shape.
    We are going to improve this service with a series of refactorings as we explore
    the many DI techniques. In the following chapters, we will tackle the problems
    we have outlined in this chapter by applying the different DI techniques available
    in Go.
  prefs: []
  type: TYPE_NORMAL
- en: For each different technique, keep in mind the code smells, the SOLID principles,
    the code UX, and all the other ideas we discussed in part 1\. Also, remember to
    bring along your inner skeptic.
  prefs: []
  type: TYPE_NORMAL
- en: Always ask yourself, what does this technique achieve? How does this technique
    make the code better/worse? How could you apply this technique to improve other
    code that belongs to you?
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which of the goals that are defined for our service is most important to you
    personally?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the issues outlined seem to be the most urgent or important?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
