- en: Chapter 6. Adding Friendship Capabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 5](part0040.xhtml#aid-164MG1 "Chapter 5. Managing Users"), *Managing
    Users*, we implemented the user registration and login system. We now have user
    information in our database and we can continue with one of the most important
    characteristics of social networks—friendship. In this chapter, we will add a
    logic for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Finding friends
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Marking users as friends
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying the linked users on the **Profile** page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding friends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of finding friends involves a series of changes in our current codebase.
    The following sections will guide us through the searching and displaying of friend
    profiles. We will make a couple of improvements in our REST API and define a new
    controller and model.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the search page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have pages for registration, login, and profile management. We will
    add one more link in our navigation—`Find friends`. In order to do this, we have
    to update the `frontend/tpl/navigation.html` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The link that we added at the end will forward the user to a new route. As
    with the other pages, our router will catch the URL change and fire a handler.
    Here is a little update of the `app.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The adding of new friends should not be possible if the user is not authenticated.
    We will apply a simple check here in the frontend, but we will protect the API
    calls too. A new `FindFriends` controller has to be created. The role of this
    controller is to show a form with an input field and a button. The user submits
    the form, we query the database, and we later display the users that match the
    entered string. Here is how the controller begins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We kept the same `Navigation` and `Footer` components. There are several variables
    with their respective default values. The `loading` keyword will be used as a
    flag indicating that we are making a request to the API. The fetching of friends
    that match certain criteria may be a complex operation. So, it will be a good
    practice to show the user that we are working on his/her query. The `message`
    property will be used either to display confirmation that everything went okay
    or to report an error. The last two variables keep the data. The `searchFor` variable
    will host the string entered by the user and `foundFriends` will host the users
    returned by the backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check what we need as the HTML markup. The `frontend/tpl/find-friends.html`
    file contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `header` and the `navigation` sections stay untouched. We have a nicely
    placed title at the top followed by the form that we mentioned. If the `loading`
    flag has `true` as a value, we display the **Loading. Please wait.** message.
    If we are not in the process of querying the backend, then we show the input field
    and the button. The following screenshot demonstrates how this looks in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the search page](img/image00178.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The next part of the template renders the users sent by the backend. It shows
    their name and a **Add as a friend** button. We will see a screenshot of this
    view in the pages that follow.
  prefs: []
  type: TYPE_NORMAL
- en: The last part of the HTML markup is for the conditional displaying of a message.
    If we set a value to the `message` variable, then Ractive.js reveals the `div`
    element and makes our text visible.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have the user interface that will accept the user's input. Now, we need to
    communicate with the backend and retrieve users matching the value of the form's
    field. In our system, we make requests to the API through models.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s create a new `frontend/js/models/Friends.js` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The endpoint of the `friendship` functionality will be `/api/friends`. To search
    among users, we append `/find` to the URL. We are going to make a `POST` request
    with the value of the `searchFor` variable. The code that handles the result again
    uses the `lib/Ajax` module, and if everything is okay, it fires the specified
    callback.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update the controller that calls the newly created model and its `find`
    function. At the top of the `controllers/FindFriends.js` file, we will add a `require`
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `render` handler of the controller, we will place the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `find` event is fired by the button in our form. Once we register the button''s
    click, we display the `loading` string and clear any previously shown message.
    We get the value of the input field and ask the model for matching users. If there
    are any such potential friends, we render them by setting a value to the `foundFriends`
    variable. If not, we display a message saying that there are no users who match
    the criteria. Once we finish with the API method implementation, the screen will
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing the model](img/image00179.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Fetching friends from the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The changes that we need to make are in `backend/API.js`. We need to add a
    couple of new routes. However, before proceeding with the querying of users, we
    will add a helper function to fetch the current user''s profile. We will keep
    the name and e-mail of the current user in a `session` variable, but that''s not
    enough, because we want to display more user information. So, the following function
    fetches the complete profile from the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We use the e-mail of the user as a criterion for the request. The object containing
    the profile's data is returned as an argument of the callback.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have all the information about the current user, we can continue implementing
    the user''s search. The route that should answer such queries is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The first `if` clause guarantees that this route is accessible only to the
    registered and logged in users. This method accepts only the `POST` requests.
    The rest fetches the `searchFor` variable and calls the `findFriends` function,
    which can be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The users in our system have their names split into two variables—`firstName`
    and `lastName`. We cannot be sure as to which one the user may be referring to
    when they type in the search form's field. So, we will search in the database
    of both properties. We will also use a regular expression to make sure that our
    search is not case-sensitive.
  prefs: []
  type: TYPE_NORMAL
- en: 'The MongoDB database provides a syntax to perform complex queries. In our case,
    we want to fetch the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The users whose first or last names match the criteria sent by the client side.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The users who are different from the already added friends of the current user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The users who are different from the current user. We don't want to offer the
    friendship of the user with their own profile.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `$nin` variable means *value not in the provided array*. We will exclude
    the e-mail address of the current user. A little detail that is worth a mention
    is that MongoDB stores the IDs of the users in a 12-byte BSON type. They are not
    in plain text. So, we need to use a `ObjectID` function before sending the query.
    The method is accessible via the same `mongodb` module—`var ObjectId = require('mongodb').ObjectID`.
  prefs: []
  type: TYPE_NORMAL
- en: When the database driver returns the records that fulfill our criteria, we filter
    the information and respond with a proper JSON file. We will not send the entire
    profiles of the users, because we are not going to use all the data. The names
    and IDs are enough.
  prefs: []
  type: TYPE_NORMAL
- en: Adding that new route to the API will make friend searching work. Now, let's
    add logic that attaches profiles to the current user.
  prefs: []
  type: TYPE_NORMAL
- en: Marking users as friends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we check the HTML template of our new page, we will see that every rendered
    user has a button that dispatches an `add` event. Let''s handle this in our controller
    and run a function in our model, which is similar to the process of finding friends:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We use the same technique with the `loading` flag. The model's method that we
    will cover in the following code accepts the `id` value of the user and reports
    if the linking is successful. We need to clear the `foundFriends` array. Otherwise,
    the current user may click on the same profile twice. The other option is to remove
    only the clicked item, but this involves more code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The addition in `models/Friends.js` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The only difference between the `add` and `find` methods is that in the first
    one, we sent `searchFor` and in the second one, we sent the `id` parameter. The
    error handling and result responding is the same. Of course, the endpoints are
    also tweaked.
  prefs: []
  type: TYPE_NORMAL
- en: 'We show profiles, the user clicks on some of them, and our model fires a `POST`
    request to the backend. It is time to implement the API route that marks users
    as friends. To do this, we will update the current user''s profile by adding a
    new array called `friends`, which contains references to friends'' profiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding method is again protected. We require an authenticated user and
    a `POST` request to be made. After fetching the ID of the friend, we use the `$push`
    operator to create (if it doesn't exist) and fill the `friends` array. The only
    job of the `done` function is to send a response to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Our next step in this chapter is to show the added friends on the **Profile**
    page of the user.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the linked users on the Profile page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Again, we''ll start by updating our templates. In the previous chapter, we
    created `frontend/tpl/profile.html`. It contains a form that we use for profile
    updates. Let''s add the following code after it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If the Ractive component has a `friends` property, then we will render a list
    of users. The page will display the name of the users and it will look like the
    next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying the linked users on the Profile page](img/image00180.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The controller that renders the page should also be updated. We should use
    the same `models/Friends` model that was developed in the previous sections. This
    is why we need to add `var Friends = require(''../models/Friends'');` at the top.
    Three other lines of code will make the fetching of records work. We will add
    them in the `onrender` handler of the controller as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Another small addition that we have to make in the controller is defining a
    default value of the `friends` variable, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we are not going to update the model. We will use the default `fetch`
    method that sends a `GET` request to the `/api/friends` endpoint. The only addition
    that needs to be made is in the `backend/API.js` file. We need a route that finds
    the friends of the current user and returns them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is the second place that we used the `getCurrentUser` helper function.
    We do not have the profiles of the users. So, we need to make one additional request
    to the MongoDB server. The `$in` operator helps us in this case. Again, we need
    to convert the IDs to the proper format before sending them along with the query.
    In the end, before responding to the browser, we delete sensitive information,
    such as the ID, password, and e-mail. The frontend receives a nice array with
    all the friends of the currently logged in user.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we made the creating of links between users possible. We reinforced
    our knowledge about frontend controllers and models. We extended the project's
    API with a couple of new methods and performed some complex database queries.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to upload content with Node.js. Like
    other popular social networks, the posted information will be shown as a feed
    to the users.
  prefs: []
  type: TYPE_NORMAL
