- en: Appendix 1. CSS Selector Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back at the beginning of 2014 I was having a *debate* (I used air-quotes there
    people) with some fellow developers about the irrelevance, or not, of worrying
    about CSS selector speed.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever exchanging theories/evidence about the relative speed of CSS selectors,
    developers often reference *Steve Souders* ([http://stevesouders.com/](http://stevesouders.com/))
    work on CSS selectors from 2009\. It's used to validate claims such as *attribute
    selectors are slow* or *pseudo selectors are slow*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the last few years, I''ve felt these kinds of things just weren''t worth
    worrying about. The sound-bite I have been wheeling out for years is:'
  prefs: []
  type: TYPE_NORMAL
- en: '*With CSS, architecture is outside the braces; performance is inside*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: But besides referencing *Nicole Sullivan's later post on Performance Calendar* ([http://calendar.perfplanet.com/2011/css-selector-performance-has-changed-for-the-better/](http://calendar.perfplanet.com/2011/css-selector-performance-has-changed-for-the-better/))
    to back up my conviction that the selectors used don't really matter, I had never
    actually tested the theory.
  prefs: []
  type: TYPE_NORMAL
- en: To try and address this, I attempted to produce some tests of my own that would
    settle the argument. At the least, I believed it would prompt someone with more
    knowledge/evidence to provide further data.
  prefs: []
  type: TYPE_NORMAL
- en: Testing selector speed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Steve Souders'' aforementioned tests use JavaScript’s `new Date()`. However,
    nowadays, modern browsers (iOS/Safari were a notable exception at the time of
    testing) support the *Navigation Timing API* ([https://www.w3.org/TR/navigation-timing/](https://www.w3.org/TR/navigation-timing/))
    which gives us a more accurate measure we can use. For the tests, I implemented
    it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This lets us limit the timing of the tests between the point all assets have
    been received (`responseEnd`) and the point the page is rendered (`loadEventEnd`).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, I set up a very simple test. 20 different pages, all with an identical,
    enormous DOM, made up of 1000 identical chunks of this markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '20 different CSS selection methods were tested to colour the inner most nodes
    red. Each page differed only in the rule applied to select the inner most node
    within the blocks. Here were the different selectors tested and a link to the
    the test page for that selector:'
  prefs: []
  type: TYPE_NORMAL
- en: Data attribute: [https://benfrain.com/selector-test/01.html](https://benfrain.com/selector-test/01.html)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Data attribute (qualified): [https://benfrain.com/selector-test/02.html](https://benfrain.com/selector-test/02.html)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Data attribute (unqualified but with value): [https://benfrain.com/selector-test/03.html](https://benfrain.com/selector-test/03.html)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Data attribute (qualified with value): [https://benfrain.com/selector-test/04.html](https://benfrain.com/selector-test/04.html)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Multiple data attributes (qualified with values): [https://benfrain.com/selector-test/05.html](https://benfrain.com/selector-test/05.html)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Solo pseudo selector (e.g. `:after`): [https://benfrain.com/selector-test/06.html](https://benfrain.com/selector-test/06.html)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Combined classes (e.g. `class1.class2`): [https://benfrain.com/selector-test/07.html](https://benfrain.com/selector-test/07.html)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Multiple classes: [https://benfrain.com/selector-test/08.html](https://benfrain.com/selector-test/08.html)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Multiple classes with child selector: [https://benfrain.com/selector-test/09.html](https://benfrain.com/selector-test/09.html)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Partial attribute matching (e.g. `[class<sup>ˆ=</sup>“wrap”]`): [https://benfrain.com/selector-test/10.html](https://benfrain.com/selector-test/10.html)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: nth-child selector: [https://benfrain.com/selector-test/11.html](https://benfrain.com/selector-test/11.html)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: nth-child selector followed by another nth-child selector: [https://benfrain.com/selector-test/12.html](https://benfrain.com/selector-test/12.html)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insanity selection (all selections qualified, every class used e.g. `div.wrapper``>
    div.tagDiv > div.tagDiv.layer2 > ul.tagUL > li.tagLi > b.tagB > a.TagA.link`): [https://benfrain.com/selector-test/13.html](https://benfrain.com/selector-test/13.html)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Slight insanity selection (e.g. `.tagLi .tagB a.TagA.link`): [https://benfrain.com/selector-test/14.html](https://benfrain.com/selector-test/14.html)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Universal selector: [https://benfrain.com/selector-test/15.html](https://benfrain.com/selector-test/15.html)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Element single: [https://benfrain.com/selector-test/16.html](https://benfrain.com/selector-test/16.html)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Element double: [https://benfrain.com/selector-test/17.html](https://benfrain.com/selector-test/17.html)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Element treble: [https://benfrain.com/selector-test/18.html](https://benfrain.com/selector-test/18.html)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Element treble with pseudo: [https://benfrain.com/selector-test/19.html](https://benfrain.com/selector-test/19.html)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Single class: [https://benfrain.com/selector-test/20.html](https://benfrain.com/selector-test/20.html)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The test was run 5 times on each browser and the result averaged across the
    5 results. The browsers tested:'
  prefs: []
  type: TYPE_NORMAL
- en: Chrome 34.0.1838.2 dev
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firefox 29.0a2 Aurora
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opera 19.0.1326.63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internet Explorer 9.0.8112.16421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android 4.2 (7" tablet)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A previous version of Internet Explorer (rather than the latest Internet Explorer
    available to me) was used to shed some light on how a *non evergreen *browser
    performed. All the other browsers tested received regular updates so I wanted
    to be sure that there wasn't a considerable difference in the way modern regularly
    updating browsers deal with CSS selectors and how slightly older ones do.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Want to try the same tests out for yourself? Go and grab the files from this
    GitHub link: [https://github.com/benfrain/css-performance-tests](https://github.com/benfrain/css-performance-tests).
    Just open each page in your browser of choice (remember the browser must support
    the Network Timing API to alert a response). Also be aware that when I performed
    the test I discarded the first couple of results as they tended to be unusually
    high in some browsers.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When considering the results, don't consider one browser against another. That
    is not the purpose of the tests. The purpose is purely to try and evaluate the
    comparative difference in selection speed between the different selectors employed
    on each browser. For example, is selector 3 any faster than selector 7 on any
    browser? Therefore, when looking at the table, it makes more sense to look down
    the columns than across the rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the results. All times in milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Test** | **Chrome 34** | **Firefox 29** | **Opera 19** | **IE 19** | **Android
    4** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 56.8 | 125.4 | 63.6 | 152.6 | 1455.2 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 55.4 | 128.4 | 61.4 | 141 | 1404.6 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 55 | 125.6 | 61.8 | 152.4 | 1363.4 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 54.8 | 129 | 63.2 | 147.4 | 1421.2 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 55.4 | 124.4 | 63.2 | 147.4 | 1411.2 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 60.6 | 138 | 58.4 | 162 | 1500.4 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | 51.2 | 126.6 | 56.8 | 147.8 | 1453.8 |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | 48.8 | 127.4 | 56.2 | 150.2 | 1398.8 |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | 48.8 | 127.4 | 55.8 | 154.6 | 1348.4 |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | 52.2 | 129.4 | 58 | 172 | 1420.2 |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | 49 | 127.4 | 56.6 | 148.4 | 1352 |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | 50.6 | 127.2 | 58.4 | 146.2 | 1377.6 |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | 64.6 | 129.2 | 72.4 | 152.8 | 1461.2 |'
  prefs: []
  type: TYPE_TB
- en: '| 14 | 50.2 | 129.8 | 54.8 | 154.6 | 1381.2 |'
  prefs: []
  type: TYPE_TB
- en: '| 15 | 50 | 126.2 | 56.8 | 154.8 | 1351.6 |'
  prefs: []
  type: TYPE_TB
- en: '| 16 | 49.2 | 127.6 | 56 | 149.2 | 1379.2 |'
  prefs: []
  type: TYPE_TB
- en: '| 17 | 50.4 | 132.4 | 55 | 157.6 | 1386 |'
  prefs: []
  type: TYPE_TB
- en: '| 18 | 49.2 | 128.8 | 58.6 | 154.2 | 1380.6 |'
  prefs: []
  type: TYPE_TB
- en: '| 19 | 48.6 | 132.4 | 54.8 | 148.4 | 1349.6 |'
  prefs: []
  type: TYPE_TB
- en: '| 20 | 50.4 | 128 | 55 | 149.8 | 1393.8 |'
  prefs: []
  type: TYPE_TB
- en: '| Biggest Diff. | 16 | 13.6 | 17.6 | 31 | 152 |'
  prefs: []
  type: TYPE_TB
- en: '| Lowest | 13 | 6 | 13 | 10 | 6 |'
  prefs: []
  type: TYPE_TB
- en: The difference between fastest and slowest selector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Biggest Diff.** row shows the difference in milliseconds between the fastest
    and slowest selector. Of the desktop browsers, IE9 stands out as having the biggest
    difference between fastest and slowest selectors at **31** ms. The others are
    all around half of that figure. However, interestingly there .
  prefs: []
  type: TYPE_NORMAL
- en: The slowest selector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I was interested to note that the slowest selector type differed from browser
    to browser. Both Opera and Chrome found the *insanity* selector (test 13) the
    hardest to match (the similarity between Opera and Chrome here perhaps not surprising
    given they share the *blink* ([http://www.chromium.org/blink](http://www.chromium.org/blink))
    engine), while Firefox struggled with a single pseudo selector (*test 6* ([https://benfrain.com/selector-test/06.html](https://benfrain.com/selector-test/06.html))),
    as did the Android 4.2 device (a Tesco hudl 7" tablet). Internet Explorer 9's
    Achilles heel was the partial attribute selector (*test 10* ([https://benfrain.com/selector-test/10.html](https://benfrain.com/selector-test/10.html))).
  prefs: []
  type: TYPE_NORMAL
- en: Good CSS architecture practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One thing we can be clear on is that using a flat hierarchy of class-based selectors,
    as is the case with ECSS, provides selectors that are as fast as any others.
  prefs: []
  type: TYPE_NORMAL
- en: What does this mean?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For me, it has confirmed my believe that it is absolute folly to worry about
    the type of selector used. Second guessing a selector engine is pointless as the
    manner selector engines work through selectors clearly differs. Further more,
    the difference between fastest and slowest selectors isn't massive, even on a
    ludicrous DOM size like this. As we say in the North of England, *There are bigger
    fish to fry*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since documenting my original results, Benjamin Poulain, a WebKit Engineer
    got in touch to point out his concerns with the methodology used. His comments
    were very interesting and some of the information he related is quoted verbatim
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '*By choosing to measure performance through the loading, you are measuring
    plenty of much much bigger things than CSS, CSS Performance is only a small part
    of loading a page.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If I take the time profile of `[class^="wrap"]` for example (taken on an old
    WebKit so that it is somewhat similar to Chrome), I see:'
  prefs: []
  type: TYPE_NORMAL
- en: ~10% of the time is spent in the rasterizer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ~21% of the time is spent on the first layout.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ~48% of the time is spent in the parser and DOM tree creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ~8% is spent on style resolution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ~5% is spent on collecting the style – this is what we should be testing and
    what should take most of the time. (The remaining time is spread over many many
    little functions).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the test above, let say we have a baseline of 100 ms with the fastest selector.
    Of that, 5 ms would be spent collecting style. If a second selector is 3 times
    slower, that would appear as 110 ms in total. The test should report a 300% difference
    but instead it only shows 10%.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, I responded that whilst I understood what Benjamin was pointing
    out, my test was only supposed to illustrate that the same page, with all other
    things being equal, renders largely the same regardless of the selector used.
    Benjamin took the time to reply with further detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '*I completely agree it is useless to optimize selectors upfront, but for completely
    different reasons:*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '*It is practically impossible to predict the final performance impact of a
    given selector by just examining the selectors. In the engine, selectors are reordered,
    split, collected and compiled. To know the final performance of a given selectors,
    you would have to know in which bucket the selector was collected, how it is compiled,
    and finally what does the DOM tree looks like.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '*All of that is very different between the various engines, making the whole
    process even less predictable.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '*The second argument I have against web developers optimizing selectors is
    that they will likely make things worse. The amount of misinformation about selectors
    is larger than correct cross-browser information. The chance of someone doing
    the right thing is pretty low.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '*In practice, people discover performance problems with CSS and start removing
    rules one by one until the problem go away. I think that is the right way to go
    about this, it is easy and will lead to correct outcome.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Cause and effect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point I felt vindicated that the CSS selector used was almost entirely
    irrelevant. However, I did wonder what else we could gleam from the tests.
  prefs: []
  type: TYPE_NORMAL
- en: If the number of DOM elements on the page was halved, as you might expect, the
    speed to complete any of the tests dropped commensurately. But getting rid of
    large parts of the DOM isn't always a possibility in the real world. This made
    me wonder what difference the amount of unused styles in the CSS would have on
    the results.
  prefs: []
  type: TYPE_NORMAL
- en: What difference does style bloat make?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Another test* ([https://benfrain.com/selector-test/2-01.html](https://benfrain.com/selector-test/2-01.html)):
    I grabbed a big fat style sheet that had absolutely no relevance to the DOM tree.
    It was about 3000 lines of CSS. All these irrelevant styles were inserted before
    a final rule that would select our inner `a.link` node and make it red. I did
    the same averaging of the results across 5 runs on each browser.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Half those rules were then cut out and the test repeated* ([https://benfrain.com/selector-test/2-02.html](https://benfrain.com/selector-test/2-02.html))
    to give a comparison. Here are the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Test** | **Chrome 34** | **Firefox 29** | **Opera 19** | **IE 19** | **Android
    4** |'
  prefs: []
  type: TYPE_TB
- en: '| Full bloat | 64.4 | 237.6 | 74.2 | 436.8 | 1714.6 |'
  prefs: []
  type: TYPE_TB
- en: '| Half bloat | 51.6 | 142.8 | 65.4 | 358.6 | 1412.4 |'
  prefs: []
  type: TYPE_TB
- en: Rules diet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This provides some interesting figures. For example, Firefox was 1.7X slower
    to complete this test than it was with its slowest selector test (test 6). Android
    4.3 was 1.2X slower than its slowest selector test (test 6). Internet Explorer
    was a whopping 2.5X slower than its slowest selector!
  prefs: []
  type: TYPE_NORMAL
- en: You can see that things dropped down considerably for Firefox when half of the
    styles were removed (approx 1500 lines). The Android device came down to around
    the speed of its slowest selector at that point too.
  prefs: []
  type: TYPE_NORMAL
- en: Removing unused styles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Does this kind of horror scenario sound familiar to you? Enormous CSS files
    with all manner of selectors (often with selectors in that don't even work), heaps
    of ever more specific selectors seven or more levels deep, non-applicable vendor-prefix's,
    ID selectors all over the place and file sizes of 50–80 KB (sometimes more).
  prefs: []
  type: TYPE_NORMAL
- en: If you are working on a code base that has a big fat CSS file like this, one
    that no-one is quite sure what all the styles are actually for, my advice would
    be to look there for your CSS optimisations before the selectors being employed.
    Hopefully by this point you will be convinced that an ECSS approach might help
    in this respect.
  prefs: []
  type: TYPE_NORMAL
- en: Then again, that won't necessarily help with the actual performance of your
    CSS.
  prefs: []
  type: TYPE_NORMAL
- en: Performance inside the brackets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The *final test* ([https://benfrain.com/selector-test/3-01.html](https://benfrain.com/selector-test/3-01.html))
    I ran was to hit the page with a bunch of *expensive* properties and values. Consider
    this rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'With that rule applied, here are the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Test** | **Chrome 34** | **Firefox 29** | **Opera 19** | **IE 19** | **Android
    4** |'
  prefs: []
  type: TYPE_TB
- en: '| Expensive Styles | 65.2 | 151.4 | 65.2 | 259.2 | 1923 |'
  prefs: []
  type: TYPE_TB
- en: Here all browsers are at least up with their slowest selector speed (IE was
    1.5X slower than its slowest selector test (10) and the Android device was 1.3X
    slower than the slowest selector test (test 6)) but that's not even the full picture.
    Try and scroll that page! Repaint on those kind of styles can bring a browser
    to its knees (or whatever the equivalent of knees is for a browser).
  prefs: []
  type: TYPE_NORMAL
- en: The properties we stick inside the braces are what really affects performance.
    It stands to reason that scrolling a page that requires endless expensive re-paints
    and layout changes is going to put a strain on the device. Nice HiDPI screen?
    It will be even worse as the CPU/GPU strains to get everything re-painted to screen
    in under 16 ms.
  prefs: []
  type: TYPE_NORMAL
- en: With the expensive styles test, on the 15" Retina MacBook Pro I tested on, the
    paint time shown in continuous paint mode in Chrome never dropped below 280 ms
    (and remember, we are aiming for sub–16 ms). To put that in perspective for you,
    the first selector test page, never went above 2.5 ms. That wasn't a typo. Those
    properties created a 112X increase in paint time. Holy expensive properties Batman!
    Indeed Robin. Indeed.
  prefs: []
  type: TYPE_NORMAL
- en: What properties are expensive?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An *expensive* property/value pairing is one we can be pretty confident will
    make the browser struggle with when it has to repaint the screen (e.g. on scroll).
  prefs: []
  type: TYPE_NORMAL
- en: How can we know what will be an *expensive* style? Thankfully, we can apply
    common sense to this and get a pretty good idea what is going to tax the browser.
    Anything that requires a browser to manipulate/calculate before painting to the
    page will be more costly. For example, box-shadows, border-radius, transparency
    (as the browser has to calculate what is shown below), transforms and performance
    killers like CSS filters - if performance is your priority, anything like that
    is your worst enemy.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Juriy kangax Zaytsev did `a fantastic blog post also covering CSS performance` ([http://perfectionkills.com/profiling-css-for-fun-and-profit-optimization-notes/](http://perfectionkills.com/profiling-css-for-fun-and-profit-optimization-notes/)) back
    in 2012\. He was using the various developer tools to measure performance. He
    did a particularly good job of showing the difference that various properties
    had on performance. If this kind of thing interests you then that post is well
    worth your time.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some takeaways from these tests:'
  prefs: []
  type: TYPE_NORMAL
- en: Sweating over the selectors used in modern browsers is futile; most selection
    methods are now so fast it's really not worth spending much time over. Furthermore,
    there is disparity across browsers of what the slowest selectors are anyway. Look
    here last to speed up your CSS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Excessive unused styles are likely to cost more, performance wise, than any
    selectors you chose so look to tidy up there second. 3000 lines that are unused
    or surplus on a page are not even that uncommon. While it's common to bunch all
    the styles up into a great big single `styles.css`, if different areas of your
    site/web application can have different (additional) style sheets added (dependency
    graph style), that may be the better option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your CSS has been added to by a number of different authors over time, look
    to tools like *UnCSS* ([https://github.com/giakki/uncss](https://github.com/giakki/uncss))
    to automate the removal of styles; doing that process by hand is no fun!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The battle for high performing CSS will not be won in the selectors used, it
    will be won with the judicious use of property and values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting something painted to screen fast is obviously important but so is how
    a page feels when the user interacts with it. Look for expensive property and
    value pairs first (Chrome continuous repaint mode is your friend here), they are
    likely to provide the biggest gains.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
