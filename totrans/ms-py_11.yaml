- en: Chapter 11. Debugging – Solving the Bugs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter showed you how to add logging and tests to your code, but
    no matter how many tests you have, you will always have bugs. The biggest problem
    is always user input, as it is simply impossible to test all possible inputs,
    implying that at one point, we will need to debug the code.
  prefs: []
  type: TYPE_NORMAL
- en: There are many debugging techniques, and most certainly, you have already used
    a few of them. Within this chapter, we are going to focus on print/trace debugging
    and interactive debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging using print statements, stack traces, and logging is one of the most
    versatile methods to work with, and it is most likely the first type of debugging
    you've ever used. Even a `print 'Hello world'` can be considered this type, as
    the output will show you that your code is being executed correctly. There is
    obviously no point in explaining how and where to place print statements to debug
    your code, but there are quite a few nice tricks using decorators and other Python
    modules that render this type of debugging a lot more useful, such as `faulthandler`.
  prefs: []
  type: TYPE_NORMAL
- en: Interactive debugging is a more complicated debugging method. It allows you
    to debug a program while it's still running. Using this method, it's even possible
    to change variables while the application is running and pause the application
    at any point desired. The downside is that it requires some knowledge about the
    debugger commands to be really useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging using `print`, `trace`, `logging`, and `faulthandler`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interactive debugging using `pdb`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-interactive debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most basic form of debugging is adding a simple print statement into your
    code to see what is still working and what isn't. This is useful in a variety
    of cases and likely to help solve most of your issues. Later in this chapter,
    we will show some interactive debugging methods, but those are not always suitable.
    Interactive debugging tends to become difficult or even impossible in multithreaded
    environments, while on a closed-off remote server, you might need a different
    solution as well. Both methods have their merits, but I personally opt for non-interactive
    debugging 90% of the time since a simple print/log statement is usually enough
    to analyze the cause of a problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'A basic example of this (I''ve been known to do similar) with a generator can
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This shows exactly where the code does, and consequently, does not reach. Without
    this example, you might have expected the first print to come immediately after
    the `spam_generator()` call, since it's a generator. However, the execution completely
    stalls until we `yield` an item. Assuming you would have some setup code before
    the first `yield`, it won't run until `next` is actually called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although this is one of the simplest ways to debug functions using print statements,
    it''s definitely not the best way. We can start by making an auto-print function
    that automatically increments the letter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: While the print statement generator is slightly better than bare print statements,
    it doesn't help that much yet. It would be much more useful to see which lines
    were actually executed while running the code. We can do this manually using `inspect.currentframe`,
    but there is no need for hacking. Python has you covered with some dedicated tools.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting your script using trace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Simple print statements are useful in a lot of cases since you can easily incorporate
    print statements in nearly every application. It does not matter whether it's
    remote or local, threaded or using multiprocessing. It works almost everywhere,
    making it the most universal solution available, in addition to logging that is.
    The general solution is often not the best solution, however. There are better
    solutions available for the most common scenarios. One of them is the `trace`
    module. It offers you a way to trace every execution, relationships between functions,
    and a few others.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate, we will use our previous code but without print statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We will execute it with the trace module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Quite nice, isn't it? It shows you exactly which line is being executed with
    function names and, more importantly, which line was caused by which statement
    (or statements). Additionally, it shows you at what time it was executed relative
    to the start time of the program. This is due to the `--timing` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you might expect, this output is a bit too verbose to be universally useful.
    In spite of the fact that you can opt to ignore specific modules and directories
    by using command-line parameters, it is still too verbose in many cases. So let''s
    go for the next solution—a context manager. The preceding output has already revealed
    some of the `trace` internals. The last line shows a `sys.settrace` call, which
    is exactly what we need for manual tracing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed as a regular Python file, this returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This code immediately reveals what the trace code does internally as well:
    it uses `sys.settrace` to tell the Python interpreter where to send every statement
    that is being executed. Given this, it''s obviously trivial to write the function
    as a decorator, but I''ll leave that as an exercise to you if you need it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another take-away from this is that you can easily add extra filters to your
    trace function by wrapping `tracer.globaltrace`. The function takes the following
    parameters (from the standard Python documentation):'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Call` | A function is called (or some other code block entered). The global
    trace function is called; `arg` is `None`. The return value specifies the local
    trace function. |'
  prefs: []
  type: TYPE_TB
- en: '| `Line` | The interpreter is about to execute a new line of code or re-execute
    the condition of a loop. The local trace function is called; `arg` is `None`.
    The return value specifies the new local trace function. See `Objects/lnotab_notes.txt`
    for a detailed explanation of how this works. |'
  prefs: []
  type: TYPE_TB
- en: '| `return` | A function (or another code block) is about to return. The local
    trace function is called; `arg` is the value that will be returned or `None` if
    the event is caused by an exception being raised. The trace function''s return
    value is ignored. |'
  prefs: []
  type: TYPE_TB
- en: '| `exception` | This means an exception has occurred. The local trace function
    is called; `arg` is a tuple (`exception`, `value`, `traceback`). The return value
    specifies the new local trace function. |'
  prefs: []
  type: TYPE_TB
- en: '| `c_call` | A C function is about to be called. This may be an extension function
    or a built-in function. The `arg` is the C function object. |'
  prefs: []
  type: TYPE_TB
- en: '| `c_return` | A C function has returned, and `arg` is the C function object.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `c_exception` | A C function has raised an exception, and `arg` is the C
    function object. |'
  prefs: []
  type: TYPE_TB
- en: As you must have expected, with a simple filter function, you can easily make
    sure that only specific functions will be returned, instead of the long list you
    would normally get. You really shouldn't underestimate the amount of data generated
    by tracing code with a few imports. The preceding context manager code gives over
    300 lines of output.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging using logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 10](ch10.html "Chapter 10. Testing and Logging – Preparing for Bugs"),
    *Testing and Logging – Preparing for Bugs*, our chapter about testing and logging,
    we saw how to create custom loggers, set the levels for them, and add handlers
    to specific levels. We are going to use the `logging.DEBUG` level to log now,
    which is nothing special by itself, but with a few decorators, we can add some
    very useful debug-only code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever I''m debugging, I always find it very useful to know the input and
    output for a function. The basic version with a decorator is simple enough to
    write; just print the `args` and `kwargs` and you are done. The following example
    goes a little further. By using the `inspect` module, we can retrieve the default
    arguments as well, making it possible to show all arguments with the argument
    names and values in all cases, even if the argument was not specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Very nice of course, as we have a clear sight of when the function is called,
    which parameters were used, and what is returned. However, this is something you
    will probably only execute when you are actively debugging your code. You can
    also make the regular `logging.debug` statements in your code quite a bit more
    useful by adding a debug-specific logger, which shows more information. Simply
    replace the logging config of the preceding example with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then your result will be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It shows the time relative to the start of the application in milliseconds and
    the log level. This is followed by an identification block that shows the filename,
    line number, and function name that originated the logs. Of course, there is a
    message at the end.
  prefs: []
  type: TYPE_NORMAL
- en: Showing call stack without exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When looking at how and why a piece of code is being run, it''s often useful
    to see the entire stack trace. Simply raising an exception is, of course, an option.
    However, that will kill the current code execution, which is generally not something
    we are looking for. This is where the `traceback` module comes in handy. With
    just a few simple lines, we get a full (or limited, if you prefer) stack list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the traceback simply prints without any exceptions. The `traceback`
    module actually has quite a few other methods for printing tracebacks based on
    exceptions and such, but you probably won''t need them often. The most useful
    one is probably the `limit` parameter; this parameter allows you to limit the
    stack trace to the useful part. For example, if you''ve added this code using
    a decorator or helper function, you probably have no need to include those in
    the stack trace. That''s where the `limit` parameter helps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `print_stack` function itself has now been hidden from the
    stack trace, which makes everything a bit cleaner.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The negative limit support was added in Python 3.5\. Before that, only positive
    limits were supported.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging asyncio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `asyncio` module has a few special provisions to make debugging somewhat
    easier. Given the asynchronous nature of functions within `asyncio`, this is a
    very welcome feat. While debugging of multithreaded/multiprocessing functions
    or classes can be difficult—since concurrent classes can easily change environment
    variables in parallel—with `asyncio`, it's just as difficult if not more.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Within most Linux/Unix/Mac shell sessions, environment variables can be set
    using it as a prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, it can be configured for the current shell session using `export`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The current value can be fetched using the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'On Windows, you can configure an environment variable for your local shell
    session using the `set` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The current value can be fetched using this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When enabling the debug mode using the `PYTHONASYNCIODEBUG` environment setting
    the `asyncio` module will check whether every defined coroutine is actually run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in an error for the printer coroutine, which is never yielded
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, the `event` loop has some log messages by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in debug messages such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You might wonder why we are using the `PYTHONASYNCIODEBUG` flag instead of `loop.set_debug(True)`.
    The reason is that there are cases where this won't work because debugging is
    enabled too late. For example, when trying that with the preceding `printer()`,
    you will see that you won't get any errors when using `loop.set_debug(True)` alone.
  prefs: []
  type: TYPE_NORMAL
- en: 'When enabling debugging, the following will change:'
  prefs: []
  type: TYPE_NORMAL
- en: Coroutines that have not been yielded (as can be seen in the preceding lines)
    will raise an exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling coroutines from the "wrong" thread raises an exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The execution time of the selector will be logged.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slow callbacks (more than 100 ms) will be logged. This timeout can be modified
    through `loop.slow_callback_duration`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Warnings will be raised when resources are not closed properly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tasks that were destroyed before execution will be logged.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling crashes using faulthandler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `faulthandler` module helps when debugging really low-level crashes, that
    is, crashes that should only be possible when using low-level access to memory,
    such as C extensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here''s a bit of code that will cause your Python interpreter
    to crash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'It results in something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s quite an ugly response of course and gives you no possibility to handle
    the error. Just in case you are wondering, having a `try/except` structure won''t
    help you in these cases either. The following code will crash exactly in the same
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This is where the `faulthandler` module helps. It will still cause your interpreter
    to crash, but at least you will see a proper error message raised, so it''s a
    good default if you (or any of the sublibraries) have any interaction with raw
    memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'It results in something along these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, it's not desirable to have a Python application exit in this manner
    as the code won't exit with a normal cleanup. Resources won't be closed cleanly
    and your exit handler won't be called. If you somehow need to catch this behavior,
    your best bet is to wrap the Python executable in a separate script.
  prefs: []
  type: TYPE_NORMAL
- en: Interactive debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have discussed basic debugging methods that will always work, we
    will look at interactive debugging for some more advanced debugging techniques.
    The previous debugging methods made variables and stacks visible through modifying
    the code and/or foresight. This time around, we will look at a slightly smarter
    method, which constitutes doing the same thing interactively, but once the need
    arises.
  prefs: []
  type: TYPE_NORMAL
- en: Console on demand
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When testing some Python code, you may have used the interactive console a
    couple of times, since it''s a simple yet effective tool for testing your Python
    code. What you might not have known is that it is actually simple to start your
    own shell from within your code. So, whenever you want to drop into a regular
    shell from a specific point in your code, that''s easily possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'When executing that, we will drop into an interactive console halfway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: To exit this console, we can use *^d* (*Ctrl* + *d*) on Linux/Mac systems and
    *^z* (*Ctrl* + *Z*) on Windows systems.
  prefs: []
  type: TYPE_NORMAL
- en: One important thing to note here is that the scope is not shared between the
    two. Even though we passed along `locals()` to share the local variables for convenience,
    this relation is not bidirectional. The result is that even though we set `eggs`
    to `456` in the interactive session, it does not carry over to the outside function.
    You can modify variables in the outside scope through direct manipulation (for
    example, setting the properties) if you wish, but all variables declared locally
    will remain local.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging using pdb
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it comes to actually debugging code, the regular interactive console just
    isn''t suited. With a bit of effort, you can make it work, but it''s just not
    all that convenient for debugging since you can only see the current scope and
    can''t jump around the stack easily. With `pdb` (Python debugger), this is easily
    possible. So let''s look at a simple example of using `pdb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This example is pretty much identical to the one in the previous paragraph,
    except that this time we end up in the `pdb` console instead of a regular interactive
    console. So let''s give the interactive debugger a try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we've actually modified the value of `eggs` now. In this case,
    we used the full `continue` command, but all the `pdb` commands have short versions
    as well. So, using `c` instead of `continue` gives the same result. Just typing
    `eggs` (or any other variable) will show the contents and setting the variable
    will simply set it, just as we would expect from an interactive session.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with `pdb`, first of all, a list of the most useful (full) commands
    with shorthands is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Command | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `h(elp)` | This shows the list of commands (this list). |'
  prefs: []
  type: TYPE_TB
- en: '| `h(elp) command` | This shows the help for the given command. |'
  prefs: []
  type: TYPE_TB
- en: '| `w(here)` | Current stack trace with an arrow at the current frame. |'
  prefs: []
  type: TYPE_TB
- en: '| `d(own)` | Move down/to a newer frame in the stack. |'
  prefs: []
  type: TYPE_TB
- en: '| `u(p)` | Move up/to an older frame in the stack. |'
  prefs: []
  type: TYPE_TB
- en: '| `s(tep)` | Execute the current line and stop as soon as possible. |'
  prefs: []
  type: TYPE_TB
- en: '| `n(ext)` | Execute the current line and stop at the next line within the
    current function. |'
  prefs: []
  type: TYPE_TB
- en: '| `r(eturn)` | Continue execution until the function returns. |'
  prefs: []
  type: TYPE_TB
- en: '| `c(ont(inue))` | Continue execution up to the next breakpoint. |'
  prefs: []
  type: TYPE_TB
- en: '| `l(ist) [first[, last]]` | List the lines of source code (by default, 11
    lines) around the current line. |'
  prefs: []
  type: TYPE_TB
- en: '| `ll &#124; longlist` | List all of the source code for the current function
    or frame. |'
  prefs: []
  type: TYPE_TB
- en: '| `source expression` | List the source code for the given object. This is
    similar to longlist. |'
  prefs: []
  type: TYPE_TB
- en: '| `a(rgs)` | Print the arguments for the current function. |'
  prefs: []
  type: TYPE_TB
- en: '| `pp expression` | Pretty-print the given expression. |'
  prefs: []
  type: TYPE_TB
- en: '| `b(reak)` | Show the list of breakpoints. |'
  prefs: []
  type: TYPE_TB
- en: '| `b(reak) [filename:]lineno` | Place a breakpoint at the given line number
    and, optionally, file. |'
  prefs: []
  type: TYPE_TB
- en: '| `b(reak) function[, condition]` | Place a breakpoint at the given function.
    The condition is an expression that must evaluate to `True` for the breakpoint
    to work. |'
  prefs: []
  type: TYPE_TB
- en: '| `cl(ear) [filename:]lineno` | Clear the breakpoint (or breakpoints) at this
    line. |'
  prefs: []
  type: TYPE_TB
- en: '| `cl(ear) breakpoint [breakpoint ...]` | Clear the breakpoint (or breakpoints)
    with these numbers. |'
  prefs: []
  type: TYPE_TB
- en: '| `Command` | List all defined commands. |'
  prefs: []
  type: TYPE_TB
- en: '| `command breakpoint` | Specify a list of commands to execute whenever the
    given breakpoint is encountered. The list is ended using the `end` command. |'
  prefs: []
  type: TYPE_TB
- en: '| `Alias` | List all aliases. |'
  prefs: []
  type: TYPE_TB
- en: '| `alias name command` | Create an alias. The command can be any valid Python
    expression, so you can do the following to print all properties for an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `unalias name` | Remove an alias. |'
  prefs: []
  type: TYPE_TB
- en: '| `! statement` | Execute the statement at the current point in the stack.
    Normally the `!` sign is not needed, but this can be useful if there are collisions
    with debugger commands. For example, try `b = 123`. |'
  prefs: []
  type: TYPE_TB
- en: '| `Interact` | Open an interactive session similar to the previous paragraph.
    Note that variables set within that local scope will not be transferred. |'
  prefs: []
  type: TYPE_TB
- en: Breakpoints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It''s quite a long list, but you will probably use most of these quite regularly.
    To highlight one of the options shown in the preceding table, let''s demonstrate
    the setting and use of breakpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, nothing new has happened, but let''s now open the interactive debugging
    session, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'That was a lot of output, but it''s actually not as complex as it seems:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we used the `source spam` command to see the source for the `spam` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, we knew the line number of the first `print` statement, which we
    used to place a breakpoint (`b 5`) at line 5.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To check whether we were still at the right position, we used the `w` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since the breakpoint was set, we used `c` to continue up to the next breakpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Having stopped at the breakpoint at line 5, we used `w` again to confirm that.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Listing the code of the current function using `ll`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Listing the breakpoints using `b`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Removing the breakpoint again using `cl 1` with the breakpoint number from the
    previous command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It all seems a bit complicated in the beginning, but you'll see that it's actually
    a very convenient way of debugging once you've tried a few times.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it even better, this time we will execute the breakpoint only when
    `eggs = 3`. The code is pretty much the same, although we need a variable in this
    case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s execute the code and make sure that it only breaks at certain times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To list what we have done:'
  prefs: []
  type: TYPE_NORMAL
- en: First, using `source` spam, we looked for the line number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, we placed a breakpoint with the `eggs == 3` condition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we continued execution using `c`. As you can see, the values `0`, `1`,
    and `2` are printed as normal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The breakpoint was reached at value `3`. To verify this we used `a` to see the
    function arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And we continued to execute the rest of the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Catching exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All of these have been manual calls to the `pdb.set_trace()` function, but
    in general, you are just running your application and not really expecting issues.
    This is where exception catching can be very handy. In addition to importing `pdb`
    yourself, you can run scripts through `pdb` as a module as well. Let''s examine
    this bit of code, which dies as soon as it reaches zero division:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run it using the `pdb` parameter, we can end up in the Python Debugger
    whenever it crashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A useful little trick within `pdb` is to use the *Enter* button, which, by default,
    will execute the previously executed command again. This is very useful when stepping
    through the program.
  prefs: []
  type: TYPE_NORMAL
- en: Commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `commands` command is a little complicated but very useful. It allows you
    to execute commands whenever a specific breakpoint is encountered. To illustrate
    this, let''s start from a simple example again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is simple enough, so now we''ll add the breakpoint and the commands,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we can easily add commands to the breakpoint. After removing
    the breakpoint, these commands obviously won't be executed anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging using ipdb
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the generic Python console is useful, it can be a little rough around
    the edges. The IPython console offers a whole new world of extra features, which
    make it a much nicer console to work with. One of those features is a more convenient
    debugger.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, make sure you have `ipdb` installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s try the debugger again with our previous script. The only small
    change is that we now import `ipdb` instead of `pdb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we execute it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The commands are all the same, but the output is just a tad more legible in
    my opinion. The actual version also includes syntax highlighting, which makes
    the output even easier to follow.
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, you can just replace `pdb` with `ipdb` in most situations to simply
    get a more intuitive debugger. But I will give you the recommendation as well,
    to the `ipdb` context manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This is as convenient as it looks. It simply hooks `ipdb` into your exceptions
    so that you can easily debug whenever needed. Combine that with a debug flag to
    your application to easily allow debugging when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Other debuggers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`pdb` and `ipdb` are just two of the large number of debuggers available for
    Python. Some of the currently noteworthy debuggers are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pudb`: This offers a a full-screen command-line debugger'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pdbpp`: This hooks into the regular `pdb`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rpdb2`: This is a remote debugger that allows hooking into running (remote)
    applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Werkzeug`: This is a web-based debugger that allows debugging of web applications
    while they are running'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many others, of course, and there isn't a single one that's the absolute
    best. As is the case with all tools, they all have their advantages and their
    fallacies, and the one that is best for your current purpose can be properly decided
    only by you. Chances are that your current Python IDE already has an integrated
    debugger.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to debugging when you encounter a problem, there are times when
    you simply need to keep track of errors for later debugging. Especially when working
    with remote servers, these can be invaluable to detect when and how a Python process
    is malfunctioning. Additionally, these services offer grouping of errors as well,
    making them far more useful than a simple e-mail-on-exception type of script,
    which can quickly spam your inbox.
  prefs: []
  type: TYPE_NORMAL
- en: A nice open source solution for keeping track of errors is `sentry`. If you
    need a full-fletched solution that offers performance tracking as well, then Opbeat
    and Newrelic are very nice solutions; they offer both free and paid versions.
    Note that all of these also support tracking of other languages, such as JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explained a few different debugging techniques and gotchas. There
    is, of course, much more that can be said about debugging, but I hope you have
    acquired a nice vantage point for debugging your Python code now. Interactive
    debugging techniques are very useful for single-threaded applications and locations
    where interactive sessions are available. But since that's not always the case,
    we also discussed some non-interactive options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an overview of all the points discussed in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Non-interactive debugging using:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`logging`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trace`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`traceback`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`asyncio`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`faulthandler`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interactive debugging using both `pdb` and `ipdb`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to monitor and improve both CPU and memory
    performance, as well as finding and fixing memory leaks.
  prefs: []
  type: TYPE_NORMAL
