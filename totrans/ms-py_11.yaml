- en: Chapter 11. Debugging – Solving the Bugs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter showed you how to add logging and tests to your code, but
    no matter how many tests you have, you will always have bugs. The biggest problem
    is always user input, as it is simply impossible to test all possible inputs,
    implying that at one point, we will need to debug the code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: There are many debugging techniques, and most certainly, you have already used
    a few of them. Within this chapter, we are going to focus on print/trace debugging
    and interactive debugging.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Debugging using print statements, stack traces, and logging is one of the most
    versatile methods to work with, and it is most likely the first type of debugging
    you've ever used. Even a `print 'Hello world'` can be considered this type, as
    the output will show you that your code is being executed correctly. There is
    obviously no point in explaining how and where to place print statements to debug
    your code, but there are quite a few nice tricks using decorators and other Python
    modules that render this type of debugging a lot more useful, such as `faulthandler`.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Interactive debugging is a more complicated debugging method. It allows you
    to debug a program while it's still running. Using this method, it's even possible
    to change variables while the application is running and pause the application
    at any point desired. The downside is that it requires some knowledge about the
    debugger commands to be really useful.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Debugging using `print`, `trace`, `logging`, and `faulthandler`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interactive debugging using `pdb`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-interactive debugging
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most basic form of debugging is adding a simple print statement into your
    code to see what is still working and what isn't. This is useful in a variety
    of cases and likely to help solve most of your issues. Later in this chapter,
    we will show some interactive debugging methods, but those are not always suitable.
    Interactive debugging tends to become difficult or even impossible in multithreaded
    environments, while on a closed-off remote server, you might need a different
    solution as well. Both methods have their merits, but I personally opt for non-interactive
    debugging 90% of the time since a simple print/log statement is usually enough
    to analyze the cause of a problem.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'A basic example of this (I''ve been known to do similar) with a generator can
    be as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This shows exactly where the code does, and consequently, does not reach. Without
    this example, you might have expected the first print to come immediately after
    the `spam_generator()` call, since it's a generator. However, the execution completely
    stalls until we `yield` an item. Assuming you would have some setup code before
    the first `yield`, it won't run until `next` is actually called.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'Although this is one of the simplest ways to debug functions using print statements,
    it''s definitely not the best way. We can start by making an auto-print function
    that automatically increments the letter:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: While the print statement generator is slightly better than bare print statements,
    it doesn't help that much yet. It would be much more useful to see which lines
    were actually executed while running the code. We can do this manually using `inspect.currentframe`,
    but there is no need for hacking. Python has you covered with some dedicated tools.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting your script using trace
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Simple print statements are useful in a lot of cases since you can easily incorporate
    print statements in nearly every application. It does not matter whether it's
    remote or local, threaded or using multiprocessing. It works almost everywhere,
    making it the most universal solution available, in addition to logging that is.
    The general solution is often not the best solution, however. There are better
    solutions available for the most common scenarios. One of them is the `trace`
    module. It offers you a way to trace every execution, relationships between functions,
    and a few others.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate, we will use our previous code but without print statements:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will execute it with the trace module:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Quite nice, isn't it? It shows you exactly which line is being executed with
    function names and, more importantly, which line was caused by which statement
    (or statements). Additionally, it shows you at what time it was executed relative
    to the start time of the program. This is due to the `--timing` flag.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'As you might expect, this output is a bit too verbose to be universally useful.
    In spite of the fact that you can opt to ignore specific modules and directories
    by using command-line parameters, it is still too verbose in many cases. So let''s
    go for the next solution—a context manager. The preceding output has already revealed
    some of the `trace` internals. The last line shows a `sys.settrace` call, which
    is exactly what we need for manual tracing:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When executed as a regular Python file, this returns:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This code immediately reveals what the trace code does internally as well:
    it uses `sys.settrace` to tell the Python interpreter where to send every statement
    that is being executed. Given this, it''s obviously trivial to write the function
    as a decorator, but I''ll leave that as an exercise to you if you need it.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'Another take-away from this is that you can easily add extra filters to your
    trace function by wrapping `tracer.globaltrace`. The function takes the following
    parameters (from the standard Python documentation):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Description |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
- en: '| `Call` | A function is called (or some other code block entered). The global
    trace function is called; `arg` is `None`. The return value specifies the local
    trace function. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
- en: '| `Line` | The interpreter is about to execute a new line of code or re-execute
    the condition of a loop. The local trace function is called; `arg` is `None`.
    The return value specifies the new local trace function. See `Objects/lnotab_notes.txt`
    for a detailed explanation of how this works. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
- en: '| `return` | A function (or another code block) is about to return. The local
    trace function is called; `arg` is the value that will be returned or `None` if
    the event is caused by an exception being raised. The trace function''s return
    value is ignored. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
- en: '| `exception` | This means an exception has occurred. The local trace function
    is called; `arg` is a tuple (`exception`, `value`, `traceback`). The return value
    specifies the new local trace function. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
- en: '| `c_call` | A C function is about to be called. This may be an extension function
    or a built-in function. The `arg` is the C function object. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
- en: '| `c_return` | A C function has returned, and `arg` is the C function object.
    |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
- en: '| `c_exception` | A C function has raised an exception, and `arg` is the C
    function object. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
- en: As you must have expected, with a simple filter function, you can easily make
    sure that only specific functions will be returned, instead of the long list you
    would normally get. You really shouldn't underestimate the amount of data generated
    by tracing code with a few imports. The preceding context manager code gives over
    300 lines of output.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Debugging using logging
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 10](ch10.html "Chapter 10. Testing and Logging – Preparing for Bugs"),
    *Testing and Logging – Preparing for Bugs*, our chapter about testing and logging,
    we saw how to create custom loggers, set the levels for them, and add handlers
    to specific levels. We are going to use the `logging.DEBUG` level to log now,
    which is nothing special by itself, but with a few decorators, we can add some
    very useful debug-only code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever I''m debugging, I always find it very useful to know the input and
    output for a function. The basic version with a decorator is simple enough to
    write; just print the `args` and `kwargs` and you are done. The following example
    goes a little further. By using the `inspect` module, we can retrieve the default
    arguments as well, making it possible to show all arguments with the argument
    names and values in all cases, even if the argument was not specified:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following output is returned:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Very nice of course, as we have a clear sight of when the function is called,
    which parameters were used, and what is returned. However, this is something you
    will probably only execute when you are actively debugging your code. You can
    also make the regular `logging.debug` statements in your code quite a bit more
    useful by adding a debug-specific logger, which shows more information. Simply
    replace the logging config of the preceding example with this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then your result will be something like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It shows the time relative to the start of the application in milliseconds and
    the log level. This is followed by an identification block that shows the filename,
    line number, and function name that originated the logs. Of course, there is a
    message at the end.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Showing call stack without exceptions
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When looking at how and why a piece of code is being run, it''s often useful
    to see the entire stack trace. Simply raising an exception is, of course, an option.
    However, that will kill the current code execution, which is generally not something
    we are looking for. This is where the `traceback` module comes in handy. With
    just a few simple lines, we get a full (or limited, if you prefer) stack list:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This results in the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see, the traceback simply prints without any exceptions. The `traceback`
    module actually has quite a few other methods for printing tracebacks based on
    exceptions and such, but you probably won''t need them often. The most useful
    one is probably the `limit` parameter; this parameter allows you to limit the
    stack trace to the useful part. For example, if you''ve added this code using
    a decorator or helper function, you probably have no need to include those in
    the stack trace. That''s where the `limit` parameter helps:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This results in the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, the `print_stack` function itself has now been hidden from the
    stack trace, which makes everything a bit cleaner.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The negative limit support was added in Python 3.5\. Before that, only positive
    limits were supported.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Debugging asyncio
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `asyncio` module has a few special provisions to make debugging somewhat
    easier. Given the asynchronous nature of functions within `asyncio`, this is a
    very welcome feat. While debugging of multithreaded/multiprocessing functions
    or classes can be difficult—since concurrent classes can easily change environment
    variables in parallel—with `asyncio`, it's just as difficult if not more.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Within most Linux/Unix/Mac shell sessions, environment variables can be set
    using it as a prefix:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Also, it can be configured for the current shell session using `export`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The current value can be fetched using the following line:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'On Windows, you can configure an environment variable for your local shell
    session using the `set` command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The current value can be fetched using this line:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When enabling the debug mode using the `PYTHONASYNCIODEBUG` environment setting
    the `asyncio` module will check whether every defined coroutine is actually run:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This results in an error for the printer coroutine, which is never yielded
    here:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Additionally, the `event` loop has some log messages by default:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This results in debug messages such as the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You might wonder why we are using the `PYTHONASYNCIODEBUG` flag instead of `loop.set_debug(True)`.
    The reason is that there are cases where this won't work because debugging is
    enabled too late. For example, when trying that with the preceding `printer()`,
    you will see that you won't get any errors when using `loop.set_debug(True)` alone.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'When enabling debugging, the following will change:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Coroutines that have not been yielded (as can be seen in the preceding lines)
    will raise an exception.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling coroutines from the "wrong" thread raises an exception.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The execution time of the selector will be logged.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slow callbacks (more than 100 ms) will be logged. This timeout can be modified
    through `loop.slow_callback_duration`.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Warnings will be raised when resources are not closed properly.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tasks that were destroyed before execution will be logged.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling crashes using faulthandler
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `faulthandler` module helps when debugging really low-level crashes, that
    is, crashes that should only be possible when using low-level access to memory,
    such as C extensions.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here''s a bit of code that will cause your Python interpreter
    to crash:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'It results in something similar to the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'That''s quite an ugly response of course and gives you no possibility to handle
    the error. Just in case you are wondering, having a `try/except` structure won''t
    help you in these cases either. The following code will crash exactly in the same
    way:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is where the `faulthandler` module helps. It will still cause your interpreter
    to crash, but at least you will see a proper error message raised, so it''s a
    good default if you (or any of the sublibraries) have any interaction with raw
    memory:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'It results in something along these lines:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Obviously, it's not desirable to have a Python application exit in this manner
    as the code won't exit with a normal cleanup. Resources won't be closed cleanly
    and your exit handler won't be called. If you somehow need to catch this behavior,
    your best bet is to wrap the Python executable in a separate script.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Interactive debugging
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have discussed basic debugging methods that will always work, we
    will look at interactive debugging for some more advanced debugging techniques.
    The previous debugging methods made variables and stacks visible through modifying
    the code and/or foresight. This time around, we will look at a slightly smarter
    method, which constitutes doing the same thing interactively, but once the need
    arises.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Console on demand
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When testing some Python code, you may have used the interactive console a
    couple of times, since it''s a simple yet effective tool for testing your Python
    code. What you might not have known is that it is actually simple to start your
    own shell from within your code. So, whenever you want to drop into a regular
    shell from a specific point in your code, that''s easily possible:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When executing that, we will drop into an interactive console halfway:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: To exit this console, we can use *^d* (*Ctrl* + *d*) on Linux/Mac systems and
    *^z* (*Ctrl* + *Z*) on Windows systems.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: One important thing to note here is that the scope is not shared between the
    two. Even though we passed along `locals()` to share the local variables for convenience,
    this relation is not bidirectional. The result is that even though we set `eggs`
    to `456` in the interactive session, it does not carry over to the outside function.
    You can modify variables in the outside scope through direct manipulation (for
    example, setting the properties) if you wish, but all variables declared locally
    will remain local.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Debugging using pdb
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it comes to actually debugging code, the regular interactive console just
    isn''t suited. With a bit of effort, you can make it work, but it''s just not
    all that convenient for debugging since you can only see the current scope and
    can''t jump around the stack easily. With `pdb` (Python debugger), this is easily
    possible. So let''s look at a simple example of using `pdb`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This example is pretty much identical to the one in the previous paragraph,
    except that this time we end up in the `pdb` console instead of a regular interactive
    console. So let''s give the interactive debugger a try:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see, we've actually modified the value of `eggs` now. In this case,
    we used the full `continue` command, but all the `pdb` commands have short versions
    as well. So, using `c` instead of `continue` gives the same result. Just typing
    `eggs` (or any other variable) will show the contents and setting the variable
    will simply set it, just as we would expect from an interactive session.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with `pdb`, first of all, a list of the most useful (full) commands
    with shorthands is shown here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '| Command | Explanation |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
- en: '| `h(elp)` | This shows the list of commands (this list). |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
- en: '| `h(elp) command` | This shows the help for the given command. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
- en: '| `w(here)` | Current stack trace with an arrow at the current frame. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
- en: '| `d(own)` | Move down/to a newer frame in the stack. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
- en: '| `u(p)` | Move up/to an older frame in the stack. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
- en: '| `s(tep)` | Execute the current line and stop as soon as possible. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
- en: '| `n(ext)` | Execute the current line and stop at the next line within the
    current function. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
- en: '| `r(eturn)` | Continue execution until the function returns. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
- en: '| `c(ont(inue))` | Continue execution up to the next breakpoint. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
- en: '| `l(ist) [first[, last]]` | List the lines of source code (by default, 11
    lines) around the current line. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
- en: '| `ll &#124; longlist` | List all of the source code for the current function
    or frame. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
- en: '| `source expression` | List the source code for the given object. This is
    similar to longlist. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
- en: '| `a(rgs)` | Print the arguments for the current function. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
- en: '| `pp expression` | Pretty-print the given expression. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
- en: '| `b(reak)` | Show the list of breakpoints. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
- en: '| `b(reak) [filename:]lineno` | Place a breakpoint at the given line number
    and, optionally, file. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
- en: '| `b(reak) function[, condition]` | Place a breakpoint at the given function.
    The condition is an expression that must evaluate to `True` for the breakpoint
    to work. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
- en: '| `cl(ear) [filename:]lineno` | Clear the breakpoint (or breakpoints) at this
    line. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
- en: '| `cl(ear) breakpoint [breakpoint ...]` | Clear the breakpoint (or breakpoints)
    with these numbers. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
- en: '| `Command` | List all defined commands. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
- en: '| `command breakpoint` | Specify a list of commands to execute whenever the
    given breakpoint is encountered. The list is ended using the `end` command. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
- en: '| `Alias` | List all aliases. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
- en: '| `alias name command` | Create an alias. The command can be any valid Python
    expression, so you can do the following to print all properties for an object:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '|'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '| `unalias name` | Remove an alias. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
- en: '| `! statement` | Execute the statement at the current point in the stack.
    Normally the `!` sign is not needed, but this can be useful if there are collisions
    with debugger commands. For example, try `b = 123`. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
- en: '| `Interact` | Open an interactive session similar to the previous paragraph.
    Note that variables set within that local scope will not be transferred. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: Breakpoints
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It''s quite a long list, but you will probably use most of these quite regularly.
    To highlight one of the options shown in the preceding table, let''s demonstrate
    the setting and use of breakpoints:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'So far, nothing new has happened, but let''s now open the interactive debugging
    session, as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'That was a lot of output, but it''s actually not as complex as it seems:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: First, we used the `source spam` command to see the source for the `spam` function.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, we knew the line number of the first `print` statement, which we
    used to place a breakpoint (`b 5`) at line 5.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To check whether we were still at the right position, we used the `w` command.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since the breakpoint was set, we used `c` to continue up to the next breakpoint.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Having stopped at the breakpoint at line 5, we used `w` again to confirm that.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Listing the code of the current function using `ll`.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Listing the breakpoints using `b`.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Removing the breakpoint again using `cl 1` with the breakpoint number from the
    previous command.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It all seems a bit complicated in the beginning, but you'll see that it's actually
    a very convenient way of debugging once you've tried a few times.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it even better, this time we will execute the breakpoint only when
    `eggs = 3`. The code is pretty much the same, although we need a variable in this
    case:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, let''s execute the code and make sure that it only breaks at certain times:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To list what we have done:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: First, using `source` spam, we looked for the line number.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, we placed a breakpoint with the `eggs == 3` condition.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we continued execution using `c`. As you can see, the values `0`, `1`,
    and `2` are printed as normal.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The breakpoint was reached at value `3`. To verify this we used `a` to see the
    function arguments.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And we continued to execute the rest of the code.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Catching exceptions
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All of these have been manual calls to the `pdb.set_trace()` function, but
    in general, you are just running your application and not really expecting issues.
    This is where exception catching can be very handy. In addition to importing `pdb`
    yourself, you can run scripts through `pdb` as a module as well. Let''s examine
    this bit of code, which dies as soon as it reaches zero division:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If we run it using the `pdb` parameter, we can end up in the Python Debugger
    whenever it crashes:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Tip
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A useful little trick within `pdb` is to use the *Enter* button, which, by default,
    will execute the previously executed command again. This is very useful when stepping
    through the program.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Commands
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `commands` command is a little complicated but very useful. It allows you
    to execute commands whenever a specific breakpoint is encountered. To illustrate
    this, let''s start from a simple example again:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The code is simple enough, so now we''ll add the breakpoint and the commands,
    as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you can see, we can easily add commands to the breakpoint. After removing
    the breakpoint, these commands obviously won't be executed anymore.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Debugging using ipdb
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the generic Python console is useful, it can be a little rough around
    the edges. The IPython console offers a whole new world of extra features, which
    make it a much nicer console to work with. One of those features is a more convenient
    debugger.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'First, make sure you have `ipdb` installed:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, let''s try the debugger again with our previous script. The only small
    change is that we now import `ipdb` instead of `pdb`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then we execute it:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The commands are all the same, but the output is just a tad more legible in
    my opinion. The actual version also includes syntax highlighting, which makes
    the output even easier to follow.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, you can just replace `pdb` with `ipdb` in most situations to simply
    get a more intuitive debugger. But I will give you the recommendation as well,
    to the `ipdb` context manager:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This is as convenient as it looks. It simply hooks `ipdb` into your exceptions
    so that you can easily debug whenever needed. Combine that with a debug flag to
    your application to easily allow debugging when needed.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Other debuggers
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`pdb` and `ipdb` are just two of the large number of debuggers available for
    Python. Some of the currently noteworthy debuggers are as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '`pudb`: This offers a a full-screen command-line debugger'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pdbpp`: This hooks into the regular `pdb`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rpdb2`: This is a remote debugger that allows hooking into running (remote)
    applications'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Werkzeug`: This is a web-based debugger that allows debugging of web applications
    while they are running'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many others, of course, and there isn't a single one that's the absolute
    best. As is the case with all tools, they all have their advantages and their
    fallacies, and the one that is best for your current purpose can be properly decided
    only by you. Chances are that your current Python IDE already has an integrated
    debugger.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Debugging services
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to debugging when you encounter a problem, there are times when
    you simply need to keep track of errors for later debugging. Especially when working
    with remote servers, these can be invaluable to detect when and how a Python process
    is malfunctioning. Additionally, these services offer grouping of errors as well,
    making them far more useful than a simple e-mail-on-exception type of script,
    which can quickly spam your inbox.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在遇到问题时进行调试之外，有时您只需要跟踪错误以供以后调试。特别是在与远程服务器一起工作时，这些可以非常宝贵，可以检测 Python 进程何时以及如何发生故障。此外，这些服务还提供错误分组，使它们比简单的异常类型脚本更有用，后者可能会快速填满您的收件箱。
- en: A nice open source solution for keeping track of errors is `sentry`. If you
    need a full-fletched solution that offers performance tracking as well, then Opbeat
    and Newrelic are very nice solutions; they offer both free and paid versions.
    Note that all of these also support tracking of other languages, such as JavaScript.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的开源解决方案，用于跟踪错误的是`sentry`。如果您需要一个提供性能跟踪的完整解决方案，那么 Opbeat 和 Newrelic 都是非常好的解决方案；它们提供免费和付费版本。请注意，所有这些解决方案还支持跟踪其他语言，例如
    JavaScript。
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter explained a few different debugging techniques and gotchas. There
    is, of course, much more that can be said about debugging, but I hope you have
    acquired a nice vantage point for debugging your Python code now. Interactive
    debugging techniques are very useful for single-threaded applications and locations
    where interactive sessions are available. But since that's not always the case,
    we also discussed some non-interactive options.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一些不同的调试技术和陷阱。当然，关于调试还有很多可以说的，但我希望您现在已经获得了一个很好的调试 Python 代码的视角。交互式调试技术对于单线程应用程序和可用交互式会话的位置非常有用。但由于情况并非总是如此，我们还讨论了一些非交互式选项。
- en: 'Here''s an overview of all the points discussed in this chapter:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章讨论的所有要点概述：
- en: 'Non-interactive debugging using:'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用非交互式调试：
- en: '`print`'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印
- en: '`logging`'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录
- en: '`trace`'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪
- en: '`traceback`'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回溯
- en: '`asyncio`'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asyncio`'
- en: '`faulthandler`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障处理程序
- en: Interactive debugging using both `pdb` and `ipdb`
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`pdb`和`ipdb`进行交互式调试
- en: In the next chapter, we will see how to monitor and improve both CPU and memory
    performance, as well as finding and fixing memory leaks.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何监视和改善 CPU 和内存性能，以及查找和修复内存泄漏。
