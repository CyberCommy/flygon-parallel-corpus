- en: Cricket Score Calculator and Tracker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Object-oriented programming** (**OOP**) is a crucial element of writing .NET
    applications. Proper OOP ensures that developers can share code easily between
    projects. You don''t have to rewrite code that has already been written. This
    is called **inheritance**.'
  prefs: []
  type: TYPE_NORMAL
- en: A lot has been written throughout the years on the topic of OOP. In fact, doing
    a search on the internet on the benefits of OOP will return countless results.
    The fundamental benefits of OOP, however, are the modular approach to writing
    code, the ease with which code can be shared, and the ability to extend the functionality
    of shared code.
  prefs: []
  type: TYPE_NORMAL
- en: These little building blocks (or classes) are self-contained units of code that
    each perform a function. Developers do not need to know what goes on inside the
    class when they use it. They can just assume that the class will function on its
    own and will always work. Should the class they implement not provide a specific
    functionality, the developer is free to extend the functionality of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will have a look at the features that define OOP, which are:'
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will also have a look at:'
  prefs: []
  type: TYPE_NORMAL
- en: Single responsibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The open/closed principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will have a little fun. We will create an ASP.NET Bootstrap
    web application that keeps track of the cricket scores of your two favorite teams.
    It is with this app that the principles of OOP will become evident.
  prefs: []
  type: TYPE_NORMAL
- en: The *Cricket Score Tracker* app can be found on GitHub, and I encourage you
    to download the source code and make it your own. The GitHub repository URL is—[https://github.com/PacktPublishing/CSharp7-and-.NET-Core-2.0-Blueprints/tree/master/cricketScoreTrack](https://github.com/PacktPublishing/CSharp7-and-.NET-Core-2.0-Blueprints/tree/master/cricketScoreTrack).
  prefs: []
  type: TYPE_NORMAL
- en: There are so many features that a person can build into an application such
    as this, but the topic of OOP has only a single chapter in this book to convey
    this topic. Therefore, the focus is on OOP (more than the hard and fast rules
    of cricket) and some liberties have been taken with certain functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Let the games begin!
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Visual Studio 2017, we will create an ASP.NET Web Application project.
    You can call the application anything you like, but I called mine `cricketScoreTrack`.
    When you click on the new ASP.NET Web Application template, you will be presented
    with a few ASP.NET templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ASP.NET templates are:'
  prefs: []
  type: TYPE_NORMAL
- en: Empty
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web Forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MVC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single Page Application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure API App
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Mobile App
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are just going to select the Web Forms template. For this application, we
    don''t need authentication, so don''t change this setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6620368d-7a9f-4d12-a455-f8799ff7d0e4.png)'
  prefs: []
  type: TYPE_IMG
- en: I will assume that you have also downloaded the application from GitHub for
    this chapter, because you will need it as we discuss the architecture. The URL
    is—[https://github.com/PacktPublishing/CSharp7-and-.NET-Core-2.0-Blueprints/tree/master/cricketScoreTrack](https://github.com/PacktPublishing/CSharp7-and-.NET-Core-2.0-Blueprints/tree/master/cricketScoreTrack).
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on OK to create the web application. The project will be created and
    will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6294d3c4-b08d-41e6-9398-b510fd9e7ad0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To give you an idea of what we are building, the UI will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc166801-1c83-4a73-90e6-ada22b17a5cb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The various sections are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Batsmen selection (**1** in the preceding screenshot)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bowler selection (**2** in the preceding screenshot)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Batsmen game statistics—Runs, Balls, 4's, 6's, Strike Rate (**3** in the preceding
    screenshot)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bowler game statistics—Overs, Maidens, Runs, Wickets, Economy (**4** in the
    preceding screenshot)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Batsmen runs (**5** in the preceding screenshot)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game actions (**6** in the preceding screenshot)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game score and teams (**7** in the preceding screenshot)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Current batsmen details (**8** in the preceding screenshot)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runs per ball and over (**9** in the preceding screenshot)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, there is a lot going on here. There are obviously a lot of areas
    that you can still expand on. Another fun idea is to have an in-game statistics
    panel and even a Duckworth-Lewis calculation, if you have the time to try and
    implement it. I say try, because the actual algorithm of the calculation is a
    secret.
  prefs: []
  type: TYPE_NORMAL
- en: There are, however, a lot of implementations online, and one of particular interest
    to me was the article by Sarvashrestha Paliwal, *Azure Business Lead for Microsoft
    India*. They used machine learning to analyze historical cricket games and thereby
    provide a continually improving Duckworth-Lewis calculation.
  prefs: []
  type: TYPE_NORMAL
- en: You can read his article at the following link—[https://azure.microsoft.com/en-us/blog/improving-the-d-l-method-using-machine-learning/](https://azure.microsoft.com/en-us/blog/improving-the-d-l-method-using-machine-learning/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a closer look at the application structure. Expanding the `Scripts`
    folder, you will notice that the application uses jQuery and Bootstrap:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/473de118-1184-455a-9a14-86930a820014.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Expanding the `Content` folder, you will see the CSS files in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62e33e7b-96ef-42a3-8da5-5689289bd1bb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that there is a `custom.css` file in this folder that I added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This CSS file basically styles the buttons and some other text font on the form.
    There is nothing complicated about this CSS. The reason for the Bootstrap, jQuery, JavaScript,
    and CSS files is to enable the Bootstrap functionality on the web page.
  prefs: []
  type: TYPE_NORMAL
- en: To see Bootstrap in action, we will use Chrome to run the web application.
  prefs: []
  type: TYPE_NORMAL
- en: The version of Chrome used for this book was Version 60.0.3112.90 (Official
    Build) (64-bit).
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the Cricket Score Tracker Bootstrap web application by going to Debug on
    the menu and clicking on Start Without Debugging or by pressing *Ctrl* + *F5*.
    When the web application has loaded in Chrome, press *Ctrl* + *Shift* + *I* to
    open the developer tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6931fb6e-bc77-4d29-8e6b-0bcb05c5bdc4.png)'
  prefs: []
  type: TYPE_IMG
- en: At the top left of the screen, click on the Toggle device toolbar button or
    press *Ctrl* + *Shift* + *M*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Chrome will then render the application as it would look on a mobile device.
    From the toolbar to the top, you will see that the application has been rendered
    as it would appear on an iPhone 6 Plus:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f16a8689-f7ad-4465-b426-72538c93894b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking on the device type, you can change the device you want to render the
    page for. Changing it to an iPad Pro renders the page accordingly. You can also
    simulate the rotation of the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f466ea4f-806e-41b5-81de-c3696caf128b.png)'
  prefs: []
  type: TYPE_IMG
- en: This feature is very powerful and allows modern web developers to test the responsiveness
    of their web applications. If something doesn't look quite right after you have
    rendered your application for a particular device, you need to go and investigate
    where you went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, the devices supported were:'
  prefs: []
  type: TYPE_NORMAL
- en: BlackBerry Z30 and PlayBook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Galaxy Note 3, Note II, S3, and S5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kindle Fire HDX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LG Optimus L70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Laptop with HiDPI screen and MDPI screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Laptop with touch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft Lumina 550 and 950
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nexus 7, 6, 5, 4, 10, 5X, and 6P
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nokia Lumina 520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nokia N9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: iPad Mini
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: iPhone 4, 5, 6, and 6 Plus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: iPad and iPad Pro
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To add devices, go to the bottom of the device menu. Following the separator,
    there is an Edit... menu item. Clicking that will take you to the Emulated Devices
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the Emulated Devices screen, you will notice that there are additional
    Settings to the right of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/816cbc41-8bdd-4247-b941-06be608bb54a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'One that stands out for a developer should be the Throttling setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0430460b-e316-4064-813a-dff88ef69e44.png)'
  prefs: []
  type: TYPE_IMG
- en: As the name suggests, Throttling allows you to test your application as if it
    were running on a slower connection. You can then test functionality and ensure
    that your web application is as optimized as possible to allow it to work well
    on slower connections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Swing back to the Solution Explorer in Visual Studio 2017 and have a look at
    the folders called `BaseClasses`, `Classes`, and `Interfaces`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/252af8f1-e776-45f9-9554-3497d45a8f46.png)'
  prefs: []
  type: TYPE_IMG
- en: These folders contain the crux of this whole chapter. It is here where we will
    see what OOP is all about and how OOP works to provide a better approach to modeling
    a real-world scenario (a cricket match) in code.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As briefly mentioned earlier, OOP provides a modular approach to writing self-contained
    units of code. The concept of OOP centers around what we call the **four pillars
    of object-oriented programming**.
  prefs: []
  type: TYPE_NORMAL
- en: 'They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The order doesn't really matter, but I always write the four pillars in this
    order because I use the mnemonic **A PIE** to remember each one. Let's discuss
    each of these concepts in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An abstraction describes what something should do without actually showing
    you how to do it. According to the Microsoft documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '"An abstraction is a type that describes a contract but does not provide a
    full implementation of the contract."'
  prefs: []
  type: TYPE_NORMAL
- en: Included as examples of abstractions are **abstract classes** and **interfaces**.
    Examples of abstractions in the .NET Framework include `Stream`, `IEnumerable<T>`,
    and `Object`. If the topic of abstraction seems a bit fuzzy now, don't worry.
    I will go into much more detail in the section on encapsulation and the difference
    between encapsulation and abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might hear of polymorphism referred to as the third pillar of OOP. But if
    I wrote it in that order above, my mnemonic would no longer work!
  prefs: []
  type: TYPE_NORMAL
- en: 'Polymorphism is a Greek word that refers to something that has many shapes
    or forms. We will see an example of this in the *Cricket Score Tracking* app later
    on. Just remember that it has two distinct aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: During runtime, a class that is derived from a base class may be treated as
    an object of the class it inherits. This is seen in parameters, collections, and
    arrays.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The base class can define **virtual methods** that the derived class would then
    override. The derived class then provides their own implementation of the overridden
    methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism is a very powerful feature in OOP.
  prefs: []
  type: TYPE_NORMAL
- en: Compile-time polymorphism versus run-time polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we go further, let me pause for a minute and explain the previous two
    bullet points on polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: When we say **compile-time polymorphism**, we are saying that we will be declaring
    methods with the same name but with different signatures. Therefore, the same
    method can perform different functions based on the signature (parameters) it
    receives. This is also known as early binding, overloading, or static binding.
  prefs: []
  type: TYPE_NORMAL
- en: When we say **run-time polymorphism**, we are saying that we will be declaring
    methods with the same name and with the same signature. In a base class, for example,
    the method is overridden by the method in a derived class. This is achieved by
    what we call inheritance and by using the `virtual` or `override` keywords. Run-time
    polymorphism is also known as *late binding*, *overriding*, or *dynamic binding*.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to be able to create your own classes that reuse, extend, and modify
    the behavior that the base class defines is called **inheritance**. Another important
    aspect to understand is that a derived class can only directly inherit a single
    base class.
  prefs: []
  type: TYPE_NORMAL
- en: Does this then mean that you can only inherit the behavior defined in a single
    base class? Well, yes and no. Inheritance is transitive in nature.
  prefs: []
  type: TYPE_NORMAL
- en: 'To explain this, imagine that you have three classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Person`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pedestrian`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Driver`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Person` class is the base class. `Pedestrian` inherits from the `Person`
    class and therefore `Pedestrian` inherits the members declared in the `Person`
    class. The `Driver` class inherits from the `Pedestrian` class and therefore `Driver`
    inherits the members declared in `Pedestrian` and `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e123f4c-baf2-4cb9-af71-e25b62f56cb4.png)'
  prefs: []
  type: TYPE_IMG
- en: This is what is meant when we say that inheritance is transitive. You can only
    inherit from a single class, but you get all the members that the class you inherit
    from, inherits itself. You can only inherit from a single class, but you get all
    the members that the class you are inheriting from, inherits from its base class.
    Put another way, the `Driver` class can only inherit from a single base class
    (in the preceding image, the `Pedestrian` class). This means that because the
    `Pedestrian` class inherits from the `Person` class, and the `Driver` class inherits
    from the `Pedestrian` class, that the `Driver` class also inherits the members
    in the `Person` class.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Simply put, this means that the inner workings of the class (the implementation
    details) are not necessarily shared with outside code. Remember that we mentioned
    earlier that a class is something that you just want to use and expect it to work.
    The class exposes what it needs to to the calling code, but it maintains tight
    control over the inner workings it implements.
  prefs: []
  type: TYPE_NORMAL
- en: You can, therefore, hide the variables, properties, and methods by scoping them
    as `private`. This way, you protect the data contained inside the class from accidental
    corruption.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation versus abstraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s pause for a minute again to have a look at this concept, as it confuses
    developers (and it is a bit confusing, so examples help a lot). Part of the problem
    stems from the definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Abstraction**: only showing what is necessary'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encapsulation**: hiding complexity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we had to think of a basic class to encrypt some text, we''d need to take
    a minute to decide exactly what the class must do. I would imagine that the class
    needs to:'
  prefs: []
  type: TYPE_NORMAL
- en: Take a string value for the text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have a method to encrypt the text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, let''s code this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'I also know that if I wanted to encrypt some text, that I would need a randomly
    generated byte array to salt the text to be encrypted. Let''s add that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, taking a look at the class again, I realize that the encrypted text will
    need to be saved in a database. So, I add a method to do just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If we had to implement this class, it would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, but now we see that there is a problem. The `salt` needs to be used by
    the encryption method, so naturally we would think to add a parameter to the `Encrypt()`
    method to take the `salt`. We would therefore do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It is here that the code starts to become a bit blurred. We are calling a method
    on the class to generate a `salt`. We are then passing the `salt` we generated
    from the class, back to the class. Imagine a class with many more methods. Which
    methods need to be called when, and in what order?
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s take a step back and think. What exactly are we wanting to do here?
    We want to encrypt some text. Therefore, we just want the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is what we call **abstraction**. Looking back at the definition of abstraction,
    what we are doing in code fits with the definition because we are only showing
    what is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then what about the other methods in the class? Well, quite simply put...make
    them `private`. The developer implementing your class does not need to know how
    to encrypt a string of text. The developer implementing your class just wants
    to encrypt the string and have it saved. The code can then be **encapsulated**
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The code that calls the encrypt class is now also much simpler. It looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Again, this fits with the definition of **encapsulation**, which is to hide
    complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the code in the preceding encryption example does not have
    any implementation. I was only illustrating a concept here. You are free to add
    your own implementation, should you want to.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, do not confuse abstraction with abstract classes. These are different
    things. Abstraction is a way of thinking. We will take a look at abstract classes
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: So, take a 5-minute break, grab some fresh air or a cup of coffee, come back,
    and buckle up! It's about to get interesting.
  prefs: []
  type: TYPE_NORMAL
- en: Classes in Cricket Score Tracker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Taking what we have already learned about the four pillars of OOP, we will have
    a look at the areas in our application that make use of these concepts to provide
    the building blocks of *Cricket Score Tracker*.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open up the `BaseClasses` folder and double click on the `Player.cs` file.
    You will see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is our **abstract class**. The `abstract` modifier in the class declaration
    and the properties tells us that this thing we are going to modify has missing
    or incomplete implementation. It, therefore, is only intended for use as a base
    class. Any member marked as abstract must be implemented by classes that are derived
    from our `Player` abstract class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The abstract modifier is used with:'
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indexers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we had to include a method called `CalculatePlayerRank()` in our abstract
    `Player` class, then we would need to provide an implementation of this method
    in any class that is derived from `Player`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, in the `Player` abstract class, this method would be defined as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In any derived classes, Visual Studio 2017 will be running code analyzers to
    determine if all the members of the abstract class have been implemented by the
    derived classes. When you let Visual Studio 2017 implement the abstract class
    in a derived class, it is defaulted with `NotImplementedException()` in the method
    body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is done because you haven't actually provided any implementation for the
    `CalculatePlayerRank()` method yet. To do this, you need to replace `throw new
    NotImplementedException();` with actual working code to calculate the rank of
    the current player.
  prefs: []
  type: TYPE_NORMAL
- en: It is interesting to note is that while `NotImplementedException()` is within
    the body of the `CalculatePlayerRank()` method, it does not warn you that the
    method isn't returning an int value.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes can be seen as a blueprint of what needs to be done. The way
    you do it is up to you as a developer.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open up the `Interfaces` folder and have a look at the `IBatter.cs` and `IBowler.cs`
    files. The `IBatter` interface looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at the `IBowler` interface, you will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'An interface will only contain the signatures of methods, properties, events,
    or indexers. If we had to add a method to the interface to calculate the spin
    of the ball, it would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'On the implementation, we would see the code implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The next logical question would probably be what the difference is between an
    **abstract class** and an **interface**. Let's turn to the excellent Microsoft
    documentation at—[https://docs.microsoft.com/en-us/](https://docs.microsoft.com/en-us/).
  prefs: []
  type: TYPE_NORMAL
- en: After opening Microsoft Docs, try the dark theme. The theme toggle is to the
    right of the page, just below the Comments, Edit, and Share links. It's really
    great for us night owls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Microsoft sums up an interface very nicely with the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: An interface is like an abstract base class. Any class or struct that implements
    the interface must implement all its members.
  prefs: []
  type: TYPE_NORMAL
- en: Think of interfaces as verbs; that is to say, interfaces describe some sort
    of action. Something that a cricket player does. In this case, the actions are
    batting and bowling. The interfaces in *Cricket Score Tracker* are therefore `IBatter`
    and `IBowler`. Note that convention dictates that interfaces begin with the letter
    `I`.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes on the other hand, act as a noun that tells you what something
    is. We have Batsmen and All-Rounders. We can say that both these cricketers are
    players. That is the common noun that describes the cricketers in a cricket match.
    Therefore, the `Player` abstract class makes sense here.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The classes used in the *Cricket Score Tracker* app are then created in the
    `Classes` folder. Here you will see a `Batsman` class and an `AllRounder` class.
    For the sake of simplicity, I only created these two classes. In cricket, all
    bowlers must bat, but not all batsmen have to bowl. You then get bowlers who can
    bowl and bat equally well, and they are defined as all-rounders. This is what
    I have modeled here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the `Batsman` class first. We want a batsman to have
    the abstract properties of a player, but he must also be a batter. Our class,
    therefore, inherits the `Player` base class (remember, we can only inherit from
    a single class) and implements the properties of the `IBatter` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/831a0232-6c6d-4224-b12e-78c3279d9347.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The class definition, therefore, reads as a `Batsman` public class, inherits
    a `Player`, and implements the `IBatter` interface. The `Batsman` class, therefore,
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `Batsman` class implements the properties of the abstract class
    and the interface. Also note that, at this point in time, I do not want to add
    an implementation for the `CalculatePlayerRank()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the `AllRounder` class. We want the all-rounders to also
    have the abstract properties of a player, but they must also be a batter and a
    bowler. Our class, therefore, inherits the `Player` base class but now implements
    the properties of the `IBatter` and the `IBowler` interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3e9d4d8-759e-4f37-985a-6deca302a550.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The class definition, therefore, reads as an `AllRounder` public class, inherits
    a `Player`, and implements the `IBatter` and `IBowler` interfaces. The `AllRounder`
    class, therefore, looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You will notice once again that I didn't add in any implementation for the `CalculatePlayerRank()`
    method. Because the abstract class defines this method, all classes that inherit
    from the abstract class must implement this method.
  prefs: []
  type: TYPE_NORMAL
- en: You now also see that this `AllRounder` class must implement the properties
    of both `IBowler` and `IBatter`.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's have a look how we use the classes to create the *Cricket Score Tracker*
    app. The buttons below the Batters section and Bowler section are used to select
    batsmen and a bowler for the specific over.
  prefs: []
  type: TYPE_NORMAL
- en: 'While each button is taken care of by its own click event, they all call the
    exact same method. We will have a look at how that is accomplished in a moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/24028b13-060e-4243-a892-b968a5e3f407.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking on either button under the Batsmen section will display a modal dialog
    with a drop-down list populated with the batsmen in the team:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/56998740-9ac9-4b01-a6cc-f02e7f824cb1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, when we click on the Select Bowler button, we will see the exact
    same modal dialog screen displayed. This time, however, it will be a list of bowlers
    displayed for selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1d699c73-6536-43c9-bc12-bd70d4f5b03d.png)'
  prefs: []
  type: TYPE_IMG
- en: Selecting players from the drop-down lists will populate the text on the button
    clicked with that player's name. This then sets up the current over with the players
    involved.
  prefs: []
  type: TYPE_NORMAL
- en: Take note that we are talking in terms of the classes here. We have players,
    but they can be batsmen or all-rounders (bowlers).
  prefs: []
  type: TYPE_NORMAL
- en: 'Each player will be either a batsman or a bowler (`AllRounder` class):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd46254e-7dde-40a7-b76a-eb1e22968cbd.png)'
  prefs: []
  type: TYPE_IMG
- en: So how did we manage to make a single method return two different players? I
    used a method called `GeneratePlayerList()`. This method is responsible for creating
    the player list in the modal dialog that pops up. That is all that method is responsible
    for. In other words, it performs no other function apart from generating the player
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how the `Default.aspx.cs` file is created. For simplicity''s
    sake, I just created two lists for each team. I also created an `enum` for the
    player selection. The code looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In reality, however, you would probably make the list names `team1` and `team2`,
    and allow the user to select the teams from a setup screen for this game. I have
    not added this functionality as I am merely trying to illustrate the concepts
    of OOP here.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Page_Load`, I then populate the lists with players, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Again, for simplicity, I have hard-coded the player names and manually added
    them to the lists.
  prefs: []
  type: TYPE_NORMAL
- en: The `Get_India_Players()` method is identical to that of the `Get_SA_Players()`
    method. You can then just copy the method and change the names to your favorite
    cricket players or favorite cricket teams.
  prefs: []
  type: TYPE_NORMAL
- en: In reality, you would probably read this from a database of teams and players.
    So instead of `Get_SA_Players()` and `Get_India_Players()`, you would have a single
    `Get_Players()` method that would be responsible for reading the players into
    the lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, looking at the `Get_SA_Players()` method, we simply do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice now that the `players` list is of type `List<Player>`, and that we are
    adding `Batsman` and `AllRounder` types to it. This is what the term **polymorphism**
    means. Remember that one of the aspects of polymorphism we mentioned earlier was:'
  prefs: []
  type: TYPE_NORMAL
- en: During run time, a class that is derived from a base class may be treated as
    an object of the class it inherits. This is seen in parameters, collections or
    arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, because `Batsman` and `AllRounder` inherit from the `Player` abstract
    class, they are treated as objects of `Player` for the `List<Player>`.
  prefs: []
  type: TYPE_NORMAL
- en: If you swing back to the section on polymorphism earlier in the chapter, you
    will see that this is an example of run-time polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving back to the logic to select the batsman or bowler, we look to a method
    to generate the player list called `GeneratePlayerList()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that the method takes a `List<Player>` argument as well as a
    `Type`. The method checks whether `type` is a `Batsman` or `AllRounder` and based
    on that, reads the first and last names of the players in the list.
  prefs: []
  type: TYPE_NORMAL
- en: I believe that this method can be simplified even further, but I wanted to illustrate
    the concept of polymorphism at work.
  prefs: []
  type: TYPE_NORMAL
- en: The actual aim is to try and write the least amount of code for the maximum
    required effect. As a rule of thumb, some developers maintain that if a method's
    length is longer than the code page you are looking at in the IDE, you need to
    do some refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: Having less code and smaller methods allows the code to be easier to read and
    understand. It also allows better maintainability of that code because smaller
    sections of code are easier to debug. In fact, you might experience fewer bugs
    because you are writing smaller, more manageable pieces of code.
  prefs: []
  type: TYPE_NORMAL
- en: Many years ago, I was part of a team that worked on a project for a large corporation
    in Cape Town. They had a systems architect called *Uthmaan Hendrix*. I will never
    forget this guy. He was the humblest bloke I had ever come across. The documentation
    he created for the system we worked on was simply incredible. It took almost all
    the think work out of the code we had to write. The developers didn't have to
    decide how to architect the project at all.
  prefs: []
  type: TYPE_NORMAL
- en: This project implemented SOLID principles, and understanding the code was really
    easy. I still have a copy of that document. I still refer to it from time to time.
    Unfortunately, not all developers have the luxury of having a dedicated systems
    architect on the project they are working with. It is, however, good for developers
    to understand what the SOLID design principles are.
  prefs: []
  type: TYPE_NORMAL
- en: SOLID design principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This brings us to another interesting concept in OOP called **SOLID** design
    principles. These design principles apply to any OOP design and are intended to
    make software easier to understand, more flexible, and easily maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The term SOLID is a mnemonic for:'
  prefs: []
  type: TYPE_NORMAL
- en: Single responsibility principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open/closed principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Liskov substitution principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface segregation principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency inversion principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will only take a look at the first two principles—the **single
    responsibility principle** and the **open/closed principle**. Let's look at the
    single responsibility principle next.
  prefs: []
  type: TYPE_NORMAL
- en: Single responsibility principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Simply put, a module or class should have the following characteristics only:'
  prefs: []
  type: TYPE_NORMAL
- en: It should do one single thing and only have a single reason to change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should do its one single thing well
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The functionality provided needs to be entirely encapsulated by that class or
    module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What is meant when saying that a module must be responsible for a single thing?
    The Google definition of a module is:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Each of a set of standardized parts or independent units that can be used
    to construct a more complex structure, such as an item of furniture or a building."'
  prefs: []
  type: TYPE_NORMAL
- en: From this, we can understand that a module is a simple building block. It can
    be used or reused to create something bigger and more complex when used with other
    modules. In C# therefore, the module does closely resemble a class, but I will
    go so far as to say that a module can also be extended to be a method.
  prefs: []
  type: TYPE_NORMAL
- en: The function that the class or module performs can only be one thing. That is
    to say that it has a **narrow responsibility**. It is not concerned with anything
    else other than doing that one thing it was designed to do.
  prefs: []
  type: TYPE_NORMAL
- en: If we had to apply the single responsibility principle to a person, then that
    person would be only a software developer, for example. But what if a software
    developer also was a doctor and a mechanic and a school teacher? Would that person
    be effective in any of those roles? That would contravene the single responsibility
    principle. The same is true for code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having a look at our `AllRounder` and `Batsman` classes, you will notice that
    in `AllRounder`, we have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In `Batsman`, we have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Using what we have learned about the single responsibility principle, we notice
    that there is an issue here. To illustrate the problem, let''s compare the code
    side by side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/25126aec-6d16-4015-be30-41596360896f.png)'
  prefs: []
  type: TYPE_IMG
- en: We are essentially repeating code in the `Batsman` and `AllRounder` classes.
    This doesn't really bode well for single responsibility, does it? I mean, the
    one principle is that a class must only have a single function to perform. At
    the moment, both the `Batsman` and `AllRounder` classes are taking care of calculating
    strike rates. They also both take care of calculating the player rank. They even
    both have exactly the same code for calculating the strike rate of a batsman!
  prefs: []
  type: TYPE_NORMAL
- en: The problem comes in when the strike rate calculation changes (not that it easily
    would, but let's assume it does). We now know that we have to change the calculation
    in both places. As soon as the developer changes one calculation and not the other,
    a bug is introduced into our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s simplify our classes. In the `BaseClasses` folder, create a new abstract
    class called `Statistics`. The code should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Classes` folder, create a new derived class called `PlayerStatistics`
    (that is to say it inherits from the `Statistics` abstract class). The code should
    look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You will see that the `PlayerStatistics` class is now solely responsible for
    calculating player statistics for the player's rank and the player's strike rate.
  prefs: []
  type: TYPE_NORMAL
- en: You will see that I have not included much of an implementation for calculating
    the player's rank. I briefly commented the code on GitHub for this method on how
    a player's rank is determined. It is quite a complicated calculation and differs
    for batsmen and bowlers. I have therefore omitted it for the purposes of this
    chapter on OOP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your Solution should now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/61d01824-3ddf-4b48-b0bb-9888f267f147.png)'
  prefs: []
  type: TYPE_IMG
- en: Swing back over to your `Player` abstract class and remove `abstract public
    int CalculatePlayerRank();` from the class. In the `IBowler` interface, remove
    the `double BowlerStrikeRate { get; }` property. In the `IBatter` interface, remove
    the `double BatsmanBattingStrikeRate { get; }` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Batsman` class, remove `public double BatsmanBattingStrikeRate` and
    `public override int CalculatePlayerRank()` from the class. The code in the `Batsman`
    class will now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the `AllRounder` class, remove the `public enum StrikeRate { Bowling
    = 0, Batting = 1 }` enum as well as the `public double BatsmanBattingStrikeRate`
    and `public double BowlerStrikeRate` properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, remove the `private double CalculateStrikeRate(StrikeRate strikeRateType)`
    and `public override int CalculatePlayerRank()` methods. The code for the `AllRounder`
    class now looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Looking back at our `AllRounder` and `Batsman` classes, the code is clearly
    simplified. It is definitely more flexible and is starting to look like a well-constructed
    set of classes. Give your solution a rebuild and make sure that it is all working.
  prefs: []
  type: TYPE_NORMAL
- en: Open/closed principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, we had a look at the **single responsibility principle**. Hand in
    hand with this is the **open/closed principle**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bertrand Meyer stated that software entities (classes, modules, functions,
    and so on):'
  prefs: []
  type: TYPE_NORMAL
- en: Should be open for extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should be closed for modification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What exactly does this mean? Let's take the `PlayerStatistics` class as an example.
    Inside this class, you know that we have a method to calculate the strike rate
    of a particular player. This is included in the class because it inherits from
    the `Statistics` abstract class. That is correct, but the fact that the `CalculateStrikeRate(Player
    player)` method caters for two player types (all-rounders and batsmen) is already
    a hint of a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume that we have introduced new player types—different bowler types
    (for example, fast bowlers and spin bowlers). In order for us to accommodate the
    new player type, we must change the code in the `CalculateStrikeRate()` method.
  prefs: []
  type: TYPE_NORMAL
- en: What if we wanted to pass through a collection of batsmen to calculate the average
    strike rate between all of them? We would need to modify the `CalculateStrikeRate()`
    method again to accommodate this. As time goes by and the complexities increase,
    it will become very difficult to keep on catering for different player types that
    need the strike rate calculation. This means that our `CalculateStrikeRate()`
    method is **open for modification** and **closed for extension**. This is in contravention
    of the principles stated previously in the bullet list.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what can we do to fix this? In truth, we are already halfway there. Start
    by creating a new `Bowler` class in the `Classes` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: You can see how easy it is to construct new player types—we have only to tell
    the class that it needs to inherit the `Player` abstract class and implement the
    `IBowler` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to create new player statistics classes—namely, `BatsmanStatistics`,
    `BowlerStatistics`, and `AllRounderStatistics`. The code for the `BatsmanStatistics`
    class will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add the `AllRounderStatistics` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we add the new player type statistics class called `BowlerStatistics`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Moving the responsibility of calculating the strike rates for all players away
    from the `PlayerStatistics` class makes our code cleaner and more robust. In fact,
    the `PlayerStatistics` class is all but obsolete.
  prefs: []
  type: TYPE_NORMAL
- en: By adding another player type, we were able to easily define the logic of this
    new player by implementing the correct interface. Our code is smaller and easier
    to maintain. We can see this by comparing the previous code for `CalculateStrikeRate()`
    with the new code we wrote.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate more clearly, take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is much more complex and less maintainable than the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The benefit of creating a `BowlerStatistics` class, for example, is that you
    know that throughout the class we are only dealing with a bowler and nothing else...a
    single responsibility that is open for extension without having to modify the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the principles of SOLID programming are great guidelines to follow, very
    few systems that you come across will actually implement them throughout the application.
    This is especially true if you inherit a system and that system has been in production
    for a number of years.
  prefs: []
  type: TYPE_NORMAL
- en: I will admit that I have come across applications designed with SOLID in mind.
    These were really easy to work on and the bar is set high for other developers
    in a team to maintain the same level of code quality.
  prefs: []
  type: TYPE_NORMAL
- en: Peer code reviews and a thorough understanding of SOLID principles by every
    developer on the team ensure that the same level of code is maintained.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has had a lot going on. Apart from laying the foundation for a
    really nice *Cricket Score Tracking* app, we have had a look at what OOP really
    means.
  prefs: []
  type: TYPE_NORMAL
- en: We had a look at abstraction and the difference between abstraction and encapsulation.
    We discussed polymorphism, and we looked at what run-time polymorphism is versus
    compile-time polymorphism. We also had a look at inheritance, which was creating
    a derived class by inheriting a base class.
  prefs: []
  type: TYPE_NORMAL
- en: We then discussed classes, abstract classes (which are not to be confused with
    abstraction), and interfaces. The difference between abstract classes and interfaces
    were (hopefully) clearly explained. Remember, an interface acts as a verb or action
    whereas an abstract class acts as a noun which states what something is.
  prefs: []
  type: TYPE_NORMAL
- en: In the last section, we briefly discussed SOLID design principles and highlighted
    the single responsibility and open/closed principles.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be delving into cross-platform development using
    .NET Core. You will see that .NET Core is a very important skill to master and
    that it will be with us for a long time to come. As .NET Core and the .NET Standard
    evolve, developers will be empowered to create—well, I will leave that up to you
    to imagine. The sky's the limit.
  prefs: []
  type: TYPE_NORMAL
