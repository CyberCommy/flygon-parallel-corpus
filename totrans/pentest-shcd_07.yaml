- en: Exploit Development – Part 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploit development, here we are! Now we are starting the real stuff! In this
    chapter, we will walk through how to deal with exploits fuzzing. We will also
    learn techniques in exploit development, such as controlling the instruction pointer
    and how to find a place to put our shellcode in.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the topics that we will cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing and controlling instruction pointer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Injecting a shellcode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A complete example of buffer overflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start!
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing and controlling instruction pointer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we injected characters, but we need to know the exact
    offset of the instruction pointer, which was injecting 24 As. The idea of finding
    the exact offset of the RIP register is injecting a specific sequence length of
    a pattern, and based on the last element on the stack, calculating the offset
    of the RIP register. Don't worry, you will understand in the next example. So
    how can we determine the exact offset of the RIP register? We have two tools for
    this, the Metasploit Framework and PEDA, and we will talk about both of them.
  prefs: []
  type: TYPE_NORMAL
- en: Using Metasploit Framework and PEDA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we will use the Metasploit Framework to create the pattern, and to do
    so we need to navigate to this location: `/usr/share/metasploit-framework/tools/exploit/`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, how to create a pattern? We can create one using `pattern_create.rb`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take an example using our vulnerable code but with a bigger buffer,
    let''s say `256`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s compile it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we will use GDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we calculate the offset of the RIP location. So, first let''s create
    a pattern by using the Metasploit Framework on our attacking machine and inside
    `/usr/share/metasploit-framework/tools/exploit/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous command, we generated a pattern with a length of `300` and
    saved it in a file with the name `pattern`. Now copy this file to our victim machine
    and use this pattern as input inside GDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding command can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00285.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The code stopped, as expected, with an error. Now, we need to extract the last
    element in the stack, because the next element after that should overflow the
    RIP register. Let''s see how to get the last element in the stack, using the `x`
    command to print the content of a memory. Let''s take a look at how the `x` command
    works in GDB, using `help x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00286.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s print the last element inside the stack using `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding command can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00287.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The last element in the stack is ;`0x41386941`. You can also use `x/wx $rsp`
    to print a full word from inside the RSP register. Now we need to calculate the
    exact location of the RIP register using `pattern_offset.rb` on our attacking
    machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we specified the query we extracted from the stack; then we specified
    the length of the pattern we used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00288.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'It tells us that the last element in the stack is at location `264`, which
    means that the next six characters should overflow the RIP register:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If our calculation is correct, we should see the 42s in the RIP. Let''s run
    this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, from inside GDB, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding command can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00289.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Our 42s are now in the instruction pointer, which is `bbbbbb` in ASCII.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting shellcode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The RIP now contains our 6 Bs (`424242424242`) and the code has stopped complaining
    about where `0x0000424242424242` is in the memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have succeeded with our exploit so far. This is what our payload looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00290.gif)'
  prefs: []
  type: TYPE_IMG
- en: We need to find a way to inject a shellcode in the As so we can jump to it easily.
    To do so, we need to first inject `0x90` or the NOP instruction, which is NOP,
    just to make sure that our shellcode is injected correctly. After injecting our
    shellcode, we change the instruction pointer (RIP) to any address in the memory
    containing the NOP instruction (`0x90`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then the execution should just pass on all **NOP** instructions until it hits
    the **Shellcode**, and it will start executing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00291.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'This is what our exploit should look like. Let''s try to inject the `execve
    /bin/sh` shellcode (length `32`). Now we need to get any address in the memory
    that contains `0x90`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the new exploit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, from inside GDB, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding command can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00292.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The program stopped. Now, let''s look inside the stack to search for our NOP
    slide by printing `200` hex values from the memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding command can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00293.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We got them! These are our NOP''s instructions that we injected. Also, after
    the NOPs, you can see 32 Cs (`43`), so now we can choose any address in the middle
    of this NOP''s instructions; let''s select `0x7fffffffe2c0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00294.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'This is what the final payload should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the exploit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, from inside GDB, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding command can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00295.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we got the bash prompt inside GDB; let''s try to execute something like
    `cat /etc/issue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00296.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It gave us the content of `/etc/issue`.
  prefs: []
  type: TYPE_NORMAL
- en: It worked!
  prefs: []
  type: TYPE_NORMAL
- en: A complete example of buffer overflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's see a complete example of the buffer overflow. What we need is to
    download and run vulnserver on Windows. Vulnserver is a vulnerable server, where
    we can practice exploit development skills. You can find it at [https://github.com/stephenbradshaw/vulnserver](https://github.com/stephenbradshaw/vulnserver).
  prefs: []
  type: TYPE_NORMAL
- en: 'After downloading it, run it using `vulnserver.exe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00297.gif)'
  prefs: []
  type: TYPE_IMG
- en: Now, it's working and waiting for a connection on port `9999` using netcat.
  prefs: []
  type: TYPE_NORMAL
- en: 'Netcat is a tool used to initiate a connection with a server or listen on a
    port and wait for a connection from another client. Now, let''s use `nc` from
    the attacking machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding command can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00298.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s try fuzzing a parameter, such as `TRUN` (which is a vulnerable
    parameter inside a vulnerable-by-design application). We need to build up a script
    to help us do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try to send `50` As:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00299.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'It didn''t crash. How about `5000` As:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the `./fuzzing.py` command can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00300.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'No reply! Let''s take a look at our Windows machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00301.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The program crashed and it's complaining about memory location `0x41414141`,
    which is our `5000` As. At the second stage, which is controlling the RIP, let's
    create a pattern with a length of `5000` bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'From our attacking machine, navigate to `/usr/share/metasploit-framework/tools/exploit/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding command can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00302.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Copy the output pattern to our exploit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run vulnserver. Then, open the Immunity Debugger as an administrator.
    Navigate to File | Attach and select vulnserver:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00303.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Attach and hit the run program. Then run our exploit, and look at
    what happens inside the Immunity Debugger:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00304.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a look inside the registers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00305.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, the EIP contains `396F4338`. Let''s try to find this pattern from our
    attacking machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding command can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00306.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'So, to control the instruction pointer, we need to inject `2006` As. Then,
    we need 4 bytes to control the EIP register and the rest will be injected as a
    shellcode (`5000-2006-4`); that gives us `2990` characters. Let''s try it to make
    sure we are going in the right direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what our payload should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00307.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Close the Immunity Debugger and start the application again. Then, start the
    exploit code again. We should see Bs injected inside the EIP register:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00308.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'It worked! I''m going to recheck again using the Immunity Debugger. Let''s
    take a look inside the Registers (FPU):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00309.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we have control over the EIP register. Let''s take a look inside the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00310.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, there are our As, then 4 bytes of Bs that overflowed the EIP
    register, and  then `299*0` of Cs .
  prefs: []
  type: TYPE_NORMAL
- en: What we are going to do in the next chapter is inject a shellcode in those Cs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went through fuzzing and how to get the program to crash.
    Then, we saw how to get the exact offset of the RIP register using the Metasploit
    Framework and a very simple method of injecting a shellcode. Finally, we went
    through a complete example of fuzzing and controlling the instruction pointer.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue with our example and see how to find a
    place for a shellcode and make it work. Also, we will learn more techniques in
    the buffer overflow.
  prefs: []
  type: TYPE_NORMAL
