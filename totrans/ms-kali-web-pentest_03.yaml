- en: Chapter 4. Scanning for Vulnerabilities with Arachni
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Web application vulnerability scanners are big businesses. A quick research
    into alternatives will show you that there are literally hundreds of open source
    and commercial scanners, and all of them offer varying coverage of the vuln space
    as well as functions that extend into the different phases of the Pen Test Kill
    chain. As is the case with any trend in security, this explosion in the market
    is a symptom of something else entirely: web applications are, by their very nature,
    easy to access and popular for hackers to exploit. The payoff for a successful
    breach or compromise is massive.'
  prefs: []
  type: TYPE_NORMAL
- en: Most major companies involved in cyber security solutions publish annual reports
    that summarize the past year's events and make predictions of the expected trends
    that will shape the business in the years to come. Verizon, Dell, Cisco, FireEye,
    Symantec, and HP are just some of the more anticipated releases each year. While
    they do not usually deal in technical details and **Tactics,** the **Techniques
    and Procedures** (**TTPs**) of specific threats, they do help shedÂ the light
    on prevailing threat areas, high-level delivery modes, and the perceived motivation
    for any of these changes. A consensus of reports in 2016 and 2017 has noted the
    shift on the part of attackers towards the exploits of user browsers and plugins,
    as well as the advent of *malvertizing*, embedded ads, and frames that contain
    malware or link to sites that do.
  prefs: []
  type: TYPE_NORMAL
- en: 'These trends point to a couple of things. Firstly, users and by extension their
    end-user devices (mobile, laptop, home) are the weakest link in our security story.
    Second, as the same users demand access anytime and anywhere, it becomes difficult
    to secure the elastic perimeter, as there is no longer a perimeter to defend but
    a very fluid environment. Hackers, by their very nature, are going to exploit
    the trust we all put in these new shifts in behavior and corresponding weaknesses;
    hacking the enterprise is more involved and delicate at this point in time, so
    depending on their motivation, the get-rich-quick set is going to shift to the
    path of least resistance: web applications and the application-client paradigm.'
  prefs: []
  type: TYPE_NORMAL
- en: So, what are our customers doing in response? They are starting to purchase
    tools that can help them begin to secure their environment, but only if they are
    wielded correctly. In Kali Linux, we have some fantastic, well-regarded scanners
    that we can use to help our customers better understand their exposure to vulnerabilities
    and better understand their architecture. While we have some great options, it
    is helpful to mix them to ensure that we are covering vectors with multiple tools
    that can complement each other and reduce our blind spots. One of the best such
    tools, and one I am sure you have used in the past if you have conducted web application
    vulnerability scans, is **Arachni**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to see how we can use Arachni for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Crawling web applications effectively for quick initial scans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using active scanning techniques to probe further and uncover more vectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launching scans and trace flows on DOM and JavaScript environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mimicking browser constraints of mobile platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Producing high-quality reports, either as a standalone or as the basis for a
    multi-tool pen test deliverable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Walking intoÂ spider webs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Arachni is an open source scanner that focuses on the recon phase of our penetration
    testing in a different manner than any other tool out there. If you've used Arachni
    without paying attention to what makes it different (just like me), then you may
    find that changing your workflow will greatly improve results. The creator of
    the tool, *Tasos Laskos*, developed the tool to address a couple of opposed goals.
    First, scans can take an excessive amount of time (many hours to even weeks),
    and this makes these scans less than helpful. The time is lost and makes testing
    a more drawn-out process. Second, more data and coverage is a good thing, as it
    enhances accuracy, but it also adds additional time to the test process to complete
    the necessary transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Laskos developed Arachni to reduce the amount of time for a scan while allowing
    the tool to scale such that it is able to process more test vectors efficiently.
    Its timing was improved by employing asynchronous HTTP requests to do the tool's
    bidding and by allowing Arachni to scale across a cluster of systems so that they
    are all processing in parallel. The accuracy goal was enhanced by open sourcing
    the tool and using a Ruby framework that can allow anyone to add new or better
    optimized tests to the tool. The timing, accuracy, and coverage of the testing
    are further improved by machine learning techniques that allow the scanner to
    hone testing vectors used through the results from earlier vectors in the test
    battery. Together, these enhancements make Arachni a formidable scan tool that
    we will explore more deeply for improved testing efficacy and timing.
  prefs: []
  type: TYPE_NORMAL
- en: Optimal Arachni deployment tips
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we are just practicing with Arachni, we would likely invoke a single serverÂ 
    and client hosted on the same Kali Box. The **Web UI Client** executable should
    be running to ensure that Arachni is being operated in the same manner as it would
    be in a real testing scenario. A command-line option is available, but it tends
    to be limited in scale and works best in single-server deployments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Arachni high-level architecture can be seenÂ here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_04_01-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Arachni's architecture is its secret sauce â�� it helps with scale and speed
    alike.
  prefs: []
  type: TYPE_NORMAL
- en: The brain of the operation here is the **Web UI Client** (**arachni_web**).
    It provides the single point of contact that will contact its grid of **Dispatch
    Servers** (**dispatchers**) with initial scan requests. The dispatchers then spawns
    a new **instance** on theÂ **server**.Â  At this point, the Web UI Client will
    be able to communicate directly with the spawned Instance to configure it for
    the appropriate scanning jobs. When an instance is done with its task, The Web
    UI client pulls the data and stores it, while the instance simply goes away, returning
    the resources it consumed to the operating system for future instances or other
    software tasks altogether.
  prefs: []
  type: TYPE_NORMAL
- en: As we move into production testing, we can scale the deployment to take advantage
    ofÂ additional resources on other servers in our grid, and this will not only
    allow us to run multiple scans, but also accommodate teams of users while consolidating
    the data gathered in a central database on the Web UI Client. **SQLite3** is the
    default option, but if you will ever turn this installation into a grid or large-scale
    installation, it is highly recommended you start with PostgreSQL instead. The
    documentation for how to do this is located here:Â [https://github.com/Arachni/arachni-ui-web/wiki/database](https://github.com/Arachni/arachni-ui-web/wiki/database).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you have selected one database or the other, you are locked in; and changing
    your mind means losing all of your prior data. It is worth the effort to build
    out the PostgreSQL environment up front if you think it will go that way.
  prefs: []
  type: TYPE_NORMAL
- en: Arachni differs from other black-box **Dynamic Application Security Test** (**DAST**)
    scanners, in that it makes heavy use of asynchronous HTTP to conduct its scans.
    This allows each Instance to send HTTP requests to targets in parallel. Because
    you can have multiple scans in progress at the same time, it greatly improves
    the speed with which we can go from initiationÂ to completion. Most scanners spend
    considerable time waiting on scan threads to finish. This is made moreÂ egregiousÂ given
    that these scanners often run a set array of scans and do not tailor their scan
    list on-the-fly like Arachni.
  prefs: []
  type: TYPE_NORMAL
- en: The number of instances that can be supported is really going to depend on the
    number of servers available, their resource availability, and the bandwidth available
    outbound to initiate scans. I would caution that if you are worried about bandwidth,
    it is likely that the generated traffic exceeds non-trivial amounts and should
    be throttled down to avoid impairing the application's performance for real users
    or alerting the security operations folks. Nothing says *I'm here to damage your
    application*Â like a **Distributed Denial of Service** (**DDoS**) attack from
    your application scanner. As they say, with great power comes great responsibility!
  prefs: []
  type: TYPE_NORMAL
- en: An encore for stacks and frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Our first step in any active recon could very well just be to attempt a scan,
    but it's a good idea before taking on any job or task to simply browse to the
    site's main page first. Using browser plugins such asÂ **Wappalyzer** ([https://wappalyzer.com](https://wappalyzer.com)),
    we can easily see an initial footprint of the website and discover the platform
    or framework a web application is built on (as discussed in [Chapter 1](000.html#)*,
    Common Web Applications and Architectures)*. We'll start our detailed Arachni
    best practices using the **Damn Vulnerable Web Application** (**DVWA**), so let's
    see what the browser and Wappalyzer can tell us before we dive into a scan!
  prefs: []
  type: TYPE_NORMAL
- en: As seen in following screenshot, DVWA is apparently running on a Linux operating
    system, employs Apache as the web server, MySQL as the database, and a mix of
    scripting languages are employed (Python, Perl, Ruby, and PHP). This very much
    looks like your typical **LAMP** stack, and we'll craft a scan that realizes these
    details and helps to narrow the scan time. Other traditional stacks hosted on
    Windows and Linux/Unix alike using languages such as PHP or ASP.NET are giving
    way to newer stacks based on Ruby, Java, JavaScript, and Python that specialize
    in mobile services, super-scalable architectures, and other modern concerns have
    sprung up such that there are too many to mention. To add to the fun, web stack
    or framework means something different to everybody. The days of HTML being statically
    coded are giving way to a new approach centered around an elementÂ calledÂ the
    **Document Object Model** (**DOM**), where the scripting languages (JavaScript,
    Python, and so on) dynamically build the HTML or XML presented in the browser.Â No
    matter what vintage of stack is in use, beingÂ able to quickly ascertain what
    is running, can point us in the right direction for **Common Vulnerabilities and
    Exploits (CVEs)** and other characteristics we can leverage in our testing.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_04_02.png)'
  prefs: []
  type: TYPE_IMG
- en: Scans are more productive when we let our browser help with a quick footprint
    of the target.
  prefs: []
  type: TYPE_NORMAL
- en: DVWA also uses OpenSSL, which, after the last two or three years, is well worth
    a careful look, as it has been subjected to several high-profile vulnerabilities
    such asÂ **Heartbleed** and others ([https://www.openssl.org/news/vulnerabilities.html](https://www.openssl.org/news/vulnerabilities.html))
    that dominated news outlets worldwide. It is always pretty impressive for something
    so technical to capture headlines, but we're after even the small stuff â�� those
    are just as easy to exploit and often go unaddressed in favor of higher-profile
    vulnerabilities. The previous screenshot in Firefox with the Wappalyzer plugin
    showed us all of these interesting nuggets of information.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a good insight into the stacks running on popular sites, you can learn more
    about it atÂ [https://stackshare.io](https://stackshare.io/). If you want to see
    just how many stacks and perspectives there are, this Reddit thread is educational,
    impressive, and available atÂ [https://www.reddit.com/r/webdev/comments/2les4x/what_frameworks_do_you_use_and_why_are_they/](https://www.reddit.com/r/webdev/comments/2les4x/what_frameworks_do_you_use_and_why_are_they/)Â .
  prefs: []
  type: TYPE_NORMAL
- en: The Arachni test scenario
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: The DVWA we're using is included in the **OWASP BWA** image, which is located
    in my lab at the addressÂ `https://172.16.30.131/dvwa/`. Our Kali box is on the
    same subnet (`172.16.30.133`), and we're interested in shortening the scan time
    over the default profile. We'll use this very simple topology in figure followingÂ to
    show off some of the advanced moves Arachni can make with a little bit of additional
    effort and input over a base scan.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_04_03a.png)'
  prefs: []
  type: TYPE_IMG
- en: Simple Arachni Test Scenario
  prefs: []
  type: TYPE_NORMAL
- en: Profiles for efficiency
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most pen tester's early experience with Arachni usually involves running scans
    with the default settings, which run a comprehensive list of threat vectors past
    the target environment. This is a great way to see what Arachni can do, but the
    OSINT gathered in the recon phase or even through browsing, as we've just seen,
    gives us some great information that can help us narrow the search field. We can
    leverage this information to craft a custom profile, which, as far as Arachni
    is concerned, is where most of the bells and whistles are located.
  prefs: []
  type: TYPE_NORMAL
- en: Why should we do this? Eliminating vectors we know not to be of interest (unused
    database tests, operating system vectors, and so on) can both reduce the scan
    times and avoid crushing the target with excessive requests. This information
    can also steer us toward a deeper investigation at lower speeds as well. We'll
    walk through this process together and identify some options worth considering.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new profile
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s build a profile for systems running one of the most common stacks. The
    LAMP stack we see running on the DVWA site still runs theÂ majority of web applications
    with **Windows/IIS/SQL/ASP.NET** (**WISA**) being a close second, so this is a
    good profile to have on hand. We''ll want to click on the **`+`**Â button in the
    **`Profiles`** menu at the top, as seenÂ here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_04_03.png)'
  prefs: []
  type: TYPE_IMG
- en: Most Arachni's is on by default â�� we can tailor or focus based on Recon &
    OSINT using Profiles.
  prefs: []
  type: TYPE_NORMAL
- en: This will start us at the **`Top`** of the **`Profiles`** navigation menu in
    figure following, located at the left of the browser window (1). We'll want to
    decide on a profile name (2), enter a description to help track the intent (3,
    a good idea for teams and large production grids), and the users (4) who can access
    it; selected **`Global`**. It is important to note that these profiles are local
    to the Web UI Client, so your teammates will need to be able to reach the portal
    from their location.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_04_04.png)'
  prefs: []
  type: TYPE_IMG
- en: Not the most exciting part, but the naming conventions and documentation make
    life easier.
  prefs: []
  type: TYPE_NORMAL
- en: Scoping and auditing options
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The **scope** Section customizes things a little too finely to be used in a
    profile that is meant to fit multiple applications. This section includes options
    to scan HTTPS only, set path and subdomain limits, exclude paths based on strings,
    or limit the DOM tree depth. If you are conducting a white-box test or doing an
    internal penetration testing of the same application as a part of the SDLC, these
    options are a fantastic way to help focus the testing on the impacted areas rather
    than cast so large a net that the scan is prolonged and contains extraneous results.
    Keeping this in mind, let's move on.
  prefs: []
  type: TYPE_NORMAL
- en: We'll set our high-level scanning strategy with theÂ **audit** options in figure
    following. When we are testing a server, our scanning can be made much more efficient
    if we omit resource-intensive elements that delay our progress unnecessarily.
    If we have a site we know to be using HTTP **GETs** and **POSTs** equally, we
    can just test with one of those queries. Testing processes are different for all
    of us â�� we may overlap our Arachni scans with Burp Suite or OWASP ZAP scans
    and no longer need to scan headers or process cookies; we'll be covering this
    in [Chapter 5](000.html#), *Proxy Operations with OWASP ZAP and Burp Suite.*Â To
    follow, we'll uncheck the box here as well.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_04_05-1.png)'
  prefs: []
  type: TYPE_IMG
- en: The Audit Section is where we decide how many aspects of the web server get
    tested.
  prefs: []
  type: TYPE_NORMAL
- en: Converting social engineering into user input and mobile platform emulation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Depending on our success in the Recon phase, some of our OSINT may include credentials
    for a web user.Â  These can often be scraped in a MITM attack similar to what
    we discussed using SET in [Chapter 3](000.html#), *Stalking Prey Through Target
    Recon*. While it is certainly acceptable to scan sites without credentials, the
    revelations that may come with a scan as a logged-in user never disappoint. Without
    the credentials, you'll likely see a majority of static content and much less
    sensitive information exposed in black-box tests. White-box tests can better serve
    to secure data in the event of compromised credentials and thus input strings
    here are just as valuable if they are available. The HTTP section followingÂ likewise
    can help tailor HTTP requests to better mimic a legitimate client, work through
    any proxy in the path, and also throttle some of the request rates and file sizes
    to ensure neither the scanner nor the target are overwhelmed, or in their case,
    alerted to our presence. In the event you need to emulate a different browser
    and platform combination, you can provide those modifications here (the website
    at [http://www.useragentstring.com/pages/useragentstring.php](http://www.useragentstring.com/pages/useragentstring.php)
    provides an exhaustive list). As we'll see, the simple fields entered here in
    the **`Input`** fields will result in a much greater scanned area as we delve
    deeper into the application.
  prefs: []
  type: TYPE_NORMAL
- en: There are a host of other fields in figure following*Â *thatÂ we may need to
    be aware of as well. Addresses, names, and other static information are popular,
    but more dynamic input processes such as CAPTCHAÂ fields are built specifically
    to prevent non-human form fills. This can limit the scanner's reach, but rest
    assured that there are many other ways to overcome this obstacle so that we can
    test to ensure the target is truly protected.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_04_06-1.png)'
  prefs: []
  type: TYPE_IMG
- en: The Input section is very handy when we have a user's potential credentials
    to leverage
  prefs: []
  type: TYPE_NORMAL
- en: Fingerprinting and determining platforms
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The **fingerprinting** section is one of the most impactful ways we can focus
    our scans and win back time in our schedule. Fingerprinting itself is a fantastic
    tool if you don''t already know your target''s stack. As we discovered earlier
    with our browser, we''re running LAMP and can omit the fingerprinting while selecting
    tests that only pertain to that framework. Note that in figure following*,*Â I
    am attempting to test against all 4 detected languages (Perl, PHP, Python, and
    Ruby):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_04_07.png)'
  prefs: []
  type: TYPE_IMG
- en: Fingerprinting allows us to explicitly select tests â�� no sense using them
    all if we don't have to.
  prefs: []
  type: TYPE_NORMAL
- en: Checks (please)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The **Checks** section is where the nitty-gritty details of what vulnerabilities
    we'll test against are offered. Each of the checks is either an active or a passive
    check, and we can enable all or some of them depending on the need. In this case,
    we have plenty of information on the DVWA's framework, but we have no clue as
    to what they will be subjected to. If this was truly a black-box scan, and we
    were trying to stay covert, I mightÂ omit all active checks (seen in following
    figure) in earlier scans and wait until I am able to conduct this from a less-suspicious
    host closer to the web server.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_04_08.png)'
  prefs: []
  type: TYPE_IMG
- en: Active checks dictate what vulnerabilities Arachni will interact with the target
    proactively to discover.
  prefs: []
  type: TYPE_NORMAL
- en: The passive scanning section is much less obtrusive and while these tests canÂ add
    some time, they are well worth using, especially in earlier recon efforts. This
    can be seen in following figure, and for more details, you can click on the name
    of each type for additional information.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_04_09-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Passive checks are collected without interacting with input fields on the application.
  prefs: []
  type: TYPE_NORMAL
- en: Plugging into Arachni extensions and third-party add-ons
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Arachni's Ruby-based framework (because, surprise, Arachni is a web application
    too!) isÂ an easy tool for anyone to build additional capabilities for. Widely
    accepted plugins, when meeting the developer's high standards, even make it into
    the Web UI Client in the **`Plugins`**Â section. In this version of Arachni, we
    have several plugins that have been integrated into Arachni and can help our scan
    reduce its impact on the target (Auto-Throttle or Rate-Limiter) or add functionality
    to scan for additional quirks and vulnerabilities.Â It even allows modification
    of fields and test parameters on the fly. Some of these are simply checked (see
    the following screenshot*)*, others require additional configuration after expanding
    them (simply click on the hyperlinked name of each plugin for details).
  prefs: []
  type: TYPE_NORMAL
- en: 'I selected **`AutoThrottle`** and **`WAF Detector`** for this profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_04_10-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Plugins modify any profile to allow on-the-fly parameter fuzzing, rate limiting,
    or other special tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative way to conduct WAF detection is to use our trusty **Nmap**Â tool.
    Nmap includes a couple of scripts for this purpose. One simply detects the presence
    of a WAF, while the other, if a WAF is found, will typically tell us what brand
    or version is in use. Confirming through multiple scripts and tools can often
    increase confidence in the overall test fidelity. To use these scripts, enter
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Browser clusters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All of these scans and tests are conducted as if the Instances are actually
    browser sessions interacting with the web application and user. We can actually
    modify the browser's emulated behavior, time limits, size, and even the number
    of independent browsers in use in the **`Browser Cluster`**Â section. For quick
    scans, I advise checking the box that allows the scanner to omit images.
  prefs: []
  type: TYPE_NORMAL
- en: Session checking is also a potentially valuable capability, and its options
    are shown in figure following. There is nothing worse than scanning an application
    just to find out that the logic behind that application has shunted your sessions,
    scans, or traffic to a linked domain outside the target's control. We can enter
    confirmation pages here to ensure that we periodically check back in with an anchor
    page to determine our state and ensure we're still scanning insideÂ the targetÂ application's
    structure, and not following a tangent into a linked application.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_04_11.png)'
  prefs: []
  type: TYPE_IMG
- en: Browser and Session settings ensure we present our best side to the right site.
  prefs: []
  type: TYPE_NORMAL
- en: After we've made all of our profile changes, we can select the **`Create Profile`**
    button at the bottom, and we should be good to go! If you run into issues, a top-center
    error box will steer you right to where the issues lie and tell you what must
    be revised before the profile can be accepted.
  prefs: []
  type: TYPE_NORMAL
- en: Kicking off our custom scan
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once we've made our custom profile, we can invoke it, schedule it, or put it
    away for safe keeping.Â  To run the scan, simply initiate a scan and select **`LAMP
    Profile`****`Â (Global)`** (or whatever name you used) in the **`Configuration
    Profile to use`**Â field, as seen in following figure. We can control the number
    of instances, how the workload is provisioned (direct to a local computer running
    one or more instances, to a remote server, or using a grid of computers), and
    schedule it if so desired.Â  Here, we'll just run it with two instances now and
    see how it performs.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_04_12.png)'
  prefs: []
  type: TYPE_IMG
- en: Running a scan with a custom profile is straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: While the scan is running, we can observe the summary and see just how well
    our custom profile is working. As seen in following figure, our scan is already
    far beyond what we saw with the default profile, with more pages discovered, more
    requests attempted, and better overall coverage while keeping a lower profile.
    This results in greater time to complete, but the automation should allow us to
    fire and forget while we work on other things. Â
  prefs: []
  type: TYPE_NORMAL
- en: I recommend that you find places in your own workflow where you can kick off
    automated tasks, while personally working on more labor-intensive efforts, such
    as Maltego graph building, social engineering, or the setup for follow-on tasks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_04_13.png)'
  prefs: []
  type: TYPE_IMG
- en: The LAMP profile is slower, but revealings more and at lower burden to the target
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The results of our tailored scan are that we see 34 issues versus the 29 identified
    onesÂ in the wide-open scan before, but that our scan was 28 minutes versus 34
    seconds. We also managed to unearth over 90 pages versus 27 (some as a result
    of our user input) and did so at a much lower request rate than the default, thus
    protecting the DVWA from a mini **Denial of Service** (**DoS**) and staying under
    the radar of any defenses that may have been on the way. Arachni archives scan
    until we run out of space or tell it to delete them, so we'll always have both
    to compare and contrast. In practice, I would recommend running a single-targeted
    scan when the risk is acceptable and running smaller subscans for more covert
    phases of your work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a summary of these results:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Â  | **LAMP profile** | **Default profile** |'
  prefs: []
  type: TYPE_TB
- en: '| Time to complete | 38 minutes | 36 seconds |'
  prefs: []
  type: TYPE_TB
- en: '| Pages found | 90 | 27 |'
  prefs: []
  type: TYPE_TB
- en: '| High severity | 3 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| Medium severity | 8 | 7 |'
  prefs: []
  type: TYPE_TB
- en: '| Low severity | 6 | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| Informational | 17 | 16 |'
  prefs: []
  type: TYPE_TB
- en: '| Total issues | 34 | 29 |'
  prefs: []
  type: TYPE_TB
- en: 'The reports can be exported in a variety of useful formats with HTML, JSON,
    XML, Marshal, YAMR, and AFR available. As with all of them, the HTML reports are
    data-rich and near-presentation ready as in following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_04_14.png)'
  prefs: []
  type: TYPE_IMG
- en: Arachni's report formats are production-ready and a great start on building
    your deliverables to the customer.
  prefs: []
  type: TYPE_NORMAL
- en: For the more technical customers, it is helpful to provide follow-up or immediate
    actions (see following figure) that they can take. Your value as a pen tester
    will be much greater if you not only identify problems, but also offer recommendations
    based on best practices that can help the customer's target network be remediated
    and made more secure.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_04_15.png)'
  prefs: []
  type: TYPE_IMG
- en: Detailed vulnerability information can help quickly educate the customer or
    set up the next phases.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Effective penetration testing is contingent on many things, but the best results
    come with a well-educated set of scans that can both educate as well as prepare
    the table for the later phases of the test. As recent events and continuous headlines
    have demonstrated, there is a staggering number and variety of vectors available
    for attackers to leverage. The volume and importance of these potential holes
    demand comprehensive test suites that automate scans and help us quickly ascertain
    the risk exposure of a target. Almost as important is the ability to process the
    copious amounts of raw data and turn them around as actionable intelligence.
  prefs: []
  type: TYPE_NORMAL
- en: Arachni is a fantastic tool when it comes to providing these scan, and as an
    added bonus, you can form the basis of our detailed reports or deliverables. Because
    Arachni is an open source and extensible product, it is well supported by the
    community and offers a Ruby framework, on which anyone can graft their own extensions
    or plugins. There are literally thousands of options in Arachni, but hopefully,
    our immersion in the profile builder offers some insight as to how to better employ
    Arachni and other complementary tools in your browser or nmap to scope out your
    target systems efficiently. The depth to which Arachni investigates a target's
    vulnerabilities allows it to uncover potential vectors in detail rivaling or exceeding
    many commercial alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we discussed ways we could scale Arachni's deployment and tips
    for how to tailor scan profiles to reveal more and remain inconspicuous. We looked
    at how we could better profile our targets, custom craft our scanning behavior,
    and load and focus on the target's attributes gained from the Recon phase of the
    test. We also saw how these tweaks went a long way towards getting deeper page
    discovery and vulnerability identification. The reporting elements were also briefly
    discussed; if anything, this area is ripe with possibilities, and depending on
    your workflows your processes will greatly accelerate report generation and support
    long-term continuous improvement that we should all hope becomes standard in the
    SDLC.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll take a look at two more tools that overlap with Arachni
    but take the pen test further into the Kill Chain--**Burp Suite** and **OWASP
    ZAP**. These tools replicate some of Arachni's functions, but can also leverage
    what we have learned here to begin actually exploiting these holes and confirm
    the impact. After seeing what the DVWA has to worry about, I am sure we'll see
    some interesting results!
  prefs: []
  type: TYPE_NORMAL
