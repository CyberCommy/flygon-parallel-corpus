- en: Cryptography
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduces you to algorithms related to cryptography. We will start
    by presenting the background, then we will discuss symmetric encryption algorithms.
    We will then explain the **Message-Digest 5** (**MD5**) algorithm and the **Secure
    Hash Algorithm**(**SHA**) and present the limitations and weaknesses of implementing
    symmetric algorithms. Next, we will discuss asymmetric encryption algorithms and
    how they are used to create digital certificates. Finally, we will present a practical
    example that summarizes all of these techniques.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a basic understanding of various issues
    related to cryptography.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics are discussed in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to cryptography
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the types of cryptography techniques
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example – security concerns when deploying a machine learning model
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by looking at the basic concepts.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Cryptography
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Techniques to protect secrets have been around for centuries. The earliest attempts
    to secure and hide data from adversaries date back to ancient inscriptions discovered
    on monuments in Egypt, where a special alphabet that was known by only a few trusted
    people was used. This early form of security is called **obscurity** and is still
    used in different forms today. In order for this method to work, it is critical
    to protect the secret, which is the meaning of the alphabet. Later in time, finding
    foolproof ways of protecting important messages was important in both World War
    One and World War Two. In the late-20^(th) century, with the introduction of electronics
    and computers, sophisticated algorithms were developed to secure data, giving
    rise to a whole new field called **cryptography**. This chapter discusses the
    algorithmic aspects of cryptography. The purpose of these algorithms is to allow
    secure data exchange between two processes or users. Cryptographic algorithms
    find strategies of using mathematical functions to ensure the stated security
    goals.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Importance of the Weakest Link
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, when architecting the security of digital infrastructure, we put
    too much emphasis on the security of individual entities and don't pay the necessary
    attention to end-to-end security. This can result in us overlooking some loopholes
    and vulnerabilities in the system, which can later be exploited by hackers to
    access sensitive data. The important point to remember is that a digital infrastructure,
    as a whole, is only as strong as its **weakest link**. For a hacker, this weakest
    link can provide backdoor access to the sensitive data in the digital infrastructure.
    Beyond a certain point, there is not much benefit in fortifying the front door
    without closing all the back doors.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: As the algorithms and techniques for keeping digital infrastructure become more
    and more sophisticated, attackers keep upgrading their techniques as well. It
    is always important to remember that one of the easiest ways for attackers to
    hack digital infrastructure is by exploiting these vulnerabilities to access sensitive
    information.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: In 2014, a cyber attack on a Canadian federal research institute—the **National
    Research Council** (**NRC**)—is estimated to have cost hundreds of millions of
    dollars. The attackers were able to steal decades of research data and intellectual
    property material. They used a loophole in the Apache software that was used on
    the web servers to gain access to the sensitive data.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will highlight the vulnerabilities of various encryption
    algorithms.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Let's first look at the basic terminology used.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: The Basic Terminology
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at the basic terminology related to cryptography:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '**Cipher**: An algorithm that performs a particular cryptographic function.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Plain text**: The plain data, which can be a text file, a video, a bitmap,
    or a digitized voice. In this chapter, we will represent plain text as *P*.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cipher text**: The scrambled text that is obtained after applying cryptography
    to the plain text. In this chapter, we will represent this as *C*.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密文**：应用加密后得到的混乱文本。在本章中，我们将其表示为*C*。'
- en: '**Cipher suite**: A set or suite of cryptographic software components. When
    two separate nodes want to exchange messages using cryptography, they first need
    to agree on a cipher suite. This is important in ensuring that they use exactly
    the same implementation of the cryptographic functions.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密码套件**：一组或套件的加密软件组件。当两个独立节点想要使用加密交换消息时，它们首先需要就密码套件达成一致。这对于确保它们使用完全相同的加密函数实现非常重要。'
- en: '**Encryption**: The process of converting plain text, *P*, into cipher text,
    *C*, is called encryption.  Mathematically, it is represented by *encrypt(P) =
    C*.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加密**：将明文*P*转换为密文*C*的过程称为加密。在数学上，它表示为*encrypt(P) = C*。'
- en: '**Decryption**: The process of converting cipher text back into plain text.
    Mathematically, it is represented by *decrypt(C) = P*.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解密**：将密文转换回明文的过程。在数学上，它表示为*decrypt(C) = P*。'
- en: '**Cryptanalysis**: The methods used to analyze the strength of the cryptographic
    algorithms. The analyst tries to recover the plain text without access to the
    secret.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密码分析**：用于分析加密算法强度的方法。分析人员试图在没有秘密访问的情况下恢复明文。'
- en: '**Personally Identifiable Information** (**PII**): PII is the information that
    can be used to trace an individual''s identity when used alone or with other relevant
    data. Some examples include protected information, such as a social security number,
    date of birth, or mother''s maiden name.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**个人可识别信息**（**PII**）：PII是指可以单独使用或与其他相关数据一起用于追踪个人身份的信息。一些例子包括受保护的信息，如社会安全号码、出生日期或母亲的婚前姓氏。'
- en: Understanding the Security Requirements
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解安全需求
- en: 'It is important to first understand the exact security needs of a system. Understanding
    this will help us use the correct cryptographic technique and discover the potential
    loopholes in a system. In order to do this, we first need to better understand
    the needs of the system. In order to understand the security requirements, we
    perform the following three steps:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先了解系统的确切安全需求是很重要的。了解这一点将帮助我们使用正确的加密技术，并发现系统中的潜在漏洞。为了做到这一点，我们首先需要更好地了解系统的需求。为了了解安全需求，我们执行以下三个步骤：
- en: Identify the entities.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别实体。
- en: Establish the security goals.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确立安全目标。
- en: Understand the sensitivity of the data.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解数据的敏感性。
- en: Let's look at these steps one by one.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一看看这些步骤。
- en: Identifying the Entities
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别实体
- en: 'One way to identify the entities is to start by answering the following four
    questions, which will help us understand the needs of the system in the context
    of security:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 识别实体的一种方法是首先回答以下四个问题，这将帮助我们了解系统在安全环境中的需求：
- en: Which applications need to be protected?
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些应用程序需要受到保护？
- en: Who are we protecting the applications from?
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们要保护应用程序免受谁的攻击？
- en: Where should we protect them?
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该在哪里保护它们？
- en: Why are we protecting them?
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为什么要保护它们？
- en: Once we better understand these requirements, we can establish the security
    goals of our digital system.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们更好地了解这些要求，我们就可以确立我们数字系统的安全目标。
- en: Establishing the Security Goals
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确立安全目标
- en: 'Cryptographic algorithms are typically used to meet one or more security goals:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通常使用加密算法来满足一个或多个安全目标：
- en: '**Authentication**:Simply put, authentication is how we prove that a user is
    who they claim to be. Through the process of authentication, we ensure that a
    user''s identity is verified. The process of authentication starts by having the
    user present their identity. This is followed by providing information that is
    only known by the user and so can only be produced by them.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证**：简单来说，认证是我们如何证明用户是其所声称的人的方式。通过认证的过程，我们确保用户的身份得到验证。认证的过程始于用户提供其身份。接着是提供只有用户知道的信息，因此只能由他们产生。'
- en: '**Confidentiality**:  Data that needs to be protected is called **sensitive
    data**. Confidentiality is the concept of restricting sensitive data to authorized
    users only. To protect the confidentiality of sensitive data during its transit
    or in storage, you need to render the data so that it is unreadable except by
    authorized users. This is accomplished by using encryption algorithms, which we
    will discuss later on in this chapter.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**机密性**：需要受到保护的数据称为**敏感数据**。机密性是将敏感数据限制为仅授权用户的概念。为了在传输或存储过程中保护敏感数据的机密性，您需要使数据变得不可读，除了授权用户之外。这是通过使用加密算法来实现的，我们将在本章后面讨论。'
- en: '**Integrity**: Integrity is the process of establishing that data has not been
    altered in any way during its transit or storage. For example, **TCP/IP** (**Transmission
    Control Protocol/Internet Protocol**) uses checksum or **Cyclic Redundancy Check**
    (**CRC**) algorithms to verify data integrity.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完整性**：完整性是指建立数据在传输或存储过程中没有被任何方式改变的过程。例如，**TCP/IP**（传输控制协议/互联网协议）使用校验和或**循环冗余校验**（**CRC**）算法来验证数据的完整性。'
- en: '**Non-repudiation**: Non-repudiation is the concept of a sender of information
    receiving confirmation that the data was received and the recipient receiving
    confirmation of the sender''s identity. This provides irrefutable evidence that
    a message was sent or received, which can be used later to prove the receipt of
    data and the points of failures in communication.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可否认性**：不可否认性是指信息发送方收到数据已被接收的确认，接收方收到发送方身份的确认的概念。这提供了无可辩驳的证据，证明了消息的发送或接收，这可以在以后用来证明数据的接收和通信中的故障点。'
- en: Understanding the Sensitivity of the Data
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解数据的敏感性
- en: 'It is important to understand the classified nature of data. We also need to
    think about how serious the consequences are if the data is compromised. The classification
    of the data helps us choose the correct cryptographic algorithm. There is more
    than one way to classify data, based on the sensitivity of the information it
    contains. Let''s look at the typical ways of classifying data:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '**Public data or unclassified data**: Anything that is available for consumption
    for the public. For example, information found on a company''s website or a government''s
    info portal.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Internal data or confidential data**:Although not for public consumption,
    exposing this data to the public may not have damaging consequences. For example,
    if an employee''s emails complaining about their manager are exposed, it may be
    embarrassing for the company but this may not have damaging consequences.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sensitive data or secret data**:  Data that is not supposed to be for public
    consumption and exposing it to the public has damaging consequences for an individual
    or an organization. For example, leaking the details of a future iPhone may harm
    Apple''s business goals and can give an advantage to rivals, such as Samsung.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Highly sensitive data**: Also called **top-secret data**. This is information
    that if disclosed, would be extremely damaging to the organization. This can include
    customer social security numbers, credit card numbers, or other very sensitive
    information. Top-secret data is protected through multiple layers of security
    and requires special permission to access.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, more sophisticated security designs are much slower than simple
    algorithms. It is important to strike the right balance between the security and
    the performance of the system.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Basic Design of Ciphers
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Designing ciphers is about coming up with an algorithm that can scramble sensitive
    data so that a malicious process or an unauthorized user cannot access it. Although
    over time ciphers have become more and more sophisticated, the underlying principles
    that ciphers are based on remain unchanged.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by looking at some relatively simple ciphers that will help us understand
    the underlying principles that are used in the design of cryptographic algorithms.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Presenting Substitution Ciphers
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Substitution ciphers have been in use for hundreds of years in various forms.
    As the name indicates, substitution ciphers are based on a simple concept—substituting
    characters in plain text with other characters in a predetermined, organized way.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the exact steps involved in this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: First, we map each character to a substitute character.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, encode and convert the plaintext into cipher text by replacing each character
    in the plain text with another character in the ciphertext using substitution
    mapping.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To decode, bring back the plaintext by using substitution mapping.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s look at some examples:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '**Caesar cipher**:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In Caesar ciphers, the substitution mapping is created by replacing each character
    with the third character to the right of it. This mapping is described in the
    following diagram:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/91bc4fec-861e-4d78-9050-7f30a9758aa1.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
- en: 'Let''s see how we can implement a Caesar cipher using Python:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can see that we applied a Caesar cipher to the plaintext, `CALM`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s print the cipher text after encrypting with the Caesar cipher:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8edd428d-94b2-436e-ac6f-a1878e094b43.png)Caesar ciphers are said
    to have been used by Julius Caesar to communicate with his advisers.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '**Rotation 13** (**ROT13**):'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ROT13 is another of the substitution-based encryptions. In ROT13, the substitution
    mapping is created by replacing each character with the 13^(th) character to the
    right of it. The following diagram illustrates this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a44fe40c-b91e-469b-bfcb-efef009e8856.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
- en: 'This means that if `ROT13()` is the function that implements ROT13, then the
    following applies:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let''s print the encoded value of `C`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/49619d35-4c7c-45be-a774-966b96f9a104.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
- en: '**Cryptanalysis of substitution ciphers** :'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Substitution ciphers are simple to implement and understand. Unfortunately,
    they are also easy to crack. A simple cryptanalysis of substitution ciphers shows
    that if we use the English language alphabet, then all we need to determine to
    crack the cipher is how much are we rotating by. We can try each letter of the
    English alphabet one by one until we are able to decrypt the text. This means
    that it will take around 25 attempts to reconstruct the plain text.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at another type of simple cipher—transposition ciphers.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Transposition Ciphers
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In transposition ciphers, the characters of the plain text are transposed.
    Let''s look at the steps involved for this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Create the matrix and choose the size of the transposition matrix. It should
    be large enough to fit the plain text string.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill in the matrix by writing in all of the characters of the string horizontally.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read all of the characters of the string vertically in the matrix.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's look at an example.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Let's take the `Ottawa Rocks` plain text (*P*).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s encode *P*. For that, we will use a 3 x 4  matrix and write in
    the plaintext horizontally:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '| O | t | t | a |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
- en: '| w | a | R | o |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
- en: '| c | k | s |  |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
- en: The `read` process will read the string vertically, which will generate the
    cipher text—`OwctaktRsao`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: The Germans used a cipher named ADFGVX in the First World War, which used both
    the transposition and substitution ciphers. Years later, it was cracked by George
    Painvin.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: So, these are some of the types of ciphers. Now, let's look at some of the cryptographic
    techniques that are currently used.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Types of Cryptographic Techniques
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Different types of cryptographic techniques use different types of algorithms
    and are used under different sets of circumstances.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'Broadly, cryptographic techniques can be divided into the following three types:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Hashing
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Symmetric
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asymmetric
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at them one by one.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Using the Cryptographic Hash Function
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The cryptographic hash function is a mathematical algorithm that can be used
    to create unique fingerprint of a message. It creates a fixed-sized output, called
    a **hash**, from plain text.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'Mathematically, this looks as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '*C[1]  = hashFunction(P[1])*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'This is explained as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '*P[1]* is the plain text representing the input data.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C[1]*  is a fixed-length hash that is generated by the cryptographic hash
    function.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is shown in the following diagram. The variable-length data is converted
    into a fixed-length hash through a one-way hash function:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/36a659e2-2da6-459b-969d-b8400697eb4c.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
- en: 'The hash function has the following five characteristics:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: It is deterministic. The same plain text generates the same hash.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unique input strings should generate unique output hash values.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regardless of the input message, it has a fixed length.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even small changes in the plain text generate a new hash.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a one-way function, which means that plain text, *P*[*1*,]  cannot be
    generated from the cipher text, *C*[*1*.]
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we have a situation where each unique message does not have a unique hash,
    we call it a **collision**. That is, if we have two texts, *P[1]*  and *P[2]*  ,
    in the case of collision, it means *hashFunction(P[1]) = hashFunction(P[2])*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of the hashing algorithm used, collisions are rare. Otherwise, hashing
    wouldn't be useful. However, for some applications, collisions cannot be tolerated.
    In those cases, we need to use a hashing algorithm that is more complex but much
    less likely to generate hash values that collide.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Implementing cryptographic hash functions
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cryptographic hash functions can be implemented by using various algorithms.
    Let's take a deeper look at two of them.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Understanding MD5-tolerated
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MD5 was developed by Poul-Henning Kamp in 1994 to replace MD4\. It generates
    a 128-bit hash. MD5 is a relatively simple algorithm that is vulnerable to collision.
    In applications where a collision cannot be tolerated, MD5 should not be used.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example. In order to generate an MD5 hash in Python, we will
    use the `passlib` library, which one of the most popular open source libraries,
    implementing over 30 password-hashing algorithms. If it is not already installed
    on your device, install it by using the following code in a Jupyter notebook:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。为了在Python中生成MD5哈希，我们将使用`passlib`库，这是一个最流行的开源库之一，实现了30多种密码哈希算法。如果它还没有安装在您的设备上，请在Jupyter笔记本中使用以下代码安装它：
- en: '[PRE2]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In Python, we can generate the MD5 hash as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们可以按照以下方式生成MD5哈希：
- en: '![](assets/32a01072-7c27-4d65-a565-26af8195a8da.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/32a01072-7c27-4d65-a565-26af8195a8da.png)'
- en: Note that MD5 generates a hash of 128 bits.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，MD5生成128位的哈希。
- en: 'As mentioned, we can use this generated hash as a fingerprint of the original
    text, which was `myPassword`. Let''s see how we can do this in Python:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们可以将生成的哈希用作原始文本的指纹，原始文本是`myPassword`。让我们看看如何在Python中实现这一点：
- en: '![](assets/dd3a883a-f1b2-4fd5-bf4a-35a505809106.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dd3a883a-f1b2-4fd5-bf4a-35a505809106.png)'
- en: Note that the generated hash for the `myPassword` string  matched the original
    hash, which generated a `True` value. However, it returned `False` as soon as
    the plain text was changed to `myPassword2`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对`myPassword`字符串生成的哈希与原始哈希匹配，生成了一个`True`值。但是，一旦明文更改为`myPassword2`，它就返回了`False`。
- en: Now, let's look at another hashing algorithm—**Secure Hash Algorithm** (**SHA**).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看另一个哈希算法——**安全哈希算法**（**SHA**）。
- en: Understanding SHA
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解SHA
- en: 'SHA was developed by the **National Institute of Standards and Technology**
    (**NIST**). Let''s see how we can use Python to create a hash using the SHA algorithm:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: SHA是由**国家标准与技术研究所**（**NIST**）开发的。让我们看看如何使用Python来创建SHA算法的哈希：
- en: '[PRE3]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note the use of a parameter called `salt`. Salting is the procedure of adding
    random characters before hashing.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意使用一个名为`salt`的参数。加盐是在哈希之前添加随机字符的过程。
- en: 'Running this code will give us the following result:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码将给我们带来以下结果：
- en: '![](assets/0ac664a2-c588-48d5-a4d9-934b566d653f.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0ac664a2-c588-48d5-a4d9-934b566d653f.png)'
- en: Note that when we use the SHA algorithm, the hash generated is of 512 bytes.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们使用SHA算法时，生成的哈希是512字节。
- en: An Application of the Cryptographic Hash Function
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密哈希函数的应用
- en: Hash functions are used to check the integrity of a file after making a copy
    of it. To achieve this, when a file is copied from a source to a destination (for
    example, when downloaded from a web server), a corresponding hash is also copied
    with it. This original hash, *h[original]*, acts as a fingerprint of the original
    file. After copying the file, we generate the hash again from the copied version
    of the file—that is, *h[copied]*. If *h*[*original*] = *h[copied]*—that is, the
    generated hash matches the original hash—this verifies that the file has not changed
    and none of the data was lost during the download process. We can use any cryptographic
    hash function, such as MD5 or SHA, to generate a hash for this purpose.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数用于在复制文件后检查文件的完整性。为了实现这一点，当文件从源复制到目的地（例如，从Web服务器下载时），相应的哈希也会被复制。这个原始哈希，*h[original]*，充当了原始文件的指纹。复制文件后，我们再次从复制的文件版本生成哈希，即*h[copied]*。如果*h*[*original*]
    = *h[copied]*—也就是说，生成的哈希与原始哈希匹配—这验证了文件没有改变，并且在下载过程中没有丢失任何数据。我们可以使用任何加密哈希函数，比如MD5或SHA，来为此目的生成哈希。
- en: Now, let's look at symmetric encryption.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看对称加密。
- en: Using Symmetric Encryption
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用对称加密
- en: 'In cryptography, a key is a combination of numbers that is used to encode plain
    text using an algorithm of our choice. In symmetric encryption, we use the same
    key for encryption and decryption. If the key used for symmetric encryption is
    *K*, then for symmetric encryption, the following equation holds:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在密码学中，密钥是一组数字，用于使用我们选择的算法对明文进行编码。在对称加密中，我们使用相同的密钥进行加密和解密。如果用于对称加密的密钥是*K*，那么对称加密的等式如下：
- en: '*E[K](P) = C*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*E[K](P) = C*'
- en: Here, *P* is the plain text and *C* is the cipher text.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*P*是明文，*C*是密文。
- en: 'For decryption, we use the same key, *K*, to convert it back to *P*:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于解密，我们使用相同的密钥*K*将其转换回*P*：
- en: '*D[K](C) = P*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*D[K](C) = P*'
- en: 'This process is shown in the following diagram:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程在下面的图表中显示：
- en: '![](assets/52dabfcd-01bc-4ef2-80ce-c70d455676c8.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/52dabfcd-01bc-4ef2-80ce-c70d455676c8.png)'
- en: Now, let's look at how we can use symmetric encryption with Python.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在Python中使用对称加密。
- en: Coding Symmetric Encryption
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写对称加密
- en: 'We will use Python''s `cryptography` package, in this section, to demonstrate
    symmetric encryption. It is a comprehensive package that implements many cryptographic
    algorithms, such as symmetric ciphers and different message digests. When using
    it for the first time, we first need to install it using the `pip` command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用Python的`cryptography`包来演示对称加密。它是一个全面的包，实现了许多加密算法，比如对称密码和不同的消息摘要。第一次使用时，我们需要使用`pip`命令来安装它：
- en: '[PRE4]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once installed, we can now use the package to implement symmetric encryption,
    as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们现在可以使用该包来实现对称加密，如下所示：
- en: 'First, let''s import the packages we need:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们导入我们需要的包：
- en: '[PRE5]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s generate the key:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们生成密钥：
- en: '![](assets/90609769-1a16-48cf-96b8-6fefa3799ab5.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/90609769-1a16-48cf-96b8-6fefa3799ab5.png)'
- en: 'Now, let''s open the key:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们打开密钥：
- en: '[PRE6]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Using the key, let''s now try to encrypt the message:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用密钥，现在让我们尝试加密消息：
- en: '[PRE7]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, let''s decrypt the message using the same key:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用相同的密钥解密消息：
- en: '[PRE8]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s decrypt the message and assign it to a variable named `decrypt`:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们解密消息并将其赋给一个名为`decrypt`的变量：
- en: '[PRE9]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s now print the `decrypt` variable to verify whether we are able to get
    the same message:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们打印`decrypt`变量，以验证我们是否能够得到相同的消息：
- en: '![](assets/556b14e4-1ddb-4956-906a-06c41f96996e.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/556b14e4-1ddb-4956-906a-06c41f96996e.png)'
- en: Let's look at some of the advantages of symmetric encryption.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些对称加密的优势。
- en: The Advantages of Symmetric Encryption
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对称加密的优势
- en: Although the performance of the symmetric encryption is dependent on the exact
    algorithm that is used, in general, it is a lot faster than asymmetric encryption.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: The Problems with Symmetric Encryption
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When two users or processes plan to use symmetric encryption to communicate,
    they need to exchange keys using a secure channel. This gives rise to the following
    two problems:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '**Key protection**: How to protect the symmetric encryption key.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Key distribution**:  How to share the symmetric encryption key from the source
    to the destination.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's look at asymmetric encryption.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Asymmetric Encryption
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the 1970s, asymmetric encryption was devised to address some of the weaknesses
    of symmetric encryption that we discussed in the previous section.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step in asymmetric encryption is to generate two different keys that
    look totally different but are algorithmically related. One of them is chosen
    as the private key, *K[pr]*, and the other one is chosen as the public key, *K[pu]*.
    Mathematically, we can represent this as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '*E[Kpr](P) = C*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Here, *P* is the plain text and *C* is the cipher text.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'We can decrypt it as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '*D[Kpu](C) = P*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Public keys are supposed to be freely distributed and private keys are kept
    secret by the owner of the key pair.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: The fundamental principle is that if you encrypt with one of the keys, the only
    way to decrypt it is by using the other key. For example, if we encrypt the data
    using the public key, we will need to decrypt it using the other key—that is,
    the private key. Now, let's look at one of the fundamental protocols of asymmetric
    encryption—the **Secure Sockets Layer** (**SSL**)/**Transport Layer Security**
    (**TLS**) handshake—which is responsible for establishing a connection between
    two nodes using asymmetric encryption.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: The SSL/TLS Handshaking Algorithm
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SSLwas originally developed to add security to HTTP. Over time, SSL was replaced
    with a more efficient and more secure protocol, called TLS. TLS handshakes are
    the basis of how HTTP creates a secure communication session. A TLS handshake
    occurs between the two participating entities—the **client** and the **server**.
    This process is shown in the following diagram:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/787e64d9-a0ed-47d9-9c9b-c7409c0926ea.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
- en: 'A TLS handshake establishes a secure connection between the participating nodes.
    The following are the steps that are involved in this process:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'The client sends a `client hello` message to the server. The message also contains
    the following:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The version of TLS that is used
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list of cipher suites supported by the client
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A compression algorithm
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A random byte string, identified by `byte_client`
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The server sends a `server hello` message back to the client. The message also
    contains the following:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A cipher suite selected by the server from the list provided by the client
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A session ID
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A random byte string, identified by `byte_server`
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A server digital certificate, identified by `cert_server`, containing the public
    key of the server
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the server requires a digital certificate for client authentication or a
    client certificate request, the client server request also includes the following:'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The distinguished names of the acceptable CAs
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The types of certificates supported
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client verifies `cert_server`.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client generates a random byte string, identified by `byte_client2`, and
    encrypts it with the public key of the server provided through `cert_server`.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client generates a random byte string and identifies encrypts with its own
    private key.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server verifies the client certificate.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client sends a `finished` message to the server, which is encrypted with
    a secret key.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To acknowledge this from the server side, the server sends a `finished` message
    to the client, which is encrypted with a secret key.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The server and client have now established a secure channel. They can now exchange
    messages that are symmetrically encrypted with the shared secret key. The entire
    methodology is shown as follows:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/6a90b582-3e7c-4378-9f8b-63fec0e0db16.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6a90b582-3e7c-4378-9f8b-63fec0e0db16.png)'
- en: Now, let's discuss how we can use asymmetric encryption to create **Public Key
    Infrastructure** (**PKI**), which is created to meet one or more security goals
    for an organization.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论如何使用非对称加密来创建**公钥基础设施**（**PKI**），PKI是为了满足组织的一个或多个安全目标而创建的。
- en: Public Key Infrastructure
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 公钥基础设施
- en: Asymmetric encryption is used to implement PKI. PKI is one of the most popular
    and reliable ways to manage encryption keys for an organization. All the participants
    trust a central trusting authority called a CA.CAs verify the identity of individuals
    and organizations and then issue them digital certificates (a digital certificate
    contains a copy of a person or organization's public key and its identity), verifying
    that the public key associated with that individual or organization actually belongs
    to that individual or organization.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 非对称加密用于实现PKI。PKI是管理组织加密密钥的最流行和可靠的方式之一。所有参与者都信任一个名为CA的中央信任机构。CA验证个人和组织的身份，然后为他们颁发数字证书（数字证书包含个人或组织的公钥副本和其身份），验证与该个人或组织相关联的公钥实际上属于该个人或组织。
- en: The way it works is that the CA asks a user to prove their identity, with different
    standards followed for individuals and organizations. This could involve simply
    verifying ownership of a domain name, or it could involve a more rigorous process
    that involves physical proof of identity, depending on the type of digital certificate
    that a user is trying to obtain. If the CA is satisfied that the user is indeed
    who they claim to be, the user then provides the CA with their public encryption
    key over a secure channel. The CA uses this information to create a digital certificate
    that contains information about the user's identity and their public key. This
    certificate is digitally signed by the CA. The user can then show their certificate
    to anyone who wants to verify their identity, without having to send it through
    a secure channel, as the certificate doesn't contain any sensitive information
    itself. The person receiving the certificate does not have to verify the user's
    identity directly. That person can simply verify that the certificate is valid
    by verifying the CA's digital signature, which validates that the public key contained
    in the certificate does, in fact, belong to the individual or organization named
    on the certificate.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作方式是CA要求用户证明其身份，对个人和组织遵循不同的标准。这可能涉及简单地验证域名的所有权，也可能涉及更严格的过程，包括身份的物理证明，这取决于用户试图获得的数字证书的类型。如果CA确信用户确实是他们声称的人，用户随后通过安全通道向CA提供他们的公共加密密钥。CA使用这些信息创建包含用户身份和他们的公钥信息的数字证书。该证书由CA数字签名。用户随后可以向任何想要验证其身份的人展示其证书，而无需通过安全通道发送它，因为证书本身不包含任何敏感信息。接收证书的人不必直接验证用户的身份。该人只需验证证书是否有效，验证CA的数字签名，以验证证书中包含的公钥实际上属于证书上命名的个人或组织。
- en: The private key of the CA of an organization is the weakest link in the PKI
    chain of trust. If an impersonator gets hold of Microsoft's private key, for example,
    they can install malicious software onto millions of computers around the world
    by impersonating a Windows update.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 组织的CA的私钥是PKI信任链中最薄弱的环节。例如，如果冒名顶替者获取了微软的私钥，他们可以通过冒充Windows更新在全球数百万台计算机上安装恶意软件。
- en: Example – Security Concerns When Deploying a Machine Learning Model
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例-部署机器学习模型时的安全问题
- en: In [Chapter 6](ce14ecc1-8ad5-406e-88d0-7f3acb3e4569.xhtml), *Unsupervised Machine
    Learning Algorithms*, we looked at the **CRISP-DM**  (**Cross-Industry Standard
    Process for Data Mining**) life cycle, which specifies the different phases of
    training and deploying a machine learning model. Once a model is trained and evaluated,
    the final phase is deployment. If it is a critical machine learning model, then
    we want to make sure that all of its security goals are met.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ce14ecc1-8ad5-406e-88d0-7f3acb3e4569.xhtml)中，*无监督机器学习算法*，我们看了**CRISP-DM**（**跨行业标准数据挖掘过程**）生命周期，该生命周期指定了训练和部署机器学习模型的不同阶段。一旦模型被训练和评估，最后阶段是部署。如果这是一个关键的机器学习模型，那么我们希望确保它的所有安全目标都得到满足。
- en: 'Let''s analyze the common challenges faced in deploying a model such as this
    and how we can address those challenges using the concepts discussed in this chapter.
    We will discuss strategies to protect our trained model against the following
    three challenges:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析部署这样一个模型时面临的常见挑战，以及如何使用本章讨论的概念来解决这些挑战。我们将讨论保护我们训练好的模型免受以下三个挑战的策略：
- en: '**Man-in-the-Middle** (**MITM**) attacks'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中间人**（**MITM**）攻击'
- en: Masquerading
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冒充
- en: Data tempering
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据篡改
- en: Let's look at them one by one.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个来看。
- en: MITM attacks
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中间人攻击
- en: One of the possible attacks that we would want to protect our model against
    is MITM attacks. A MITM attack occurs when an intruder tries to eavesdrop on a
    supposedly private communication to deploy a trained machine learning model.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望保护我们的模型免受的可能攻击之一是中间人攻击。中间人攻击发生在入侵者试图窃听假定为私人通信的情况下，部署训练好的机器学习模型。
- en: Let's try to understand MITM attacks sequentially using an example scenario.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用一个示例场景来顺序理解中间人攻击。
- en: 'Let''s assume that Bob and Alice want to exchange messages using PKI:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 假设鲍勃和爱丽丝想要使用PKI交换消息：
- en: Bob is using {Pr[Bob], Pu[Bob]} and Alice is using {Pr[Alice], Pu[Alice]}. Bob
    has created a message, *M[Bob]*, and Alice has created a message, *M[Alice]*.
    They want to exchange these messages with each other in a secure way.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 鲍勃使用{Pr[Bob]，Pu[Bob]}，爱丽丝使用{Pr[Alice]，Pu[Alice]}。鲍勃创建了消息*M[Bob]*，爱丽丝创建了消息*M[Alice]*。他们希望以安全的方式彼此交换这些消息。
- en: Initially, they need to exchange their public keys to establish a secure connection
    with each other. This means that Bob uses *Pu[Alice]*  to encrypt *M[Bob]* before
    sending the message to Alice.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's assume that we have an eavesdropper, *X*, who is using {Pr[X], Pu[X]}.
    The attacker is able to intercept the public key exchanges between Bob and Alice
    and replace them with its own public certificate.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bob sends *M[Bob]*  to Alice, encrypting it with *Pu[X]*  instead of *Pu[Alice]*,
    wrongfully thinking that this is Alice's public certificate. Eavesdropper *X*
    intercepts the communication. It intercepts the *M[Bob]*  message and decrypts
    it using *Pr[Bob]*.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This MITM attack is shown in the following diagram:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1500b5c1-9b2b-4c0c-8c7c-c1ca674612eb.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
- en: Now, let's look at how we can prevent MITM attacks.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: How to prevent MITM attacks
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's explore how we can prevent MITM attacks by introducing a CA to the organization.
    Let's say the name of this CA is myTrustCA. The digital certificate has its public
    key, named *Pu[myTrustCA]*, embedded in it.myTrustCA is responsible for signing
    the certificates for all of the people in the organization, including Alice and
    Bob. This means that both Bob and Alice have their certificates signed by myTrustCA.
    When signing their certificates, myTrustCA verifies that they are indeed who they
    claim to be.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, with this new arrangement in place, let''s revisit the sequential interaction
    between Bob and Alice:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Bob is using {Pr[Bob], Pu[Bob]} and Alice is using {Pr[Alice], Pu[Alice]}. Both
    of their public keys are embedded into their digital certificates, signed by myTrustCA.
    Bob has created a message, *M[Bob]*, and Alice has created a message, *M[Alice]*.
    They want to exchange these messages with each other in a secure way.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They exchange their digital certificates, which contain their public keys. They
    will only accept the public keys if they are embedded in the certificates signed
    by the CA they trust. They need to exchange their public keys to establish a secure
    connection with each other. This means that Bob will use *Pu**[Alice]*  to encrypt
    *M**[Bob]* before sending the message to Alice.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's assume that we have an eavesdropper, *X*, who is using {Pr[X], Pu[X]}.
    The attacker is able to intercept the public key exchanges between Bob and Alice
    and replace them with its own public certificate,  *Pu[X]*.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bob rejects *X*'s attempt, as the bad guy's digital certificate is not signed
    by the CA that Bob trusts. The secure handshake is aborted, the attempted attack
    is logged with a timestamp and all details, and a security exception is raised.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When deploying a trained machine learning model, instead of Alice, there is
    a deployment server. Bob only deploys the model after establishing a secure channel,
    using the previously mentioned steps.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Let us see how we can implement this in Python.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: First let us import the packages that are needed.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now let us create a class that can verify the certirficate.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let us look into other vulnerabilities that our deployed model can face.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding Masquerading
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Attacker *X* pretends to be an authorized user, Bob, and gains access to sensitive
    data, which is the trained model, in this case. We need to protect the model against
    any unauthorized changes.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: One way of protecting our trained model against masquerading is by encrypting
    the model with an authorized user's private key. Once encrypted, anyone can read
    and utilize the model by decrypting it through the public key of the authorized
    user, which is found in their digital certificate. No one can make any unauthorized
    changes to the model.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Data and Model Encrpytion
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the model is deployed, the real-time unlabeled data that is provided as
    input to the model can also be tampered with. The trained model is used for inference
    and provides a label to this data. To protect data against tampering, we need
    to protect the data at rest and in communication. To protect the data at rest,
    symmetric encryption can be used to encode it. To transfer the data, SSL/TLS-based
    secure channels can be established to provide a secure tunnel. This secure tunnel
    can be used to transfer the symmetric key and the data can be decrypted on the
    server before it is provided to the trained model.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the more efficient and foolproof ways to protect data against
    tampering.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric encryption can also be used to encrypt a model when it has been trained,
    before deploying it to a server. This will prevent any unauthorized access to
    the model before it is deployed.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can encrypt a trained model at the source, using symmetric
    encryption with the help of the following steps, and then decrypt it at the destination
    before using it:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first train a simple model using the Iris dataset:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, let''s define the names of the files that will store the model:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that  `filename_source`  is the file that will store the trained unencrypted  model
    at the source.  `filename_destination`  is the file that will store the trained
    unencrypted model at the destination, and  `filename_sec`  is the encrypted trained
    model.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use  `pickle`  to store the trained model in a file:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s define a function named  `write_key()`  that will generate a symmetric
    key and store it in a file named  `key.key`:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, let''s define a function named  `load_key()`  that can read the stored
    key from the  `key.key` file:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, let''s define an  `encrypt()`  function that can encrypt and train the
    model, and store it in a file named  `filename_sec`:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We will use these functions to generate a symmetric key and store it in a file.
    Then, we will read this key and use it to store our trained model in a file named  `filename_sec`:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now the model is encrypted. It will be transferred to the destination where
    it will be used for prediction:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will define a function named  `decrypt()`  that we can use to decrypt
    the model from  `filename_sec`  to  `filename_destination`  using the key stored
    in the  `key.key` file:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now let''s use this function to decrypt the model and store it in a file named  `filename_destination`:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now let''s use this unencrypted file to load the model and use it for predictions:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/62b061a9-c024-47b5-b3fa-8c4cbe41f146.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
- en: Note that we have used symmetric encryption to encode the model. The same technique
    can be used to encrypt data as well, if needed.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about cryptographic algorithms. We started by identifying
    the security goals of a problem. We then discussed various cryptographic techniques
    and also looked at the details of the PKI infrastructure. Finally, we looked at
    the different ways of protecting a trained machine learning model against common
    attacks. Now, you should be able to understand the fundamentals of security algorithms
    used to protect modern IT infrastructures.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at designing large-scale algorithms. We will
    study the challenges and trade-offs involved in designing and selecting large
    algorithms. We will also look at the use of a GPU and clusters to solve complex
    problems.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
