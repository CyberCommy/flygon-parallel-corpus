- en: Cryptography
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduces you to algorithms related to cryptography. We will start
    by presenting the background, then we will discuss symmetric encryption algorithms.
    We will then explain the **Message-Digest 5** (**MD5**) algorithm and the **Secure
    Hash Algorithm**(**SHA**) and present the limitations and weaknesses of implementing
    symmetric algorithms. Next, we will discuss asymmetric encryption algorithms and
    how they are used to create digital certificates. Finally, we will present a practical
    example that summarizes all of these techniques.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a basic understanding of various issues
    related to cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics are discussed in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to cryptography
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the types of cryptography techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example – security concerns when deploying a machine learning model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by looking at the basic concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Cryptography
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Techniques to protect secrets have been around for centuries. The earliest attempts
    to secure and hide data from adversaries date back to ancient inscriptions discovered
    on monuments in Egypt, where a special alphabet that was known by only a few trusted
    people was used. This early form of security is called **obscurity** and is still
    used in different forms today. In order for this method to work, it is critical
    to protect the secret, which is the meaning of the alphabet. Later in time, finding
    foolproof ways of protecting important messages was important in both World War
    One and World War Two. In the late-20^(th) century, with the introduction of electronics
    and computers, sophisticated algorithms were developed to secure data, giving
    rise to a whole new field called **cryptography**. This chapter discusses the
    algorithmic aspects of cryptography. The purpose of these algorithms is to allow
    secure data exchange between two processes or users. Cryptographic algorithms
    find strategies of using mathematical functions to ensure the stated security
    goals.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Importance of the Weakest Link
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, when architecting the security of digital infrastructure, we put
    too much emphasis on the security of individual entities and don't pay the necessary
    attention to end-to-end security. This can result in us overlooking some loopholes
    and vulnerabilities in the system, which can later be exploited by hackers to
    access sensitive data. The important point to remember is that a digital infrastructure,
    as a whole, is only as strong as its **weakest link**. For a hacker, this weakest
    link can provide backdoor access to the sensitive data in the digital infrastructure.
    Beyond a certain point, there is not much benefit in fortifying the front door
    without closing all the back doors.
  prefs: []
  type: TYPE_NORMAL
- en: As the algorithms and techniques for keeping digital infrastructure become more
    and more sophisticated, attackers keep upgrading their techniques as well. It
    is always important to remember that one of the easiest ways for attackers to
    hack digital infrastructure is by exploiting these vulnerabilities to access sensitive
    information.
  prefs: []
  type: TYPE_NORMAL
- en: In 2014, a cyber attack on a Canadian federal research institute—the **National
    Research Council** (**NRC**)—is estimated to have cost hundreds of millions of
    dollars. The attackers were able to steal decades of research data and intellectual
    property material. They used a loophole in the Apache software that was used on
    the web servers to gain access to the sensitive data.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will highlight the vulnerabilities of various encryption
    algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first look at the basic terminology used.
  prefs: []
  type: TYPE_NORMAL
- en: The Basic Terminology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at the basic terminology related to cryptography:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cipher**: An algorithm that performs a particular cryptographic function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Plain text**: The plain data, which can be a text file, a video, a bitmap,
    or a digitized voice. In this chapter, we will represent plain text as *P*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cipher text**: The scrambled text that is obtained after applying cryptography
    to the plain text. In this chapter, we will represent this as *C*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cipher suite**: A set or suite of cryptographic software components. When
    two separate nodes want to exchange messages using cryptography, they first need
    to agree on a cipher suite. This is important in ensuring that they use exactly
    the same implementation of the cryptographic functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encryption**: The process of converting plain text, *P*, into cipher text,
    *C*, is called encryption.  Mathematically, it is represented by *encrypt(P) =
    C*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decryption**: The process of converting cipher text back into plain text.
    Mathematically, it is represented by *decrypt(C) = P*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cryptanalysis**: The methods used to analyze the strength of the cryptographic
    algorithms. The analyst tries to recover the plain text without access to the
    secret.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Personally Identifiable Information** (**PII**): PII is the information that
    can be used to trace an individual''s identity when used alone or with other relevant
    data. Some examples include protected information, such as a social security number,
    date of birth, or mother''s maiden name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Security Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is important to first understand the exact security needs of a system. Understanding
    this will help us use the correct cryptographic technique and discover the potential
    loopholes in a system. In order to do this, we first need to better understand
    the needs of the system. In order to understand the security requirements, we
    perform the following three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify the entities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Establish the security goals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the sensitivity of the data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at these steps one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the Entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One way to identify the entities is to start by answering the following four
    questions, which will help us understand the needs of the system in the context
    of security:'
  prefs: []
  type: TYPE_NORMAL
- en: Which applications need to be protected?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Who are we protecting the applications from?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where should we protect them?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why are we protecting them?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we better understand these requirements, we can establish the security
    goals of our digital system.
  prefs: []
  type: TYPE_NORMAL
- en: Establishing the Security Goals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Cryptographic algorithms are typically used to meet one or more security goals:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication**:Simply put, authentication is how we prove that a user is
    who they claim to be. Through the process of authentication, we ensure that a
    user''s identity is verified. The process of authentication starts by having the
    user present their identity. This is followed by providing information that is
    only known by the user and so can only be produced by them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Confidentiality**:  Data that needs to be protected is called **sensitive
    data**. Confidentiality is the concept of restricting sensitive data to authorized
    users only. To protect the confidentiality of sensitive data during its transit
    or in storage, you need to render the data so that it is unreadable except by
    authorized users. This is accomplished by using encryption algorithms, which we
    will discuss later on in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integrity**: Integrity is the process of establishing that data has not been
    altered in any way during its transit or storage. For example, **TCP/IP** (**Transmission
    Control Protocol/Internet Protocol**) uses checksum or **Cyclic Redundancy Check**
    (**CRC**) algorithms to verify data integrity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Non-repudiation**: Non-repudiation is the concept of a sender of information
    receiving confirmation that the data was received and the recipient receiving
    confirmation of the sender''s identity. This provides irrefutable evidence that
    a message was sent or received, which can be used later to prove the receipt of
    data and the points of failures in communication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Sensitivity of the Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is important to understand the classified nature of data. We also need to
    think about how serious the consequences are if the data is compromised. The classification
    of the data helps us choose the correct cryptographic algorithm. There is more
    than one way to classify data, based on the sensitivity of the information it
    contains. Let''s look at the typical ways of classifying data:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Public data or unclassified data**: Anything that is available for consumption
    for the public. For example, information found on a company''s website or a government''s
    info portal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Internal data or confidential data**:Although not for public consumption,
    exposing this data to the public may not have damaging consequences. For example,
    if an employee''s emails complaining about their manager are exposed, it may be
    embarrassing for the company but this may not have damaging consequences.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sensitive data or secret data**:  Data that is not supposed to be for public
    consumption and exposing it to the public has damaging consequences for an individual
    or an organization. For example, leaking the details of a future iPhone may harm
    Apple''s business goals and can give an advantage to rivals, such as Samsung.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Highly sensitive data**: Also called **top-secret data**. This is information
    that if disclosed, would be extremely damaging to the organization. This can include
    customer social security numbers, credit card numbers, or other very sensitive
    information. Top-secret data is protected through multiple layers of security
    and requires special permission to access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, more sophisticated security designs are much slower than simple
    algorithms. It is important to strike the right balance between the security and
    the performance of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Basic Design of Ciphers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Designing ciphers is about coming up with an algorithm that can scramble sensitive
    data so that a malicious process or an unauthorized user cannot access it. Although
    over time ciphers have become more and more sophisticated, the underlying principles
    that ciphers are based on remain unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by looking at some relatively simple ciphers that will help us understand
    the underlying principles that are used in the design of cryptographic algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Presenting Substitution Ciphers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Substitution ciphers have been in use for hundreds of years in various forms.
    As the name indicates, substitution ciphers are based on a simple concept—substituting
    characters in plain text with other characters in a predetermined, organized way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the exact steps involved in this:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we map each character to a substitute character.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, encode and convert the plaintext into cipher text by replacing each character
    in the plain text with another character in the ciphertext using substitution
    mapping.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To decode, bring back the plaintext by using substitution mapping.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s look at some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Caesar cipher**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In Caesar ciphers, the substitution mapping is created by replacing each character
    with the third character to the right of it. This mapping is described in the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/91bc4fec-861e-4d78-9050-7f30a9758aa1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s see how we can implement a Caesar cipher using Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We can see that we applied a Caesar cipher to the plaintext, `CALM`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s print the cipher text after encrypting with the Caesar cipher:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8edd428d-94b2-436e-ac6f-a1878e094b43.png)Caesar ciphers are said
    to have been used by Julius Caesar to communicate with his advisers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rotation 13** (**ROT13**):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ROT13 is another of the substitution-based encryptions. In ROT13, the substitution
    mapping is created by replacing each character with the 13^(th) character to the
    right of it. The following diagram illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a44fe40c-b91e-469b-bfcb-efef009e8856.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This means that if `ROT13()` is the function that implements ROT13, then the
    following applies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s print the encoded value of `C`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/49619d35-4c7c-45be-a774-966b96f9a104.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Cryptanalysis of substitution ciphers** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Substitution ciphers are simple to implement and understand. Unfortunately,
    they are also easy to crack. A simple cryptanalysis of substitution ciphers shows
    that if we use the English language alphabet, then all we need to determine to
    crack the cipher is how much are we rotating by. We can try each letter of the
    English alphabet one by one until we are able to decrypt the text. This means
    that it will take around 25 attempts to reconstruct the plain text.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at another type of simple cipher—transposition ciphers.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Transposition Ciphers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In transposition ciphers, the characters of the plain text are transposed.
    Let''s look at the steps involved for this:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the matrix and choose the size of the transposition matrix. It should
    be large enough to fit the plain text string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill in the matrix by writing in all of the characters of the string horizontally.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read all of the characters of the string vertically in the matrix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take the `Ottawa Rocks` plain text (*P*).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s encode *P*. For that, we will use a 3 x 4  matrix and write in
    the plaintext horizontally:'
  prefs: []
  type: TYPE_NORMAL
- en: '| O | t | t | a |'
  prefs: []
  type: TYPE_TB
- en: '| w | a | R | o |'
  prefs: []
  type: TYPE_TB
- en: '| c | k | s |  |'
  prefs: []
  type: TYPE_TB
- en: The `read` process will read the string vertically, which will generate the
    cipher text—`OwctaktRsao`.
  prefs: []
  type: TYPE_NORMAL
- en: The Germans used a cipher named ADFGVX in the First World War, which used both
    the transposition and substitution ciphers. Years later, it was cracked by George
    Painvin.
  prefs: []
  type: TYPE_NORMAL
- en: So, these are some of the types of ciphers. Now, let's look at some of the cryptographic
    techniques that are currently used.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Types of Cryptographic Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Different types of cryptographic techniques use different types of algorithms
    and are used under different sets of circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Broadly, cryptographic techniques can be divided into the following three types:'
  prefs: []
  type: TYPE_NORMAL
- en: Hashing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Symmetric
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asymmetric
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Cryptographic Hash Function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The cryptographic hash function is a mathematical algorithm that can be used
    to create unique fingerprint of a message. It creates a fixed-sized output, called
    a **hash**, from plain text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mathematically, this looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*C[1]  = hashFunction(P[1])*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*P[1]* is the plain text representing the input data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C[1]*  is a fixed-length hash that is generated by the cryptographic hash
    function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is shown in the following diagram. The variable-length data is converted
    into a fixed-length hash through a one-way hash function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/36a659e2-2da6-459b-969d-b8400697eb4c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The hash function has the following five characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: It is deterministic. The same plain text generates the same hash.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unique input strings should generate unique output hash values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regardless of the input message, it has a fixed length.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even small changes in the plain text generate a new hash.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a one-way function, which means that plain text, *P*[*1*,]  cannot be
    generated from the cipher text, *C*[*1*.]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we have a situation where each unique message does not have a unique hash,
    we call it a **collision**. That is, if we have two texts, *P[1]*  and *P[2]*  ,
    in the case of collision, it means *hashFunction(P[1]) = hashFunction(P[2])*.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of the hashing algorithm used, collisions are rare. Otherwise, hashing
    wouldn't be useful. However, for some applications, collisions cannot be tolerated.
    In those cases, we need to use a hashing algorithm that is more complex but much
    less likely to generate hash values that collide.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing cryptographic hash functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cryptographic hash functions can be implemented by using various algorithms.
    Let's take a deeper look at two of them.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding MD5-tolerated
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MD5 was developed by Poul-Henning Kamp in 1994 to replace MD4\. It generates
    a 128-bit hash. MD5 is a relatively simple algorithm that is vulnerable to collision.
    In applications where a collision cannot be tolerated, MD5 should not be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example. In order to generate an MD5 hash in Python, we will
    use the `passlib` library, which one of the most popular open source libraries,
    implementing over 30 password-hashing algorithms. If it is not already installed
    on your device, install it by using the following code in a Jupyter notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In Python, we can generate the MD5 hash as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/32a01072-7c27-4d65-a565-26af8195a8da.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that MD5 generates a hash of 128 bits.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned, we can use this generated hash as a fingerprint of the original
    text, which was `myPassword`. Let''s see how we can do this in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dd3a883a-f1b2-4fd5-bf4a-35a505809106.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the generated hash for the `myPassword` string  matched the original
    hash, which generated a `True` value. However, it returned `False` as soon as
    the plain text was changed to `myPassword2`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at another hashing algorithm—**Secure Hash Algorithm** (**SHA**).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding SHA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SHA was developed by the **National Institute of Standards and Technology**
    (**NIST**). Let''s see how we can use Python to create a hash using the SHA algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of a parameter called `salt`. Salting is the procedure of adding
    random characters before hashing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this code will give us the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0ac664a2-c588-48d5-a4d9-934b566d653f.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that when we use the SHA algorithm, the hash generated is of 512 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: An Application of the Cryptographic Hash Function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hash functions are used to check the integrity of a file after making a copy
    of it. To achieve this, when a file is copied from a source to a destination (for
    example, when downloaded from a web server), a corresponding hash is also copied
    with it. This original hash, *h[original]*, acts as a fingerprint of the original
    file. After copying the file, we generate the hash again from the copied version
    of the file—that is, *h[copied]*. If *h*[*original*] = *h[copied]*—that is, the
    generated hash matches the original hash—this verifies that the file has not changed
    and none of the data was lost during the download process. We can use any cryptographic
    hash function, such as MD5 or SHA, to generate a hash for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at symmetric encryption.
  prefs: []
  type: TYPE_NORMAL
- en: Using Symmetric Encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In cryptography, a key is a combination of numbers that is used to encode plain
    text using an algorithm of our choice. In symmetric encryption, we use the same
    key for encryption and decryption. If the key used for symmetric encryption is
    *K*, then for symmetric encryption, the following equation holds:'
  prefs: []
  type: TYPE_NORMAL
- en: '*E[K](P) = C*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, *P* is the plain text and *C* is the cipher text.
  prefs: []
  type: TYPE_NORMAL
- en: 'For decryption, we use the same key, *K*, to convert it back to *P*:'
  prefs: []
  type: TYPE_NORMAL
- en: '*D[K](C) = P*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This process is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/52dabfcd-01bc-4ef2-80ce-c70d455676c8.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's look at how we can use symmetric encryption with Python.
  prefs: []
  type: TYPE_NORMAL
- en: Coding Symmetric Encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use Python''s `cryptography` package, in this section, to demonstrate
    symmetric encryption. It is a comprehensive package that implements many cryptographic
    algorithms, such as symmetric ciphers and different message digests. When using
    it for the first time, we first need to install it using the `pip` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, we can now use the package to implement symmetric encryption,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s import the packages we need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s generate the key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/90609769-1a16-48cf-96b8-6fefa3799ab5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s open the key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the key, let''s now try to encrypt the message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s decrypt the message using the same key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s decrypt the message and assign it to a variable named `decrypt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now print the `decrypt` variable to verify whether we are able to get
    the same message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/556b14e4-1ddb-4956-906a-06c41f96996e.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's look at some of the advantages of symmetric encryption.
  prefs: []
  type: TYPE_NORMAL
- en: The Advantages of Symmetric Encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although the performance of the symmetric encryption is dependent on the exact
    algorithm that is used, in general, it is a lot faster than asymmetric encryption.
  prefs: []
  type: TYPE_NORMAL
- en: The Problems with Symmetric Encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When two users or processes plan to use symmetric encryption to communicate,
    they need to exchange keys using a secure channel. This gives rise to the following
    two problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Key protection**: How to protect the symmetric encryption key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Key distribution**:  How to share the symmetric encryption key from the source
    to the destination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's look at asymmetric encryption.
  prefs: []
  type: TYPE_NORMAL
- en: Asymmetric Encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the 1970s, asymmetric encryption was devised to address some of the weaknesses
    of symmetric encryption that we discussed in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step in asymmetric encryption is to generate two different keys that
    look totally different but are algorithmically related. One of them is chosen
    as the private key, *K[pr]*, and the other one is chosen as the public key, *K[pu]*.
    Mathematically, we can represent this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*E[Kpr](P) = C*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, *P* is the plain text and *C* is the cipher text.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can decrypt it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*D[Kpu](C) = P*'
  prefs: []
  type: TYPE_NORMAL
- en: Public keys are supposed to be freely distributed and private keys are kept
    secret by the owner of the key pair.
  prefs: []
  type: TYPE_NORMAL
- en: The fundamental principle is that if you encrypt with one of the keys, the only
    way to decrypt it is by using the other key. For example, if we encrypt the data
    using the public key, we will need to decrypt it using the other key—that is,
    the private key. Now, let's look at one of the fundamental protocols of asymmetric
    encryption—the **Secure Sockets Layer** (**SSL**)/**Transport Layer Security**
    (**TLS**) handshake—which is responsible for establishing a connection between
    two nodes using asymmetric encryption.
  prefs: []
  type: TYPE_NORMAL
- en: The SSL/TLS Handshaking Algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SSLwas originally developed to add security to HTTP. Over time, SSL was replaced
    with a more efficient and more secure protocol, called TLS. TLS handshakes are
    the basis of how HTTP creates a secure communication session. A TLS handshake
    occurs between the two participating entities—the **client** and the **server**.
    This process is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/787e64d9-a0ed-47d9-9c9b-c7409c0926ea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A TLS handshake establishes a secure connection between the participating nodes.
    The following are the steps that are involved in this process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The client sends a `client hello` message to the server. The message also contains
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The version of TLS that is used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list of cipher suites supported by the client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A compression algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A random byte string, identified by `byte_client`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The server sends a `server hello` message back to the client. The message also
    contains the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A cipher suite selected by the server from the list provided by the client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A session ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A random byte string, identified by `byte_server`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A server digital certificate, identified by `cert_server`, containing the public
    key of the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the server requires a digital certificate for client authentication or a
    client certificate request, the client server request also includes the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The distinguished names of the acceptable CAs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The types of certificates supported
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client verifies `cert_server`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client generates a random byte string, identified by `byte_client2`, and
    encrypts it with the public key of the server provided through `cert_server`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client generates a random byte string and identifies encrypts with its own
    private key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server verifies the client certificate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client sends a `finished` message to the server, which is encrypted with
    a secret key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To acknowledge this from the server side, the server sends a `finished` message
    to the client, which is encrypted with a secret key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The server and client have now established a secure channel. They can now exchange
    messages that are symmetrically encrypted with the shared secret key. The entire
    methodology is shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/6a90b582-3e7c-4378-9f8b-63fec0e0db16.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's discuss how we can use asymmetric encryption to create **Public Key
    Infrastructure** (**PKI**), which is created to meet one or more security goals
    for an organization.
  prefs: []
  type: TYPE_NORMAL
- en: Public Key Infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asymmetric encryption is used to implement PKI. PKI is one of the most popular
    and reliable ways to manage encryption keys for an organization. All the participants
    trust a central trusting authority called a CA.CAs verify the identity of individuals
    and organizations and then issue them digital certificates (a digital certificate
    contains a copy of a person or organization's public key and its identity), verifying
    that the public key associated with that individual or organization actually belongs
    to that individual or organization.
  prefs: []
  type: TYPE_NORMAL
- en: The way it works is that the CA asks a user to prove their identity, with different
    standards followed for individuals and organizations. This could involve simply
    verifying ownership of a domain name, or it could involve a more rigorous process
    that involves physical proof of identity, depending on the type of digital certificate
    that a user is trying to obtain. If the CA is satisfied that the user is indeed
    who they claim to be, the user then provides the CA with their public encryption
    key over a secure channel. The CA uses this information to create a digital certificate
    that contains information about the user's identity and their public key. This
    certificate is digitally signed by the CA. The user can then show their certificate
    to anyone who wants to verify their identity, without having to send it through
    a secure channel, as the certificate doesn't contain any sensitive information
    itself. The person receiving the certificate does not have to verify the user's
    identity directly. That person can simply verify that the certificate is valid
    by verifying the CA's digital signature, which validates that the public key contained
    in the certificate does, in fact, belong to the individual or organization named
    on the certificate.
  prefs: []
  type: TYPE_NORMAL
- en: The private key of the CA of an organization is the weakest link in the PKI
    chain of trust. If an impersonator gets hold of Microsoft's private key, for example,
    they can install malicious software onto millions of computers around the world
    by impersonating a Windows update.
  prefs: []
  type: TYPE_NORMAL
- en: Example – Security Concerns When Deploying a Machine Learning Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 6](ce14ecc1-8ad5-406e-88d0-7f3acb3e4569.xhtml), *Unsupervised Machine
    Learning Algorithms*, we looked at the **CRISP-DM**  (**Cross-Industry Standard
    Process for Data Mining**) life cycle, which specifies the different phases of
    training and deploying a machine learning model. Once a model is trained and evaluated,
    the final phase is deployment. If it is a critical machine learning model, then
    we want to make sure that all of its security goals are met.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s analyze the common challenges faced in deploying a model such as this
    and how we can address those challenges using the concepts discussed in this chapter.
    We will discuss strategies to protect our trained model against the following
    three challenges:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Man-in-the-Middle** (**MITM**) attacks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Masquerading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data tempering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: MITM attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the possible attacks that we would want to protect our model against
    is MITM attacks. A MITM attack occurs when an intruder tries to eavesdrop on a
    supposedly private communication to deploy a trained machine learning model.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try to understand MITM attacks sequentially using an example scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that Bob and Alice want to exchange messages using PKI:'
  prefs: []
  type: TYPE_NORMAL
- en: Bob is using {Pr[Bob], Pu[Bob]} and Alice is using {Pr[Alice], Pu[Alice]}. Bob
    has created a message, *M[Bob]*, and Alice has created a message, *M[Alice]*.
    They want to exchange these messages with each other in a secure way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initially, they need to exchange their public keys to establish a secure connection
    with each other. This means that Bob uses *Pu[Alice]*  to encrypt *M[Bob]* before
    sending the message to Alice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's assume that we have an eavesdropper, *X*, who is using {Pr[X], Pu[X]}.
    The attacker is able to intercept the public key exchanges between Bob and Alice
    and replace them with its own public certificate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bob sends *M[Bob]*  to Alice, encrypting it with *Pu[X]*  instead of *Pu[Alice]*,
    wrongfully thinking that this is Alice's public certificate. Eavesdropper *X*
    intercepts the communication. It intercepts the *M[Bob]*  message and decrypts
    it using *Pr[Bob]*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This MITM attack is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1500b5c1-9b2b-4c0c-8c7c-c1ca674612eb.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's look at how we can prevent MITM attacks.
  prefs: []
  type: TYPE_NORMAL
- en: How to prevent MITM attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's explore how we can prevent MITM attacks by introducing a CA to the organization.
    Let's say the name of this CA is myTrustCA. The digital certificate has its public
    key, named *Pu[myTrustCA]*, embedded in it.myTrustCA is responsible for signing
    the certificates for all of the people in the organization, including Alice and
    Bob. This means that both Bob and Alice have their certificates signed by myTrustCA.
    When signing their certificates, myTrustCA verifies that they are indeed who they
    claim to be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, with this new arrangement in place, let''s revisit the sequential interaction
    between Bob and Alice:'
  prefs: []
  type: TYPE_NORMAL
- en: Bob is using {Pr[Bob], Pu[Bob]} and Alice is using {Pr[Alice], Pu[Alice]}. Both
    of their public keys are embedded into their digital certificates, signed by myTrustCA.
    Bob has created a message, *M[Bob]*, and Alice has created a message, *M[Alice]*.
    They want to exchange these messages with each other in a secure way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They exchange their digital certificates, which contain their public keys. They
    will only accept the public keys if they are embedded in the certificates signed
    by the CA they trust. They need to exchange their public keys to establish a secure
    connection with each other. This means that Bob will use *Pu**[Alice]*  to encrypt
    *M**[Bob]* before sending the message to Alice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's assume that we have an eavesdropper, *X*, who is using {Pr[X], Pu[X]}.
    The attacker is able to intercept the public key exchanges between Bob and Alice
    and replace them with its own public certificate,  *Pu[X]*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bob rejects *X*'s attempt, as the bad guy's digital certificate is not signed
    by the CA that Bob trusts. The secure handshake is aborted, the attempted attack
    is logged with a timestamp and all details, and a security exception is raised.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When deploying a trained machine learning model, instead of Alice, there is
    a deployment server. Bob only deploys the model after establishing a secure channel,
    using the previously mentioned steps.
  prefs: []
  type: TYPE_NORMAL
- en: Let us see how we can implement this in Python.
  prefs: []
  type: TYPE_NORMAL
- en: First let us import the packages that are needed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now let us create a class that can verify the certirficate.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Let us look into other vulnerabilities that our deployed model can face.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding Masquerading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Attacker *X* pretends to be an authorized user, Bob, and gains access to sensitive
    data, which is the trained model, in this case. We need to protect the model against
    any unauthorized changes.
  prefs: []
  type: TYPE_NORMAL
- en: One way of protecting our trained model against masquerading is by encrypting
    the model with an authorized user's private key. Once encrypted, anyone can read
    and utilize the model by decrypting it through the public key of the authorized
    user, which is found in their digital certificate. No one can make any unauthorized
    changes to the model.
  prefs: []
  type: TYPE_NORMAL
- en: Data and Model Encrpytion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the model is deployed, the real-time unlabeled data that is provided as
    input to the model can also be tampered with. The trained model is used for inference
    and provides a label to this data. To protect data against tampering, we need
    to protect the data at rest and in communication. To protect the data at rest,
    symmetric encryption can be used to encode it. To transfer the data, SSL/TLS-based
    secure channels can be established to provide a secure tunnel. This secure tunnel
    can be used to transfer the symmetric key and the data can be decrypted on the
    server before it is provided to the trained model.
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the more efficient and foolproof ways to protect data against
    tampering.
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric encryption can also be used to encrypt a model when it has been trained,
    before deploying it to a server. This will prevent any unauthorized access to
    the model before it is deployed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can encrypt a trained model at the source, using symmetric
    encryption with the help of the following steps, and then decrypt it at the destination
    before using it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first train a simple model using the Iris dataset:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s define the names of the files that will store the model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note that  `filename_source`  is the file that will store the trained unencrypted  model
    at the source.  `filename_destination`  is the file that will store the trained
    unencrypted model at the destination, and  `filename_sec`  is the encrypted trained
    model.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use  `pickle`  to store the trained model in a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define a function named  `write_key()`  that will generate a symmetric
    key and store it in a file named  `key.key`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s define a function named  `load_key()`  that can read the stored
    key from the  `key.key` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s define an  `encrypt()`  function that can encrypt and train the
    model, and store it in a file named  `filename_sec`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use these functions to generate a symmetric key and store it in a file.
    Then, we will read this key and use it to store our trained model in a file named  `filename_sec`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the model is encrypted. It will be transferred to the destination where
    it will be used for prediction:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will define a function named  `decrypt()`  that we can use to decrypt
    the model from  `filename_sec`  to  `filename_destination`  using the key stored
    in the  `key.key` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s use this function to decrypt the model and store it in a file named  `filename_destination`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s use this unencrypted file to load the model and use it for predictions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/62b061a9-c024-47b5-b3fa-8c4cbe41f146.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that we have used symmetric encryption to encode the model. The same technique
    can be used to encrypt data as well, if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about cryptographic algorithms. We started by identifying
    the security goals of a problem. We then discussed various cryptographic techniques
    and also looked at the details of the PKI infrastructure. Finally, we looked at
    the different ways of protecting a trained machine learning model against common
    attacks. Now, you should be able to understand the fundamentals of security algorithms
    used to protect modern IT infrastructures.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at designing large-scale algorithms. We will
    study the challenges and trade-offs involved in designing and selecting large
    algorithms. We will also look at the use of a GPU and clusters to solve complex
    problems.
  prefs: []
  type: TYPE_NORMAL
