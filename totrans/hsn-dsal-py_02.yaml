- en: Python Data Types and Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to examine Python data types in more detail. We
    have already introduced two data types, the string and list, `str()` and `list()`.
    However, these data types are not sufficient, and we often need more specialized
    data objects to represent/store our data. Python has various other standard data
    types that are used to store and manage data, which we will be discussing in this
    chapter. In addition to the built-in types, there are several internal modules
    that allow us to address common issues when working with data structures. First,
    we are going to review some operations and expressions that are common to all
    data types, and we will discuss more related to data types in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter''s objectives are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding various important built-in data types supported in Python 3.7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring various additional collections of high-performance alternatives to
    built-in data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of the code used in this chapter is given at the following GitHub link: [https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter02](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter02).
  prefs: []
  type: TYPE_NORMAL
- en: Built-in data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python data types can be divided into three categories: numeric, sequence,
    and mapping. There is also the `None` object that represents `Null`, or the absence
    of a value. It should not be forgotten that other objects such as classes, files,
    and exceptions can also properly be considered *types*; however, they will not
    be considered here.'
  prefs: []
  type: TYPE_NORMAL
- en: Every value in Python has a data type. Unlike many programming languages, in Python
    you do not need to explicitly declare the type of a variable. Python keeps track
    of object types internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python built-in data types are outlined in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Category** | **Name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| None | `None` | It is a null object. |'
  prefs: []
  type: TYPE_TB
- en: '| Numeric | `int` | This is an integer data type. |'
  prefs: []
  type: TYPE_TB
- en: '|  | `float` | This data type can store a floating-point number. |'
  prefs: []
  type: TYPE_TB
- en: '|  | `complex` | It stores a complex number. |'
  prefs: []
  type: TYPE_TB
- en: '|  | `bool` | It is Boolean type and returns `True` or `False`. |'
  prefs: []
  type: TYPE_TB
- en: '| Sequences | `str` | It is used to store a string of characters. |'
  prefs: []
  type: TYPE_TB
- en: '|  | `liXst` | It can store a list of arbitrary objects. |'
  prefs: []
  type: TYPE_TB
- en: '|  | `Tuple` | It can store a group of arbitrary items. |'
  prefs: []
  type: TYPE_TB
- en: '|  | `range` | It is used to create a range of integers. |'
  prefs: []
  type: TYPE_TB
- en: '| Mapping | `dict` | It is a dictionary data type that stores data in *key/value*
    pairs. |'
  prefs: []
  type: TYPE_TB
- en: '|  | `set` | It is a mutable and unordered collection of unique items. |'
  prefs: []
  type: TYPE_TB
- en: '|  | `frozenset` | It is an immutable set. |'
  prefs: []
  type: TYPE_TB
- en: None type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `None` type is immutable. It is used as `None` to show the absence of a
    value; it is similar to `null` in many programming languages, such as C and C++.
    Objects return `None` when there is actually nothing to return. It is also returned
    by `False` Boolean expressions. `None` is often used as a default value in function
    arguments to detect whether a function call has passed a value or not.
  prefs: []
  type: TYPE_NORMAL
- en: Numeric types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Number types include integers (`int`), that is, whole numbers of unlimited
    range, floating-point numbers (`float`), complex numbers (`complex`), which are
    represented by two float numbers, and Boolean (`bool`) in Python. Python provides
    the `int` data type that allows standard arithmetic operators (`+`, `-`, `*` and
    `/` ) to work on them, similar to other programming languages. A Boolean data
    type has two possible values, `True` and `False`. These values are mapped to `1`
    and `0`, respectively. Let''s consider an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `a` and `b` variables are of the `int` type and `c` is a floating-point
    type. The division operator (`/`) always returns a `float` type; however, if you
    wish to get the `int` type after division, you can use the floor division operator
    (`//`), which discards any fractional part and will return the largest integer
    value that is less than or equal to `x`. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It is advised that readers use the division operator carefully, as its function
    differs according to the Python version. In Python 2, the division operator returns
    only `integer`, not `float`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exponent operator (`**`) can be used to get the power of a number (for
    example, `x ** y`), and the modulus operator (`%`) returns the remainder of the
    division (for example, `a% b` returns the remainder of `a/b`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Complex numbers are represented by two floating-point numbers. They are assigned
    using the `j` operator to signify the imaginary part of the complex number. We
    can access the real and imaginary parts with `f.real` and `f.imag`, respectively,
    as shown in the following code snippet. Complex numbers are generally used for
    scientific computations. Python supports addition, subtraction, multiplication,
    power, conjugates, and so forth on complex numbers, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In Python, Boolean types are represented using  truth values, that is, `True`
    and `False`; it''s similar to `0` and `1`*.* There is a `bool` class in Python,
    which returns `True` or `False`. Boolean values can be combined with logical operators
    such as `and`, `or`, and `not`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'A Boolean operation returns either `True` or `False`. Boolean operations are
    ordered in priority, so if more than one Boolean operation occurs in an expression,
    the operation with the highest priority will occur first. The following table
    outlines the three Boolean operators in descending order of priority:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| `not x` | It returns `False` if `x` is `True`, and returns `True` if `x`
    is `False`. |'
  prefs: []
  type: TYPE_TB
- en: '| `x and y` | It returns `True` if `x` and `y` are both `True`; otherwise,
    it returns `False`. |'
  prefs: []
  type: TYPE_TB
- en: '| `x or` `y` | It returns `True` if either `x` or `y` is `True`; otherwise,
    it returns `False`. |'
  prefs: []
  type: TYPE_TB
- en: Python is very efficient when evaluating Boolean expressions as it will only
    evaluate an operator if it needs to. For example, if `x` is `True` in an expression
    `x or y`, then there is no need to evaluate `y` since the expression is `True`
    anyway—that is why in Python the `y` is not evaluated. Similarly, in an expression `x and y`*,*
    if `x` is `False`, the interpreter will simply evaluate `x` and return `False`,
    without evaluating `y`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The comparison operators (`<`, `<=`, `>`, `>=`, `==`, and `!=`) work with numbers,
    lists, and other collection objects and return `True` if the condition holds.
    For collection objects, comparison operators compare the number of elements and
    the equivalence operator ( `==`) returns `True` if each collection object is structurally
    equivalent, and the value of each element is identical. Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Representation error
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It should be noted that the native double precision representation of floating-point
    numbers leads to some unexpected results. For example, consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a result of the fact that most decimal fractions are not exactly representable
    as a binary fraction, which is how most underlying hardware represents floating-point
    numbers. For algorithms or applications where this may be an issue, Python provides
    a decimal module. This module allows for the exact representation of decimal numbers
    and facilitates greater control of properties, such as rounding behavior, number
    of significant digits, and precision. It defines two objects, a `Decimal` type,
    representing decimal numbers, and a `Context` type, representing various computational
    parameters such as precision, rounding, and error handling. An example of its
    usage can be seen in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here we have created a global context and set the precision to `4`. The `Decimal`
    object can be treated pretty much as you would treat `int` or `float`. They are
    subject to all of the same mathematical operations and can be used as dictionary
    keys, placed in sets, and so on. In addition, `Decimal` objects also have several
    methods for mathematical operations, such as natural exponents, `x.exp()`; natural
    logarithms, `x.ln()`; and base 10 logarithms, `x.log10()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python also has a `fractions` module that implements a rational number type.
    The following example shows several ways to create fractions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: It is also worth mentioning here the NumPy extension. This has types for mathematical
    objects, such as arrays, vectors, and matrices, and capabilities for linear algebra,
    calculation of Fourier transforms, eigenvectors, logical operations, and much
    more.
  prefs: []
  type: TYPE_NORMAL
- en: Membership, identity, and logical operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Membership operators (`in` and `not in`) test for variables in sequences, such
    as lists or strings, and do what you would expect; `x in y` returns `True` if
    an `x` variable is found in `y`. The `is` operator compares object identity. For
    example, the following snippet shows contrast equivalence with object identity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Sequences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sequences are ordered sets of objects indexed by non-negative integers. Sequences
    include `string`, `list`, `tuple`, and `range` objects. Lists and tuples are sequences
    of arbitrary objects, whereas strings are sequences of characters. However, `string`,
    `tuple`, and `range` objects are immutable, whereas, the `list` object is mutable.
    All sequence types have a number of operations in common. Note that, for the immutable
    types, any operation will only return a value rather than actually change the
    value.
  prefs: []
  type: TYPE_NORMAL
- en: For all sequences, the indexing and slicing operators apply as described in
    the previous chapter. The `string` and `list` data types were discussed in detail
    in [Chapter 1](2818f56c-fbcf-422f-83dc-16cbdbd8b5bf.xhtml), *Python Objects, Types,
    and Expressions*. Here, we present some of the important methods and operations
    that are common to all of the sequence types (`string`, `list`, `tuple`, and `range`
    objects).
  prefs: []
  type: TYPE_NORMAL
- en: 'All sequences have the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `len(s)` | Returns the number of elements in `s`. |'
  prefs: []
  type: TYPE_TB
- en: '| `min(s,[,default=obj, key=func])` | Returns the minimum value in `s` (alphabetically
    for strings). |'
  prefs: []
  type: TYPE_TB
- en: '| `max(s,[,default=obj, key=func])` | Returns the maximum value in `s` (alphabetically
    for strings). |'
  prefs: []
  type: TYPE_TB
- en: '| `sum(s,[,start=0])` | Returns the sum of the elements (returns `TypeError`
    if `s`is not numeric). |'
  prefs: []
  type: TYPE_TB
- en: '| `all(s)` | Returns `True` if all elements in `s` are `True` (that is, not
    `0`, `False`, or `Null`). |'
  prefs: []
  type: TYPE_TB
- en: '| `any(s)` | Checks whether any item in `s` is `True`. |'
  prefs: []
  type: TYPE_TB
- en: 'In addition, all sequences support the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `s+r` | Concatenates two sequences of the same type. |'
  prefs: []
  type: TYPE_TB
- en: '| `s*n` | Makes `n` copies of `s`, where `n` is an integer. |'
  prefs: []
  type: TYPE_TB
- en: '| `v1,v2...,vn=s` | Unpacks `n` variables from `s` to `v1`, `v2`, and so on.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `s[i]` | Indexing returns the `i` element of `s`. |'
  prefs: []
  type: TYPE_TB
- en: '| `s[i:j:stride]` | Slicing returns elements between `i` and `j` with optional
    stride. |'
  prefs: []
  type: TYPE_TB
- en: '| `x in s` | Returns `True` if the `x` element is in `s`. |'
  prefs: []
  type: TYPE_TB
- en: '| `x not in s` | Returns `True` if the `x` element is not in `s`. |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s consider an example code snippet implementing some of the preceding
    operations on the `list` data type :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Learning about tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tuples are immutable sequences of arbitrary objects. A tuple is a comma-separated
    sequence of values; however, it is common practice to enclose them in parentheses.
    Tuples are very useful when we want to set up multiple variables in one line,
    or to allow a function to return multiple values of different objects. Tuple is
    an ordered sequence of items similar to the `list` data type. The only difference
    is that tuples are immutable; hence, once created they cannot be modified, unlike
    `list`. Tuples are indexed by integers greater than zero. Tuples are **hashable**,
    which means we can sort lists of them and they can be used as keys to dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: We can also create a tuple using the built-in function: `tuple()`. With no argument,
    this creates an empty tuple. If the argument to `tuple()` is a sequence then this
    creates a tuple of elements of that sequence. It is important to remember to use
    a trailing comma when creating a tuple with one element—without the trailing comma,
    this will be interpreted as a string. An important use of tuples is to allow us
    to assign more than one variable at a time by placing a tuple on the left-hand
    side of an assignment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Most operators, such as those for slicing and indexing, work as they do on
    lists. However, because tuples are immutable, trying to modify an element of a
    tuple will give you `TypeError`. We can compare tuples in the same way that we
    compare other sequences, using the `==`, `>` and `<` operators. Consider an example
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s consider another example to better understand tuples. For example, we
    can use multiple assignments to swap values in a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Beginning with dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Python, the `Dictionary` data type is one of the most popular and useful
    data types. A dictionary stores the data in a mapping of key and value pair. Dictionaries
    are mainly a collection of objects; they are indexed by numbers, strings, or any
    other immutable objects. Keys should be unique in the dictionaries; however, the
    values in the dictionary can be changed. Python dictionaries are the only built-in
    mapping type; they can be thought of as a mapping from a set of keys to a set
    of values. They are created using the `{key:value}` syntax. For example, the following
    code can be used to create a dictionary that maps words to numerals using different
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add keys and values. We can also update multiple values, and test for
    the membership or occurrence of a value using the `in` operator, as shown in the
    following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `in` operator to find an element in a list takes too much time if the list
    is long. The running time required to look up an element in a list increases linearly
    with an increase in the size of the list. Whereas, the `in` operator in dictionaries
    uses a hashing function, which enables dictionaries to be very efficient, as the
    time taken in looking up an element is independent of the size of the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice when we print out the `{key: value}` pairs of the dictionary it does
    so in no particular order. This is not a problem since we use specified keys to
    look up each dictionary value rather than an ordered sequence of integers, as
    is the case for strings and lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table contains all the dictionary methods and their descriptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `len(d)` | Returns total number of items in the dictionary, `d`. |'
  prefs: []
  type: TYPE_TB
- en: '| `d.clear()` | Removes all of the items from the dictionary, `d`. |'
  prefs: []
  type: TYPE_TB
- en: '| `d.copy()` | Returns a shallow copy of the dictionary, `d`. |'
  prefs: []
  type: TYPE_TB
- en: '| `d.fromkeys(s[,value])` | Returns a new dictionary with keys from the `s`
    sequence and values set to `value`. |'
  prefs: []
  type: TYPE_TB
- en: '| `d.get(k[,v])` | Returns `d[k]` if it is found; otherwise, it returns `v`
    (`None` if `v` is not given). |'
  prefs: []
  type: TYPE_TB
- en: '| `d.items()` | Returns all of the `key:value` pairs of the dictionary, `d`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `d.keys()` | Returns all of the keys defined in the dictionary, `d`. |'
  prefs: []
  type: TYPE_TB
- en: '| `d.pop(k[,default])` | Returns `d[k]` and removes it from `d`. |'
  prefs: []
  type: TYPE_TB
- en: '| `d.popitem()` | Removes a random `key:value` pair from the dictionary, `d`,
    and returns it as a tuple. |'
  prefs: []
  type: TYPE_TB
- en: '| `d.setdefault(k[,v])` | Returns `d[k]`. If it is not found, it returns `v`
    and sets `d[k]` to `v`. |'
  prefs: []
  type: TYPE_TB
- en: '| `d.update(b)` | Adds all of the objects from the `b` dictionary to the `d` dictionary .
    |'
  prefs: []
  type: TYPE_TB
- en: '| `d.values()` | Returns all of the values in the dictionary, `d`. |'
  prefs: []
  type: TYPE_TB
- en: Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It should be noted that the `in` operator, when applied to dictionaries, works
    in a slightly different way to when it is applied to a list. When we use the `in`
    operator on a list, the relationship between the time it takes to find an element
    and the size of the list is considered linear. That is, as the size of the list
    gets bigger, the corresponding time it takes to find an element grows, at most,
    linearly. The relationship between the time an algorithm takes to run compared
    to the size of its input is often referred to as its time complexity. We will
    talk more about this important topic in the next (and subsequent) chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to the `list` object, when the `in` operator is applied to dictionaries,
    it uses a hashing algorithm, and this has the effect of an increase in each lookup
    time that is almost independent of the size of the dictionary. This makes dictionaries
    extremely useful as a way to work with large amounts of indexed data. We will
    talk more about this important topic of rates of growth hashing in [Chapter 4](234b9cb7-47a2-4910-8039-d7fed6c4af81.xhtml), *Lists
    and Pointer Structures*, and [Chapter 14](1f1d6528-c080-4c90-abab-ab41d55d721e.xhtml), *Implementations,
    Applications, and Tools*.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we want to do a simple sort on either the keys or values of a dictionary,
    we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note that the first line in the preceding code sorts the keys alphabetically
    and the second line sorts the values in order of the integer value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sorted()` method has two optional arguments that are of interest: `key`
    and `reverse`. The `key` argument has nothing to do with the dictionary keys,
    but rather is a way of passing a function to the sort algorithm to determine the
    sort order. For example, in the following code, we use the `__getitem__` special
    method to sort the dictionary keys according to the dictionary values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f060180f-67e3-4a18-a2cf-de92fa784c2c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Essentially, what the preceding code is doing is, for every key in `d`, it
    uses the corresponding value to sort. We can also sort the values according to
    the sorted order of the dictionary keys. However, since dictionaries do not have
    a method to return a key by using its value, the equivalent of the `list.index`
    method for lists, using the optional key argument to do this is a little tricky.
    An alternative approach is to use a list comprehension, as the following example
    demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/8d05572b-0a3c-4320-9d9c-b6cf38b5243e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `sorted()` method also has an optional `reverse` argument, and unsurprisingly
    this does exactly what it says—reverses the order of the sorted list, as in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/bf6f08ee-d55a-4c47-8424-f493cbe2fc19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s say we are given the following dictionary, with English words as
    keys and French words as values. Our task is to place the string values in the
    correct numerical order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, when we print this dictionary out, it will be unlikely to print
    in the correct order. Because all keys and values are strings, we have no context
    for numerical ordering. To place these items in correct order, we need to use
    the first dictionary we created, mapping words to numerals as a way to order our
    English to French dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/06a4e849-5cde-45c4-893c-d2182152f278.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice we are using the values of the first dictionary, `d`, to sort the keys
    of the second dictionary, `d2`. Since our keys in both dictionaries are the same,
    we can use a list comprehension to sort the values of the French to English dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/25cc0171-9321-4d8f-8b78-aafc7196f837.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can, of course, define our own custom method that we can use as the key
    argument to the sorted method. For example, here we define a function that simply
    returns the last letter of a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use this as the key to our sorted function to sort each element
    by its last letter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/95c948bf-cd5b-4254-add5-e98835006e00.png)'
  prefs: []
  type: TYPE_IMG
- en: Dictionaries for text analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common use of dictionaries is to count the occurrences of like items in a
    sequence; a typical example is counting the occurrences of words in a body of
    text. The following code creates a dictionary where each word in the text is used
    as a key and the number of occurrences as its value. This uses a very common idiom
    of nested loops. Here we are using it to traverse the lines in a file in an outer
    loop and the keys of a dictionary on the inner loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return a dictionary with an element for each unique word in the text
    file. A common task is to filter items such as these into subsets we are interested
    in. You will need a text file saved in the same directory as you run the code.
    Here we have used `alice.txt`, a short excerpt from *Alice in Wonderland*. To
    obtain the same results, you can download `alice.txt` from [davejulian.net/bo5630](http://davejulian.net/bo5630) or
    use a text file of your own. In the following code, we create another dictionary,
    filtered, containing a subset of items from `count`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'When we print the filtered dictionary, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of the **dictionary comprehension** used to construct the filtered
    dictionary. Dictionary comprehensions work in an identical way to the list comprehensions
    we looked at in [Chapter 1](2818f56c-fbcf-422f-83dc-16cbdbd8b5bf.xhtml), *Python
    Objects, Types, and Expressions*.
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sets are unordered collections of unique items. Sets are themselves mutable—we
    can add and remove items from them; however, the items themselves must be immutable.
    An important distinction with sets is that they cannot contain duplicate items.
    Sets are typically used to perform mathematical operations such as intersection,
    union, difference, and complement.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike sequence types, set types do not provide any indexing or slicing operations.
    There are two types of set objects in Python, the mutable `set` object and the
    immutable `frozenset` object. Sets are created using comma-separated values within
    curly braces. By the way, we cannot create an empty set using `a={}`, because
    this will create a dictionary. To create an empty set, we write either `a=set()`
    or `a=frozenset()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Methods and operations of sets are described in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `len(a)` | Provides the total number of elements in the `a` set. |'
  prefs: []
  type: TYPE_TB
- en: '| `a.copy()` | Provides another copy of the `a` set. |'
  prefs: []
  type: TYPE_TB
- en: '| `a.difference(t)` | Provides a set of elements that are in the `a` set but
    not in `t`. |'
  prefs: []
  type: TYPE_TB
- en: '| `a.intersection(t)` | Provides a set of elements that are in both sets, `a`
    and `t`. |'
  prefs: []
  type: TYPE_TB
- en: '| `a.isdisjoint(t)` | Returns `True` if no element is common in both the sets, `a`
    and `t`. |'
  prefs: []
  type: TYPE_TB
- en: '| `a.issubset(t)` | Returns `True` if all of the elements of the `a` set are
    also in the `t` set. |'
  prefs: []
  type: TYPE_TB
- en: '| `a.issuperset(t)` | Returns `True` if all of the elements of the `t` set
    are also in the `a` set. |'
  prefs: []
  type: TYPE_TB
- en: '| `a.symmetric_difference(t)` | Returns a set of elements that are in either
    the `a` or `t` sets, but not in both. |'
  prefs: []
  type: TYPE_TB
- en: '| `a.union(t)` | Returns a set of elements that are in either the `a` or `t` sets.
    |'
  prefs: []
  type: TYPE_TB
- en: In the preceding table, the `t` parameter can be any Python object that supports
    iteration and all methods are available to both `set` and `frozenset` objects.
    It is important to be aware that the operator versions of these methods require
    their arguments to be sets, whereas the methods themselves can accept any iterable
    type. For example, `s-[1,2,3]`, for any set, `s`, will generate an unsupported
    operand type. Using the equivalent, `s.difference([1,2,3])` will return a result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mutable `set` objects have additional methods, described in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `s.add(item)` | Adds an item to `s`; nothing happens if the item is already
    added. |'
  prefs: []
  type: TYPE_TB
- en: '| `s.clear()` | Removes all elements from the set, `s`. |'
  prefs: []
  type: TYPE_TB
- en: '| `s.difference_update(t)` | Removes those elements from the `s` set that are
    also in the other set, `t`. |'
  prefs: []
  type: TYPE_TB
- en: '| `s.discard(item)` | Removes the item from the set, `s`. |'
  prefs: []
  type: TYPE_TB
- en: '| `s.intersection_update(t)` | Remove the items from the set, `s`, which are
    not in the intersection of the sets, `s` and `t`. |'
  prefs: []
  type: TYPE_TB
- en: '| `s.pop()` | Returns an arbitrary item from the set, `s`, and it removes it
    from the `s` set. |'
  prefs: []
  type: TYPE_TB
- en: '| `s.remove(item)` | Deletes the item from the `s` set. |'
  prefs: []
  type: TYPE_TB
- en: '| `s.symetric_difference_update(t)` | Deletes all of the elements from the `s` set
    that are not in the symmetric difference of the sets, `s` and `t`. |'
  prefs: []
  type: TYPE_TB
- en: '| `s.update(t)` | Appends all of the items in an iterable object, `t`, to the `s`
    set. |'
  prefs: []
  type: TYPE_TB
- en: 'Here, consider a simple example showing addition, removal, discard, and clear
    operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example demonstrates some simple set operations and their results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/1a0c26a1-0555-49b8-8608-248609446dc5.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the `set` object does not care that its members are not all of the
    same type, as long as they are all immutable. If you try to use a mutable object
    such as a list or dictionary in a set, you will receive an unhashable type error.
    Hashable types all have a hash value that does not change throughout the lifetime
    of the instance. All built-in immutable types are hashable. All built-in mutable
    types are not hashable, so they cannot be used as elements of sets or keys to
    dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: Notice also in the preceding code that when we print out the union of `s1` and
    `s2`, there is only one element with the value `'ab'`. This is a natural property
    of sets in that they do not include duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these built-in methods, there are a number of other operations
    that we can perform on sets. For example, to test for membership of a set, use
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/5c5e5c1a-63b6-4006-afac-81716a723380.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can loop through elements in a set using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2399773c-55a5-49a9-9a07-415c66c31853.png)'
  prefs: []
  type: TYPE_IMG
- en: Immutable sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python has an immutable set type called `frozenset`. It works pretty much exactly
    like `set`, apart from not allowing methods or operations that change values such
    as the `add()` or `clear()` methods. There are several ways that this immutability
    can be useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, since normal sets are mutable and therefore not hashable, they
    cannot be used as members of other sets. On the other hand `frozenset` is immutable
    and therefore able to be used as a member of a set:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a230c9f0-720b-45ec-b2d3-42635c4e0682.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, the immutable property of `frozenset` means we can use it for a key to
    a dictionary, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b92757f5-6d64-4355-866e-0cdb00e71f53.png)'
  prefs: []
  type: TYPE_IMG
- en: Modules for data structures and algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the built-in types, there are several Python modules that we
    can use to extend the built-in types and functions. In many cases, these Python
    modules may offer efficiency and programming advantages that allow us to simplify
    our code.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have looked at the built-in datatypes of strings, lists, sets, and
    dictionaries as well as the decimal and fraction modules. They are often described
    by the term **Abstract ****Data Types** (**ADTs**). ADTs can be considered mathematical
    specifications for the set of operations that can be performed on data. They are
    defined by their behavior rather than their implementation. In addition to the
    ADTs that we have looked at, there are several Python libraries that provide extensions
    to the built-in datatypes. These will be discussed in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `collections` module provides more specialized, high-performance alternatives
    for the built-in data types as well as a utility function to create named tuples.
    The following table lists the datatypes and operations of the collections module
    and their descriptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Datatype or operation** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `namedtuple()` | Creates tuple subclasses with named fields. |'
  prefs: []
  type: TYPE_TB
- en: '| `deque` | Lists with fast appends and pops either end. |'
  prefs: []
  type: TYPE_TB
- en: '| `ChainMap` | Dictionary-like class to create a single view of multiple mappings.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Counter` | Dictionary subclass for counting hashable objects. |'
  prefs: []
  type: TYPE_TB
- en: '| `OrderedDict` | Dictionary subclass that remembers the entry order. |'
  prefs: []
  type: TYPE_TB
- en: '| `defaultdict` | Dictionary subclass that calls a function to supply missing
    values. |'
  prefs: []
  type: TYPE_TB
- en: '| `UserDict UserList UserString` | These three data types are simply wrappers
    for their underlying base classes. Their use has largely been supplanted by the
    ability to subclass their respective base classes directly. Can be used to access
    the underlying object as an attribute. |'
  prefs: []
  type: TYPE_TB
- en: Deques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Double-ended queues, or deques (usually pronounced *decks*), are list-like objects
    that support thread-safe, memory-efficient appends. Deques are mutable and support
    some of the operations of lists, such as indexing. Deques can be assigned by index,
    for example, `dq[1] = z`; however, we cannot directly slice deques. For example,
    `dq[1:2]` results in `TypeError` (we will look at a way to return a slice from
    a deque as a list shortly).
  prefs: []
  type: TYPE_NORMAL
- en: The major advantage of deques over lists is that inserting items at the beginning
    of a deque is much faster than inserting items at the beginning of a list, although
    inserting items at the end of a deque is very slightly slower than the equivalent
    operation on a list. Deques are thread-safe and can be serialized using the `pickle`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'A useful way of thinking about deques is in terms of populating and consuming
    items. Items in deques are usually populated and consumed sequentially from either
    end:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/bdd5dc25-b4ee-4f13-80dd-c2e7b82634c1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can use the `pop()`and `popleft()` methods for consuming items in the deque,
    as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/13e07836-1988-41fc-ba5a-aa3b008691b0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also use the `rotate(n)` method to move and rotate all items of `n`
    steps to the right for positive values of the `n` integer or negative values of
    `n` steps to the left, using positive integers as the argument, as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/bb9cb7b6-1956-438a-b247-b56375078185.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that we can use the `rotate` and `pop` methods to delete selected elements.
    Also worth knowing is a simple way to return a slice of a deque, as a list, which
    can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/811e6dec-b990-403d-a4a2-02d5214f0f38.png)'
  prefs: []
  type: TYPE_IMG
- en: The `itertools.islice()` method works in the same way that slice works on a
    list, except rather than taking a list for an argument, it takes an iterable and
    returns selected values, by start and stop indices, as a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'A useful feature of deques is that they support a `maxlen` optional parameter
    that restricts the size of the deque. This makes it ideally suited to a data structure
    known as a **circular buffer**. This is a fixed-size structure that is effectively
    connected end to end and they are typically used for buffering data streams. The
    following is a basic example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This prints out the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2d67615b-9051-493c-9727-6a2f6244f6f1.png)'
  prefs: []
  type: TYPE_IMG
- en: In this example, we are populating from the right and consuming from the left.
    Notice that once the buffer is full the oldest values are consumed first and values
    are replaced from the right. We will look at circular buffers again in [Chapter
    4](234b9cb7-47a2-4910-8039-d7fed6c4af81.xhtml), *Lists and Pointer Structures*,
    when implementing circular lists.
  prefs: []
  type: TYPE_NORMAL
- en: ChainMap objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `collections.chainmap` class was added in Python 3.2, and it provides a
    way to link a number of dictionaries, or other mappings, so that they can be treated
    as one object. In addition, there is a `maps` attribute, a `new_child()` method,
    and a `parents` property. The underlying mappings for `ChainMap` objects are stored
    in a list and are accessible using the `maps[i]` attribute to retrieve the `ith` dictionary.
    Note that, even though dictionaries themselves are unordered, `ChainMap` objects
    are ordered lists of dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: '`ChainMap` is useful in applications where we are using a number of dictionaries
    containing related data. The consuming application expects data in terms of a
    priority, where the same key in two dictionaries is given priority if it occurs
    at the beginning of the underlying list. `ChainMap` is typically used to simulate
    nested contexts such as when we have multiple overriding configuration settings.
    The following example demonstrates a possible use case for `ChainMap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The advantage of using `ChainMap` objects, rather than just a dictionary, is
    that we retain previously set values. Adding a child context overrides values
    for the same key, but it does not remove it from the data structure. This can
    be useful when we may need to keep a record of changes so that we can easily roll
    back to a previous setting.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can retrieve and change any value in any of the dictionaries by providing
    the `map()` method with an appropriate index. This index represents a dictionary
    in `ChainMap`. Also, we can retrieve the parent setting, that is, the default
    settings, by using the `parents()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Counter objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Counter` is a subclass of a dictionary where each dictionary key is a hashable
    object and the associated value is an integer count of that object. There are
    three ways to initialize a counter. We can pass it any sequence object, a dictionary
    of `key:value` pairs, or a tuple of the format `(object=value,...)`, as in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also create an empty counter object and populate it by passing its `update`
    method an iterable or a dictionary. Notice how the `update` method adds the counts
    rather than replacing them with new values. Once the counter is populated, we
    can access stored values in the same way we would do for dictionaries, as in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The most notable difference between counter objects and dictionaries is that
    counter objects return a zero count for missing items rather than raising a key
    error. We can create an iterator out of a `Counter` object by using its `elements()`
    method. This returns an iterator where counts below one are not included and the
    order is not guaranteed. In the following code, we perform some updates, create
    an iterator from `Counter` elements, and use `sorted()` to sort the keys alphabetically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Two other `Counter` methods worth mentioning are `most_common()` and `subtract()`.
    The most common method takes a positive integer argument that determines the number
    of most common elements to return. Elements are returned as a list of (key,value)
    tuples.
  prefs: []
  type: TYPE_NORMAL
- en: 'The subtract method works exactly like update except, instead of adding values,
    it subtracts them, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Ordered dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The important thing about ordered dictionaries is that they remember the insertion
    order, so when we iterate over them, they return values in the order they were
    inserted. This is in contrast to a normal dictionary, where the order is arbitrary.
    When we test to see whether two dictionaries are equal, this equality is only
    based on their keys and values; however, with `OrderedDict`, the insertion order
    is also considered an equality test between two `OrderedDict` objects with the
    same keys and values, but a different insertion order will return `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, when we add values from a list using `update`, `OrderedDict` will
    retain the same order as the list. This is the order that is returned when we
    iterate the values, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`OrderedDict` is often used in conjunction with the sorted method to create
    a sorted dictionary. In the following example, we use a Lambda function to sort
    the values, and here we use a numerical expression to sort the integer values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: defaultdict
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `defaultdict` object is a subclass of `dict`, and therefore they share
    methods and operations. It acts as a convenient way to initialize dictionaries.
    With `dict`, Python will throw `KeyError` when attempting to access a key that
    is not already in the dictionary. The `defaultdict` overrides one method, `missing
    (key)`, and creates a new instance variable, `default_factory`. With `defaultdict`,
    rather than throw an error, it will run the function supplied as the `default_factory`
    argument, which will generate a value. A simple use of `defaultdict` is to set
    `default_factory` to `int` and use it to quickly tally the counts of items in
    the dictionary, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that if we tried to do this with an ordinary dictionary, we
    would get a key error when we tried to add the first key. The `int` we supplied
    as an argument to the `defaultdict` is really the `int()` function that simply
    returns a zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can, of course, create a function that will determine the dictionary''s
    values. For example, the following function returns `True` if the supplied argument
    is a primary color, that is `red`, `green`, or `blue`, or returns `False` otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Learning about named tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `namedtuple` method returns a tuple-like object that has fields accessible
    with named indexes as well as the integer indexes of normal tuples. This allows
    for code that is, to a certain extent, self-documenting and more readable. It
    can be especially useful in an application where there are a large number of tuples
    and we need to easily keep track of what each tuple represents. Furthermore, `namedtuple`
    inherits methods from tuple and it is backward-compatible with tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'The field names are passed to the `namedtuple` method as comma and/or whitespace-separated
    values. They can also be passed as a sequence of strings. Field names are single
    strings, and they can be any legal Python identifier that does not begin with
    a digit or an underscore. A typical example is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to the inherited tuple methods, the named tuple also defines three
    methods of its own, `_make()`, `asdict()`, and `_replace`. These methods begin
    with an underscore to prevent potential conflicts with field names. The `_make()`
    method takes an iterable as an argument and turns it into a named tuple object,
    as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `_asdict` method returns an `OrderedDict` object with the field names mapped
    to index keys and the values mapped to the dictionary values. The `_replace` method
    returns a new instance of the tuple, replacing the specified values. In addition,
    `_fields` returns the tuple of string listing the fields names. The `_fields_defaults`
    method provides dictionary mapping field names to the default values. Consider
    the example code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `array` module defines a data type array that is similar to the list data
    type except for the constraint that their contents must be of a single type of
    the underlying representation, as is determined by the machine architecture or
    underlying C implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The type of an array is determined at creation time and it is indicated by
    one of the following type codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Code** | **C type** | **Python type** | **Minimum bytes** |'
  prefs: []
  type: TYPE_TB
- en: '| ''b'' | `signedchar` | int | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| ''B'' | `unsignedchar` | int | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| ''u'' | `Py_UNICODE` | Unicodecharacter | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| ''h'' | `signedshort` | int | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| ''H'' | `unsignedshort` | int | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| ''i'' | `signedint` | int | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| ''I'' | `unsignedint` | int | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| ''l'' | `signedlong` | int | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| ''L'' | `unsignedlong` | int | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| ''q'' | `signedlonglong` | int | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| ''Q'' | `unsignedlonlong` | int | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| ''f'' | `float` | float | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| ''d'' | `double` | float | 8 |'
  prefs: []
  type: TYPE_TB
- en: 'The array objects support the attributes and methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Attribute or method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `a.itemsize` | The size of one array item in bytes. |'
  prefs: []
  type: TYPE_TB
- en: '| `a.append(x)` | Appends an `x` element at the end of the `a` array. |'
  prefs: []
  type: TYPE_TB
- en: '| `a.buffer_info()` | Returns a tuple containing the current memory location
    and length of the buffer used to store the array. |'
  prefs: []
  type: TYPE_TB
- en: '| `a.byteswap()` | Swaps the byte order of each item in the `a` array. |'
  prefs: []
  type: TYPE_TB
- en: '| `a.count(x)` | Returns the occurrences of `x` in the `a` array. |'
  prefs: []
  type: TYPE_TB
- en: '| `a.extend(b)` | Appends all the elements from iterable `b` at the end of
    the `a` array. |'
  prefs: []
  type: TYPE_TB
- en: '| `a.frombytes(s)` | Appends elements from an `s` string, where the string
    is an array of machine values. |'
  prefs: []
  type: TYPE_TB
- en: '| `a.fromfile(f,n)` | Reads `n` machine values from the file and appends them
    at the end of the array. |'
  prefs: []
  type: TYPE_TB
- en: '| `a.fromlist(l)` | Appends all of the elements from the `l` list to the array.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `a.fromunicode(s)` | Extends an array of the `u` type with the Unicode string, `s`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `index(x)` | Returns the first (smallest) index of the `x` element. |'
  prefs: []
  type: TYPE_TB
- en: '| `a.insert(i,x)` | Inserts an item of which the value is `x`, in the array
    at `i` index position. |'
  prefs: []
  type: TYPE_TB
- en: '| `a.pop([i])` | Returns the item at index, `I`, and removes it from the array.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `a.remove(x)` | Removes the first occurrence of the `x` item from the array.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `a.reverse()` | Reverses the order of items in the `a` array. |'
  prefs: []
  type: TYPE_TB
- en: '| `a.tofile(f)` | Writes all the elements to the `f` file object. |'
  prefs: []
  type: TYPE_TB
- en: '| `a.tolist()` | Converts the array into a list. |'
  prefs: []
  type: TYPE_TB
- en: '| `a.tounicode()` | Converts an array of the `u` type into a Unicode string
    |'
  prefs: []
  type: TYPE_TB
- en: Array objects support all of the normal sequence operations such as indexing,
    slicing, concatenation, and multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using arrays, as opposed to lists, is a much more efficient way of storing
    data that is of the same type. In the following example, we have created an integer
    array of the digits from `0` to one million minus `1`, and an identical list.
    Storing one million integers in an integer array requires around 90% of the memory
    of an equivalent list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Because we are interested in saving space, that is, we are dealing with large
    datasets and limited memory size, we usually perform in-place operations on arrays,
    and only create copies when we need to. Typically, enumerate is used to perform
    an operation on each element. In the following snippet, we perform the simple
    operation of adding one to each item in the array.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that when performing operations on arrays that create lists,
    such as list comprehensions, the memory efficiency gains of using an array in
    the first place will be negated. When we need to create a new data object, a solution
    is to use a generator expression to perform the operation.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays created with this module are unsuitable for work that requires a matrix
    of vector operations. In the next chapter, we will build our own abstract data
    type to deal with these operations. Also important for numerical work is the NumPy
    extension, available at [www.numpy.org](http://www.numpy.org/) .
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last two chapters, we presented the language features and data types
    of Python. We looked at the built-in data types and some internal Python modules,
    most notably the `collections` module. There are also several other Python modules
    that are relevant to the topic of this book, but rather than examining them separately,
    their use and functionality should become self-evident as we begin using them.
    There are also a number of external libraries, for example, SciPy.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce the basic theory and techniques of algorithm
    design.
  prefs: []
  type: TYPE_NORMAL
