- en: Chapter 7. Bottlenecks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we've seen in the previous chapters, a lot of elements influence performance.
    Even the process of development will influence how you monitor performance degradation.
    The patterns you use might not make a difference on a small scale, but after deployment,
    you'll regret every bad decision you made.
  prefs: []
  type: TYPE_NORMAL
- en: The host is also an important performance factor. How well your processor performs
    for your specific tasks is important. How much memory you have available influences
    how much of your data will reside in a fast location or will move to a slower
    location, such as a local disk.
  prefs: []
  type: TYPE_NORMAL
- en: Caching your data is also of great importance. The technique of accelerating
    data access using some kind of middle storage to give a perception of greater
    speed creates an important illusion of a fast application. Although this might
    seem wrong since it looks like an illusion, it's actually very important if you
    want to stretch performance to the limit.
  prefs: []
  type: TYPE_NORMAL
- en: All of this is important, but there are limits that you cannot pass, or at least
    some that you should know in order to go around and choose a better design pattern.
    Some of these limits are outside your scope and you cannot tweak or control them.
    Others could be minimized if you have the budget and/or time and want to take
    that path. I recommend that you take it, as knowing the surroundings of your application
    will give you a bigger picture of the understanding of how it all works and how
    it could be improved.
  prefs: []
  type: TYPE_NORMAL
- en: Host limits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The place where you host your application—the server—has limits. There are
    two types of limits on the host: hardware and software. Hardware limits can be
    easy to spot. Your application might be consuming all of the memory and needing
    to consume disk to continue working. Adding more memory by upgrading your host,
    whether physical or virtual, seems to be the right choice.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For Node.js applications you also have a software memory limit imposed by V8,
    so don''t forget about this when upgrading your memory banks. As a 32-bit environment
    has a limit of more or less 3.5 GB, I''m assuming that you''re upgrading memory
    in a 64-bit environment. In this case, your application would be running by default
    at a 1 GB V8 limit. You then need to run your application with a higher limit
    by starting it in a way similar to the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This would run `application.js` with a 4 GB memory limit. This is actually not
    recommended. You have probably chosen a design pattern that is not suitable for
    the task, and you should try to split your application into smaller services.
  prefs: []
  type: TYPE_NORMAL
- en: When you don't control your production environment other restrictions might
    apply, such as the inability to install a software dependency or upgrade a library
    to fix a security or performance issue. If you don't control the environment from
    top to bottom, you're not stretching its limits.
  prefs: []
  type: TYPE_NORMAL
- en: Operating systems and database servers usually come with predefined values for
    moderated usage. This is usually fine for the average user, but definitely not
    enough for the power user.
  prefs: []
  type: TYPE_NORMAL
- en: A simple example is the maximum number of open file descriptors for each process.
    A socket is a file descriptor, and if you use the default 1024 limit it means
    that at most you'll probably have 1,000 open clients connected. I'm being generous;
    I'm talking about a Linux machine. If you look at OS X, you will have a worse
    scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to this limit, and looking at Linux in particular, you can check out
    the other limits that definitely influence your application. Look at the manual
    and see what options you might want to tweak. The following is an example of the
    limits and defaults you may find in a Linux system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There are other methods and options that you can change and optimize for your
    application. I'm talking about kernel parameters. You can look at them and change
    them using the `sysctl` command.
  prefs: []
  type: TYPE_NORMAL
- en: You can tweak areas such as the filesystem, network timings and routing, the
    virtual memory behavior, and the kernel itself, like processor scheduling and
    reaction to hanging tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a small list showing just a fraction of the options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned before, it's not just the operating system that can be badly optimized
    for your use case. Services usually come with a simple default configuration that
    is not targeted at performance.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL database servers can have some weird configuration parameters, such as
    `innodb_flush_log_at_trx_commit`, which defaults to `1`. This means that every
    transaction triggers a flush to disk (to save the transaction). If you have 100
    transactions per second, it means your disk will heat and degrade performance
    by issuing 100 flushes per second.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, you would want to ensure that this configuration is `2`, which means
    that disk flush is done at most once per second. This configuration does not ensure
    ACID ([https://en.wikipedia.org/wiki/ACID](https://en.wikipedia.org/wiki/ACID))
    compliance, but I think you'll thank me later. Performance comes at a cost, and
    in this case, an uninterruptible power supply is required.
  prefs: []
  type: TYPE_NORMAL
- en: Another configuration you must watch out for is the memory used by the operative
    system and all the services involved in your application. For instance, taking
    the MySQL server, you must ensure that it doesn't consume all of the memory and
    leaves some for your other services. This avoids swaps and ensures that it runs
    smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: Network limits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The network is nowadays the de facto transport method for accessing applications.
    As the Internet of Things becomes more of a reality, even common desktop applications,
    such as office productivity tools, are moving to the cloud. You probably didn't
    ever develop a traditional desktop application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cloud applications give you many advantages over traditional ones, such as
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Easier deployments. Since the application is located in one or more central
    points, it's simpler to fix a bug or add a feature to all of your user base.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: License enforcements. As the application is not installed in the user's computer
    and you control the host, you can block its usage or control the quality of service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proper environment. Because you control the host, you ensure that it has a proper
    processor and enough memory and disk space to operate as it should.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of these are very good pros, but what about the cons? Well, for every advantage,
    there''s usually a disadvantage. It''s not good or bad; it just depends on what
    you prefer. Taking the previous list, we can enumerate the counterparts:'
  prefs: []
  type: TYPE_NORMAL
- en: Deployments must be made with care, as a server contains sensitive data and
    it is the only way to use your application. Do you accept Gmail being offline
    for 15 minutes? To guarantee a proper deployment, you need proper infrastructure
    with data duplicated to ensure that you can remove servers from the network pool,
    update them, and redeploy them again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enforcing a license means that you keep a service online and no downtime is
    accepted. Similarly, you may need to ensure a billing system while the user is
    using the application. This is the opposite of a common desktop application, where
    you pay once and then forget about it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adapting application to multiple environments. Supporting all major browser
    vendors is not easy. With this comes the user's assumption that your application
    must have a mobile-friendly alternative, which usually doesn't exist in a desktop
    version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a lot of market offers (free and paid) to "convert" your web application
    into a desktop application if you prefer the advantages of not moving your application
    to the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Applications now prefer to reside in the cloud. Their advantages usually surpass
    those of desktop applications, and there's something important mentioned in the
    advantages—licensing. The cloud gives you the "as a service" opportunity, which
    you usually don't have in a traditional application.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the cloud come a lot of hard work and troubles. You need to register your
    own domain, pay for a dedicated or shared host, and deploy your application. If
    you''re developing a big application and want to live up to your promises, you
    need more than that: hardware, a network link with a good quality of service,
    a support team, a backup plan, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'No matter what you choose, there are limits you should be aware of. You probably
    know them but this is never reflected. You have limits such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: Responsiveness. When the user interacts using the application interface, it
    might feel slow, as the interface is being downloaded from the cloud as the user
    is using the interface. This responsiveness can be improved if you cache the interface
    in the user's computer. Caching means that sometimes the user might be looking
    at an old interface, but that might not be as critical as getting a fast user
    experience. There are standards for doing this. Take a look at the Offline Web
    Applications section of the HTML standard as an example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data access, when a user interacts with a more data-intensive interface. Sometimes,
    part of the slowness of the interface is related to your server collecting data
    from the database and sending it through the network. You can also use a cache,
    but you may have to be more careful because interface caching is one thing and
    data caching is another. People can tolerate one or two hours with an old interface,
    but not with old data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Security is critical. Offer HTTPS access to your users so that they can feel
    comfortable about their privacy.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from these limits, there are security issues that reduce performance.
    For example, in terms of privacy you have to choose HTTPS, which means a good
    certificate and good server configuration to avoid poor ciphers. This in turn
    means that some users might be unable to access the application, and data exchange
    between the server and the client will be a bit slower.
  prefs: []
  type: TYPE_NORMAL
- en: This is a requirement if you want to ensure that the data being transferred
    from the server to the end user is not compromised. However, this is actually
    not enough because the user must also have an up-to-date browser and a good configuration.
    There have been a lot of SSL weaknesses found recently, and they can be avoided
    by updating the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Networking was not designed to be secure; it was designed with the assumption
    that everyone has good intentions, which is definitely wrong. When your users
    access your application using a public hotspot (from a coffee shop, a mall, or
    an airport), they're vulnerable to privacy issues. Attackers can sniff the network
    traffic and try to find a password or attach themselves to an open session and
    be able to impersonate a user.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a secure connection is important, but it might reduce performance and
    also the number of users that each of your servers can handle. This can be the
    cost of security. Think that HTTPS is always slower? Try [http://www.httpvshttps.com/](http://www.httpvshttps.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Also, don't forget about your database. Ensure that you don't have any default
    password and you only allow access from your application (don't give access to
    everyone on the Internet).
  prefs: []
  type: TYPE_NORMAL
- en: Security does not end here. As your application is a known network location,
    you can be the victim of an attack. Perhaps you think that putting the server
    behind a firewall and just redirecting traffic to the ports that the users need
    (such as HTTP and HTTPS) is enough, but don't forget **Denial of Service** (**DoS**)
    attacks. An attacker with an attack network can bring your application down by
    just forcing it to be so busy with them that real users won't be able to access
    and use it. This gives them a perception of poor performance and is something
    you can't avoid.
  prefs: []
  type: TYPE_NORMAL
- en: For example, GitHub faced an attack from China in March 2015\. It lasted a few
    days. They couldn't avoid it and could only mitigate it by trying to deflect the
    traffic. Some people were greatly affected. As your application becomes bigger,
    more attackers may be interested in your information or just in denying access
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: Client limits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clients also have limits. They may be using an operating system that you don't
    know or can't be sure about. This also applies to the browser, the applications
    installed, and even the location.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Never trust the user agent sent by browsers. Also, don't ever infer any information
    from it. It can be forged to be anything. A laptop can mimic a Nokia phone from
    the last century very easily—no hacking is necessary!
  prefs: []
  type: TYPE_NORMAL
- en: 'This is something every developer must observe as a rule: never trust the client.
    I''m not saying this in a bad way, but you have to be sure of the information
    you have. For example, your interface has validations in forms and you''re sure
    that they validate correctly before submitting, right? Wrong! Never trust the
    client.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, never trust the link between the client and you. Validate information
    again on the server side. If possible, by using Node.js, use the same code to
    validate on both sides and avoid duplicated code. For example, you can use some
    code to validate a form in a web view and that code can also be used in the server.
    Don't forget! Node.js is JavaScript. If it's a complex piece of code or module,
    you may want to look at browserify ([http://browserify.org/](http://browserify.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: Form validations should be done on both sides to give a perception of performance
    and to actually avoid common errors. You shouldn't validate everything on the
    client, but at least check whether a currency field actually has a number and
    not text, and confirm that all the required fields have proper values. This reduces
    the round trips of submitting to the server and the server replying back with
    an error.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the limits of the application, there are limits outside that you
    can't control. The user will always blame you, and perhaps it's not your application's
    fault most of the time. Are you prepared for an intermittent connection for a
    client from a cellular network? I'm not referring to 3G, because this can be stable
    enough. I'm referring to GPRS connections.
  prefs: []
  type: TYPE_NORMAL
- en: Do you have a full-blown application for a cellphone that does not have a more
    than 300-pixel wide screen and behaves like my TI-83 from high school? Are you
    expecting that everyone will use the latest cellphone with a huge screen and more
    processor power than your netbook? It's here that the sense of performance is
    noticed.
  prefs: []
  type: TYPE_NORMAL
- en: A huge application can bring down a weaker cellphone just by rendering the interface.
    A cheap processor will have a hard time rendering all the elements and running
    all of the JavaScript in your application. It will be a challenge for it to render
    on a small screen. Therefore, it's better to have a completely different interface
    for this type of screen and simply use an adaptive interface for smaller differences.
  prefs: []
  type: TYPE_NORMAL
- en: The user accepts a different interface because they are actually interfacing
    with the application in a different way. They are probably using a finger on a
    cellphone and a mouse or a couple of fingers on a tablet or a laptop. Also, the
    distance between the eyes and the screen is different, hence the resolution difference.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this and to target the best performance possible, you should bring
    forth a simpler interface. Remove clutter-like information that the user will
    probably not need, for example, in a cellphone. Keep only the important actions.
    If possible, cache the interface for a better sense of performance. It's better
    to see a spinning wheel than a blank screen with no progress information.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, the Web gives you choices. You can use different types of devices
    with different systems and web browsers. This is good for the user but horrible
    for the developer. It's a fragmentation that forces applications to be developed
    with only a couple of targets in mind and not all of the market.
  prefs: []
  type: TYPE_NORMAL
- en: You need to focus on the main target of the application and develop the best
    interface for it. You can then move your focus to other environments, such as
    the smaller screens on cellphones and watches. Don't make an application that
    can run on all screens but isn't the best on any of them.
  prefs: []
  type: TYPE_NORMAL
- en: A few years ago, applications were copied to all screens, which was actually
    dumb. People use different devices with different goals in mind. For example,
    people won't want to create a task list on a cellphone, but will probably want
    to check it and mark it as complete. This means that you can have in place a much
    smaller application to do exactly what the user wants, avoiding excessive information
    and the risk of slowing down interaction and degrading experience.
  prefs: []
  type: TYPE_NORMAL
- en: Browser limits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Browser vendors are merging efforts to make the lives of developers easier.
    A few years ago, it was hell to develop a web application for several browsers.
    You would usually focus on one or two of them. If you focused on more, your code
    would get a lot more complicated and performance would be compromised. Usually,
    applications would become slower with time and with newer browser versions.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, it's safer to develop an application in only one browser. Most of
    the application, if not all—depending on what abstraction you used for the DOM
    (jQuery is the best example)—will run just fine on other browsers. You can then
    make a couple of improvements, and you will have an application running smoothly
    on every browser.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping these abstraction layers up to date is important to avoid deprecated
    and slower code. Browsers tend to release versions more often and bring newer
    developer interfaces that those abstractions take advantage of.
  prefs: []
  type: TYPE_NORMAL
- en: '![Browser limits](img/4183_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot is a `jsperf` testing some versions of jQuery. The
    versions are not actually the latest ones, but it doesn't matter. Take it with
    a grain of salt. As you can see, the newer versions perform better—not always,
    but this is usually true. You can see how, in this example, the performance of
    the oldest version is 77 percent worse than the newest one.
  prefs: []
  type: TYPE_NORMAL
- en: Performance variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Performance should be seen as a mixture of choices and variables that you should
    adjust depending on your needs. Here are some variables you should consider:'
  prefs: []
  type: TYPE_NORMAL
- en: Choose the best or second best platform. Remember that the best one could potentially
    not be the best for you.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define your data structure and choose your database server wisely. Think big
    and plan how you'll react to fast data growth.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plan your application's modules and don't forget about making tests to every
    module. Create a developing environment that can be replicated in order for it
    to be easier for new developers to start programming faster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose a target environment and start developing. Don't start developing for
    every device and browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your application's performance is not constrained by your code and database
    choices. There are limitations that you must be aware of in order to choose the
    best path for your application. These are just external elements of your application
    that influence its performance, but there are others as well.
  prefs: []
  type: TYPE_NORMAL
- en: The most important rule—you shouldn't forget it—is to plan your steps. Don't
    develop without thinking properly about this. A bad choice will make your life
    harder later on when you have to fix it. It's better to lose an hour thinking
    than a week fixing. That's actually part of your own development performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prepared for Bentham Chang, Safari ID bentham@gmail.com User number: 2843974
    © 2015 Safari Books Online, LLC. This download file is made available for personal
    use only and is subject to the Terms of Service. Any other use requires prior
    written consent from the copyright owner. Unauthorized use, reproduction and/or
    distribution are strictly prohibited and violate applicable laws. All rights reserved.'
  prefs: []
  type: TYPE_NORMAL
