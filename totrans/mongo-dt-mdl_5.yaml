- en: Chapter 5. Optimizing Queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have taken a great step forward in comprehending how to improve
    read and write performance using indexes, let's see how we can analyze them if
    these indexes are behaving as expected, and also how indexes can influence a database's
    lifecycle. In addition to this, through this analysis, we will be able to evaluate
    and optimize the created queries and indexes.
  prefs: []
  type: TYPE_NORMAL
- en: So, in this chapter, we will study the concept of query plans and how MongoDB
    handles it. This includes understanding query covering and query selectivity,
    and how these plans behave when used in sharded environments and through replica
    sets.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the query plan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we run a query, MongoDB will internally figure out the best way to do it
    by choosing from a set of possibilities extracted after query analysis (performed
    by the MongoDB query optimizer). These possibilities are called **query plans**.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a better understanding of a query plan, we must go back to the cursor
    concept and one of the cursor methods: `explain()`. The `explain()` method is
    one of the big changes in the MongoDB 3.0 release. It has been significantly enhanced
    due to the new query introspection system.'
  prefs: []
  type: TYPE_NORMAL
- en: Not only has the output changed, as we saw earlier, but also the way we use
    it. We now can pass to the `explain()` method an option parameter that specifies
    the verbosity of the `explain` output. The possible modes are `"queryPlanner"`,
    `"executionStats"`, and `"allPlansExecution"`. The default mode is `"queryPlanner"`.
  prefs: []
  type: TYPE_NORMAL
- en: In the `"queryPlanner"` mode, MongoDB runs the query optimizer to choose the
    winning plan under evaluation, and returns the information to the evaluated method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `"executionStats"` mode, MongoDB runs the query optimizer to choose the
    winning plan, executes it, and returns the information to the evaluated method.
    If we are executing the `explain()` method for a write operation, it returns the
    information about the operation that would be performed but does not actually
    execute it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, in the `"allPlansExecution"` mode, MongoDB runs the query optimizer
    to choose the winning plan, executes it, and returns the information to the evaluated
    method as well as information for the other candidate plans.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find more about the `explain()` method in the MongoDB 3.0 reference
    guide at [http://docs.mongodb.org/manual/reference/method/db.collection.explain/#db.collection.explain](http://docs.mongodb.org/manual/reference/method/db.collection.explain/#db.collection.explain).
  prefs: []
  type: TYPE_NORMAL
- en: The output of an `explain` execution shows us the query plans as a tree of stages.
    From the leaf to the root, each stage passes its results to the parent node. The
    first stage, which happens on the leaf node, accesses the collection or indices
    and passes the results to internal nodes. These internal nodes manipulate the
    results from which the final stage or the root node derives the result set.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four stages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`COLLSCAN`: This means that a full collection scan happened during this stage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IXSCAN`: This indicates that an index key scan happened during this stage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FETCH`: This is the stage when we are retrieving documents'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SHARD_MERGE`: This is the stage where results that came from each shard are
    merged and passed to the parent stage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detailed information about the winning plan stages can be found in the `explain.queryPlanner.winningPlan`
    key of the `explain()` execution output. The `explain.queryPlanner.winningPlan.stage`
    key shows us the name of the root stage. If there are one or more child stages,
    the stage will have an `inputStage` or `inputStages` key depending on how many
    stages we have. The child stages will be represented by the keys `explain.queryPlanner.winningPlan.inputStage`
    and `explain.queryPlanner.winningPlan.inputStages` of the `explain()` execution
    output.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn more about the `explain()` method, visit the MongoDB 3.0 manual page
    at [http://docs.mongodb.org/manual/reference/explain-results/](http://docs.mongodb.org/manual/reference/explain-results/).
  prefs: []
  type: TYPE_NORMAL
- en: All these changes in the execution and the output of the `explain()` method
    were made mainly to improve the DBAs' productivity. One of the biggest advantages
    compared to the previous MongoDB versions is that `explain()` does not need to
    execute the query to calculate the query plan. It also exposes query introspection
    to a wider range of operations including find, count, update, remove, group, and
    aggregate, giving DBAs the power to optimize queries of each type.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Getting straight to the point, the `explain` method will give us statistics
    from the query execution. For instance, we will see in these statistics whether
    a cursor is used or an index.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the following `products` collection as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have already seen, when the collection is created, an index in the `_id`
    field is added automatically. To get all the documents in the collection, we will
    execute the following query in the mongod shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the query will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To help you understand how MongoDB reaches this result, let''s use the `explain`
    method on the cursor that was returned by the command `find`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this operation is a document with information about the selected
    query plan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Initially, let''s check only four fields in this document: `queryPlanner.winningPlan.stage`,
    `queryPlanner.executionStats.nReturned`, `queryPlanner.executionStats.totalKeysExamined`,
    and `queryPlanner.executionStats.totalDocsExamined`:'
  prefs: []
  type: TYPE_NORMAL
- en: The `queryPlanner.winningPlan.stage` field is showing us that a full collection
    scan will be performed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `queryPlanner.executionStats.nReturned` field shows how many documents match
    the query criteria. In other words, it shows us how many documents will be returned
    from the query execution. In this case, the result will be three documents.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `queryPlanner.executionStats.totalDocsExamined` field is the number of documents
    from the collection that will be scanned. In the example, all the documents were
    scanned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `queryPlanner.executionStats.totalKeysExamined` field shows the number of
    index entries that were scanned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When executing a collection scan, as in the preceding example, `nscanned` also
    represents the number of documents scanned in the collection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What happens if we create an index of the `price` field of our collection?
    Let''s see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, the query result will be the same three documents that were returned
    in the previous execution. However, the result for the `explain` command will
    be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The returned document is fairly different from the previous one. Once again,
    let''s focus on these four fields: `queryPlanner.winningPlan.stage`, `queryPlanner.executionStats.nReturned`,
    `queryPlanner.executionStats.totalKeysExamined`, and `queryPlanner.executionStats.totalDocsExamined`.'
  prefs: []
  type: TYPE_NORMAL
- en: This time, we can see that we did not have a full collection scan. Instead of
    this, we had a `FETCH` stage with a child `IXSCAN` stage, as we can see in the
    `queryPlanner.winningPlan.inputStage.stage` field. This means that the query used
    an index. The name of the index can be found in the field `queryPlanner.winningPlan.inputStage.indexName`,
    in the example, `price_1`.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the mean difference in this result is that both `queryPlanner.executionStats.totalDocsExamined`
    and `queryPlanner.executionStats.totalKeysExamined`, returned the value `3`, showing
    us that three documents were scanned. It is quite different from the 10 documents
    that we saw when executing the query without an index.
  prefs: []
  type: TYPE_NORMAL
- en: One point we should make is that the number of documents and keys scanned is
    the same as we can see in `queryPlanner.executionStats.totalDocsExamined` and
    `queryPlanner.executionStats.totalKeysExamined`. This means that our query was
    not covered by the index. In the next section, we will see how to cover a query
    using an index and what its benefits are.
  prefs: []
  type: TYPE_NORMAL
- en: Covering a query
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes we can choose to create indexes with one or more fields, considering
    the frequency that they appear in our queries. We can also choose to create indexes
    in order to improve query performance, using them not only to match the criteria
    but also to extract results from the index itself.
  prefs: []
  type: TYPE_NORMAL
- en: We may say that, when we have a query, all the fields in the criteria are part
    of an index and when all the fields in the query are part of the same index, this
    query is covered by the index.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example shown in the previous section, we had an index created of the
    `price` field of the `products` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When we execute the following query, which retrieves the documents where the
    `price` field has a value greater than `65` but with a projection where we excluded
    the `_id` field from the result and included only the `price` field, we will have
    a different result from the one previously shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we analyze the query using the `explain` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'By doing this, we also have a different result from the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we notice is that the value of `queryPlanner.executionStats.totalDocsExamined`
    is `0`. This can be explained because our query is covered by the index. This
    means that we do not need to scan the documents from the collection. We will use
    the index to return the results, as we can observe in the value `3` for the `queryPlanner.executionStats.totalKeysExamined`
    field.
  prefs: []
  type: TYPE_NORMAL
- en: Another difference is that the `IXSCAN` stage is not a child of the `FETCH`
    stage. Every time that an index covers a query, `IXSCAN` will not be a descendent
    of the `FETCH` stage.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Queries that are covered by the index can be extremely fast. This happens because
    the index keys are usually much smaller than the document itself and also because
    the index is in volatile memory or in disk sequential write mode.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, it's not always the case that we will have a query covered, even
    though we had the same conditions that were described previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering the following `customers` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And an index created of the `followedSellers` field, executing the following
    command on mongod shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute the following query on mongod shell, which was supposed to be
    covered by the index, since we are using `followedSellers` on the query criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When we analyze this query using the `explain` command on the mongod shell,
    to see if the query is covered by the index, we can observe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We have the following document as a result. We can see that, despite using
    a field that is in the index in the criteria and restricting the result to this
    field, the returned output has the `FETCH` stage as a parent of the `IXSCAN` stage.
    In addition, the values for `totalDocsExamined` and `totalKeysExamined` are different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `totalDocsExamined` field returned `2`, which means that it was necessary
    to scan two of the five documents from the collection. Meanwhile, the `totalKeysExamined`
    field returned `4`, showing that it was necessary to scan four index entries for
    the returned result.
  prefs: []
  type: TYPE_NORMAL
- en: Another situation in which we do not have the query covered by an index is when
    the query execution is used in an index of a field that is part of an embedded
    document.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the example using the `products` collection that was already used
    in [Chapter 4](ch04.html "Chapter 4. Indexing"), *Indexing*, with an index of
    the `supplier.name` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following query will not be covered by the index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that, though this query is not covered by the index, it will use the
    index in its plan.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, when we are executing a query in a sharded collection, through **mongos**,
    this query will never be covered by an index.
  prefs: []
  type: TYPE_NORMAL
- en: The query optimizer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you understand both evaluating query performance using the `explain()`
    method and how to take advantage of an index by covering a query, we will proceed
    to meet the huge responsibility of selecting and maintaining the query plan in
    MongoDB, the query optimizer.
  prefs: []
  type: TYPE_NORMAL
- en: The query optimizer is responsible for processing and selecting the best and
    most efficient query plan for a query. For this purpose, it takes into account
    all the collection indexes.
  prefs: []
  type: TYPE_NORMAL
- en: The process performed by the query optimizer is not an exact science, meaning
    that it is a little bit empirical—in other words, based on trial and error.
  prefs: []
  type: TYPE_NORMAL
- en: When we execute a query for the very first time, the query optimizer will run
    the query against all available indexes of the collection and choose the most
    efficient one. Thereafter, every time we run the same query or queries with the
    same pattern, the selected index will be used for the query plan.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the same `products` collection we used previously in this chapter, the
    following queries will run through the same query plan because they have the same
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As the collection's data changes, the query optimizer re-evaluates it. Moreover,
    as the collection grows (more precisely for each 1,000 write operations, during
    each index creation, when the `mongod` process restarts, or when we call the `explain()`
    method), the optimizer re-evaluates itself.
  prefs: []
  type: TYPE_NORMAL
- en: Even with this marvelous automatic process known as the query optimizer, we
    may want to choose which index we want to use. For this, we use the `hint` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we have these indexes in our previous `products` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to retrieve all the products where the `price` field has a value
    greater than 10, sorted by the `name` field in descending order, use the following
    command to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The index chosen by the query optimizer will be the one created on the `name`
    and `price` fields, as we could see running the `explain()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we can force the use of the index only of the `price` field, in this
    manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To be certain, we use the `explain` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Reading from many MongoDB instances
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have spoken a lot about reading from one MongoDB instance. Nevertheless,
    it is important that we speak briefly about reading from a sharded environment
    or from a replica set.
  prefs: []
  type: TYPE_NORMAL
- en: '![Reading from many MongoDB instances](img/B04075_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When we are reading from a shard, it is important to have the shard key as part
    of the query criteria. This is because, when we have the shard key, we will target
    the execution on one specific shard, whereas if we do not have the shard key,
    we will force the execution on all the shards in the cluster. Thus, the performance
    of a query in a sharded environment is linked to the shard key to a great extent.
  prefs: []
  type: TYPE_NORMAL
- en: By default, when we have a replica set in MongoDB, we will always read from
    the primary. We can modify this behavior to force a read operation execution on
    to a secondary node by modifying the read preferences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we have a replica set with three nodes: `rs1s1`, `rs1s2`, and
    `rs1s3` and that `rs1s1` is the primary node, and `rs1s2` and `rs1s3` are the
    secondary nodes. To execute a read operation forcing the read on a secondary node,
    we could do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, we have the following read preference options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`primary`, which is the default option and will force the user to read from
    the primary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`primaryPreferred`, which will read preferably from the primary but, in the
    case of unavailability, will read from a secondary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`secondaryPreferred`, which will read from a secondary but, in the case of
    unavailability, will read from the primary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nearest`, which will read from the lowest network latency node in the cluster.
    In other words, with the shortest network distance, regardless of whether it is
    the primary or a secondary node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In short, if our application wants to maximize consistency, then we should prioritize
    the read on the primary; when we are looking for availability, we should use `primaryPreferred`
    because we can guarantee consistency on most of the reads. When something goes
    wrong in the primary node, we can count on any secondary node. Finally, if we
    are looking for the lowest latency, we may use `nearest`, reminding ourselves
    that we do not have a guarantee of data consistency because we are prioritizing
    the lowest latency network node.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned to analyze query performance using MongoDB's native
    tools and to optimize our queries with this.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about how to manage our database and its collections
    better by doing a functional or geographic segregation. You will also see how
    to maintain collections that should support a high read and write throughput.
  prefs: []
  type: TYPE_NORMAL
