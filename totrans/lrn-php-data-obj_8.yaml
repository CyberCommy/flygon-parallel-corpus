- en: Appendix A. Introduction to OOP in PHP5
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book, we were mainly using procedural code to build the example
    application. However, the PDO API is fully object-oriented, and in the last chapter
    we imitated real-life entities in the database by using classes. This appendix
    is for those programmers who are not familiar with PHP5's object-oriented extensions.
    We will introduce you to the basics of OOP, as many developers coming from earlier
    versions of PHP have no experience of this type of programming. However, this
    is only a short introduction; if you want to master OOP, you should refer to some
    of the books devoted to this topic.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: What is Object-Oriented Programming?
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Object-oriented programming (OOP) is a relatively new concept, although its
    roots date back to 1960s. In OOP, the software works with objects that model real-life
    entities (such as books and authors in the [Chapter 7)](ch07.html "Chapter 7. An
    Advanced Example"). Whereas procedural programming involves a series of instructions,
    an application in OOP involves a set of objects that interact with each other.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: The Syntax for Declaring Objects
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An object can be viewed as a container for several variables, called properties,
    and for functions that act on these variables. These functions are called methods.
    Every object belongs to a class. In PHP, every object can belong to only one class
    (although some other OOP languages allow multiple inheritance), but there can
    be many objects, or instances, belonging to a single class. A class is a syntactic
    construct that allows you to describe what properties and methods the objects
    belonging to this class will have.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: There is an analogy with species and living organisms—for example, a Dog (a
    species, or a class) is a generalization of all living dogs. A generalized dog
    has such properties as weight and age, and a method such as bark, and a real-life
    dog, say Lessie, which belongs to the dog species, could be described as an instance
    of the `Dog` class.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we would model this in PHP5:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this small snippet of code, we defined a class called `Dog`. In PHP5, a class
    definition starts with the reserved word `class` followed by the class's name
    (A class's name can contain the same characters as a function's name.) All the
    class's properties and methods, collectively called **members**, are defined inside
    the `{…}` block.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we are using the keyword, `public`, when we declare properties
    and methods. In PHP4 we would have used the `var` keyword instead, but this keyword
    is deprecated in PHP5\. Besides the `public` keyword, we could have used the `protected`
    keyword or the `private` keyword, but more on this later.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the second part of the code, we create the object with the
    `new` keyword:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This line creates a new object belonging to the `Dog` class and assigns it
    to the `$lessie` variable. This is a very important step, since this is the only
    way to create objects. After the PHP processes it, the `$lessie` variable becomes
    initialized and we can access the properties and methods declared in the `Dog`
    class so that we act on the object called `Lessie`. We would now like to have
    two dogs in our application, and the second one will be called `K9`. To achieve
    that, we would have to write something like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, we can access both the `$k9` and `$lessie` variables, if we would like
    to interface with each of our dogs.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: In other words, before we can communicate with an instance, it first has to
    be created with the `new` keyword.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: After the variable has been initialized, we can access its properties and methods.
    As you can see in the code, this is achieved with the `->` construct, which is
    used with both properties and methods. Note that when accessing a class’s properties,
    we don’t have to write the dollar sign after the -> (but we have to use it when
    declaring the properties inside the class definition).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'The methods are declared with the `function` keyword followed by the method’s
    name and a list of parameters. In fact, a class’s methods are declared in a similar
    way to that for an ordinary function, but there is one major difference. Inside
    the declaration of a method, there always exists implicit variable, called `$this`,
    which allows you to access the object’s properties. Let’s see how we could create
    a `getInfo()` method to return some additional information about our dogs:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This code would display the following output:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Constructors
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every class also has a special function (which may be implicit or explicitly
    declared) called a **constructor**. The constructor is always called when PHP
    encounters the `new` keyword, and its purpose is to perform some initialization
    tasks. Let''s extend the `Dog` class so that it has a `$name` property. We will
    also change the code so as to initialize the `name, weight`, and `age` properties
    inside the constructor rather than in the main application:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This application would display the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here's a brief summary of what we did. We first declared the `$name` property
    and then the constructor for our `Dog` class. The constructors are declared as
    function with the special name of `__construct` (the word `constructor` prepended
    with two underscores('_'). Our constructor accepts three parameters—`name`, `age`,
    and `weight`, whose values are assigned to the object's properties. The order
    in which we assign values to the properties does not matter. Note that we always
    have to use the `$this` variable to denote the properties of the object. By doing
    this, we can differentiate the local variables `$name, $age`, and `$weight` (passed
    as parameters) from the object's own properties, which have the same names, inside
    the constructor.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: We also changed the `getInfo()` method so that it returns the name of the dog
    as well. We can now instantiate objects by passing the name, the age, and the
    weight to the constructor. Since these properties get assigned in the constructor,
    we don't have to do this in the main part of the code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'It should be also noted that you can assign default values to properties in
    the class definition. This will ensure that every object of that class will have
    the default values automatically assigned. For example, we can do the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you run the application with this `Dog` class definition, then you will
    see the following output:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can now see, the default property value for `hasCollar` has propagated
    to every newly created instance (of course, it can be later changed for each object).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Destructors
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is an opposite concept to constructors, called destructors. As its name
    suggests, destructors are used to perform cleanup tasks (classic examples of such
    tasks are deleting temporary files, closing database connections, etc). In PHP5,
    destructor on an object is called, when there are no more references to that object
    (for example, by setting the variable that holds the reference to the object to
    **null** or when the application terminates), then the destructor will be called.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'Destructor is a method: `__destruct()`. If you add that method to the class,
    then it will be called when the object is freed. Let’s add the destructor to the
    **Dog** class:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, if you run the code again, it will give the following output:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that the order in which PHP5 calls the destructors is not defined. Also,
    in a destructor, the code may not access other objects unless they are referenced
    by the object being freed. In other words, the destructor should only cleanup
    those resources that were created by that object.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: The Advantages of OOP
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The power of OOP lies in its three main characteristics: inheritance, encapsulation,
    and polymorphism.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inheritance in OOP allows you to create new classes that inherit an existing
    class''s behaviour (methods) and attributes (properties). Let''s consider the
    following example. Assume that we have a class called `Fruit`. It is a generalized
    type of class for different fruits, and its common attributes are color and weight.
    In OOP, we can subclass `Fruit` to create new classes `Apple` and `Banana`. Both
    these classes (being subclasses of Fruit) will have the same properties: `weight`
    and `color`. (Note we are speaking about properties as such, not about their values).
    An apple can have a green color, while a `Banana` can have a yellow color. But
    any code that interacts with `Apple` or `Banana` class instances does not need
    to know what kind of fruit it is communicating with.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put this example into code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, in this small application we have one `Apple` object and one
    `Banana` object. We iterate over them in a loop, but access their properties regardless
    of their type, since both classes use the same property names. But these properties
    carry different values for each fruit.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Inheritance also allows to extend or completely override the behavior of the
    parent classes. Let''s assume that our `Fruit` class has one more characteristic—price
    per kg. It also has a new method—`getPrice()` that just multiplies the weight
    (which we have in grams) by the price:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we can use this method in the subclasses:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we will assume that the `Banana` class has another method for calculating
    price so that a discount is applied:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, we changed the method in the `Banana` class so that the code
    calling the `Banana` class's implementation of the `getPrice()` method will get
    discounted price, while the `Apple` class's `getPrice()` method returns full price.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, we could reuse the `Fruit` class''s implementation of the
    `getPrice()` method in the `Banana` class (so that we don''t have to duplicate
    the code contained in the base class):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Encapsulation
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Encapsulation (sometimes called information hiding) is a more theoretical concept.
    It involves defining methods in a class in such a way that we hide the implementation
    details from the client code. We have already seen this when we redefined the
    price calculation in the `Banana` class. From the application''s point of view,
    nothing changed: we still call the `getPrice()` method, but we don''t know how
    this calculation is performed.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: In other words, classes are accessible through their methods, which have the
    same names so that, even if the code behind these names changes, the names themselves
    do not change. This ensures that existing code does not need to be changed to
    work with new versions of methods.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do more to hide implementation details from client code, PHP5, like
    other object-oriented languages, supports **visibility modifiers** for methods
    and properties. For example, we could add a private property, which will be hidden
    from the rest of the application, to the `Banana` class:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `$mySecretProperty` property is only accessible (or visible) in the `Banana`
    class; an attempt to access it from outside the `Banana` class's methods would
    trigger a run-time error. (In a compiled language, this would lead to a compilation
    error.)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'In PHP5, there exist two more modifiers: **public** (which we have already
    used), and **protected**. Public method or property is accessible from all the
    application, while protected is accessible inside the class and its subclasses
    only.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Polymorphism** is a feature of OOP that allows us to write code that will
    work with objects belonging to different classes provided that these classes have
    the same base class. We have already seen polymorphism in action in the above
    example when we were accessing properties and methods of different objects using
    their names but returning different values and taking different actions.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: The subclasses implement all the properties and methods belonging to the base
    class, and all future subclasses of the base class are guaranteed to implement
    these properties and methods so that the existing code can work even with subclasses
    which do not yet exist.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: PHP5 supports interfaces. An interface is a construct that describes certain
    behaviour in different classes and class hierarchies. For example, let’s consider
    a `Tradeable` interface that has a single method, `isImported():`
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we can declare in the definition of the `Fruit` class that it implements
    the Tradeable interface:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We have made `Fruit` objects and all objects belonging to its subclasses `(Apple`
    and `Banans)` non-imported by default. Now we can make bananas imported while
    leaving apples domestic:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next we will create an imaginary `Car` class that implements the `Tradeable`
    interface:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Note that `Car` does not extend `Fruit`, but it still has the `isImported()`
    method. Now we can call this method from the application:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This small example shows how objects from different class hierarchies can be
    treated in the same way by giving them a common interface. By doing this, objects
    that normally have quite different meanings can be manipulated in the same way,
    and this makes them polymorphic.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Static Properties, Methods, and Class Constants
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In all the examples in this appendix, we are using instances (objects) of classes,
    which modeled real-life entities. However, in PHP5 it is possible to use **static**
    properties and methods. Static properties are variables that are common to all
    the instances of the given class so that, if a static property is changed, it
    will get changed for all objects belonging to the class.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'A static property is declared just like a regular one, but with a special **static**
    keyword:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The static properties can be accessed without even creating an instance of
    the class:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The syntax for accessing a static property is as follows: the class name, then
    double semicolon, and then the property''s name. Note that with static properties
    (unlike with regular properties), the dollar sign, `$`, sign must be present.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'Static methods, just like static properties, can be accessed without instantiating
    an object. They are declared and accessed in the following way:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The declaration of a static method has the `static` keyword followed by a regular
    method declaration. The method is accessed by the class name followed by a double
    semicolon and then the method name.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: The static properties and methods can be accessed inside the class declaration
    using the shortcut keyword `self:`
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There is also a major difference with the definition of static methods. You
    cannot use the `$this` variable (as there is no object to which the `$this` variable
    can refer).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Another ''static'' feature of classes is class constants. A class constant
    acts like a static property, but its value cannot be changed. Class constants
    always must have their values assigned in the class declaration section, and they
    don''t have the dollar sign before them (so they are named just like regular PHP
    constants). Class constants are mostly used for keeping the global namespace cleaner
    (which is also one of the uses for static methods):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: An attempt to assign a value to a class constant in the code will lead to a
    parse error.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen, exceptions are a very important addition to PHP5\. Exceptions
    are special kind of object that, when instantiated and `thrown`, break the normal
    execution flow and jump to a so called `catch` block.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'Exceptions are used to report error conditions. Traditionally, functions return
    error codes if they fail. The application has to check every function call before
    proceeding to the next function call. Remember the piece of code that you use
    to connect to a MySQL database:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If the `mysql_xxx` functions could throw exceptions, this code could be simplified
    to this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Of course, this code would not work, as these functions are not designed to
    throw exceptions. You will have to use PDO, and in [Chapter 3](ch03.html "Chapter 3. Error
    Handling") we saw how to work with PDO exceptions.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这段代码不会起作用，因为这些函数并不是设计来抛出异常的。您将需要使用PDO，在[第3章](ch03.html "第3章。错误处理")中我们看到了如何处理PDO异常。
- en: 'Exceptions allow you to postpone error checking and maintain cleaner code.
    A function (or method) that causes an exception to be thrown is terminated, and
    the code in the block specified by the `catch` keyword is executed. Any code that
    might throw an exception is wrapped into the `try` block:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 异常允许您延迟错误检查并保持更清晰的代码。导致异常抛出的函数（或方法）将被终止，并且`catch`关键字指定的块中的代码将被执行。任何可能抛出异常的代码都被包装在`try`块中：
- en: '[PRE29]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The real power of exceptions is the ability to escalate them up the call stack.
    This means that, if you design a function or class method that can throw an exception,
    that function or method does not have to catch that exception. In fact, many application
    libraries are designed in such a way so that they don't process exceptions themselves,
    but instead let them pass to the calling code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 异常的真正威力在于能够将它们升级到调用堆栈。这意味着，如果您设计了一个可能抛出异常的函数或类方法，那么该函数或方法不必捕获该异常。事实上，许多应用程序库都是设计成不处理异常，而是让它们传递给调用代码。
- en: For example, many of the methods of the `PDO` and `PDOStatement` classes that
    we have encountered in this book can throw exceptions, and it is your responsibility
    to catch them and act appropriately.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，本书中遇到的`PDO`和`PDOStatement`类的许多方法都可能抛出异常，您有责任捕获并适当处理它们。
- en: 'Take a closer look at the `catch` block in the above code snippet. It is followed
    by the word `Exception` (which is the name of the base class for all exceptions
    in PHP) and the variable identifier `$e`. We can use the `$e` variable inside
    the `catch` block to inspect the error message and other debug information. The
    `Exception` class defines the following methods:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看上面代码片段中的`catch`块。它后面跟着`Exception`（这是PHP中所有异常的基类的名称）和变量标识符`$e`。我们可以在`catch`块中使用`$e`变量来检查错误消息和其他调试信息。`Exception`类定义了以下方法：
- en: '`getMessage()` returns the error message.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getMessage()`返回错误消息。'
- en: '`getCode()` returns the error code.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCode()`返回错误代码。'
- en: '`getFile()` returns the name of the file where the exception occurred.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getFile()`返回异常发生的文件名。'
- en: '`getLine()` returns the number of the line where the exception occurred.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getLine()`返回异常发生的行号。'
- en: '`getTrace()` and `getTraceAsString()` return the backtrace (call stack), useful
    for debugging.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getTrace()`和`getTraceAsString()`返回回溯（调用堆栈），用于调试。'
- en: Of course, the error messages and error codes vary depending on where the exception
    occurred, so that they depend on which application library (such as PDO) you use.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，错误消息和错误代码会根据异常发生的位置而变化，因此它们取决于您使用的应用程序库（如PDO）。
- en: We specified the `Exception` class name after the `catch` keyword, because this
    class, like other classes, can be extended to create subclasses. For example,
    all exceptions that are thrown from PDO methods are instances of the `PDOException`
    class.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`catch`关键字后面指定了`Exception`类名，因为这个类，像其他类一样，可以被扩展以创建子类。例如，从PDO方法抛出的所有异常都是`PDOException`类的实例。
- en: 'The exception handling mechanism allows us to create different handling routines
    for different classes of exception. For example, we can do the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理机制允许我们为不同类别的异常创建不同的处理程序。例如，我们可以这样做：
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This code defines two error handling routines for all PDO errors: one class
    for a database error and another class for all other errors, which we identify
    as unexpected errors. Of course, in real life applications, the error handling
    strategies would be more complicated, but this example shows how exceptions can
    be classified.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码为所有PDO错误定义了两个错误处理程序：一个用于数据库错误，另一个用于所有其他错误，我们将其标识为意外错误。当然，在实际应用中，错误处理策略会更加复杂，但这个例子展示了异常如何被分类。
- en: Summary
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this appendix, we saw that PHP5 has some new OOP extensions that are comparable
    with those of modern programming languages. They allow us to write very big applications
    while maintaining code reuse and cleanliness. Object-oriented programming is a
    natural solution for big projects such as content management systems or database
    libraries involving PDO. Libraries for PHP5 are now being written with object-oriented
    programming in mind.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个附录中，我们看到PHP5具有一些新的面向对象编程扩展，这些扩展与现代编程语言的扩展相当。它们允许我们编写非常庞大的应用程序，同时保持代码重用和整洁。面向对象编程是大型项目（如内容管理系统或涉及PDO的数据库库）的自然解决方案。现在，为PHP5编写的库都考虑了面向对象编程。
- en: However, this appendix just gives a short introduction to the main concepts
    behind OOP so that you can follow the code examples in this book. If you want
    to fully master object-oriented programming, you should refer to books that will
    introduce you to and guide you through this challenging topic.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个附录只是简要介绍了面向对象编程背后的主要概念，以便您可以跟随本书中的代码示例。如果您想完全掌握面向对象编程，您应该参考一些能够介绍并指导您掌握这一挑战性主题的书籍。
