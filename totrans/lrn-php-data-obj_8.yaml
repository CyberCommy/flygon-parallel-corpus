- en: Appendix A. Introduction to OOP in PHP5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book, we were mainly using procedural code to build the example
    application. However, the PDO API is fully object-oriented, and in the last chapter
    we imitated real-life entities in the database by using classes. This appendix
    is for those programmers who are not familiar with PHP5's object-oriented extensions.
    We will introduce you to the basics of OOP, as many developers coming from earlier
    versions of PHP have no experience of this type of programming. However, this
    is only a short introduction; if you want to master OOP, you should refer to some
    of the books devoted to this topic.
  prefs: []
  type: TYPE_NORMAL
- en: What is Object-Oriented Programming?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Object-oriented programming (OOP) is a relatively new concept, although its
    roots date back to 1960s. In OOP, the software works with objects that model real-life
    entities (such as books and authors in the [Chapter 7)](ch07.html "Chapter 7. An
    Advanced Example"). Whereas procedural programming involves a series of instructions,
    an application in OOP involves a set of objects that interact with each other.
  prefs: []
  type: TYPE_NORMAL
- en: The Syntax for Declaring Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An object can be viewed as a container for several variables, called properties,
    and for functions that act on these variables. These functions are called methods.
    Every object belongs to a class. In PHP, every object can belong to only one class
    (although some other OOP languages allow multiple inheritance), but there can
    be many objects, or instances, belonging to a single class. A class is a syntactic
    construct that allows you to describe what properties and methods the objects
    belonging to this class will have.
  prefs: []
  type: TYPE_NORMAL
- en: There is an analogy with species and living organisms—for example, a Dog (a
    species, or a class) is a generalization of all living dogs. A generalized dog
    has such properties as weight and age, and a method such as bark, and a real-life
    dog, say Lessie, which belongs to the dog species, could be described as an instance
    of the `Dog` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we would model this in PHP5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this small snippet of code, we defined a class called `Dog`. In PHP5, a class
    definition starts with the reserved word `class` followed by the class's name
    (A class's name can contain the same characters as a function's name.) All the
    class's properties and methods, collectively called **members**, are defined inside
    the `{…}` block.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we are using the keyword, `public`, when we declare properties
    and methods. In PHP4 we would have used the `var` keyword instead, but this keyword
    is deprecated in PHP5\. Besides the `public` keyword, we could have used the `protected`
    keyword or the `private` keyword, but more on this later.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the second part of the code, we create the object with the
    `new` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This line creates a new object belonging to the `Dog` class and assigns it
    to the `$lessie` variable. This is a very important step, since this is the only
    way to create objects. After the PHP processes it, the `$lessie` variable becomes
    initialized and we can access the properties and methods declared in the `Dog`
    class so that we act on the object called `Lessie`. We would now like to have
    two dogs in our application, and the second one will be called `K9`. To achieve
    that, we would have to write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can access both the `$k9` and `$lessie` variables, if we would like
    to interface with each of our dogs.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, before we can communicate with an instance, it first has to
    be created with the `new` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: After the variable has been initialized, we can access its properties and methods.
    As you can see in the code, this is achieved with the `->` construct, which is
    used with both properties and methods. Note that when accessing a class’s properties,
    we don’t have to write the dollar sign after the -> (but we have to use it when
    declaring the properties inside the class definition).
  prefs: []
  type: TYPE_NORMAL
- en: 'The methods are declared with the `function` keyword followed by the method’s
    name and a list of parameters. In fact, a class’s methods are declared in a similar
    way to that for an ordinary function, but there is one major difference. Inside
    the declaration of a method, there always exists implicit variable, called `$this`,
    which allows you to access the object’s properties. Let’s see how we could create
    a `getInfo()` method to return some additional information about our dogs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This code would display the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every class also has a special function (which may be implicit or explicitly
    declared) called a **constructor**. The constructor is always called when PHP
    encounters the `new` keyword, and its purpose is to perform some initialization
    tasks. Let''s extend the `Dog` class so that it has a `$name` property. We will
    also change the code so as to initialize the `name, weight`, and `age` properties
    inside the constructor rather than in the main application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This application would display the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here's a brief summary of what we did. We first declared the `$name` property
    and then the constructor for our `Dog` class. The constructors are declared as
    function with the special name of `__construct` (the word `constructor` prepended
    with two underscores('_'). Our constructor accepts three parameters—`name`, `age`,
    and `weight`, whose values are assigned to the object's properties. The order
    in which we assign values to the properties does not matter. Note that we always
    have to use the `$this` variable to denote the properties of the object. By doing
    this, we can differentiate the local variables `$name, $age`, and `$weight` (passed
    as parameters) from the object's own properties, which have the same names, inside
    the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: We also changed the `getInfo()` method so that it returns the name of the dog
    as well. We can now instantiate objects by passing the name, the age, and the
    weight to the constructor. Since these properties get assigned in the constructor,
    we don't have to do this in the main part of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should be also noted that you can assign default values to properties in
    the class definition. This will ensure that every object of that class will have
    the default values automatically assigned. For example, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the application with this `Dog` class definition, then you will
    see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can now see, the default property value for `hasCollar` has propagated
    to every newly created instance (of course, it can be later changed for each object).
  prefs: []
  type: TYPE_NORMAL
- en: Destructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is an opposite concept to constructors, called destructors. As its name
    suggests, destructors are used to perform cleanup tasks (classic examples of such
    tasks are deleting temporary files, closing database connections, etc). In PHP5,
    destructor on an object is called, when there are no more references to that object
    (for example, by setting the variable that holds the reference to the object to
    **null** or when the application terminates), then the destructor will be called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Destructor is a method: `__destruct()`. If you add that method to the class,
    then it will be called when the object is freed. Let’s add the destructor to the
    **Dog** class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you run the code again, it will give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that the order in which PHP5 calls the destructors is not defined. Also,
    in a destructor, the code may not access other objects unless they are referenced
    by the object being freed. In other words, the destructor should only cleanup
    those resources that were created by that object.
  prefs: []
  type: TYPE_NORMAL
- en: The Advantages of OOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The power of OOP lies in its three main characteristics: inheritance, encapsulation,
    and polymorphism.'
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inheritance in OOP allows you to create new classes that inherit an existing
    class''s behaviour (methods) and attributes (properties). Let''s consider the
    following example. Assume that we have a class called `Fruit`. It is a generalized
    type of class for different fruits, and its common attributes are color and weight.
    In OOP, we can subclass `Fruit` to create new classes `Apple` and `Banana`. Both
    these classes (being subclasses of Fruit) will have the same properties: `weight`
    and `color`. (Note we are speaking about properties as such, not about their values).
    An apple can have a green color, while a `Banana` can have a yellow color. But
    any code that interacts with `Apple` or `Banana` class instances does not need
    to know what kind of fruit it is communicating with.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put this example into code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, in this small application we have one `Apple` object and one
    `Banana` object. We iterate over them in a loop, but access their properties regardless
    of their type, since both classes use the same property names. But these properties
    carry different values for each fruit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inheritance also allows to extend or completely override the behavior of the
    parent classes. Let''s assume that our `Fruit` class has one more characteristic—price
    per kg. It also has a new method—`getPrice()` that just multiplies the weight
    (which we have in grams) by the price:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use this method in the subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will assume that the `Banana` class has another method for calculating
    price so that a discount is applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we changed the method in the `Banana` class so that the code
    calling the `Banana` class's implementation of the `getPrice()` method will get
    discounted price, while the `Apple` class's `getPrice()` method returns full price.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, we could reuse the `Fruit` class''s implementation of the
    `getPrice()` method in the `Banana` class (so that we don''t have to duplicate
    the code contained in the base class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Encapsulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Encapsulation (sometimes called information hiding) is a more theoretical concept.
    It involves defining methods in a class in such a way that we hide the implementation
    details from the client code. We have already seen this when we redefined the
    price calculation in the `Banana` class. From the application''s point of view,
    nothing changed: we still call the `getPrice()` method, but we don''t know how
    this calculation is performed.'
  prefs: []
  type: TYPE_NORMAL
- en: In other words, classes are accessible through their methods, which have the
    same names so that, even if the code behind these names changes, the names themselves
    do not change. This ensures that existing code does not need to be changed to
    work with new versions of methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do more to hide implementation details from client code, PHP5, like
    other object-oriented languages, supports **visibility modifiers** for methods
    and properties. For example, we could add a private property, which will be hidden
    from the rest of the application, to the `Banana` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `$mySecretProperty` property is only accessible (or visible) in the `Banana`
    class; an attempt to access it from outside the `Banana` class's methods would
    trigger a run-time error. (In a compiled language, this would lead to a compilation
    error.)
  prefs: []
  type: TYPE_NORMAL
- en: 'In PHP5, there exist two more modifiers: **public** (which we have already
    used), and **protected**. Public method or property is accessible from all the
    application, while protected is accessible inside the class and its subclasses
    only.'
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Polymorphism** is a feature of OOP that allows us to write code that will
    work with objects belonging to different classes provided that these classes have
    the same base class. We have already seen polymorphism in action in the above
    example when we were accessing properties and methods of different objects using
    their names but returning different values and taking different actions.'
  prefs: []
  type: TYPE_NORMAL
- en: The subclasses implement all the properties and methods belonging to the base
    class, and all future subclasses of the base class are guaranteed to implement
    these properties and methods so that the existing code can work even with subclasses
    which do not yet exist.
  prefs: []
  type: TYPE_NORMAL
- en: PHP5 supports interfaces. An interface is a construct that describes certain
    behaviour in different classes and class hierarchies. For example, let’s consider
    a `Tradeable` interface that has a single method, `isImported():`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can declare in the definition of the `Fruit` class that it implements
    the Tradeable interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We have made `Fruit` objects and all objects belonging to its subclasses `(Apple`
    and `Banans)` non-imported by default. Now we can make bananas imported while
    leaving apples domestic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we will create an imaginary `Car` class that implements the `Tradeable`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `Car` does not extend `Fruit`, but it still has the `isImported()`
    method. Now we can call this method from the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This small example shows how objects from different class hierarchies can be
    treated in the same way by giving them a common interface. By doing this, objects
    that normally have quite different meanings can be manipulated in the same way,
    and this makes them polymorphic.
  prefs: []
  type: TYPE_NORMAL
- en: Static Properties, Methods, and Class Constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In all the examples in this appendix, we are using instances (objects) of classes,
    which modeled real-life entities. However, in PHP5 it is possible to use **static**
    properties and methods. Static properties are variables that are common to all
    the instances of the given class so that, if a static property is changed, it
    will get changed for all objects belonging to the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'A static property is declared just like a regular one, but with a special **static**
    keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The static properties can be accessed without even creating an instance of
    the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax for accessing a static property is as follows: the class name, then
    double semicolon, and then the property''s name. Note that with static properties
    (unlike with regular properties), the dollar sign, `$`, sign must be present.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Static methods, just like static properties, can be accessed without instantiating
    an object. They are declared and accessed in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The declaration of a static method has the `static` keyword followed by a regular
    method declaration. The method is accessed by the class name followed by a double
    semicolon and then the method name.
  prefs: []
  type: TYPE_NORMAL
- en: The static properties and methods can be accessed inside the class declaration
    using the shortcut keyword `self:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: There is also a major difference with the definition of static methods. You
    cannot use the `$this` variable (as there is no object to which the `$this` variable
    can refer).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another ''static'' feature of classes is class constants. A class constant
    acts like a static property, but its value cannot be changed. Class constants
    always must have their values assigned in the class declaration section, and they
    don''t have the dollar sign before them (so they are named just like regular PHP
    constants). Class constants are mostly used for keeping the global namespace cleaner
    (which is also one of the uses for static methods):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: An attempt to assign a value to a class constant in the code will lead to a
    parse error.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen, exceptions are a very important addition to PHP5\. Exceptions
    are special kind of object that, when instantiated and `thrown`, break the normal
    execution flow and jump to a so called `catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exceptions are used to report error conditions. Traditionally, functions return
    error codes if they fail. The application has to check every function call before
    proceeding to the next function call. Remember the piece of code that you use
    to connect to a MySQL database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `mysql_xxx` functions could throw exceptions, this code could be simplified
    to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this code would not work, as these functions are not designed to
    throw exceptions. You will have to use PDO, and in [Chapter 3](ch03.html "Chapter 3. Error
    Handling") we saw how to work with PDO exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exceptions allow you to postpone error checking and maintain cleaner code.
    A function (or method) that causes an exception to be thrown is terminated, and
    the code in the block specified by the `catch` keyword is executed. Any code that
    might throw an exception is wrapped into the `try` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The real power of exceptions is the ability to escalate them up the call stack.
    This means that, if you design a function or class method that can throw an exception,
    that function or method does not have to catch that exception. In fact, many application
    libraries are designed in such a way so that they don't process exceptions themselves,
    but instead let them pass to the calling code.
  prefs: []
  type: TYPE_NORMAL
- en: For example, many of the methods of the `PDO` and `PDOStatement` classes that
    we have encountered in this book can throw exceptions, and it is your responsibility
    to catch them and act appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a closer look at the `catch` block in the above code snippet. It is followed
    by the word `Exception` (which is the name of the base class for all exceptions
    in PHP) and the variable identifier `$e`. We can use the `$e` variable inside
    the `catch` block to inspect the error message and other debug information. The
    `Exception` class defines the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getMessage()` returns the error message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getCode()` returns the error code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getFile()` returns the name of the file where the exception occurred.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getLine()` returns the number of the line where the exception occurred.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getTrace()` and `getTraceAsString()` return the backtrace (call stack), useful
    for debugging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, the error messages and error codes vary depending on where the exception
    occurred, so that they depend on which application library (such as PDO) you use.
  prefs: []
  type: TYPE_NORMAL
- en: We specified the `Exception` class name after the `catch` keyword, because this
    class, like other classes, can be extended to create subclasses. For example,
    all exceptions that are thrown from PDO methods are instances of the `PDOException`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exception handling mechanism allows us to create different handling routines
    for different classes of exception. For example, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This code defines two error handling routines for all PDO errors: one class
    for a database error and another class for all other errors, which we identify
    as unexpected errors. Of course, in real life applications, the error handling
    strategies would be more complicated, but this example shows how exceptions can
    be classified.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this appendix, we saw that PHP5 has some new OOP extensions that are comparable
    with those of modern programming languages. They allow us to write very big applications
    while maintaining code reuse and cleanliness. Object-oriented programming is a
    natural solution for big projects such as content management systems or database
    libraries involving PDO. Libraries for PHP5 are now being written with object-oriented
    programming in mind.
  prefs: []
  type: TYPE_NORMAL
- en: However, this appendix just gives a short introduction to the main concepts
    behind OOP so that you can follow the code examples in this book. If you want
    to fully master object-oriented programming, you should refer to books that will
    introduce you to and guide you through this challenging topic.
  prefs: []
  type: TYPE_NORMAL
