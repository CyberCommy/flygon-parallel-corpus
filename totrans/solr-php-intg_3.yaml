- en: Chapter 3. Select Query on Solr and Query Modes (DisMax/eDisMax)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will cover how to execute a basic select query on the Solr index
    using PHP and the Solarium library. We will be specifying different query parameters
    such as number of rows to fetch, fetching specific fields, sorting, and some other
    parameters in the Solarium query. We will discuss what query modes (query parsers)
    in Solr are and will also go through the different query modes available in Solr
    and their usage. We will look at different features to improve the results from
    our query or get more specific results from our query. The topics that will be
    covered are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic select query with sorting and return fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running queries using select configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Re-using queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DisMax and eDisMax query modes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component-based architecture of Solarium
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing queries using DisMax and eDisMax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Date boosting in eDisMax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced tuning parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a basic select query with sorting and return fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the following query, let us look for all the books in our index and return
    the top five results in JSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As seen earlier, we can form a query URL and use cURL to fire the query via
    PHP. Decode the JSON response and use it as result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at the Solarium code to execute `select` queries on Solr. Create
    a `select` query from the Solarium client as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a query to search for all books:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Suppose we show three results per page. So on the second page, we will start
    from four and display the next three results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Set which fields should be returned using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PHP 5.4 users can use square brackets to construct an array instead of the earlier
    `array(...)` construct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us sort the result by price using the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, execute the following `select` query and get the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The resultset contains an array of documents. And each document is an object
    containing fields and values. For a multivalued field in Solr, all values will
    be returned as an array. We will need to handle the values accordingly. In addition
    to the four fields that we retrieved using our query, we also get the score of
    the document. The document score is a number calculated by Lucene to rank the
    documents based on their relevance with respect to the input query. We will talk
    in depth about scoring in later chapters. Let us iterate over the resultset and
    display the fields.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'From the resultset, we can also get the number of documents found using the
    `getNumFound()` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Internally, the parameters that we set are used to form a Solr query and the
    same query is executed on Solr. We can check the query being executed from the
    Solr logs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Solr logs are located in the `<tomcat_home>/logs` folder in the `catalina.out`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The executed query looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameter for the `setQuery()` function should be equal to the `q` parameter
    in our Solr query. If we want to search on multiple fields in our Solr index,
    we will have to create the search query with the required fields. For example,
    if we want to search for `Author` as `Martin` and `Category` as `book`, our `setQuery()`
    function will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Running a query using select configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to building the `select` query through functions, it is also possible
    to build a `select` query using an array of key-value pairs. Here is a `selectconfig`
    query with parameters for the preceding query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also add multiple sorting fields as an array using the `addSorts(array
    $sorts)` function. To sort by price and then by score, we can use the following
    parameters in the `addSorts()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We can use the `getQuery()` function to get the query parameter. And the `getSorts()`
    function to get the sorting parameter from our select query. We can also use the
    `removeField($fieldStr)` and `removeSort($sortStr)` functions to remove parameters
    from the fields list and sort list of our query.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `setQueryDefaultField(String $field)` and `setQueryDefaultOperator(String
    $operator)` functions to change the default query field and default operator in
    our Solr query. If the functions are not provided, the default query field and
    default query operator are picked up from the Solr configuration. The default
    search field is picked up from the `df` parameter in `solrconfig.xml`. The default
    operator is `OR` if not provided. It can be overwritten by passing the `q.op`
    parameter in the query.
  prefs: []
  type: TYPE_NORMAL
- en: Re-using queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most cases, the queries that you build as a part of the application can be
    reused. It would make more sense to re-use the queries instead of creating them
    again. The functions provided by the Solarium interface help in modifying the
    Solarium query for re-use. Let us see an example for re-using queries.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we form a complex query based on input parameters. For pagination purposes,
    we would like to use the same query but change the `start` and `rows` parameters
    to fetch the next or previous page. Another case where a query could be reused
    is sorting. Suppose we would like to sort by price in ascending order and later
    by descending order.
  prefs: []
  type: TYPE_NORMAL
- en: Let us first define and create an alias for Solarium namespaces we will be using
    in our code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a class that extends the Solarium query interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the class we will create the `init()` function, which will override
    the same function in the `parent` class and add our default query parameters there
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`RESULTSPERPAGE` is a private variable that can be declared as `5`. Create
    a separate function to set the query.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Create a function to reset the sorting. A reset would mean removing all previous
    sorting parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Changing sorting parameters includes resetting the current sort and adding a
    new sorting parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'A function to add additional sorting parameters is used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'A function to change the page is used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Once the class is defined, we can create an instance of the class and set our
    initial query. This will give us results from the first page.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: To go to any other page, simply call the `goToPage()` function that we have
    created with the page we want to go to. It will alter the Solarium query, and
    change the `Start` parameter to coincide with results for the page.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The complete code is available as part of downloads. What we have done here
    is extend the query interface and add our own functions to change the query, reset
    and add sorting parameters, and for pagination. Once we have an object of the
    `myQuery` class, all we have to do is keep on altering the parameters as required
    and keep on executing the query with the altered parameters.
  prefs: []
  type: TYPE_NORMAL
- en: DisMax and eDisMax query modes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**DisMax** (**Disjunction Max**)and **eDisMax** (**Extended Disjunction Max**)
    are query modes in Solr. They define the way how Solr parses user input to query
    different fields and with different relevance weights. eDisMax is an improvement
    over the DisMax query mode. DisMax and eDisMax are by default enabled in our Solr
    configuration. To switch the query type we need to specify `defType=dismax` or
    `defType=edismax` in our Solr query.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us add some more books to our index. Execute the following command in our
    `<solr dir>/example/exampledocs` folder (`books.csv` is available in code downloads):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: DisMax handles most queries. But there are still some cases where DisMax is
    unable to provide results. It is advisable to use eDisMax in those cases. The
    DisMax query parser does not support the default Lucene query syntax. But that
    syntax is supported in eDisMax. Let us check it out.
  prefs: []
  type: TYPE_NORMAL
- en: 'To search for `books` in `cat`, let us execute the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be getting zero results because the query `q=cat:book` is not supported
    by DisMax. To execute this query in DisMax, we will have to specify an additional
    query parameter `qf` (query fields) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'But `q=cat:book` will work on eDisMax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: To understand how the Solarium library can be used for executing DisMax and
    eDisMax queries, we need to introduce the concept of **components**. Solr query
    has lots of options. Putting all options in a single query model can cause decreased
    performance. So, additional functionality is broken down into components. The
    query model of Solarium handles basic queries, and additional functionality can
    be added to the query by using components. Components are only loaded when used
    thus improving performance. The component structure allows for easy addition of
    more components.
  prefs: []
  type: TYPE_NORMAL
- en: Executing queries using DisMax and eDisMax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us explore how to execute DisMax and eDisMax queries using the Solarium
    library. First, get a DisMax component from our select query using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Boosting is used in Solr to alter the score of some documents in a resultset,
    so that certain documents are ranked higher than others based on their content.
    A boost query is a raw query string that is inserted along with the user's query
    to boost certain documents in the result. We can set a boost on `author = martin`.
    This query will boost results where author contains `martin` by `2`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Query fields specify the fields to query with certain boosts. The query string
    passed in `setQuery` function is matched against text in these fields. When a
    field is boosted, a match for a query text in that field is given more importance
    and so that document is ranked higher. In the following function, matches in the
    author field are boosted by `3`, where as matches in name are boosted by `2` and
    the `cat` field has no boost. So during search, the document in which the input
    query text matches with that in author is ranked higher compared to documents
    where text is found in the `name` or `cat` fields.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: By default, all clauses in the default Solr query are treated as optional, unless
    they are specified by a `+` or `-` sign. Optional clauses are interpreted as any
    one of the clauses in the query should match with the text in the specified fields
    in the document to consider that document to be a part of the search result. When
    dealing with optional clauses, the minimum match parameter says that some minimum
    number of clauses must match. The minimum number of clauses can be a number or
    a percentage. In case of a number irrespective of the number of clauses in the
    query the minimum specified must match. In case of a percentage, a number is computed
    from the available number of clauses and the percentage and it is rounded down
    to the nearest integer and then used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Phrase query fields are used to boost the score of documents in case the terms
    in the query parameter appear in close proximity. The closer the query terms are
    in the Phrase query field, the higher is the score of the document. In the following
    code, this score is being boosted by `5` giving higher relevance to these documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Phrase slop is the number of positions a token has to be moved in relation to
    another token in order to match a phrase specified in the query. During indexing
    the input text is analyzed and broken into smaller words or phrases that are known
    as **tokens**. Similarly during search, the input query is broken into tokens
    that are matched with tokens in the index. This is used in conjunction to the
    `Phrase` fields to specify the slop to apply to queries with the `Phrase` fields
    set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Query slop specifies the slop permitted in phrases in the user's input query.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: eDisMax has all features of the DisMax parser and extends it.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the preceding mentioned functions will also work with eDisMax queries.
    All we have to do is get the eDisMax component and call these functions on the
    eDisMax component. To get the eDisMax component, call the `getEDisMax()` function
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In addition to this, field-based queries similar to that supported by the basic
    Solr query parser are also supported in eDisMax and they give us better flexibility
    in creating our search query.
  prefs: []
  type: TYPE_NORMAL
- en: eDisMax provides us with the option of applying a boost function with multiplicative
    effect. We can use the `setBoostFunctionsMult()` function to provide a boost function
    that will multiply with the score. The DisMax parser on the other hand provides
    the `setBoostFunctions()` function, which can influence the score by adding the
    resultant boost of the function to the score of the query.
  prefs: []
  type: TYPE_NORMAL
- en: eDisMax provides some other functions such as `setPhraseBigramFields()`, which
    chops the user query into bigrams and queries the fields specified with the related
    boost. For example, if the user has entered `hello world solr`, it will be broken
    into `hello world` and `world solr` and executed on the fields specified in these
    functions. Similarly, another `setPhraseTrigramFields()` function can be used
    to break the user input into trigrams instead of bigrams. Trigrams would contain
    three-word phrases instead of the two-word phrases we saw earlier in bigrams.
    eDisMax also provides functions such as `setPhraseBigramSlop()` and `setPhraseTrigramSlop()`
    to specify custom slop with respect to the bigram and trigram fields during search.
  prefs: []
  type: TYPE_NORMAL
- en: '**Slop** is the number of positions a token has to be moved with respect to
    another to get a match. A slop of `5` between tokens `t1` and `t2` would mean
    that `t1` should occur within five tokens of `t2`.'
  prefs: []
  type: TYPE_NORMAL
- en: Let us look at the Solr query logs for DisMax and eDisMax queries.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We can see that in addition to the normal parameters of Solr query, there is
    a `defType` parameter that specifies the type of query. In the preceding case,
    we can see that `defType` is DisMax or eDisMax depending on the type of query
    we executed.
  prefs: []
  type: TYPE_NORMAL
- en: Date boosting in an eDisMax query
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us use eDisMax to boost the results of a search based on date so that the
    most recent book appears on top. We will use the `setBoostFunctionsMult()` function
    to specify the boost on `modified_date`, which in our case stores the date when
    the record was last added or updated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we are searching for all books where the author is not named Martin (`martin`).
    The `–` (negative sign) is meant for *not query*. And we have added a multiplicative
    boost on the reciprocal of the date between today and last modified date. The
    `recip` function provided by Solr is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here `m`, `a`, and `b` are constants, `x` can be any numeric value or complex
    function. In our case, `x` is the number of milliseconds between `NOW` and `last_modified`.
    We are adding `1` in the denominator to avoid errors in cases where `last_modified`
    is not present. This shows that as the difference between `NOW` and `last_modified`
    increases the boost for that document decreases. Recent documents have higher
    `last_modified` and so the difference with respect to `NOW` is less and so boost
    is more. Let us check the Solr logs for the query.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Copy and paste the parameters from the query in Solr log and append to the Solr
    `select` URL. Also change `wt=json` to `wt=csv`. This will give a comma separated
    view of the results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '![Date boosting in an eDisMax query](graphics/4920_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The URL can be altered further to tune/modify the query as per our requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced query parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Alternative queries are used when the query parameter is either blank or not
    specified. Solarium by default sets the query parameter as `*:*`. Alternative
    queries can be used to get all documents from an index for faceting purposes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: For selecting all documents in DisMax/eDisMax, the normal query syntax `*:*`
    does not work. To select all documents, set the default query value in Solarium
    query to empty string. This is required as the default query in Solarium is `*:*`.
    Also set the alternative query to `*:*`. DisMax/eDisMax normal query syntax does
    not support `*:*`, but the alternative query syntax does.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We were able to execute select queries on Solr using the Solarium library. We
    explored the basic parameters for the `select` query. We saw how to use a configuration
    array to create a Solarium query. We were able to iterate through the results
    after executing a query. We extended the query class to re-use queries. We were
    able to do pagination on our existing query and were able to change the sorting
    parameters without recreating the complete query again. We saw DisMax and eDisMax
    query modes in Solr. We also got an idea of the component based structure of Solarium
    library. We explored the query parameters for DisMax and eDisMax queries. We also
    saw how to use an eDisMax query to do "recent first" date boosting on Solr. Finally,
    we saw some advanced query parameters for DisMax and eDisMax in Solarium.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will go deeper into advanced queries based on different
    criteria from our query result.
  prefs: []
  type: TYPE_NORMAL
