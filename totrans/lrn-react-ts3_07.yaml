- en: Working with Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Forms are extremely common in the apps we build. In this chapter, we'll learn
    how to build forms using controlled components in React and TypeScript. We'll
    build a Contact Us form for the React shop we have been working on in other chapters
    as our learning exercise.
  prefs: []
  type: TYPE_NORMAL
- en: We'll quickly discover that there is a fair amount of boilerplate code involved
    in creating forms, so we'll look at building a generic form component to reduce
    the boilerplate code. Client-side validation is critical to the user experience
    of the forms we build, so we'll also cover this topic in a fair amount of depth.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, form submission is a critical consideration. We'll cover how to handle
    submission errors, as well as success.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a form with controlled components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing boilerplate code with generic components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Form submission
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll use the following technologies in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Node.js** and `npm`: TypeScript and React are dependent on these. Install
    them from the following link: [https://nodejs.org/en/download/](https://nodejs.org/en/download/).
    If you already have these installed, make sure `npm` is at least version 5.2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual Studio Code**: We''ll need an editor to write our React and TypeScript'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: code, which can be installed from [https://code.visualstudio.com/](https://code.visualstudio.com/).
    We'll also need the TSLint extension (by egamma) and the Prettier extension (by
    Estben Petersen).
  prefs: []
  type: TYPE_NORMAL
- en: '**React shop**: We''ll start with the React shop project we finished in [Chapter
    6](3680b0b4-3a8c-4fae-8ac2-da283139bbb6.xhtml), *Component Patterns*. This is
    available on GitHub at [https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/06-ComponentPatterns](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/06-ComponentPatterns).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to restore code from a previous chapter, the `LearnReact17WithTypeScript`
    repository at [https://github.com/carlrip/LearnReact17WithTypeScript](https://github.com/carlrip/LearnReact17WithTypeScript)
    can be downloaded. The relevant folder can then be opened in Visual Studio Code
    and then `npm install` can be entered in the terminal to do the restore. All the
    code snippets in this chapter can be found online at [https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/07-WorkingWithForms](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/07-WorkingWithForms).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a form with controlled components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Forms are a common part of most apps. In React, the standard way to create a
    form is with what is called *controlled components*. A controlled component has
    its value synchronized with state in React. This will make more sense when we've
    implemented our first controlled component.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to extend the React shop we have been building to include a Contact
    Us form. This will be implemented using controlled components.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Contact Us page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start work on our form, we need a page to host the form in. The page
    will be a container component, and our form will be a presentational component.
    We also need to create a navigation option that takes us to our new page.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll write the following codes before starting to implement our form:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you haven''t already, open the React shop project in Visual Studio Code.
    Create a new file called `ContactUsPage.tsx` in the `src` folder, containing the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This component will eventually contain state, so, we have created a class-based
    component. This simply renders a heading with some instructions at the moment.
    Eventually, it will reference our form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now add this page to the available routes. Open `Routes.tsx`, and import
    our page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `render` method for the `Routes` component, we can now add a new route
    to our page just above the `admin` route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `Header.tsx` now, which contains all the navigation options. Let''s add
    a `NavLink` to our new page just above the admin link:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the project in your development server, by entering the following in the
    terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a new navigation option that takes us to our new page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a3962f6b-53ca-42b1-a6b3-d987b02f8944.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have our new page, we are ready to implement our first controlled
    input in a form. We'll do this in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating controlled inputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll start to create our form containing our first controlled
    input:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `ContactUs.tsx` in the `src` folder containing the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is a function component that renders a form containing a label and an input
    for the user's name.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have referenced some CSS classes, so let''s add these to the bottom of `index.css`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `form-group` class wraps each field in our form, displaying the label above
    the input with nice spacing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s reference our form from our page now. Go to `ContactUsPage.tsx` and
    import our component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then reference our component in the `render` method at the bottom of
    the `div` container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at the running app and go to the Contact Us page, we''ll see our
    name field rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dc455066-7714-4043-916e-3cd46c5e0eb0.png)'
  prefs: []
  type: TYPE_IMG
- en: We can enter our name into this field, but nothing will happen yet. We want
    the entered name to be stored in the `ContactUsPage` container component state.
    This is because `ContactUsPage` will eventually manage the form submission.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a state type to `ContactUsPage`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As well as the person's name, we are going to capture their email address, reason
    for contacting the shop, and any additional notes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also initialize the state in a constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to get the name value from the state in `ContactUsPage` into the
    `ContactUs` component. This will allow us to display the value in the input. We
    can do this by first creating props in the `ContactUs` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We have created props for all the data we are going to eventually capture in
    our form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can bind the name input value to the `name` prop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now pass these from the state in `ContactUsPage`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Let's go to the running app and go to our Contact Us page. Try typing something
    into the name input.
  prefs: []
  type: TYPE_NORMAL
- en: Nothing seems to happen... something is preventing us from entering the value.
  prefs: []
  type: TYPE_NORMAL
- en: We have just set the input value to some React state, so React is now controlling
    the value of the input. This is why we no longer appear to be able to type into
    it.
  prefs: []
  type: TYPE_NORMAL
- en: We are part-way through creating our first controlled input. However, controlled
    inputs aren't much use if users can't enter anything into them. So, how can we
    make our input editable again?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that we need to listen to changes to the input value, and update
    the state accordingly. React will then render the new input value from the state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s listen to changes to the input via the `onChange` prop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create the handler we have just referenced as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that we've used the generic `React.ChangeEvent` command with the type of
    the element we are handling (`HTMLInputElement`).
  prefs: []
  type: TYPE_NORMAL
- en: The `currentTarget` prop in the event argument gives us a reference to the element
    that the event handler is attached to. The `value` property within this gives
    us the latest value of the input.
  prefs: []
  type: TYPE_NORMAL
- en: 'The handler references an `onNameChange` function prop that we haven''t defined
    yet. So, let''s add this to our interface, along with similar props for the other
    fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now pass these props from `ContactUsPage` into `ContactUs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create the change handlers we''ve just referenced in `ContactUsPage`
    that set the relevant state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If we now go to the Contact Us page in the running app and enter something into
    the name, this time the input behaves as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add fields for email, reason, and notes in our `render` method for `ContactUs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: For each field, we render a `label` and the appropriate editor inside a `div`
    container, with a `form-group` class to space our fields out nicely.
  prefs: []
  type: TYPE_NORMAL
- en: All the editors reference handlers for handling changes to their value. All
    the editors also have their value set from the appropriate `ContactUs` prop. So,
    all the field editors have controlled components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a closer look at the `select` editor. We set the value in the `select`
    tag using a `value` attribute. However, this doesn''t exist in the native `select`
    tag. Usually, we have to include a `selected` attribute in the relevant `option`
    tag within the `select` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: React adds the `value` prop to the `select` tag, and manages the `selected`
    attribute on the `option` tag for us, behind the scenes. This allows us to consistently
    manage `input`, `textarea`, and `selected` in our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now create the change handlers for these fields that call the function
    props we created earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This completes our basic Contact Us form, using various controlled form elements.
    We haven't implemented any validation or submitted the form yet. We'll get to
    these later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We're already noticing lots of similar code for each field for getting changes
    to fields into state. In the next section, we are going to start work on a generic
    form component and switch to using this for our Contact Us form.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing boilerplate code with generic components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generic form components will help reduce the amount of code required to implement
    a form. We are going to do just this in this section, refactoring what we did
    in the last section for our `ContactUs` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s think about how we would ideally consume the generic components to produce
    the new version of the `ContactUs` component. It could be something like the following
    JSX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, there are two generic compound components: `Form` and `Field`.
    Here are some key points:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Form` component is the container for the compound, managing the state and
    the interactions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We pass default values in for the fields in a `defaultValues` prop on the `Form`
    component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Field` component renders the label and an editor for each field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each field has a `name` prop that will determine the property name in the state
    that the field value is stored under.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each field has a `label` prop that specifies the text to display in each field
    label.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The specific field editor is specified using a `type` prop. The default editor
    is a text-based `input`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the editor type is `Select`, then we can specify the options that appear
    in this using an `options` prop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JSX to render the new `ContactUs` component is much shorter than the original
    version, and arguably easier to read. The state management and event handlers
    are hidden away and encapsulated within the `Form` component.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic form component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s time to start work on our generic `Form` component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a new file in the `src` folder called `Form.tsx`,
    containing the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`Form` is a class-based component because it needs to manage state. We have
    named the props interface `IFormProps` because later on we''ll need an interface
    for field props.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a `defaultValues` prop to the `IFormProps` interface. This will
    hold the default value for every field in the form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We use an additional interface called `IValues` for the default value type.
    This is an indexable key/value type that has a `string` type key and an `any`
    type value. The key will be the field name, and the value will be the field value.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the value for the `defaultValues` prop could be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s move on to the state in `Form` now. We are going to store the field
    values in a state property called `values`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note that this is the same type as the `defaultValues` prop, which is `IValues`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to initialize the state with the default values in the constructor
    now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The final bit we are going to do in this section is to start implementing the
    `render` method in the `Form` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We render the child components in a `form` tag, using the magical `children`
    prop we used in the last chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This leads us nicely to the `Field` component, which we'll implement in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a basic Field component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Field` component needs to render a label and an editor. It will live in
    a static property called `Field` inside the `Form` component. Consumers can then
    reference this component using `Form.Field`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating an interface for the field props in `Form.tsx` just
    above `IFormProps`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `name` prop is the name of the field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `label` prop is the text to display in the field label.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `type` prop is the type of editor to display. We have used a union type
    for this prop, containing the available types we are going to support. Note that
    we have defined this as an optional prop, so we'll need to define a default value
    for this a little later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `options` prop, which is only applicable to the `Select` editor type, is
    also optional. This defines the list of options to display in the drop-down in
    a `string` array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s add a skeleton static `Field` property in `Form` for the `Field`
    component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we forget, let''s add that default for the field `type` prop. We define
    this as follows, outside and underneath the `Form` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: So, the default `type` will be a text-based input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s have a go at rendering the field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We start by destructuring `name`, `label`, `type`, and `options` from the props
    object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The field is wrapped in a `div` container, which spaces the fields out vertically,
    using the `form-group` class we already implemented in `index.css`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `label` is then rendered just before the `input` inside the `div` container,
    with the `htmlFor` attribute of the label referencing the `id` of the `input`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a good start, but not all the different field editors are inputs. In
    fact, this will only work for types `Text` and `Email`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s adjust this slightly and wrap a conditional expression around the
    input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s deal with the `TextArea` type by adding the highlighted JSX:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now render the final editor we are going to support, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We render a `select` tag, containing the options specified by using the `map`
    function in the `options` array prop. Note that we give each option a unique `key`
    attribute to keep React happy when detecting any changes to the options.
  prefs: []
  type: TYPE_NORMAL
- en: We now have basic `Form` and `Field` components in play, which is great. However,
    the implementation is still pretty useless because we are not managing the field
    values yet in state. Let's cover that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing state with React context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The state for field values lives in the `Form` component. However, the values
    are rendered and changed with the `Field` component. The `Field` component doesn't
    have access to the state within `Form`, because the state lives in the `Form`
    instance and `Field` doesn't.
  prefs: []
  type: TYPE_NORMAL
- en: This is very similar to the compound `Tabs` component we implemented in the
    last chapter. We shared state between the components in the `Tabs` compound using
    React context.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use the same approach for our `Forms` component in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating an interface for the form context in `Form.tsx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The context just contains values that have the same type, `IValues`, as in our
    state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the context component now just under `IFormContext` using `React.createContext`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We keep the TypeScript compiler happy by setting the initial context value to
    an empty literal value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `render` method in `Form`, create the context value containing the values
    from the state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Wrap the context provider around the `form` tag in the `render` method''s JSX:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now consume the context in the `Field` SFC:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have access to the context, let''s render the values from it in
    all three editors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The TypeScript compiler is now happy with our `Form` and `Field` components.
    So, we could start work on the new `ContactUs` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: However, users will not be able to enter anything into our form yet, because
    we are not handling changes and passing new values to state. We now need to implement
    change handlers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a `setValue` method in the `Form` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the key points in this method:'
  prefs: []
  type: TYPE_NORMAL
- en: This method takes in the field name and new value as parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new state for the `values` object is created using a new object called `newValues`,
    which spreads the old values from the state and then adds the new field name and
    value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new values are then set in the state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We then create a reference to this method in the form context so that the `Field`
    component can access it. Let''s add this to the form context interface first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We set the property as optional to keep the TypeScript compiler happy when the
    form context component is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then create a reference to the `setValue` method in `Form` when the
    context value is created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have access to invoke this method from the `Field` component. In `Field`,
    just after we destructure the `props` object, let''s create a change handler that
    will invoke the `setValue` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the key points in this method:'
  prefs: []
  type: TYPE_NORMAL
- en: The TypeScript change event type is `ChangeEvent<T>`, where `T` is the type
    of the element that is being handled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The handler's first parameter, `e`, is the React change event handler parameter.
    We union all the different change handler types for our different editors, so
    that we can handle all changes in a single function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The handler's second parameter is the form context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need a conditional statement to check that the `setValue` method is not `undefined`,
    to keep the TypeScript compiler happy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can then call the `setValue` method with the field name and new value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can then reference this change handler in the `input` tag, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Note that we use a lamda function so that we can pass in the context value to
    `handleChange`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do the same in the `textarea` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also do this in the `select` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: So, our `Form` and `Field` components are now nicely working together, rendering
    fields and managing their values. In the next section, we'll give our generic
    components a try by implementing a new `ContactUs` component.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing our new ContactUs component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to implement a new `ContactUs` component using
    our `Form` and `Field` components:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by removing the props interface from `ContactUs.tsx`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The content within the `ContactUs` SFC will be very different to the original
    version. Let''s start by removing the content so that it looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s import our `Form` component into `ContactUs.tsx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now reference the `Form` component, passing some default values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add the `name` field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note we haven't passed the `type` prop because this will default to a text-based
    input, which is just what we require.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the `email`, `reason`, and `notes` fields now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ContactUsPage` is going to be much simpler now. It won''t contain any
    state because that is managed within the `Form` component now. We also don''t
    need to pass any props to the `ContactUs` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: If we go to the running app and go to the Contact Us page, it renders as required
    and accepts the values we enter.
  prefs: []
  type: TYPE_NORMAL
- en: Our generic form component is progressing nicely, and we have consumed it to
    implement the `ContactUs` component as we had hoped. In the next section, we are
    going to improve our generic component even further by adding validation.
  prefs: []
  type: TYPE_NORMAL
- en: Validating forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Including validation on a form improves the user experience, by giving them
    immediate feedback on whether the information entered is valid. In this section,
    we are going to add validation to our `Form` component and then consume it in
    our `ContactUs` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The validation rules we are going to implement in the `ContactUs` component
    are these:'
  prefs: []
  type: TYPE_NORMAL
- en: The name and email fields should be populated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name field should be at least two characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to execute validation rules when the field editor loses focus.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll add a prop to the `Form` component that allows consumers
    to specify validation rules.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a validation rules prop to form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s think about how we would want to specify validation rules to a form.
    We need to be able to specify one or more rules for a field. Some rules could
    have a parameter, such as a minimum length. It would be nice if we could specify
    the rules, as in the example that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s have a go at implementing the `validationRules` prop on the `Form` component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by defining a type for the `Validator` function in `Form.tsx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: A `Validator` function will take in the field name, the values for the whole
    form, and an optional argument specific to the function. A string containing the
    validation error message will be returned. If the field is valid, a blank string
    will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use this type to create a `Validator` function to check that a field
    called `required` under the `Validator` type is populated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We export the function so that it can be used in our `ContactUs` implementation
    later. The function checks whether the field value is `undefined`, `null`, or
    an empty string and if so, it returns a This must be populated validation error
    message.
  prefs: []
  type: TYPE_NORMAL
- en: If the field value isn't `undefined`, `null`, or an empty string, then an empty
    string is returned to indicate the value is valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, let''s create a `Validator` function for checking that a field input
    is over a minimum length:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The function checks whether the length of the field value is less than the length
    argument, and if so it returns a validation error message. Otherwise, an empty
    string is returned to indicate the value is valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add the ability to pass validation rules via a prop to the `Form`
    component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The `validationRules` prop is an indexable key/value type, where the key is
    the field name and the value is one or more validation rules of type `IValidation`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A validation rule contains the validation function of type `Validator`, and
    an argument to pass into the validation function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With the new `validationRules` prop in place, let''s add this to the `ContactUs`
    component. Import the validator functions first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add the validation rules to the `ContactUs` component JSX:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Now, our form is valid if the name and email are populated, and the name is
    at least two characters long.
  prefs: []
  type: TYPE_NORMAL
- en: That's the `validationRules` prop complete. In the next section, we'll track
    the validation error messages in preparation for rendering them on the page.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking validation error messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to track the validation error messages in state as the user completes
    the form and fields become valid or invalid. Later on, we'll be able to render
    the error messages to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Form` component is responsible for managing all the form states, so we''ll
    add the error message state to there, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the validation error message state to the form state interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The `errors` state is an indexable key/value type where the key is the field
    name and the value is an array of validation error messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s initialize the `errors` state in the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The `defaultValues` prop contains all the field names in its keys. We iterate
    through the `defaultValues` keys, setting the appropriate `errors` key to an empty
    array. As a result, when the `Form` component initializes, none of the fields
    contain any validation error messages, which is exactly what we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Field` component is eventually going to render the validation error messages,
    so we need to add these to the form context. Let''s start by adding these to the
    form context interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add an `errors` empty literal as the default value when the context
    is created. This is to keep the TypeScript compiler happy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now include the errors in the context value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Now, the validation errors are in the form state, and also in the form context
    for the `Field` component to access. In the next section, we'll create a method
    that is going to invoke the validation rules.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking validation rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we can define validation rules, and have state to track validation
    error messages, but nothing is invoking the rules yet. This is what we are going
    to implement in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create a method within the `Form` component that is going to validate
    a field, calling the specified validator function. Let''s create a method called
    `validate` that takes in the field name and its value. The method will return
    an array of validation error messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s get the validation rules for the field and initialize an `errors` array.
    We''ll collect all the errors in the `errors` array as the validators are executed.
    We''ll also return the array of `errors` after all the validators have been executed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The rules can be an `IValidation` array or just a single `IValidation`. Let''s
    check for this and call the `validator` function if we just have a single validation
    rule:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now deal with the branch of code for when there are multiple validation
    rules. We can use the `forEach` function on the rules array to iterate through
    the rules and execute the `validator` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The final bit of code we need to implement in the `validate` method is to set
    the new `errors` form state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: We spread the old errors state into a new object, and then add the new errors
    for the field.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Field` component needs to call into this `validate` method. We are going
    to add a reference to this method to the form context. Let''s add it to the `IFormContext`
    interface first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now add it to the context value in the `render` method in `Form`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Our form validation is coming along nicely, and we now have a method we can
    call to invoke all the rules for a field. However, this method isn't being called
    from anywhere yet as the user fills out the form. We'll do that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Triggering validation rule execution from field
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the user fills in the form, we want the validation rules to trigger when
    a field loses focus. We''ll implement this in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a function that is going to handle the `blur` event for all three
    of the different editors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The TypeScript blur event type is `FocusEvent<T>`, where `T` is the type of
    the element that is being handled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The handler's first parameter, `e`, is the React blur event handler parameter.
    We union all the different handler types for our different editors, so that we
    can handle all the blur events in a single function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The handler's second parameter is the form context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need a conditional statement to check that the `validate` method is not `undefined`,
    to keep the TypeScript compiler happy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can then call the `validate` method with the field name and new value we
    need to validate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can now reference this handler in the `Field` JSX for the text and email
    editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: We set the `onBlur` prop to a lamda expression that calls our `handleBlur` function,
    passing in the blur argument as well as the context value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s reference the handler in the other two editors now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Our field is now executing validation rules when it loses focus. There's one
    more task to do before we can give our Contact Us page a try, which we'll do in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering validation error messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to render the validation error messages in the
    `Field` component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s display all errors in a `span` with the `form-error` CSS class we have
    already implemented. We display these at the bottom of the `div` container of
    the `form-group`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: So, we first check that we have errors for the field name, and then use the
    `map` function in the `errors` array to render a `span` for each error.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have referenced a CSS `form-error` class, so let''s add this to `index.css`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s time to give the Contact Us page a try. If our app isn''t started, start
    it using `npm start` and go to the Contact Us page. If we tab through the name
    and email fields, the required validation rule triggers and error messages are
    displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5c1c0bd5-41d7-4dfe-a583-681a209e50fd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is just what we want. If we go back to the name field and try to enter
    just a single character before tabbing away, the minimum length validation error
    triggers, as we would expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/985e637e-04be-4016-ba1f-990898bada01.png)'
  prefs: []
  type: TYPE_IMG
- en: Our generic form component is nearly complete now. Our final task is to submit
    the form, which we'll do in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Form submission
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Submitting the form is the final part of the form implementation. The consumer
    of the `Form` component will handle the actual submission, which will probably
    result in a call to a web API. Our `Form` component will simply call a function
    in the consumer code when the form is submitted.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a submit button to the form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to add a submit button to our `Form` component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a submit button to the `Form` JSX, wrapped in a `div` container
    within `form-group`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Style the button with the following CSS in `index.css`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: We now have a black submit button on our form that is gray when disabled.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a onSubmit form prop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our `Form` component, we need a new prop that allows a consumer to specify
    the `submit` function to be called. We''ll do this in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a new prop function called `onSubmit` in the `Form`
    props interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The function will take in the field values and asynchronously return whether
    the submission was successful, with any validation errors that occurred on the
    server.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to track whether the form is being submitted or not in the `Form`
    state. We are also going to track whether the form has successfully been submitted
    in the `Form` state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s initialize those state values in the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now disable the submit button if the form is being submitted, or has
    successfully been submitted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s reference a submit handler in the `form` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now start to implement the submit handler we just referenced:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: We call `preventDefault` in the submit event argument to stop the browser automatically
    posting the form.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to make sure all the fields are valid before starting the form submission
    process. Let''s reference and create a `validateForm` function that does this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The `validateForm` function iterates through the fields, calling the `validate`
    function that has already been implemented. The state is updated with the latest
    validation errors, and we return whether there are any errors or not in any of
    the fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement the rest of the submit handler now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: If the form is valid, we start by setting the `submitting` state to `true`.
    We then call the `onSubmit` prop function asynchronously. When the `onSubmit`
    prop function has finished, we set any validation errors from the function in
    the state along with whether the submission was successful. We also set in the
    state the fact that the submission process has finished.
  prefs: []
  type: TYPE_NORMAL
- en: Now, our `Form` component has an `onSubmit` function prop. In the next section,
    we'll consume this in our Contact Us page.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming the onSubmit form prop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll consume the `onSubmit` form prop in the `ContactUs`
    component. The `ContactUs` component won''t manage the submission—it will simply
    delegate to the `ContactUsPage` component to handle the submission:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by importing `ISubmitResult` and `IValues`, and creating a props
    interface in the `ContactUs` component for the `onSubmit` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `handleSubmit` function that will invoke the `onSubmit` prop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The `onSubmit` prop is asynchronous, so we need to prefix our function with
    `async` and prefix the `onSubmit` call with `await`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bind this submit handler in the form `onSubmit` prop in the JSX:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s move on to the `ContactUsPage` component now. Let''s start by creating
    the submit handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: In practice, this will probably call a web API. In our example, we wait asynchronously
    for one second and return a validation error with the `email` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the `wait` function we just referenced:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s wire up the `handleSubmit` method to the `ContactUs` `onSubmit` prop
    now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'We have referenced `IValues` and `ISubmitResult`, so let''s import these:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'If we go to the Contact Us page in the running app, fill out the form, and
    click the Submit button, we are informed that there is a problem with the email
    field, as we would expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5f19c687-47c8-4ade-b729-bb59fccf669d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s change the submit handler in `ContactUsPage` to return a successful
    result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we go to the Contact Us page in the running app again, fill out the
    form, and click the Submit button, the submission goes through fine and the Submit
    button is disabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dc82f431-136d-484c-b5e2-c3b86a943fa8.png)'
  prefs: []
  type: TYPE_IMG
- en: So, that's our Contact Us page complete, together with our generic `Form` and
    `Field` components.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed controlled components, which are React's recommended
    method for handling form data entry. With controlled components, we let React
    control input values via component state.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at building generic `Form` and `Field` components containing state
    and change handlers, so that we don't need to implement individual state and change
    handlers for every field in every form in our apps.
  prefs: []
  type: TYPE_NORMAL
- en: We then created some standard validation functions, and added the ability to
    add validation rules within the generic `Form` component and render validation
    errors automatically in the `Field` component.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we added the ability to handle form submission when consuming the generic
    `Form` component. Our Contact Us page was changed to use the generic `Form` and
    `Field` components.
  prefs: []
  type: TYPE_NORMAL
- en: Our generic components only deal with very simple forms. Not surprisingly, there
    are a fair number of well-established form libraries already out in the wild.
    A popular choice is Formik, which is similar in some ways to what we have just
    built but much more powerful.
  prefs: []
  type: TYPE_NORMAL
- en: If you are building an app that contains lots of forms, it is well worth either
    building a generic form as we have just done or using an established library such
    as Formik to speed up the development process.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Check whether all that information about forms in React and TypeScript has
    stuck by trying the following implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: Extend our generic `Field` component to include a number editor, using the native
    number input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement an urgency field on the Contact Us form to indicate how urgent a response
    is. The field should be numeric.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a new validator function in the generic `Form` component, which validates
    whether a number falls between two other numbers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a validation rule on the urgency field to ensure the input is a number
    between 1 and 10.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our validation triggers when a user clicks in and out of a field without typing
    anything. How can we trigger validation when a field loses focus, but only when
    it has been changed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following links are good sources of further information on forms in React:'
  prefs: []
  type: TYPE_NORMAL
- en: There is a section in the React documentation on forms at [https://reactjs.org/docs/forms.html](https://reactjs.org/docs/forms.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Formik library is well worth looking into. This can be found at [https://github.com/jaredpalmer/formik](https://github.com/jaredpalmer/formik).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
