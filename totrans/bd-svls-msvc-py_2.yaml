- en: Creating Your First Serverless Data API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will build a complete serverless microservice, accessible
    via a REST API, and capable of querying a NoSQL database. We will start by discussing
    and creating the **Amazon Web Services** (**AWS**) security infrastructure to
    ensure restricted access to AWS resources. We will then create, add records to,
    and query a NoSQL database, first using the Management Console, then using Python.
    Then, we will go over the code used in the Lambda function in Python and API Gateway
    integration. Finally, we will deploy it and test that the API is working.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of security in AWS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing your serverless microservice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a serverless microservice data API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up Lambda security in the AWS management console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and writing to a NoSQL database called DynamoDB using AWS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and writing to a NoSQL database called DynamoDB using Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Lambda to query DynamoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up API Gateway and integrating it with a Lambda Proxy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting API Gateway, Lambda, and DynamoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cleaning-up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of security in AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start with a discussion on security and how to set it up correctly in
    AWS.
  prefs: []
  type: TYPE_NORMAL
- en: Why is security important?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might have heard of ransomware, cyber attacks, or security breaches recently
    and you would not want your organization to be affected by these. Some of these
    are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00e91e01-7fe9-43b6-ae6b-08fccf6ccd6a.png)'
  prefs: []
  type: TYPE_IMG
- en: Systems not being configured correctly, missing updates, or using insecure communication
    can lead to them being hacked or being subject to a ransomware demand. This can
    result in litigation costs, data loss or leaks, and financial costs to your organization.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many reasons for ensuring your systems are secure, including the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Compliance**: Compliance with the law, regulations, and standards, for example,
    the EU **General Data Protection Regulation** (**GDPR**), the **Health Information
    Portability and Accountability Act** (**HIPAA**), and the Federal Trade Commission
    Act.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data integrity**: If systems aren''t secure, data could be stripped or tampered
    with, meaning you can no longer trust the customer data or financial reporting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Personally Identifiable Information (PII)**: Consumers and clients are aware
    of your privacy policy. Data should be securely protected, anonymized, and deleted
    when no longer required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data availability**: Data is available to authorized users, but if, for example,
    a natural disaster occurred in your data center, what would happen in terms of
    accessing data?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A lot of security in AWS stems from configuration and having the correct architecture,
    so it''s important to understand the following subset of important security related
    terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security in transit:** For example, HTTPS SSL—think of it as the padlock
    on your browser'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security at rest:** For example, data encryption, where only a user with
    a key can read the data in a data store'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authentication**: For example, a process to confirm the user or system are
    who they are meant to be'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization:** For example, permissions and control mechanisms to access
    specific resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security by design principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many security standards, principles, certifications, and guidance—probably
    enough to fill a few books. Here is one that I found practical and useful, from
    the **Open Web Application Security Project** (**OWASP**) at [https://www.owasp.org](https://www.owasp.org).
    The OWASP security by design principles ([https://www.owasp.org/index.php/Security_by_Design_Principles](https://www.owasp.org/index.php/Security_by_Design_Principles))
    apply to any system, application, or service, helping to make them more secure
    by design, and that includes serverless computing. Even if there are no servers
    that need managing with serverless, you still need to ensure your architecture,
    integration, configuration, and code adhere to the following principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Minimize attack surface area**: Every added feature is a risk—ensure they
    are secure, for example, delete any Lambdas that are no longer being used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Establish secure defaults**: These have defaults for every user, Identity
    and Access Management policy, and serverless stack component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Principle of least privilege**: The account or service has the least amount
    of privilege required to perform its business processes, for example, if a Lambda
    only needs read access to a table, then it should have no more access than that.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Principle of defense in depth**: Have different validation layers and centralized
    audit controls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fail securely**: This ensures that if a request or transformation fails,
    it is still secure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Don''t trust services**: Especially third parties, external services, or
    libraries, for example, JavaScipt and Node.js libraries infected with malware.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Separation of duties**: Use a different role for a different task, for example,
    administrators should not be users or system users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoid security by obscurity**: This is generally a bad idea and a weak security
    control. Instead of relying on the architecture or source code being secret, instead
    rely on other factors, such as good architecture, limiting requests, and audit
    controls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keep security simple**: Don''t over-engineer; use simple architectures and
    design patterns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fix security issues correctly**: Fix issues promptly and add new tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep these principles in mind when building any serverless microservices.
  prefs: []
  type: TYPE_NORMAL
- en: AWS Identity and Access Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Identity and Access Management** (**IAM**), is a central location where you
    can manage users'' security credentials, such as passwords, access keys, and permission
    policies, that control access to the AWS services and resources. We are going
    to talk about the most relevant IAM resources—policies, users, groups, and roles—but
    first, we will talk about the JSON ([https://www.json.org/](https://www.json.org/))
    format as it is used in IAM policies.'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript object notation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JSON, or JavaScript object notation, is a standard data format that is used
    in REST APIs and microservices. It can be read by humans but also by machines.
    So, humans can actually understand the values and, also, machines can automatically
    parse the data. The data objects consist of attribute-value pairs and array data
    types. The data type values supported are number, string, Boolean, array, object,
    and null, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is an example of details related to John Smith. You can see
    the first name is the key and the string value is John. In that way, you have
    two strings separated by a colon. So, you see that John Smith is 27 years old
    and the city he lives in is New York, with the postal code 10021, and you can
    see that he has two phone numbers. One is his home phone number and the other
    one is a mobile phone number. JSON is very descriptive and can easily be parsed
    programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: You can see that it doesn't have to be flat either. It can also be hierarchical
    and has the keys built into the data. You can also very easily add new phone numbers
    to JSON data and extend the schema, without breaking the model, unlike other formats
    such as **comma-separated variable** (**CSV**) files. JSON is supported natively
    in the standard Python JSON library, but you can also use other libraries. What
    I like about it is that there is native mapping to Python data types.
  prefs: []
  type: TYPE_NORMAL
- en: IAM policies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**IAM policies** are JSON documents that define effects, actions, resources,
    and conditions, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is an example of a JSON document that will grant read access to a DynamoDB
    table called `Books` only if the request originates from a specific **Classless
    Inter-Domain Routing** (**CIDR**), `10.70.112.23/16`, that is, in **Internet Protocol
    address** (**IP address**) version 4 ranges from `10.70.0.0` to `10.70.255.255`.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a visual editor that allows you to create these, or you can do
    so manually by editing the actual JSON document itself. For example, we created
    a new user earlier in the book and gave them administrator rights using an AWS
    managed policy, but you can create your own, as shown. My recommendation is to
    use AWS managed policies when possible, unless it's a resource for which access
    can, or should, be more restricted, such as a DynamoDB table or an S3 bucket.
  prefs: []
  type: TYPE_NORMAL
- en: IAM users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IAM users are people or services that interact with AWS. We actually set up
    a new user in [Chapter 1](669eac03-68f5-4097-83fb-0f0ecce5ef42.xhtml), *Serverless
    Microservices Architectures and Patterns*. They can have access to the AWS Management
    Console via a password with multi-factor authentication, and/or they may have
    an access key for programmatic access using the command-line interface or the
    AWS **software development kits** (**SDKs**). You can attach one or more IAM policies
    directly to a user to grant them access to a resource or service. A policy could
    be like what we have just shown you, for granting read access to a DynamoDB table
    called `Books` from a specific originating IP range.
  prefs: []
  type: TYPE_NORMAL
- en: IAM groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IAM groups are used to mimic this security feature in your organization groups.
    You could think of it as active directory groups. For example, in your organization,
    you would have administrators, developers, and testers. To create a group, you
    can use the AWS Management Console, the SDK, or the CLI. Once you have created
    a group, you can attach it to a user or, alternatively, you can create one when
    you are creating a new user. I tend to attach IAM policies to a group, and then
    assign groups to users, as it makes it much easier to manage and standardizes
    access. For example, I can assign the data science group to new joiners of the
    team knowing that it's identical to the other users. Equally, if someone leaves,
    then their magical policies will not be deleted with them!
  prefs: []
  type: TYPE_NORMAL
- en: IAM roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IAM roles are similar to IAM users, in that they can have a policy attached
    to them but they can be assumed by anyone who needs access in a so-called trusted
    entity. In that way, you can delegate access to users, applications, or services,
    without having to give them a new AWS key, as they use temporary security tokens
    through this trusted entity. For example, without actually having to share any
    keys, and purely using the roles, you could grant a third party read access to
    an S3 bucket only and nothing else within your AWS environment.
  prefs: []
  type: TYPE_NORMAL
- en: Securing your serverless microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss security in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we discussed earlier, AWS Lambda is the central component in a serverless
    stack, or the integration connector with your custom code, triggered by events
    between AWS managed services. A Lambda function always has an execution IAM role
    associated with it, and using policies attached to that role is one of the best,
    and most secure, ways to deny or grant it access to other AWS resources. The beauty
    is that there is no need to manage or exchange any keys or passwords for a lot
    of the AWS managed services, such as S3, DynamoDB, and Kinesis Stream. There are
    some exceptions, such as some of the Amazon **Relational Database Service** (**RDS**),
    such as SQL Server, but MySQL or PostgreSQL do support IAM database authentication.
    The following diagram shows the workings of Lambda functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bbd8bc82-4ea4-4878-9ef8-e8ae994318d5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As the preceding diagram shows, there are generally two IAM roles involved
    in a Lambda function:'
  prefs: []
  type: TYPE_NORMAL
- en: Invoking the Lambda, for example, from API Gateway or AWS Step Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Granting read and write access to AWS resources, for example, granting a Lambda
    read access to to a DynamoDB table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition, note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Key Management Service** (**KMS**) can be used for the encryption/decryption
    of data at rest in DynamoDB or RDS, but also to encrypt passwords or keys, for
    example, should you need them to integrate with a third party API or database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lambda is launched in a secure **Virtual Private Cloud** (**VPC**) by default.
    However, you can also run it inside your own private VPC if there are resources
    you need to access, such as ElastiCache clusters or RDS. You may also do so to
    add another layer of security.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API Gateway security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s have a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe7bfbaa-7153-4c5e-a79b-54add185b401.png)'
  prefs: []
  type: TYPE_IMG
- en: 'API Gateway can be used to create a public-facing API without authentication,
    but sometimes you will want to restrict access. The following are are three different
    ways of controlling who can call the request authorization API:'
  prefs: []
  type: TYPE_NORMAL
- en: IAM roles and policies can be used to grant access to an API, where API Gateway
    verifies the caller's signature on the requests transparently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Amazon Cognito user pool controls who can access the API. The user or service
    will have to first sign in to access the API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API Gateway custom authorizers request, for example, a bearer token, and use
    a Lambda function to check whether the client is authorized to call the API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Within API Gateway, note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: If you get requests from a domain other than the API's own domain, you must
    enable **cross-origin resource sharing** (**CORS**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client-side SSL certificates are also supported, for example, to allow backend
    systems to validate that HTTP requests do originate from API Gateway and not another
    system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API Gateway may also need to be granted access via an IAM role, for example,
    should it need to write records to Kinesis Streams or invoke a Lambda function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage plans let you create API keys for customers, allowing you to limit and
    monitor usage. This could allow you to create a pay-per-usage API for your customers,
    for example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DynamoDB security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f62c398-0a4f-4f87-a86a-253dae0709e1.png)'
  prefs: []
  type: TYPE_IMG
- en: DynamoDB is an AWS-managed service and authorization is managed via an IAM permission
    policy. The IAM policy, which grants or deny access to DynamoDB, is attached to
    a specific IAM user or role, which can then access it. If you want to assume the
    role in one AWS account, we also have the option of delegating the permissions
    for the same, so that they can access a DynamoDB table in a different AWS account.
    The benefit in that scenario is that no keys are exchanged.
  prefs: []
  type: TYPE_NORMAL
- en: 'What I recommend is that you apply the **least privilege principle** when creating
    these policies for DynamoDB you lock them down as much as possible, which means
    avoiding the wildcard star for table access, such as using `"Resource": "*"`.
    For example, in the policy documents, avoid giving read and write access to all
    the tables unless absolutely necessary. It is better to list specific actions,
    table names, and constraints explicitly when possible.'
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring and alerting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now consider the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0964e92f-9c6d-4c88-bf77-d87cb52c79ed.png)'
  prefs: []
  type: TYPE_IMG
- en: In general, it's important to monitor systems for any suspicious activity, or
    even spot any performance issues with systems. API Gateway, DynamoDB, and Lambda
    functions all have built-in support for CloudWatch and X-Ray for that specific
    task. CloudWatch allows you to track metrics and monitor log files, set specific
    alarms, and automatically react to changes in your AWS resources. X-Ray is a service
    that traces requests and can also generate specific service maps. The combination
    of these free systems gives you very good insight, an out-of-the-box view, into
    how your serverless system is performing. CloudTrail is another service that allows
    you to monitor all APIs and access to resources by any user or system.
  prefs: []
  type: TYPE_NORMAL
- en: Find out more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will now have a much deeper understanding of security in AWS and why it's
    important for your organization.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to find out more, here are some links to white papers and best
    practice guides. I recommend reading the following white papers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://aws.amazon.com/whitepapers/aws-security-best-practices/](https://aws.amazon.com/whitepapers/aws-security-best-practices/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://aws.amazon.com/products/security/](https://aws.amazon.com/products/security/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://aws.amazon.com/whitepapers/#security](https://aws.amazon.com/whitepapers/#security)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html](http://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a serverless microservice data API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at the architecture and requirements of building
    a serverless microservice. The rest of the chapter is heavily hands-on in terms
    of configuration in the AWS Management Console, but also Python code. The Python
    code follows basic design patterns and is kept simple, so that you can understand
    and easily adapt it for your own use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Serverless microservice data API requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to create a microservice that is able to serve a web visits count, for
    a specific event, of the total users browsing your website.
  prefs: []
  type: TYPE_NORMAL
- en: Query string
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For a specific `EventId` passed into the request, we want to retrieve a daily
    web visits count (already collected by another system) as a response. We are going
    to be querying by `EventId` and `startDate`; where we want to retrieve all web
    visit counts after the `startDate`. The URL, with its parameter, will look as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4c4b9280-b78e-47d8-b8db-e39e8719e0be.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, you can see that we have `EventId` as resource `1234`, and a `startDate`
    parameter formatted in the `YYYYMMDD` format. In this case, it's `20180102`. That
    is the request.
  prefs: []
  type: TYPE_NORMAL
- en: We can either enter this request in the browser or programmatically, and the
    response that we want to get is from the NoSQL database, where the live data is
    stored. The actual response format will be in JSON coming back from the database,
    through a Lambda function, to be presented to either the user, or the other service
    that has queried the API programmatically. We also want this API to scale very
    easily and be very cost-effective; that is, we don't want to have a machine running
    all the time, for example, as that would cost money and need to be maintained.
    We only want to pay when actual requests are made.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b4c88d9-ce6b-4a8c-8629-57d0d64cb71e.png)'
  prefs: []
  type: TYPE_IMG
- en: Here is an example of the time-series data that we're interested in, where we
    have `EventId` that is for event `324`, and we have the date in the format `EventDay`,
    which is in October 2017, and we have a total `EventCount` of web events in the
    right-hand column in the table. You can see that on the October 10, 2017, `EventId`
    with `324` had an `EventCount` of `2`, which means there was a total daily count
    of visits equal to `2` on that specific day for that event. The next day it's
    `0`, as there is no entry for the 11^(th). Then, it increased to `10` on the 12^(th), `10`
    on the 13^(th), then it went down to `6`, `0`, `6`, and `2`. Note that when we
    have no data in the table for a specific date, then it's `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the data we want the API to provide as a response in JSON, so another
    client application can chart it, as shown in the following chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07f9fb37-d98e-4ace-a031-7efa48238f6c.png)'
  prefs: []
  type: TYPE_IMG
- en: For example, if we plot the data in Excel, you would see this sort of chart,
    with the `EventCount` beginning at `2`, with a gap on the October 11, where there
    was no visits for this specific user, then an increase to `10`, `10`, `6`, then
    a gap on October 15, then up to `6` again on October 16.
  prefs: []
  type: TYPE_NORMAL
- en: Data API architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know the requirements and shape of the data that we want to return,
    we will talk about the overall architecture. Again, the whole stack will rely
    on the JSON format for data exchange between all the services.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows what we have in the the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cef634e9-ee16-4fc5-8a30-5c96d42f4966.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The request flow is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We have a client browser, mobile client, or a backend service on the internet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That will query our API Gateway, passing the request with the `EventId` and
    the `startDate` as an optional URL parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will get authenticated through an AWS IAM role.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That will then launch the Lambda function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Lambda function will then use a role to access DynamoDB.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Lambda will query Dynamo to search for that specific `EventId`. Optionally,
    the query will also include a specific `startDate` that is compared with `EventDay`.
    If `EventDay` is greater than `startDate`, then the records will be returned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following diagram shows what we have in the the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b30dc9eb-1705-478f-b6ab-15b0fe98c5af.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The response flow is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The data will be returned from DynamoDB, as shown at the bottom-right of the
    preceding diagram
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will be via the same IAM role associated with the Lambda function
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The JSON records from DynamoDB are returned to the Lambda function, which parses
    it into a JSON response
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That will get passed via the API Gateway role by the Lambda function
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is passed back into API Gateway
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Eventually, it is returned to the client browser mobile client, or the backend
    service that made the initial request, so that it can be charted
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also have Amazon CloudWatch configured for monitoring requests, by providing
    dashboards for metrics and logs.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Lambda security in the AWS Management Console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be signing into the AWS Management Console. The reason we are using
    the Management Console first is to give you a better understanding of how Lambda
    functions work, and how they integrate with the other AWS services, such as API
    Gateway and DynamoDB. In later chapters, we will show you how to deploy Lambda
    functions using the AWS CLI. If you are a first-timer to Lambda, then I always
    find it useful to first create a full serverless stack manually in the Management
    Console to gain a better and deeper understanding than, say, have a magic command
    spin up the full AWS infrastructure!
  prefs: []
  type: TYPE_NORMAL
- en: We are going to first use the AWS Management Console to create the Lambda IAM
    role and policies, so that the Lambda function can access DynamoDB, and also write
    any logs or any statuses to CloudWatch. The Management Console, which we used
    earlier, in [Chapter 1](669eac03-68f5-4097-83fb-0f0ecce5ef42.xhtml), *Serverless
    Microservices Architectures and Patterns*, allows you to centrally control all
    of the AWS services, create roles, and even create Lambda functions. In terms
    of the architecture for the serverless microservice, we are starting with the
    right part of the following diagram first, and building the rest step by step.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the data API Lambda IAM:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6493077-a0e2-48a2-a383-c2f853329301.png)'
  prefs: []
  type: TYPE_IMG
- en: Create two IAM policies and attach them to a new Lambda IAM role next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an IAM policy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to create the Lambda function and the IAM role and policies. The
    first thing that you need to do is to log on to the AWS Management Console. In
    IAM, we want to create the actual policy itself. You can click on Create policies,
    and we are going to use the JSON editor.
  prefs: []
  type: TYPE_NORMAL
- en: DynamoDB IAM policy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we need a policy allowing the Lambda function to read records from DynamoDB.
    We can do so by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Sign into the AWS Management Console at [ht](https://console.aws.amazon.com/)[tps://console.aws.amazon.com/](https://console.aws.amazon.com/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Security, Identity & Compliance | IAM, or search for IAM under Find services.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the IAM navigation pane, choose Policies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Create policies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the JSON tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rather than using the **JSON** view, you can also use, or switch to, the **Visual
    Editor** for creating a policy, but I prefer the JSON view, as the code can be
    source-controlled and deployed programmatically as we'll do later with the AWS
    CLI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type, or paste, the following JSON policy document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Update `<your-region>` with your AWS region, such as `us-east-1`, and update
    `<your-aws-accountid>` with your AWS account ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do not know your AWS account number, you can find it in the Support
    Center window, available from the top Support | Support Center menu in the AWS
    Management Console, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/59d18745-a86a-4ee9-a819-735b77e5fc6d.png)'
  prefs: []
  type: TYPE_IMG
- en: Choose Review Policy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the Review Policy page, type `dynamo-readonly-user-visits` for the name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Create Policy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This IAM policy, called dynamo-readonly-user-visits, will now be available under
    the Filter policies as Customer managed.
  prefs: []
  type: TYPE_NORMAL
- en: We talked about security being very important, and one way to ensure it is to
    apply the OWASP security by design principles, such as the principle of least
    privilege, as talked about earlier. Here, we do that by locking down the table
    access using a policy. You'll notice that I've restricted it to a specific name,
    `dynamo` table. For the policy name, it should be as descriptive and granular
    as possible to make it easier to maintain. I tend to have one policy per AWS resource
    where possible. I've used prefix `dynamo-readonly` so that it is obvious that
    you will only get the ability to read from one specific table, called `user-visits`.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda IAM policy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a policy to be able to write logs and push metrics to CloudWatch:'
  prefs: []
  type: TYPE_NORMAL
- en: Sign in to the AWS Management Console and open the IAM console at [https://console.aws.amazon.com/iam/](https://console.aws.amazon.com/iam/),
    if you're not signed in already.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the IAM navigation pane, choose Policies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Create policies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the JSON tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type or copy and paste the following JSON document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The main idea of this policy is to allow the Lambda function to create CloudWatch
    log groups and streams, and to add the log events into those streams and then
    describe them. I've also added another statement that allows you to put metrics,
    which is required if you want to push custom monitor metrics.
  prefs: []
  type: TYPE_NORMAL
- en: Choose Review Policy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On Review Policy, type `lambda-cloud-write` for the name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Create Policy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating the Lambda IAM role
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have two IAM policies, we will create a new Lambda IAM role and
    attach those two policies to it:'
  prefs: []
  type: TYPE_NORMAL
- en: Sign in to the AWS Management Console and open the IAM console at [https://console.aws.amazon.com/iam/](https://console.aws.amazon.com/iam/)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the navigation pane, choose Roles
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Create Role
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select AWS service and, under that, select Lambda
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Choose Next: Permissions'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under Attach permissions policies | Filter polices, type `dynamo-readonly-user-visits-api`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the checkbox for dynamo-readonly-user-visits-api
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under Attach permissions policies | Filter polices, type `lambda-cloud-write`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the checkbox for lambda-cloud-write
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Next:Tags
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Next:Review
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the Review page, type `lambda-dynamo-data-api` for the Role name
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Create role
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have created two IAM policies and attached them to a new Lambda execution
    role, which we will later associate with the Lambda function.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and writing to a NoSQL database called DynamoDB using AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to look at creating a DynamoDB table, writing data to the table
    from hardcoded values, writing data records from a file, and then we are going
    to show two different ways to query a table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34519652-13e5-4efb-90b7-fed14b7f655a.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a DynamoDB in AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps show how to create a DynamoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: You need to sign in to the AWS Management Console first and then open the AWS
    DynamoDB console at [https://console.aws.amazon.com/dynamodb/](https://console.aws.amazon.com/dynamodb/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Create table or, in the DynamoDB navigation pane, choose Tables and choose
    Create table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Create DynamoDB Table window, perform the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under Table name, type `user-visits`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Primary key for Partition key, type `EventId` and choose String
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the Add sort key box
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Sort Key, type `EventDay` and choose Number
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The partition key and hash key can be used interchangeably, like sort key and
    range keys. A primary key can be the partition key alone, or a composite key with
    both a partition key and a sort key.
  prefs: []
  type: TYPE_NORMAL
- en: Writing data to DynamoDB using AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Sign in to the AWS Management Console and open the DynamoDB console at [https://console.aws.amazon.com/dynamodb/](https://console.aws.amazon.com/dynamodb/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the DynamoDB navigation pane, choose Tables and choose user-visits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the user-visits pane, choose the Items* tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Create Item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Create Item popup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under EventId String, type `324`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under EventDay Number, type `20171001`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose + > Append>Number, for field, type `EventCount`, and for Number, type
    `3`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Save
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will now see a new record has been added in the Items tab in the lower-right
    pane, as the scan has also been done automatically.
  prefs: []
  type: TYPE_NORMAL
- en: DynamoDB is a managed NoSQL database, which means that each row can have different
    columns, and the names of the columns, known as attributes, are case-sensitive.
  prefs: []
  type: TYPE_NORMAL
- en: Querying DynamoDB using AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two types of searches you can do on DynamoDB; `Scan` and `Query`.
    `Scan` retrieves all the records from a table. `Query` makes use of the primary
    key to efficiently retrieve a set of records. Both allow you to have optional
    consistency, pagination, filters, conditions, and to choose the attributes to
    be returned. Generally speaking, `Scan` is useful if you want to retrieve all
    of the data, or the data across many different primary keys, and `Query` should
    be used when you have a primary key and want to retrieve all, or a filtered version
    of, the associated records.
  prefs: []
  type: TYPE_NORMAL
- en: DynamoDB Scan in AWS Management Console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Sign in to the AWS Management Console and open the DynamoDB console at [https://console.aws.amazon.com/dynamodb/](https://console.aws.amazon.com/dynamodb/)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the DynamoDB navigation pane, choose Tables and choose user-visits
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the user-visits pane choose the Items* tab
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Scan from the dropdown
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optionally, choose +Add Filter to filter the query results
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Start Search
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should now see the results in a table in the lower-right pane, with the
    columns EventId, EventDay, and EventCount.
  prefs: []
  type: TYPE_NORMAL
- en: DynamoDB Query in AWS Management Console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Sign in to the AWS Management Console and open the DynamoDB console at [https://console.aws.amazon.com/dynamodb/](https://console.aws.amazon.com/dynamodb/)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the DynamoDB navigation pane, choose Tables and choose user-visits
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the user-visits pane, choose the Items* tab
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Query from the dropdown
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under Partition Key, type `324`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under Sort Key, select `>` and type `20171001`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Start Search
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will see that no results are returned, as we are looking for records with
    EventDay greater than `20171001` and there are none in the current table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the following to find the record:'
  prefs: []
  type: TYPE_NORMAL
- en: Under Sort Key, select `>=` and type `20171001`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Start Search
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will now see that the record we added is visible, as it meets the query
    search criterion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the following to find the record:'
  prefs: []
  type: TYPE_NORMAL
- en: Under Sort Key, select between and type `20170930` and `20171002`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Start Search
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we use the between condition to retrieve the records too.
  prefs: []
  type: TYPE_NORMAL
- en: This query flexibility gives you the ability to retrieve data at a very low
    latency. However, you will notice that the partition key for the condition expression
    is always fixed to `=`, and has to be provided to all `Query` operations—this
    is something common in many NoSQL databases. If you do not have, or know, the
    primary key, then you need to use `Scan` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting DynamoDB using AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s delete the table, as we are going to re-create it using Python. Perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Log on to the console at [https://console.aws.amazon.com/dynamodb/](https://console.aws.amazon.com/dynamodb/)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Tables from the left-hand DynamoDB menu
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose user-visits
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Delete table
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Delete
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating and writing to a NoSQL database called DynamoDB using Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we understand how to create a table, add data, and query DynamoDB using
    the AWS Console, we will look at how we can do this using only Python code.
  prefs: []
  type: TYPE_NORMAL
- en: We recommend you use a Python **Integrated development environment** (**IDE**)
    such as Eclipse PyDev ([http://www.pydev.org/download.html](http://www.pydev.org/download.html)) or
    PyCharm ([https://www.jetbrains.com/pycharm/](https://www.jetbrains.com/pycharm/)).
    You do not need to use an IDE, but I would recommend that you do. If you really
    want to, you can use VI, for example, on Linux to actually edit your code. But
    using an IDE allows you, for example, to run debugging or set up unit testing
    locally and step through it, which makes it easier and more productive for development.
  prefs: []
  type: TYPE_NORMAL
- en: First create the table using [Boto3 https://boto3.readthedocs.io/](https://boto3.readthedocs.io/)
    in Python. Run the code in the following section in PyCharm or your favorite text
    editor.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a DynamoDB table using Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is generic Python code to create a table. Create a Python script called
    `dynamo_table_creation.py` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Rather than creating a DynamoDB table in the AWS Console, here, we are creating
    it using the Python SDK Boto3\. `main()` calls the method called `create_dynamo_table()`,
    which takes various parameters associated with the table we are going to create, `table_name`
    being the first. Ignore the `enable_streams` parameter, which we will use later.
    The other two are linked to the initial read and write capacities. These will
    have a direct impact on the costs, along with the table size and the data retrieved.
    That is why I have set them to `1` by default. The region parameter should be
    your AWS region.
  prefs: []
  type: TYPE_NORMAL
- en: We then create a `boto3.client()`, which is a low-level client representing
    DynamoDB. We then use this to create a table using `client.create_table()`, passing
    in the parameters passed in to our `create_dynamo_table()`, along with the partition
    key name, `EventId`, with its data type, `String`, indicated by `S`, and sort
    key name, `EventDay`, with its data type number indicated as `N`. All other attributes
    will be optional and arbitrary.
  prefs: []
  type: TYPE_NORMAL
- en: You will notice a change in key terminology in DynamoDB between the Management
    Console and Boto3 descriptions, but they are synonyms: `Partition key (AWS Console)
    = Hash key (Boto3)` and `Sort key (AWS Console) = Range key (Boto3)`.
  prefs: []
  type: TYPE_NORMAL
- en: Both together, as a composite key, are called a primary key.
  prefs: []
  type: TYPE_NORMAL
- en: Writing to DynamoDB using Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code writes three records to DynamoDB. Create another file called
    `dynamo_modify_items.py` with the following Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use Boto3's `resource()`, which is a higher-level service resource
    with the repository pattern. We abstract all the DynamoDB-related code in the
    `DynamoRepository()` class that instantiates as `dynamo_repo` with `table_name`.
    `self.dynamodb.Table()` creates a table resource based on `table_name`. That will
    be used later on when calling `update_dynamo_event_counter()` to update DynamoDB
    records.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `self.table.update_item()`, I first declare a variable called `eventCount`
    using `ExpressionAttributeValues`. I''m using this in the DynamoDB advanced *Update
    Expressions* ([https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.UpdateExpressions.html](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.UpdateExpressions.html)),
    which is one of my favorite features in DynamoDB. Why? Because not all NoSQL databases
    can do something similar without having something like a semaphore lock and having
    the clients do a retry. It performs the following three actions in one atomic
    statement, while circumventing possible concurrency violations at the cost of
    eventual consistency:'
  prefs: []
  type: TYPE_NORMAL
- en: Reads records matching the given `EventId=event_name` and `EventDay=event_datetime`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creates a new item if it doesn't exist, setting `EventCount=1`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it does already exist, then it increments `EventCount` by `event_count`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first function calls `dynamo_repo.update_dynamo_event_counter('324', 20171001)`,
    sets `EventCount` to `1`; the second function call, `dynamo_repo.update_dynamo_event_counter('324',
    20171001, 2)`, increments `EventCount` by `2`, so that it's now `3`. The third
    function call adds a new record, as the `EventCount` or primary key, is different.
  prefs: []
  type: TYPE_NORMAL
- en: Querying DynamoDB using Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have created a table and added data, we just need to write some
    code to query it. This will form part of the code that will be used in the Lambda
    function later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Python script called `dynamo_query_table.py` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As I did earlier, I''ve created the `DynamoRepository` class, which abstracts
    all interactions with DynamoDB, including the connection and querying of tables.
    The following are the two methods used for querying the table using DynamoDB''s `self.table.query()`:'
  prefs: []
  type: TYPE_NORMAL
- en: The `query_dynamo_record_by_parition()` method, which queries for records by
    `partition_key`, also known as a hash key, which in this case is `EventId`. Here,
    we are using just the equality condition in the `query()`, shown as `KeyConditionExpression=Key(partition_key).eq(parition_value))`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `query_dynamo_record_by_parition_sort_key()` method, which queries for records
    by `partition_key` and `sort_key` , also known as a **range key**, which in this
    case is the `EventDate`. Here, we are using just the equality condition and the
    greater than or equal condition in the `query()` as `KeyConditionExpression=Key(partition_key).eq(partition_value)
    & Key(sort_key).gte(sort_value))`. This gives you the additional flexibility of
    quickly filtering by specific date ranges, for example, to retrieve the last 10
    days of event data to display in a dashboard.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then parse the returned records from the queries and print them to the console.
    This JSON will be what the Lambda will return to API Gateway as a response in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Lambda to query DynamoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the `security` and `user-visits` table set up with some data,
    and know how to write code to query that DynamoDB table, we will write the Lambda
    Python code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Lambda function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we have the IAM role with two IAM policies attached, create the Lambda
    function itself. Here, we are creating a function from scratch, as we want to
    walk through the full details to deepen your understanding of what is involved
    in creating a serverless stack. The following diagram shows data API architecture
    involving CloudWatch, DynamoDB, IAM, and Lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6fc69a46-c0c9-40a1-b40b-a7063ff759ce.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Sign in to the AWS Management Console and open the AWS Lambda console at [https://console.aws.amazon.com/lambda/](https://console.aws.amazon.com/lambda/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Create function or, in the AWS Lambda navigation pane, choose Functions
    and choose Create function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the Create function page, choose Author from scratch taking the following
    steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For Name, type `lambda-dynamo-data-api`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Runtime, choose Python 3.7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Role, leave Choose an existing role
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Existing Role, choose lambda-dynamo-data-api
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under the Function Code, a new file called `lambda_function.py` has been created.
    Copy and paste the following code under the lambda_function tab, overwriting the
    existing code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Choose Save.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A Lambda function always has a `handler` ([https://docs.aws.amazon.com/lambda/latest/dg/python-programming-model-handler-types.html](https://docs.aws.amazon.com/lambda/latest/dg/python-programming-model-handler-types.html))
    and the main idea `event` is passed in, which contains the event source data.
    Here, this will be an API Gateway GET request. The other parameter is the `context`
    ([https://docs.aws.amazon.com/lambda/latest/dg/python-context-object.html](https://docs.aws.amazon.com/lambda/latest/dg/python-context-object.html)),
    which gives you details such as memory or the time-to-live for the Lambda.
  prefs: []
  type: TYPE_NORMAL
- en: You will recognize `class DynamoRepository()` from the earlier example, which
    deals with connection and queries. The new `HttpUtils` class is a set of utility
    methods for parsing the query string and body, and returning a response. The other
    new `Controller()` class controls the main flow. Here, it assumes the API Gateway
    request is a `GET` method, so it call functions to parse the request, query DynamoDB,
    and return the response to API Gateway.
  prefs: []
  type: TYPE_NORMAL
- en: Exception flows are built defensively, so all exceptions are caught (generally,
    best practice is to only catch specific named exceptions and raise the rest) rather
    than raised. This is because we want the API to be able to return a 4XX or 5XX
    in the event of exceptions. For debugging purposes, we are returning the exception
    too. In a production environment, you would not return the exception, only log
    it, as it could expose vulnerabilities in the code. As an analogy, you might remember
    seeing those SQL Server errors with a source error and full stack trace in yellow
    on a white background, from a poorly secured web application in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'I recommend that you develop your Lambda code locally, but AWS has recently
    acquired an online IDE editor called Cloud9, which is where you have pasted the
    Python code, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eeeca884-2730-451c-8db5-05f0391eaee3.png)'
  prefs: []
  type: TYPE_IMG
- en: Testing the Lambda function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have the Lambda code deployed, we can test that it is working correctly
    in the AWS Management Console. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Sign in to the AWS Management Console and open the AWS Lambda console at [https://console.aws.amazon.com/lambda/](https://console.aws.amazon.com/lambda/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the AWS Lambda navigation pane, choose Functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose lambda-dynamo-data-api.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In Configure test event, under Event name, type `requestApiGatewayGetValid`
    and type or copy and paste the following code in the JSON document, overwriting
    the old code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are some important sections of the API Gateway `GET` request
    JSON:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The request uses the `GET` method from `"httpMethod": "GET"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The resource or `EventID` is `324` and comes from `"path": "/path/to/resource/324"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The query parameters come from `"queryStringParameters": { "StartDate": "20171009"}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose Create.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Test to run the test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see from the execution results that the test succeeded with the
    sample API Gateway `GET` request. This includes the duration, memory used, and
    log output. Expand the details to see the response that will be sent to DynamoDB.
    It should be something like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If there is an error, check the Log Output for details, it could be something
    to do with the IAM role/policy, DynamoDB name, or the Lambda code.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the API Gateway and integrating it with a Lambda proxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we know the Lambda function works with some API Gateway test data,
    and returns a header and body with a `statusCode` of `200`, we just need to add
    the API Gateway that will invoke the Lambda function, as shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc895bd8-4aa8-4a6a-b9f7-37649647eaf7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Sign in to the AWS Management Console and open the API Gateway console at [https://console.aws.amazon.com/apigateway/](https://console.aws.amazon.com/apigateway/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Get Started or, in the Amazon API Gateway navigation pane, choose APIs
    and choose Create API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the Create page, perform the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Choose Protocol, select REST
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Create new API, select New API
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under Settings, type `metrics` for API name
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose `Regional` for Endpoint Type
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Create API
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Create Resource from the Actions drop-down menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the New Child Resource window, perform the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Resource Name, type `visits`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Resource Path, type `visits`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Enable API Gateway CORS
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Create Resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `/visits` resource and choose Create Resource from the Actions drop-down
    menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the New Child Resource window, perform the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Resource Name, type `{resourceId}`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Resource Path, type `{resourceId}`, replacing the default `-resourceId-`
    value
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check Enable API Gateway CORS
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Create Resource
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `/Vists/{resourceId}` resource and choose Create Method from the
    Actions drop-down menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose GET in the dropdown and then the checkmark to its right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Choose the GET resource method in the /visits/{resourceId} - GET - Setup window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Integration type, choose Lambda Function
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check Use Lambda Proxy integration
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Lambda Region, select your region from the dropdown
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Lambda Function, type `lambda-dynamo-data-api`
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
- en: Check Use Default Timeout
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Save
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose OK in the Add Permission to Lambda Function. This will allow API Gateway
    to invoke the Lambda function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should now have an API Gateway GET - Method Execution that looks like the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43efcff4-4fa0-43dc-a33e-dcda75179f44.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally do a quick test to make sure it works before we deploy it by performing
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Choose `/visits/{resourceId} - GET` in the Resources menu on the left
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Test
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `324` under Path {resourceId}
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Test
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see the status 200, latency, logs, and JSON response body, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If you don't get a `2XX` status code, then look at the logs, which will help
    you diagnose the issue. It will probably be linked to security IAM roles.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting API Gateway, Lambda, and DynamoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we know the API Gateway integration with the Lambda function works,
    we will deploy it and get the URL. The architecture is shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/892f052b-4dd6-4c9d-8cfa-d45b93e60c14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The workings of this architecture is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Sign in to the AWS Management Console and open the API Gateway console at [https://console.aws.amazon.com/apigateway/](https://console.aws.amazon.com/apigateway/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Amazon API Gateway navigation pane, choose APIs and metrics.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Resources under metrics and `/Vists/{resourceId}`, and choose Deploy
    API from the Actions drop-down menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Deploy API pop-up window, perform the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Deployment stage, choose [New Stage]
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Stage name, type `prod`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Stage description, type `prod`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `Deploy`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Stages under metrics should be automatically selected on the left-hand menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select GET under `prod/visits/{resourceId}/GET` to get the invoke URL. The invoke
    URL should look like this: `https://{restapi_id}.execute-api.{region}.amazonaws.com/prod/visits/{resourceId}`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open a new browser tab and paste in the invoke URL: `https://{restapi_id}.execute-api.{region}.amazonaws.com/Prod/visits/{resourceId}`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The response body will be `{"message": "Internal server error"}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is because we validated `resource_id` in the URL `parse_parameters()` function
    before querying DynamoDB to make sure that it is a number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open a new browser tab and paste in the invoke URL: `https://{restapi_id}.execute-api.{region}.amazonaws.com/prod/visits/324`.
    As we have used the correct `resourceId` or `EventId` internally, you should see
    the following code in your browser tab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Open a new browser tab and paste in the invoke URL: `https://{restapi_id}.execute-api.{region}.amazonaws.com/Prod/visits/324?startDate=20171002`.
    As we have added the `startDate=20171002` parameter, you should see the following
    code in your browser tab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: That is using the other `query_by_partition_and_sort_key()` method in the Lambda
    with the `startDate`.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a fully working serverless data API, with the ability to run different
    types of queries on DynamoDB.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning-up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need to delete the resources manually. I recommend you use the AWS
    Console to do so. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Deleting API Gateway:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log on to the Console at [https://console.aws.amazon.com/apigateway/](https://console.aws.amazon.com/apigateway/)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Resource under metrics on the left-hand APIs menu
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Delete API from the Actions drop-down menu
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type metrics in the Enter the name of the API before confirming this action
    textbox
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Delete API
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Deleting the DynamoDB table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log on to the Console at [https://console.aws.amazon.com/dynamodb/](https://console.aws.amazon.com/dynamodb/)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Tables on the left-hand DynamoDB menu
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose user-visits
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Delete table
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Delete
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Deleting the Lambda function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log on to the Console at [https://console.aws.amazon.com/lambda/](https://console.aws.amazon.com/lambda/)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Functions on the left-hand AWS Lambda menu
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose lambda-dynamo-data-api
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Delete function under the Actions menu
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Delete
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Deleting the IAM role and policies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log on to the Console at [https://console.aws.amazon.com/iam/](https://console.aws.amazon.com/iam/)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Roles in the IAM navigation pane
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose lambda-dynamo-data-api
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Delete Role at the top-right
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Yes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Policies in the IAM navigation pane
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Customer Managed under Filter Policies
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the radio button next to dynamo-readonly-user-visits, and choose Delete
    under the Policy actions menu
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Delete in the popup
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the radio button next to lambda-cloud-write, and choose Delete under
    the Policy actions menu
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Delete in the popup
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have discussed security and why it is important. Applying
    the OWASP security by design principles is a good first step to ensure that your
    serverless stack is secure. We then discussed IAM roles and gave an overview of
    policies, explaining how they are the key documents to ensure restricted access
    to AWS resources. We then looked at an overview of some of the security concepts
    and principles regarding securing your serverless microservices, specifically
    regarding Lambda, API Gateway, and DynamoDB.
  prefs: []
  type: TYPE_NORMAL
- en: We then built a scalable serverless microservice with a RESTful data API. We
    started by creating a DynamoDB table, then added data to it, and queried it, first
    using the AWS console manually, then using the Python Boto3 SDK. We then built
    a simple Lambda to parse the request URL parameters, query DynamoDB, and return
    the records as part of a response body. We then looked at setting the integration
    between the Lambda and the API Gateway. We then connected everything together
    by deploying the API. We created a fully working API that is highly scalable,
    that you can tweak very easily for your own use cases, and that is very cost effective.
    In less than 30 minutes, you have created a highly scalable serverless microservice
    with an API. It is pay-per-usage for the API Gateway and the Lambda costs. For
    DynamoDB, you can actually change the read and write capacity very easily, set
    it to autoscale the read and write capacity based on the load, or even pay based
    on actual usage via the on-demand capacity mode, making it fully pay-per-API usage
    and data stored, avoiding traditional capacity planning or over-provisioning.
  prefs: []
  type: TYPE_NORMAL
- en: We have done a lot of work in the AWS Console, but in later chapters, we will
    be doing most of the work using the AWS CLI, or using code deployment pipelines.
    However, using the AWS Console should have given you a really good understanding
    of what you can do in AWS, and how Lambda integrates with DynamoDB and API Gateway.
    This solid foundation is really useful when we automate most of the creation and
    provisioning using configuration, scripts, and code. In the following chapters,
    we will be adding more functionality, automated testing, and deployment pipelines,
    and implementing microservice patterns.
  prefs: []
  type: TYPE_NORMAL
- en: In your organization, you will be developing a lot of source code and you won't
    want to deploy it manually, as we have done in this chapter. You will want to
    first test the code automatically to make sure it is working as expected, then
    you will deploy the stack in a repeatable fashion. This is needed for continuous
    integration or continuous delivery systems used in production.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to talk about how to deploy your serverless
    microservices using code and configuration to make the process more repeatable
    and scalable.
  prefs: []
  type: TYPE_NORMAL
