- en: Creating Your First Serverless Data API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的第一个无服务器数据API
- en: In this chapter, we will build a complete serverless microservice, accessible
    via a REST API, and capable of querying a NoSQL database. We will start by discussing
    and creating the **Amazon Web Services** (**AWS**) security infrastructure to
    ensure restricted access to AWS resources. We will then create, add records to,
    and query a NoSQL database, first using the Management Console, then using Python.
    Then, we will go over the code used in the Lambda function in Python and API Gateway
    integration. Finally, we will deploy it and test that the API is working.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个完整的无服务器微服务，通过REST API可访问，并能够查询NoSQL数据库。我们将首先讨论并创建**亚马逊网络服务**（**AWS**）安全基础设施，以确保对AWS资源的受限访问。然后，我们将使用管理控制台，然后使用Python创建、添加记录并查询NoSQL数据库。然后，我们将讨论Python中Lambda函数中使用的代码和API网关集成。最后，我们将部署它并测试API是否正常工作。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Overview of security in AWS
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS安全概述
- en: Securing your serverless microservice
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护您的无服务器微服务
- en: Building a serverless microservice data API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建无服务器微服务数据API
- en: Setting up Lambda security in the AWS management console
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在AWS管理控制台中设置Lambda安全
- en: Creating and writing to a NoSQL database called DynamoDB using AWS
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AWS创建和写入名为DynamoDB的NoSQL数据库
- en: Creating and writing to a NoSQL database called DynamoDB using Python
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python创建和写入名为DynamoDB的NoSQL数据库
- en: Creating a Lambda to query DynamoDB
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个用于查询DynamoDB的Lambda
- en: Setting up API Gateway and integrating it with a Lambda Proxy
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置API网关并将其与Lambda代理集成
- en: Connecting API Gateway, Lambda, and DynamoDB
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接API网关、Lambda和DynamoDB
- en: Cleaning-up
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理
- en: Overview of security in AWS
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS安全概述
- en: We will start with a discussion on security and how to set it up correctly in
    AWS.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从讨论安全性以及如何在AWS中正确设置它开始。
- en: Why is security important?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么安全性很重要？
- en: 'You might have heard of ransomware, cyber attacks, or security breaches recently
    and you would not want your organization to be affected by these. Some of these
    are shown as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能最近听说过勒索软件、网络攻击或安全漏洞，您不希望您的组织受到这些影响。以下是其中一些：
- en: '![](img/00e91e01-7fe9-43b6-ae6b-08fccf6ccd6a.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00e91e01-7fe9-43b6-ae6b-08fccf6ccd6a.png)'
- en: Systems not being configured correctly, missing updates, or using insecure communication
    can lead to them being hacked or being subject to a ransomware demand. This can
    result in litigation costs, data loss or leaks, and financial costs to your organization.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 系统配置不正确、缺少更新或使用不安全的通信可能导致系统被黑客攻击或遭受勒索软件要求。这可能导致诉讼费用、数据丢失或泄露以及对您的组织的财务成本。
- en: 'There are many reasons for ensuring your systems are secure, including the
    following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 确保系统安全的原因有很多，包括以下几点：
- en: '**Compliance**: Compliance with the law, regulations, and standards, for example,
    the EU **General Data Protection Regulation** (**GDPR**), the **Health Information
    Portability and Accountability Act** (**HIPAA**), and the Federal Trade Commission
    Act.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**合规性：**遵守法律、法规和标准，例如欧盟**通用数据保护条例**（**GDPR**）、**健康信息便携和责任法案**（**HIPAA**）和**联邦贸易委员会法案**。'
- en: '**Data integrity**: If systems aren''t secure, data could be stripped or tampered
    with, meaning you can no longer trust the customer data or financial reporting.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据完整性：如果系统不安全，数据可能会被剥离或篡改，这意味着您不能再信任客户数据或财务报告。
- en: '**Personally Identifiable Information (PII)**: Consumers and clients are aware
    of your privacy policy. Data should be securely protected, anonymized, and deleted
    when no longer required.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**个人可识别信息（PII）：**消费者和客户了解您的隐私政策。数据应该得到安全保护，在不再需要时进行匿名化和删除。'
- en: '**Data availability**: Data is available to authorized users, but if, for example,
    a natural disaster occurred in your data center, what would happen in terms of
    accessing data?'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据可用性：**数据对授权用户可用，但是，例如，如果您的数据中心发生自然灾害，那么在访问数据方面会发生什么？'
- en: 'A lot of security in AWS stems from configuration and having the correct architecture,
    so it''s important to understand the following subset of important security related
    terms:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: AWS中的许多安全性源于配置和正确的架构，因此了解以下重要安全相关术语的子集非常重要：
- en: '**Security in transit:** For example, HTTPS SSL—think of it as the padlock
    on your browser'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传输中的安全：**例如，HTTPS SSL——把它看作是浏览器上的挂锁'
- en: '**Security at rest:** For example, data encryption, where only a user with
    a key can read the data in a data store'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态安全：**例如，数据加密，只有拥有密钥的用户才能读取数据存储中的数据'
- en: '**Authentication**: For example, a process to confirm the user or system are
    who they are meant to be'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份验证：**例如，确认用户或系统是否是其应该是的过程'
- en: '**Authorization:** For example, permissions and control mechanisms to access
    specific resources'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权：**例如，访问特定资源的权限和控制机制'
- en: Security by design principles
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全设计原则
- en: 'There are many security standards, principles, certifications, and guidance—probably
    enough to fill a few books. Here is one that I found practical and useful, from
    the **Open Web Application Security Project** (**OWASP**) at [https://www.owasp.org](https://www.owasp.org).
    The OWASP security by design principles ([https://www.owasp.org/index.php/Security_by_Design_Principles](https://www.owasp.org/index.php/Security_by_Design_Principles))
    apply to any system, application, or service, helping to make them more secure
    by design, and that includes serverless computing. Even if there are no servers
    that need managing with serverless, you still need to ensure your architecture,
    integration, configuration, and code adhere to the following principles:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多安全标准、原则、认证和指导，可能足以填满几本书。以下是我发现实用和有用的一个，来自**开放式Web应用安全项目**（**OWASP**）[https://www.owasp.org](https://www.owasp.org)。
    OWASP安全设计原则([https://www.owasp.org/index.php/Security_by_Design_Principles](https://www.owasp.org/index.php/Security_by_Design_Principles))适用于任何系统、应用程序或服务，有助于通过设计使它们更加安全，包括无服务器计算。即使无需管理无服务器的服务器，您仍需要确保您的架构、集成、配置和代码遵循以下原则：
- en: '**Minimize attack surface area**: Every added feature is a risk—ensure they
    are secure, for example, delete any Lambdas that are no longer being used.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化攻击面积：每增加一个功能都是一个风险——确保它们是安全的，例如，删除不再使用的任何Lambda。
- en: '**Establish secure defaults**: These have defaults for every user, Identity
    and Access Management policy, and serverless stack component.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立安全默认值：这些默认值适用于每个用户、身份和访问管理策略和无服务器堆栈组件。
- en: '**Principle of least privilege**: The account or service has the least amount
    of privilege required to perform its business processes, for example, if a Lambda
    only needs read access to a table, then it should have no more access than that.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小特权原则：账户或服务具有执行其业务流程所需的最少特权，例如，如果一个Lambda只需要对表进行读取访问，则它不应该拥有更多的访问权限。
- en: '**Principle of defense in depth**: Have different validation layers and centralized
    audit controls.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深度防御原则：具有不同的验证层和集中审计控制。
- en: '**Fail securely**: This ensures that if a request or transformation fails,
    it is still secure.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全失败：这确保了如果请求或转换失败，它仍然是安全的。
- en: '**Don''t trust services**: Especially third parties, external services, or
    libraries, for example, JavaScipt and Node.js libraries infected with malware.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要相信服务：特别是第三方、外部服务或库，例如，感染恶意软件的JavaScript和Node.js库。
- en: '**Separation of duties**: Use a different role for a different task, for example,
    administrators should not be users or system users.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 职责分离：为不同的任务使用不同的角色，例如，管理员不应该是用户或系统用户。
- en: '**Avoid security by obscurity**: This is generally a bad idea and a weak security
    control. Instead of relying on the architecture or source code being secret, instead
    rely on other factors, such as good architecture, limiting requests, and audit
    controls.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免通过混淆来保护安全性：这通常是一个坏主意和一个薄弱的安全控制。与其依赖于架构或源代码是秘密，不如依赖于其他因素，如良好的架构、限制请求和审计控制。
- en: '**Keep security simple**: Don''t over-engineer; use simple architectures and
    design patterns.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持安全简单：不要过度设计；使用简单的架构和设计模式。
- en: '**Fix security issues correctly**: Fix issues promptly and add new tests.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确修复安全问题：及时修复问题并添加新的测试。
- en: Keep these principles in mind when building any serverless microservices.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建任何无服务器微服务时，请牢记这些原则。
- en: AWS Identity and Access Management
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS身份和访问管理
- en: '**Identity and Access Management** (**IAM**), is a central location where you
    can manage users'' security credentials, such as passwords, access keys, and permission
    policies, that control access to the AWS services and resources. We are going
    to talk about the most relevant IAM resources—policies, users, groups, and roles—but
    first, we will talk about the JSON ([https://www.json.org/](https://www.json.org/))
    format as it is used in IAM policies.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 身份和访问管理（IAM）是一个中心位置，您可以在其中管理用户的安全凭据，例如密码、访问密钥和权限策略，以控制对AWS服务和资源的访问。我们将讨论最相关的IAM资源——策略、用户、组和角色——但首先，我们将讨论IAM策略中使用的JSON（[https://www.json.org/](https://www.json.org/)）格式。
- en: JavaScript object notation
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript对象表示法
- en: 'JSON, or JavaScript object notation, is a standard data format that is used
    in REST APIs and microservices. It can be read by humans but also by machines.
    So, humans can actually understand the values and, also, machines can automatically
    parse the data. The data objects consist of attribute-value pairs and array data
    types. The data type values supported are number, string, Boolean, array, object,
    and null, as shown in the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: JSON，或JavaScript对象表示法，是在REST API和微服务中使用的标准数据格式。它可以被人类阅读，也可以被机器自动解析。数据对象由属性-值对和数组数据类型组成。支持的数据类型值包括数字、字符串、布尔值、数组、对象和null，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code is an example of details related to John Smith. You can see
    the first name is the key and the string value is John. In that way, you have
    two strings separated by a colon. So, you see that John Smith is 27 years old
    and the city he lives in is New York, with the postal code 10021, and you can
    see that he has two phone numbers. One is his home phone number and the other
    one is a mobile phone number. JSON is very descriptive and can easily be parsed
    programmatically.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是与John Smith相关的详细信息的示例。您可以看到名字是键，字符串值是John。这样，您有两个由冒号分隔的字符串。因此，您可以看到John
    Smith今年27岁，他居住的城市是纽约，邮政编码是10021，您可以看到他有两个电话号码。一个是他的家庭电话号码，另一个是移动电话号码。JSON非常描述性，可以很容易地以编程方式解析。
- en: You can see that it doesn't have to be flat either. It can also be hierarchical
    and has the keys built into the data. You can also very easily add new phone numbers
    to JSON data and extend the schema, without breaking the model, unlike other formats
    such as **comma-separated variable** (**CSV**) files. JSON is supported natively
    in the standard Python JSON library, but you can also use other libraries. What
    I like about it is that there is native mapping to Python data types.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到它也不必是扁平的。它也可以是分层的，并且键内置到数据中。您还可以很容易地向JSON数据添加新的电话号码并扩展模式，而不会破坏模型，不像其他格式，如逗号分隔变量（CSV）文件。JSON在标准Python
    JSON库中得到了本地支持，但您也可以使用其他库。我喜欢它的原因是它与Python数据类型有本地映射。
- en: IAM policies
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IAM策略
- en: '**IAM policies** are JSON documents that define effects, actions, resources,
    and conditions, as shown in the following code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: IAM策略是定义效果、操作、资源和条件的JSON文档，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is an example of a JSON document that will grant read access to a DynamoDB
    table called `Books` only if the request originates from a specific **Classless
    Inter-Domain Routing** (**CIDR**), `10.70.112.23/16`, that is, in **Internet Protocol
    address** (**IP address**) version 4 ranges from `10.70.0.0` to `10.70.255.255`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个JSON文档的示例，只有在请求来自特定的CIDR（无类域间路由选择）`10.70.112.23/16`时，才会授予对名为`Books`的DynamoDB表的读取访问权限，即在IP地址版本4范围内从`10.70.0.0`到`10.70.255.255`。
- en: There is also a visual editor that allows you to create these, or you can do
    so manually by editing the actual JSON document itself. For example, we created
    a new user earlier in the book and gave them administrator rights using an AWS
    managed policy, but you can create your own, as shown. My recommendation is to
    use AWS managed policies when possible, unless it's a resource for which access
    can, or should, be more restricted, such as a DynamoDB table or an S3 bucket.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个可视化编辑器，允许您创建这些，或者您可以通过编辑实际的JSON文档来手动创建。例如，我们在本书的前面创建了一个新用户，并使用AWS托管策略赋予了他们管理员权限，但您也可以像所示的那样创建自己的。我的建议是在可能的情况下使用AWS托管策略，除非是可以或应该更受限制的资源，比如DynamoDB表或S3存储桶。
- en: IAM users
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IAM用户
- en: IAM users are people or services that interact with AWS. We actually set up
    a new user in [Chapter 1](669eac03-68f5-4097-83fb-0f0ecce5ef42.xhtml), *Serverless
    Microservices Architectures and Patterns*. They can have access to the AWS Management
    Console via a password with multi-factor authentication, and/or they may have
    an access key for programmatic access using the command-line interface or the
    AWS **software development kits** (**SDKs**). You can attach one or more IAM policies
    directly to a user to grant them access to a resource or service. A policy could
    be like what we have just shown you, for granting read access to a DynamoDB table
    called `Books` from a specific originating IP range.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: IAM用户是与AWS交互的人或服务。我们实际上在[第1章](669eac03-68f5-4097-83fb-0f0ecce5ef42.xhtml)中设置了一个新用户，*无服务器微服务架构和模式*。他们可以通过多因素身份验证的密码访问AWS管理控制台，和/或者可以使用命令行界面或AWS
    **软件开发工具包**（**SDK**）进行编程访问。您可以直接向用户附加一个或多个IAM策略，以授予他们对资源或服务的访问权限。策略可以像我们刚刚向您展示的那样，用于授予特定来源IP范围对名为`Books`的DynamoDB表的读取访问权限。
- en: IAM groups
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IAM组
- en: IAM groups are used to mimic this security feature in your organization groups.
    You could think of it as active directory groups. For example, in your organization,
    you would have administrators, developers, and testers. To create a group, you
    can use the AWS Management Console, the SDK, or the CLI. Once you have created
    a group, you can attach it to a user or, alternatively, you can create one when
    you are creating a new user. I tend to attach IAM policies to a group, and then
    assign groups to users, as it makes it much easier to manage and standardizes
    access. For example, I can assign the data science group to new joiners of the
    team knowing that it's identical to the other users. Equally, if someone leaves,
    then their magical policies will not be deleted with them!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: IAM组用于在组织组中模仿此安全功能。您可以将其视为活动目录组。例如，在您的组织中，您将拥有管理员、开发人员和测试人员。要创建一个组，您可以使用AWS管理控制台、SDK或CLI。创建组后，您可以将其附加到用户，或者在创建新用户时也可以创建一个。我倾向于将IAM策略附加到组，然后将组分配给用户，因为这样更容易管理并标准化访问权限。例如，我可以将数据科学组分配给团队的新成员，知道它与其他用户相同。同样，如果有人离开，那么他们的神奇策略也不会随着他们被删除！
- en: IAM roles
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IAM角色
- en: IAM roles are similar to IAM users, in that they can have a policy attached
    to them but they can be assumed by anyone who needs access in a so-called trusted
    entity. In that way, you can delegate access to users, applications, or services,
    without having to give them a new AWS key, as they use temporary security tokens
    through this trusted entity. For example, without actually having to share any
    keys, and purely using the roles, you could grant a third party read access to
    an S3 bucket only and nothing else within your AWS environment.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: IAM角色类似于IAM用户，它们可以附加策略，但可以由需要在所谓的受信实体中获得访问权限的任何人承担。通过这种方式，您可以委托访问权限给用户、应用程序或服务，而无需给他们一个新的AWS密钥，因为他们通过这个受信实体使用临时安全令牌。例如，无需共享任何密钥，纯粹使用角色，您可以仅授予第三方对S3存储桶的读取访问权限，而不允许其访问AWS环境中的其他任何内容。
- en: Securing your serverless microservices
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护您的无服务器微服务
- en: In this section, we will discuss security in detail.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将详细讨论安全性。
- en: Lambda security
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda安全性
- en: 'As we discussed earlier, AWS Lambda is the central component in a serverless
    stack, or the integration connector with your custom code, triggered by events
    between AWS managed services. A Lambda function always has an execution IAM role
    associated with it, and using policies attached to that role is one of the best,
    and most secure, ways to deny or grant it access to other AWS resources. The beauty
    is that there is no need to manage or exchange any keys or passwords for a lot
    of the AWS managed services, such as S3, DynamoDB, and Kinesis Stream. There are
    some exceptions, such as some of the Amazon **Relational Database Service** (**RDS**),
    such as SQL Server, but MySQL or PostgreSQL do support IAM database authentication.
    The following diagram shows the workings of Lambda functions:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，AWS Lambda是无服务器堆栈中的核心组件，或者是与您的自定义代码集成连接器，由AWS托管服务之间的事件触发。Lambda函数始终与执行IAM角色相关联，并且使用附加到该角色的策略是拒绝或授予其访问其他AWS资源的最佳且最安全的方式之一。美妙的是，对于许多AWS托管服务，如S3、DynamoDB和Kinesis
    Stream，无需管理或交换任何密钥或密码。也有一些例外，比如一些Amazon **关系型数据库服务**（**RDS**），比如SQL Server，但MySQL或PostgreSQL支持IAM数据库身份验证。以下图显示了Lambda函数的工作原理：
- en: '![](img/bbd8bc82-4ea4-4878-9ef8-e8ae994318d5.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bbd8bc82-4ea4-4878-9ef8-e8ae994318d5.png)'
- en: 'As the preceding diagram shows, there are generally two IAM roles involved
    in a Lambda function:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，在Lambda函数中通常涉及两个IAM角色：
- en: Invoking the Lambda, for example, from API Gateway or AWS Step Functions
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用Lambda，例如，从API网关或AWS Step Functions
- en: Granting read and write access to AWS resources, for example, granting a Lambda
    read access to to a DynamoDB table
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授予对AWS资源的读取和写入访问权限，例如，授予Lambda对DynamoDB表的读取访问权限
- en: 'In addition, note the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意以下内容：
- en: '**Key Management Service** (**KMS**) can be used for the encryption/decryption
    of data at rest in DynamoDB or RDS, but also to encrypt passwords or keys, for
    example, should you need them to integrate with a third party API or database.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lambda is launched in a secure **Virtual Private Cloud** (**VPC**) by default.
    However, you can also run it inside your own private VPC if there are resources
    you need to access, such as ElastiCache clusters or RDS. You may also do so to
    add another layer of security.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API Gateway security
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s have a look at the following diagram:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe7bfbaa-7153-4c5e-a79b-54add185b401.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
- en: 'API Gateway can be used to create a public-facing API without authentication,
    but sometimes you will want to restrict access. The following are are three different
    ways of controlling who can call the request authorization API:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: IAM roles and policies can be used to grant access to an API, where API Gateway
    verifies the caller's signature on the requests transparently.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Amazon Cognito user pool controls who can access the API. The user or service
    will have to first sign in to access the API.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API Gateway custom authorizers request, for example, a bearer token, and use
    a Lambda function to check whether the client is authorized to call the API.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Within API Gateway, note the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: If you get requests from a domain other than the API's own domain, you must
    enable **cross-origin resource sharing** (**CORS**).
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client-side SSL certificates are also supported, for example, to allow backend
    systems to validate that HTTP requests do originate from API Gateway and not another
    system.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API Gateway may also need to be granted access via an IAM role, for example,
    should it need to write records to Kinesis Streams or invoke a Lambda function.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage plans let you create API keys for customers, allowing you to limit and
    monitor usage. This could allow you to create a pay-per-usage API for your customers,
    for example.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DynamoDB security
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s look at the following diagram:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f62c398-0a4f-4f87-a86a-253dae0709e1.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
- en: DynamoDB is an AWS-managed service and authorization is managed via an IAM permission
    policy. The IAM policy, which grants or deny access to DynamoDB, is attached to
    a specific IAM user or role, which can then access it. If you want to assume the
    role in one AWS account, we also have the option of delegating the permissions
    for the same, so that they can access a DynamoDB table in a different AWS account.
    The benefit in that scenario is that no keys are exchanged.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'What I recommend is that you apply the **least privilege principle** when creating
    these policies for DynamoDB you lock them down as much as possible, which means
    avoiding the wildcard star for table access, such as using `"Resource": "*"`.
    For example, in the policy documents, avoid giving read and write access to all
    the tables unless absolutely necessary. It is better to list specific actions,
    table names, and constraints explicitly when possible.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring and alerting
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now consider the following diagram:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0964e92f-9c6d-4c88-bf77-d87cb52c79ed.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
- en: In general, it's important to monitor systems for any suspicious activity, or
    even spot any performance issues with systems. API Gateway, DynamoDB, and Lambda
    functions all have built-in support for CloudWatch and X-Ray for that specific
    task. CloudWatch allows you to track metrics and monitor log files, set specific
    alarms, and automatically react to changes in your AWS resources. X-Ray is a service
    that traces requests and can also generate specific service maps. The combination
    of these free systems gives you very good insight, an out-of-the-box view, into
    how your serverless system is performing. CloudTrail is another service that allows
    you to monitor all APIs and access to resources by any user or system.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Find out more
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will now have a much deeper understanding of security in AWS and why it's
    important for your organization.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to find out more, here are some links to white papers and best
    practice guides. I recommend reading the following white papers:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[https://aws.amazon.com/whitepapers/aws-security-best-practices/](https://aws.amazon.com/whitepapers/aws-security-best-practices/)'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://aws.amazon.com/products/security/](https://aws.amazon.com/products/security/)'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://aws.amazon.com/whitepapers/#security](https://aws.amazon.com/whitepapers/#security)'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html](http://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html)'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a serverless microservice data API
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at the architecture and requirements of building
    a serverless microservice. The rest of the chapter is heavily hands-on in terms
    of configuration in the AWS Management Console, but also Python code. The Python
    code follows basic design patterns and is kept simple, so that you can understand
    and easily adapt it for your own use cases.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Serverless microservice data API requirements
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to create a microservice that is able to serve a web visits count, for
    a specific event, of the total users browsing your website.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Query string
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For a specific `EventId` passed into the request, we want to retrieve a daily
    web visits count (already collected by another system) as a response. We are going
    to be querying by `EventId` and `startDate`; where we want to retrieve all web
    visit counts after the `startDate`. The URL, with its parameter, will look as
    follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4c4b9280-b78e-47d8-b8db-e39e8719e0be.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
- en: Here, you can see that we have `EventId` as resource `1234`, and a `startDate`
    parameter formatted in the `YYYYMMDD` format. In this case, it's `20180102`. That
    is the request.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: We can either enter this request in the browser or programmatically, and the
    response that we want to get is from the NoSQL database, where the live data is
    stored. The actual response format will be in JSON coming back from the database,
    through a Lambda function, to be presented to either the user, or the other service
    that has queried the API programmatically. We also want this API to scale very
    easily and be very cost-effective; that is, we don't want to have a machine running
    all the time, for example, as that would cost money and need to be maintained.
    We only want to pay when actual requests are made.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the following diagram:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b4c88d9-ce6b-4a8c-8629-57d0d64cb71e.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
- en: Here is an example of the time-series data that we're interested in, where we
    have `EventId` that is for event `324`, and we have the date in the format `EventDay`,
    which is in October 2017, and we have a total `EventCount` of web events in the
    right-hand column in the table. You can see that on the October 10, 2017, `EventId`
    with `324` had an `EventCount` of `2`, which means there was a total daily count
    of visits equal to `2` on that specific day for that event. The next day it's
    `0`, as there is no entry for the 11^(th). Then, it increased to `10` on the 12^(th), `10`
    on the 13^(th), then it went down to `6`, `0`, `6`, and `2`. Note that when we
    have no data in the table for a specific date, then it's `0`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the data we want the API to provide as a response in JSON, so another
    client application can chart it, as shown in the following chart:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07f9fb37-d98e-4ace-a031-7efa48238f6c.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: For example, if we plot the data in Excel, you would see this sort of chart,
    with the `EventCount` beginning at `2`, with a gap on the October 11, where there
    was no visits for this specific user, then an increase to `10`, `10`, `6`, then
    a gap on October 15, then up to `6` again on October 16.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Data API architecture
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know the requirements and shape of the data that we want to return,
    we will talk about the overall architecture. Again, the whole stack will rely
    on the JSON format for data exchange between all the services.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows what we have in the the request:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cef634e9-ee16-4fc5-8a30-5c96d42f4966.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: 'The request flow is as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: We have a client browser, mobile client, or a backend service on the internet.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That will query our API Gateway, passing the request with the `EventId` and
    the `startDate` as an optional URL parameter.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will get authenticated through an AWS IAM role.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That will then launch the Lambda function.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Lambda function will then use a role to access DynamoDB.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Lambda will query Dynamo to search for that specific `EventId`. Optionally,
    the query will also include a specific `startDate` that is compared with `EventDay`.
    If `EventDay` is greater than `startDate`, then the records will be returned.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following diagram shows what we have in the the response:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b30dc9eb-1705-478f-b6ab-15b0fe98c5af.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: 'The response flow is as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: The data will be returned from DynamoDB, as shown at the bottom-right of the
    preceding diagram
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will be via the same IAM role associated with the Lambda function
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The JSON records from DynamoDB are returned to the Lambda function, which parses
    it into a JSON response
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That will get passed via the API Gateway role by the Lambda function
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is passed back into API Gateway
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Eventually, it is returned to the client browser mobile client, or the backend
    service that made the initial request, so that it can be charted
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also have Amazon CloudWatch configured for monitoring requests, by providing
    dashboards for metrics and logs.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Lambda security in the AWS Management Console
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be signing into the AWS Management Console. The reason we are using
    the Management Console first is to give you a better understanding of how Lambda
    functions work, and how they integrate with the other AWS services, such as API
    Gateway and DynamoDB. In later chapters, we will show you how to deploy Lambda
    functions using the AWS CLI. If you are a first-timer to Lambda, then I always
    find it useful to first create a full serverless stack manually in the Management
    Console to gain a better and deeper understanding than, say, have a magic command
    spin up the full AWS infrastructure!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: We are going to first use the AWS Management Console to create the Lambda IAM
    role and policies, so that the Lambda function can access DynamoDB, and also write
    any logs or any statuses to CloudWatch. The Management Console, which we used
    earlier, in [Chapter 1](669eac03-68f5-4097-83fb-0f0ecce5ef42.xhtml), *Serverless
    Microservices Architectures and Patterns*, allows you to centrally control all
    of the AWS services, create roles, and even create Lambda functions. In terms
    of the architecture for the serverless microservice, we are starting with the
    right part of the following diagram first, and building the rest step by step.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the data API Lambda IAM:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6493077-a0e2-48a2-a383-c2f853329301.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: Create two IAM policies and attach them to a new Lambda IAM role next.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Creating an IAM policy
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to create the Lambda function and the IAM role and policies. The
    first thing that you need to do is to log on to the AWS Management Console. In
    IAM, we want to create the actual policy itself. You can click on Create policies,
    and we are going to use the JSON editor.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: DynamoDB IAM policy
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we need a policy allowing the Lambda function to read records from DynamoDB.
    We can do so by doing the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Sign into the AWS Management Console at [ht](https://console.aws.amazon.com/)[tps://console.aws.amazon.com/](https://console.aws.amazon.com/).
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Security, Identity & Compliance | IAM, or search for IAM under Find services.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the IAM navigation pane, choose Policies.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Create policies.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the JSON tab.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rather than using the **JSON** view, you can also use, or switch to, the **Visual
    Editor** for creating a policy, but I prefer the JSON view, as the code can be
    source-controlled and deployed programmatically as we'll do later with the AWS
    CLI.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'Type, or paste, the following JSON policy document:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Update `<your-region>` with your AWS region, such as `us-east-1`, and update
    `<your-aws-accountid>` with your AWS account ID.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`<your-region>`为您的AWS区域，例如`us-east-1`，并将`<your-aws-accountid>`更新为您的AWS账户ID。
- en: 'If you do not know your AWS account number, you can find it in the Support
    Center window, available from the top Support | Support Center menu in the AWS
    Management Console, as shown in the following screenshot:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不知道您的AWS账号，您可以在AWS管理控制台顶部的Support | Support Center菜单中找到它，如下面的屏幕截图所示：
- en: '![](img/59d18745-a86a-4ee9-a819-735b77e5fc6d.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59d18745-a86a-4ee9-a819-735b77e5fc6d.png)'
- en: Choose Review Policy.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择Review Policy。
- en: On the Review Policy page, type `dynamo-readonly-user-visits` for the name.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Review Policy页面，为名称输入`dynamo-readonly-user-visits`。
- en: Choose Create Policy.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择创建策略。
- en: This IAM policy, called dynamo-readonly-user-visits, will now be available under
    the Filter policies as Customer managed.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个名为dynamo-readonly-user-visits的IAM策略现在将在筛选策略下作为客户管理的策略可用。
- en: We talked about security being very important, and one way to ensure it is to
    apply the OWASP security by design principles, such as the principle of least
    privilege, as talked about earlier. Here, we do that by locking down the table
    access using a policy. You'll notice that I've restricted it to a specific name,
    `dynamo` table. For the policy name, it should be as descriptive and granular
    as possible to make it easier to maintain. I tend to have one policy per AWS resource
    where possible. I've used prefix `dynamo-readonly` so that it is obvious that
    you will only get the ability to read from one specific table, called `user-visits`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们谈到了安全性非常重要，确保安全的一种方法是应用OWASP安全设计原则，比如之前谈到的最小特权原则。在这里，我们通过使用策略来限制表访问来实现这一点。您会注意到，我将其限制在一个特定的名称，`dynamo`表。对于策略名称，应尽可能描述和细化，以便更容易维护。我倾向于在可能的情况下为每个AWS资源使用一个策略。我使用前缀`dynamo-readonly`，这样就很明显，您只能从一个名为`user-visits`的特定表中读取。
- en: Lambda IAM policy
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda IAM策略
- en: 'Create a policy to be able to write logs and push metrics to CloudWatch:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个策略，以便能够将日志写入和推送指标到CloudWatch：
- en: Sign in to the AWS Management Console and open the IAM console at [https://console.aws.amazon.com/iam/](https://console.aws.amazon.com/iam/),
    if you're not signed in already.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录AWS管理控制台，并在[https://console.aws.amazon.com/iam/](https://console.aws.amazon.com/iam/)中打开IAM控制台，如果您尚未登录。
- en: In the IAM navigation pane, choose Policies.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在IAM导航窗格中，选择策略。
- en: Choose Create policies.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择创建策略。
- en: Choose the JSON tab.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择JSON选项卡。
- en: 'Type or copy and paste the following JSON document:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入或复制以下JSON文档：
- en: '[PRE3]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The main idea of this policy is to allow the Lambda function to create CloudWatch
    log groups and streams, and to add the log events into those streams and then
    describe them. I've also added another statement that allows you to put metrics,
    which is required if you want to push custom monitor metrics.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个策略的主要目的是允许Lambda函数创建CloudWatch日志组和流，并将日志事件添加到这些流中，然后描述它们。我还添加了另一个允许您放置指标的声明，如果您想要推送自定义监视指标，则需要这样做。
- en: Choose Review Policy.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择Review Policy。
- en: On Review Policy, type `lambda-cloud-write` for the name.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Review Policy中，为名称输入`lambda-cloud-write`。
- en: Choose Create Policy.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择创建策略。
- en: Creating the Lambda IAM role
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Lambda IAM角色
- en: 'Now that we have two IAM policies, we will create a new Lambda IAM role and
    attach those two policies to it:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了两个IAM策略，我们将创建一个新的Lambda IAM角色，并将这两个策略附加到它：
- en: Sign in to the AWS Management Console and open the IAM console at [https://console.aws.amazon.com/iam/](https://console.aws.amazon.com/iam/)
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录AWS管理控制台，并在[https://console.aws.amazon.com/iam/](https://console.aws.amazon.com/iam/)中打开IAM控制台
- en: In the navigation pane, choose Roles
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导航窗格中，选择角色
- en: Choose Create Role
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择创建角色
- en: Select AWS service and, under that, select Lambda
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择AWS服务，然后在下面选择Lambda
- en: 'Choose Next: Permissions'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择下一步：权限
- en: Under Attach permissions policies | Filter polices, type `dynamo-readonly-user-visits-api`
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在附加权限策略 | 筛选策略下，输入`dynamo-readonly-user-visits-api`
- en: Select the checkbox for dynamo-readonly-user-visits-api
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择复选框以选择dynamo-readonly-user-visits-api
- en: Under Attach permissions policies | Filter polices, type `lambda-cloud-write`
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在附加权限策略 | 筛选策略下，输入`lambda-cloud-write`
- en: Select the checkbox for lambda-cloud-write
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择lambda-cloud-write的复选框
- en: Choose Next:Tags
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择下一步：标签
- en: Choose Next:Review
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择下一步：审核
- en: On the Review page, type `lambda-dynamo-data-api` for the Role name
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Review页面，为角色名称输入`lambda-dynamo-data-api`
- en: Choose Create role
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择创建角色
- en: You have created two IAM policies and attached them to a new Lambda execution
    role, which we will later associate with the Lambda function.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 您已创建了两个IAM策略，并将它们附加到一个新的Lambda执行角色上，稍后我们将将其与Lambda函数关联。
- en: Creating and writing to a NoSQL database called DynamoDB using AWS
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AWS创建和写入名为DynamoDB的NoSQL数据库
- en: 'We are going to look at creating a DynamoDB table, writing data to the table
    from hardcoded values, writing data records from a file, and then we are going
    to show two different ways to query a table:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个DynamoDB表，从硬编码值向表中写入数据，从文件写入数据记录，然后我们将展示两种不同的查询表的方法：
- en: '![](img/34519652-13e5-4efb-90b7-fed14b7f655a.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/34519652-13e5-4efb-90b7-fed14b7f655a.png)'
- en: Creating a DynamoDB in AWS
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在AWS中创建DynamoDB
- en: 'The following steps show how to create a DynamoDB:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤显示如何创建DynamoDB：
- en: You need to sign in to the AWS Management Console first and then open the AWS
    DynamoDB console at [https://console.aws.amazon.com/dynamodb/](https://console.aws.amazon.com/dynamodb/).
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要先登录AWS管理控制台，然后在[https://console.aws.amazon.com/dynamodb/](https://console.aws.amazon.com/dynamodb/)中打开AWS
    DynamoDB控制台。
- en: Choose Create table or, in the DynamoDB navigation pane, choose Tables and choose
    Create table.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择创建表，或者在DynamoDB导航窗格中，选择表，然后选择创建表。
- en: 'In the Create DynamoDB Table window, perform the following steps:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建DynamoDB表窗口中，执行以下步骤：
- en: Under Table name, type `user-visits`
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在表名下，输入`user-visits`
- en: In Primary key for Partition key, type `EventId` and choose String
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Partition key的主键中，输入`EventId`并选择String
- en: Check the Add sort key box
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选添加排序键框
- en: In Sort Key, type `EventDay` and choose Number
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在排序键中，输入`EventDay`并选择Number
- en: The partition key and hash key can be used interchangeably, like sort key and
    range keys. A primary key can be the partition key alone, or a composite key with
    both a partition key and a sort key.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 分区键和哈希键可以互换使用，就像排序键和范围键一样。主键可以是仅分区键，也可以是具有分区键和排序键的复合键。
- en: Writing data to DynamoDB using AWS
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AWS将数据写入DynamoDB
- en: 'Perform the following steps:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Sign in to the AWS Management Console and open the DynamoDB console at [https://console.aws.amazon.com/dynamodb/](https://console.aws.amazon.com/dynamodb/).
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到AWS管理控制台，并在[https://console.aws.amazon.com/dynamodb/](https://console.aws.amazon.com/dynamodb/)中打开DynamoDB控制台。
- en: In the DynamoDB navigation pane, choose Tables and choose user-visits.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在DynamoDB导航窗格中，选择Tables并选择user-visits。
- en: On the user-visits pane, choose the Items* tab.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在user-visits窗格中，选择Items*选项卡。
- en: Choose Create Item.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择创建项目。
- en: 'In the Create Item popup:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建项目弹出窗口中：
- en: Under EventId String, type `324`
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在EventId String下，输入`324`
- en: Under EventDay Number, type `20171001`
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在EventDay Number下，输入`20171001`
- en: Choose + > Append>Number, for field, type `EventCount`, and for Number, type
    `3`
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择+ > 追加 > 数字，对于字段，输入`EventCount`，对于数字，输入`3`
- en: Choose Save
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择保存
- en: You will now see a new record has been added in the Items tab in the lower-right
    pane, as the scan has also been done automatically.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您会看到在右下窗格的Items选项卡中添加了一个新记录，因为扫描也已自动完成。
- en: DynamoDB is a managed NoSQL database, which means that each row can have different
    columns, and the names of the columns, known as attributes, are case-sensitive.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: DynamoDB是一个托管的NoSQL数据库，这意味着每行可以有不同的列，列的名称，即属性，是区分大小写的。
- en: Querying DynamoDB using AWS
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AWS查询DynamoDB
- en: There are two types of searches you can do on DynamoDB; `Scan` and `Query`.
    `Scan` retrieves all the records from a table. `Query` makes use of the primary
    key to efficiently retrieve a set of records. Both allow you to have optional
    consistency, pagination, filters, conditions, and to choose the attributes to
    be returned. Generally speaking, `Scan` is useful if you want to retrieve all
    of the data, or the data across many different primary keys, and `Query` should
    be used when you have a primary key and want to retrieve all, or a filtered version
    of, the associated records.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在DynamoDB上有两种类型的搜索；`Scan`和`Query`。`Scan`从表中检索所有记录。`Query`利用主键有效地检索一组记录。两者都允许您具有可选的一致性、分页、过滤器、条件，并选择要返回的属性。一般来说，`Scan`适用于检索所有数据或跨许多不同主键的数据，而`Query`应该在您有主键并且想要检索所有或经过筛选的相关记录时使用。
- en: DynamoDB Scan in AWS Management Console
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在AWS管理控制台中的DynamoDB扫描
- en: 'Perform the following steps:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Sign in to the AWS Management Console and open the DynamoDB console at [https://console.aws.amazon.com/dynamodb/](https://console.aws.amazon.com/dynamodb/)
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到AWS管理控制台，并在[https://console.aws.amazon.com/dynamodb/](https://console.aws.amazon.com/dynamodb/)中打开DynamoDB控制台。
- en: In the DynamoDB navigation pane, choose Tables and choose user-visits
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在DynamoDB导航窗格中，选择Tables并选择user-visits
- en: On the user-visits pane choose the Items* tab
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在user-visits窗格中选择Items*选项卡
- en: Select Scan from the dropdown
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉菜单中选择Scan
- en: Optionally, choose +Add Filter to filter the query results
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选择+Add Filter以过滤查询结果
- en: Select Start Search
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择开始搜索
- en: You should now see the results in a table in the lower-right pane, with the
    columns EventId, EventDay, and EventCount.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该在右下窗格的表中看到结果，其中包含EventId、EventDay和EventCount列。
- en: DynamoDB Query in AWS Management Console
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在AWS管理控制台中的DynamoDB查询
- en: 'Perform the following steps:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Sign in to the AWS Management Console and open the DynamoDB console at [https://console.aws.amazon.com/dynamodb/](https://console.aws.amazon.com/dynamodb/)
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到AWS管理控制台，并在[https://console.aws.amazon.com/dynamodb/](https://console.aws.amazon.com/dynamodb/)中打开DynamoDB控制台。
- en: In the DynamoDB navigation pane, choose Tables and choose user-visits
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在DynamoDB导航窗格中，选择Tables并选择user-visits
- en: On the user-visits pane, choose the Items* tab
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在user-visits窗格中，选择Items*选项卡
- en: Select Query from the dropdown
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉菜单中选择查询
- en: Under Partition Key, type `324`
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在分区键下，输入`324`
- en: Under Sort Key, select `>` and type `20171001`
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Sort Key下，选择`>`并输入`20171001`
- en: Select Start Search
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择开始搜索
- en: You will see that no results are returned, as we are looking for records with
    EventDay greater than `20171001` and there are none in the current table.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到没有返回结果，因为我们正在寻找EventDay大于`20171001`的记录，而当前表中没有这样的记录。
- en: 'Modify the following to find the record:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 修改以下内容以查找记录：
- en: Under Sort Key, select `>=` and type `20171001`
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Sort Key下，选择`>=`并输入`20171001`
- en: Select Start Search
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择开始搜索
- en: You will now see that the record we added is visible, as it meets the query
    search criterion.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您会看到我们添加的记录可见，因为它符合查询搜索条件。
- en: 'Modify the following to find the record:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 修改以下内容以查找记录：
- en: Under Sort Key, select between and type `20170930` and `20171002`
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Sort Key下，选择between并输入`20170930`和`20171002`
- en: Select Start Search
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择开始搜索
- en: Here, we use the between condition to retrieve the records too.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用between条件来检索记录。
- en: This query flexibility gives you the ability to retrieve data at a very low
    latency. However, you will notice that the partition key for the condition expression
    is always fixed to `=`, and has to be provided to all `Query` operations—this
    is something common in many NoSQL databases. If you do not have, or know, the
    primary key, then you need to use `Scan` instead.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这种查询灵活性使您能够以非常低的延迟检索数据。但是，您会注意到条件表达式的分区键始终固定为`=`,并且必须提供给所有`Query`操作-这在许多NoSQL数据库中很常见。如果您没有或不知道主键，那么您需要使用`Scan`。
- en: Deleting DynamoDB using AWS
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AWS删除DynamoDB
- en: 'Let''s delete the table, as we are going to re-create it using Python. Perform
    the following steps:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们删除表，因为我们将使用Python重新创建它。执行以下步骤：
- en: Log on to the console at [https://console.aws.amazon.com/dynamodb/](https://console.aws.amazon.com/dynamodb/)
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到[https://console.aws.amazon.com/dynamodb/](https://console.aws.amazon.com/dynamodb/)控制台
- en: Choose Tables from the left-hand DynamoDB menu
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左侧DynamoDB菜单中选择Tables
- en: Choose user-visits
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择user-visits
- en: Choose Delete table
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择删除表
- en: Choose Delete
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择删除
- en: Creating and writing to a NoSQL database called DynamoDB using Python
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we understand how to create a table, add data, and query DynamoDB using
    the AWS Console, we will look at how we can do this using only Python code.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: We recommend you use a Python **Integrated development environment** (**IDE**)
    such as Eclipse PyDev ([http://www.pydev.org/download.html](http://www.pydev.org/download.html)) or
    PyCharm ([https://www.jetbrains.com/pycharm/](https://www.jetbrains.com/pycharm/)).
    You do not need to use an IDE, but I would recommend that you do. If you really
    want to, you can use VI, for example, on Linux to actually edit your code. But
    using an IDE allows you, for example, to run debugging or set up unit testing
    locally and step through it, which makes it easier and more productive for development.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: First create the table using [Boto3 https://boto3.readthedocs.io/](https://boto3.readthedocs.io/)
    in Python. Run the code in the following section in PyCharm or your favorite text
    editor.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Creating a DynamoDB table using Python
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is generic Python code to create a table. Create a Python script called
    `dynamo_table_creation.py` with the following code:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Rather than creating a DynamoDB table in the AWS Console, here, we are creating
    it using the Python SDK Boto3\. `main()` calls the method called `create_dynamo_table()`,
    which takes various parameters associated with the table we are going to create, `table_name`
    being the first. Ignore the `enable_streams` parameter, which we will use later.
    The other two are linked to the initial read and write capacities. These will
    have a direct impact on the costs, along with the table size and the data retrieved.
    That is why I have set them to `1` by default. The region parameter should be
    your AWS region.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: We then create a `boto3.client()`, which is a low-level client representing
    DynamoDB. We then use this to create a table using `client.create_table()`, passing
    in the parameters passed in to our `create_dynamo_table()`, along with the partition
    key name, `EventId`, with its data type, `String`, indicated by `S`, and sort
    key name, `EventDay`, with its data type number indicated as `N`. All other attributes
    will be optional and arbitrary.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: You will notice a change in key terminology in DynamoDB between the Management
    Console and Boto3 descriptions, but they are synonyms: `Partition key (AWS Console)
    = Hash key (Boto3)` and `Sort key (AWS Console) = Range key (Boto3)`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Both together, as a composite key, are called a primary key.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Writing to DynamoDB using Python
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code writes three records to DynamoDB. Create another file called
    `dynamo_modify_items.py` with the following Python code:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we use Boto3's `resource()`, which is a higher-level service resource
    with the repository pattern. We abstract all the DynamoDB-related code in the
    `DynamoRepository()` class that instantiates as `dynamo_repo` with `table_name`.
    `self.dynamodb.Table()` creates a table resource based on `table_name`. That will
    be used later on when calling `update_dynamo_event_counter()` to update DynamoDB
    records.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'In `self.table.update_item()`, I first declare a variable called `eventCount`
    using `ExpressionAttributeValues`. I''m using this in the DynamoDB advanced *Update
    Expressions* ([https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.UpdateExpressions.html](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.UpdateExpressions.html)),
    which is one of my favorite features in DynamoDB. Why? Because not all NoSQL databases
    can do something similar without having something like a semaphore lock and having
    the clients do a retry. It performs the following three actions in one atomic
    statement, while circumventing possible concurrency violations at the cost of
    eventual consistency:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Reads records matching the given `EventId=event_name` and `EventDay=event_datetime`
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creates a new item if it doesn't exist, setting `EventCount=1`
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it does already exist, then it increments `EventCount` by `event_count`
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first function calls `dynamo_repo.update_dynamo_event_counter('324', 20171001)`,
    sets `EventCount` to `1`; the second function call, `dynamo_repo.update_dynamo_event_counter('324',
    20171001, 2)`, increments `EventCount` by `2`, so that it's now `3`. The third
    function call adds a new record, as the `EventCount` or primary key, is different.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Querying DynamoDB using Python
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have created a table and added data, we just need to write some
    code to query it. This will form part of the code that will be used in the Lambda
    function later on.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Python script called `dynamo_query_table.py` with the following code:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As I did earlier, I''ve created the `DynamoRepository` class, which abstracts
    all interactions with DynamoDB, including the connection and querying of tables.
    The following are the two methods used for querying the table using DynamoDB''s `self.table.query()`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: The `query_dynamo_record_by_parition()` method, which queries for records by
    `partition_key`, also known as a hash key, which in this case is `EventId`. Here,
    we are using just the equality condition in the `query()`, shown as `KeyConditionExpression=Key(partition_key).eq(parition_value))`.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `query_dynamo_record_by_parition_sort_key()` method, which queries for records
    by `partition_key` and `sort_key` , also known as a **range key**, which in this
    case is the `EventDate`. Here, we are using just the equality condition and the
    greater than or equal condition in the `query()` as `KeyConditionExpression=Key(partition_key).eq(partition_value)
    & Key(sort_key).gte(sort_value))`. This gives you the additional flexibility of
    quickly filtering by specific date ranges, for example, to retrieve the last 10
    days of event data to display in a dashboard.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then parse the returned records from the queries and print them to the console.
    This JSON will be what the Lambda will return to API Gateway as a response in
    the next section.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Lambda to query DynamoDB
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the `security` and `user-visits` table set up with some data,
    and know how to write code to query that DynamoDB table, we will write the Lambda
    Python code.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Lambda function
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we have the IAM role with two IAM policies attached, create the Lambda
    function itself. Here, we are creating a function from scratch, as we want to
    walk through the full details to deepen your understanding of what is involved
    in creating a serverless stack. The following diagram shows data API architecture
    involving CloudWatch, DynamoDB, IAM, and Lambda:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6fc69a46-c0c9-40a1-b40b-a7063ff759ce.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
- en: 'Perform the following steps:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Sign in to the AWS Management Console and open the AWS Lambda console at [https://console.aws.amazon.com/lambda/](https://console.aws.amazon.com/lambda/).
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Create function or, in the AWS Lambda navigation pane, choose Functions
    and choose Create function.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the Create function page, choose Author from scratch taking the following
    steps:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For Name, type `lambda-dynamo-data-api`
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Runtime, choose Python 3.7
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Role, leave Choose an existing role
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Existing Role, choose lambda-dynamo-data-api
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under the Function Code, a new file called `lambda_function.py` has been created.
    Copy and paste the following code under the lambda_function tab, overwriting the
    existing code:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Choose Save.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A Lambda function always has a `handler` ([https://docs.aws.amazon.com/lambda/latest/dg/python-programming-model-handler-types.html](https://docs.aws.amazon.com/lambda/latest/dg/python-programming-model-handler-types.html))
    and the main idea `event` is passed in, which contains the event source data.
    Here, this will be an API Gateway GET request. The other parameter is the `context`
    ([https://docs.aws.amazon.com/lambda/latest/dg/python-context-object.html](https://docs.aws.amazon.com/lambda/latest/dg/python-context-object.html)),
    which gives you details such as memory or the time-to-live for the Lambda.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: You will recognize `class DynamoRepository()` from the earlier example, which
    deals with connection and queries. The new `HttpUtils` class is a set of utility
    methods for parsing the query string and body, and returning a response. The other
    new `Controller()` class controls the main flow. Here, it assumes the API Gateway
    request is a `GET` method, so it call functions to parse the request, query DynamoDB,
    and return the response to API Gateway.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Exception flows are built defensively, so all exceptions are caught (generally,
    best practice is to only catch specific named exceptions and raise the rest) rather
    than raised. This is because we want the API to be able to return a 4XX or 5XX
    in the event of exceptions. For debugging purposes, we are returning the exception
    too. In a production environment, you would not return the exception, only log
    it, as it could expose vulnerabilities in the code. As an analogy, you might remember
    seeing those SQL Server errors with a source error and full stack trace in yellow
    on a white background, from a poorly secured web application in your browser.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'I recommend that you develop your Lambda code locally, but AWS has recently
    acquired an online IDE editor called Cloud9, which is where you have pasted the
    Python code, as shown in the following screenshot:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eeeca884-2730-451c-8db5-05f0391eaee3.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
- en: Testing the Lambda function
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have the Lambda code deployed, we can test that it is working correctly
    in the AWS Management Console. Perform the following steps:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Sign in to the AWS Management Console and open the AWS Lambda console at [https://console.aws.amazon.com/lambda/](https://console.aws.amazon.com/lambda/).
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the AWS Lambda navigation pane, choose Functions.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose lambda-dynamo-data-api.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Test.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In Configure test event, under Event name, type `requestApiGatewayGetValid`
    and type or copy and paste the following code in the JSON document, overwriting
    the old code:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following are some important sections of the API Gateway `GET` request
    JSON:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The request uses the `GET` method from `"httpMethod": "GET"`'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The resource or `EventID` is `324` and comes from `"path": "/path/to/resource/324"`'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The query parameters come from `"queryStringParameters": { "StartDate": "20171009"}`'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose Create.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Test to run the test.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see from the execution results that the test succeeded with the
    sample API Gateway `GET` request. This includes the duration, memory used, and
    log output. Expand the details to see the response that will be sent to DynamoDB.
    It should be something like the following code:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If there is an error, check the Log Output for details, it could be something
    to do with the IAM role/policy, DynamoDB name, or the Lambda code.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the API Gateway and integrating it with a Lambda proxy
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we know the Lambda function works with some API Gateway test data,
    and returns a header and body with a `statusCode` of `200`, we just need to add
    the API Gateway that will invoke the Lambda function, as shown in the following
    diagram:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc895bd8-4aa8-4a6a-b9f7-37649647eaf7.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
- en: 'Perform the following steps:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Sign in to the AWS Management Console and open the API Gateway console at [https://console.aws.amazon.com/apigateway/](https://console.aws.amazon.com/apigateway/).
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Get Started or, in the Amazon API Gateway navigation pane, choose APIs
    and choose Create API.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the Create page, perform the following steps:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Choose Protocol, select REST
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Create new API, select New API
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under Settings, type `metrics` for API name
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose `Regional` for Endpoint Type
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Create API
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Create Resource from the Actions drop-down menu.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the New Child Resource window, perform the following steps:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Resource Name, type `visits`
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Resource Path, type `visits`
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Enable API Gateway CORS
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Create Resource.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `/visits` resource and choose Create Resource from the Actions drop-down
    menu.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the New Child Resource window, perform the following steps:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Resource Name, type `{resourceId}`
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Resource Path, type `{resourceId}`, replacing the default `-resourceId-`
    value
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check Enable API Gateway CORS
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Create Resource
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `/Vists/{resourceId}` resource and choose Create Method from the
    Actions drop-down menu.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose GET in the dropdown and then the checkmark to its right.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Choose the GET resource method in the /visits/{resourceId} - GET - Setup window:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Integration type, choose Lambda Function
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check Use Lambda Proxy integration
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Lambda Region, select your region from the dropdown
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Lambda Function, type `lambda-dynamo-data-api`
  id: totrans-348
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
- en: Check Use Default Timeout
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Save
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose OK in the Add Permission to Lambda Function. This will allow API Gateway
    to invoke the Lambda function.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should now have an API Gateway GET - Method Execution that looks like the
    following screenshot:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43efcff4-4fa0-43dc-a33e-dcda75179f44.png)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
- en: 'Finally do a quick test to make sure it works before we deploy it by performing
    the following steps:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: Choose `/visits/{resourceId} - GET` in the Resources menu on the left
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Test
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `324` under Path {resourceId}
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Test
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see the status 200, latency, logs, and JSON response body, as shown
    in the following code:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you don't get a `2XX` status code, then look at the logs, which will help
    you diagnose the issue. It will probably be linked to security IAM roles.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Connecting API Gateway, Lambda, and DynamoDB
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we know the API Gateway integration with the Lambda function works,
    we will deploy it and get the URL. The architecture is shown in the following
    diagram:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/892f052b-4dd6-4c9d-8cfa-d45b93e60c14.png)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
- en: 'The workings of this architecture is as follows:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Sign in to the AWS Management Console and open the API Gateway console at [https://console.aws.amazon.com/apigateway/](https://console.aws.amazon.com/apigateway/).
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Amazon API Gateway navigation pane, choose APIs and metrics.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Resources under metrics and `/Vists/{resourceId}`, and choose Deploy
    API from the Actions drop-down menu.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Deploy API pop-up window, perform the following steps:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Deployment stage, choose [New Stage]
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Stage name, type `prod`
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Stage description, type `prod`
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `Deploy`
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Stages under metrics should be automatically selected on the left-hand menu.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select GET under `prod/visits/{resourceId}/GET` to get the invoke URL. The invoke
    URL should look like this: `https://{restapi_id}.execute-api.{region}.amazonaws.com/prod/visits/{resourceId}`.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open a new browser tab and paste in the invoke URL: `https://{restapi_id}.execute-api.{region}.amazonaws.com/Prod/visits/{resourceId}`:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The response body will be `{"message": "Internal server error"}`'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is because we validated `resource_id` in the URL `parse_parameters()` function
    before querying DynamoDB to make sure that it is a number
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open a new browser tab and paste in the invoke URL: `https://{restapi_id}.execute-api.{region}.amazonaws.com/prod/visits/324`.
    As we have used the correct `resourceId` or `EventId` internally, you should see
    the following code in your browser tab:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Open a new browser tab and paste in the invoke URL: `https://{restapi_id}.execute-api.{region}.amazonaws.com/Prod/visits/324?startDate=20171002`.
    As we have added the `startDate=20171002` parameter, you should see the following
    code in your browser tab:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: That is using the other `query_by_partition_and_sort_key()` method in the Lambda
    with the `startDate`.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: We now have a fully working serverless data API, with the ability to run different
    types of queries on DynamoDB.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning-up
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need to delete the resources manually. I recommend you use the AWS
    Console to do so. Perform the following steps:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: 'Deleting API Gateway:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log on to the Console at [https://console.aws.amazon.com/apigateway/](https://console.aws.amazon.com/apigateway/)
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Resource under metrics on the left-hand APIs menu
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Delete API from the Actions drop-down menu
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type metrics in the Enter the name of the API before confirming this action
    textbox
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Delete API
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Deleting the DynamoDB table:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log on to the Console at [https://console.aws.amazon.com/dynamodb/](https://console.aws.amazon.com/dynamodb/)
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Tables on the left-hand DynamoDB menu
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose user-visits
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Delete table
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Delete
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Deleting the Lambda function:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log on to the Console at [https://console.aws.amazon.com/lambda/](https://console.aws.amazon.com/lambda/)
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Functions on the left-hand AWS Lambda menu
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose lambda-dynamo-data-api
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Delete function under the Actions menu
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Delete
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Deleting the IAM role and policies:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log on to the Console at [https://console.aws.amazon.com/iam/](https://console.aws.amazon.com/iam/)
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Roles in the IAM navigation pane
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose lambda-dynamo-data-api
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Delete Role at the top-right
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Yes
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Policies in the IAM navigation pane
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Customer Managed under Filter Policies
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the radio button next to dynamo-readonly-user-visits, and choose Delete
    under the Policy actions menu
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Delete in the popup
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the radio button next to lambda-cloud-write, and choose Delete under
    the Policy actions menu
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Delete in the popup
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-417
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have discussed security and why it is important. Applying
    the OWASP security by design principles is a good first step to ensure that your
    serverless stack is secure. We then discussed IAM roles and gave an overview of
    policies, explaining how they are the key documents to ensure restricted access
    to AWS resources. We then looked at an overview of some of the security concepts
    and principles regarding securing your serverless microservices, specifically
    regarding Lambda, API Gateway, and DynamoDB.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: We then built a scalable serverless microservice with a RESTful data API. We
    started by creating a DynamoDB table, then added data to it, and queried it, first
    using the AWS console manually, then using the Python Boto3 SDK. We then built
    a simple Lambda to parse the request URL parameters, query DynamoDB, and return
    the records as part of a response body. We then looked at setting the integration
    between the Lambda and the API Gateway. We then connected everything together
    by deploying the API. We created a fully working API that is highly scalable,
    that you can tweak very easily for your own use cases, and that is very cost effective.
    In less than 30 minutes, you have created a highly scalable serverless microservice
    with an API. It is pay-per-usage for the API Gateway and the Lambda costs. For
    DynamoDB, you can actually change the read and write capacity very easily, set
    it to autoscale the read and write capacity based on the load, or even pay based
    on actual usage via the on-demand capacity mode, making it fully pay-per-API usage
    and data stored, avoiding traditional capacity planning or over-provisioning.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: We have done a lot of work in the AWS Console, but in later chapters, we will
    be doing most of the work using the AWS CLI, or using code deployment pipelines.
    However, using the AWS Console should have given you a really good understanding
    of what you can do in AWS, and how Lambda integrates with DynamoDB and API Gateway.
    This solid foundation is really useful when we automate most of the creation and
    provisioning using configuration, scripts, and code. In the following chapters,
    we will be adding more functionality, automated testing, and deployment pipelines,
    and implementing microservice patterns.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: In your organization, you will be developing a lot of source code and you won't
    want to deploy it manually, as we have done in this chapter. You will want to
    first test the code automatically to make sure it is working as expected, then
    you will deploy the stack in a repeatable fashion. This is needed for continuous
    integration or continuous delivery systems used in production.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to talk about how to deploy your serverless
    microservices using code and configuration to make the process more repeatable
    and scalable.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
