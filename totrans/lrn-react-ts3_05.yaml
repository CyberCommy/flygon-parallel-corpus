- en: Advanced Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already learned about a fair amount of the type system in TypeScript.
    In this chapter, we'll continue on this journey, this time diving into some of
    the more advanced types and concepts that will help us later in the book to create
    reusable strongly type React components.
  prefs: []
  type: TYPE_NORMAL
- en: We'll learn about how we can combine existing types to create union type. We'll
    find out in [Chapter 8](https://cdp.packtpub.com/learn_react_17_with_typescript_3/wp-admin/post.php?post=31&action=edit#post_31),* React
    Redux,* that these types are fundamental to creating strongly typed React Redux
    code.
  prefs: []
  type: TYPE_NORMAL
- en: We briefly covered type guards in [Chapter 2](https://cdp.packtpub.com/learn_react_17_with_typescript_3/wp-admin/post.php?post=31&action=edit#post_31),* What
    is New in TypeScript 3*, when we learned about the `unknown` type. We look at
    these in more detail in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Generics are a TypeScript feature that many libraries use to allow consumers
    to create strongly typed apps with their library. React itself uses it in class
    components to allow us to create strongly typed props and states in the component. We
    cover generics in detail in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Overload signatures is a nice feature that allows us to have a single function
    taking different combinations of parameters. We'll learn how to use these in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Lookup and mapped types allow us to dynamically create new types from existing
    types. We learn all about these at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Union types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type guards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overload signatures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lookup and mapped types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll use the following technologies in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**TypeScript playground**: This is a website at [http://www.typescriptlang.org/play](http://www.typescriptlang.org/play) that
    allows us to play and understand the features in TypeScript without installing
    it. We''ll use this the majority of the time in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual Studio Code**: We''ll need an editor to write our React and TypeScript
    code that can be installed from the [https://code.visualstudio.com/](https://code.visualstudio.com/) website.
    We will also need the **TSLint** (by egamma) and **Prettier** (by Esben Petersen) extensions
    installed within Visual Studio Code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the code snippets in this chapter can be found online at: [https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/05-AdvancedTypes.](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/05-AdvancedTypes)
  prefs: []
  type: TYPE_NORMAL
- en: Union types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, union types are types that we can combine together to
    form a new type. Unions are commonly used with string literal types, which we'll
    cover in the first section. Unions can be used in a pattern called discriminated
    union, which we can use when creating generic and reusable React components.
  prefs: []
  type: TYPE_NORMAL
- en: String literal types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A variable of a string literal type can only be assigned the exact string value
    specified in the string literal type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the TypeScript playground, let''s go through an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a string literal type called `Control` that can only be set to
    the `"Textbox"` string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now create a variable called `notes` with our `Control` type and set
    this to `"Textbox"`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As we would expect, the TypeScript compiler is happy with this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s set our variable to a different value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the compilation error Type ''"DropDown"'' is not assignable to type
    ''"Textbox"'':'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/91dd9145-99e1-43da-af3c-7bff1f48250f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As with all other types in TypeScript, `null` and `undefined` are valid values
    as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: String literal types aren't that useful on their own. However, they become extremely
    useful when used in a union type, which we'll look at in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: String literal union types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A string literal union type is where we combine multiple string literal types
    together.
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue from the previous example and go through this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s enhance our `Control` type to be a union of string literals:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We combine types in a union type using `|`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting our `notes` variable to either `"Textbox"` or `"DropDown"` is now perfectly
    valid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s extend our `Control` type to include more string literals:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now set our `notes` variable to any of these values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If we think about it, this is really useful. We could have declared the `notes`
    variable as a `string`, but declaring it with the specific string literals it
    can contain makes it super type-safe.
  prefs: []
  type: TYPE_NORMAL
- en: Discriminated union pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The discriminated union pattern allows us to handle the logic for different
    union types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first create three interfaces to represent a textbox, a date picker,
    and a number slider:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: They all have a property called `control`, which will be the discriminant in
    the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on to combine these interfaces into a union type called `Field`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: So, we can create union types from any types, and not just string literals.
    In this case, we have created a union type from three interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now create a function to initialize the value in the `Field` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The value we need to set depends on the discriminant property, `control`. So,
    we have used a `switch` statement to branch on this property.
  prefs: []
  type: TYPE_NORMAL
- en: The `default` branch in the `switch` statement is where things get interesting.
    This branch should never be reached, so we have put a statement with the `never`
    type in that branch. We'll see the value of doing this after the next steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s pretend time has passed and we have a new requirement for checkbox fields.
    Let''s implement an interface for this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also add this to the union `Field` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll immediately see that our `initializeValue` function throws a compilation
    error on the `never` declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/63d39be5-cdfb-4d52-857e-8f99b628dab0.png)'
  prefs: []
  type: TYPE_IMG
- en: This is very valuable because the `never` statement ensures we don't forget
    to add a branch of code for the new checkbox requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s go and implement this additional branch for the `"Checkbox"` field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: So, union types allow us to combine any types together to form another type.
    This allows us to create stricter types, particularly when working with strings.
    The discriminated union pattern allows us to have branches of logic for different
    types in the union, and the `never` type helps us catch all the changes that need
    to happen when we add a new type into the union type.
  prefs: []
  type: TYPE_NORMAL
- en: Type guards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Type guards allow us to narrow down the specific type of an object within a
    conditional branch of code. They are useful when working with union types, when
    we need to implement a branch of code that deals with a specific type in the union.
  prefs: []
  type: TYPE_NORMAL
- en: We already worked with a type guard in the last section when we implemented
    the `intializeValue` function. The `switch` statement on the discriminant property
    `control` allowed us to set the value on each type in the union.
  prefs: []
  type: TYPE_NORMAL
- en: There are other ways we can implement type guards. The following sections go
    through different ways.
  prefs: []
  type: TYPE_NORMAL
- en: Using the typeof keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `typeof` keyword is a JavaScript keyword that returns a string that represents
    the type. So, we can use this in a condition to narrow down the type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a union type that can be a string or an array of strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to implement a function called `first` that takes in a parameter of
    type `StringOrStringArray` and returns a `string`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The function needs to return the first character if `stringOrArray` is a `string`; otherwise,
    it should return the first array element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If we hover over `stringOrArray` in the first branch, we see that the type
    has been successfully narrowed to `string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c3bd8a84-3970-4d30-8028-6e7274641e85.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we hover over `stringOrArray` in the second branch, we see that the type
    has been successfully narrowed to `string[]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c486254e-591c-4bf5-8e52-79dc8e0e4f47.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To check our function works, we can add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If we run the program, **T** and **The** will be output to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `typeof` keyword can only be used with JavaScript types, though. To illustrate
    that point, let''s create an enhanced version of our function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll call our function `firstEnhanced`. We want to make the second branch
    specifically deal with the `string[]` type and mark the third branch as a place
    that should never be reached. Let''s give this a try:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The TypeScript compiler isn''t happy with the second branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6d9a86b0-d783-40de-bd18-a5ea0de264b4.png)'
  prefs: []
  type: TYPE_IMG
- en: The message gives us a clue as to what is going on. The JavaScript `typeof`
    keyword works with JavaScript types, which are `string`, `number`, `boolean`,
    `symbol`, `undefined`, `object`, and `function`; hence the union type in the error
    message combining these types. So, `typeof` in our second branch will actually
    return `"object"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement this properly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The TypeScript compiler is now happy again.
  prefs: []
  type: TYPE_NORMAL
- en: So, `typeof` is great for branching on JavaScript types but not ideal for TypeScript
    specific types. Let's find out how we can bridge this gap in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Using the instanceof keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `instanceof` keyword is another JavaScript keyword. It checks whether an
    object has a particular constructor function. It is typically used to determine
    whether an object is an instance of a class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two classes representing `Person` and `Company`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have a union type combining both of these classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to write a function that takes in a `Person` or `Company` and outputs
    their name to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When using `instanceof`, we have the variable we are checking before it and
    the constructor name (the class name) after it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we hover over `personOrCompany` in the first branch, we get the `Person`
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b107a292-3690-4dec-9489-8fa7b6b876b7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we hover over `personOrCompany` in the second branch, we get the `Company`
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3086686e-4083-49af-8128-a5427e653428.png)'
  prefs: []
  type: TYPE_IMG
- en: So, `instanceof` is great for narrowing down the type if we are dealing with
    classes. However, there are lots of TypeScript types we use that aren't JavaScript
    types or based on classes. So, what do we do in these situations? Let's find out
    in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Using the in keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `in` keyword is another JavaScript keyword that can be used to check whether
    a property is in an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement the example from the last section using the `in` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of classes for the `Person` and `Company` structures, we have interfaces
    this time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We again create a union type from the `Person` and `Company` structures:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s implement our function using the `in` keyword:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We put the property name in double quotes before the `in` keyword, followed
    by the object to check.
  prefs: []
  type: TYPE_NORMAL
- en: If we hover over `personOrCompany` in the first branch, we get the `IPerson` type.  If
    we hover over `personOrCompany` in the second branch, we get the `ICompany` type.
  prefs: []
  type: TYPE_NORMAL
- en: So, the `in` keyword is pretty flexible. It can be used with any object to narrow
    down its type by checking if a property exists.
  prefs: []
  type: TYPE_NORMAL
- en: There is one final type guard we will go through in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using a user-defined type guard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In situations where we can't use the other type guards, we can create our own.
    We can do this by creating a function with the return type as type predicate.
    We actually used a user-defined type guard earlier in the book when we went through
    the `unknown` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement the example from the last two sections using our own type
    guard function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the same interfaces and union type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'So, let''s implement the type guard function that returns whether the object
    is of type `IPerson`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The type predicate `personOrCompany` is `IPerson` helps the TypeScript compiler
    narrow down the type. To confirm this, hovering over `personOrCompany` in the
    first branch should give the `IPerson` type.  If we then hover over `personOrCompany` in
    the second branch, we should get the `ICompany` type.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a user-defined type guard is a little more work than the other methods,
    but it gives us lots of flexibility to deal with cases if the other methods don't
    work.
  prefs: []
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generics can be applied to a function or a whole class. It's a mechanism for
    allowing the consumers, own type to be used with the generic function or class.
    The following sections go through examples of both of these.
  prefs: []
  type: TYPE_NORMAL
- en: Generic functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go through an example of a generic function. We are going to create
    a wrapper function around the `fetch` JavaScript function for getting data from
    a web service:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating the `function` signature:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We place a `T` in angled brackets after the function name to denote that it
    is a generic function. We can actually use any letter, but `T` is commonly used. 
    We then use `T` in the signature where the type is generic. In our example, the
    generic bit is the return type, so we are returning `Promise<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to use an arrow function, this would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now implement our function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s consume the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We pass the type we want to use in the function in angle brackets after the
    function name. In our case, it is `IPerson`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we hover over `person` in the `then` callback, we see that `person` is correctly
    typed to `IPerson`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e5c149ed-5efb-44a6-92e5-7c2fd38ac377.png)'
  prefs: []
  type: TYPE_IMG
- en: So, as the name suggests, a generic function is a function that works with a
    generic type. An alternative implementation for the previous example would be
    to use `any` as the return type, but that wouldn't be type-safe.
  prefs: []
  type: TYPE_NORMAL
- en: Generic classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can make a whole class generic. Let''s dive into an example of a generic
    class that stores data in a list:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define our class first without any content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We mark the class as generic by putting `<T>` after the class name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the class, let''s create a `private` property for the data in the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We refer to the generic type using `T`.  In our example, our `data` property
    is an array of whatever type the class has been declared with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now add a `public` method to get all the data in the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We reference the generic array as the return type with `T[]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement a method for adding an item to the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We reference the data item being passed in with the generic type `T`. The implementation
    simply uses the arrays `push` method to add the item to our `private` array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also implement a method for removing an item from the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We again reference the data item being passed in with the generic type `T`.
    The implementation uses the arrays `filter` method to filter the item out of our
    private array. The filter predicate uses a `private` method that checks whether
    two objects are equal.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now that we''ve implemented our generic list class, let''s create a type
    and some data in preparation for consuming it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now create an instance of our generic class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We put the type we want to use with the class after the class name in angled
    brackets.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now interact with the class by adding and removing `billy`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try to use a different type with our list instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We get a compilation error, as we would expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8c9d178e-6280-42a8-b058-b1297b821cde.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s save all the items in our list instance to a variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'If we hover over the `items` variable, we see that the type has been correctly
    inferred to `IPerson[]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d327fe7b-856e-46ad-8e97-a3a8291947e1.png)'
  prefs: []
  type: TYPE_IMG
- en: So, a generic class allows us to use the class with different types but still
    maintain strong typing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We actually used generic classes earlier in the book where we implemented React
    class components with props and state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `React.Component` class has two generic parameters for the props and
    state.
  prefs: []
  type: TYPE_NORMAL
- en: So, generics are a really important concept that we'll use heavily in this book
    to create strongly typed React components.
  prefs: []
  type: TYPE_NORMAL
- en: Overload signatures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Overload signatures allow a function to be called with different signatures. This
    feature can be used nicely to streamline a set of functions that a library offers
    to consumers. Wouldn''t it be nice for a library that contained `condenseString`
    public functions and `condenseArray` to be streamlined so that it just contained
    a single public `condense` function? We''ll do just this in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a function that removes spaces from a string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We have another function that removes spaces from array items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We now want to combine these two functions into a single function. We can do
    this as follows using union types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s consume our unified function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'As we enter the function parameter, IntelliSense reminds us that we need to
    enter a string or an array of strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/16211526-e4fe-4474-ac5f-e0a20c980546.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we hover over the `condensedText` variable, we see that the inferred type
    is the union type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/be356958-af22-4cd1-a743-26cc4f932376.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It''s time to add two signature overloads to improve the consumption of our
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We add function overload signatures before the main function signature. We've
    added an overload for when we work with a string, and a second overload for when
    we work with an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consume our overloaded function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We get improved IntelliSense now as we type the parameter. We also get up and
    down arrows to scroll through the two different signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3e18d290-be0c-4bac-b77e-cc8bceea1b4a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we hover over the `moreCondensedText` variable, we see that we get better
    type inference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9556262a-e3ca-429f-b871-7fc53c4c55ee.png)'
  prefs: []
  type: TYPE_IMG
- en: So, overload signatures improve the experience for developers consuming our
    functions. They can give improved IntelliSense and type inference.
  prefs: []
  type: TYPE_NORMAL
- en: Lookup and mapped types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `keyof` is a keyword in TypeScript that creates a union type of all the
    properties in an object. The type that is created is called a lookup type.  This
    allows us to create types dynamically, based on the properties of an existing
    type. It's a useful feature that we can use to create generic but strongly typed
    code against varying data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the following `IPerson` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a lookup type on this interface using `keyof`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'If we hover over the `PersonProps` type, we see that a union type containing
    `"id"` and `"name"` has been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/adf4d8ce-701b-4c33-bae1-625b4f3bee33.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s add a new property to `IPerson`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'If we hover over the `PersonProps` type again, we see that the type has been
    automatically extended to include `"age"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e3f68ad0-87a7-49b2-a2ea-44b820ab9ded.png)'
  prefs: []
  type: TYPE_IMG
- en: So, the `PersonProps` type is a lookup type because it looks up the literals
    it needs to contain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create something useful now with a lookup type:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to create a `Field` class that contains the field name, a label,
    and a default value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a start, but we can make `name` more strongly typed by making our class
    generic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We have created two generic parameters on the class. The first one is for the
    type of the object containing the field, and the second one is for the property
    name within the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'It will probably make more sense if we create an instance of the class. Let''s
    do just that using `IPerson` from the last example and passing `"id"` in as the
    field name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try and reference a property that doesn''t exist in `IPerson`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We get a compilation error, as we would expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9bcff5a0-6fb8-45c1-9716-8cd06aacca2c.png)'
  prefs: []
  type: TYPE_IMG
- en: Catching problems like this is the benefit of the lookup type, rather than using
    a `string` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move our attention to the `defaultValue` property in our `Field` class.
    This is not type-safe at the moment. For example, we can set `idField` to a string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s resolve this and make `defaultValue` type-safe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We are looking up the type using `T[K]`. For `idField`, this will resolve to
    the type of the `id` property in `IPerson`, which is `number`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The line of code that sets `idField.defaultValue` now throws a compilation
    error, as we would expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/229bceae-9608-4b21-af80-a048171564ce.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s change `"2"` to `2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The compilation error disappears.
  prefs: []
  type: TYPE_NORMAL
- en: So, lookup types can be useful when creating generic components for variable
    data types.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to mapped types now. Again, these let us create new types from
    an existing type's properties. However, mapped types allow us to specifically
    define the properties in the new type by mapping them from the existing property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a type that we will map from in the next step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s create a new version of the `interface` where all the properties
    are `readonly` using mapped type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The important bit that creates the map is `[P in keyof IPerson]`. This iterates
    through all the properties in `IPerson` and assigns each one to `P` to create
    the type. So, the type that is generated in the previous example is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Let try this out to see if our type really is `readonly`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'As we expect, a compilation error is thrown where we try to set the `readonly`
    property to a new value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e5cdc52a-81b3-4d5c-a4cf-45e9b1d0b7ef.png)'
  prefs: []
  type: TYPE_IMG
- en: So our mapped type worked! A more generic version of this mapped type is actually
    in TypeScript as a standard type, and is `Readonly<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the standard `readonly` type now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try changing the values in our `readonly`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'A compilation error is thrown, as we would expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ec2cbbfd-da34-49d8-b69d-995921a2d5d1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we were in Visual Studio Code and used the Go to Definition option on the
    `Readonly` type, we would get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This is very similar to our `ReadonlyPerson` type, but `IPerson` has been substituted
    with generic type `T`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a go at creating our own generic mapped type now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to create a mapped type that makes all the properties of an existing
    type of type `string`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try to consume our mapped type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try to set `id` to a number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The expected compilation error is thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ec29dcfe-ffbc-4520-83ab-6920edba4a0c.png)'
  prefs: []
  type: TYPE_IMG
- en: So, mapped types are useful in situations when we need a new type that is based
    on an existing type. Along with `Readonly<T>`, there are quite a few standard
    mapped types in TypeScript, such as `Partial<T>`, which creates a mapped type
    making all the properties optional.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've learned some of the more advanced types in TypeScript in this chapter,
    starting with union types. Union types are extremely useful, allowing us to create
    new types by unioning existing types together. We discovered that unioning together
    string literals allow us to create a type that is more specific and type-safe
    than a regular `string`.
  prefs: []
  type: TYPE_NORMAL
- en: We explored various ways of implementing type guards. Type guards are useful
    to help the compiler narrow down a union type in branches of logic. They are also
    useful when working with the `unknown` type to tell the compiler what the type
    is in branches of logic.
  prefs: []
  type: TYPE_NORMAL
- en: Generics, as the name suggests, allow us to create generic types. Having covered
    this topic in detail, the type-safety for props and state in React components
    makes a lot more sense now. We will continue to use generic classes and functions
    heavily in the rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: We learned that overload signatures allow us to have a function that has different
    parameters and return types. We can now use this feature to good effect to streamline
    public functions we expose in a library.
  prefs: []
  type: TYPE_NORMAL
- en: We learned about how we can dynamically create new types from existing type
    properties using both lookup and mapped types. We are now aware that there are
    lots of useful standard TypeScript mapped types such as `Readonly<T>` and `Partial<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about all these features is great preparation for the next chapter,
    where we'll dive into some common patterns when working with React components.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s have a go at some questions on advanced types:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have an `interface` that represents a course result, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this `interface` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The grades can only be A, B, C, or D. How can we create a stronger typed version
    of the `grade` property in this interface?
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the following functions that validate that numbers and strings are
    populated with a value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: How can we combine these into a single function called `isPopulated` with signature
    overloads?
  prefs: []
  type: TYPE_NORMAL
- en: How can we implement a more flexible version of the `isPopulated` function with
    generics?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have the follow `type` alias of stages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: How can we programmatically turn this into the `'Pending' | 'Started' | 'Completed'` union
    type?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have the following union type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'How can we programmatically create the following type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The TypeScript documentation has a great section on advanced types that is
    worth looking at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.typescriptlang.org/docs/handbook/advanced-types.html](https://www.typescriptlang.org/docs/handbook/advanced-types.html)'
  prefs: []
  type: TYPE_NORMAL
