- en: Implementing a Backtesting System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **backtest** is a simulation of a model-driven investment strategy's response
    to historical data. While working on designing and developing a backtest, it would
    be helpful to think in terms of the concept of creating video games.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will design and implement an event-driven backtesting system
    using an object-oriented approach. The resulting profits and losses of our trading
    model may be plotted on to a graph to help visualize the performance of our trading
    strategy. However, is this sufficient enough to determine whether it is a good
    model?
  prefs: []
  type: TYPE_NORMAL
- en: There are many concerns to be addressed in backtesting—for example, the effects
    of transaction costs, execution latency of orders, access to detailed transactions,
    and quality of historical data. Notwithstanding these factors, the primary goal
    of creating a backtesting system is to test a model as accurately as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Backtesting involves a lot of research that merits its own literature. We will
    briefly cover some thoughts that you might want to consider when implementing
    a backtest. Typically, a number of algorithms are employed in backtesting. We
    will briefly discuss some of these: k-means clustering, k-nearest neighbors, classification
    and regression trees, 2k factorial design, and genetic algorithms.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing backtesting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concerns in backtesting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concept of an event-driven backtesting system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing and implementing a backtesting system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing classes to store tick data and market data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing classes for orders and positions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a mean-reverting strategy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the backtest engine single and multiple times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ten considerations for a backtesting model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussion of algorithms in backtesting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing backtesting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A backtest is a simulation of a model-driven investment strategy's response
    to historical data. The purpose of performing experiments with backtests is to
    make discoveries about a process or system. By using historical data, you can
    save time in testing an investment strategy for the period forward. It helps you
    test an investment theory based on the movements of the tested period. It is also
    used to both evaluate and calibrate an investment model. Creating a model is only
    the first step. The investment strategy will typically employ the model to help
    you drive simulated trading decisions and compute various factors related to either
    risk or return. These factors are typically used together to find a combination
    that is predictive of return.
  prefs: []
  type: TYPE_NORMAL
- en: Concerns in backtesting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'However, there are many concerns to be addressed in backtesting:'
  prefs: []
  type: TYPE_NORMAL
- en: A backtest can never exactly replicate the performance of an investment strategy
    in an actual trading environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The quality of the historical data is questionable, since it is subjected to
    outliers by third-party data vendors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look-ahead bias takes many forms. For example, listed companies may split, merge,
    or de-list, resulting in substantial changes to its stock price.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For strategies based on information from the order book, the market microstructure
    is extremely difficult to simulate realistically, since it represents the collective
    visible supply and demand in continuous time. This supply and demand are in turn
    affected by news events around the world.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Icebergs and resting orders are some hidden elements of the market that could
    affect the structure once activated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other factors to be considered are transaction costs, execution latency of orders,
    and access to detailed transactions from backtesting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notwithstanding these factors, the primary goal of creating a backtesting system
    is thus to test a model as accurately as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Look-ahead bias is the use of available future data during the period it is
    being analyzed, resulting in inaccurate results in the simulation or study. It
    is vital to use information that would be only available during the period of
    study.In finance, iceberg orders are large orders that are broken up into several
    small orders. Only a small portion of the order is visible to the public—just
    like the *tip of the iceberg*—while the mass of the actual order is hidden. A
    **resting order** is an order whose price is away from the market and is waiting
    to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Concept of an event-driven backtesting system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While working on designing and developing a backtest, it would be helpful to
    think in terms of the concept of creating video games. After all, we are trying
    to create a simulated market pricing and ordering environment, very much akin
    to creating a virtual gaming world. Trading can also be regarded as a thrilling
    game of buying low and selling high.
  prefs: []
  type: TYPE_NORMAL
- en: In a virtual trading environment, components are needed for the simulation of
    price feeds, the order-matching engine, the order-book management, as well as
    functions for account and position updates. To achieve these functionalities,
    we can explore the concept of an event-driven backtesting system.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by understanding the concept of an event-driven programming paradigm
    used throughout the game development process. A system typically receives events
    as its inputs. It might be a keystroke entered by a user or a mouse movement.
    Other events could be messages that are generated by another system, a process,
    or a sensor to notify the host system of an incoming event.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the stages involved in a game engine system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/463d52f9-5032-4afb-af9f-0feeba28e129.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a look at a pseudo-code implementation of a main game engine loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The core functions within the main game engine loop may process generated system
    events, as in the case of the `handle_input_events()` function, which handles
    the keyboard events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Using an event-driven system, such as the preceding example, helps us achieve
    code modularity and reusability by being able to swap and use similar events from
    different system components. The use of object-oriented programming is further
    enforced, where classes define objects in a game. These features are particularly
    useful for interfacing with different market data sources, multiple trading algorithms,
    and runtime environments when designing our trading platform. The simulated trading
    environment is close to being a realistic one and helps us prevent look-ahead
    bias.
  prefs: []
  type: TYPE_NORMAL
- en: Designing and implementing a backtesting system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have an idea of designing a video game for creating a backtesting
    trading system, we can begin our object-oriented approach by first defining the
    required classes for the various components in our trading system.
  prefs: []
  type: TYPE_NORMAL
- en: We are interested in implementing a simple backtesting system to test a mean-reverting
    strategy. Using the daily historical prices from a data-source provider, we will
    take the closing price of each day to compute the volatility of price returns
    for a particular instrument, using the AAPL stock price as an example. We would
    like to test a theory that if the standard deviation of returns for an elapsed
    number of days is far from the mean of zero by a particular threshold, a buy or
    sell signal is generated. When such a signal is indeed generated, a market order
    is sent to the exchange to be executed at the opening price of the next trading
    day.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as we open a position, we would like to track our unrealized and realized
    profits to date. Our open position can be closed when an opposing signal is generated.
    On completion of the backtest, we will plot our profits and losses to see how
    well our strategy holds.
  prefs: []
  type: TYPE_NORMAL
- en: Does our theory sound like a viable trading strategy? Let's find out! The following
    sections explain the classes that go into implementing a backtesting system.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a class to store tick data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Write a class named `TickData` that represents a single unit of data received
    from a market data source with the following Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are interested in storing the timestamp, symbol of the instrument,
    the opening and closing price, as well as the total volume traded. Detailed descriptions
    of a single unit of tick data, such as the highest price reached or last-traded
    volume, can be added as our system evolves.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a class to store market data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An instance of the `MarketData` class is used throughout the system to store
    and retrieve prices referenced by various components. Essentially, it is a container
    for storing the last available tick data. Additional `get` helper functions are
    included to provide easy reference to the required information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Writing a class to generate sources of market data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Write a class called `MarketDataSource` to help us fetch historical data from
    an external data provider. In this example, we will be using **Quandl** as our
    data provider. The constructor of the class is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor, the `symbol` parameter contains the value recognized by
    our data provider to download our desired dataset. An object of `MarketData` is
    instantiated for storing the most recent market data available. The `tick_event_handler`
    parameter stores the method handler as we iterate through our data source. The `start`
    and `end` parameters refer to the starting and ending dates of the dataset that
    we wish to keep in the `pandas` DataFrame variable, `df`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `fetch_historical_prices()` method inside the `MarketDataSource` method
    containing specific instructions for downloading from our data provider and returning
    the desired `pandas` DataFrame object, which holds our daily market prices, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As this method is specific to Quandl's API, you may rewrite this method to download
    from your own data provider accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, add the `run()` method inside the `MarketDataSource` class to simulate
    the streaming prices from our data provider during backtesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the first `if` statement performs a check on the presence of an
    existing market data before performing the download from our data provider. This
    allows us to run several simulations on the backtest using the cached data, avoiding
    the unnecessary download overheads and having our backtests run quicker.
  prefs: []
  type: TYPE_NORMAL
- en: The `for` loop on our `df` market data variable is used to simulate the streaming
    prices. Each tick data is transformed and formatted as an instance of `TickData` and
    added to the `market_data` object as the most recently available tick data for
    that particular symbol. This object is then passed to any tick data event handlers
    listening to a tick event.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the order class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Order` class in the following code represents a single order sent by the
    strategy to the server. Each order contains a timestamp, the symbol, quantity,
    and a flag indicating a buy or sell order. In the following examples, we will
    be using market orders only, and `is_market_order` is expected to be `True`. Other
    order types, such as limit and stop orders, may be implemented if desired. Once
    an order is filled, the order is further updated with the filled price, time,
    and quantity. Write this class as given in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Writing a class to keep track of positions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Position` class helps us keep track of our current market position and
    account balance for a traded instrument, and is written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The number of units bought, sold, and net are declared as `buys`, `sells`, and
    `net` variables, respectively. The `rpnl` variable stores the recently realized
    profits and losses for the symbol. Note that the `position_value` variable starts
    with a value of zero. When securities are bought, the value of the securities
    is debited from this account. When securities are sold, the value of the securities
    is credited into this account.
  prefs: []
  type: TYPE_NORMAL
- en: 'When an order is filled, an account''s position changes. Write a method named
    `on_position_event()` inside the `Position` class to handle these position events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: On a change in our position, we update and keep track of the number of securities
    bought and sold, as well as the current value of the securities. When the net
    position is zero, the position is closed out and we obtain the current realized
    profits and losses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever a position is open, the value of our securities is influenced by market
    movements. Having a measure of unrealized profits and losses helps to keep track
    of the change in market value on every tick movement. Add the following `calculate_unrealized_pnl()`
    method inside the `Position` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Calling the `calculate_unrealized_pnl()` method with the current market price
    gives us the current market value of our position for a particular security.
  prefs: []
  type: TYPE_NORMAL
- en: Writing an abstract strategy class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Strategy` class given in the following code is the base class for all
    other strategy implementations, and is written as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `on_tick_event()` abstract method is called when new market tick data arrives.
    Child classes would have to implement this abstract method to act upon incoming
    market prices. The `on_position_event()` abstract method is called whenever there
    are updates to our positions. Child classes would have to implement this abstract
    method to act upon incoming position updates.
  prefs: []
  type: TYPE_NORMAL
- en: The `send_market_order()` method is called by child strategy classes to route
    a market order to the broker. The handler for such an event is stored in the constructor,
    where the actual implementation is done by the owner of this class in the next
    section and interfaced directly with a broker API.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a mean-reverting strategy class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we are implementing a **mean-reverting trading strategy**
    on the AAPL stock price. Write the `MeanRevertingStrategy` child class that inherits
    the `Strategy` class from the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor, we accept parameter values for telling our strategy the
    security symbol to trade and the number of units for each trade. The `send_order_event_handler`
    function variable is passed to the parent class to be stored. The `lookback_intervals`,
    `buy_threshold`, and `sell_threshold` variables are parameters concerned with
    generating trading signals using mean-reversion calculations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pandas` DataFrame `prices` variable will be used to store incoming prices,
    and the `is_long` and `is_short` Boolean variables store the current position
    of this strategy, and only one of them can be `True` at any time. These are assigned
    in the `on_position_event()` method inside the `MeanRevertingStrategy` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `on_position_event()` method implements the parent abstract method and gets
    called on every update of our position.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, implement the `on_tick_event()` abstract method inside the `MeanRevertingStrategy`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: On every tick-data event, market prices are stored in the current strategy class
    to be used for the calculation of trading signals, provided there is sufficient
    data to so. In this example, we are using daily historical prices with a look-back
    period of 20 days. In other words, we will be using the mean of the past 20 days'
    prices to determine a mean reversion. Until there is insufficient data, we simply
    skip this step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `store_prices()` method inside the `MeanRevertingStrategy` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: On each tick event, the `prices` DataFrame store the daily closing price, indexed
    by a timestamp.
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic for generating trading signals is given in the `generate_signals_and_send_order()`
    method inside the `MeanRevertingStrategy` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: On each tick event, the **z-score** for the current period is calculated, which
    we will cover shortly. As soon as the z-score exceeds our buying threshold value,
    a buy signal is generated. We can either close a short position or enter into
    a long position by sending a buy market order to our broker. Conversely, when
    the z-score exceeds our selling threshold value, a sell signal is generated. We
    can either close a long position or enter into a short position by sending a sell
    market order to our broker. In our backtest system, orders are executed at the
    opening of the next day.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `calculate_z_score()` method inside the `MeanRevertingStrategy` class
    for calculating z-scores on every tick event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The daily percentage returns of closing prices are z-scored using this formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c6b40be1-683a-46a7-aa23-0f5d3ffc2e25.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, *x* is the most recent return, *μ* is the mean of returns, and *σ* is
    the standard deviation of returns. A z-score value of 0 indicates that the score
    is the same as the mean. Take for example a buying threshold value of -1.5\. When
    the z-score falls below -1.5, this indicates a strong buying signal, since z-scores
    for the following periods are expected to revert to the mean of zero. Similarly,
    a selling threshold value of 1.5 could indicate a strong selling signal and z-scores
    are expected to revert to the mean.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the goal of this backtesting system aims to find optimal threshold
    values in maximizing our profits.
  prefs: []
  type: TYPE_NORMAL
- en: Binding our modules with a backtesting engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After defining all of our core modular components, we are now ready to implement
    the backtesting engine as the `BacktestEngine` class with the following codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Within the backtest engine, we store the symbol and the number of units to trade.
    An instance of `MarketDataSource` is created with the symbol, together with the
    start and end dates for defining the timeframe of our dataset. Emitted tick events
    will be handled by our local `on_tick_event()` method, which we will implement
    shortly. The `strategy` variable is intended to store an instance of our mean-reverting
    strategy class. The `unfilled_orders` variable acts as our order book that will
    store incoming market orders for execution at the next trading day. The `positions`
    variable is intended to store instances of `Position` objects, indexed by symbol.
    The `df_rpnl` variable is intended to store our realized profits and losses during
    backtesting, which we can use to plot at the end of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The entry point for running the backtesting engine is the `start()` method
    given as follows inside the `Backtester` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: A single instance of `Backtester` may be run multiple times by calling the `start()`
    method. At the start of every run, we initialize the `unfilled_orders`, `positions`,
    and `df_rpl` variables. A new instance of a strategy class is instantiated with
    the symbol and number of units to trade, a method named `on_order_received()`
    for receiving orders triggered from the strategy, as well as any keyword `kwargs`
    arguments required by the strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `on_order_received()` method inside the `BacktestEngine` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We are notified on the console when an order is generated and added to the order
    book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `on_tick_event()` method inside the `BacktestEngine` class to
    handle tick events emitted by the market data source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The market data source in this example is expected to be the daily historical
    prices. A tick event received represents a new trading day. At the start of the
    trading day, we check our order book and match any unfilled orders at the opening
    by calling the `match_order_book()` method. After which, we pass the latest market
    data represented by the `market_data` variable to the strategy's tick-event handler
    to perform trading functions. At the end of the trading day, we print out information
    on our positions to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `match_order_book()` and `match_unfilled_orders()` methods inside
    the `BacktestEngine` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'On every call of the `match_order_book()` command, a list of pending orders
    stored in the `unfilled_orders` variable is checked for execution in the market
    and removed from the list when this operation is successful. The `if` statement
    in the `match_unfilled_orders()` method verifies that the order is in the correct
    state and marks the order as filled immediately at the current market-opening
    price. This would trigger a series of events on the `on_order_filled()` method. Implement
    this method inside the `BacktestEngine` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As soon as an order is filled, the corresponding position of the traded symbol
    is required to be updated. The `position` variable contains the retrieved `Position`
    instance, and a call on its `on_position_event()` command updates its state. The
    realized profits and losses are calculated and saved to the `pandas` DataFrame
    `df_rpnl` along with the timestamp. The strategy is also informed of a change
    in position by calling the `on_position_event()` command. We are notified on the
    console when such an event occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `get_position()` method inside the `BacktestEngine` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `get_position()` method is a helper method that simply gets the current
    `Position` object for a trading symbol. An instance is created if none is found.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last command call by `on_tick_event()` is `print_position_status()`. Implement
    this method inside the `BacktestEngine` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: On every tick event, we print any available position information on the current
    market value, realized and unrealized profits, and losses to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Running our backtesting engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With all of the required methods defined inside the `BacktestEngine` class,
    we may now go ahead and create an instance of this class with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are interested in trading one unit of AAPL stock each time,
    using three years of daily historical data for backtesting from the year 2015
    to 2017.
  prefs: []
  type: TYPE_NORMAL
- en: 'Issue the `start()` command to run the backtesting engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `lookback_interval` parameter argument with a value of 20 tells our strategy
    to use the most recent 20 days' of daily historical prices in calculating z-scores.
    The `buy_threshold` and `sell_threshold` parameter arguments define the boundary
    limits at which a buy or sell signal is generated. In this example, a buy threshold
    value of -1.5 indicates that a long position is desired when the z-score falls
    below -1.5\. Similarly, a sell threshold value of 1.5 indicates that a short position
    is desired when the z-score rises above 1.5.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the engine runs, you will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'From the output logs, a buy signal is generated on February 25, 2015 and a
    market order is added to the order book for execution at the opening of the next
    trading day on February 26 at USD 128.785\. By the end of the trading day, our
    long position would have an unrealized profit of USD 1.63:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Scrolling further down the logs, you should see that on March 30, 2015 a sell
    signal is generated, and a sell market order is executed on the next day, March
    31, at the price of USD 126.09\. This closes our long position and leaves us with
    a realized loss of USD 2.695.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the backtest engine finishes, we can plot our strategies realized and
    profits on to a chart to visualize this trading strategy with the following Python
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/1390828c-fe24-4857-81bc-cf305c4274f3.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the realized profits and losses are not complete at the end of the
    backtest. We may still be holding on to a long or short position with unrealized
    profits or losses. Be sure to account for this remaining value when evaluating
    your strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple runs of the backtest engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using **fixed strategy parameters**, we were able to have the backtest engine
    run a single time and visualize its performance. Since the goal of backtesting
    is to find the optimal strategy parameters for considering in a trading system,
    we would like our backtest engine to run multiple times on different strategy
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, define the list of threshold values that we would like to test
    in a constant variable named `THRESHOLDS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Each item in the list constant is a tuple of buy and sell threshold values.
    We can iterate these values with a `for` loop, calling the `engine.start()` command
    and plotting on a graph on every iteration with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/5f42cfaa-70c6-41c3-b86e-42c95ef8f7d1.png)'
  prefs: []
  type: TYPE_IMG
- en: The four plots show the outcomes of the various threshold values being used
    in our strategy. By varying the strategy parameters, we obtained different profiles
    of risk and returns. Perhaps you may find better strategy parameters in achieving
    better results than this!
  prefs: []
  type: TYPE_NORMAL
- en: Improving your backtesting system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at creating a simple backtesting system based on
    the daily closing prices for a mean-reverting strategy. There are several areas
    of considerations to make such a backtesting model more realistic. Are historical
    daily prices sufficient to test our model? Should intra-day limit orders be used
    instead? Our account value started from zero; how can we reflect our capital requirements
    accurately? Are we able to borrow shares for shorting?
  prefs: []
  type: TYPE_NORMAL
- en: Since we took an object-oriented approach in creating a backtesting system,
    how easy would it be to integrate other components in the future? A trading system
    could accept more than one source of market data. We could also create components
    that allow us to deploy our system to the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: The list of concerns mentioned are not exhaustive. To guide us in implementing
    a robust backtesting model, the next section spells out ten considerations in
    the design of such a system.
  prefs: []
  type: TYPE_NORMAL
- en: Ten considerations for a backtesting model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we performed one replication of a backtest. Our result
    looks pretty optimistic. However, is this sufficient to deduce that this is a
    good model? The truth is that backtesting involves a lot of research that merits
    literature of its own. The following list briefly covers some thoughts that you
    might want to consider when implementing your backtests.
  prefs: []
  type: TYPE_NORMAL
- en: Resources restricting your model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The resources that are available to your backtesting system limit how well you
    can implement your backtest. A financial model that generates signals using only
    the last closing price needs a set of historical data on the closing prices. A
    trading system that requires reading from the order book requires all levels of
    the order book data to be available on every tick. This adds up the storage complexity.
    Other resources, such as exchange data, estimation techniques, and computer resources
    pose a limitation on the nature of the model that can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Criteria of evaluation of the model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we conclude that a model is good? Some factors to consider are Sharpe
    ratios, hit ratios, average rate of return, VaR statistics, as well as the minimum
    and maximum drawdown encountered. How can a combination of such factors balance
    so that a model is usable? How much can the maximum drawdown be tolerated in achieving
    a high Sharpe ratio?
  prefs: []
  type: TYPE_NORMAL
- en: Estimating the quality of backtest parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using a variety of parameters on a model typically gives us varied results.
    From multiple models, we can obtain additional sets of data for each model. Can
    the parameters from the model with the best performance be trustworthy? Using
    methods such as model averaging can help us correct optimistic estimates.
  prefs: []
  type: TYPE_NORMAL
- en: The model-averaging technique is the average fit for a number of models as opposed
    to using a single best model.
  prefs: []
  type: TYPE_NORMAL
- en: Be prepared to face model risk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Perhaps after extensive backtesting, you may find yourself with a good-quality
    model. How long is it going to stay that way? In **model risk**, the market structure
    or the model parameters may change with time, or a regime change may cause the
    functional form of your model to change abruptly. By then, you could even be uncertain
    that your model is correct. A solution that addresses model risk is **model averaging**.
  prefs: []
  type: TYPE_NORMAL
- en: Performance of a backtest with in–sample data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Backtesting helps us perform extensive parameter searches that optimize the
    results of a model. This exploits the true and the idiosyncratic aspects of the
    sample data. Also, historical data can never mimic the way that the entire data
    comes from live markets. These optimized results will always produce an optimistic
    assessment of the model and the strategy used.
  prefs: []
  type: TYPE_NORMAL
- en: Addressing common pitfalls in backtesting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most common error made in backtesting is **look-ahead bias**, and it comes
    in many forms. For example, parameter estimates may be derived from the entire
    period of the sample data, which constitute using information from the future.
    Statistical estimates such as these and model selection should be estimated sequentially,
    which could actually be difficult to do.
  prefs: []
  type: TYPE_NORMAL
- en: Errors in data come in all forms, from hardware, software, and human errors
    that could occur while routed by data distribution vendors. Listed companies may
    split, merge, or de-list, resulting in substantial changes to their stock prices.
    These actions could lead to survivorship bias in our models. Failure to clean
    data properly will give undue influence to idiosyncratic aspects of data, and
    thus affect the model parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '**Survivorship bias** is the logical error of concentrating on results that
    have survived some past selection process. For example, a stock-market index may
    report a strong performance even in bad times because poor performing stocks are
    dropped from its component weightage, resulting in an overestimation of past returns.'
  prefs: []
  type: TYPE_NORMAL
- en: Failure to use shrinkage estimators or model averaging could report results
    containing extreme values, making it difficult for comparison and evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: In statistics, a shrinkage estimator is used as an alternative to an ordinary
    least-squares estimator to produce the smallest mean-squared error. They can be
    used to shrink raw estimates from the model output toward zero or another fixed
    constant value.
  prefs: []
  type: TYPE_NORMAL
- en: Have a common-sense idea of your model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, common sense could be lacking in our models. We may attempt to explain
    a trendless variable with a trended variable or infer causation from correlation.
    Can logarithmic values be used when the context does or does not require it? Let's
    see in the further section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the context for the model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having a common-sense idea of a model is barely sufficient. A good model takes
    into account the history, personnel involved, operating constraints, common peculiarities,
    and all the understanding for the rationale of the model. Are commodity prices
    following seasonal movements? How was the data gathered? Are the formulas used
    in the computation of variables reliable? These questions can help us determine
    the causes, should things go wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you have the right data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not many of us have access to tick-level data. Low-resolution tick data may
    miss out on detailed information. Even tick-level data may be fraught with errors.
    Using summary statistics, such as the mean, standard errors, maximums, minimums,
    and correlations, tells us a lot about the nature of the data whether we can really
    use it, or infer backtest parameter estimates.
  prefs: []
  type: TYPE_NORMAL
- en: 'When data cleaning is performed, we might ask these questions: what are things
    to look out for? Are values realistic and logical? How is the missing data coded?'
  prefs: []
  type: TYPE_NORMAL
- en: Devise a system of reporting data and results. The use of graphs helps the human
    eye to visualize patterns that might come across as unexpected. Histograms might
    reveal an unexpected distribution, or residual plots might show unexpected prediction
    error patterns. Scatter plots of residualized data may show additional modeling
    opportunities.
  prefs: []
  type: TYPE_NORMAL
- en: Residualized data is the difference or *residuals* between the observed values
    and those of the model.
  prefs: []
  type: TYPE_NORMAL
- en: Data mine your results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From running over several iterations of backtests, the results represent a source
    of information about your model. Running your model in real-time conditions produces
    another source of results. By data mining all this wealth of information, we can
    obtain a data-driven result that can avoid tailoring the model specifications
    to the sample data. It is recommended to use shrinkage estimators or model averaging
    when reporting the results.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion of algorithms in backtesting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After taking into consideration the designing of a backtesting model, one or
    more algorithms may be used to improve the model on a continuous basis. This section
    briefly covers some of the algorithmic techniques used in areas of backtesting,
    such as data mining and machine learning.
  prefs: []
  type: TYPE_NORMAL
- en: K-means clustering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **k-means clustering** algorithm is a method of clustering analysis in data
    mining. From the backtest results of *n* observations, the k-means algorithm is
    designed to classify the data into *k* clusters based on their relative distance
    from one another. The center point of each cluster is computed. The objective
    then is to find the within-cluster sum of squares that gives us a model-averaged
    point. The model-averaged point indicates the likely average performance of the
    model, which can be used for further comparison with the performance of other
    models.
  prefs: []
  type: TYPE_NORMAL
- en: K-nearest neighbors machine learning algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **k-nearest neighbors** (**KNN**) is a lazy learning technique that does
    not build any models.
  prefs: []
  type: TYPE_NORMAL
- en: An initial set of backtest model parameters are chosen either by random or best
    guess.
  prefs: []
  type: TYPE_NORMAL
- en: After analyzing the results of the model, a *k* number of sets of parameters
    that is closest to the original set are used for computation in the next step.
    The model will then take the set of parameters that gives the best results.
  prefs: []
  type: TYPE_NORMAL
- en: The process continues until the terminating condition is reached, thereby always
    giving the best set of model parameters available.
  prefs: []
  type: TYPE_NORMAL
- en: Classification and regression tree analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Classification And Regression Tree** (**CART**) analysis contains two
    decision trees that are used in data mining. The classification tree uses classification
    rules to classify the outcomes of a model using nodes and branches in the decision
    tree. The regression tree attempts to assign a real value to the classified outcome.
    The resulting values are averaged to provide a measure of the quality of the decision.
  prefs: []
  type: TYPE_NORMAL
- en: The 2k factorial design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When designing experiments for backtesting, we can consider the use of **2k
    factorial design**. Suppose we have two factors, A and B. Each factor behaves
    as a Boolean value, with values of either +1 or -1\. A +1 value indicates a quantitatively
    high value, while -1 indicates a low value. This gives us a combination of 2²
    = 4 outcomes. For a 3-factor model, this gives us a combination of 2³ = 8 outcomes.
    The following table illustrates an example with two factors with outcomes W, X,
    Y, and Z:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **A** | **B** | **Replication I** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Value | +1 | +1 | W |'
  prefs: []
  type: TYPE_TB
- en: '| Value | +1 | -1 | X |'
  prefs: []
  type: TYPE_TB
- en: '| Value | -1 | +1 | Y |'
  prefs: []
  type: TYPE_TB
- en: '| Value | -1 | -1 | Z |'
  prefs: []
  type: TYPE_TB
- en: Note that we are generating one replication of backtest to produce a set of
    outcomes. Performing additional replications gives us more information. From this
    data, we can perform a regression and analyze its variance. The objectives of
    these tests are to determine which factors, A or B, are more influential over
    another, and what values should be chosen so that the outcomes are either near
    some desired value, able to achieve a low variance, or minimize the effects of
    uncontrollable variables.
  prefs: []
  type: TYPE_NORMAL
- en: The genetic algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Genetic Algorithm** (**GA**) is a technique where every individual evolves
    through the process of natural selection in order to optimize a problem. A population
    of candidate solutions in an optimization problem goes through an iterative process
    of selection to become parents, undergoing mutation and crossover to produce the
    next generation of offspring. Over cycles of successive generations, the population
    evolves toward an optimal solution.
  prefs: []
  type: TYPE_NORMAL
- en: The application of GAs can be applied to a variety of optimizing problems, including
    backtesting, and is especially useful for solving standard optimizations, discontinuous
    or non-differentiable problems, or nonlinear outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A backtest is a simulation of a model-driven investment strategy's response
    to historical data. The purpose of performing experiments with backtests is to
    make discoveries about a process or system and to compute various factors related
    to either risk or return. The factors are typically used together to find a combination
    that is predictive of the return.
  prefs: []
  type: TYPE_NORMAL
- en: While working on designing and developing a backtest, it would be helpful to
    think in terms of the concept of creating video games. In a virtual trading environment,
    components are needed for the simulation of price feeds, the order-matching engine,
    the order book management, as well as functions for account and position updates.
    To achieve these functionalities, we can explore the concept of an event-driven
    backtesting system.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we designed and implemented a backtesting system that interacts
    with various components that handle tick data, fetching historical prices from
    a data provider, handling order and position updates, and simulating a streaming
    price feed that triggers our strategy to perform mean-reversion calculations.
    The z-score of each period is evaluated for a trading signal, which leads to the
    generation of market orders for execution at the opening of the next trading day.
    We performed a single backtest run as well as multiple runs with varying strategy
    parameters, plotting the resulting profits and losses to help us visualize the
    performance of our trading strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Backtesting involves a lot of research that merits literature of its own. In
    this chapter, we explored ten considerations for designing a backtest model. To
    help improve our models on a continuous basis, a number of algorithms can be employed
    in backtesting. We briefly discussed some of these: k-means clustering, k-nearest
    neighbors, classification and regression trees, 2k factorial design, and genetic
    algorithms.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn to perform predictions using machine learning.
  prefs: []
  type: TYPE_NORMAL
