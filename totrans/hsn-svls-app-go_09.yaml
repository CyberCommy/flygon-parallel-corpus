- en: Building the Frontend with S3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to build a static website that consumes API Gateway responses using AWS
    Simple Storage Service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to optimize the access to your website assets such as JavaScript, CSS, images
    with CloudFront distribution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to set up a custom domain name for a serverless application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create an SSL certificate to show your content with HTTPS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating the deployment process of the web application using a CI/CD pipeline.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before proceeding with this chapter, you should have a basic understanding of
    web development and knowledge of how DNS works. The code bundle for this chapter
    is hosted on GitHub at [https://github.com/PacktPublishing/Hands-On-Serverless-Applications-with-Go](https://github.com/PacktPublishing/Hands-On-Serverless-Applications-with-Go).
  prefs: []
  type: TYPE_NORMAL
- en: Single Page Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn how to build a web application that will call
    the API Gateway invocation URL that we built in previous chapters and list the
    movies, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/03e5c169-f346-4aa6-b14e-aa8e484514a3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For each movie, we will display its cover image and title. In addition, a user
    can filter the movies by their categories by clicking on the button to the right
    of Horror . Finally, to add a new movie to the database, a modal will pop up if
    the user clicks on the New button on the navigation bar. The modal will ask the
    user to fill in the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/52d23b4d-2387-4b89-b66a-31f1b0bc0b67.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that the application mock-ups are defined, we will use a JavaScript framework
    to build the web application quickly. For example, I will be using **Angular 5**,
    which is currently the latest stable version of Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Developing web applications with Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular is a fully-integrated framework developed by Google. It allows you to
    build dynamic web applications without thinking about which libraries to select
    and how to deal with everyday problems. Keep in mind that the goal is to reach
    a large audience, Angular was chosen because it's one of the most commonly-used
    frameworks. However, it's up to you to choose whichever framework you're familiar
    with, such as React, Vue, or Ember.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to built-in ready-to-use modules, Angular leverages the power of
    the **Single Page Application** **(SPA)** architecture. This architecture allows
    you to navigate between pages without refreshing the browser, hence allowing a
    better user experience as the application is more fluid and responsive, including
    better performance (you can preload and cache extra pages).
  prefs: []
  type: TYPE_NORMAL
- en: Angular comes with its own CLI. You can install it by going to [https://cli.angular.io](https://cli.angular.io)
    for a step-by-step guide. This book is dedicated to Lambda. Hence, only the basic
    concepts of Angular are covered in the upcoming sections, to make this chapter
    easy to understand for those who aren't web developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the **Angular CLI** is installed, we need to create a new Angular application
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The CLI will generate the basic templates files and install all the required
    **npm** dependencies to run an Angular 5 application. The file structure looks
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc7d0c0d-e3c7-469e-af1b-bd5248fcea5e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, on the `frontend` directory, start a local web server with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will compile all the `TypeScripts` files, build the project, and
    start a web server on port `4200`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/38a446fd-123d-4aaf-ae92-912de1d9a18d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Open your browser and navigate to [http://localhost:4200](http://localhost:4200). This
    is what you should see in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3da4087e-5f28-4843-96d6-532f7b448647.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that our sample app is built and running, let's create our web application.
    The Angular structure is based on either a components and services architecture
    (similar to Model-View-Controller).
  prefs: []
  type: TYPE_NORMAL
- en: Generating your first Angular component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For those who haven''t had much experience with Angular, a component is basically
    a Lego brick for the UI. Your web application can be divided into multiple components.
    Each component has the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPONENT_NAME.component.ts**: The component-logic definition written in
    TypeScript'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**COMPONENT_NAME.component.html**: The HTML code of the component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**COMPONENT_NAME.component.css**: The CSS structure of the component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**COMPONENT_NAME.component.spec.ts**: The unit test of the component class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our example, we will need at least three components:'
  prefs: []
  type: TYPE_NORMAL
- en: The Navigation Bar component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The List of Movies component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Movie component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we create our first component, let's install **Bootstrap**, which is
    a frontend web framework developed by Twitter to build attractive user interfaces.
    It comes with a set of CSS-based design templates for forms, buttons, navigation,
    and other interface components, as well as optional JavaScript extensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and install Bootstrap 4 from your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, import the Bootstrap CSS classes in the `.angular-cli.json` file in order
    to make the CSS directives available in all components of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to create our navigation bar component by issuing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Override the HTML code generated by default in `navbar.component.html`to use
    the navigation bar provided by the Bootstrap framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `navbar.component.ts` and update the selector property to `movies-navbar`.
    The selector here is nothing but a tag that can be used to reference the component
    on other components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `movies-navbar` selector needs to be added in the `app.component.html`
    file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The Angular CLI uses live reload. Hence, every time our code is changed, the
    CLI will recompile, re-inject if needed, and ask the browser to refresh the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c6f1c45-5246-4dfb-a0b3-fbe06fdfe08a.png)'
  prefs: []
  type: TYPE_IMG
- en: When the `movies-navbar` tag is added, everything that is present in the `navbar.component.html`
    file of the new component will be displayed in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we will create a new component for the movie item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to display movies as cards in our interface; replace the `movie-item.component.html`
    code with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the browser, you should see something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7123f3d-1d1a-44b3-9d50-3afa01f7bc29.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create another component to display the list of movies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This component will use the Angular `ngFor` directive to iterate over `movie`
    in the `movies` array and print out the movie by calling the `movie-item` component
    (this is known as composition):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `movies` array is declared in`list-movies.component.ts` and initialized
    in the class constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Movie` class is a simple entity with three fields, namely, `name`, `cover`,
    and `description`, and getters and setters to access and modify the class attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding code, we will see three movies displayed in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5cd01aa8-7d2d-4026-90ac-d566046acdd9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By now, the movie attributes are hardcoded in the HTML page, in order to change
    that, we need to pass the movie item to the `movie-item` element. Update `movie-item.component.ts`
    to add a new movie field and use the `Input` annotation to use the Angular input
    binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the HTML template of the preceding component, use the getters of the `Movie`
    class to get the values of attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, make the `ListMoviesComponent` nest the `MovieItemComponent` child inside
    an `*ngFor` repeater, and bind the`movie` instance to the child''s `movie` property
    on each iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the browser, you should ensure that the movie''s attributes are properly
    defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/630275ba-4d91-40d0-a0d8-d402270dc7c9.png)'
  prefs: []
  type: TYPE_IMG
- en: Everything is going well so far. However, the movies list is still static and
    hardcoded. We will fix that by calling the serverless API to retrieve the list
    of movies dynamically from the database.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Rest web services with Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapters, we created two stages, the `staging` and `production`
    environments. Therefore, we should create two environment files to point to the
    right API Gateway deployment stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '`environment.ts`: Contains the development HTTP URL:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`environment.prod.ts`: Contains the production HTTP URL:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `environment` object will read the values from `environment.ts` if `ng build`
    or `ng serve` are executed, and read the values from `environment.prod.ts` if
    you build your application for production mode with the `ng build --prod` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a service, we need to make use of the command line. The command is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`movies-api.service.ts` will implement the `findAll` function, which will call
    the API Gateway `findAll` endpoint using the `Http` service. The `map` method
    will help convert the response to JSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Before calling `MoviesApiService`, it needs to be imported in the `app.module.ts` main
    module in the providers section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `MoviesListComponent` to call the new service. On the browser console,
    you should have an error message regarding the Access-Control-Allow-Origin header
    not being present in the  response returned by the API Gateway.That will be the
    topic of the upcoming section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/851f2f1c-7972-4bc7-bdc7-5f9b7f7a7bb5.png)'
  prefs: []
  type: TYPE_IMG
- en: Cross Origin Resource Sharing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For security purposes, the browser will block the flow if the external requests
    don't match the exact host, protocol, and port of your website. In our example,
    we have different domain names (localhost and API Gateway URL).
  prefs: []
  type: TYPE_NORMAL
- en: 'This mechanism is known as the **Same-origin policy**. To solve this problem,
    you can either use a CORS header, proxy server, or JSON workaround. In this section,
    I will demonstrate how we can use a CORS header in the response returned by the
    Lambda function to resolve this issue:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `findAllMovie` function''s code to add `Access-Control-Allow-Origin:*`to
    enable cross-origin requests from anywhere (or specify a domain instead of *):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Commit your changes; a new build should be triggered. At the end of the CI/CD
    pipeline, the `FindAllMovies` Lambda function''s code will be updated. Test it
    out; you should have the new key as part of the `headers` attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/07d58921-c7aa-4a90-b4c1-07eeb1c06fc0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you refresh the web application page, the JSON objects will be displayed
    in the console too:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c4214806-29e1-4105-98d1-f7c212456f0e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Update `list-movies.component.ts` to call the `findAll` function from `MoviesApiService`.
    The data returned will be stored in the `movies` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, the list of movies will be retrieved and displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/deeaef10-1459-4d94-ba8d-3ce1d7d111c0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We don''t have cover images; you can update the DynamoDB `movies` table to
    add an image and description attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/05553e5c-ccd9-442f-b0e1-340b1d1880ec.png)'
  prefs: []
  type: TYPE_IMG
- en: The NoSQL database allows you to alter the table schema at any time without
    having to first define the structure, while the relational database requires you
    to use predefined schemas to determine the structure of your data before you work
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you refresh the web-application page, you should have the movies with their
    corresponding description and poster cover:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/38fd8f1e-4d36-468e-baca-ea0ea6b6d55f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s improve this web application by implementing a new movie feature. As
    the user needs to fill in the movie''s image cover and description, we need to
    update the `insert` Lambda function to add a cover and description fields in addition
    to a random unique ID generated on the backend:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the new changes are pushed to the code repository and deployed, open your
    REST client and issue a POST request to add a new movie with the following JSON
    scheme:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/06a712ec-4680-4479-a7a0-0ff4dd8b9a4f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A `200` success code should be returned, and in the web application, the new
    movie should be listed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/604c09c6-c24d-4dae-916c-2e9d1cffd8ba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As seen in the *Single Page Application* section, when the user clicks on the
    New button, a modal will pop up with a creation form. In order to build this modal
    and to avoid using jQuery, we will use another library that provides a set of
    native Angular directives based on Bootstrap''s markup and CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install this library with the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, you need to import it into the main `app.module.ts` module,
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To hold the creation form, we need to create a new component:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This component will have two `input` fields for the movie''s title and cover
    link. Plus, a `textarea` element for the movie''s description:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Each time the user clicks on the Save button, a `save` function will be invoked
    in response to the click event. The `insert` function defined in the `MoviesApiService`
    service calls the `POST` method on the `insert` endpoint of the API Gateway:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a click event on the Newelement from the navigation bar:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The click event will call `newMovie` and open the modal by calling the `ModalService`
    module of the `ng-bootstrap` library:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Once these changes are compiled, click on the New item from the navigation
    bar, and the modal will pop up. Fill in the required fields and click on the Save
    button:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/e44877e8-d1ca-4658-9c42-39974e51867e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The movie will be saved in the database table. If you refresh the page, the
    movie will be in the list of movies displayed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/a92e0046-6172-4658-abb6-19d3781897f5.png)'
  prefs: []
  type: TYPE_IMG
- en: S3 static website hosting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our application has been created, let's deploy it to a remote server.
    Instead of maintaining a web server, such as Apache or Nginx in an EC2 instance,
    let's keep it serverless and use an S3 bucket with the S3 website-hosting feature
    enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an S3 bucket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started, create an S3 bucket either from the AWS console or with the
    following AWS CLI command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, build the web application for production mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `--prod` flag will generate an optimized version of the code and do additional
    build steps, such as JavaScript and CSS minification, dead code elimination, and
    bundling:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/322a7e1e-7bf4-4653-a81c-ea30977265c7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This will give you the `dist/` directory with `index.html` and all the bundled
    `js` files ready for production. Configure the bucket to host a website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy everything within the *dist/* folder into the S3 bucket we created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You can verify that the files have been successfully stored from the S3 bucket
    dashboard or with the `aws s3 ls` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba4ee6eb-461b-4b32-b183-62721b89b64a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By default, when you create an S3 bucket, it''s private. Hence, you should
    make it publicly accessible with the following bucket policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'On the bucket configuration page, click on the Permissions tab, then Bucket
    Policy, paste the policy content to the editor, and then Save it. A warning message
    will pop up indicating that the bucket has become public:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b07d05cc-d54b-4ed7-a076-8db8261c65f4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To access the web application, point your browser to [http://serverlessmovies.s3-website-us-east-1.amazonaws.com](http://serverlessmovies.s3-website-us-east-1.amazonaws.com) (replace
    this with your own bucket name):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce0b68f2-d681-4e91-bb0d-3341014dc12f.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that our application is deployed to production, let's create a custom domain
    name to have a user-friendly link to access the website. To route domain traffic
    to the S3 bucket, we will use **Amazon Route 53** to create an alias record that
    points into the bucket.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Route 53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are new to Route 53, create a new hosted zone with the domain name you
    own, as in the following image. You can either use an existing domain name or
    buy one from the Amazon registrar or an external DNS registrar, such as GoDaddy. Make
    sure to choose Public Hosted Zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b0d9e07c-47dc-4076-a2da-0d1b79f751a9.png)'
  prefs: []
  type: TYPE_IMG
- en: Once created, the `NS` and `SOA` records are created automatically for you.
    If you bought your domain name from AWS, you can skip this section. If not, you
    must change the nameservers record on the registrar you bought the domain name
    from. In this example, I bought the [http://serverlessmovies.com/](http://serverlessmovies.com/)[ domain
    name from GoDaddy, so on the domain name settings page, I have changed the nameservers
    to point to the `NS` record values provided by AWS, as follows:](http://serverlessmovies.com/)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/841ce75e-ea5f-4dc9-a242-19a701c61d99.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It may take a few minutes for the changes to propagate. Once it''s validated
    by the registrar, hop over to `Route 53` and create a new `A` alias record that
    points to the S3 website we created earlier by selecting the target S3 bucket
    from the drop-down list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1d24fc9d-79d0-4dbc-814f-3f1af412a9db.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When you''re finished, you''ll be able to open a browser, enter the name of
    your domain, and view your web application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c14323ae-631c-4a93-9724-5839221e9c21.png)'
  prefs: []
  type: TYPE_IMG
- en: Having a secure website can make a difference and make users trust your web
    application more, which is why, in the upcoming section, we will use a free SSL
    provided by AWS to show the content with `HTTPS` at your custom domain name.
  prefs: []
  type: TYPE_NORMAL
- en: Certificate Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can easily get an SSL certificate with **AWS Certificate Manager** **(ACM)**.
    Click on the Request a certificate button to create a new SSL certificate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2440c5ce-c1b2-4233-bfbc-42b7fe24561c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select Request a public certificateand add your domain name. You might also
    want to secure your subdomains by adding an asterisk:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8931642d-6d2c-423d-b287-0f63b7952fd2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Under both domain names, click on the Create record in Route 53 button. This
    will automatically create a `CNAME` record set in Route 53 with the given values,
    which ACM will then check in order to validate that you own those domains:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da7ccd6e-11a6-44a0-bef5-9d1036d6c1ba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once Amazon verifies that the domain name is yours, the certificate status
    will change from Pending validation to Issued:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6629d9fa-fbb7-43a4-a7f5-10f1c68b672b.png)'
  prefs: []
  type: TYPE_IMG
- en: However, we can't configure the S3 bucket to use our SSL to encrypt the traffic.
    That's why we will use a **CloudFront** distribution, also known as a CDN, in
    front of the S3 bucket.
  prefs: []
  type: TYPE_NORMAL
- en: CloudFront distribution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to using CloudFront to add SSL termination on the website, CloudFront
    is mostly used as a **Content Delivery Network** **(CDN)** to store static assets
    (such as HTML pages, images, fonts, CSS, and JavaScript) in multiple edge locations
    around the world, which results in faster downloads and within less response time.
  prefs: []
  type: TYPE_NORMAL
- en: 'That being said, navigate to CloudFront, and then create a new web distribution.
    Set the S3 website URL in the Origin Domain Name field and leave the other fields
    as the default. You may want to redirect the `HTTP` traffic to `HTTPS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b7c1a87b-b91d-4312-97dd-e7006fa3b72b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, select the SSL certificate we created in the *Certificate Manager* section
    and add your domain name to the Alternate Domain Names (CNAMEs) area:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e35d051d-c500-49ee-bdbe-60b5dde4ea99.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Save and wait a few minutes while CloudFront copies all the files
    to the AWS edge locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9709af60-4dd2-4963-b3aa-6dd5b70eb130.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the CDN is fully deployed, jump to the domain-name-hosted zone page and
    update the website record to point to the CloudFront distribution domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/01ecaef5-9cfb-466d-9572-b5919502ef19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you go to the URL again, you should be redirected to `HTTPS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82344bd0-45df-49a9-8b65-2215ddd6f002.png)'
  prefs: []
  type: TYPE_IMG
- en: Feel free to create a new `CNAME` record for the API Gateway URL. The record
    might be [https://api.serverlessmovies.com](https://api.serverlessmovies.com),
    which points to[https://51cxzthvma.execute-api.us-east-1.amazonaws.com/production/movies](http://51cxzthvma.execute-api.us-east-1.amazonaws.com/production/movies).
  prefs: []
  type: TYPE_NORMAL
- en: CI/CD workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our serverless application is deployed to production. However, to avoid doing
    the same steps over and over each time you implement a new functionality, we can
    create a CI/CD pipeline to automate the workflow described in the previous section.
    I opt for CircleCI as a CI server. However, you might use Jenkins or CodePipeline—make
    sure to read the previous chapters for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'As seen in the previous chapters, the pipeline should be defined in a template
    file. The following is an example of the pipeline used to automate the deployment
    process of the web app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The following steps will be executed in order:'
  prefs: []
  type: TYPE_NORMAL
- en: Checking out the changes from the code repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the AWS CLI, application npm dependencies, and the Angular CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the artifacts with the `ng build` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying over the artefacts to the S3 bucket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, all changes to your web application''s code will go through the pipeline
    and will be deployed automatically to production:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d1c29e1-1de2-410b-bff5-ba6ce1d90eca.png)'
  prefs: []
  type: TYPE_IMG
- en: API documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before finishing this chapter, we will go through how to create documentation
    for the serverless API we've built so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the API Gateway console, select the deployment stage that you''re interested
    in generating documentation for. In the following example, I chose the `production`
    environment. Then, click on the Export tab and click on the Export as Swagger section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/68a99745-c216-4fa1-ba0a-3d7851162a5c.png)'
  prefs: []
  type: TYPE_IMG
- en: Swagger is an implementation of the **OpenAPI**, which is a standard defined
    by the Linux Foundation on how to describe and define APIs. This definition is
    called the **OpenAPI specification document**.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can save the document in either a JSON or YAML file. Then, navigate to [https://editor.swagger.io/](https://editor.swagger.io/)
    and paste the content on the website editor, it will be compiled and an HTML page
    will be generated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c8796d5-7187-469e-be1b-263ab3498dac.png)'
  prefs: []
  type: TYPE_IMG
- en: The AWS CLI can also be used to export the API Gateway documentation with the
    `aws apigateway get-export --rest-api-id API_ID --stage-name STAGE_NAME --export-type
    swagger swagger.json` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'API Gateway and Lambda functions are similar to the serverless application.
    A CI/CD can be written to automate the generation of the documentation automatically
    each time a new endpoint or resource has been implemented on the API Gateway.
    The pipeline must implement the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an S3 bucket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable a static website feature on the bucket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Download the Swagger UI from [https://github.com/swagger-api/swagger-ui](https://github.com/swagger-api/swagger-ui)
    and copy the source code to S3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a DNS record ([docs.serverlessmovies.com](http://docs.serverlessmovies.com))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the `aws apigateway export` command to generate the Swagger definition file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the `spec` file to S3 with the `aws s3 cp` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To sum up, we have seen how to build a serverless API from scratch using multiple
    Lambda functions, as well as how to use API Gateway to create a unified API and
    dispatch the incoming requests to the right Lambda function. We resolved the Lambda's
    stateless issue with a DynamoDB datastore and looked at how the use of reserved
    concurrency can help protect downstream resources. Then, we hosted a serverless
    web application in an S3 bucket with CloudFront in front of it to optimize the
    delivery of the web assets. Finally, we learned how to route domain traffic to
    the web application using Route 53 and how to secure it with SSL termination.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure illustrates the architecture we''ve implemented so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1db81716-6ac1-4b45-bb1b-070252a8166d.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next chapter, we will improve the CI/CD workflow to add unit and integration
    testing to catch bugs and issues before deploying Lambda functions to production.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implement a Lambda function that takes the movie category as input and returns
    a list of movies that correspond to that category.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a Lambda function that takes a movie's title as input and returns
    all movies that have the keyword in their title.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a delete button on the web application to delete a movie by calling
    the `DeleteMovie` Lambda function from API Gateway.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement an edit button on the web application to allow the user to update
    movie attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a CI/CD workflow with either CircleCI, Jenkins, or CodePipeline to
    automate the generation and deployment of the API Gateway documentation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
