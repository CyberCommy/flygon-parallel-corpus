- en: Chapter 11. Epilogue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our game finished, and after a quick foray into component based design,
    our introduction to procedural content generation is complete. We started simply
    with the generation and use of random numbers, and worked our way right up to
    creating complex procedural behaviors and content. We've touched upon many subjects,
    and hopefully working through this book has helped define what procedural generation
    is, and given some solid examples of how to approach and implement it in your
    games.
  prefs: []
  type: TYPE_NORMAL
- en: Before you close the book for the final time, let's take a quick look back at
    the project, identifying how and where we implemented procedural generation. We'll
    then reiterate its pros and cons one last time before finishing our work.
  prefs: []
  type: TYPE_NORMAL
- en: Project breakdown
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our game project started as a blank roguelike template with limited functionality,
    but with our work, we turned it into a fully fledged procedural roguelike game.
    Let's run through the project to identify how we used procedural generation to
    do so.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also identify some further possible exercises for each chapter if you
    wish to explore the topic in detail. The goal of this book was to introduce you
    to the fundamentals of the topic, so hopefully you can hit the ground running
    as you take this further.
  prefs: []
  type: TYPE_NORMAL
- en: Procedurally populating environments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We started by spawning game items randomly around the level. This involved the
    generation of random numbers within a given range and using those as tile indices
    and enumerator values. This was the first time we used random numbers and enumerators
    to select random values and items, which is a technique that we relied heavily
    on throughout the course of the book.
  prefs: []
  type: TYPE_NORMAL
- en: If you wished to take this further, you could have a look at how to bias the
    spawn location of items or limit it to certain areas of the map. So, for example,
    you can bias the spawn location in such a way that all the gems will tend to spawn
    to the right-hand side of the level, and all the gold to the left-hand side. While
    not immediately beneficial to our project, you can imagine how it might be useful
    in other situations. You may want all your enemies to spawn at a certain part
    of the level, or a certain item to spawn in a given area of the map. Gaining more
    control over your game levels will be very beneficial.
  prefs: []
  type: TYPE_NORMAL
- en: Creating unique and random game objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With our items now spread around the levels, we turned our attention to making
    them more random and unique. Instead of hardcoding item variables we generated
    them during runtime, making the objects more varied. We used this technique to
    create multiple object types from a single class, such as all potions coming from
    the same class.
  prefs: []
  type: TYPE_NORMAL
- en: To extend this further in the project, why not try adding some random armor
    and/or weapons? They can be dropped by the enemies and have random sprites and
    statistics. You can take the same approach that we took with potions and create
    an ambiguous class that can generate a vast range of possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Procedurally generating art
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we had a look at how to create art procedurally. We started
    with a simple approach by using SFML's built-in sprite modification functions
    and moved on to a more complex approach in which we rendered multiple sprite components
    together to create new, unique ones, giving the enemies random armor.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to learn more, you should have a look at how to create art completely
    from scratch. There are algorithms, such as Perlin and Simplex noise, that generate
    2D noise. These algorithms can be used as a base for a procedural texture. Start
    looking at such algorithms and take it from there.
  prefs: []
  type: TYPE_NORMAL
- en: Procedurally modifying audio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Procedurally generating audio is a complex task. Therefore, the work that we
    did in this chapter was somewhat brief and really limited to modifying the existing
    sound procedurally as opposed to their outright creation. As with art, SFML provides
    a range of functions to edit sounds, such as pitch and volume, which were used
    to give simple sounds some variance. We then created spatialized 3D sound using
    SFML's built-in audio functions, giving our game some depth.
  prefs: []
  type: TYPE_NORMAL
- en: Sound can be generated entirely procedurally, but it's a complex and difficult
    process and as such, it isn't very popular as compared to other procedural implementations.
    However, if you want to look into this further, you could perhaps start by creating
    single sounds and learn how a computer produces them. From here, it's a case of
    learning how to put these sounds together to create something appealing, and then
    generating a procedural algorithm to do so. It's not for the faint-hearted, that's
    for sure!
  prefs: []
  type: TYPE_NORMAL
- en: Procedural behavior and mechanics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Progressing from the simple use of random numbers and selecting values from
    enumerators, we implemented a much more sophisticated and meaty procedural system,
    giving the enemies a basic AI in the form of pathfinding. We implemented A* pathfinding,
    enabling the enemies to chase the player around the maze. We also created a system
    to generate random level goals, so now our player is periodically presented with
    a unique goal in return for a unique reward.
  prefs: []
  type: TYPE_NORMAL
- en: The game mechanics that we generated are rather simple, so why not have a go
    at generating some more complex ones yourself? You can give players an actual
    task that has to be completed in order to continue playing the game. Otherwise,
    if it was the AI work that captured your interest, you could build upon it, making
    the enemies smarter and more of a challenge. Maybe if they lose line of sight
    of the player they will stop chasing, or they try predict player movement to block
    you off instead of simply following.
  prefs: []
  type: TYPE_NORMAL
- en: Procedural dungeon generation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our pièce de résistance, we implemented procedural dungeon generation. Until
    this point levels were loaded from a text file, but we implemented a recursive
    backtracker algorithm to generate a maze and then added rooms to that maze to
    create more open areas. Thus, levels are now procedurally generated, and we can
    generate a new one with a single function call.
  prefs: []
  type: TYPE_NORMAL
- en: There are lots of ways to approach procedural dungeon generation, and a number
    of different algorithms that can be utilized for this. If this area interests
    you there's plenty of room to explore. Take a look at some alternate algorithms
    and experiment with the implementation. Try to generate some rooms with different
    characteristics, or add some environmental and aesthetic features to give a level
    more character.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A great resource for further reading is [http://weblog.jamisbuck.org/](http://weblog.jamisbuck.org/).
    The blog is a goldmine for everything related to maze generation and covers a
    number of algorithms. You should definitely check it out.
  prefs: []
  type: TYPE_NORMAL
- en: Component-based architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Procedural content generation revolves around flexibility and as such, I felt
    that touching upon component-based design would be a good way to end our work.
    Through component-based design, we can create a flexible code base whose inherent
    flexibility will make it easier to implement procedural systems.
  prefs: []
  type: TYPE_NORMAL
- en: We ran through the fundamentals of component-based design in this chapter and
    looked at a couple of isolated examples. A good exercise is to run through the
    project, moving it over to an entirely component-based approach. This will really
    get you familiar with the concept, and you'll be ready to use it in your next
    project.
  prefs: []
  type: TYPE_NORMAL
- en: The pros and cons of procedural generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the last time, let's have a look at the major pros and cons of using procedural
    generation in our games.
  prefs: []
  type: TYPE_NORMAL
- en: Pros
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It creates dynamic content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can save on memory usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It saves development time and money
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It creates a large variety of options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It increases replayability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You relinquish control*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be taxing on hardware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can feel repetitive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's hard to script set game events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It may generate unusable content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '* The amount of control that you will relinquish depends upon the quality of
    your algorithm. At the end of the day, you''re the one that writes the algorithm.
    Therefore, you can make it do what you want.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope that you found the content in this book useful. The goal was to introduce
    you to the vast topic that procedural generation is, and I felt that working with
    a real game was the best way to do that. We covered the key areas of development
    and identified ways to use procedural generation in each aspects. Hopefully, you
    now have enough knowledge to use it in your own games, and can undertake further
    reading to learn more about the areas that interest you the most.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, procedural generation isn't just one thing or one approach. It's the
    dynamic generation of content. There's no one right way to implement it, so experiment.
    Find new ways to create content dynamically and play with it. There's no wrong
    answer.
  prefs: []
  type: TYPE_NORMAL
- en: Happy programming!
  prefs: []
  type: TYPE_NORMAL
