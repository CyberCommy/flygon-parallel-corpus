- en: Chapter 11. Epilogue
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our game finished, and after a quick foray into component based design,
    our introduction to procedural content generation is complete. We started simply
    with the generation and use of random numbers, and worked our way right up to
    creating complex procedural behaviors and content. We've touched upon many subjects,
    and hopefully working through this book has helped define what procedural generation
    is, and given some solid examples of how to approach and implement it in your
    games.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Before you close the book for the final time, let's take a quick look back at
    the project, identifying how and where we implemented procedural generation. We'll
    then reiterate its pros and cons one last time before finishing our work.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Project breakdown
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our game project started as a blank roguelike template with limited functionality,
    but with our work, we turned it into a fully fledged procedural roguelike game.
    Let's run through the project to identify how we used procedural generation to
    do so.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: We'll also identify some further possible exercises for each chapter if you
    wish to explore the topic in detail. The goal of this book was to introduce you
    to the fundamentals of the topic, so hopefully you can hit the ground running
    as you take this further.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Procedurally populating environments
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We started by spawning game items randomly around the level. This involved the
    generation of random numbers within a given range and using those as tile indices
    and enumerator values. This was the first time we used random numbers and enumerators
    to select random values and items, which is a technique that we relied heavily
    on throughout the course of the book.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: If you wished to take this further, you could have a look at how to bias the
    spawn location of items or limit it to certain areas of the map. So, for example,
    you can bias the spawn location in such a way that all the gems will tend to spawn
    to the right-hand side of the level, and all the gold to the left-hand side. While
    not immediately beneficial to our project, you can imagine how it might be useful
    in other situations. You may want all your enemies to spawn at a certain part
    of the level, or a certain item to spawn in a given area of the map. Gaining more
    control over your game levels will be very beneficial.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Creating unique and random game objects
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With our items now spread around the levels, we turned our attention to making
    them more random and unique. Instead of hardcoding item variables we generated
    them during runtime, making the objects more varied. We used this technique to
    create multiple object types from a single class, such as all potions coming from
    the same class.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: To extend this further in the project, why not try adding some random armor
    and/or weapons? They can be dropped by the enemies and have random sprites and
    statistics. You can take the same approach that we took with potions and create
    an ambiguous class that can generate a vast range of possibilities.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Procedurally generating art
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we had a look at how to create art procedurally. We started
    with a simple approach by using SFML's built-in sprite modification functions
    and moved on to a more complex approach in which we rendered multiple sprite components
    together to create new, unique ones, giving the enemies random armor.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: If you want to learn more, you should have a look at how to create art completely
    from scratch. There are algorithms, such as Perlin and Simplex noise, that generate
    2D noise. These algorithms can be used as a base for a procedural texture. Start
    looking at such algorithms and take it from there.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Procedurally modifying audio
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Procedurally generating audio is a complex task. Therefore, the work that we
    did in this chapter was somewhat brief and really limited to modifying the existing
    sound procedurally as opposed to their outright creation. As with art, SFML provides
    a range of functions to edit sounds, such as pitch and volume, which were used
    to give simple sounds some variance. We then created spatialized 3D sound using
    SFML's built-in audio functions, giving our game some depth.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Sound can be generated entirely procedurally, but it's a complex and difficult
    process and as such, it isn't very popular as compared to other procedural implementations.
    However, if you want to look into this further, you could perhaps start by creating
    single sounds and learn how a computer produces them. From here, it's a case of
    learning how to put these sounds together to create something appealing, and then
    generating a procedural algorithm to do so. It's not for the faint-hearted, that's
    for sure!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Procedural behavior and mechanics
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Progressing from the simple use of random numbers and selecting values from
    enumerators, we implemented a much more sophisticated and meaty procedural system,
    giving the enemies a basic AI in the form of pathfinding. We implemented A* pathfinding,
    enabling the enemies to chase the player around the maze. We also created a system
    to generate random level goals, so now our player is periodically presented with
    a unique goal in return for a unique reward.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: The game mechanics that we generated are rather simple, so why not have a go
    at generating some more complex ones yourself? You can give players an actual
    task that has to be completed in order to continue playing the game. Otherwise,
    if it was the AI work that captured your interest, you could build upon it, making
    the enemies smarter and more of a challenge. Maybe if they lose line of sight
    of the player they will stop chasing, or they try predict player movement to block
    you off instead of simply following.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Procedural dungeon generation
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our pièce de résistance, we implemented procedural dungeon generation. Until
    this point levels were loaded from a text file, but we implemented a recursive
    backtracker algorithm to generate a maze and then added rooms to that maze to
    create more open areas. Thus, levels are now procedurally generated, and we can
    generate a new one with a single function call.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: There are lots of ways to approach procedural dungeon generation, and a number
    of different algorithms that can be utilized for this. If this area interests
    you there's plenty of room to explore. Take a look at some alternate algorithms
    and experiment with the implementation. Try to generate some rooms with different
    characteristics, or add some environmental and aesthetic features to give a level
    more character.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A great resource for further reading is [http://weblog.jamisbuck.org/](http://weblog.jamisbuck.org/).
    The blog is a goldmine for everything related to maze generation and covers a
    number of algorithms. You should definitely check it out.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Component-based architecture
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Procedural content generation revolves around flexibility and as such, I felt
    that touching upon component-based design would be a good way to end our work.
    Through component-based design, we can create a flexible code base whose inherent
    flexibility will make it easier to implement procedural systems.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: We ran through the fundamentals of component-based design in this chapter and
    looked at a couple of isolated examples. A good exercise is to run through the
    project, moving it over to an entirely component-based approach. This will really
    get you familiar with the concept, and you'll be ready to use it in your next
    project.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: The pros and cons of procedural generation
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the last time, let's have a look at the major pros and cons of using procedural
    generation in our games.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Pros
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It creates dynamic content
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can save on memory usage
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It saves development time and money
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It creates a large variety of options
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It increases replayability
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它增加了可重复性
- en: Cons
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺点
- en: You relinquish control*
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您放弃控制*
- en: It can be taxing on hardware
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能会对硬件造成负担
- en: It can feel repetitive
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能会感觉重复
- en: It's hard to script set game events
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很难编写游戏事件的脚本
- en: It may generate unusable content
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能会生成无法使用的内容
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '* The amount of control that you will relinquish depends upon the quality of
    your algorithm. At the end of the day, you''re the one that writes the algorithm.
    Therefore, you can make it do what you want.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*您放弃的控制量取决于您的算法质量。最终，你是写算法的人。因此，你可以让它做你想要的事情。'
- en: Summary
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: I hope that you found the content in this book useful. The goal was to introduce
    you to the vast topic that procedural generation is, and I felt that working with
    a real game was the best way to do that. We covered the key areas of development
    and identified ways to use procedural generation in each aspects. Hopefully, you
    now have enough knowledge to use it in your own games, and can undertake further
    reading to learn more about the areas that interest you the most.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你觉得这本书中的内容有用。目标是向您介绍程序生成的广泛主题，我觉得与真实游戏一起工作是最好的方法。我们涵盖了开发的关键领域，并确定了在每个方面使用程序生成的方法。希望现在您已经有足够的知识来在自己的游戏中使用它，并且可以进行进一步阅读，了解更多您最感兴趣的领域。
- en: Remember, procedural generation isn't just one thing or one approach. It's the
    dynamic generation of content. There's no one right way to implement it, so experiment.
    Find new ways to create content dynamically and play with it. There's no wrong
    answer.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，程序生成不仅仅是一种方法或一种途径。它是内容的动态生成。没有一种正确的实现方式，所以要进行实验。找到新的动态创建内容的方法并进行尝试。没有错误的答案。
- en: Happy programming!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 愉快的编程！
