- en: Displaying, Looping, Searching, and Filtering Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Chapter 1, *Getting Started with Vue.js*, we covered the `data`, `computed`, and
    `method` objects within Vue and how to display static data values. In this chapter,
    were are going to cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying lists and more complex data with Vue using `v-if`, `v-else`, and `v-for`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering the lists using form elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying conditional CSS classes based on the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The data we are going to be using is going to be randomly generated by the
    JSON generator service ([http://www.json-generator.com/](http://www.json-generator.com/)).
    This website allows us to get dummy data to practice with. The following template
    was used to generate the data we will be using. Copy the following into the left-hand
    side to generate data of the same format so the attributes match with the code
    examples, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Before we get into building our simple app and displaying our users, we'll cover
    some more of the features of Vue and the HTML-specific attributes available in
    your view. These range from dynamically rendering content to looping through arrays.
  prefs: []
  type: TYPE_NORMAL
- en: HTML declarations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vue allows you to use HTML tags and attributes to control and alter the view
    of your application. This involves setting attributes dynamically, such as `alt`
    and `href`. It also allows you to render tags and components based on data in
    the application. These attributes begin with a `v-` and, as mentioned at the beginning
    of this book, get removed from the HTML on render. Before we start outputting
    and filtering our data, we'll run through a few of the common declarations.
  prefs: []
  type: TYPE_NORMAL
- en: v-html
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `v-html` directive allows you to output content without using the mustache-style
    curly bracket syntax. It can also be used if your output contains HTML tags –
    it will render the output as HTML instead of plain text. The value of the HTML
    attribute is that of the data key or computed function name:'
  prefs: []
  type: TYPE_NORMAL
- en: '**View**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your view app space, add the `v-html` attribute to an element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**JavaScript**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the JavaScript, set the `message` variable to a string which contains some
    HTML elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You should try and avoid adding HTML to your Vue instance, as it starts to mix
    up the View in the ViewModel and Model of our MVVM structure. There is also the
    danger you output an invalid HTML tag inside another. You should only use `v-html`
    with data you trust, because using it with an external API could be a security
    concern as it would allow the API to have control over your application. A potentially
    malicious API could use `v-html` to inject undesired content and HTML. Only use
    `v-html` with data you can fully trust.
  prefs: []
  type: TYPE_NORMAL
- en: Declarative rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regular HTML attributes, such as the `src` of the `<img>` tag, can be dynamically
    populated with Vue using the `v-bind:` attribute. This allows you to populate
    any existing attribute with data from your Vue application. This might be an image
    source or element ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `bind` option gets used by prepending the attribute you wish to populate.
    For example, if you wished to populate an image source with the value of a data
    key called `imageSource`, you would do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**View**:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an img tag in your view app space, with a dynamic `src` attribute, using
    `v-bind` and a variable called `imageSource`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**JavaScript**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a variable in your Vue JavaScript code called `imageSource`. Add the
    URL to the desired image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `v-bind:` attribute can be shortened to just `:`, so, for example, `v-bind:src`
    would become `:src`.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using custom HTML declarations, Vue allows you to render elements and contents
    conditionally based on data attributes or JavaScript declarations. These include
    `v-if`, for showing a container whether a declaration equates to true, and `v-else`,
    to show an alternative.
  prefs: []
  type: TYPE_NORMAL
- en: v-if
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most basic example of this would be the `v-if` directive – determining a
    value or function if the block should be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Create a Vue instance with a single `div` inside the view and a data key, `isVisible`,
    set to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: '**View**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start off with the view code as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**JavaScript**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the JavaScript, initialize Vue and create an `isVisible` data property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Right now, your Vue app would be displaying the contents of your element. Now
    add the `v-if` directive to your HTML element with the value of `isVisible`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon pressing save, your text should disappear. That is because the tag is
    being conditionally rendered based on the value, which is currently `false`. If
    you open up your JavaScript console and run the following code, your element should
    reappear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`v-if` doesn''t just work with Boolean true/false values. You can check whether
    a data property is equal to a specific string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: For example, the preceding code checks whether a selected data property is equal
    to the value of `yes`. The `v-if` attribute accepts JavaScript operators, so can
    check not equals, bigger, or less than.
  prefs: []
  type: TYPE_NORMAL
- en: The danger here is that your logic starts to creep into your View away from
    your ViewModel. To combat this, the attribute also takes functions as a value.
    The method can be as complicated as required but ultimately must return a `true`
    if you wish to show the code and a `false` if not. Bear in mind that if the function
    returns anything other than a false value (such as `0` or `false`) then the result
    will be interpreted as true.
  prefs: []
  type: TYPE_NORMAL
- en: 'This would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And your method could be as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If you don't wish to completely remove the element and only hide it, there is
    a more appropriate directive, `v-show`. This applies a CSS display property rather
    than manipulating the DOM – `v-show` is covered later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: v-else
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`v-else` allows you to render an alternative element based on the opposite
    of the `v-if` statement. If that results in `true`, the first element will be
    displayed; otherwise, the element containing `v-else` will.'
  prefs: []
  type: TYPE_NORMAL
- en: The element with `v-else` needs to directly follow the one containing `v-if`; otherwise,
    your application will throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: '`v-else` has no value and is placed within the element tag.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding the preceding HTML to your app space will only show one of the `<div>`
    elements – toggling the value in your console as we did earlier will reveal the
    other container. You can also use `v-else-if` should you wish to chain your conditions.
    An example of `v-else-if` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You might see me will be displayed if the `isVisible` variable equates to `false`,
    but the `otherVisible` variable equates to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: '`v-else` should be used sparingly as can be ambiguous and might lead to false
    positive situation.'
  prefs: []
  type: TYPE_NORMAL
- en: v-for and displaying our data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next HTML declaration means we can start displaying our data and putting
    some of these attributes into practice. As our data is an array, we will need
    to loop through it to display each element. To do this, we will use the `v-for`
    directive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate your JSON and assign it to a variable called `people`. During these
    examples, the generated JSON loop will be displayed in the code blocks as `[...]`.
    Your Vue app should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to start displaying each person''s name in our View as a bulleted
    list. This is where the `v-for` directive comes in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `v-for` loops through the JSON list and for every entry temporarily assigns
    it the `person` variable. We can then output the value or attributes of the variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `v-for` loop needs to be applied to the HTML element you want to be repeated,
    in this case, `<li>`. If you don''t have a wrapping element or don''t wish to
    use the HTML you can use the Vue `<template>` elements. These get removed at runtime
    while still creating a container for you to output the data with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The template tag also hides the contents until the app has initialized, which
    may be handy if your network is slow or your JavaScript takes a while to fire.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just leaving our view to output `{{ person }}` will create a long string of
    information, without any use to us. Update the output to target the `name` property
    of the `person` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Viewing the result in the browser should reveal a list of the user''s names.
    Update the HTML to list the users in a table showing their names, email addresses,
    and balance. Apply the `v-for` to the `<tr>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Add an extra cell to your table. This is going to display Active if they are
    active and Inactive if not, using the `isActive` property on the `person` object.
    This can be achieved in two ways – using the `v-if` directive or alternatively
    using a ternary `if`. Ternary ifs are in-line `if` statements that can be placed
    within the curly brackets of your View. We would use the `v-if` if we wanted to
    use HTML elements to apply some styling.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were using a ternary ''if'', the cell would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And if we opted for the `v-if` option with `v-else`, allowing us to use the
    HTML we wish, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This active element is a perfect example of where a Vue Component would be
    ideal – we''ll cover that in [Chapter 3](f611e841-86d6-4741-a792-d10f9c289358.xhtml),
    *Optimizing our App and Using Components to Display Data*. As an alternative that
    is more in keeping with our MVVM methodology, we could create a method, which
    returns the status text. This would tidy up our view and moves the logic to our
    app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Our method would then carry out the same logic as our view was:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Our table will now look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/34661335-a835-4887-9022-225f20db9fca.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating links using v-html
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step is to link the email address so that it is clickable for users
    viewing the list of people. In this instance, we need to concatenate strings by
    adding a `mailto:` before the email address.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first instinct is to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'But Vue doesn''t allow interpolation inside attributes. Instead, we must use
    the `v-bind` directive on the `href` attribute. This turns the attribute into
    a JavaScript variable, so any raw text must be written in quotes, and the concatenated
    with the desired variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note the addition of `v-bind:`, the single quotes and concatenation `+` identifier.
  prefs: []
  type: TYPE_NORMAL
- en: Format balance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we move on to filtering the users, add a method to correctly format
    the balance, prepending a currency symbol defined in the data object and ensuring
    there are two numbers after the decimal point. We can adapt our method from Chapter
    1, *Getting Started with Vue.js*,  to achieve this. Our Vue application should
    now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can utilize this new method in our View:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Format registered date
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The registered date field in the data is computer friendly, which is not very
    human-friendly to read. Create a new method titled `formatDate` that takes one
    parameter — similar to the `formatBalance` method previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want full customization of the display of your date, there are several
    libraries available, such as `moment.js`, that give you much more flexibility
    over the output of any date and time-based data. For this method, we are going
    to use a native JavaScript function, to `LocaleString()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'With the registered date, we pass it to the native `Date()` function so JavaScript
    knows to interpret the string as a date. Once stored in the registered variable,
    we return the object as a string with the `toLocaleString()` function. This function
    accepts a huge array of options (as outlined on MDN) to customize the output of
    your date. For now, we''ll pass it the locale we wish to display and use the defaults
    for that location. We can now utilize our method in the view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Each table row should now look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a53323a8-ebca-4641-8ee8-77a7ac252ead.png)'
  prefs: []
  type: TYPE_IMG
- en: Filtering our data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our data being listed out, we are now going to build filtering ability.
    This will allow a user to select a field to filter by and a text field to enter
    their query. The Vue application will then filter the rows as the user types.
    To do this, we are going to bind some form inputs to various values in the `data`
    object, create a new method, and use a new directive on the table rows; `v-show`.
  prefs: []
  type: TYPE_NORMAL
- en: Building the form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Start off by creating the HTML in your view. Create a `<select>` box with an
    `<option>` for each field you want to filter, an `<input>` for the query, and
    a pair of radio buttons – we'll use these to filter active and non-active users.
    Make sure the value attribute of each `<option>` reflects the key in the user
    data – this will save on code required and will make the purpose of the select
    box more obvious.
  prefs: []
  type: TYPE_NORMAL
- en: The data you are filtering by does not need to be displayed for our filtering
    to work, although a user experience consideration needs to come into play here.
    Would it make sense if a table row was being displayed without the data you're
    filtering it on?
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the form that will be used for filtering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This form includes a select box for selecting a field a filter by, an input
    box that would allow the user to enter a query to filter on, and a pair of radio
    buttons for when we wish to filter by active and non-active users. The imagined
    user flow is this: the user would select the field they wish to filter the data
    by and either enter their query or select the radio buttons. When the `isActive` (Active
    user) option is selected in the select box, the radio buttons will be displayed
    and the input box will be hidden. We have ensured the first radio button is selected
    by default to help.'
  prefs: []
  type: TYPE_NORMAL
- en: The filtering inputs do not need to be included in a form to work; however,
    it is good practice to retain semantic HTML, even in a JavaScript application.
  prefs: []
  type: TYPE_NORMAL
- en: Binding the inputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To bind inputs to a variable that can be accessed through your Vue instance
    requires an HTML attribute to be added to the fields and a corresponding key added
    to the `data` object. Create a variable in the `data` object for each of the fields
    so we can bind the form elements to them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The data object now has three additional keys: `filterField`, which will be
    used for storing the value of the dropdown; `filterQuery`, the placeholder for
    data entered into the textbox; and `filterUserState`, which allows us to store
    the radio button checkboxes.
  prefs: []
  type: TYPE_NORMAL
- en: Now there are data keys to utilize, we are able to bind form elements to them.
    Apply a `v-model=""` attribute to each form field, with the value of the data
    key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure the two radio buttons have exactly the same `v-model=""` attribute:
    this is so they can update the same value. To verify that it has worked, you can
    now output the data variables and get the value of the fields.'
  prefs: []
  type: TYPE_NORMAL
- en: Try outputting `filterField` or `filterQuery` and changing the fields.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: One thing you may notice if you were to output the `filterUserState` variable
    is it appears to be in working, But, it is not getting the actual results desired.
    The output of the variable would be `true` and `false`as set in the value attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'On closer inspection, the values are actually strings, rather than a Boolean
    value. A Boolean value is a hard `true` or `false`, `1` or `0`, which you can
    easily compare against, whereas a string would require exact checking on a hardcoded
    string. This can be verified by outputting the `typeof` variable that it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be resolved by binding the values of the radio buttons with the `v-bind:value` attribute.
    This attribute allows you to specify the value for Vue to interpret and can take
    Boolean, string, or object values. For now, we''ll pass it `true` and `false`,
    as we were already doing with the standard value attribute, but Vue will know
    to interpret it as Boolean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to show and hide the table rows based on these filters.
  prefs: []
  type: TYPE_NORMAL
- en: Showing and hiding Vue content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Along with `v-if` for showing and hiding content, you can also use the `v-show=""`
    directive. `v-show` is very similar to `v-if`; they both get added to the HTML
    wrapper and can both accept the same parameters, including a function.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between the two is `v-if` alters the markup, removing and adding
    HTML elements as required, whereas `v-show` renders the element regardless, hiding
    and showing the element with inline CSS styles. `v-if` is much more suited to
    runtime renders or infrequent user interactivities as it could potentially be
    restructuring the whole page. `v-show` is favorable when lots of elements are
    quickly coming in and out of view, for example, when filtering!
  prefs: []
  type: TYPE_NORMAL
- en: When using `v-show` with a method, the function needs to return just a `true`
    or `false`. The function has no concept of where it is being used, so we need
    to pass in the current person being rendered to calculate if it should be shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a method on your Vue instance titled `filterRow()` and inside, set it
    to `return true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The function takes one parameter, which is the person will we pass in from
    though from the HTML. In your view, add the `v-show` attribute to the `<tr>` element
    with `filterRow` as the value while passing in the person object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'As a simple test, return the `isActive` value to the person. This should instantly
    filter out anyone who is inactive, as their value will return `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Filtering our content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we have control over our people rows and some filter controls in our view,
    we need to make our filters work. We are already filtering by our `isActive` key,
    so the radio buttons will be the first to be wired up. We already have the value
    in a Boolean form for both the radio buttons values and the key we will be filtering
    by. For this filter to work, we need to compare the `isActive` key with the radio
    button's value.
  prefs: []
  type: TYPE_NORMAL
- en: If the `filterUserState` value is `true`, show users where `isActive` is `true`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `filterUserState` value is `false`, however, only show users where their
    `isActive` value is `false` as well
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This can be written in one line by comparing the two variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: On page load, no users will be shown as the `filterUserState` key is set to
    neither `true` nor `false`. Clicking one of the radio buttons will reveal the
    corresponding users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make the filter work only if the active user option is selected in the
    dropdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This code sets a variable to `true` as a default. We can then return the variable
    immediately and our row will show. Before returning, however, it checks the value
    of the select box and if is the desired value, will then filter by our radio buttons.
    As our select box is bound to the `filterField` value, as with the `filterUserState`
    variable, it updates while we interact with the app. Try selecting the Active
    user option in the select box and changing the radio buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to use the input query box when the active user option is
    not selected. We also want our query to be a *fuzzy* search — for example, to
    match words containing the search query rather than matching exactly. We also
    want it to be case insensitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: There are a few things we had to add to this method in order to work. The first
    step is to check that our select field has a value to begin the filtering. As
    the first option in our select field has a `value=""`, this equates to `false`.
    If this is the case, the method returns the default of `true`.
  prefs: []
  type: TYPE_NORMAL
- en: If it does have a value, it then goes to our original `if` statement. This checks
    on the specific value to see whether it matches `isActive` – if it does, it runs
    the code we wrote previously. If not, we start our alternate filtering. A new
    variable of `query` is established, which takes the value of the input and converts
    it to lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: The second variable is the data we are going to be filtering against. This uses
    the value of the select box, which is the field key on the person, to extract
    the value to filter with. This value is converted to a string (in the case of
    the date or balance), converted to lowercase and stored as the `field` variable.
    Lastly, we then use the `includes` function to check whether the field includes
    the query entered. If it does, we return `true` and the row is shown if; not,
    the row is hidden.
  prefs: []
  type: TYPE_NORMAL
- en: The next issue we can address is when filtering with numbers. It is not intuitive
    for the user to enter the exact balance of the user they are after — a much more
    natural way of searching is to find users with a balance under or over a certain
    amount, for example, `< 2000`.
  prefs: []
  type: TYPE_NORMAL
- en: The first step in doing this is to only apply this type of filtering when it
    is the `balance` field. We can approach this two ways – we can either check that
    the field name is `balance`, similar to how we check the `isActive` field, or
    we can check the type of data we are filtering on.
  prefs: []
  type: TYPE_NORMAL
- en: Checking against the field name is simpler. We can do an `else if()`  in our
    method or even migrate to a `switch` statement for easier reading and expansion.
    The alternative of checking the field type, however, is more scalable. It means
    we can expand our dataset with more numeric fields without having to extend or
    change our code. It does mean, however, that there will be further `if` statements
    in our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we will do first is alter our storing method, as we don''t want to necessarily
    lowercase the field or query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to establish the type of data in the field variable. This
    can be established by, once again, using the `typeof` operator. This can be used
    in an `if` statement, to check whether the type of field is a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Once our check is complete, we can default back to our original query code.
    It will use this if the select option *is not* `isActive` and the data were are
    filtering on *is not* a number. If this is the case, then it will lowercase the
    field and see if it includes what has been written in the query box when converted
    to lowercase as before.
  prefs: []
  type: TYPE_NORMAL
- en: The next stage is to actually compare our numbered data against what has been
    written in the query box. To do this, we are going to use the native JavaScript
    `eval` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `eval` function can be a potentially dangerous function and should not
    be used in production code without some serious input sanitizing checks, plus,
    it is less performant than lengthier alternatives. It runs everything inside as
    native JavaScript and so can be open to abuse. However, as we are using this for
    a dummy application, with the focus being on Vue itself rather than creating a
    fully web-safe application, it is fine in this instance. You can read more about
    `eval` in 24 ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This passes both the field and the query to the `eval()` function and passes
    the result (either `true` or `false`) to our `result` variable to determine the
    visibility of the row. The `eval` function literally evaluates the expression
    and determines if it is `true` or `false`. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the number `500` is our field, or in this specific example,
    `balance`. Anything that is after that is what is written by our user. Your filtering
    code is now ready to go. Try selecting the balance from the dropdown and filtering
    for users with a balance higher than `2000`.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on, we need to add some error checking. If you have your JavaScript
    console open, you may have noticed an error when you typed the first greater or
    less than. This was because the `eval` function is unable to evaluate `X >` (where
    `X` is the balance). You may have also been tempted to type `*$2000*` with the
    currency and realized this doesn't work. This is because the currency is applied
    while rendering the view, whereas we are filtering the data before this is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: In order to combat these two errors, we must remove any currency symbols typed
    in the query and test our `eval` function before relying on it to return the results.
    Remove the currency symbol with the native JavaScript `replace()` function. If
    it changes, uses the currency symbol stored in the app, rather than hardcoding
    the currently used one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to test the `eval` function so it does not throw an error with
    every key pressed. To do this, we use a `try...catch` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'As we don''t want to output anything when an error is entered, we can leave
    the `catch` statement empty. We could put the `field.includes(query)` statement
    in here, so it falls back to the default functionality. Our full `filterRow()`
    method now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Filtering our filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we have our filtering in place, we need to only show the radio buttons when
    the `isActive` option is selected in our dropdown. Using the knowledge we've learned,
    this should be relatively straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new method that checks the select box value and returns `true` when
    Active User is selected in our dropdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use `v-show` for both the input and radio buttons, reversing the
    effect when on the query box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Take note of the exclamation point before the method call on the input field.
    This means not, and effectively reverses the result of the function, for example
    not true is the same as false and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'To improve user experience, we can also check that the filtering is active
    at all before showing either of the inputs. This can be added by including a secondary
    check in our `v-show` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This now checks that `filterField` has a value and that the select box is not
    set to `isActive`. Make sure you add this to the radio buttons too.
  prefs: []
  type: TYPE_NORMAL
- en: 'A further user experience enhancement would be to ensure all the users don''t
    disappear when the `isActive` option is chosen. This currently happens because
    the default is set to a string, which does not match with either the `true` or
    `false` values of the field. Before filtering in this field, we should check that
    the `filterUserState` variable is either `true` or `false`, that is a Boolean.
    We can do this by using `typeof` once more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We are using a ternary operator to check that the result to filter on is `boolean`.
    If it is, then filter as we were; if it is not then simply show the row.
  prefs: []
  type: TYPE_NORMAL
- en: Changing CSS classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with any HTML attribute, Vue is able to manipulate CSS classes. As with everything
    in Vue, this can be done in a myriad of ways ranging from attributes on the object
    itself to utilizing methods. We'll start off adding a class if the user is active.
  prefs: []
  type: TYPE_NORMAL
- en: Binding a CSS class is similar to other attributes. The value takes an object
    that can calculate logic from within the view or be abstracted out into our Vue
    instance. This all depends on the complexity of the operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s add a class to the cell containing the `isActive` variable if
    the user is active:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The class HTML attribute is first prepended by `v-bind:` to let Vue know it
    needs to process the attribute. The value is then an object, with the CSS class
    as the key and the condition as the value. This code toggles the `active` class
    on the table cell if the `person.isActive` variable equates to `true`. If we wanted
    to add an `inactive` class if the user was not active, we could add it to the
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Here's we've used the exclamation point again to reverse the status. If you
    run this app, you should find the CSS classes applied as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we''re just applying two classes based on one condition, a ternary `if`
    statement can be used inside of the class attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Note the single quotes around the class names. Once again, however, logic has
    started to creep into our View and, should we wish to also use this class elsewhere,
    is not very scalable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new method on our Vue instance called `activeClass` and abstract the
    logic into that — not forgetting to pass the person object in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now call that method in our view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: I appreciate this is quite a simple execution; let's try a slightly more complex
    one. We want to add a conditional class to the balance cell depending on the value.
    If their balance is under $2000, we will add an `error` class. If it is between
    $2000 and $3000, a `warning` class will be applied and if it is over $3000 a `success`
    class will be added.
  prefs: []
  type: TYPE_NORMAL
- en: Along with the `error`, `warning` and `success` classes, a class of `increasing`
    will be added if the balance is over $500\. For example, a balance of $2,600 will
    get both the `warning`, and `increasing` classes, whereas $2,400 would only receive
    the `warning` class.
  prefs: []
  type: TYPE_NORMAL
- en: As this contains several bits of logic, we will create a use a method in our
    instance. Create a `balanceClass` method and bind it to the class HTML attribute
    of the cell containing the balance. To begin with, we'll add the `error`, `warning`
    and `success` classes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In the method, we need to access the `balance` property of the person passed
    in and return the name of the class we wish to add. For now, we''ll return a fixed
    result to verify that it''s working:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to evaluate our balance. As it''s already a number, comparing it
    against our criteria won''t involve any conversions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding method, the class output gets set to `success` by default,
    as we only need to change the output if it is less than `3000`. The first `if`
    checks whether the balance is below our first threshold – if it does, it sets
    the output to `error`. If not, it tries the second condition, which is to check
    whether the balance is below `3000`. If successful, the class applied becomes
    `warning`. Lastly, it outputs the chosen class, which applies directly to the
    element.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to consider how we can do the `increasing` class. To get it to
    output alongside the existing `balanceLevel` class, we need to convert the output
    from a single variable to an array. To verify that this works, hardcode the extra
    class to the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This adds the two classes to the element. Convert the string to a variable and
    set to `false` by default. Vue won't output anything for a `false` value passed
    in the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'To work out if we need the increasing class, we need to do some calculations
    on the balance. As we want the increasing class if the balance is above 500 no
    matter what range it is in, we need to round the number and compare:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Initially, we set the `increasing` variable to `false` as a default. We also
    store a version of the balance divided by `1000`. The means our balances turn
    out to be 2.45643 instead of 2456.42\. From there, we compare the number after
    it has been rounded by JavaScript (For example 2.5 becomes 3, whereas 2.4 becomes
    2) to the number that has been forced to round up (example 2.1 becomes 3, along
    with 2.9).
  prefs: []
  type: TYPE_NORMAL
- en: 'If the number output is the same, the `increasing` variable is set to the string
    of the class we want to set. We can then pass this variable along with the `balanceLevel`
    variable out as an array. The full method now looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Filtering and custom classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now have a fully fledged user list/register that has filtering on selected
    fields and custom CSS classes depending on the criteria. To recap, this is what
    our view looks like now we have the filter in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'And the JavaScript for our Vue app should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'With a small amount of CSS, our people filtering app now looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/96fba2af-74a5-435c-9d2c-3425a29348cb.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at Vue HTML declarations, conditionally rendering
    our HTML and showing an alternative if required. We also put into practice what
    we learned about methods. Lastly, we built a filtering component for our table,
    allowing us to show active and inactive users, find users with specific names
    and emails, and filter out rows based on the balance.
  prefs: []
  type: TYPE_NORMAL
- en: Now we've got to a good point in our app, it's a good opportunity to take a
    look at our code to see if it can be optimized in any way. By optimizations, I
    mean reducing repetition, making the code simpler if possible, and abstracting
    logic out into smaller, readable, and reusable chunks.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](f611e841-86d6-4741-a792-d10f9c289358.xhtml), *Optimizing Our
    App and Using Components to Display Data*, we will optimize our code and look
    at Vue components as a way of separating out logic into separate segments and
    sections.
  prefs: []
  type: TYPE_NORMAL
