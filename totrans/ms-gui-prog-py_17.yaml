- en: Embedding Data Plots with QtCharts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The world is full of data. From server logs to financial records, sensor telemetry
    to census statistics, there seems to be no end to the raw data that programmers
    are tasked to sift through and extract meaning from. In addition to this, nothing
    distills a set of raw data into meaningful information as effectively as a good
    chart or graph. While there are some great charting tools such as `matplotlib`
    available for Python, PyQt offers its own `QtCharts` library, which is a simple
    toolkit for constructing charts, graphs, and other data visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to explore data visualization using `QtCharts`
    in the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Making a simple chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying real-time data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styling Qt charts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to the basic PyQt setup we''ve been using throughout the book,
    you will need to install PyQt support for the `QtCharts` library. This support
    is not part of the default PyQt install, but it can be easily installed from PyPI,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll also need the `psutil` library, which can be installed from PyPI. We
    already used this library in [Chapter 12](1a25e80a-2680-47f4-b309-782cf9b8580f.xhtml),
    *Creating 2D Graphics with QPainter,* so if you have been through that chapter,
    then you should already have it. If not, it can be easily installed using the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Finally, you may want to download the example code for this chapter from [https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter14](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter14).
  prefs: []
  type: TYPE_NORMAL
- en: Check out the following video to see the code in action: [http://bit.ly/2M5y67f](http://bit.ly/2M5y67f)
  prefs: []
  type: TYPE_NORMAL
- en: Making a simple chart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 12](1a25e80a-2680-47f4-b309-782cf9b8580f.xhtml), *Creating 2D Graphics
    with QPainter,* we created a CPU activity graph using the Qt graphics framework
    and the `psutil` library. While that approach to building a chart worked fine,
    it took a lot of work to create a rudimentary chart that lacked simple niceties
    such as axis labels, a title, or a legend. The `QtChart` library is also based
    on the Qt graphics framework, but simplifies the creation of a variety of feature-complete
    charts.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate how it works, we're going to build a more complete system monitoring
    program that includes several charts derived from data provided by the `psutil`
    library.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To begin our program, copy the Qt application template from [Chapter 4](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml),
    *Building Applications with QMainWindow,* to a new file called `system_monitor.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the application, we need to import the `QtChart` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re also going to need the `deque` class and the `psutil` library, just
    like we needed them in [Chapter 12](https://cdp.packtpub.com/mastering_gui_programming_with_python/wp-admin/post.php?post=37&action=edit#post_35), *Creating
    2D Graphics with QPainter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Our program will contain several charts, each in its own tab. So, we will create
    a tab widget in `MainWindow.__init__()` to hold all the charts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now that the main framework of the GUI is in place, we'll start creating our
    chart classes and adding them to the GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Building a disk usage chart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first chart we'll create is a bar chart for displaying the disk space used
    by each storage partition on the computer. Each detected partition will have a
    bar indicating what percentage of its space is being used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a class for the chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The class is subclassed from the `QtChart.QChartView` class; this subclass of
    `QGraphicsView` is a widget that can display `QChart` objects. Just like the Qt
    graphics framework, the `QtChart` framework is based on a model-view design. In
    this case, the `QChart` object is analogous to a `QGraphicsScene` object, which
    will be attached to the `QChartView` object for display.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our `QChart` object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `QChart` object receives a title but, otherwise, doesn't require a lot of
    configuration; notice that it says nothing about being a bar chart either. Unlike
    other charting libraries you may have used, the `QChart` object doesn't determine
    what kind of chart we're creating. It's simply a container for data plots.
  prefs: []
  type: TYPE_NORMAL
- en: The actual type of chart is determined by adding one or more **series** objects
    to the chart. A series represents a single set of plotted data on a chart. `QtChart`
    contains many series classes, all derived from `QAbstractSeries`, each of which represents
    a different kind of chart style.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of these classes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Class | Chart type | Useful for |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `QLineSeries` | Straight-line plot | Points sampled from continuous data
    |'
  prefs: []
  type: TYPE_TB
- en: '| `QSplineSeries` | Line plot, but with curves | Points sampled from continuous
    data |'
  prefs: []
  type: TYPE_TB
- en: '| `QBarSeries` | Bar chart | Comparing values by category |'
  prefs: []
  type: TYPE_TB
- en: '| `QStackedBarSeries` | Stacked bar chart | Comparing subdivided values by
    category |'
  prefs: []
  type: TYPE_TB
- en: '| `QPieSeries` | Pie chart | Relative percentages |'
  prefs: []
  type: TYPE_TB
- en: '| `QScatterSeries` | Scatter Plot | Collections of points |'
  prefs: []
  type: TYPE_TB
- en: A complete list of available series types can be found at [https://doc.qt.io/qt-5/qtcharts-overview.html](https://doc.qt.io/qt-5/qtcharts-overview.html).
    Our chart will be comparing disk usage percentages across multiple partitions,
    so the most sensible type of series to use from among these options seems to be
    the `QBarSeries` class. Each partition will be a *category* that will have a single
    value (the usage percentage) associated with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the `QBarSeries` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: After creating the series object, we can add it to our chart using the `addSeries()`
    method. As you might suspect from the name of this method, we can actually add
    multiple series to the chart, and they don't all need to be of the same type.
    We could, for example, combine a bar and line series in the same chart. In our
    case, though, we're only going to have one series.
  prefs: []
  type: TYPE_NORMAL
- en: 'To append data to our series, we have to create something called a **bar set**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Qt bar charts are designed to show data in categories, but also allow for different
    sets of data to be compared across those categories. For instance, if you wanted
    to compare the relative sales success of several of your company's products in
    various US cities, you could use the cities as your categories and create a bar
    set for each product.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, the categories are going to be the partitions on the system, and
    we have only one set of data that we want to see for each of those partitions
    – that is, the disk usage percent.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we''ll create a single bar set to append to our series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `QBarSet` constructor takes a single argument, which represents the label
    for the dataset. This `QBarSet` object is the object to which we're going to append
    our actual data.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s go ahead and retrieve that data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This code utilizes the `disk_partitions()` function of `pustil` to list all
    the writable partitions on the system (we aren't interested in read-only devices,
    such as optical drives, since their usage is irrelevant). For each partition,
    we use the `disk_usage()` function to retrieve a named tuple of information about
    disk usage. The `percent` property of this tuple contains the usage percentage
    of the disk, so we append that value to our bar set. We also append the device
    name of the partition to a list of partitions.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, our chart contains a data series and can display the bars for
    the data. However, it would be difficult to extract much meaning from the chart
    because there would be no **axes** labeling the data. To fix this, we need to
    create a couple of axis objects to represent the *x* and *y *axes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with the *x* axis, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`QtCharts` offers different types of axis objects to handle different approaches
    to organizing data. Our *x* axis is made up of categories—one for each partition
    found on the computer – so, we''ve created a `QBarCategoryAxis` object to represent
    the *x* axis. To define the categories used, we pass a list of strings to the `append()`
    method.'
  prefs: []
  type: TYPE_NORMAL
- en: It's important that the order of our categories matches the order in which data
    is appended to the bar set, since each data point is categorized according to
    its position in the series.
  prefs: []
  type: TYPE_NORMAL
- en: Once created, an axis has to be attached both to the chart and to the series;
    this is because the chart needs to know about the axis object so that it can properly
    label and scale the axis. This is accomplished by passing the axis object to the
    chart's `setAxisX()` method. The series also needs to know about the axis object
    so that it can scale the plots correctly for the chart, which we accomplish by
    passing it to the series object's `attachAxis()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our *y* axis represents a percentage, so we''ll need an axis type that handles
    values between `0` and `100`. We will use a `QValueAxis` object for this, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`QValueAxis` represents an axis that displays a scale of numeric values, and
    allows us to set an appropriate range for the values. Once created, we can attach
    it to both the chart and the series.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we can create an instance of our chart view object in `MainView.__init__()`
    and add it to the tab widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the application at this point, you should get a display of your
    partition usage percentages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a5c9d296-9255-447f-bb1a-c03e0f2da444.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Your display will look slightly different, depending on your OS and drive configurations.
    The preceding diagram looks pretty good, but one small improvement we can make
    is to actually put percentage labels on our bars so that readers can see the precise
    data values. This can be done back in `DiskUsageChartView.__init__()` by adding
    the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when we run the program, we get labeled bars, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fa104c14-f8df-45ab-8620-39906e58bc21.png)'
  prefs: []
  type: TYPE_IMG
- en: Well, it seems this author is due for a larger hard drive!
  prefs: []
  type: TYPE_NORMAL
- en: Displaying real-time data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have seen how easy it is to create a static chart, let's take a
    look at the process of creating a chart that updates in real time. Essentially,
    the process is the same, but we'll need to periodically update the chart's data
    series with fresh data. To demonstrate this, let's make a real-time CPU usage
    monitor.
  prefs: []
  type: TYPE_NORMAL
- en: Building a CPU usage chart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start our CPU monitor in a new class called `CPUUsageView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Just as we did with our disk usage chart, we're basing this class on `QChartView`
    and beginning the constructor by creating a `QChart` object. We've also defined
    a title, and, just as we did in [Chapter 12](1a25e80a-2680-47f4-b309-782cf9b8580f.xhtml),
    *Creating 2D Graphics with QPainter*, configured a number of data points to display
    at one time. We're going to do a lot more points this time, though, so that we
    can get a more detailed chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating the chart object, the next step is to create the series object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This time, we're using the `QSplineSeries` object; we could have also used `QLineSeries`,
    but the spline version will connect our data point using cubic spline curves for
    a smooth appearance, which is similar to what we achieved using Bezier curves
    in [Chapter 12](1a25e80a-2680-47f4-b309-782cf9b8580f.xhtml), *Creating 2D Graphics
    with QPainter*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to populate the series object with some default data, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we're creating a `deque` object to store the data points and filling
    it with zeros. We then append this data to our series by creating a list of `QPoint`
    objects from our `deque` object using a list comprehension. Unlike the `QBarSeries`
    class, data is appended directly to the `QSplineSeries` object; there is nothing
    analogous to the `QBarSet` class for line-based series.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our series is set up, let''s work on the axes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Because our data is mostly (*x*, *y*) coordinates, both our axes are `QValueAxis`
    objects. However, the value of our *x* axis coordinate is essentially meaningless
    (it's just the index of the CPU usage value in the `deque` object), so we'll hide
    those labels by setting the axis's `labelsVisible` property to `False`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this time, we passed the series object along with the axis when setting
    the chart's *x* and *y *axes with `setAxisX()` and `setAxisY`. Doing this automatically
    attaches the axis to the series as well, and saves us an extra method call for
    each axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we''re using curves here, we should make one appearance optimization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `QChartView` object's `renderHint` property can be used to activate **anti-aliasing**,
    which will improve the smoothness of the spline curves.
  prefs: []
  type: TYPE_NORMAL
- en: The basic framework for our chart is now complete; what we need now is a way
    to collect the data and update the series.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the chart data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our first step in updating our data is to create a method that calls `psutil.cpu_percent()`
    and updates the `deque` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: To update the chart, we only need to update the data in the series. There are
    a couple of ways to do this; for example, we could completely remove all the data
    in the chart and `append()` new values.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better approach is to `replace()` the values, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: First, we generate a new set of `QPoint` objects from our `deque` object using
    a list comprehension, and then pass the list to the series object's `replace()`
    method, which swaps out all the data. This method is somewhat faster than wiping
    out all the data and repopulating the series, although either approach works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the refresh method, we just need to call it periodically;
    back in `__init__()`, let''s add a timer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This timer will call `refresh_stats()` every `200` milliseconds, updating the
    series and, consequently, the chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in `MainView.__init__()`, let''s add our CPU chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can run the application and click on the CPU Usage tab to see a chart
    that is similar to the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/57289362-6e4b-409f-bd5a-6d2d74860221.png)'
  prefs: []
  type: TYPE_IMG
- en: Try doing some CPU-intensive tasks to generate some interesting data for the
    chart.
  prefs: []
  type: TYPE_NORMAL
- en: Panning and zooming around the chart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our refresh method being called five times a second, the data in this series
    is pretty detailed for such a small chart. A dense chart such as this one is something
    a user might like to explore in more detail. To implement this capability, we
    can take advantage of the `QChart` object's methods for panning and zooming around
    the chart image, and allow the user to get a better view of the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure interactive controls for the `CPUUsageView` class, we can override
    the `keyPressEvent()` method, just as we did in our game in [Chapter 12](1a25e80a-2680-47f4-b309-782cf9b8580f.xhtml), *Creating
    2D Graphics with QPainter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This code is similar to the code that we used in our tank game—we create a `dict`
    object to map key codes to callback functions, and then check our event object
    to see whether one of the mapped keys was pressed. If it was, then we call the
    `callback` method.
  prefs: []
  type: TYPE_NORMAL
- en: The first of these methods we've mapped is `QChart.scroll()`. `scroll()` takes
    *x* and *y *values and moves the chart within the chart view by that amount. Here,
    we've mapped the arrow keys to `lambda` functions, which scroll the chart appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: The other methods we've mapped are `zoomIn()` and `zoomOut()`. These do precisely
    what their names suggest, each zooming in or out by a factor of two. If we wanted
    to customize the amount of zoom, then we could alternately call the `zoom()` method,
    which takes a float value indicating the zoom factor.
  prefs: []
  type: TYPE_NORMAL
- en: If you run this program now, you should find that you can move the chart around
    using the arrow keys and zoom in or out using the angle brackets (remember to
    press *Shift* on most keyboards to get an angle bracket).
  prefs: []
  type: TYPE_NORMAL
- en: Styling Qt charts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As good as Qt charts look by default, let's face it—nobody wants to be stuck
    with defaults when it comes to style. Fortunately, `QtCharts` offers a wide variety
    of options for styling the different components of our visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: To explore these options, we're going to build a third chart to show physical
    and swap memory usage, and then style it to our own preferences.
  prefs: []
  type: TYPE_NORMAL
- en: Building the memory chart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start this chart view object just like we started the others in the
    previous sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This class starts in a similar way to our disk usage chart – by subclassing
    `QChartView`, defining a chart, defining a series, and then defining some bar
    sets. This time, however, we are going to use `QStackedBarSeries`. The stacked
    bar is just like the regular bar chart, except that each bar set is stacked vertically
    rather than placed side by side. This kind of chart is useful for displaying a
    series of relative percentages, which is exactly what we're going to display.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we're going to have two bar sets – one for physical memory usage
    and the other for swap memory usage, each as a percentage of the total memory
    (physical and swap). By using a stacked bar, the total memory usage will be represented
    by the bar height, while the individual segments will show the swap and physical
    components of that total.
  prefs: []
  type: TYPE_NORMAL
- en: 'To hold our data, we''ll once again set up a `deque` object with the default
    data and append the data to the bar sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, each data point in the `deque` object needs to have two values:
    the first for the physical data and the second for the swap. We''re representing
    this by using a two-tuple sequence for each data point.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step, once again, is to set up our axes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, like the CPU usage chart, our *x* axis just represents the somewhat meaningless
    index number of the data, so we're just going to hide the labels. Our *y* axis,
    on the other hand, represents a percentage, so we'll set its range from `0` to
    `100`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll create our `refresh` method to update the chart data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `psutil` library has two functions for examining memory usage: `virtual_memory()`,
    which returns information about the physical RAM; and `swap_memory()`, which returns
    information about the swap file usage. We're applying some basic arithmetic to
    find out the percentage of total memory (swap and physical) used by swap and physical
    memory. We then append this data to the `deque` object and iterate through it
    to replace the data in the bar sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we''ll add our timer back in `__init__()` to call the refresh method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The chart view class should now be fully functional, so let's add it to the
    `MainWindow` class and test it out.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, add the following code in `MainWindow.__init__()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: If you run the program at this point, you should have a working memory usage
    monitor that updates once per second. It's nice, but it looks too default-like;
    so, let's style things up a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Chart styling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To give our memory chart a healthy dose of individuality, let's head back up
    to `MemoryChartView.__init__()` and start adding in code to style the various
    elements of the chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the easiest, yet most interesting, changes that we can make is to activate
    the chart''s built-in animations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `QChart` object's `animationOptions` property determines which of the built-in
    chart animations will be run when the chart is created or updated. The options
    include `GridAxisAnimations`, which animate the drawing of the axes; `SeriesAnimations`,
    which animate updates to the series data; `AllAnimations`, which we've used here
    to activate both grid and series animations; and `NoAnimations`, which, as you
    might guess, is used to turn all the animations off (this is, of course, the default).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the program now, you''ll see that the grid and axes sweep into place
    and each bar pops up from the bottom of the chart in a smooth animation. The animations
    themselves are preset for each series type; note that we can''t do much to customize
    them other than set the easing curve and duration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've set the chart's `animationEasingCurve` property to a `QtCore.QEasingCurve`
    object with an *out bounce* easing curve. We've also slowed the animation time
    to a full second. If you run the program now, you'll see the animations bounce
    and last slightly longer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another simple tweak we can make is enabling the chart''s drop shadow, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Setting `dropShadowEnabled` to `True` will cause a drop shadow to be displayed
    around the chart's plot area, giving it a subtle 3D effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more dramatic change in appearance comes by setting the chart''s `theme`
    property, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Although this is called a chart theme, it mainly affects the colors used for
    the plots. Qt 5.12 ships with eight chart themes, which can be found at [https://doc.qt.io/qt-5/qchart.html#ChartTheme-enum](https://doc.qt.io/qt-5/qchart.html#ChartTheme-enum).
    Here, we've configured the *Brown Sand* theme, which will utilize earth tones
    for our data plots.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of our stacked bar chart, this means each part of the stack will
    get a different color from the theme.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another very noticeable change we can make is done by setting the chart''s
    background. This can be done by setting the `backgroundBrush` property to a custom
    `QBrush` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we've created a linear gradient and used it to create a `QBrush`
    object for the background (see [Chapter 6](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml),
    *Styling Qt Applications,* for more discussion on this).
  prefs: []
  type: TYPE_NORMAL
- en: 'The background also has a `QPen` object, which is used to draw the border around
    the plot area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the program at this point, you might find the text a little hard
    to read. Unfortunately, there isn''t an easy way to update the look of all the
    text in the chart at once – we need to do it piece by piece. We can start with
    the chart''s title text by setting the `titleBrush` and `titleFont` properties,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Fixing the rest of the text cannot be done through the `chart` object. For that,
    we need to look at styling the other objects in the chart.
  prefs: []
  type: TYPE_NORMAL
- en: Styling axes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The font and color of the labels used on the chart''s axes must be set through
    our axis''s objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've set the *y* axis font and color by using the `setLabelsFont()` and
    `setLabelsBrush()` methods, respectively. Note that we could set the *x* axis
    label font and color as well, but there isn't much point since we're not showing
    the *x *labels.
  prefs: []
  type: TYPE_NORMAL
- en: 'The axis objects also give us access to styling our grid lines, using the `gridLinePen`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''ve set up a dashed silver `QPen` object to draw the grid lines of
    our *x* and *y *axes. Incidentally, if you want to change how many grid lines
    are drawn on the chart, that can be done by setting the axis object''s `tickCount`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The default tick count is `5`, and the minimum is `2`. Note that this number
    includes the top and bottom lines, so to have a grid line at every 10 percent,
    we've set the axis to `11` ticks.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help users distinguish between tightly-packed grid lines, we can also enable
    **shades** on the axis object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, if you run the application, this causes every alternate region
    between the grid lines to be shaded according to the configured color rather than
    using the default background.
  prefs: []
  type: TYPE_NORMAL
- en: Styling the legend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final thing that we might want to fix in this chart is the **legend**. This
    is the part of the chart that explains which color goes with which bar set. The
    legend is represented by a `QLegend` object, which is automatically created and
    updated by the `QChart` object as we add bar sets or series objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can retrieve the chart''s `QLegend` object using the `legend()` accessor
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the legend doesn''t have a background and simply draws directly
    on the chart background. We can change that to improve readability, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We first turn on the background by setting `backgroundVisible` to `True` and
    then configuring a brush for the background by setting the `brush` property to
    a `QBrush` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The color and font of the text can also be configured, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We can set the label color using `setLabelColor()`, or use a brush for finer
    control using the `setLabelBrush()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can configure the shape of the markers that are used to indicate
    the colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The options here include `MarkerShapeCircle`, `MarkerShapeRectangle`, and `MarkerShapeFromSeries`,
    the last of which chooses a shape that is appropriate to the series being drawn
    (for example, a short line for line or spline plots, or a dot for scatter plots).
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, your memory chart should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/039075c6-d675-44f1-84d3-393b24627858.png)'
  prefs: []
  type: TYPE_IMG
- en: Not bad! Now, try your own color, brush, pen, and font values to see what you
    can create!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to visualize data using `QtChart`. You created
    a static table, an animated real-time table, and a fancy chart with custom colors
    and fonts. You also learned how to create bar charts, stacked bar charts, and
    spline charts.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to explore the use of PyQt on the Raspberry
    Pi. You'll learn how to install a recent version of PyQt and how to interface
    your PyQt applications with circuits and external hardware using the unique capabilities
    of the Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Try these questions to test your knowledge on this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following descriptions of datasets. Suggest a style of chart for
    each:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Web server hit counts by date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sales figures by salesperson per month
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The percentage of support tickets for the past year by a company department
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The yield of a plot of bean plants against the plant's height, for several hundred
    plants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which chart component has not been configured in the following code, and what
    will the result be?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: What's wrong with the following code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You want to create a bar chart comparing Bob and Alice''s sales figures for
    the quarter. What code needs to be added? Note that axes are not required here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Given a `QChart` object named `chart`, write some code so that the chart has
    a black background and blue data plots.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Style the other two charts in the system monitor script using the techniques
    you used for the `Memory Usage` chart. Experiment with different brushes and pens,
    and see whether you can find other properties to set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`QPolarChart` is a subclass of `QChart`, which allows you to construct a polar
    chart. Investigate the use of the polar chart in the Qt documentation and see
    whether you can create a polar chart of an appropriate dataset.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`psutil.cpu_percent()` takes an optional argument, `percpu`, which will create
    a list of values showing usage information per CPU core. Update your application
    to use this option and separately display each CPU core''s activity on one chart.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For further information, please refer to the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: The `QtCharts` overview can be found at [https://doc.qt.io/qt-5/qtcharts-index.html](https://doc.qt.io/qt-5/qtcharts-index.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More documentation on the `psutil` library can be found at [https://psutil.readthedocs.io/en/latest/](https://psutil.readthedocs.io/en/latest/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This guide from the University of California at Berkeley offers some guidelines
    for choosing the right kind of plot for different types of data: [http://guides.lib.berkeley.edu/data-visualization/type](http://guides.lib.berkeley.edu/data-visualization/type)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
