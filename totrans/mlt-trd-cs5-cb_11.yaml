- en: Chapter 11. There's More
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will look through a new programming paradigm in the Windows
    8 operating system. You will learn about:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a timer in a Windows Store application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using WinRT from a usual application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using BackgroundTask in a Windows Store application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microsoft released the first public beta build of Windows 8 at the BUILD conference
    on September 13, 2011\. The new OS tried to address almost every problem that
    Windows had by introducing features such as responsive UI suitable for tablet
    devices with touch, lower power consumption, new application model, new asynchronous
    APIs, and tighter security.
  prefs: []
  type: TYPE_NORMAL
- en: The core of Windows API improvements was a new multiplatform component system,
    **WinRT**, which is a logical development of COM. With WinRT, a programmer can
    use native C++ code, C# and .NET, and even JavaScript and HTML to develop applications.
    Another change is the introduction of a centralized application store, which did
    not exist on the Windows platform before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Being a new application platform, Windows 8 had backward-compatibility and
    allowed to run the usual Windows applications. This lead to a situation where
    there are two major classes of applications: the Windows Store applications, where
    new programs are distributed via the Windows Store, and the usual classic applications
    that did not change since the previous version of Windows.'
  prefs: []
  type: TYPE_NORMAL
- en: The Windows Store applications are what we are going to look at in this chapter.
    The development paradigm shifted very much, and as a programmer you have to comply
    with specific rules. The program has to respond in a limited time to start up
    or to finish, keeping the whole operating system and other applications responsive.
    To save the battery, your applications are no longer running in the background
    by default; instead of that they get suspended and actually stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: New Windows APIs are asynchronous, and you can use only white-listed API functions
    in your application. For example, you are not allowed to create a new `Thread`
    class instance anymore. You have to use a system-managed thread pool instead.
    A lot of usual APIs cannot be used anymore, and you have to study new ways to
    achieve the same goals as before.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will see how a Windows Store application is different from
    the usual Windows application, how we can use some of the WinRT benefits from
    the usual applications, and go through a simplified scenario of a Windows Store
    application with background notifications.
  prefs: []
  type: TYPE_NORMAL
- en: Using a timer in a Windows Store application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows how to use a simple timer in Windows Store applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2012 and the Windows
    8+ operating system. No other prerequisites are required. The source code for
    this recipe can be found at `7644_Code\Chapter11\Recipe1`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to use a timer in a Windows Store application, perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Blank App (XAML)** project under
    **Windows Store**.![How to do it...](img/7644OT_11_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In case you are asked to renew your developer license, you have to agree to
    the Microsoft privacy terms.![How to do it...](img/7644OT_11_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, sign in to your Microsoft account (or create one first).![How to do it...](img/7644OT_11_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, you get a confirmation dialog that the developer license was successfully
    renewed.![How to do it...](img/7644OT_11_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `MainPage.xaml` file, add the `Name` attribute to the `Grid` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `MainPage.xaml.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet above the `MainPage` constructor definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the `MainPage()` constructor with the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `OnNavigatedTo` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the program runs, it creates an instance of a `MainPage` class. Here we
    instantiate `DispatcherTimer` in the constructor, and initialize the `ticks` counter
    to zero. Then, in the `OnNavigatedTo` event handler, we create our UI controls
    and bind the start and stop buttons to the corresponding lambda expressions, which
    contain the `start` and `stop` logics.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `timer` event handler works directly with the UI controls.
    This is okay because `DispatcherTimer` is implemented in such a way that the handlers
    of the `Tick` event of `timer` are run by the UI thread. However, if you run the
    program and then switch to something else, and switch the to the program delete
    after a couple of minutes, you may notice that the seconds counter is far behind
    the real amount of time passed. This happens because Windows 8 applications, or
    Windows Store applications as they are usually referred to, have completely different
    lifecycles.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please be aware that Windows Store applications behave much like the applications
    on smartphone and tablet platforms. Instead of running in the background they
    become suspended after some time, and this means that they are actually frozen
    until the user switches back to them. You have a limited time to save the current
    application state before it becomes suspended, and you are able to restore the
    state when the applications run again.
  prefs: []
  type: TYPE_NORMAL
- en: While this behavior could save power and CPU resources, it creates significant
    difficulties to program applications that are supposed to do some processing in
    the background. Windows 8 has a set of special APIs for programming such applications.
    We will go through such a scenario later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Using WinRT from usual applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows how to create a console application that will be able to use
    the WinRT API.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2012 and the Windows
    8+ operating system. There are no other prerequisites. The source code for this
    recipe can be found at `7644_Code\Chapter11\Recipe2`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to use WinRT from usual applications, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the created project in Visual Studio **Solution Explorer** and
    select the **Unload Project…** menu option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the unloaded project and select the **Edit ProjectName.csproj**
    menu option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following XML below the `<TargetFrameworkVersion>` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Save the `.csproj` file, right-click on the unloaded project in Visual Studio
    **Solution Explorer**, and select the **Reload Project** menu option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the project and select **Add Reference** from the **Core** library
    under **Windows**. Then click on the **Browse** button.![How to do it...](img/7644OT_11_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `C:\Program Files\Reference Assemblies\Microsoft\Framework\.NETCore\v4.5`
    and click on `System.Runtime.WindowsRuntime.dll`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Program` class definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here we used quite a tricky way to consume the WinRT API from a common .NET
    console application. Unfortunately, not all available APIs will work in that scenario,
    but still it could be useful to work with movement sensors, GPS location services,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: To reference WinRT in Visual Studio we manually edit the `.csproj` file specifying
    the target platform for the application as Windows 8\. Then we manually reference
    `System.Runtime.WindowsRuntime.dll` to leverage the `GetAwaiter` extension method
    implementation for the WinRT asynchronous operations. This allows us to use `await`
    on WinRT APIs directly. There is a backward conversion as well. When we create
    a WinRT library, we have to expose the WinRT native `IAsyncOperation` interfaces
    family for asynchronous operations, so they could be consumed from JavaScript
    and C++ in a language-agnostic manner.
  prefs: []
  type: TYPE_NORMAL
- en: File operations in WinRT are quite self-descriptive; here we have asynchronous
    file create and delete operations. Still, file operations in WinRT contain security
    restrictions, encouraging you to use special Windows folders for your application,
    and not allowing you to work with just any file path on your disk drive.
  prefs: []
  type: TYPE_NORMAL
- en: Using BackgroundTask in Windows Store applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe walks through the process of creating a background task in a Windows
    Store application, which updates the application's live tile on a desktop.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2012 and the Windows
    8+ operating system. There are no other prerequisites. The source code for this
    recipe can be found at `7644_Code\Chapter11\Recipe3`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to use `BackgroundTask` in Windows Store applications, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Blank App (XAML)** project under
    **Windows Store**. In case you need to renew a developer license, please refer
    to the *Using a timer in a Windows Store application* recipe for detailed instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Assets** folder, open the **SmallLogo.png** file in the Paint editor,
    crop it to the 24 x 24 pixels size, save it back to the **Assets** folder as `SmallLogo-Badge.png`,
    and include it in the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `Package.appxmanifest` file. In the **Declarations** tab, add **Background
    Tasks** to **Supported Declarations**. Under **Properties**, check the supported
    properties **System event** and **Timer**, and set the name of **Entry point**
    to `YourNamespace.TileSchedulerTask`. `YourNamespace` should be the namespace
    of your application.![How to do it...](img/7644OT_11_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Application UI** tab, select **Lock screen notifications** as **Badge**,
    and **Badge logo** as **Assets\SmallLogo-Badge.png**.![How to do it...](img/7644OT_11_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `MainPage.xaml` file, insert the following XAML into the `Grid` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `MainPage.xaml.cs` file add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet above the `MainPage` constructor definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the `MainPage` constructor with the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet above the `OnNavigatedTo` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `OnNavigatedTo` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `MainPage` class definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The preceding program shows how to create a background time-based task, and
    how to show the updates from this task on a live tile on the Windows 8 start screen.
    Programming Windows Store applications is quite a challenging task itself—you
    have to care about an application suspending/restoring its state, and many other
    things. Here we are going to concentrate on our main task, leaving behind the
    secondary issues.
  prefs: []
  type: TYPE_NORMAL
- en: Our main goal is to run some code, when the application itself is not in the
    foreground. First, we create an implementation of the `IBackgroundTask` interface.
    This is our code, and the `Run` method will be called when we get a trigger signal.
    It is important that if the `Run` method contains asynchronous code with `await`
    in it, we have to use a special deferral object as shown in the recipe to explicitly
    specify when we begin and end the `Run` method execution. In our case, method
    call is synchronous, but to illustrate this requirement we work with the deferral
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Inside our task in the `Run` method, we create a set of tile updates each minute
    for 4 hours, and register it in `TileUpdateManager` with the help of the `ScheduledTaskNotification`
    class. A tile uses a special XML format to specify how exactly the text should
    be positioned on it. When we trigger our task from the system, it schedules one-minute
    tile updates for the next 4 hours. Then, we need to register our background task.
    We do it twice; one registration provides a `UserPresent` trigger, which means
    that this task will be triggered when a user is logged on. The next trigger is
    a time trigger, which runs the task once every 3 hours.
  prefs: []
  type: TYPE_NORMAL
- en: When the program runs, it creates a timer, which runs when the application is
    in the foreground. At the same time it is trying to register background tasks;
    to register those tasks the program needs user permission, and it will show a
    dialog requesting permissions from the user. Now we have scheduled live tile updates
    for the next 4 hours. If we close our application, the live tile will continue
    to show new time every minute. In the next 3 hours the time trigger will run our
    background task once again, and we will schedule another live tile update.
  prefs: []
  type: TYPE_NORMAL
