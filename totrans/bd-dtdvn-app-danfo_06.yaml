- en: '*Chapter 4*: **Data Analysis, Wrangling, and Transformation**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Data analysis**, **wrangling**, and **transformation** are important aspects
    of any data-driven project, and the majority of your time as a data analyst/scientist
    will be spent doing one form of data processing or the other. While JavaScript
    is a flexible language with good features for manipulating data structures, it
    is quite tedious to write utility functions to perform data wrangling operations
    all the time. As such, we have built powerful data wrangling and transformation
    features into Danfo.js, and this can greatly reduce the time that''s spent on
    this stage.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will show you how to practically use Danfo.js on real-world
    datasets. You'll learn how to load different types of datasets and analyze them
    by performing operations such as handling missing values, calculating descriptive
    statistics, performing mathematical operations, combining datasets, and performing
    string manipulations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Transforming data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining datasets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Series data accessors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating statistics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with this chapter, you should have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A modern browser such as Chrome, Safari, Opera, or Firefox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js, Danfo.js, and Dnotebook installed on your system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A stable internet connection for downloading datasets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The installation instructions for Danfo.js can be found in [*Chapter 3*](B17076_03_ePub_RK.xhtml#_idTextAnchor066),
    *Getting Started with Danfo.js*, while the installation steps for Dnotebook can
    be found in [*Chapter 2*](B17076_02_ePub_RK.xhtml#_idTextAnchor045), *Dnotebook
    – An Interactive Computing Environment for JavaScript*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you do not want to install any software or library, you can use the online
    version of Dnotebook at [https://playnotebook.jsdata.org/](https://playnotebook.jsdata.org/).
    However, don't forget to install the latest version of Danfo.js before using any
    functionality!
  prefs: []
  type: TYPE_NORMAL
- en: Transforming data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data transformation is the process of converting data from one format (master
    format) into another (target format) based on defined steps/processes. Data transformation
    can be simple or complex, depending on the structure, format, end goal, size,
    or complexity of the dataset, and as such, it is important to know the features
    that are available in Danfo.js for doing these transformations.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll introduce some features available in Danfo.js for doing
    data transformation. Under each sub-section, we'll introduce a couple of functions,
    including `fillna`, `drop_duplicates`, `map`, `addColumns`, `apply`, `query`,
    and `sample`, as well as functions for encoding data.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing missing values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many datasets come with missing values and in order to get the most out of these
    datasets, we must do some form of data filling/replacement. Danfo.js provides
    a `fillna` method that, when given a DataFrame or Series, can automatically fill
    any missing field with the specified value.
  prefs: []
  type: TYPE_NORMAL
- en: When you load a dataset into Danfo.js data structures, all the missing values,
    which can be undefined, empty, null, none, and so on, are stored as `NaN`, and
    as such, the `fillna` method can easily find and replace them.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing values in a Series
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The signature of the `fillna` method of a `Series` object is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `value` parameter is the new value you want to use for replacing missing
    values, while the `inplace` parameter is used to specify whether to make changes
    directly to the object or a copy. Let's look at an example of this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume we have the following Series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In your Dnotebook environment, `table(sdata)` will display the table shown
    in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Series with missing values'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – Series with missing values
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are working in a browser or the Node.js environment, you can view the
    output of the `print` function in the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'To replace the missing values (`NaN`), we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the output gives us the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Series with missing values'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 – Series with missing values
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also fill missing values in place, that is, you can directly mutate
    the object, instead of creating a new one. This can be seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Filling in place can help reduce memory usage in scenarios where you are working
    with large DataFrames or Series.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing values in DataFrames
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `fillna` function can also be used to fill in missing values in a DataFrame.
    The signature of the `fillna` method of a DataFrame object is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'First, let''s understand the parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`columns`: The `columns` parameter is the array of column names that you want
    to fill.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`values`: The `values` parameter, which is also an array and must be the same
    size as `columns`, holds the corresponding values you want to replace with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inplace`: This specifies whether we should modify the current DataFrame or
    return a new one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume we have the following DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the code is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – DataFrame with missing values'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3 – DataFrame with missing values
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of filling in the missing values, there are two ways we can approach
    this. First, we can fill in all the missing fields with single values, as shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The code output is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Filling in all the missing values in a DataFrame with a single
    value'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 – Filling in all the missing values in a DataFrame with a single
    value
  prefs: []
  type: TYPE_NORMAL
- en: The majority of the time, when working with DataFrames, filling in all the missing
    values with the same field is not advisable or even useful, as you must take into
    consideration the fact that different fields have different types of values, which
    means the filling strategies will differ.
  prefs: []
  type: TYPE_NORMAL
- en: To handle such cases, we can specify a list of columns and their corresponding
    values to fill them, as we will show here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the same DataFrame we used in the previous example, we can specify the
    `Name` and `Count` columns and fill them with the `Apples` and `–99` values, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The code''s output is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Filling in the missing values in a DataFrame with specific values'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.5 – Filling in the missing values in a DataFrame with specific values
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Fill values such as -9, -99, and -999 are commonly used to indicate missingness
    in data analytics.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how to remove duplicates in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Removing duplicates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Duplicate fields are common scenarios when working with Series or columns in
    a DataFrame. For example, take a look at the Series in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The code''s output is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Series with duplicate fields'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.6 – Series with duplicate fields
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding figure, you can see that the value `10` occurs multiple times.
    If the need arises, you can easily drop/remove these duplicates with the `drop_duplicates`
    function. The signature of the `drop_duplicates` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `drop_duplicates` function has just two parameters, and the first parameter
    (`inplace`) is pretty self-explanatory. The second parameter, `keep`, can be used
    to specify which of the duplicates to keep. You can either keep the first or last
    duplicate in a Series. This helps preserve the structure and order or values in
    a Series after dropping duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see this in action. In the following code block, we are dropping all
    the duplicate values and keeping just the first occurrence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The code''s output is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Series after dropping duplicates with keep set to first'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.7 – Series after dropping duplicates with keep set to first
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the preceding output, you can see that the first value of the duplicates
    is kept while the others are dropped. In contrast, let''s set the `keep` parameter
    to `last` and watch the order of the fields change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The code''s output is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Series after dropping duplicates with keep set to last'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.8 – Series after dropping duplicates with keep set to last
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the last `10` and `20` duplicates fields are kept, and that the
    order is different from when we set `keep` to `first`. The following figure will
    help you understand the `keep` parameter when dropping duplicates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Difference between the output when keep is set to first or last'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.9 – Difference between the output when keep is set to first or last
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding figure, you'll observe that the major difference between
    setting `keep` to `first` or `last` is the order of the resulting values.
  prefs: []
  type: TYPE_NORMAL
- en: In the next sub-section, we'll look at data transformation with the `map` function.
  prefs: []
  type: TYPE_NORMAL
- en: Data transformation with the map function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some cases, you may want to apply a transformation to each value in a Series
    or DataFrame column. This is usually useful when you have some custom function
    or mapping and want to apply it easily to each field. Danfo.js provides a simple
    interface called `map` that can be used here. Let's see an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume we have a DataFrame of items and their corresponding weights
    in `grams`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The code''s output is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10 – DataFrame with items and their corresponding weights in grams'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.10 – DataFrame with items and their corresponding weights in grams
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to create a new column called `kilograms`, whose values are the corresponding
    grams but converted into kilograms. Here, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `convertToKg` function with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the `map` function on the `grams` column, as shown in the following code
    block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the new `kilograms` column to the DataFrame using the `addColumn` function,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Putting this all together, we have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The code output is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 – DataFrame with items and their corresponding weights in grams'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.11 – DataFrame with items and their corresponding weights in grams
  prefs: []
  type: TYPE_NORMAL
- en: The `map` function can also perform one-to-one mapping when you pass it an object
    with key-value pairs. This can be used for things such as encoding, quick mapping,
    and so on. Let's see an example of this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume we have the following Series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we want to map each numeric value to its corresponding name. We can specify
    a `mapper` object and pass it to the `map` function, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The code''s output is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12 – Series with numeric values mapped to string names'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.12 – Series with numeric values mapped to string names
  prefs: []
  type: TYPE_NORMAL
- en: The `map` function is very useful when working with Series, but sometimes, you
    may want to apply functions to specific axes (rows or columns). In such scenarios,
    you can use another Danfo.js function called the `apply` function.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll introduce the `apply` function.
  prefs: []
  type: TYPE_NORMAL
- en: Data transformation with the apply function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `apply` function can be used to map functions or transformations to a specific
    axis in a DataFrame. It is a little more advanced and powerful than the `map`
    function, and we'll explain why.
  prefs: []
  type: TYPE_NORMAL
- en: 'First is the fact that we can apply tensor operations across a specified axis.
    Let''s take a look at a DataFrame that contains the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The code''s output is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.13 – Sample DataFrame with three columns'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.13 – Sample DataFrame with three columns
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can apply any compatible tensor operation across a specified axis.
    For example, in the following code, we can apply a `softmax` function ([https://en.wikipedia.org/wiki/Softmax_function](https://en.wikipedia.org/wiki/Softmax_function))
    to each element in the DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The code''s output is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.14 – DataFrame after applying a softmax function element-wise'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.14 – DataFrame after applying a softmax function element-wise
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We set the axis to `0` for element-wise tensor operations. This is because some
    tensor operations cannot be performed element-wise. You can read more about the
    supported operations at [https://js.tensorflow.org/api/latest/](https://js.tensorflow.org/api/latest/).
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at another example of applying a function that can work on both columns
    (axis = 1) and rows (axis = 0), respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use the TensorFlow `sum` function for this, as shown in the following
    code. First, let''s apply it across the row axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the `df_new` DataFrame results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.15 – DataFrame after applying the sum function across the row (0)
    axis'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.15 – DataFrame after applying the sum function across the row (0) axis
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the same DataFrame as earlier, change the axis to `1` for the column-wise
    operation, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the DataFrame results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.16 – DataFrame after applying the sum function across the column
    (1) axis'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.16 – DataFrame after applying the sum function across the column (1)
    axis
  prefs: []
  type: TYPE_NORMAL
- en: Custom JavaScript functions can also be used with the `apply` function. The
    only caveat here is that you do not need to specify an axis, as JavaScript functions
    are applied element-wise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of using `apply` with a JavaScript function. In the
    following code block, we are applying the `toLowerCase` string function to each
    element in the DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the DataFrame results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.17 – DataFrame after applying a JavaScript function element-wise'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.17 – DataFrame after applying a JavaScript function element-wise
  prefs: []
  type: TYPE_NORMAL
- en: The `apply` function is very powerful and can be used to apply custom transformations
    to columns or rows across a DataFrame or Series. In the next sub-section, we'll
    look at the different ways of filtering and querying DataFrames and Series.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering and querying
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Filtering and querying are important when we need to get a subset of the data
    that satisfies a specific Boolean condition. Filtering and querying can be done
    on DataFrames and Series using the `query` method, as we'll demonstrate in the
    following examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume we have a DataFrame that contains the following columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the DataFrame results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.18 – DataFrame with sample values for querying'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.18 – DataFrame with sample values for querying
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s filter the DataFrame and only return rows where the `B` column
    has values greater than `5`. This should return rows `0` and `3`. We can do this
    with the `query` function, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.19 – DataFrame after querying'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.19 – DataFrame after querying
  prefs: []
  type: TYPE_NORMAL
- en: The `query` method accepts all JavaScript Boolean operators (`>`, `<`, `>=`,
    `<=`, and `==`), and it also works on string columns, as shown in the following
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a DataFrame with string columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.20 – DataFrame before applying the string query'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.20 – DataFrame before applying the string query
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will run a query with the equals to operator (`"=="`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.21 – DataFrame after applying the string query'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.21 – DataFrame after applying the string query
  prefs: []
  type: TYPE_NORMAL
- en: 'In most scenarios, the DataFrame you''re querying is large, so you may want
    to perform a query in place. This can be done by specifying `inplace` as `true`,
    as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the DataFrame results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.22 – DataFrame after performing an inplace query'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.22 – DataFrame after performing an inplace query
  prefs: []
  type: TYPE_NORMAL
- en: The `query` method is very important, and you use it a lot when filtering your
    data by specific properties. Another bonus of using the `query` function is that
    it allows `inplace` functionality, which means it's useful for filtering large
    datasets.
  prefs: []
  type: TYPE_NORMAL
- en: In the next sub-section, we'll look at another useful concept called random
    sampling.
  prefs: []
  type: TYPE_NORMAL
- en: Random sampling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Random sampling** from a DataFrame or Series is useful when you need to reorder
    rows randomly. This is mostly useful in preprocessing steps before **machine learning**
    (**ML**).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example of using random sampling. Let''s assume we have a DataFrame
    that contains the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.23 – DataFrame before random sampling'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.23 – DataFrame before random sampling
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s randomly select two rows by calling the `sample` function on the
    DataFrame, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.24 – DataFrame in browser console after randomly sampling two rows'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.24 – DataFrame in browser console after randomly sampling two rows
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, you'll notice that the code is wrapped in an `async`
    function. This is because the `sample` method returns a promise, and as such,
    we have to await the result. The preceding code can be executed in the browser
    or node.js environment as is, but it will need a little bit of tweaking to work
    in Dnotebook.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to run the exact code in Dnotebook, you can tweak it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, you can see that we explicitly defined `sample` using
    `var`. This makes the `sample` variable available to all cells. Using the `let`
    declaration here instead will make the variable available to only the cell where
    it was defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in a new cell, you can print the sample DataFrame using the `table` method,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.25 – DataFrame in Dnotebook after randomly sampling two rows'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.25 – DataFrame in Dnotebook after randomly sampling two rows
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll briefly talk about some encoding features available
    in Danfo.js.
  prefs: []
  type: TYPE_NORMAL
- en: Encoding DataFrames and Series
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Encoding** is another important transformation that can be applied to DataFrames/Series
    before ML or **statistical modeling**. It is an important data preprocessing step
    that is always performed before feeding data into models.'
  prefs: []
  type: TYPE_NORMAL
- en: ML or statistical models can only work with numeric values and as such, all
    string/categorical columns must be converted appropriately into numeric form.
    There are numerous types of encoding, such as **one-hot encoding**, **label encoding**,
    **mean encoding**, and so on, and the choice of encoding may differ, depending
    on the type of data you have.
  prefs: []
  type: TYPE_NORMAL
- en: 'Danfo.js currently supports two popular encoding schemes: *label* and *one-hot
    encoder*, and in the following section, we''ll explain how to use them.'
  prefs: []
  type: TYPE_NORMAL
- en: Label encoder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The label encoder maps categories in a column to an integer value between 0
    and the number of unique classes in the column. Let's see an example of using
    this on a DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume we have the following DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the DataFrame results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.26 – DataFrame before encoding'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_26.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.26 – DataFrame before encoding
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s encode the `fruits` column using `LabelEncoder`, as shown in the
    following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code block, you will notice that we created a `LabelEncoder`
    object first and then called the `fit` method on the column (`fruits`). The `fit`
    method simply learns and stores the mapping in the encoder object. This can be
    used later to transform any column/array, as we'll see shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'After calling the `fit` method, we must call the `transform` method to apply
    the labels, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the DataFrame results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.27 – DataFrame before label encoding'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_27.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.27 – DataFrame before label encoding
  prefs: []
  type: TYPE_NORMAL
- en: 'From the preceding output, you can see that unique integers have been assigned
    to each label. In scenarios where `transform` is called on a column with a new
    category that was not available during the `fit` (learning) stage, it is represented
    with a value of `–1`. Let''s take a look at an example of this while using the
    same encoder from the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the DataFrame results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.28 – DataFrame after applying transform to an array with new categories'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_28.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.28 – DataFrame after applying transform to an array with new categories
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, you can see that we are calling the trained encoder
    on an array with new categories (`man` and `car`). Notice that the output has
    `–1` in place of these new categories, as we explained earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's talk about one-hot encoding.
  prefs: []
  type: TYPE_NORMAL
- en: One-hot encoding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One-hot encoding is mostly applied to ordinal categories in a dataset. In this
    encoding scheme, binary values of `0` (hot) and `1` (cold) are used to encode
    unique categories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the same DataFrame as in the preceding section, let''s create a one-hot
    encoder object and apply it to the `country` column, as shown in the following
    code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the DataFrame results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.29 – DataFrame after one-hot encoding'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_29.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.29 – DataFrame after one-hot encoding
  prefs: []
  type: TYPE_NORMAL
- en: 'From the preceding output, you can see that for each unique category, a series
    of 1s and 0s are used to replace the categories, and that we now have two extra
    columns that have been generated. The following diagram gives us an intuitive
    understanding of how each unique class is mapped to one-hot categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.30 – One-hot encoding mapping for three categories'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_30.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.30 – One-hot encoding mapping for three categories
  prefs: []
  type: TYPE_NORMAL
- en: One last encoding feature available in Danfo.js that we'll talk about is the
    `get_dummies` function. This function works in the same way as the one-hot encoding
    function, but the major difference is the fact that you can apply it across a
    DataFrame and it will automatically encode any categorical column it finds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example of using the `get_dummies` function. Let''s assume we
    have the following DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the DataFrame results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.31 – DataFrame before applying the get_dummies function'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_31.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.31 – DataFrame before applying the get_dummies function
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can encode all the categorical columns (`fruits` and `country`) at
    once by passing the DataFrame to the `get_dummies` function, as shown in the following
    code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the DataFrame results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.32 – One-hot encoding a mapping for three categories'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_32.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.32 – One-hot encoding a mapping for three categories
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding figure, you can see that the `get_dummies` function automatically
    detected the `fruits` and `country` categorical variables and one-hot encoded
    them. Columns are autogenerated and their names start with the corresponding column
    and category.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can specify the columns you want to encode, as well as the prefix for naming
    each encoded column. To see more available options, please refer to the official
    Danfo.js documentation: [https://danfo.jsdata.org/](https://danfo.jsdata.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll look at various ways of combining datasets.
  prefs: []
  type: TYPE_NORMAL
- en: Combining datasets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DataFrames and Series can be combined using built-in functions in Danfo.js.
    Methods such as `danfo.merge` and `danfo.concat` exist that, depending on the
    configurations, can help you combine datasets in different forms using familiar
    database-like joins.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll briefly talk about these join types, starting with the
    `merge` function.
  prefs: []
  type: TYPE_NORMAL
- en: DataFrame merge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `merge` operation is similar to the database `Join` operation in that it
    performs join operations on columns or indexes found in the object. The signature
    of the `merge` operation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s understand what each parameter entails:'
  prefs: []
  type: TYPE_NORMAL
- en: '`left`: The left-hand side DataFrame/Series you want to merge to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`right`: The right-hand side DataFrame/Series you want to merge to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`on`: The name(s) of the column(s) to join. These column(s) must be found in
    both the left and right DataFrames.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`how`: The `how` parameter specifies how the merge should be carried out. It
    is similar to the database-style joins, and it can be either `left`, `right`,
    `outer`, or `inner`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Danfo.js `merge` function is very similar to the pandas `merge` function
    since it performs in-memory join operations that are similar to relational database
    joins. The following table provides a comparison of Danfo''s merge methods and
    SQL joins:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.33 – Comparing the Danfo.js merge methods to SQL joins'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_33.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.33 – Comparing the Danfo.js merge methods to SQL joins (Source: pandas
    Doc: https://pandas.pydata.org/pandas-docs/stable/user_guide/merging.html#brief-primer-on-merge-methods-relational-algebra)'
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we'll present some examples to help you understand
    how and when to use the `merge` function.
  prefs: []
  type: TYPE_NORMAL
- en: Inner merge by a single key
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Merging DataFrames on a single common key results in an inner join by default.
    An inner join requires two DataFrames to have matching column values, and it returns
    the intersection of the two; that is, it returns a DataFrame with only those rows
    that have common characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume we have two DataFrames, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the first DataFrame results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.34 – First DataFrame to perform a merge operation on'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_34.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.34 – First DataFrame to perform a merge operation on
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now print the second DataFrame, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.35 – Second DataFrame to perform a merge operation on'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_35.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.35 – Second DataFrame to perform a merge operation on
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will perform an inner join, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the DataFrame results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.36 – Inner merge of two DataFrames on a single key'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_36.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.36 – Inner merge of two DataFrames on a single key
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding output, you can see that the inner join in `Key1` results
    in a DataFrame that contains all the values from DataFrame 1 and DataFrame 2\.
    This is also called a **Cartesian product** of the two DataFrames.
  prefs: []
  type: TYPE_NORMAL
- en: We can take things further and merge multiple keys. We'll look at this in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Inner merge on two keys
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Performing an inner merge on two keys will also return the intersection of both
    DataFrames, but it will only return rows with keys that have been found in both
    the left- and right-hand sides of the DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the same DataFrames we created earlier, we can perform an inner join
    on two keys, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the DataFrame results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.37 – Inner merge of two DataFrames on two keys'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_37.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.37 – Inner merge of two DataFrames on two keys
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding output, you can see that performing an inner merge on two
    keys results in a DataFrame with only those keys present in the left- and right-hand
    sides of the DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: Outer merge on a single key
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The outer merge, as we saw in the preceding table, performs a union of two DataFrames.
    That is, it returns values from the keys present in both DataFrames. Performing
    an outer join on a single key will return the same result as performing an inner
    join on a single key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the same DataFrames from earlier, we can specify the `how` parameter
    to change the merge behavior from its default `inner` join to `outer`, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the DataFrame results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.38 – Outer merge of two DataFrames on a single key'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_38.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.38 – Outer merge of two DataFrames on a single key
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding diagram, you can see that the union of the first DataFrame
    with keys (`K0`, `K0`, `K1`, `K2`) and the second DataFrame with keys (`K0`, `K1`,
    `K1`, `K2`) is (`K0`, `K0`, `K1`, `K1`, `K2`). These keys are then used to unionize
    the DataFrames. After doing this, we received the result shown in the preceding
    table.
  prefs: []
  type: TYPE_NORMAL
- en: We can also perform an outer join on two keys. This will be different from the
    inner join on two keys, as we will see in the following sub-section.
  prefs: []
  type: TYPE_NORMAL
- en: Outer merge on two keys
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Still using the same DataFrames from earlier, we can add a second key, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the DataFrame results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.39 – Outer merge of two DataFrames on two keys'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_39.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.39 – Outer merge of two DataFrames on two keys
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding output, we can see that the rows that were returned always
    have keys in `Key1` and `Key2` present. If the keys present in the first DataFrame
    are not in the second, the values are always filled with `NaN`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Merging in Danfo.js does not support merging on more than two keys at a time.
    This may change in the future, so if you need support for such a feature, be sure
    to check out the *Discussions* section in the official Danfo.js GitHub repository
    ([https://github.com/opensource9ja/danfojs](https://github.com/opensource9ja/danfojs)).
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we'll briefly look at left and right joins, which
    are also important when performing merging.
  prefs: []
  type: TYPE_NORMAL
- en: Right and left merges
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Right and left joins are pretty straightforward; they only return rows with
    keys present in the specified `how` parameter. For instance, let''s say we specify
    the `how` parameter as `right`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the DataFrame results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.40 – Right merge of two DataFrames on two keys'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_40.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.40 – Right merge of two DataFrames on two keys
  prefs: []
  type: TYPE_NORMAL
- en: The resulting diagram shows only rows whose keys are present in the right DataFrame.
    This means that the right DataFrame is given a higher preference when performing
    the merge.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we set `how` to `left`, then a higher preference is given to the left DataFrame,
    and we only see rows whose keys are present in the left DataFrame. The following
    code shows an example of performing a `left` join:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the DataFrame results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.41 – Left merge of two DataFrames on two keys'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_41.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.41 – Left merge of two DataFrames on two keys
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the preceding output, we can confirm that the resulting row gives
    more preference to the left DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: The Danfo.js `merge` function is very powerful and useful and will come in handy
    when you start working with more than one dataset with overlapping keys. In the
    next section, we'll introduce another useful function, known as **concatenation**,
    for transforming datasets.
  prefs: []
  type: TYPE_NORMAL
- en: Data concatenation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Concatenating data is another important data combination technique, and as its
    name suggests, this is basically joining, stacking, or arranging data together
    along an axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function for concatenating data in Danfo.js is exposed as `danfo.concat`,
    and the signature of this function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s understand what each parameter represents:'
  prefs: []
  type: TYPE_NORMAL
- en: '`df_list`: The `df_list` parameter is an array of DataFrames or Series you
    want to join together.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`axis`: The `axis` parameters can accept a row (0) or column (1) and specify
    the axis where the objects will be aligned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we'll present some examples that will help you understand how to use the
    `concat` function. First up, we will learn how to concatenate three DataFrames
    along the row axis.
  prefs: []
  type: TYPE_NORMAL
- en: Concatenating DataFrames along the row axis (0)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, let''s create three DataFrames, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Printing each DataFrame using the `print` function in Node.js and the browser,
    or using the `table` function in Dnotebook, will give us the following output.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the `df1` DataFrame is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.42 – First DataFrame (df1) to be concatenated'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_42.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.42 – First DataFrame (df1) to be concatenated
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the `df2` DataFrame is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.43 – Second DataFrame (df2) to be concatenated'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_43.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.43 – Second DataFrame (df2) to be concatenated
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the output of the `df3` DataFrame is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.44 – Third DataFrame (df3) to be concatenated'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_44.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.44 – Third DataFrame (df3) to be concatenated
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s combine these DataFrames using the `concat` function, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.45 – Result of concatenating three DataFrames along the row axis
    (0)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_45.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.45 – Result of concatenating three DataFrames along the row axis (0)
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see that the `concat` function simply combines each DataFrame
    (`df1`, `df2`, `df3`) along the column axis; that is, it stacks them below the
    first DataFrame in `df_list` to create one giant combination.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, the index looks different. This is because, internally, Danfo.js generated
    new indexes for the combination. If you need numeric indexes, then you can use
    the `reset_index` function, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.46 – Resetting the index of the combined DataFrames'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_46.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.46 – Resetting the index of the combined DataFrames
  prefs: []
  type: TYPE_NORMAL
- en: Now, what would a concatenation along the column axis using the same DataFrames
    look like? We'll try this out in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Concatenating DataFrames along the column axis (1)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using the same DataFrames we created earlier, simply change `axis` to `1` in
    the `concat` code, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the DataFrame results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.47 – Result of applying concat to three DataFrames along the column
    axis (0)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_47.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.47 – Result of applying concat to three DataFrames along the column
    axis (0)
  prefs: []
  type: TYPE_NORMAL
- en: Concatenation also works on Series objects. We'll look at an example in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Concatenating Series along a specified axis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Series are also Danfo.js data structures, and as such, the `concat` function
    can also be used on them. This works the same way as concatenating DataFrames,
    as we'll demonstrate shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the DataFrames from the previous section, we''ll create some Series objects,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we are using a DataFrame sub-setting to grab different columns
    as Series from the DataFrames. Now, we can combine these Series into an array,
    which we''ll then pass to the `concat` function, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the DataFrame results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.48 – Result of applying concat to three Series along the row axis
    (0)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_48.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.48 – Result of applying concat to three Series along the row axis (0)
  prefs: []
  type: TYPE_NORMAL
- en: 'Changing the axis to row (0) will also work and return a DataFrame with lots
    of missing entries, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.49 – Result of applying concat to three Series along the column
    axis (1)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_49.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.49 – Result of applying concat to three Series along the column axis
    (1)
  prefs: []
  type: TYPE_NORMAL
- en: Now, you may be wondering why there are lots of missing fields in the resulting
    combination. This is because when objects are combined along a specified axis,
    sometimes, the position/length of the object will not align with the first DataFrame.
    Padding is done with `NaN` to return consistent lengths.
  prefs: []
  type: TYPE_NORMAL
- en: In this sub-section, we covered two important functions (`merge` and `concat`)
    that can help you perform complex combinations on DataFrames or Series. In the
    next section, we'll talk about something different but important as well, and
    that is **string/text manipulation**.
  prefs: []
  type: TYPE_NORMAL
- en: Series data accessors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Danfo.js provides data type-specific methods under various accessors. **Accessors**
    are namespaces within the Series object that can only be applied/called on specific
    data types. Two accessors are currently provided for string and date-time Series,
    and in this section, we'll discuss each and provide some examples for clarity.
  prefs: []
  type: TYPE_NORMAL
- en: String accessors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: String columns in DataFrames or a Series with a `dtype` string can be accessed
    under the `str` accessor. Calling the `str` accessor on such an object exposes
    numerous string functions for manipulating the data. We will present some examples
    in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume we have a Series that contains the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing this Series results in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.50 – Result of applying concat to three Series along the column
    axis (1)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_50.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.50 – Result of applying concat to three Series along the column axis
    (1)
  prefs: []
  type: TYPE_NORMAL
- en: 'From the preceding output, we can see that the Series (`sf`) contains text
    and is of the string type. You can confirm this with the `dtype` function, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our Series, which is of the string data type, we can call the
    `str` accessor on it and use various JavaScript string methods, such as `capitalize`,
    `split`, `len`, `join`, `trim`, `substring`, `slice`, `replace`, and so on, as
    shown in the following examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code applies the `capitalize` function to a Series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing this Series results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.51 – Result of applying capitalize to a string Series'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_51.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.51 – Result of applying capitalize to a string Series
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code applies the `substring` function to a Series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing this Series results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.52 – Result of applying the substring function to a string Series'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_52.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.52 – Result of applying the substring function to a string Series
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code applies the `replace` function to a Series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing this Series results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.53 – Result of applying the replace function to a string Series'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_53.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.53 – Result of applying the replace function to a string Series
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code applies the `join` function to a Series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing this Series results in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.54 – Result of applying the join function to a string Series'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_54.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.54 – Result of applying the join function to a string Series
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code applies the `indexOf` function to a Series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing this Series results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.55 – Result of applying the indexOf function to a string Series'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_55.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.55 – Result of applying the indexOf function to a string Series
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There are numerous exposed string methods available via the `str` accessor.
    You can see the full list in the Danfo.js documentation ([https://danfo.jsdata.org/api-reference/series#string-handling](https://danfo.jsdata.org/api-reference/series#string-handling)).
  prefs: []
  type: TYPE_NORMAL
- en: Date-time accessors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The second accessor that's exposed by Danfo.js on Series objects is the date-time
    accessor. This can be accessed under the `dt` namespace. Processing and extracting
    different information such as the day, month, and year from a date-time column
    is a common process when doing data transformations since the date-time raw format
    is barely useful.
  prefs: []
  type: TYPE_NORMAL
- en: If your data has a date-time column, the `dt` accessor can be called on it,
    and this, in turn, exposes various functions that can be used to extract information,
    such as the year, month, month name, day of the week, hour, second, and minute
    of the day.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some examples of using the `dt` accessor on a Series with date
    columns. First, we''ll create a Series with some date-time fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing this Series results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.56 – Series with date-time fields'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_56.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.56 – Series with date-time fields
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a Series with date fields, we can extract some information,
    such as the hour of the day, year, month, or day of the week. The first thing
    we need to do is convert the Series into Danfo.js''s date-time format using the
    `dt` accessor, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The `dateTime` variable now exposes different methods for extracting date information.
    Leveraging this, we can do any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get the hour of the day as a new Series:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.57 – New Series showing the extracted hour of the day'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_57.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.57 – New Series showing the extracted hour of the day
  prefs: []
  type: TYPE_NORMAL
- en: 'Get the year as a new Series:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.58 – New Series showing the extracted year'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_58.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.58 – New Series showing the extracted year
  prefs: []
  type: TYPE_NORMAL
- en: 'Get the month as a new Series:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.59 – New Series showing the extracted name of the month'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_59.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.59 – New Series showing the extracted name of the month
  prefs: []
  type: TYPE_NORMAL
- en: 'Get the day of the week as a new Series:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.60 – New Series showing the extracted day of the week'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_60.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.60 – New Series showing the extracted day of the week
  prefs: []
  type: TYPE_NORMAL
- en: 'Some other functions that are exposed by the `dt` accessors are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Series.dt.month`: This returns the month as an integer, starting from 1 (January)
    to 12 (December).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Series.dt.day`: This returns the day of the week as an integer, starting from
    0 (Monday) to 6 (Sunday).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Series.dt.minutes`: This returns the minute of the day as an integer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Series.dt.seconds`: This returns the seconds of the day as an integer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Congratulations on making it to the end of this section! Data transformation
    and aggregation are very important aspects of data analysis. Armed with this knowledge,
    you can properly transform and wrangle your dataset.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll show you how to calculate descriptive statistics
    on your datasets using Danfo.js.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating statistics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Danfo.js comes with some important statistical and mathematical functions. These
    functions can be used to generate a summary or descriptive statistics of entire
    DataFrames, as well as a single Series. In datasets, statistics are important
    because they can give us better insights into data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following sections, we''ll use the popular Titanic dataset, which you
    can download from the following GitHub repository: [https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/blob/main/Chapter03/data/titanic.csv](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/blob/main/Chapter03/data/titanic.csv).'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s load the dataset into Dnotebook using the `read_csv` function,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code loads the Titanic dataset from the specified URL and persists
    it in the `df` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We are using the `load_csv` and `var` declarations here because we are working
    in Dnotebook. As we have mentioned consistently, you wouldn't use this approach
    in a browser or Node.js script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in a new cell, we can print the head of the loaded dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the DataFrame results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.61 – The first five rows of the Titanic dataset'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_61.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.61 – The first five rows of the Titanic dataset
  prefs: []
  type: TYPE_NORMAL
- en: 'We can call the `describe` function on the entire data to quickly get description
    statistics for all the columns, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the DataFrame results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.62 – Output of using the describe function on the Titanic dataset'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_62.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.62 – Output of using the describe function on the Titanic dataset
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, we called the `describe` function and then printed the
    output with `table`. The `describe` function only works on numeric data types,
    and by default, it will only auto-select columns that are of the `float32` or
    `int32` type.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: By default, all statistical and mathematical computation removes `NaN` values
    before the computation is performed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `describe` function provides descriptive statistics for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NaN` values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**mean**: The average value in a column.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Standard Deviation** (**std**): The measure of the amount of variation or
    dispersion of a set of values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minimum** (**min**): The smallest value in a column.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**median**: The middle value in a column.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maximum** (**max**): The largest value in a column.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**variance**: The measure of the spread of values from the average.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating statistics by axis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `describe` function, while quick and easy to apply, is not very helpful
    when you need to calculate statistics along a specific axis. In this section,
    we'll introduce some of the most popular methods and show you how to calculate
    statistics based on a specified axis.
  prefs: []
  type: TYPE_NORMAL
- en: Central tendencies such as mean, mode, and median can be called on a DataFrame
    with a specified axis. Here, axis `0` represents `rows`, while axis `1` represents
    `columns`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we are computing the mean, mode, and median of the numeric
    columns in the Titanic dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we selected all the numeric columns so that we can apply
    mathematical operations. Next, we''ll call the `mean` function, which, by default,
    returns the mean across the column axis (`1`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the DataFrame results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.63 – Calling the mean function on numeric columns'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_63.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.63 – Calling the mean function on numeric columns
  prefs: []
  type: TYPE_NORMAL
- en: 'The precision shown in the preceding output looks a bit too long. We can round
    the result to two decimal places to make it more presentable, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the DataFrame results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.64 – Calling the mean function on numeric columns and rounding values
    to two decimal places'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_64.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.64 – Calling the mean function on numeric columns and rounding values
    to two decimal places
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting output looks cleaner when rounded to two decimal places. Next,
    let''s calculate `mean` across the row axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.65 – Calling the mean function on the row axis'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_4_65.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.65 – Calling the mean function on the row axis
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding output, you can see that the returned values have numeric labels.
    This is because the row axis originally had numeric labels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the same idea, we can compute statistics such as mode, median, standard
    deviation, variance, cumulative sum, cumulative mean, absolute values, and so
    on. The following are the statistical functions that are currently available in
    Danfo.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '`abs`: Returns a Series/DataFrame with the absolute numeric value of each element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`count`: Counts the cells for each column or row, excluding `NaN` values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cummax`: Returns the cumulative maximum over a DataFrame or Series.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cummin`: Returns the cumulative minimum over a DataFrame or Series.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cumprod`: Returns the cumulative product over a DataFrame or Series.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cumsum`: Returns the cumulative sum over a DataFrame or Series.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`describe`: Generates descriptive statistics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max`: Returns the maximum of the values for the requested axis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mean`: Returns the mean of the values for the requested axis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`median`: Returns the median of the values for the requested axis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min`: Returns the minimum of the values for the requested axis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mode`: Returns the mode(s) of elements along the selected axis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sum`: Returns the sum of the values for the requested axis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std`: Returns the standard deviation over the requested axis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`var`: Returns unbiased variance over the requested axis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nunique`: Counts the distinct elements over the requested axis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The list of supported functions will likely change, and new ones will be added.
    So, it is better to keep track of the new ones by checking out [https://danfo.jsdata.org/api-reference/dataframe#computations-descriptive-stats](https://danfo.jsdata.org/api-reference/dataframe#computations-descriptive-stats).
  prefs: []
  type: TYPE_NORMAL
- en: Descriptive statistics are very important, and in this section, we successfully
    covered some important functions that can help you calculate statistics based
    on a specified axis effectively in Danfo.js.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have successfully covered the data transformation and wrangling
    functions available in Danfo.js. First, we introduced you to the various wrangling
    functions for replacing values, filling missing values, and detecting missing
    values, as well as applying and mapping methods for applying custom functions
    to your dataset. Knowledge of these functions and techniques ensures you have
    the required foundation for building data-driven products, as well as getting
    insights from your data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we showed you how to use the various merge and concatenation functions
    in Danfo.js. Finally, we showed you how to calculate descriptive statistics on
    your dataset.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll take things a step further and show you how to make
    beautiful and amazing charts/plots using Danfo.js's built-in plotting features,
    as well as by integrating third-party plotting libraries.
  prefs: []
  type: TYPE_NORMAL
