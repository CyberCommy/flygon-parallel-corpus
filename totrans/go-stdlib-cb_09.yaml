- en: Come to the Server Side
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter contains the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the TCP server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the UDP server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling multiple clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the HTTP server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling HTTP requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating HTTP middleware layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serving static files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serving content generated with templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling redirects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling cookies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gracefully shutdown the HTTP server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serving secured HTTP content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolving form variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers topics from implementing simple TCP and UDP servers to spinning
    the HTTP server. The recipes will lead you from the HTTP request handling, serving
    the static content, to providing the secured HTTP content.
  prefs: []
  type: TYPE_NORMAL
- en: Check if Go is properly installed. The *Getting ready* section in the *Retrieving
    Golang version* recipe of *[Chapter 1](acf67248-0aa9-4150-a43b-d13eb9de89f2.xhtml)*, *Interacting
    With Environment,* will help you.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the ports `8080` and `7070` are not used by another application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the TCP server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the chapter *Connect the Network,* the client side of the TCP connection
    is presented. In this recipe, the server side will be described.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter09/recipe01`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `servertcp.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the code by `go run servertcp.go`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8dfefbc6-9c4b-4e14-b076-71fa553960dd.png)'
  prefs: []
  type: TYPE_IMG
- en: Open another Terminal and execute `nc localhost 8080`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write any text, for example, `Hello`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8ad77c3b-7195-4721-9c59-3c0a7893c688.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The TCP server could be created using the `net` package. The net package contains
    the `Listen` function that creates the `TCPListener`, which can `Accept` the client
    connections. The `Accept` method calls on the `TCPListener` blocks until the client
    connection is received. If the client connection comes, the `Accept` method returns
    the `TCPConn` connection. The `TCPConn` is a connection to the client that serves
    to read and write data.
  prefs: []
  type: TYPE_NORMAL
- en: The `TCPConn` implements the `Reader` and `Writer` interfaces. All the approaches
    to write and read the data could be used. Note that there is a delimiter character
    for reading the data, otherwise, the EOF is received if the client forcibly closes
    the connection.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this implementation handles only one client at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the UDP server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **User Datagram Protocol** (**UDP**) is one of the essential protocols of
    the internet. This recipe will show you how to listen for the UDP packets and
    read the content.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter09/recipe02`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `serverudp.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Start the server by `go run serverudp.go:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f8f78af0-6fb6-4921-a76c-3bc5e8d5e9a0.png)'
  prefs: []
  type: TYPE_IMG
- en: Open another Terminal and execute `nc -u localhost 7070`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write any message to the Terminal, for example, `Hello`, and hit *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fd570795-3779-4f90-ad46-33ad28dbabbe.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with the TCP server, the UDP server can be created with the help of the `net`
    package. With the use of the `ListenPacket` function, the `PacketConn` is created.
  prefs: []
  type: TYPE_NORMAL
- en: The `PacketConn` does not implement the `Reader` and `Writer` interface as the
    `TCPConn`. For reading the received packet, the `ReadFrom` method should be used.
    The `ReadFrom` method blocks until the packet is received. After this, the `Addr`
    of the client is returned (remember the UDP is not connection-based ). To respond to
    the client, the `WriteTo` method of `PacketConn` could be used; this consumes
    the message and the `Addr`, which is the client `Addr`, in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Handling multiple clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous recipes show how to create UDP and TCP servers. The sample codes
    are not ready to handle multiple clients simultaneously. In this recipe, we will
    cover how to handle more clients at any given time.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter09/recipe03`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `multipletcp.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by `go run multipletcp.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open two another Terminals and execute the `nc localhost 8080`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write something to both opened Terminals and see the output. The following two
    images are the connected clients.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Terminal 1 connected to `localhost:8080`:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/a3ff1b6b-ae4e-43db-8eda-51970a7c9c7e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Terminal 2 connected to `localhost:8080`:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/ed6cbf04-737c-4795-8b0d-7121b5c5e134.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The output in the Terminal where the server is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9fc41327-6ecb-4dd7-a4b4-d4b109e1d948.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The TCP server implementation works the same as the previous recipe, *Creating
    the TCP server,* from this chapter. The implementation is enhanced, with the ability
    to handle multiple clients simultaneously. Note that we are now handling the accepted
    connection in the separate `goroutine`. This means the server can continue to
    accept the client connections with the `Accept` method.
  prefs: []
  type: TYPE_NORMAL
- en: Because the UDP protocol is not stateful and does not keep any connection, the
    handling of multiple clients is moved to application logic and you need to identify
    the clients and packet sequence. Only the writing response to a client could be
    parallelized with the use of goroutines.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the HTTP Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The creation of the HTTP server in Go is very easy, and the standard library
    provides more ways of how to do that. Let's look at the very basic one.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter09/recipe04`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `httpserver.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by `go run httpserver.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d968e06b-4856-4ba6-a454-2da48208c165.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Access the URL `http://localhost:8080` in a browser or use `curl`. The `Hello
    world` content should be displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/013de77f-87a8-4bd4-91e5-f0dc437e913c.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `net/http` package contains a few ways of creating the HTTP server. The
    most simple one is to implement the `Handler` interface from the `net/http` package.
    The `Handler` interface requires the type to implement the `ServeHTTP` method.
    This method handles the request and response.
  prefs: []
  type: TYPE_NORMAL
- en: The server itself is created in the form of the `Server` struct from the `net/http`
    package. The `Server` struct requires the `Handler` and `Addr` fields. By calling
    the method, `ListenAndServe`,  the server starts serving the content on the given
    address.
  prefs: []
  type: TYPE_NORMAL
- en: If the `Serve` method of the `Server` is used, then the `Listener` must be provided.
  prefs: []
  type: TYPE_NORMAL
- en: The `net/http` package provides also the default server which could be used
    if the `ListenAndServe` is called as a function from the `net/http` package. It
    consumes the `Handler` and `Addr`, the same as the `Server` struct. Internally,
    the `Server` is created.
  prefs: []
  type: TYPE_NORMAL
- en: Handling HTTP requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The applications usually use the URL paths and HTTP methods to define the behavior
    of the application. This recipe will illustrate how to leverage the standard library
    for handling different URLs and methods.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter09/recipe05`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `handle.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by `go run handle.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check the following URLs in the browser or via `curl`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8080/user`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost:8080/items/clothes`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost:8080/admin/ports`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a51caee0-0d11-49f0-8f5f-c947a53ce435.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `net/http` package contains the `ServeMux` struct, which implements the
    `Handler` interface to be used in a `Server` struct, but also contains the mechanism
    of how to define the handling of different paths. The `ServeMux` pointer contains
    the methods `HandleFunc` and `Handle`, which accept the path, and the `HandlerFunc`
    function handles the request for the given path, or another handler does the same.
  prefs: []
  type: TYPE_NORMAL
- en: See the preceding example for how these could be used. The `Handler` interface
    and `HandlerFunc` require implementing the function with request and response
    arguments. This way you get access to these two structures. The request itself
    gives access to `Headers`, the HTTP method, and other request parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Creating HTTP middleware layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern applications with web UI or REST API usually use the middleware mechanism
    to log the activity, or guard the security of the given interface. In this recipe,
    the implementation of such a middleware layer will be presented.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter09/recipe06`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `middleware.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by `go run middleware.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check the URL `http://localhost:8080/api/users` with use of `curl` by executing
    these two commands (the first without and the second with the `X-Auth` header):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`curl -X GET -I http://localhost:8080/api/users`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`curl -X GET -H "X-Auth: authenticated" -I http://localhost:8080/api/users`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4689efc2-a6b0-4f6b-916f-60e382705cad.png)'
  prefs: []
  type: TYPE_IMG
- en: Test the URL `http://localhost:8080/api/profile` using the `X-User` header.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6508230d-9f72-47ac-8518-6a646364fb91.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The implementation of middleware in the preceding example leverages the *functions
    as first-class citizens* feature of Golang. The original `HandlerFunc` is wrapped
    into a `HandlerFunc` which checks the `X-Auth` header. The `Secure` function is
    then used to secure the `HandlerFunc`, used in the `HandleFunc` methods of `ServeMux`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this is just a simple example, but this way you can implement more
    sophisticated solutions. For example, the user identity could be extracted from
    the `Header` token and subsequently, the new type of handler could be defined
    as `type AuthHandler func(u *User,w http.ResponseWriter, r *http.Request)`. The
    function `WithUser` then creates the `HandlerFunc` for the `ServeMux`.
  prefs: []
  type: TYPE_NORMAL
- en: Serving static files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost any web application needs to serve static files. The serving of JavaScript
    files, static HTML pages, or CSS style sheets could be easily achieved with the
    use of the standard library. This recipe will show how.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter09/recipe07`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the file `welcome.txt` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the folder `html`, navigate to it and create the file `page.html` with
    the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `static.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by `go run static.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check the following URLs with the browser or the `curl` utility:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8080/html/page.html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost:8080/welcome`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3f559fb9-21e6-4e04-87cb-e8c704091a71.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `net/http` package provides the functions `ServeFile` and `FileServer`,
    which are designed to serve the static files. The `ServeFile` function just consumes
    the `ResponseWriter` and `Request` with the given file path argument and writes
    the content of the file to the response.
  prefs: []
  type: TYPE_NORMAL
- en: The `FileServer` function creates the whole `Handler` which consumes the `FileSystem`
    argument. The preceding example uses the `Dir` type, which implements the `FileSystem`
    interface. The `FileSystem` interface requires implementing the `Open` method,
    which consumes string and returns the actual `File` for the given path.
  prefs: []
  type: TYPE_NORMAL
- en: Serving content generated with templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For some purposes, it is not necessary to create highly dynamic web UI with
    all the JavaScript, and the static content with generated content could be sufficient.
    The Go standard library provides a way of constructing dynamically generated content.
    This recipe gives a lead into the Go standard library templating.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter09/recipe08`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the file `template.tpl` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the file `dynamic.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by `go run dynamic.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check the URL `http://localhost:8080` and see the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7ccdc694-3eb4-4c27-a8a7-fdaa4c8a70b2.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Go standard library also contains the package for templating the content.
    The packages `html/template` and `text/template` provide the functions to parse
    the templates and use them to create the output. The parsing is done with the `ParseXXX`
    functions or the methods of the newly-created `Template` struct pointer. The preceding
    example uses the `ParseFiles` function of the `html/template` package.
  prefs: []
  type: TYPE_NORMAL
- en: The templates themselves are text-based documents or pieces of text which contain
    dynamic variables. The use of the template is based on merging the template text
    with the structure that contains the values for the variables present in the template.
    For merging the template with such structures, the `Execute` and `ExecuteTemplate`
    methods are there.  Note that these  consume the writer interface, where the output
    is written; the `ResponseWriter` is used in this case.
  prefs: []
  type: TYPE_NORMAL
- en: The template syntax and features are explained well in the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Handling redirects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Redirects are the usual way of telling the client that the content was moved,
    or there is a needs to look somewhere else to accomplish the request. This recipe
    describes the way to implement redirects with the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter09/recipe09`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the file `redirect.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by `go run redirect.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `curl -v -L http://localhost:8080/s`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ecured/handle` to see if redirect works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9aea8cdd-df60-4b0a-9a56-93249e28c8bd.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `net/http` package contains a simple way of executing the redirect. The
    `RedirectHandler` could be utilized. The function consumes the `URL` where the
    request will be redirected and the `status code` which will be sent to client.
    The function itself sends results to the `Handler`, which could be used in the `Handle`
    method of `ServeMux` (the example uses the default one directly from the package).
  prefs: []
  type: TYPE_NORMAL
- en: The second approach is the use of the `Redirect` function, which does the redirect
    for you. The function consumes `ResponseWriter`, the request pointer and the same
    as `RequestHandler`, the URL and status code, which will be sent to the client.
  prefs: []
  type: TYPE_NORMAL
- en: The redirect could be also done with the help of manually setting the `Location`
    header and writing the proper status code. The Go library only makes this easy
    to use for the developer.
  prefs: []
  type: TYPE_NORMAL
- en: Handling cookies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cookies provide a way of easily storing data on the client side. This recipe
    illustrates how to set, retrieve and remove the cookies with the help of the standard
    library.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter09/recipe10`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the file `cookies.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by `go run cookies.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Access the URLs in the following sequence and see:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The response in a browser directed to the URL `http://localhost:8080/set`:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/94747619-36e0-41ac-80b9-afd0caefacbd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The response in a browser directed to the URL `http://localhost:8080/get` (the
    response contains the available cookies):'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/71f9eafc-cbbe-4c49-a539-d31ba6aa96d2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The response in a browser directed to the URL `http://localhost:8080/remove` (this
    will remove the cookie):'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/b753a078-b68e-47cf-bb10-7f83a8a5897a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The response in a browser directed to the URL `http://localhost:8080/get` (proof
    that the cookie `X-Cookie` was removed):'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/50a7c538-9702-4101-883b-9be3d0f5f1a8.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `net/http` package also provides the functions and mechanisms to operate
    on cookies. The sample code presents how to set/get and remove the cookies. The
    `SetCookie` function accepts the `Cookie` struct pointer that represents the cookies,
    and naturally the `ResponseWriter`. The `Name`, `Value`, `Domain`, and expiration
    are set directly in the `Cookie` struct. Behind the scenes, the `SetCookie` function
    writes the header to set the cookies.
  prefs: []
  type: TYPE_NORMAL
- en: The cookie values could be retrieved from the `Request` struct. The method `Cookie`
    with the name parameter returns the pointer to the `Cookie`, if the cookie exists
    in the request.
  prefs: []
  type: TYPE_NORMAL
- en: To list all cookies within the request, the method `Cookies` could be called.
    This method returns the slice of the `Cookie` structs pointers.
  prefs: []
  type: TYPE_NORMAL
- en: To let the client know that the cookie should be removed, the `Cookie` with
    the given name could be retrieved and the `MaxAge` field should be set to a negative
    value. Note that this is not a Go feature, but the way the client should work.
  prefs: []
  type: TYPE_NORMAL
- en: Gracefully shutdown the HTTP server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](acf67248-0aa9-4150-a43b-d13eb9de89f2.xhtml), *Interacting with
    the Environment*, the mechanism of how to implement graceful shutdown was presented.
    In this recipe, we will describe how to shut down the HTTP server and give it
    time to handle the existing clients.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter09/recipe11`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the file `gracefully.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by `go run gracefully.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Wait until the server starts listening:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/77347b25-fda9-49ea-b253-64bcb6839553.png)'
  prefs: []
  type: TYPE_IMG
- en: Connect with the browser to `http://localhost:8080`; this will cause the browser
    to wait for a response for 10 seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the interval of 10 seconds, press *Ctrl* + *C* to send the `SIGINT` signal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to connect again from another tab (the server should refuse other connections).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fe6669e0-c15f-4bae-9492-be6c5636a481.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Server` from the `net/http` package provides the method to gracefully shutdown
    the connection. The preceding code starts the HTTP server in a separate `goroutine` and
    keeps the reference to the `Server` struct in a variable.
  prefs: []
  type: TYPE_NORMAL
- en: By calling the `Shutdown` method, the `Server` starts refusing new connections
    and closes opened listeners and idle connections. Then it waits indefinitely for
    the already pending connections, till these become idle. After all the connections
    are closed, the server shuts down. Note that the `Shutdown` method consumes the
    `Context`. If the provided `Context` expires prior to the shutdown, then the error
    from `Context` is returned and the `Shutdown` does not block anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Serving secured HTTP content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe describes the simplest way of creating the HTTP server, which serves
    the content via the TLS/SSL layer.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prepare the private key and self-signed X-509 certificate. For this purpose,
    the OpenSSL utility could be used. By executing the command `openssl genrsa -out
    server.key 2048`, the private key derived with the use of an RSA algorithm is
    generated to the file `server.key`. Based on this private key, the X-509 certificate
    could be generated by calling `openssl req -new -x509 -sha256 -key server.key
    -out server.crt -days 365`. The `server.crt` file is created.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter09/recipe12`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the created `server.key` and `server.crt` files in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the file `servetls.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Execute the server by `go run servetls.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Access the URL `https://localhost:8080` (the HTTPS protocol is used). If using
    the `curl` utility, the `--insecure` flag must be used, as our certificate is
    self-signed and not trusted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e896790c-9b63-4b81-905f-5ae525a862a9.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides the `ListenAndServe` function, within the `net/http` package, the TLS
    variant for serving HTTP via SSL/TLS, exists. With the use of the `ListenAndServeTLS`
    method of the `Server`, the secured HTTP is served. The `ListenAndServeTLS` consumes
    the path to the private key and X-509 certificate. Naturally, the function `ListenAndServeTLS`,
    directly from `net/http` package, could be used.
  prefs: []
  type: TYPE_NORMAL
- en: Resolving form variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HTTP `POST` form is a very common way of passing the information to the
    server, in a structured way. This recipe shows how to parse and access these on
    the server side.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter09/recipe12`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the file `form.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by `go run form.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the second Terminal and execute the `POST` using `curl`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'See the output in the first Terminal, where the server is running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dfb65601-5441-4053-b9e5-01235355f3d3.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Request` struct of the `net/http` package contains the `Form` field which
    contains the `POST` form variables and URL query variables merged. The important
    step in the preceding code is the call of the `ParseForm` method on the `Request`
    pointer. This method call causes the parsing of the `POST` form values and query
    values into a `Form` variable. Note that if the `Get` method on the `Form` field
    is used, the `POST` value of the parameter is prioritized. The `Form` and `PostForm`
    fields are, in fact, of type `url.Values`.
  prefs: []
  type: TYPE_NORMAL
- en: If only the parameters from the `POST` form need to be accessed, the `PostForm`
    field of the `Request` is provided. This one keeps only those that were part of
    the `POST` body.
  prefs: []
  type: TYPE_NORMAL
