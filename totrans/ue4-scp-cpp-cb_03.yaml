- en: Chapter 3. Memory Management and Smart Pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Unmanaged memory – using `malloc()`/`free()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unmanaged memory – using `new`/`delete`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managed memory – using `NewObject< >` and `ConstructObject< >`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managed memory – deallocating memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managed memory – smart pointers (`TSharedPtr`, `TWeakPtr`, `TAutoPtr`) to track
    an object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `TScopedPointer` to track an object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unreal's garbage collection system and `UPROPERTY()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forcing garbage collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breakpoints and stepping through code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding bugs and using call stacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Profiler to identify hot spots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memory management is always one of the most important things to get right in
    your computer program to ensure stability and good, bug-free operation of your
    code. A dangling pointer (pointer referring to something that has been removed
    from memory) is an example of a bug that is hard to track if it occurs.
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](img/00064.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In any computer program, memory management is extremely important. UE4's `UObject`
    reference counting system is the default way that memory is managed for Actors
    and `UObject` derivatives. This is the default way that your memory will be managed
    within your UE4 program.
  prefs: []
  type: TYPE_NORMAL
- en: If you write custom C++ classes of your own, which do not derive from `UObject`,
    you may find the `TSharedPtr` / `TWeakPtr` reference counted classes useful. These
    classes provide reference counting and automatic deletion for 0 reference objects.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter provides recipes for memory management within UE4.
  prefs: []
  type: TYPE_NORMAL
- en: Unmanaged memory – using malloc( )/free( )
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basic way to allocate memory for your computer program in C (and C++) is
    by using `malloc()`. `malloc()` designates a block of the computer system's memory
    for your program's use. Once your program is using a segment of memory, no other
    program can use or access that segment of memory. An attempt to access a segment
    of memory not allocated to your program will generate a "segmentation fault",
    and represents an illegal operation on most systems.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at an example code that allocates a pointer variable `i`, then
    assigns memory to it using `malloc()`. We allocate a single integer behind an
    `int*` pointer. After allocation, we store a value inside `int`, using the dereferencing
    operator `*`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The preceding code does what is shown in the diagram that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first line creates an `int*` pointer variable `i`, which starts as a dangling
    pointer referring to a segment of memory that probably won't be valid for your
    program to reference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the second diagram, we use a `malloc()` call to initialize the variable `i`
    to point to a segment of memory precisely the size of an `int` variable, which
    will be valid for your program to refer to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then initialize the contents of that memory segment to the value `0` using
    the command `*i = 0;`.![How it works…](img/00065.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note the difference between assignment to a pointer variable (`i =`), which
    tells the pointer what memory address to refer to, and assignment to what is inside
    the memory address that the pointer variable refers to (`*i =`).
  prefs: []
  type: TYPE_NORMAL
- en: When the memory in the variable `i` needs to be released back to the system,
    we do so using a `free()` deallocation call, as shown in the following diagram.
    `i` is then assigned to point to memory address `0`, (diagrammed by the **electrical
    grounding** symbol reference ![How it works…](img/00066.jpeg)).
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/00067.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The reason we set the variable `i` to point to the `NULL` reference is to make
    it clear that the variable `i` does not refer to a valid segment of memory.
  prefs: []
  type: TYPE_NORMAL
- en: Unmanaged memory – using new/delete
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `new` operator is almost the same as a `malloc` call, except that it invokes
    a constructor call on the object created immediately after the memory is allocated.
    Objects allocated with the operator `new` should be deallocated with the operator
    `delete` (and not `free()`).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C++, use of `malloc()` was replaced, as best practice, by use of the operator
    `new`. The main difference between the functionality of `malloc()` and the operator
    `new` is that `new` will call the constructor on object types after memory allocation.
  prefs: []
  type: TYPE_NORMAL
- en: '| `malloc` | `new` |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Allocates a zone of contiguous space for use. | Allocates a zone of contiguous
    space for use.Calls constructor as object type used as an argument to the operator
    `new`. |'
  prefs: []
  type: TYPE_TB
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following code, we declare a simple `Object` class, then construct an
    instance of it using the operator `new`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The operator `new` works by allocating space just as `malloc()` does. If the
    type used with the operator `new` is an object type, the constructor is invoked
    automatically with the use of the keyword `new`, whereas the constructor is never
    invoked with the use of `malloc()`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should avoid using naked heap allocations with the keyword `new` (or `malloc`
    for that matter). Managed memory is preferred within the engine so that all memory
    use is tracked and clean. If you allocate a `UObject` derivative, you definitely
    need to use `NewObject< >` or `ConstructObject< >` (outlined in subsequent recipes).
  prefs: []
  type: TYPE_NORMAL
- en: Managed memory – using NewObject< > and ConstructObject< >
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Managed memory refers to memory that is allocated and deallocated by some programmed
    subsystem above the `new`, `delete`, `malloc,` and `free` calls in C++. These
    subsystems are commonly created so that the programmer does not forget to release
    memory after allocating it. Unreleased, occupied, but unused memory chunks are
    called memory leaks. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the memory allocated is not referenceable by any variable!
    So you can neither use the allocated memory after the `for` loop, nor can you
    free it. If your program allocates all available system memory, then what will
    happen is that your system will run out of memory entirely, and your OS will flag
    your program and close it for using up too much memory.
  prefs: []
  type: TYPE_NORMAL
- en: Memory management prevents forgetting to release memory. In memory-managed programs,
    it is commonly remembered by objects that are dynamically allocated the number
    of pointers referencing the object. When there are zero pointers referencing the
    object, it is either automatically deleted immediately, or flagged for deletion
    on the next run of the **garbage collector**.
  prefs: []
  type: TYPE_NORMAL
- en: Use of managed memory is automatic within UE4\. Any allocation of an object
    to be used within the engine must be done using `NewObject< >()` or `SpawnActor<
    >()`. The release of objects is done by removing the reference to the object,
    then occasionally calling the garbage cleanup routine (listed further in this
    chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you need to construct any `UObject` derivative that is not a derivative
    of the `Actor` class, you should always use `NewObject< >`. `SpawnActor< >` should
    be used only when the object is an `Actor` or its derivative.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Say we are trying to construct an object of type `UAction`, which itself derives
    from `UObject`. For example, the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To construct an instance of the `UAction` class, we''d do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, `UAction::StaticClass()` gets you a base `UClass*` for the `UAction` object.
    The first argument to `NewObject< >` is `GetTransientPackage()`, which simply
    retrieves the transient package for the game. A package (`UPackage`) in UE4 is
    just a data conglomerate. Here we use the **Transient Package** to store our heap-allocated
    data. You could also use `UPROPERTY() TSubclassOf<AActor>` from Blueprints to
    select a `UClass` instance.
  prefs: []
  type: TYPE_NORMAL
- en: The third argument (optional) is a combination of parameters that indicate how
    `UObject` is treated by the memory management system.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is another function very similar to `NewObject< >` called `ConstructObject<
    >`. `ConstructObject< >` provides more parameters in construction, and you may
    find it useful if you need to specify these parameters. Otherwise, `NewObject`
    works just fine.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may also want to see the documentation for `RF_*` flags at [https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Objects/Creation/index.html#objectflags](https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Objects/Creation/index.html#objectflags)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managed memory – deallocating memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`UObject`s are reference-counted and garbage-collected when there are no more
    references to the `UObject` instance. Memory allocated on a `UObject` class derivative
    using `ConstructObject<>` or `NewObject< >` can also be deallocated manually (before
    the reference count drops to 0) by calling the `UObject::ConditionalBeginDestroy()`
    member function.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You'd only do this if you were sure you no longer wanted `UObject` or the `UObject`
    class derivative instance in memory. Use the `ConditionalBeginDestroy()` function
    to release memory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code demonstrates the deallocation of a `UObject class`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The command `ConditionalBeginDestroy()` begins the deallocation process, calling
    the `BeginDestroy()` and `FinishDestroy()` overrideable functions.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Be careful not to call `UObject::ConditionalBeginDestroy()` on any object still
    being referenced in memory by other objects' pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Managed memory – smart pointers (TSharedPtr, TWeakPtr, TAutoPtr) to track an
    object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When people are afraid that they'll forget the `delete` call for standard C++
    objects they create, they often use smart pointers to prevent memory leaks. `TSharedPtr`
    is a very useful C++ class that will make any custom C++ object reference-counted—with
    the exception of `UObject` derivatives, which are already reference-counted. An
    alternate class `TWeakPtr` is also provided for pointing to a reference-counted
    object with the strange property of being unable to prevent deletion (hence, "weak").
  prefs: []
  type: TYPE_NORMAL
- en: '![Managed memory – smart pointers (TSharedPtr, TWeakPtr, TAutoPtr) to track
    an object](img/00068.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`UObject` and it''s derivative classes (anything created with `NewObject` or
    `ConstructObject`) cannot use `TSharedPtr`!'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you don''t want to use raw pointers and manually track deletes into your
    C++ code that does not use `UObject` derivatives, then that code is a good candidate
    for using smart pointers such as `TSharedPtr`, `TSharedRef`,and the like. When
    you use a dynamically allocated object (created using the keyword `new`), you
    can wrap it up in a reference-counted pointer so that deallocation happens automatically.
    The different types of smart pointers determine the smart pointer behavior and
    deletion call time. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TSharedPtr`: A thread-safe (provided you supplied `ESPMode::ThreadSafe` as
    the second argument to the template) reference-counted pointer type that indicates
    a shared object. The shared object will be deallocated when there are no more
    references to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TAutoPtr`: Non-thread-safe shared pointer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can demonstrate use of the four types of smart pointers referred to previously
    using a short code segment. In all of this code, the starting pointer can either
    be a raw pointer, or a copy of another smart pointer. All you have to do is take
    the C++ raw pointer and wrap it in a constructor call to any of `TSharedPtr`,
    `TSharedRef`, `TWeakPtr,` or `TAutoPtr`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some differences between weak pointers and shared pointers. Weak pointers
    do not have the capability to keep the object in memory when the reference count
    drops to 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantage of using a weak pointer (over a raw pointer) is that when the
    object underneath the weak pointer is manually deleted (using `ConditionalBeginDestroy()`),
    the weak pointer''s reference becomes a `NULL` reference. This enables you to
    check if the resource underneath the pointer is still allocated properly by checking
    a statement of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Shared pointers are thread-safe. This means that the underlying object can safely
    be manipulated on separate threads. Always remember that you cannot use `TSharedRef`
    with `UObject`s or `UObject` derivatives—only on your custom C++ classes, or on
    your `FStructures` can you use any of the `TSharedPtr`, `TSharedRef`, `TWeakPtr`
    classes to wrap up a raw pointer. You must use `TWeakObjectPointer` or `UPROPERTY()`
    as a starting point to point to an object using a smart pointer.
  prefs: []
  type: TYPE_NORMAL
- en: You can use `TAutoPtr` if you do not need the thread-safety guarantee of `TSharedPtr`.
    `TAutoPtr` will automatically delete an object when the number of references to
    it drops to 0.
  prefs: []
  type: TYPE_NORMAL
- en: Using TScopedPointer to track an object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A scoped pointer is a pointer that is auto-deleted at the end of the block in
    which it was declared. Recall that a scope is just a section of code during which
    a variable is "alive". A scope will last until the first closing brace, `}`, that
    occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the following block, we have two scopes. The outer scope declares
    an integer variable `x` (valid for the entire outer block), while the inner scope
    declares an integer variable `y` (valid for the inner block, after the line on
    which it is declared):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Scoped pointers are useful when it is important that a reference-counted object
    (which is in danger of going out of scope) is retained for the duration of usage.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To declare a scoped pointer, we simply use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This declares a scoped pointer referencing an object of the type declared within
    the angle brackets: `< AWarrior >`.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `TScopedPointer` variable type automatically adds a reference count to the
    variable pointed to. This prevents deallocation of the underlying object for at
    least the life of the scoped pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Unreal's garbage collection system and UPROPERTY( )
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you have an object (such as `TArray< >`) as a `UPROPERTY()` member of `UCLASS()`,
    you need to declare that member as `UPROPERTY()` (even if you won't edit it in
    blueprints), otherwise `TArray` will not stay allocated properly.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Say we have a `UCLASS()` macro as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You'd have to list the `TArray` member as `UPROPERTY()` for it to be properly
    reference counted. If you don't do so, you'll get an unexpected memory error type
    bug sitting about in the code.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `UPROPERTY()` declaration tells UE4 that `TArray` must be properly memory
    managed. Without the `UPROPERTY()` declaration, your `TArray` won't work properly.
  prefs: []
  type: TYPE_NORMAL
- en: Forcing garbage collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When memory fills up, and you want to free some of it, garbage collection can
    be forced. You seldom need to do this, but you can do it in the case of having
    a very large texture (or set of textures) that are reference-counted that you
    need to clear.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Simply call `ConditionalBeginDestroy()` on all `UObject`s that you want deallocated
    from memory, or set their reference counts to 0.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Garbage collection is performed by calling the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Breakpoints and stepping through code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Breakpoints are how you pause your C++ program to temporarily stop the code
    from running, and have a chance to analyze and inspect your program's operation.
    You can peer at variables, step through code, and change variable values.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Breakpoints are easy to set in Visual Studio. All you have to do is press *F9*
    on the line of code that you want operation to pause at, or click in the grey
    margin to the left of the line of code that you want to pause operation at. The
    code will pause when operation reaches the line indicated.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Press *F9* on the line you want execution to pause at. This will add a breakpoint
    to the code, indicated by a red dot, as shown in the screenshot below. Clicking
    on the red dot toggles it.![How to do it...](img/00069.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Build Configuration** to any of the configurations with **Debug** in the
    title (**DebugGame** Editor or simply **DebugGame** if you will launch without
    the editor).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch your code by pressing *F5* (without holding *Ctrl*), or select the **Debug**
    | **Start Debugging** menu option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the code reaches the red dot, the code's execution will pause.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The paused view will take you to the code editor in **Debug mode**. In this
    mode, the windows may appear rearranged, with **Solution Explorer** possibly moved
    to the right, and new windows appearing at the bottom, including **Locals**, **Watch
    1**, and **Call Stack**. If these windows do not appear, find them under the **Debug**
    | **Windows** submenu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check out your variables under the **Locals** window (**Debug** | **Windows**
    | **Locals**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *F10* to step over a line of code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *F11* to step into a line of code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Debuggers are powerful tools that allow you to see everything about your code
    as it is running, including variable states.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stepping over a line of code (*F10*) executes the line of code in its entirety,
    and then pauses the program again, immediately, at the next line. If the line
    of code is a function call, then the function is executed without pausing at the
    first line of code of the function call. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Stepping into a line of code (*F11*) will pause execution at the very next line
    of code run.
  prefs: []
  type: TYPE_NORMAL
- en: Finding bugs and using call stacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you have a bug in your code, Visual Studio halts and allows you to inspect
    the code. The place at which Visual Studio halts won't always be the exact location
    of the bug, but it can be close. It will at least be at a line of code that doesn't
    execute properly.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we'll describe **Call Stack,** and how to trace where you think
    an error may come from. Try adding a bug to your code, or add a breakpoint somewhere
    interesting that you'd like to pause for inspection.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Run the code to a point where a bug occurs by pressing *F5,* or selecting the
    **Debug** | **Start Debugging** menu option. For example, add these lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The code will pause at the second line (`o->GetName()`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the code pauses, navigate to the **Call Stack** window (**Debug** | **Windows**
    | **Call Stack**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Call Stack** is a list of function calls that were executed. When a bug
    occurs, the line on which it occurred is listed at the top of the **Call Stack**.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/00070.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using the Profiler to identify hot spots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++ Profiler is extremely useful for finding sections of code that require
    a high amount of processing time. Using the Profiler can help you find sections
    of code to focus on during optimization. If you suspect that a region of code
    runs slowly, then you can actually confirm that it isn't slow if it doesn't appear
    highlighted in the Profiler.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go to **Debug** | **Start Diagnostic Tools Without Debugging…**![How to do it...](img/00071.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the dialog shown in the preceding screenshot, select the type of analysis
    you'd like displayed. You can choose to analyze **CPU Usage**, **GPU Usage**,
    **Memory Usage**, or step through a **Performance Wizard** to assist you in selecting
    what you want to see.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Start** button at the bottom of the dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop the code after a brief time (less than a minute or two) to halt sample
    collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not collect too many samples or the Profiler will take a really long time
    to start up.
  prefs: []
  type: TYPE_NORMAL
- en: Inspect the results that appear in the `.diagsession` file. Be sure to browse
    all available tabs that open up. Available tabs will vary depending on the type
    of analysis performed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The C++ Profiler samples and analyzes the running code, and presents to you
    a series of diagrams and figures about how the code performed.
  prefs: []
  type: TYPE_NORMAL
