- en: Writing Your First Kernel Module - LKMs Part 1
  prefs: []
  type: TYPE_NORMAL
- en: Welcome to your journey of learning about a fundamental aspect of Linux kernel
    development – the **Loadable Kernel Module** (**LKM**) framework – and how it
    is to be used by the *module user* or *module author*, who is typically a kernel
    or device driver programmer. This topic is rather vast and hence is split into
    two chapters – this one and the next.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll begin by taking a quick look at the basics of the Linux
    kernel architecture, which will help us to understand the LKM framework. Then,
    we'll look into why kernel modules are useful and write our own simple *Hello,
    world* LKM, build and run it. We'll see how messages are written to the kernel
    log and understand and make use of the LKM Makefile. By the end of this chapter,
    you will have learned the basics of Linux kernel architecture and the LKM framework,
    applying it to write a simple yet complete piece of kernel code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the kernel architecture – part I
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring LKMs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing our very first kernel module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common operations on kernel modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding kernel logging and printk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the basics of a kernel module Makefile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have already carefully followed [Chapter 1](ad75db43-a1a2-4f3f-92c7-a544f47baa23.xhtml),
    *Kernel Workspace Setup*, the technical prerequisites that follow will already
    be taken care of. (The chapter also mentions various useful open source tools
    and projects; I definitely recommend that you browse through it at least once.)
    For your convenience, we summarize some key points here.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build and use a kernel module on a Linux distribution (or custom system),
    you need, at minimum, the following two components to be installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A toolchain**: This includes the compiler, assembler, linker/loader, C library,
    and various other bits and pieces. If building for the local system, as we assume
    for now, then any modern Linux distribution will have a native toolchain pre-installed.
    If not, simply installing the `gcc` package for your distribution should be sufficient;
    on an Ubuntu- or Debian-based Linux system, use this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Kernel headers**: These headers will be used during compilation. In reality,
    you install a package geared to not only install the kernel headers but also other
    required bits and pieces (such as the kernel Makefile) onto the system. Again, any
    modern Linux distribution will/should have the kernel header pre-installed. If
    not (you can check using `dpkg(1)`, as shown here), simply install the package
    for your distribution; on an Ubuntu- or Debian-based Linux system, use this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, the second command using the `dpkg(1)` utility is simply used to verify
    that the `linux-headers` packages are indeed installed.
  prefs: []
  type: TYPE_NORMAL
- en: This package may be named `kernel-headers-<ver#>` on some distributions. Also,
    for development directly on a Raspberry Pi, install the relevant kernel headers
    package named `raspberrypi-kernel-headers`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The entire source tree for this book is available in its GitHub repository
    at [https://github.com/PacktPublishing/Linux-Kernel-Programming](https://github.com/PacktPublishing/Linux-Kernel-Programming),
    and the code for this chapter under the `ch4` directory. We definitely expect
    you to clone it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The code for this chapter is under its directory namesake, `chn` (where `n` is
    the chapter number; so here, it's under `ch4/`).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding kernel architecture – part 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we begin to deepen our understanding of the kernel. More specifically,
    here we delve into what user and kernel spaces are and the major subsystems and
    various components that make up the Linux kernel. This information is dealt with
    at a higher level of abstraction for now and is deliberately kept brief. We shall
    delve a lot deeper into understanding the fabric of the kernel in [Chapter 6](e13fb379-a77f-4ba5-9de6-d6707b0214e6.xhtml), *Kernel
    Internals Essentials - Processes and Threads**.*
  prefs: []
  type: TYPE_NORMAL
- en: User space and kernel space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modern microprocessors support a minimum of two privilege levels. As a real-world
    example, the Intel/AMD x86[-64] family supports four privilege levels (they call
    them *ring levels*), and the ARM (32-bit) microprocessor family supports up to
    seven (ARM calls them *execution modes*; six are privileged and one is non-privileged).
  prefs: []
  type: TYPE_NORMAL
- en: 'The key point here is that for security and stability on the platform, all
    modern operating systemsrunning on these processors will make use of (at least)
    two of the privilege levels (or modes):'
  prefs: []
  type: TYPE_NORMAL
- en: '**User space**: For *applications* to run in *unprivileged user mode*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kernel space**: For the *kernel* (and all its components) to run in privileged
    mode – *kernel mode*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure shows this basic architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d5b3064-6e8e-4b85-8ba3-26e71a262908.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Basic architecture – two privilege modes
  prefs: []
  type: TYPE_NORMAL
- en: A few details on the Linux system architecture follow; do read on.
  prefs: []
  type: TYPE_NORMAL
- en: Library and system call APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'User space applications often rely on **Application Programming Interfaces**(**APIs**) to
    perform their work. A *library* is essentially a collection or archive of APIs,
    allowing you to use a standardized, well-written, and well-tested interface (and
    leverage the usual benefits: not having to reinvent the wheel, portability, standardization,
    and so on). Linux systems have several libraries; even hundreds on enterprise-class
    systems is not uncommon. Of these, *all* usermode Linux applications (executables)
    are "auto-linked" into one important, always-used library: `glibc`* – the GNU
    standard C library*, as you shall learn. However, libraries are only ever available
    in user mode; the kernel does not have libraries (more on this in the following
    chapter).'
  prefs: []
  type: TYPE_NORMAL
- en: Examples of library APIs are the well-known `printf(3)` (recall, from [Chapter
    1](ad75db43-a1a2-4f3f-92c7-a544f47baa23.xhtml), *Kernel Workspace Setup*, the
    section of the man pages where this API can be found), `scanf(3)`, `strcmp(3)`,
    `malloc(3)`, and `free(3)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, a key point: if user and kernel are separate address spaces and at differing
    privilege levels, how can a user process *access* the kernel? The short answer
    is *via system calls.* A **system call** is a special API, in the sense that it
    is the only legal (synchronous) way for user space processes to access the kernel.
    In other words, system calls are the only legal *entry point* into the kernel
    space. They have the ability to *switch* from non-privileged user mode to privileged
    kernel mode (more on this and the monolithic design in [Chapter 6](e13fb379-a77f-4ba5-9de6-d6707b0214e6.xhtml), *Kernel
    Internals Essentials – Processes and Threads*, under the *Process and interrupt
    contexts* section). Examples of system calls include `fork(2)`, `execve(2)`, `open(2)`,`read(2)`,
    `write(2)`, `socket(2)`, `accept(2)`, `chmod(2)`, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Look up all library and system call APIs in the man pages online:'
  prefs: []
  type: TYPE_NORMAL
- en: '- Library APIs, man section 3: [https://linux.die.net/man/3/](https://linux.die.net/man/3/)'
  prefs: []
  type: TYPE_NORMAL
- en: '- System call APIs, man section 2: [https://linux.die.net/man/2/](https://linux.die.net/man/2/)'
  prefs: []
  type: TYPE_NORMAL
- en: The point being stressed here is that it's really only via system calls that
    user applications and the kernel communicate; that is the interface. In this book,
    we do not delve further into these details. If you are interested in knowing more,
    please refer to the book *Hands-On System Programming with Linux*, by Packt (specifically
    *Chapter 1, Linux System Architecture*).
  prefs: []
  type: TYPE_NORMAL
- en: Kernel space components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This book focuses entirely on the kernel space, of course. The Linux kernel
    today is a rather large and complex beast. Internally, it consists of a few major
    subsystems and several components. A broad enumeration of kernel subsystems and
    components yields the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Core kernel**: This code handles the typical core work of any modern operating
    system, including (user and kernel) process and thread creation/destruction, CPU
    scheduling, synchronization primitives, signaling, timers, interrupt handling,
    namespaces, cgroups, module support, crypto, and more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory Management (MM)**: This handles all memory-related work, including
    the setup and maintenance of kernel and process **Virtual Address Spaces** (**VASes**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VFS (for filesystem support)**: The **Virtual Filesystem Switch** (**VFS**)
    is an abstraction layer over the actual filesystems implemented within the Linux
    kernel (for example, `ext[2|4]`, `vfat`, `reiserfs`, `ntfs`, `msdos`, `iso9660`,
    JFFS2, and UFS).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Block IO**: The code paths implementing the actual file I/O, from the VFS
    right down to the block device driver and everything in between (really, quite
    a lot!), is encompassed here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network protocol stack**: Linux is well known for its precise, to-the-letter-of-the-RFC,
    high-quality implementation of the well-known (and not-so-well-known) network
    protocols at all layers of the model, with TCP/IP being perhaps the most famous.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inter-Process Communication (IPC) support**: The implementation of IPC mechanisms
    is done here; Linux supports message queues, shared memory, semaphores (both the
    older SysV and the newer POSIX ones), and other IPC mechanisms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sound support**: All the code that implements audio is here, from the firmware
    to drivers and codecs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Virtualization support**: Linux has become extremely popular with large and
    small cloud providers alike, a big reason being its high-quality, low-footprint
    virtualization engine, **Kernel-based Virtual Machine** (**KVM**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All this forms the major kernel subsystems; in addition, we have these:'
  prefs: []
  type: TYPE_NORMAL
- en: Arch-specific (meaning CPU-specific) code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kernel initialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many types of device drivers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recall that in [Chapter 2](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml), *Building
    the 5.x Linux Kernel from Source – Part 1*, the *A brief tour of the kernel source
    tree* section gave the kernel source tree (code) layout corresponding to the major
    subsystems and other components.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is a well-known fact that the Linux kernel follows the **monolithic kernel
    architecture**. Essentially, a monolithic design is one in which *all* kernel
    components (that we mentioned in this section) live in and share the kernel address
    space (or kernel *segment*). This can be clearly seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/880b83aa-6e39-424c-84d5-a1904241bcac.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Linux kernel space - major subsystems and blocks
  prefs: []
  type: TYPE_NORMAL
- en: Another fact you should be aware of is that these address spaces are of course *virtual*
    address spacesand not physical. The kernel will (leveraging hardware such as the
    MMU/TLB/caches) *map*, at the page granularity level, virtual pages to physical
    page frames. It does this by using a *master *kernel paging table to map kernel
    virtual pages to physical frames, and, for every single process that is alive,
    it maps the process's virtual pages to physical page frames via individual paging
    tables for each process.
  prefs: []
  type: TYPE_NORMAL
- en: More in-depth coverage of the essentials of the kernel and memory management
    architecture and internals awaits you in [Chapter 6](e13fb379-a77f-4ba5-9de6-d6707b0214e6.xhtml),
    *Kernel Internals Essentials – Processes and Threads *(and more chapters that
    follow).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a basic understanding of the user and kernel spaces, let's
    move on and begin our journey into the LKM framework.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring LKMs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Simply put, a kernel module is a means to provide kernel-level functionality
    without resorting to working within the kernel source tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visualize a scenario where you have to add a support feature to the Linux kernel
    – perhaps a new device driver in order to use a certain hardware peripheral chip,
    a new filesystem, or a new I/O scheduler. One way to do this is pretty obvious:
    update the kernel source tree with the new code, build it, and test it.'
  prefs: []
  type: TYPE_NORMAL
- en: Though this may seem straightforward, it's actually a lot of work – every change
    in the code that we write, no matter how minor, will require us to rebuild the
    kernel image and then reboot the system in order to test it. There must be a cleaner,
    easier way; indeed there is – *the LKM framework*!
  prefs: []
  type: TYPE_NORMAL
- en: The LKM framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The LKM framework is a means to compile a piece of kernel code *outside of *the
    kernel source tree, often referred to as "out-of-tree" code, keeping it independent
    from the kernel in a limited sense, and then insert it into or *plug it into* kernel
    memory, have it run and perform its job, and then remove it (or *unplug* it) from
    kernel memory.
  prefs: []
  type: TYPE_NORMAL
- en: The kernel module's source code, typically consisting of one or more C source
    files, header files, and a Makefile, is built (via `make(1)`, of course) into
    a *kernel module*. The kernel module itself is merely a binary object file and
    not a binary executable. In Linux 2.4 and earlier, the kernel module's filename
    had a `.o` suffix; on modern 2.6 Linux and later, it instead has a `.ko` (**k**ernel
    **o**bject) suffix. Once built, you can insert this `.ko` file – the kernel module
    – into the live kernel at runtime, effectively making it a part of the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Note that not *all* kernel functionality can be provided via the LKM framework.
    Several core features, such as the core CPU scheduler code, memory manage the
    signaling, timer, interrupt management code paths, and so on, can only be developed
    within the kernel itself. Similarly, a kernel module is only allowed access to
    a subset of the full kernel API; more on this later.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might ask: how do I *insert* an object into the kernel? Let''s keep it
    simple – the answer is: via the `insmod(8)` utility. For now, let''s skip the
    details (these will be explained in the upcoming *Running the kernel module *section).
    The following figure provides an overview of first building and then inserting
    a kernel module into kernel memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/538b17b8-db71-480b-b991-8e396a816a0b.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Building and then inserting a kernel module into kernel memory
  prefs: []
  type: TYPE_NORMAL
- en: 'Worry not: the actual code for both the kernel module C source as well as its
    Makefile is dealt with in detail in an upcoming section; for now, we want to gain
    a conceptual understanding only.'
  prefs: []
  type: TYPE_NORMAL
- en: The kernel module is loaded into and lives in kernel memory, that is, the kernel
    VAS (the bottom half of *Figure 4.3*) in an area of space allocated for it by
    the kernel. Make no mistake, *it is kernel code and runs with kernel privileges*.
    This way, you, the kernel (or driver) developer does not have to reconfigure,
    rebuild, and reboot the system each time. All you have to do is edit the code
    of the kernel module, rebuild it, remove the old copy from memory (if it exists),
    and insert the new version. It saves time, and it increases productivity.
  prefs: []
  type: TYPE_NORMAL
- en: 'One reason that kernel modules are advantageous is that they lend themselves
    to dynamic product configuration. For example, kernel modules can be designed
    to provide different features at differing price points; a script generating the
    final image for an embedded product could install a given set of kernel modules
    depending on the price the customer is willing to pay. Here''s another example
    of how this technology is leveraged in a *debug* or troubleshooting scenario:
    a kernel module could be used to dynamically generate diagnostics and debug logs
    on an existing product. Technologies such as kprobes and the like allow just this.'
  prefs: []
  type: TYPE_NORMAL
- en: In effect, the LKM framework gives us a means of dynamically extending kernel
    functionality by allowing us to insert and remove live code from kernel memory.
    This ability to plug in and unplug kernel functionality at our whim makes us realize
    that the Linux kernel is not purely monolithic, it is also *modular.*
  prefs: []
  type: TYPE_NORMAL
- en: Kernel modules within the kernel source tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In fact, the kernel module object isn't completely unfamiliar to us. In [Chapter
    3](93e5c09d-6c80-47e7-91ab-d3f3f25d00e1.xhtml), *Building the 5.x Linux Kernel
    from Source - Part 2*, we built kernel modules as part of the kernel build process
    and had them installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that these kernel modules are part of the kernel source and have been
    configured as modules by selecting `M` in the tristate kernel menuconfig prompt.
    They get installed into directories under `/lib/modules/$(uname -r)/`. So, to
    see a little bit regarding the kernel modules installed under our currently running
    an Ubuntu 18.04.3 LTS guest kernel, we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, the folks at Canonical and elsewhere have been busy! Over five thousand
    kernel modules... Think about it – it makes sense: distributors cannot know in
    advance exactly what hardware peripherals a user will end up using (especially
    on generic computers like x86-based systems). Kernel modules serve as a convenient
    means to support huge amounts of hardware without insanely bloating the kernel
    image file (`bzImage` or `zImage`, for example).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The installed kernel modules for our Ubuntu Linux system live within the `/lib/modules/$(uname
    -r)/kernel` directory, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, looking at the top level of the `kernel/` directory under `/lib/modules/$(uname
    -r)` for the distro kernel (Ubuntu 18.04.3 LTS running the `5.0.0-36-generic`
    kernel), we see that there are many sub folders and literally a few thousand kernel
    modules packed within. By contrast, for the kernel we built (refer to [Chapter
    2](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml), *Building the 5.x Linux Kernel
    from Source – Part 1*, and [Chapter 3](93e5c09d-6c80-47e7-91ab-d3f3f25d00e1.xhtml),
    *Building the 5.x Linux Kernel from Source – Part 2*, for the details), there
    are much fewer. You will recall from our discussions in [Chapter 2](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml),
    *Building the 5.x Linux Kernel from Source – Part 1*, that we deliberately used
    the `localmodconfig` target to keep the build small and fast. Thus, here, our
    custom 5.4.0 kernel has just some 60-odd kernel modules built against it***.***
  prefs: []
  type: TYPE_NORMAL
- en: 'One area that sees pretty heavy usage of kernel modules is that of *device
    drivers*. As an example, let''s look at a network device driver that is architected
    as a kernel module. You can find several (with familiar brands too!) under the
    distro kernel''s `kernel/drivers/net/ethernet` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3596e74-fd45-46b0-b1ed-c068d44daa3f.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Content of our distro kernel's ethernet network drivers (kernel
    modules)
  prefs: []
  type: TYPE_NORMAL
- en: 'Popular on many Intel-based laptops is the Intel 1GbE **Network Interface Card**
    (**NIC**) ethernet adapter. The network device driver that drives it is called
    the `e1000` driver. Our x86-64 Ubuntu 18.04.3 guest (running on an x86-64 host
    laptop) shows that it indeed uses this driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We shall cover the `lsmod(8)` (''list modules'') utility in more detail soon.
    More importantly for us, we can see that it''s a kernel module! How about obtaining
    some more information on this particular kernel module? That''s quite easily done
    by leveraging the `modinfo(8)` utility (for readability, we truncate its verbose
    output here):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `modinfo(8)` utility allows us to peek into a kernel module's binary image
    and extract some details regarding it; more on using `modinfo` in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to gain useful information on the system, including information
    on kernel modules that are currently loaded up, is via the `systool(1)` utility.
    For an installed kernel module (details on *installing* a kernel module follow
    in the next chapter in the *Auto-loading modules on system boot *section), doing
    `systool -m <module-name> -v` reveals information about it. Look up the `systool(1)`
    man page for usage details.
  prefs: []
  type: TYPE_NORMAL
- en: The bottom line is that kernel modules have come to be *the* pragmatic way to
    build and distribute some types of kernel components, with *device drivers* being
    the most frequent use case for them. Other uses include but aren't limited to
    filesystems, network firewalls, packet sniffers, and custom kernel code.
  prefs: []
  type: TYPE_NORMAL
- en: So, if you would like to learn how to write a Linux device driver, a filesystem,
    or a firewall, you must first learn how to write a kernel module, thus leveraging
    the kernel's powerful LKM framework. That's precisely what we will be doing next.
  prefs: []
  type: TYPE_NORMAL
- en: Writing our very first kernel module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When introducing a new programming language or topic, it has become a widely
    accepted computer programming tradition to mimic the original *K&R Hello, world *program
    as the very first piece of code. I'm happy to follow this venerated tradition
    to introduce the powerful LKM framework. In this section, you will learn the steps
    to code a simple LKM. We explain the code in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing our Hello, world LKM C code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Without further ado, here is some simple *Hello, world* C code, implemented
    to abide by the Linux kernel''s LKM framework:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For reasons of readability and space constraints, only the key parts of the
    source code are displayed here. To view the complete source code, build it, and
    run it, the entire source tree for this book is available in it''s GitHub repository
    here: [https://github.com/PacktPublishing/Linux-Kernel-Programming](https://github.com/PacktPublishing/Linux-Kernel-Programming).
    We definitely expect you to clone it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`git clone https://github.com/PacktPublishing/Linux-Kernel-Programming.git`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can try out this simple *Hello, world* kernel module right away! Just `cd`
    to the correct source directory as shown here and get our helper `lkm` script
    to build and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The *hows and whys* are explained in a lot of detail shortly. Though tiny, the
    code of this, our very first kernel module, requires careful perusal and understanding.
    Do read on.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking it down
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following subsections explain pretty much each line of the preceding *Hello,
    world* C code. Remember that although the program appears very small and trivial,
    there is a lot to be understood regarding it and the surrounding LKM framework.
    The rest of this chapter focuses on this and goes into great detail. I highly
    recommend that you take the time to read through and understand these fundamentals
    first. This will help you immensely in later, possibly difficult-to-debug situations.
  prefs: []
  type: TYPE_NORMAL
- en: Kernel headers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We use `#include` for a few header files. Unlike in user space ''C'' application
    development, these are *kernel headers* (as mentioned in the *Technical requirements *section).
    Recall from [Chapter 3](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml), *Building
    the 5.x Linux Kernel from Source – Part 2*, that kernel modules were installed
    under a specific root-writeable branch. Let''s check it out again (here, we''re
    running on our guest x86_64 Ubuntu VM with the 5.0.0-36-generic distro kernel):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Notice the symbolic or soft link named `build`. It points to the location of
    the kernel headers on the system. In the preceding code, it's under `/usr/src/linux-headers-5.0.0-36-generic/`!
    As you shall see, we will supply this information to the Makefile used to build
    our kernel module. (Also, some systems have a similar soft link called `source`).
  prefs: []
  type: TYPE_NORMAL
- en: The `kernel-headers` or `linux-headers` package unpacks a limited kernel source
    tree onto the system, typically under `/usr/src/...`. This code, however, isn't
    complete, hence our use of the phrase *limited* source tree. This is because the
    complete kernel source tree isn't required for the purpose of building modules
    – just the required components (the headers, the Makefiles, and so on) are what's
    packaged and extracted.
  prefs: []
  type: TYPE_NORMAL
- en: The first line of code in our *Hello, world* kernel module is `#include <linux/init.h>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler resolves this by searching for the previously mentioned kernel
    header file under `/lib/modules/$(uname -r)/build/include/`. Thus, by following
    the `build` soft link, we can see that it ultimately picks up this header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The same follows for the other kernel headers included in the kernel module's
    source code.
  prefs: []
  type: TYPE_NORMAL
- en: Module macros
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we have a few module macros of the form `MODULE_FOO()`; most are quite
    intuitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MODULE_AUTHOR()`: Specifies the author(s) of the kernel module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MODULE_DESCRIPTION()`: Briefly describes the function of this LKM'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MODULE_LICENSE()`: Specifies the license(s) under which this kernel module
    is released'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MODULE_VERSION()`: Specifies the (local) version of the kernel module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the absence of the source code, how will this information be conveyed to
    the end user (or customer)? Ah, the `modinfo(8)` utility does precisely that!
    These macros and their information might seem trivial, but they are important
    in projects and products. This information is relied upon, for example, by a vendor
    establishing the (open source) licenses that code is running under by using `grep` on
    the `modinfo` output on all installed kernel modules.
  prefs: []
  type: TYPE_NORMAL
- en: Entry and exit points
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Never forget, kernel modules are, after all, *kernel code running with kernel
    privileges*. It''s *not* an application and thus does not have it''s entry point
    as the familiar `main()`  function (that we know well and love). This, of course,
    begs the question: what are the entry and exit points of the kernel module? Notice,
    at the bottom of our simple kernel module, the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `module_[init|exit]()` code is macros specifying the entry and exit points,
    respectively. The parameter to each is a function pointer. With modern C compilers,
    we can just specify the name of the function. Thus, in our code, the following
    applies:'
  prefs: []
  type: TYPE_NORMAL
- en: The `helloworld_lkm_init()` function is the entry point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `helloworld_lkm_exit()` function is the exit point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can almost think of these entry and exit points as a *constructor/destructor *pair
    for a kernel module. Technically, it's not the case, of course, as this isn't
    object-oriented C++ code, it's plain C. Nevertheless, it's a useful analogy.
  prefs: []
  type: TYPE_NORMAL
- en: Return values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Notice the signature of the `init` and `exit` functions is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As a good coding practice, we have used the naming format for the functions
    as `<modulename>__[init|exit]()`, where `<modulename>` is replaced with the name
    of the kernel module. You will realize that this naming convention is just that
    - it's merely a convention that is, technically speaking, unnecessary, but it
    is intuitive and thus helpful. Clearly, neither routine receives any parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Marking both functions with the `static` qualifier implies that they are private
    to this kernel module. That is what we want.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's move along to the important convention that is followed for a kernel
    module's `init` function's return value.
  prefs: []
  type: TYPE_NORMAL
- en: The 0/-E return convention
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The kernel module''s `init`function is to return a value of type `int`; this
    is a key aspect. The Linux kernel has evolved a *style* or convention, if you
    will, with regard to returning values from it (meaning from the kernel space to
    the user space process). The LKM framework follows what is colloquially referred
    to as the `0/-E` convention:'
  prefs: []
  type: TYPE_NORMAL
- en: Upon success, return integer value `0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upon failure, return the negative of the value you would like the user space
    global uninitialized integer `errno` to be set to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be aware that `errno` is a global residing in a user process VAS within the uninitialized
    data segment. With very few exceptions, whenever a Linux system call fails, `-1` is
    returned and `errno` is set to a positive value, representing the failure code;
    this work is carried out by `glibc` "glue" code on the `syscall` return path.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the `errno` value is actually an index into a global table of English
    error messages (`const char * const sys_errlist[]`); this is really how routines
    such as `perror(3)`, `strerror[_r](3)` and the like can print out failure diagnostics.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the way, you can look up the **complete list of error codes** available
    to you from within these (kernel source tree) header files: `include/uapi/asm-generic/errno-base.h`
    and `include/uapi/asm-generic/errno.h`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick example of how to return from a kernel module''s `init`function will
    help make this clear: say our kernel module''s `init`function is attempting to
    dynamically allocate some kernel memory (details on the `kmalloc()` API and so
    on will be covered in later chapters of course; please ignore it for now). Then,
    we could code it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If the memory allocation does fail (very unlikely, but hey, it can happen!),
    we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we emit a warning `printk`. Actually, in this particular case – "out
    of memory" – it''s pedantic and unnecessary. The kernel will certainly emit sufficient
    diagnostic information if a kernel-space memory allocation ever fails! See this
    link for more details: [https://lkml.org/lkml/2014/6/10/382](https://lkml.org/lkml/2014/6/10/382);
    we do so here merely as it''s early in the discussion and for reader continuity.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Return the `-ENOMEM` value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The layer to which this value will be returned in user space is actually `glibc`;
    it has some "glue" code that multiplies this value by `-1` and sets the global
    integer `errno` to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, the `[f]init_module(2)` system call will return `-1`, indicating failure
    (this is because `insmod(8)` actually invokes this system call, as you will soon
    see).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`errno` will be set to `ENOMEM`, reflecting the fact that the kernel module
    insertion failed due to a failure to allocate memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conversely, the framework *expects *the `init` function to return the value `0` upon
    success. In fact, in older kernel versions, failure to return `0` upon success
    would cause the kernel module to be abruptly unloaded from kernel memory. Nowadays,
    this removal of the kernel module does not happen but the kernel emits a warning
    message regarding the fact that a *suspicious* non-zero value has been returned.
  prefs: []
  type: TYPE_NORMAL
- en: There's not much to be said for the cleanup routine. It receives no parameters
    and returns nothing (`void`). Its job is to perform any and all required cleanup
    before the kernel module is unloaded from kernel memory.
  prefs: []
  type: TYPE_NORMAL
- en: '*Not *including the `module_exit()` macro in your kernel module makes it impossible
    to ever unload it (notwithstanding a system shutdown or reboot, of course). Interesting...
    (I suggest you try this out as a small exercise!).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, it''s never that simple: this behavior preventing the unload is
    guaranteed only if the kernel is built with the `CONFIG_MODULE_FORCE_UNLOAD` flag
    set to `Disabled` (the default).'
  prefs: []
  type: TYPE_NORMAL
- en: The ERR_PTR and PTR_ERR macros
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'On the discussion of return values, you now understand that the kernel module''s
    `init` routine must return an integer. What if you wish to return a pointer instead?
    The `ERR_PTR()` inline function comes to our rescue, allowing us to return a pointer
    *disguised* as an integer simply by typecasting it as `void *`. It actually gets
    better: you can check for an error using the `IS_ERR()` inline function (which
    really just figures out whether the value is in the range [-1 to -4095]), *encodes*
    a negative error value into a pointer via the `ERR_PTR()` inline function, and
    *retrieves* this value from the pointer using the converse routine `PTR_ERR()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a simple example, see the callee code given here. This time, we have the
    (sample) function `myfunc()` return a pointer (to a structure named `mystruct`)
    and not an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The caller code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'FYI, the inline `ERR_PTR()`, `PTR_ERR()`, and `IS_ERR()` functions all live
    within the (kernel header) `include/linux/err.h` file. The kernel documentation
    ([https://kernel.readthedocs.io/en/sphinx-samples/kernel-hacking.html#return-conventions](https://kernel.readthedocs.io/en/sphinx-samples/kernel-hacking.html#return-conventions))
    talks about kernel function return conventions. Also, you can find example usage
    for these functions under the `crypto/api-samples` code within the kernel source
    tree: [https://www.kernel.org/doc/html/v4.17/crypto/api-samples.html](https://www.kernel.org/doc/html/v4.17/crypto/api-samples.html)[.](https://www.kernel.org/doc/html/v4.17/crypto/api-samples.html)'
  prefs: []
  type: TYPE_NORMAL
- en: The __init and __exit keywords
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A niggling leftover: what exactly are the `__init` and `__exit` macros we see
    within the preceding function signatures? These are merely memory optimization
    attributes inserted by the linker.'
  prefs: []
  type: TYPE_NORMAL
- en: The `__init` macro defines an `init.text` section for code. Similarly, any data
    declared with the `__initdata` attribute goes into an `init.data` section. The
    whole point here is the code and data in the `init` function is used exactly once
    during initialization. Once it's invoked, it will never be called again; so, once
    called, it is then freed up (via `free_initmem()`).
  prefs: []
  type: TYPE_NORMAL
- en: The deal is similar with the `__exit` macro, though, of course, this only makes
    sense with kernel modules. Once the `cleanup` function is called, all the memory
    is freed. If the code were instead part of the static kernel image (or if module
    support were disabled), this macro would have no effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fine, but so far, we have still not explained some practicalities: how exactly
    can you get the kernel module object into kernel memory, have it execute, and
    then unload it, plus several other operations you might wish to perform. Let''s
    discuss these in the following section.'
  prefs: []
  type: TYPE_NORMAL
- en: Common operations on kernel modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's delve into how exactly you can build, load, and unload a kernel module.
    Besides this, we'll also walk through the basics regarding the tremendously useful
    `printk()` kernel API, details on listing the currently loaded kernel modules
    with `lsmod(8)`, and a convenience script for automating some common tasks during
    kernel module development. So, let's begin!
  prefs: []
  type: TYPE_NORMAL
- en: Building the kernel module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We definitely urge you to try out our simple *Hello, world *kernel module exercise
    (if you haven't already done so)! To do so, we assume you have cloned this book's
    GitHub repository ([https://github.com/PacktPublishing/Linux-Kernel-Programming](https://github.com/PacktPublishing/Linux-Kernel-Programming))
    already. If not, please do so now (refer to the *Technical requirements* section
    for details).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we show step by step how exactly you can build and then insert our first
    kernel module into kernel memory. Again, a quick reminder: we have performed these
    steps on an x86-64 Linux guest VM (under Oracle VirtualBox 6.1) running the Ubuntu
    18.04.3 LTS distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change to this books'' source code chapter directory and sub-directory. Our
    very first kernel module lives in its own folder (as it should!) called `helloworld_lkm`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`<book-code-dir>` is, of course, the folder into which you cloned this book''s
    GitHub repository; here (see the screenshot,  Figure 4.5), you can see that it''s `/home/llkd/book_llkd/Linux-Kernel-Programming/`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now verify the code base:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Build it with `make`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bd85fe6e-cac7-4e9f-9d65-075cb8212f04.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Listing and building our very first *Hello, world *kernel module
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows that the kernel module has been successfully
    built. It's the `./helloworld_lkm.ko` file. (Also, note that we booted from, and
    thus have built the kernel module against, our custom 5.4.0 kernel, built in earlier
    chapters.)
  prefs: []
  type: TYPE_NORMAL
- en: Running the kernel module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to have the kernel module run, you need to first load it into kernel
    memory space, of course. This is known as *inserting* the module into kernel memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting the kernel module into the Linux kernel segment can be done in a few
    ways, which all ultimately boil down to invoking one of the `[f]init_module(2)` system
    calls. For convenience, several wrapper utilities exist that will do so (or you
    can always write one). We will use the  popular `insmod(8)` (read it as "**ins**ert **mod**ule") utility
    below; the parameter for `insmod` is the pathname to the kernel module to insert:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'It fails! In fact, it should be pretty obvious why. Think about it: inserting
    code into the kernel is, in a very real sense, even superior to being *root* (superuser)
    on the system - again, I remind you: *it''s kernel code and will run with kernel
    privilege*. If any and every user is allowed to insert or remove kernel modules,
    hackers would have a field day! Deploying malicious code would become a fairly
    trivial affair. So, for security reasons, **only with root access can you insert
    or remove kernel modules**.'
  prefs: []
  type: TYPE_NORMAL
- en: Technically, being *root* implies that the process' (or thread's) **Real** and/or
    **Effective** **UID** (**RUID**/**EUID**) value is the special value *zero*. Not
    just that, but the modern kernel "sees" a thread as having certain **capabilities**(via
    the modern and superior POSIX Capabilities model); only a process/thread with
    the `CAP_SYS_MODULE` capability can (un)load kernel modules. We refer the reader
    to the man page on `capabilities(7)` for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s again attempt to insert our kernel module into memory, this time
    with *root* privileges via `sudo(8)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now it works! As alluded to earlier, the `insmod(8)` utility works by invoking
    the `[f]init_module(2)` system call. When might the `insmod(8)` utility (in effect,
    internally the `[f]init_module(2)` system calls) *fail*?
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Permissions**: Not run as root or lack of the `CAP_SYS_MODULE` capability (`errno
    <- EPERM`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The kernel tunable within the `proc` filesystem, ​`/proc/sys/kernel/modules_disabled`,
    is set to `1` (it defaults to `0`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A kernel module with the same name is already in kernel memory (`errno <- EEXISTS`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Okay, all looks good. The `$?` result being `0` implies that the previous shell
    command was successful. That's great, but where is our *Hello, world* message?
    Read on!
  prefs: []
  type: TYPE_NORMAL
- en: A quick first look at the kernel printk()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To emit a message, the user space C developer will often use the trusty `printf(3)`
    glibc API (or perhaps the `cout` when writing C++ code). However, it's important
    to understand that in kernel space, *there are no libraries*. Hence, we simply
    do *not* have access to the good old `printf()` API*.* Instead, it has essentially
    been re-implemented *within *the kernel as the `printk()` kernel API (curious
    as to where its code is? its here within the kernel source tree: `kernel/printk/printk.c:printk()`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Emitting a message via the `printk()` API is simple and very much similar to
    doing so with `printf(3)`. In our simple kernel module, here''s where the action
    occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Though very similar to `printf` at first glance, `printk` is really quite different.
    In terms of similarities, the API receives a format string as its parameter. The
    format string is pretty much identical to that of `printf`.
  prefs: []
  type: TYPE_NORMAL
- en: 'But the similarities end there. The key difference between `printf` and `printk`
    is this: the user space `printf(3)` library API works by formatting a text string
    as requested and invoking the `write(2)` system call, which in turn actually performs
    a write to the `stdout` *device,* which, by default, is the Terminal window (or
    console device). The kernel `printk` API also formats its text string as requested,
    but its *output* *destination* differs. It writes to at least one place – the
    first one in the following list – and possibly to a few more:'
  prefs: []
  type: TYPE_NORMAL
- en: A kernel log buffer in RAM (volatile)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A log file, the kernel log file (non-volatile)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The console device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For now, we shall skip the inner details regarding the workings of `printk`.
    Also, please ignore the `KERN_INFO` token within the `printk` API; we shall cover
    all this soon enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you emit a message via `printk`, it''s guaranteed that the output goes
    into a log buffer in kernel memory (RAM). This, in effect, constitutes the **kernel
    log**. It''s important to note that you will never see the `printk` output directly
    when working in graphical mode with an X server process running (the default environment
    when working on a typical Linux distro). So, the obvious question here is: how
    do you see the kernel log buffer content? There are a few ways. For now, let''s
    just make use of the quick and easy way.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `dmesg(1)` utility! By default, `dmesg` will dump the entire kernel
    log buffer content to stdout. Here, we look up the last two lines of the kernel
    log buffer with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'There it is, finally: our *Hello, world* message!'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can simply ignore the `loading out-of-tree module taints kernel.` message
    for now. For security reasons, most modern Linux distros will mark the kernel
    as *tainted *(literally, "contaminated" or "polluted") if a third party "out-of-tree"
    (or non-signed) kernel module is inserted. (Well, it''s really more of a pseudo-legal
    cover-up along the lines of: *"if something goes wrong from this point in time
    onward, we are not responsible, and so on..."*; you get the idea).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a bit of variety, here is a screenshot of our *Hello, world* kernel module
    being inserted and removed (details follow) on an x86-64 CentOS 8 guest running
    the 5.4 Linux LTS kernel (that we custom-built as shown in detail in the first
    and second chapters):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8aed7347-fd0f-452d-9345-433a8952dfd0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – Screenshot showing our working with the *Hello, world *kernel module
    on a CentOS 8 x86-64 guest
  prefs: []
  type: TYPE_NORMAL
- en: Within the kernel log, as displayed by the `dmesg(1)` utility, the numbers in
    the leftmost column are a simple timestamp, in `[seconds.microseconds]` format,
    of time elapsed since system boot (it is not recommended to treat it as being
    perfectly accurate, though). By the way, this timestamp is a `Kconfig` variable
    – a kernel config option – named `CONFIG_PRINTK_TIME`; it can be overridden by
    the `printk.time` kernel parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Listing the live kernel modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Back to our kernel module: so far, we have built it, loaded it into the kernel,
    and verified that its entry point, the `helloworld_lkm_init()` function,  got
    invoked, thus executing the `printk` API. So now, what does it do? Well, nothing
    really; the kernel module merely (happily?) sits in kernel memory doing absolutely
    nothing. We can in fact easily look it up with the `lsmod(8)` utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`lsmod` shows all kernel modules currently residing (or *live*) in kernel memory,
    sorted in reverse chronological order. Its output is column formatted, with three
    columns and an optional fourth one. Let''s look at each column separately:'
  prefs: []
  type: TYPE_NORMAL
- en: The first column displays the *name* of the kernel module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second column is the (static) *size* in bytes that it's taking in the kernel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third column is the module *usage count*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The optional fourth column (and more that may follow) is explained in the next
    chapter (in the* Understanding module stacking *section. Also, on recent x86-64
    Linux kernels, a minimum of 16 KB of kernel memory seems to be taken up by a kernel
    module.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, great: by now you''ve successfully built, loaded and run your first kernel
    module into kernel memory and it basically works: what next? Well, nothing much
    really with this one! We simply learn how to unload it in the following section.
    There''s a lot more to come of course... keep going!'
  prefs: []
  type: TYPE_NORMAL
- en: Unloading the module from kernel memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To unload the kernel module, we use the convenience utility `rmmod(8)` (*remove
    module*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The parameter to `rmmod(8)` is the *name *of the kernel module (as shown in
    the first column of `lsmod(8)`), not the pathname. Clearly, just as with `insmod(8)`,
    we need to run the `rmmod(8)` utility as the *root* user for it to succeed.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can also see that, because of our `rmmod`, the exit routine (or "destructor")
    `helloworld_lkm_exit()`functionof the kernel module got invoked. It in turn invoked
    `printk`*, *which emitted the *Goodbye, world *message (which we looked up with `dmesg`).
  prefs: []
  type: TYPE_NORMAL
- en: 'When could `rmmod` (note that internally, it becomes the `delete_module(2)` system
    call) *fail*? Here are some cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Permissions**: If it is not run as root or there is a lack of the `CAP_SYS_MODULE`
    capability (`errno <- EPERM`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the kernel module's code and/or data is being used by another module (if
    a dependency exists; this is covered in detail in the next chapter's *Module stacking*
    section) or the module is currently in use by a process (or thread), then the
    module usage count will be positive and `rmmod` will fail (`errno <- EBUSY`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The kernel module did not specify an exit routine (or destructor) with the `module_exit()`
    macro *and* the `CONFIG_MODULE_FORCE_UNLOAD` kernel config option is disabled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Several convenience utilities concerned with module management are nothing
    but symbolic (soft) links to the single `kmod(8)` utility (analogous to what the
    popular *busybox* utility does). The wrappers are `lsmod(8), rmmod(8)`, `insmod(8)`,
    `modinfo(8)`, `modprobe(8)`, and `depmod(8)`. Take a look at a few of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note that the precise location of these utilities (`/bin`, `/sbin`, or `/usr/sbin`)
    can vary with the distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Our lkm convenience script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s round off this *first kernel module* discussion with a simple yet useful
    custom Bash script called `lkm` that helps you out by automating the kernel module
    build, load, `dmesg`, and unload workflow. Here it is (the complete code is in
    the root of the book source tree):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Given the name of the kernel module as a parameter – without any extension
    part (such as `.c`) – the `lkm` script performs some validity checks, displays
    some version information, and then uses a wrapper `runcmd()` bash function to
    display the name of and run a given command, in effect getting the `clean/build/load/lsmod/dmesg`
    workflow done painlessly. Let''s try it out on our first kernel module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: All done! Remember to unload the kernel module with `rmmod(8)`.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have now learned how to write and try out a simple *Hello,
    world* kernel module. Much work remains, though, before you rest on your laurels;
    the next section delves into more key details regarding kernel logging and the
    versatile printk API.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding kernel logging and printk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is still a lot to cover regarding the logging of kernel messages via the printk
    kernel API*.* This section delves into some of the details. It's important for
    a budding kernel developer like you to clearly understand these.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we delve into more detail regarding kernel logging. We come
    to understand how exactly printk output is dealt with, looking at its pros and
    cons. We discuss the printk log levels, how modern systems log messages via the systemd journal,
    and how output can be directed to the console device. We round off this discussion
    with a note on rate-limiting printk and user-generated prints, generating printk's
    from user space and standardizing the printk output format.
  prefs: []
  type: TYPE_NORMAL
- en: 'We saw earlier, in the *A quick first look at the kernel* *printk* section, the
    essentials of using the kernel printk API''s functionality. Here, we explore a
    lot more with respect to the `printk()` API''s usage. In our simple kernel module,
    here''s the line of code that emits the "*Hello, world"* message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, `printk`is similar to `printf` in terms of the *format string* and how
    that works – but the similarities end there. For emphasis, we repeat: a key difference
    between `printf` and `printk`is that `printf(3)` is a *user space library* API
    that works by invoking the `write(2)` system call, which writes to the *stdout
    device, *which by default is usually the Terminal window (or console device).
    The printk, on the other hand, is a *kernel space* API whose output instead goes
    to at least one place, the first one shown in the list below, and possibly to
    more places:'
  prefs: []
  type: TYPE_NORMAL
- en: A kernel log buffer (in RAM; volatile)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A kernel log file (non-volatile)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The console device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's examine the kernel log buffer in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Using the kernel memory ring buffer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The kernel log buffer is simply a memory buffer within a kernel address space
    where the printk output is saved (logged). More technically, it''s the global
    `__log_buf[]` variable. Its definition in the kernel source is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: It's architected as a *ring buffer*; it has a finite size (`__LOG_BUF_LEN` bytes), and
    once it's full, it gets overwritten from byte zero. Hence, it's called a "ring"
    or circular, buffer). Here, we can see that the size is based on the `Kconfig`
    variable `CONFIG_LOG_BUF_SHIFT` (`1 << n` in C implies `2^n`). This value is shown
    and can be overridden as part of the kernel `(menu)config` here: `General Setup
    > Kernel log buffer size`.
  prefs: []
  type: TYPE_NORMAL
- en: It's an integer value with a range of `12 - 25` (we can always search `init/Kconfig` and
    see its spec), with a default value of `18`. So, the size of the log buffer =
    2^(18) = 256 KB. However, the actual runtime size is affected by other config
    directives as well, notably `LOG_CPU_MAX_BUF_SHIFT`, which makes the size a function
    of the number of CPUs on the system. Furthermore, the relevant `Kconfig` file
    says, *"Also this option is ignored when the log_buf_len kernel parameter is used
    as it forces an exact (power of two) size of the ring buffer." *So, that's interesting;
    we can often override defaults by passing a *kernel parameter* (via the bootloader)!
  prefs: []
  type: TYPE_NORMAL
- en: 'Kernel parameters are useful, many, and varied, and are well worth checking
    out. See the official documentation here: [https://www.kernel.org/doc/html/latest/admin-guide/kernel-parameters.html](https://www.kernel.org/doc/html/latest/admin-guide/kernel-parameters.html).
    A snippet from the Linux kernel documentation on the `log_buf_len` kernel parameter
    reveals the details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Whatever the size of the kernel log buffer, two issues when dealing with the printk
    API become obvious:'
  prefs: []
  type: TYPE_NORMAL
- en: Its messages are being logged in *volatile* memory (RAM); if the system crashes
    or power cycles in any manner, we will lose the precious kernel log (often eliminating
    our ability to debug).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The log buffer isn't very large by default, typically just 256 KB; voluminous
    prints will overwhelm the ring buffer, making it wrap around, thus losing information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we fix this? Read on...
  prefs: []
  type: TYPE_NORMAL
- en: Kernel logging and systemd's journalctl
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An obvious solution to the previously mentioned issues is to write (append)
    the kernel printk to a file. This is precisely how most modern Linux distributions
    are set up. The location of the log file varies with the distro: conventionally,
    the Red Hat-based ones write into the `/var/log/messages` file and the Debian-based
    ones into `/var/log/syslog`. Traditionally, the kernel printk would hook into
    the user space *system logger daemon* (`syslogd`)to perform file logging, thus
    automatically getting the benefit of more sophisticated features, such as log
    rotation, compression, and archival.'
  prefs: []
  type: TYPE_NORMAL
- en: Over the past several years, though, system logging has been completely taken
    over by a useful and powerful new framework for system initialization called **systemd** (it replaces,
    or often works in addition to, the old SysV init framework). Indeed, systemd is
    now routinely used on even embedded Linux devices. Within the systemd framework,
    logging is performed by a daemon process called `systemd-journal`, and the `journalctl(1)`utility
    is the user interface to it.
  prefs: []
  type: TYPE_NORMAL
- en: The detailed coverage of systemd and its associated utilities is beyond the
    scope of this book. Please refer to the *Further reading* section of this chapter
    for links to (a lot) more on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'One key advantage of using the journal to retrieve and interpret logs is that **all
    logs** from applications, libraries, system daemons, the kernel, drivers, and
    so on are written (merged) here. This way, we can see a (reverse) chronological
    timeline of events without having to manually piece together different logs into
    a timeline. The man page on the `journalctl(1)`utility covers its various options
    in detail. Here, we present some (hopefully) convenient aliases based on this
    utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `-b` option `current boot` implies that the journal is displayed
    from the most recent system boot date at the present moment. A numbered listing
    of stored system (re)boots can be seen with `journalctl --list-boots`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We deliberately use the `--no-pager` option as it allows us to further filter
    the output with `[e]grep(1)`, `awk(1), sort(1)`, and so on, as required. A simple
    example of using `journalctl(1)` follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the default log format of the journal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here `[source]` is `kernel` for kernel messages, or the name of the particular
    application or service that writes the message.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s useful to see a couple of usage examples from the man page on `journalctl(1)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The non-volatile logging of kernel messages into files is very useful, of course.
    Note, though, that there exist circumstances, often dictated by hardware constraints,
    that might render it impossible. For example, a tiny, highly resource-constrained
    embedded Linux device might use a small internal flash chip as its storage medium.
    Now, not only is it small and all the space is pretty much used up by the apps,
    libraries, kernel, and bootloader, it is also a fact that flash-based chips have
    an effective limit on the number of erase-write cycles they can sustain before
    wearing out. Thus, writing to it a few million times might finish it off! So,
    sometimes, system designers deliberately and/or additionally use cheaper external
    flash memory such as (micro)SD/MMC cards (for non-critical data) to mitigate this
    impact, as they're easily replaceable.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to understanding printk log levels.
  prefs: []
  type: TYPE_NORMAL
- en: Using printk log levels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand and use printk log levels, let''s begin by reproducing that single
    line of code – the first printk from our `helloworld_lkm` kernel module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now address the elephant in the room: what exactly does `KERN_INFO` mean?
    Firstly, be careful now: it''s *not* what your knee-jerk reaction says it is –
    a parameter. No! Notice that there is no comma character between it and the format
    string; just white space. `KERN_INFO` is merely one of **eight** **log levels**that
    a kernel printk gets logged at. A key thing to understand right away is that this
    log level is *not *a priority of any sort; its presence allows us *to filter messages*
    based on log level. The kernel defines eight possible log levels for printk; here
    they are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: So, now we see that the `KERN_<FOO>` log levels are merely strings (`"0", "1",
    ..., "7"`) that get prefixed to the kernel message being emitted by printk; nothing
    more. This gives us the useful ability to filter messages based on log level.
    The comment on the right of each of them clearly shows the developer when to use
    which log level.
  prefs: []
  type: TYPE_NORMAL
- en: What's `KERN_SOH`? That's the ASCII **Start Of Header** (**SOH**) value `\001`.
    See the man page on `ascii(7)`; the `ascii(1)` utility dumps the ASCII table in
    various numerical bases. From here, we can clearly see that numeric `1` (or `\001`)
    is the `SOH` character, a convention that is followed here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s quickly look at a couple of actual examples from within the Linux kernel
    source tree. When the kernel''s `hangcheck-timer`device driver (somewhat akin
    to a software watchdog) determines that a certain timer expiry (60 seconds by
    default) was delayed for over a certain threshold (by default, 180 seconds), it
    restarts the system! Here we show the relevant kernel code – the place where the
    `hangcheck-timer` driver emits printk in this regard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Check out how the printk API was called with log level set to `KERN_CRIT`.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, squeaking out an informational message might be just what
    the doctor ordered: here, we see the generic parallel printer driver politely
    informing all concerned that the printer is on fire (rather understated, yes?):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You''d think a device being on fire will qualify the printk to be emitted at
    the "emergency" logging level... well, at least the `arch/x86/kernel/cpu/mce/p5.c:pentium_machine_check()` function
    adheres to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: (The `pr_<foo>()` convenience macros are covered next).
  prefs: []
  type: TYPE_NORMAL
- en: '**An FAQ***:* if, within the `printk()`, the log level is *not* specified,
    what log level is the print emitted at? It''s `4` by default, that is, `KERN_WARNING` (the
    *Writing to the console* section reveals why exactly this is). Note, though, that
    you are expected to always specify a suitable log level when using printk.'
  prefs: []
  type: TYPE_NORMAL
- en: There's an easy way to specify the kernel message log level. This is what we
    delve into next.
  prefs: []
  type: TYPE_NORMAL
- en: The pr_<foo> convenience macros
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The convenience **`pr_<foo>()`** macros given here ease coding pain. The clunky
  prefs: []
  type: TYPE_NORMAL
- en: '`printk(KERN_FOO "<format-str>");` is replaced with the elegant'
  prefs: []
  type: TYPE_NORMAL
- en: '`pr_foo("<format-str>");`, where `<foo>` is the log level; their use is encouraged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The kernel allows us to pass `loglevel=n` as a kernel command-line parameter,
    where `n` is an integer between `0` and `7`, corresponding to the eight log levels
    mentioned previously. As expected (as you shall soon learn), all printk instances
    with a log level less than that which was passed will be directed to the console
    device as well.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a kernel message directly to the console device is at times very useful;
    the next section deals with the details on how we can achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring to the console
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Recall that the printk output might go to up to three locations:'
  prefs: []
  type: TYPE_NORMAL
- en: The first being the kernel memory log buffer (always)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second being non-volatile log files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The last one (that we''ll address here): the *console device*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traditionally, the console device is a pure kernel feature, the initial Terminal
    window that the superuser logs into (`/dev/console`) in a non-graphical environment.
    Interestingly, on Linux, we can define several consoles – a **teletype terminal**
    (**tty**) window (such as `/dev/console`), a text-mode VGA, a framebuffer, or
    even a serial port served over USB (this being common on embedded systems during
    development; see more on Linux consoles in the *Further reading *section of this
    chapter).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, when we connect a Raspberry Pi to an x86-64 laptop via a USB-to-RS232
    TTL UART (USB-to-serial) cable (see the *Further reading *section of this chapter
    for a blog article on this very useful accessory and how to set it up on the Raspberry
    Pi!) and then use `minicom(1)` (or `screen(1)`) to get a serial console, this
    is what shows up as the `tty`device – it''s the serial port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The point here is that the console is often the target of *important-enough*
    log messages, including those originating from deep within the kernel. Linux''s printk uses
    a `proc`-based mechanism for conditionally delivering its data to the console
    device. To understand this better, let''s first check out the relevant `proc`
    pseudo-file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We interpret the preceding four numbers as printk log levels (with `0` being
    the highest and `7` the lowest in terms of "urgency"). The preceding four-integer
    sequence''s meaning is this:'
  prefs: []
  type: TYPE_NORMAL
- en: The current (console) log level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*- The implication being that all messages less than this value will appear
    on the console device!*'
  prefs: []
  type: TYPE_NORMAL
- en: The default level for messages that lack an explicit log level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The minimum allowed log level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The boot-time default log level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From this, we can see that log level `4` corresponds to `KERN_WARNING`. Thus,
    with the first number being `4` (indeed, the typical default on a Linux distro),* all
    printk instances lower than log level 4 will appear on the console device, *as
    well as being logged to a file, of course – in effect, all messages at the following
    log levels: `KERN_EMERG`,  `KERN_ALERT`,  `KERN_CRIT`, and `KERN_ERR`.
  prefs: []
  type: TYPE_NORMAL
- en: Kernel messages at log level `0 [KERN_EMERG]` are *always *printed to the console,
    and indeed to all Terminal windows and the kernel log file, regardless of any
    settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s worth noting that very often, when working on embedded Linux or any kernel
    development, you will work *on* the console device, as is the case with the Raspberry
    Pi example just given. Setting the `proc printk` pseudo-file''s first integer
    value to `8` will *guarantee that all printk instances appear directly on the
    console*, **thus making printk behave like a regular printf would!** Here, we
    show how the root user can easily set this up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: (Of course, this would have to be done as root.) This can be very convenient
    during development and test.
  prefs: []
  type: TYPE_NORMAL
- en: 'On my Raspberry Pi, I keep a startup script that contains the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[ $(id -u) -eq 0 ] && echo "8 4 1 7" > /proc/sys/kernel/printk`'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, when running it as root, this takes effect and all printk instances now
    directly appear on the `minicom(1)` console, just as `printf` would.
  prefs: []
  type: TYPE_NORMAL
- en: Talking about the versatile Raspberry Pi, the next section demonstrates running
    a kernel module on one.
  prefs: []
  type: TYPE_NORMAL
- en: Writing output to the Raspberry Pi console
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On to our second kernel module! Here, we shall emit nine printk instances,
    one at each of the eight log levels, plus one via the `pr_devel()` macro (which
    is really nothing but the `KERN_DEBUG` log level). Let''s check out the relevant
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will discuss the output when running the preceding `printk_loglvl`kernel
    module on a Raspberry Pi device. If you don't possess one or it's not handy, that's
    not a problem; please go ahead and try it out on an x86-64 guest VM.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the Raspberry Pi device (here I used the Raspberry Pi 3B+ model running
    the default Raspberry Pi OS), we log in and get ourselves a root shell via a simple `sudo
    -s`. We then build the kernel module. If you have installed the default Raspberry
    Pi image on the Raspberry Pi, all required development tools, kernel headers,
    and more will be pre-installed! Figure 4.7 is a screenshot of running our `printk_loglvl`
    kernel module on a Raspberry Pi board. Also, it''s important to realize that we''re
    running **on the console device** as we are using the aforementioned USB-to-serial
    cable over the `minicom(1)` Terminal emulator app (and *not* simply over an SSH
    connection):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad3ab2f1-3279-4131-872f-49d290740d47.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – The minicom Terminal emulator app window – the console – with the
    printk_loglvl kernel module output
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice something a bit different from the x86-64 environment: here, by default,
    the first integer in the output of `/proc/sys/kernel/printk` – the current console
    log level – is `3` (not `4`). Okay, so this implies that all kernel printk instances
    at log level *less than log level 3* will appear directly on the console device.
    Look at the screenshot: this is indeed the case! Furthermore, and as expected,
    the printk instanceat the "emergency" log level (`0`) always appears on the console,
    indeed on every open Terminal window.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the interesting part: let''s set (as root, of course) the current console
    log level (remember, it''s the first integer in the output of `/proc/sys/kernel/printk`)
    to the value `8`. This way, all printk instances should appear directly on the
    console*.* We test precisely this here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4140c171-54f0-4ebf-aca5-ebffc5db9963.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – The minicom Terminal – in effect, the console – window, with the
    console log level set to 8
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, as expected, we see *all* the printk instances on the console device
    itself obviating the need to use `dmesg`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hang on a moment, though: whatever happened to the `pr_debug()` and `pr_devel()` macros
    emitting a kernel message at log level `KERN_DEBUG` (that is, integer value `7`)?
    It has *not *appeared here, nor in the following `dmesg` output? We explain this
    shortly; please read on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With `dmesg(1)`, of course, all kernel messages – well, at least those still
    in the kernel log buffer in RAM – will be revealed. We see this to be the case
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: All printk's instances – except the `KERN_DEBUG` ones – are seen as we are looking
    at the kernel log via the `dmesg` utility. So, how do we get a debug message displayed?
    That's covered next.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the pr_debug() kernel messages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Ah yes, `pr_debug()` turns out to be a bit of a special case: unless the `DEBUG` symbol is
    *defined* for the kernel module, a `printk`instance at log level `KERN_DEBUG` does
    not show up. We edit the kernel module''s Makefile to enable this. There are (at
    least) two ways to set this up:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Insert this line into the Makefile:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Generically, it's `CFLAGS_<filename>.o  :=  -DDEBUG`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could also just insert this statement into the Makefile:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In our Makefile, we have deliberately kept the `-DDEBUG` commented out, to
    begin with. Now, to try it out, un-comment one of the following commented-out
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Once done, we remove the old stale kernel module from memory, rebuild it, and
    insert it using our `lkm`script. The output reveals that `pr_debug()`now does
    take effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'A partial screenshot (Figure 4.9) of the `lkm` script''s output clearly reveals
    the `dmesg` color-coding, with `KERN_ALERT / KERN_CRIT / KERN_ERR` background
    highlighted in red/in bold red typeface/in red foreground color, respectively,
    and `KERN_WARNING` in bold black typeface, helping us humans quickly spot important
    kernel messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/76a8a54e-f3c7-4d0a-9c5f-764cc68d4686.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – Partial screenshot of lkm script's output
  prefs: []
  type: TYPE_NORMAL
- en: Note that the behavior of `pr_debug()` is not identical when the dynamic debug feature
    (`CONFIG_DYNAMIC_DEBUG=y`) is enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Device driver authors should note that for the purpose of emitting debug `printk`
    instances, they should avoid using `pr_debug()`. Instead, it is recommended that
    a device driver uses the `dev_dbg()` macro (additionally passing along a parameter
    to the device in question). Also, `pr_devel()` is meant to be used for kernel-internal
    debug `printk` instances whose output should never be visible in production systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, back to the section on console output. So, for perhaps the purpose of
    kernel debugging (if nothing else), is there a guaranteed way to ensure that *all*
    printk instances are directed to the console*? *Yes, indeed – just pass the kernel
    (boot-time) parameter called `ignore_level`. For more details on this, do look
    up the description in the official kernel documentation: [https://www.kernel.org/doc/html/latest/admin-guide/kernel-parameters.html](https://www.kernel.org/doc/html/latest/admin-guide/kernel-parameters.html).
    Toggling the ignoring of the printk log level is also possible: as mentioned there,
    you can turn on the ignoring of printk log levels by doing this, thus allowing
    all printk''s to appear on the console device (and conversely, turn it off by
    echoing N into the same pseudo-file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The `dmesg(1)` utility can also be used to control the enabling/disabling of
    kernel messages to the console device, as well as the console logging level (that
    is, the level numerically below which messages will appear on the console) via
    various option switches (in particular, the `--console-level` option). I leave
    it to you to browse through the man page on `dmesg(1)` for the details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next segment deals with another very useful logging feature: rate-limiting.'
  prefs: []
  type: TYPE_NORMAL
- en: Rate limiting the printk instances
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we emit `printk` instances from a code path that is executed very often,
    the sheer amount of `printk` instances might quickly overflow the kernel log buffer
    (in RAM; remember that it's a circular buffer), thus overwriting what might well
    be key information. Besides that, ever-growing non-volatile log files that then
    repeat pretty much the same `printk` instances (almost) ad infinitum are not a
    great idea either and waste disk space, or worse, flash space. For example, think
    of a large-ish printk in an interrupt handler code path. What if the hardware
    interrupt is invoked at a frequency of, say, 100 Hz, that is, 100 times every
    single second!
  prefs: []
  type: TYPE_NORMAL
- en: 'To mitigate these issues, the kernel provides an interesting alternative: the *rate-limited *printk*.*
    The `printk_ratelimited()` macro has identical syntax to the regular printk; the
    key point is that it effectively *suppresses* regular prints when certain conditions
    are fulfilled. The kernel provides two control files named `printk_ratelimit`
    and `printk_ratelimit_burst` via the `proc` filesystem for this purpose. Here,
    we directly reproduce the `sysctl` documentation (from [https://www.kernel.org/doc/Documentation/sysctl/kernel.txt](https://www.kernel.org/doc/Documentation/sysctl/kernel.txt))
    that explains the precise meaning of these two (pseudo) files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'On our Ubuntu 18.04.3 LTS guest system, we find that their (default) values
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This implies that by default, up to 10 instances of the same message occurring
    within a 5-second time interval can make it through before rate limiting kicks
    in.
  prefs: []
  type: TYPE_NORMAL
- en: The printk rate limiter, when it does suppress kernel `printk` instances, emits
    a helpful message mentioning exactly how many earlier printk callbacks were suppressed.
    As an example, we have a custom kernel module that makes use of the `Kprobes`framework
    to emit a `printk` instance prior to every call to `schedule()`, the kernel's
    core scheduling routine.
  prefs: []
  type: TYPE_NORMAL
- en: A **kprobe** is essentially an instrumentation framework often leveraged for
    production system troubleshooting; using it, you can specify a function that can
    be set to execute before or after a given kernel routine. The details are beyond
    the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, as scheduling occurs often, a regular printk would cause the kernel log
    buffer to quickly overflow. Precisely this sort of situation warrants the use
    of the rate-limited printk. Here, we see some sample output from our example kernel
    module (we don''t show it''s code here) using the `printk_ratelimited()` API via
    a `kprobe` that sets up a *pre-handler* function called `handle_pre_schedule()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'A code-level example of using the rate-limited printk is seen in the interrupt
    handler code of the Linux kernel''s **Real-Time Clock** (**RTC**) driver here:
    `drivers/char/rtc.c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Don't mix up the `printk_ratelimited()` macro with the older (and now deprecated) `printk_ratelimit()` macro.
    Also, the actual rate-limiting code is in `lib/ratelimit.c:___ratelimit()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, just as with the `pr_<foo>` macros we saw earlier, the kernel also provides
    the equivalent `pr_<foo>_ratelimited` macros for generating a kernel printk at
    log level `<foo>` with rate limiting enabled. Here''s a quick list of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Can we generate kernel-level messages from user space? Sounds interesting; that's
    our next sub-topic.
  prefs: []
  type: TYPE_NORMAL
- en: Generating kernel messages from the user space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A popular debug technique that we programmers use is to sprinkle prints at various
    points in the code, often allowing us to narrow down the source of an issue. This
    is indeed a useful debugging technique and is called **instrumenting** the code.
    Kernel developers often use the venerable printk API for just this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, imagine you have written a kernel module and are in the process of debugging
    it (by adding several printk''s). Your kernel code now emits several printk instances,
    which, of course, you can see at runtime via `dmesg` or some other means. That''s
    fine, but what if, especially because you''re running some automated user space
    test script, you''d like to see the point at which the script initiated some action
    within our kernel module, by printing out a certain message. As a concrete example,
    say we want the log to look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We can have our user space test script write a message into the kernel log
    buffer, just like a kernel printk would, by writing said message into the special
    `/dev/kmsg` device file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, hang on – doing so requires running with root access, of course. However,
    notice here that a simple `sudo(8)` before `echo` just doesn''t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The syntax used in the second attempt works, but it's just simpler to get yourself
    a root shell and carry out tasks such as this.
  prefs: []
  type: TYPE_NORMAL
- en: 'One more thing: the `dmesg(1)` utility has several options designed to make
    the output more human-readable; we show some of them via our sample alias to `dmesg` here,
    after which we use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The message written to the kernel log via the special `/dev/kmsg` device file will
    be *printed* at the current default log level, typically, `4 : KERN_WARNING`.
    We can override this by actually prefixing the message with the required log level
    (as a number in string format). For example, to write from the user space into
    the kernel log at log level `6 : KERN_INFO`, use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We can see that our latter message is emitted at log level `6`, as specified
    within `echo`.
  prefs: []
  type: TYPE_NORMAL
- en: There is really no way to distinguish between a user-generated kernel message
    and a kernel `printk()`*-*generated one; they look identical. So, of course, it
    could be as simple as inserting some special signature byte or string within the
    message, such as `@user@`, in order to help you distinguish these user-generated
    prints from the kernel ones.
  prefs: []
  type: TYPE_NORMAL
- en: Standardizing printk output via the pr_fmt macro
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A last but important point regarding the kernel printk; pretty often, to give
    context to your `printk()` output (*where exactly did it occur?*), you might write
    the code like this, taking advantage of various gcc macros (like `__FILE__`, `__func__`,
    and `__LINE__`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This is fine; the problem is, if there are a lot of printk's in your project,
    it can be fairly painful to guarantee a standard printk format (for example, first
    displaying the module name followed by the function name and possibly the line
    number, as seen here) is always followed by everyone working on the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the `pr_fmt` macro; defining this macro right at the beginning of your
    code (it must be even before the first `#include`), guarantees that every single
    subsequent printk in your code *will be prefixed with the format specified by
    this macro*. Lets take an example (we show a snippet of code from the next chapter;
    worry not, it''s really very simple, and serves as a template for your future
    kernel modules):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pr_fmt()` macro is highlighted in bold font; it uses the pre-defined `KBUILD_MODNAME`
    macro to substitute the name of your kernel module, and the gcc `__func__` specifier
    to display the name of the function we''re currently running! (You can even add
    a `%d` matched by the corresponding `__LINE__` macro to display the line number).
    So, bottom line: the `pr_info()` we emit in the `init` function of this LKM will
    display like this in the kernel log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the LKM name and the function name are automatically prefixed. This
    is very useful and indeed very common; in the kernel, literally hundreds of source
    files begin with the `pr_fmt()`. (A quick search on the 5.4 kernel code base revealed
    over 2,000 instances of this macro in the code base! We too shall follow this
    convention, though not in all our demo kernel modules).
  prefs: []
  type: TYPE_NORMAL
- en: The `pr_fmt()` also takes effect on the recommended printk usage for driver
    authors - via the `dev_<foo>()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Portability and the printk format specifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's a question to ponder regarding the versatile printk kernel API, how
    will you ensure that your printk output looks correct (is correctly formatted)
    and works equally well on any CPU regardless of bit width? The portability issue
    raises its head here; the good news is that getting familiar with the various
    format specifiers provided will help you a great deal in this regard, in effect
    allowing you to write arch-independent printks.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to realize that the `size_t` - pronounced *size type* - is a `typedef` for
    an unsigned integer; similarly, `ssize_t` (*signed size type*) is a `typedef` for
    a signed integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a few top-of-mind common printk format specifiers to keep in mind when
    writing portable code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For `size_t`, `ssize_t` (signed and unsigned) integers : use `%zd` and `%zu` respectively'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kernel pointers: use `%pK` for security (hashed values), `%px` for actual pointers
    (don''t use this in production!), additionally, use `%pa` for physical addresses
    (must pass it by reference)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raw buffer as a string of hex characters : `%*ph` (where `*`  is replaced by
    the number of characters; use for buffers within 64 characters, use the `print_hex_dump_bytes()` routine
    for more); variations are available (see the kernel doc, link follows)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IPv4 addresses with `%pI4`, IPv6 addresses with `%pI6` (variations too)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An exhaustive list of printk format specifiers, which to use when (with examples)
    is part of the official kernel documentation here: [https://www.kernel.org/doc/Documentation/printk-formats.txt](https://www.kernel.org/doc/Documentation/printk-formats.txt).
    The kernel also explicitly documents the fact that using the unadorned `%p` in
    a `printk()` statement can lead to security issues (link: [https://www.kernel.org/doc/html/latest/process/deprecated.html#p-format-specifier](https://www.kernel.org/doc/html/latest/process/deprecated.html#p-format-specifier)).
    I urge you to browse through it!'
  prefs: []
  type: TYPE_NORMAL
- en: Okay! Let's move towards completing this chapter by learning the basics of how
    the Makefile for your kernel module builds the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the basics of a kernel module Makefile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will have noticed that we tend to follow a *one-kernel-module-per-directory*
    rule of sorts. Yes, that definitely helps keep things organized. So, let's take
    our second kernel module, the `ch4/printk_loglvl`one. To build it, we just `cd`
    to its folder, type `make`, and (fingers crossed!) voilà, it's done. We have the `printk_loglevel.ko`kernel
    module object freshly generated (which we can then `insmod(8)/rmmod(8)`). But
    how exactly did it get built when we typed `make`? Ah, explaining this is the
    purpose of this section.
  prefs: []
  type: TYPE_NORMAL
- en: As this is our very first chapter that deals with the LKM framework and its
    corresponding Makefile, we will keep things nice and simple, especially with regard
    to the Makefile here. However, early in the following chapter, we shall introduce
    a more sophisticated, simply *better*Makefile (that is still quite simple to understand).
    We shall then use this better Makefile in all subsequent code; do look out for
    it and use it!
  prefs: []
  type: TYPE_NORMAL
- en: 'As you will know, the `make` command will by default look for a file named
    `Makefile` in the current directory; if it exists, it will parse it and execute
    command sequences as specified within it. Here''s our Makefile for the kernel
    module `printk_loglevel` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'It should go without saying that the Unix Makefile syntax basically demands
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The `rule(s)` instances are always prefixed with a `[Tab]` character, *not* white
    space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s gather the basics regarding how this Makefile works. First off, a key
    point is this: the kernel''s `Kbuild` system (which we''ve been mentioning and
    using since [Chapter 2](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml), *Building
    the 5.x Linux Kernel from Source – Part 1*), primarily uses two variable strings
    of software to build, chained up within the two `obj-y` and `obj-m` variables.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `obj-y` string has the concatenated list of all objects to build and merge
    into the final kernel image files - the uncompressed `vmlinux`and the compressed
    (boot-able) `[b]zImage`images. Think about it – it makes sense: the `y` in `obj-y` stands
    for *Yes.* All kernel built-ins and `Kconfig` options that were set to `Y` during
    the kernel configuration process (or are `Y` by default) are chained together
    via this item, built, and ultimately woven into the final kernel image files by
    the `Kbuild` build system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, it''s now easy to see that the `obj-m` string is a concatenated
    list of all kernel objects to build *separately*, *as kernel modules*! This is
    precisely why our Makefile has this all-important line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'In effect, it tells the `Kbuild` system to include our code; more correctly,
    it tells it to implicitly compile the `printk_loglvl.c` source code into the `printk_loglvl.o`binary
    object, and then add this object to the `obj-m` list. Next, the default rule for
    `make` being the `all` rule, it is processed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The processing of this single statement is quite involved; here''s what transpires:'
  prefs: []
  type: TYPE_NORMAL
- en: The `-C` option switch to `make` has the `make` process *change directory* (via
    the `chdir(2)` system call) to the directory name that follows `-C`. Thus, it
    changes directory to the kernel `build` folder (which, as we covered earlier,
    is the location of the 'limited' kernel source tree that got installed via the
    `kernel-headers` package).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once there, it *parses in* the content of the *kernel's top-level* Makefile –
    that is, the Makefile that resides there, in the root of this limited kernel source
    tree. This is a key point. This way, it's guaranteed that all kernel modules are
    tightly coupled to the kernel that they are being built against (more on this
    a bit later). This also guarantees that kernel modules are built with the exact
    same set of rules, that is, the compiler/linker configurations (the `CFLAGS` options,
    the compiler option switches, and so on), as the kernel image itself is. All this
    is required for binary compatibility.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you can see the initialization of the variable named `M`, and that the target specified
    is `modules`; hence, the `make` process now changes directory to that specified
    by the `M` variable, which you can see is set to `$(PWD)` – the very folder we
    started from (the present working directory; the `PWD := $(shell pwd)` in the
    Makefile initializes it to the correct value)!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, interestingly, it''s a recursive build: the build process, having (very
    importantly) parsed the kernel top-level Makefile, now switches back to the kernel
    module''s directory and builds the module(s) therein.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you notice that when a kernel module is built, a fair number of intermediate
    working files are generated as well? Among them are `modules.order`, `<file>.mod.c`,
    `<file>.o`, `Module.symvers`,  `<file>.mod.o`,  `.<file>.o.cmd`, `.<file>.ko.cmd`,
    a folder called `.tmp_versions/`, and, of course, the kernel module binary object
    itself, `<file>.ko` – the whole point of the build exercise. Getting rid of all
    these objects, including the kernel module object itself, is easy: just perform
    `make clean`. The `clean` rule cleans it all up. (We shall delve into the `install` target
    in the following chapter.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can look up what the `modules.order` and `modules.builtin` files (and other
    files) are meant for within the kernel documentation here: `Documentation/kbuild/kbuild.rst`.'
  prefs: []
  type: TYPE_NORMAL
- en: Also as mentioned previously, we shall, in the following chapter, introduce
    and use a more sophisticated Makefile variant - **a 'better' Makefile**; it is
    designed to help you, the kernel module/driver developer, improve code quality
    by running targets related to kernel coding style checks, static analysis, simple
    packaging, and (a dummy target) for dynamic analysis.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we conclude this chapter. Well done – you are now well on your way
    to learning Linux kernel development!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the basics of Linux kernel architecture and the
    LKM framework. You learned what a kernel module is and why it's useful. We then
    wrote a simple yet complete kernel module, a very basic *Hello, world*. The material
    then delved further into how it works, along with how to load it, see the module
    listing, and unload it. Kernel logging with printk was covered in some detail,
    along with rate limiting printk, generating kernel messages from the user space,
    standardizing it's output format, and understanding the basics of the kernel module
    Makefile.
  prefs: []
  type: TYPE_NORMAL
- en: That ends this chapter; I urge you to work on the sample code (via the book's
    GitHub repository), work on the *Questions*/assignments, and then proceed on to
    the next chapter, continuing our coverage of writing a Linux kernel module.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material: [https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/questions](https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/questions).
    You will find some of the questions answered in the book''s GitHub repo: [https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/solutions_to_assgn](https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/solutions_to_assgn).'
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To help you delve deeper into the subject with useful materials, we provide
    a rather detailed list of online references and links (and at times, even books)
    in a *Further reading* document in this book's GitHub repository. The *Further
    reading* document is available here: [https://github.com/PacktPublishing/Linux-Kernel-Programming/blob/master/Further_Reading.md](https://github.com/PacktPublishing/Linux-Kernel-Programming/blob/master/Further_Reading.md).
  prefs: []
  type: TYPE_NORMAL
