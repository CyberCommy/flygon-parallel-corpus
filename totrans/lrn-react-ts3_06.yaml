- en: Component Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will continue with the React shop we were building previously.
    We'll build a reusable tab component as well as a reusable loading indicator component
    that will both be used on the product page in our shop. The chapter will start
    by splitting the product page into a container and a presentational component
    before working on the tab component, leveraging the compound component and render
    props patterns. We'll then move on to implement a loading indicator component
    using the higher-order component pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Container and presentational components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compound components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Render props pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher-order components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll use the following technologies in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Node.js and** `npm`: TypeScript and React are dependent on these. We can
    install these from: [https://nodejs.org/en/download/](https://nodejs.org/en/download/).
    If we already have these installed, make sure `npm` is at least version 5.2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual Studio Code**: We''ll need an editor to write our React and TypeScript
    code, which can be installed from [https://code.visualstudio.com/](https://code.visualstudio.com/).
    We will also need the TSLint (by egamma) and Prettier (by Estben Petersen) extensions
    installed within Visual Studio Code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**React shop**: We''ll start from the project we began in the chapter where
    we looked at React Router. This is available on GitHub at: [https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/04-ReactRouter](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/04-ReactRouter).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the code snippets in this chapter can be found online at: [https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/06-ComponentPatterns](https://github.com/carlrip/LearnReact17WithTypeScript/tree/master/06-ComponentPatterns).
  prefs: []
  type: TYPE_NORMAL
- en: Container and presentational components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Splitting pages up into container and presentational components makes the presentational
    component easier to reuse. The container component is responsible for how things
    work, fetching any data from a web API and managing state. The presentational component
    is responsible for how things look. Presentational components receive data via
    their properties and also have property event handlers so that their container
    can manage the user interactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going use this pattern in our React shop to split the product page into
    container and presentational components. The `ProductPage` component will be the
    container and we''ll introduce a new component called `Product` that will be the presentational
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by opening our shop project in Visual Studio Code and entering
    the following command in a terminal to start the app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If we navigate to a product, let''s remind ourselves what the product page
    looks like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/fe7f8f05-1de1-488a-a184-9faace7ade77.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s create a new file called `Product.tsx` that will contain our presentational
    component with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Our presentational component is a function component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Presentational components receive data via props and also delegate event handling
    via props. So, let''s create props for the product data item, whether it has been
    added to the basket, and the handler for adding it to the basket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at `ProductsPage.tsx`, we are going to copy the JSX for when there
    is a product that is the `React.Fragment` section. We then paste this into the
    return statement for our `Product` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We have a few reference issues now to resolve.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define a product variable above the return statement to resolve the issue
    with the product reference in the JSX:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Whether the product is in the basket is passed in via the `inBasket` prop now.
    So, let''s change the conditional around the Add to Basket button to use this
    prop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The final reference issue we need to resolve is with the handler for clicking
    the Add to Basket button. Let''s first create a handler that simply calls the
    `onAddToBasket` prop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can remove the `this` reference where we reference this handler in the JSX:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: That's our `Product` presentational component complete for the time being. So,
    let's reference our `Product` component in our `ProductPage` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s import our `Product` component into `ProductPage.tsx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s replace the section we copied in the JSX with our `Product` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We pass the product, whether the product has been added to basket, and the handler
    for adding to the basket together as props to the `Product` component.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the shop again and go to the product page, it will look exactly
    the same.
  prefs: []
  type: TYPE_NORMAL
- en: So, we just implemented our first container and presentational components. Container
    components are great as the top-level component within a page, fetching data from
    a web API, and managing all the state within the page. Presentational components
    just focus on what needs to be rendered to the screen. A benefit of this pattern
    is that presentational components can be used elsewhere in the app more easily.
    For example, our `Product` component could fairly easily be used on other pages
    that we create in our shop. Another benefit of this pattern is that presentational
    components are generally easier to unit-test. In our example, our `Product` component is
    a pure function and so unit-testing this is simply a case of checking that the
    output is correct for different inputs because there are no side-effects. We'll
    cover unit testing in detail later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: We'll continue to enhance our product page in the next section by adding reviews
    to it and adding tabs to separate the product description from the reviews.
  prefs: []
  type: TYPE_NORMAL
- en: Compound components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Compound components are a set of components that work together. We are going
    to use this pattern to create a reusable tab component for use on the product
    page to separate reviews the product descriptions.
  prefs: []
  type: TYPE_NORMAL
- en: Adding reviews to a product
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we create our `Tabs` compound component, let''s add reviews to the product
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to add an interface for the review data structure in `ProductsData.ts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now add reviews to our product interface :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now add reviews to our product data array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: So, we add a `reviews` property to each product that is an array of reviews.
    Each review is an object containing `comment` and `reviewer` properties as defined
    by the `IReview` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our data in place, let''s add the reviews to our `Product` component after
    the description:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: So, we are using the `map` function on the `reviews` array to display `comment`
    and `reviewer` in a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have referenced some new CSS classes, so let''s add these into `index.css`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at the running app and go to a product, we''ll now see the reviews:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d72a2bb2-abca-46ce-a62a-c3b1c78c5741.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have added the reviews, we can work on our `Tabs` component in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic tab component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our job now is to separate the description from the reviews using a tab component
    that we are going to build. We are going to create a simple tab component first
    and refactor this into the compound component pattern in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to start on our tab component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a file called `Tabs.tsx` for our tab component with the
    following content in it as a skeleton class component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We have chosen to create a class-based component because our component will
    have to track state for whichever tab heading is active.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s complete the interface for our state by adding a property that will
    give the active heading name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Our component will take in the tab headings and display them as properties.
    So, let''s complete our interface for this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: So, our component can take in an array of heading names in a `headings` prop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the initial value for the `activeHeading` state in the constructor
    now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: So, the active heading will initially be set to the first element in the `headings`
    array. The ternary ensures our component doesn't produce an error if no tabs have
    been passed to it by the consumer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on to the render method now, let''s render our tabs in a list by mapping
    over the `headings` prop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We have referenced some CSS classes including `active`, which is set using a
    ternary based on whether it is the active tab heading being rendered or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add these CSS classes to `index.css` now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Before we can see what our tab component looks like, we need to consume it.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s add this on the `Product` component by first importing the `Tabs`
    component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now add the `Tabs` component in between the product name and description:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We pass the `Tabs` component the two tab headings we want to display, which
    are Description and Reviews.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2224eb38-ef28-4945-9ee0-e297c2a8a6e1.png)'
  prefs: []
  type: TYPE_IMG
- en: That's a good start. The first tab is underlined from the `active` CSS style
    just as we wanted. If we click on the Reviews tab nothing happens, though.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s reference the click handler back in `Tabs.tsx` for each tab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s implement the click handler as well now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We first extract the heading from the `textContent` of `li`. We then set the
    `activeHeading` state to this. This will cause React to re-render the component
    with the clicked tab shown as being active.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we help the TypeScript compiler declare the `li` variable as `HTMLLIElement`
    using the `as` keyword. Without doing this, the compiler wouldn't be happy with
    us accessing the `textContent` property within it.
  prefs: []
  type: TYPE_NORMAL
- en: If we go to the running app again, we can now click on our tabs and see the
    active state changing.
  prefs: []
  type: TYPE_NORMAL
- en: At the moment, our tabs component just renders some tabs that can be clicked
    on. It doesn't tie into any content yet. We'll actually not tie in our headings
    to content until the next section on the render props pattern. However, now it's
    time to explore the compound component pattern and enhance our tab headings a
    little more in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging the compound component pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our tab headings can only be strings at the moment. What if we want to allow
    the consumer of the component to define richer content in the headings? For example,
    a consumer might want to put an icon in front of a tab heading or make a heading
    bold. So, the consuming JSX could look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, `Tabs` and `Tabs.Tab` are compound components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Tabs` is the component that renders the `Tabs.Tab` components within it. It
    also manages the state for whichever tab is active.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Tabs.Tab` renders a single heading. It takes a unique tab name as a property,
    which allows the active tab to be managed. It also takes in a `boolean` property called
    `initialActive` that sets that tab to be active when first loaded. The heading
    that is rendered is the content within the `Tabs.Tab` tag. So, the first tab will
    render Description in bold.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, let''s refactor our basic tabs component into a compound component that
    can be used similarly to the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Tabs` component no longer takes in any properties, so, let''s remove the
    `IProps` interface. We can remove the constructor because we no longer need to
    initialize the state from the props. Let''s also change the name of our state
    property from `activeHeading` to `activeName` as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to work on the `Tab` component within `Tabs`, first. So, let''s
    create an interface for its properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `name` property is a unique name for the tab. This will be used later to
    help us manage the active tab.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `initialActive` property specifies whether the tab is active when the component
    first loads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s add the following `Tab` function component inside our `Tabs` class component
    now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This is the start of the component that will render each tab. The `Tab` component
    is defined as a static property on the `Tabs` component. This means `Tab` lives
    on the actual `Tabs` class and not in its instances. So, we must remember we don't
    have access to any `Tabs` instance members (for instance, `this`). However, we
    can reference `Tab` in JSX using `Tabs.Tab` now, which was one of our requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the moment, `Tab` is just rendering `li` with a note reminding us that we
    need to somehow render the child nodes of the component. Remember that we want
    the consuming markup for our `Tabs` component to be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'So, our render function needs to somehow render `<b> Description </b>` inside
    our `li` tag. How do we do this? The answer is via a special property called `children`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: React component properties can be of any type, including React nodes. The `children` property
    is a special property that React gives a component that contains the component's
    child nodes. We render a component's child nodes in JSX by referencing the `children` property
    in curly brackets.
  prefs: []
  type: TYPE_NORMAL
- en: Our `Tab` component is not finished, but we'll leave it like this for the time
    being. We now need to move on to the `Tabs` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `render` method in the `Tabs` class is simply going to render its child
    nodes now. Let''s replace this method with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We again use the magical `children` property to render the child nodes within
    `Tabs`.
  prefs: []
  type: TYPE_NORMAL
- en: We are progressing well with our compound `Tabs` and `Tab` components but our
    project no longer compiles because we have the tab click handler, `handleTabClick`,
    that is not referenced anymore. We need to somehow reference it from the `Tab` component
    when a tab heading is clicked, but remember `Tab` doesn't have access to members
    of `Tabs`. So, how can we do this? We'll find the answer to this problem in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing state with React context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'React context allows state to be shared between components. It works really
    well with compound components. We are going to use it in our `Tabs` and `Tab`
    components to share state between them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first task is to create an interface for the context we are going to use
    in `Tabs.tsx` at the top of the file just beneath the import statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: So, our context will contain the active tab name as well as a reference to a
    tab click handler. These are the two bits of state that need to be shared between
    the components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s create the context underneath the `ITabsContext` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We've used the `createContext` function in React to create our context, which
    is a generic function that creates a context of a generic type, which in our case
    in `ITabsContext`.
  prefs: []
  type: TYPE_NORMAL
- en: We are required to pass the default context value as the parameter value to
    `createContext` but that doesn't make sense in our case, so we just pass an empty `{}`
    object to keep the TypeScript compiler happy. This is why both the properties
    in `ITabsContext` are optional.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to use this context now in our compound components. The first thing
    we need to do is to define the context provider in the `Tabs` `render` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few things going on here, so let''s break this down:'
  prefs: []
  type: TYPE_NORMAL
- en: The constant for our context we declared earlier, `TabsContext`, is available
    in JSX as a `<TabsContext />` component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The context provider fills the context with values. Given that `Tabs` manages
    the state and event handling, it makes sense for the provider to be referenced
    there.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We reference the provider using `<TabsContext.Provider />`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The provider takes in a property called `value` for the context value. We set
    this to an object containing the active tab name and the tab click event handler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We need to adjust the tab click handler slightly because the click isn''t going
    to be handled directly in `Tabs` anymore. So, we simply need to take in the active
    tab name as a parameter and then set the active tab name state within the method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have fed the context some data, it''s time to consume this in the
    `Tab` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This again looks a little daunting, so let''s break it down:'
  prefs: []
  type: TYPE_NORMAL
- en: We can consume a context via a `Consumer` component within the context component.
    So, this is `<TabsContext.Consumer />` in our case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The child for `Consumer` needs to be a function that has a parameter for the
    context value and returns some JSX. `Consumer` will then render the JSX we return.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't worry if this is still a little confusing. We'll cover this pattern in
    a lot more detail later when we cover children props and render props.
  prefs: []
  type: TYPE_NORMAL
- en: This context function gives us everything we need to render the tab. We have
    access to the state from the `context` argument as well as access to the `Tab`
    component `props` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first line of the function determines the active tab name by using what
    is in the context. If the active tab in the context is an empty string, we use
    the current tab name if it has been defined as the initial active tab.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second line of the function creates a tab click handler that calls the context
    tab click handler if it has been specified.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The return statement is as it was before, but we've been able to add a reference
    to the tab click handler and the class name now.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, that's it for our tabs compound component. The syntax for React context
    may seem a little strange at first, but when you get used to it, it is really
    simple and elegant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can give this a try, we need to consume our compound component in
    our `Product` component. Let''s replace our previous consumption of the `Tabs`
    component with the following highlighted JSX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This is exactly the JSX we wanted to achieve when we started to build the compound
    tabs component. If we go to the running app and browse to the product page, our
    tabs component works perfectly, with the description tab in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2cb6cee1-2be4-4f5b-b4a2-d71dbe9bf45d.png)'
  prefs: []
  type: TYPE_IMG
- en: So, compound components are great for components that rely on each other. The `<Tabs.Tab
    />` syntax really *calls out the fact* that `Tab` needs to be used with `Tabs`.
  prefs: []
  type: TYPE_NORMAL
- en: React context works really well with compound components allowing the components,
    in the compound to easily share state. The state can even include functions such
    as event handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing the consumer to specify the content to be rendered in sections of a
    component gives the consumer a great deal of flexibility. Specifying this custom
    content as a child of a component is intuitive and feels natural. We'll continue
    with this approach in the following section where we'll complete our tabs component.
  prefs: []
  type: TYPE_NORMAL
- en: Render props pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We used a form of the render props pattern in the previous section where we
    leveraged the `children` prop. We used this to allow a consumer of our `Tab` component
    to render custom content for the tab heading. This is great, but what if we want
    to allow the consumer to render custom content in different sections of the component?
    In our `Tabs` component, we haven't allowed the consumer to render the content
    of the tab yet. We definitely want the consumer to be able to specify custom content
    for this, but how do we do this now that we've already used the `children` prop
    for the heading?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is simple but not obvious at first. The answer is that, because props
    can be anything, they can be a function that renders content – just like the special
    `children` prop. These types of prop are called render props. We can have as many
    render props as we like, giving us the flexibility to allow multiple sections
    of a component to be rendered by the consumer.
  prefs: []
  type: TYPE_NORMAL
- en: We actually used a render prop in the last section when we used React context.
    The way we consumed the context was via a render prop.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll complete our `Tabs` component by leveraging the render props pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Completing Tabs with render props
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to complete our Tabs component now by using the render props pattern. Before
    we implement our first render prop, let''s think about how we want the consumer
    to consume our `Tabs` component when it has been completed. The following JSX
    is how we would ideally consume the `Tabs` component from the `Product` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go through the steps of the key parts in this:'
  prefs: []
  type: TYPE_NORMAL
- en: We are still using compound components. Render props work perfectly fine with
    these components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The heading for each tab is no longer defined in the child of the `Tab` component.
    Instead, we use a `heading` render prop where we can still render a simple string
    or richer content.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tab content is then specified as the child of the `Tab` component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using render prop for tab headings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, let''s change the implementation of the tab headings to use a render prop:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Tabs.tsx`, let''s start by adding a new property in the tab props interface
    for the heading:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This property is a function with no parameters that returns a `string` or some
    JSX. This is the definition of our render prop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changing the implementation is very straightforward. We simply replace the
    call to the `children` prop function with our new render prop function in the
    return statement in the `Tab` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s switch the consumption of `Tabs` in `Product.tsx` to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We may get a TSLint warning: Lambdas are forbidden in JSX attributes due to
    their rendering performance impact. It is useful to know that lambdas can be problematic
    so that we can keep this in mind for when we do experience a performance problem.
    However, we are going to switch this rule off in `tslint.json` by specifying `"jsx-no-lambda"`
    as `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: If we want to be super performance-conscious, instead of using a lambda function
    we can reference a method within the component.
  prefs: []
  type: TYPE_NORMAL
- en: After we have saved the new TSLint settings, the compiler complaint will hopefully
    go away. Note that we may need to kill the Terminal and `npm start` the app again
    for the compiler complaint to go away.
  prefs: []
  type: TYPE_NORMAL
- en: If we try using the product page in our app, it will behave just as it did before.
  prefs: []
  type: TYPE_NORMAL
- en: So, implementing the render prop pattern is very simple. The most time-consuming
    thing with this pattern is understanding what it can do and how it works. Once
    we've got to grips with it, it is an excellent pattern we can use to provide rendering
    flexibility to consumers of our components.
  prefs: []
  type: TYPE_NORMAL
- en: We have just one more section to go now before our `Tab` component is complete.
  prefs: []
  type: TYPE_NORMAL
- en: Using children prop for tab content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The finish line is in sight now for our `Tab` component. The final task is
    to allow consumers to render tab content. We''ll use the `children` prop to do
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, in `Tabs.tsx`, let''s change the `handleTabClick` property in our
    context interface to include the content to render:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We are also going to hold the active content in state along with the active
    tab name. So, let''s add this to the state interface for `Tabs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now change the tab click handler in `Tabs` to set the state for the
    active content along with the active tab name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Tab` component, let''s call the tab click handler with the additional
    parameter for the tab content by passing the `children` prop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s render the active content from our state in the `Tabs` `render`
    method under where we render the tab headings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s change how we consume the `Tabs` component in the `Product` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The tab content is now nested within each `Tab` component exactly how we wanted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s give this a try. If we go to the product page we notice an issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f8461702-bc71-4f68-9eb0-8e684520a27d.png)'
  prefs: []
  type: TYPE_IMG
- en: The content isn't being rendered when the page first loads. If we click on the
    Reviews tab or the Description tab, the content then loads.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is that we don''t have any code to render the content when the
    tabs initially load. So, let''s resolve this in the `Tab` component by adding
    the highlighted lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted lines invoke the tab click handler if there is no active tab
    in the context and the tab is flagged as initially active. In this case, we return
    null because invoking the tab click will set the state for the active tab, which
    will cause another rendering cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our tabs component should now be complete. Let''s check by going to the product
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cc55df59-386e-410e-a76f-6f37c42b5e7f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The content renders as we expect. If we click on the Reviews tab, this renders
    fine as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5bae7243-ea0b-4a76-bcb1-7cb5e88cac12.png)'
  prefs: []
  type: TYPE_IMG
- en: So, the render props and children props patterns are great for allowing consumers
    to render custom content. The syntax may look a little tricky at first, but when
    you understand it, it makes perfect sense and is really elegant.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll look at the final pattern in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Higher-order components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **higher-order component** (**HOC**) is a functional component that takes
    in a component as a parameter and returns an enhanced version of that component.
    That may not make a lot of sense, so we''re going to go through an example in
    this section. Our example creates a HOC called `withLoader` that can be applied
    to any component in order to add a loading spinner when the component is busy.
    We are going to use this in our React shop (that we worked on in the last section)
    in the product page whilst data is being fetched. It will look like the following when
    we have finished:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9454161c-6159-4d83-8f20-a1bd53e4137a.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding asynchronous data fetching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the moment, the data fetching in our shop is instantaneous because all the
    data is local. So, before working on the `withLoader` component, let''s refactor
    the data fetching functions to include a delay and be asynchronous as well. This
    will better simulate a real data fetching function that gets the data using a
    web API:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `ProductData.ts`, let''s add the following arrow function that can be used
    to get a product:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The function takes in the product ID and uses the `filter` function in the `products`
    array to find the product and then returns it.
  prefs: []
  type: TYPE_NORMAL
- en: The function is prefixed with the `async` keyword because it is asynchronous.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function also calls a function called `wait` asynchronously with the `await`
    keyword in front of it. So, let''s create the `wait` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This function uses the standard JavaScript `setTimeout` function to wait for
    the number of milliseconds we specify in the function parameter. The function
    returns a `Promise` that is resolved when `setTimeout` completes.
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry if the `async` and `await` keywords along with promises don't make
    much sense at the moment. We'll look at these in detail later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: So, we have a function that now fetches a product asynchronously taking at least
    1 second. Let's plug this into our product page. The `ProductPage` component is
    a container component responsible for fetching data, so let's plug this in here.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s import the `getProduct` function into `ProductPage`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add a property called `loading` to the state of `ProductPage` to indicate
    whether the data is loading or not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also initialize this state to `true` in the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use the `getProduct` function when the `ProductPage` component
    loads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We call `getProduct` asynchronously using the `await` keyword. In order to do
    this, we need to mark the `componentDidMount` lifecycle method as asynchronous
    with the `async` keyword. After we've got the product, we set it in the state
    and reset the `loading` flag to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If our shop isn''t running, let''s run this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: If we go to the product page, we see that it takes roughly 1 second for the
    product to load now. You may notice Product not found! being displayed whilst
    the product loads. This is because the product is not set on the initial render.
    We'll ignore this for the time being because our `withLoader` HOC will resolve
    this issue.
  prefs: []
  type: TYPE_NORMAL
- en: So, now that we are getting data asynchronously and roughly taking 1 second,
    we are ready to implement our `withLoader` HOC and use it on the product page.
    We'll do just this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the withLoader HOC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re going to create a loader spinner component called `withLoader` that
    can be used with any component to indicate that the component is busy doing something:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a new file called `withLoader.tsx` with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few things going on here, so let''s break this down:'
  prefs: []
  type: TYPE_NORMAL
- en: '`withLoader` is a function that that takes in a component of type `P`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`withLoader` calls a function component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The properties for the function component are defined as `P & IProps`, which
    is an intersection type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An intersection type combines multiple types into one. So `X`, and `Y`, and `Z`
    combine all the properties and methods of `X`, `Y`, and `Z` together into a new
    type.
  prefs: []
  type: TYPE_NORMAL
- en: So, the properties for the SFC include all the properties from the component
    passed in along with a `loading` `boolean` property that we defined.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The props are destructured into a `loading` variable and a `props` variable
    containing all the other properties using a rest parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, the remaining work we have to do is return our loading spinner if `loading`
    is `true`, otherwise we just need to return the component passed in. We can do
    this using a ternary expression highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The component passed in is returned in the second ternary branch. We use the
    spread syntax to spread the properties in the `props` variable into the component.
  prefs: []
  type: TYPE_NORMAL
- en: The loading spinner is returned in the first ternary branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'The loading spinner references some CSS classes, so let''s add these into `index.css`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The `loader-overlay` class creates a black see-through overlay over the whole
    page. The `loader-circle-wrap` class creates a `100px` by `100px` square in the
    center of the overlay. The `loader-circle` class creates the spinning circle.
  prefs: []
  type: TYPE_NORMAL
- en: Our `withLoader` HOC is now complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'For reference, a class-based version of `withLoader` is shown in the following
    code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We are going to stick with the SFC version, though, because it doesn't contain
    any state or need access to any lifecycle methods.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll consume our `withLoader` component in the product
    page in our shop app.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming the withLoader HOC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consuming a HOC is very simple. We simply wrap the HOC around the component
    that we want to enhance. The easiest place to do this is in the export statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the `withLoader` HOC we created in the previous section to our product
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we are going to wrap the `Product` component with `withLoader`. First,
    let''s import `withLoader` into `Product.tsx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can wrap `withLoader` around `Product` in the export statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: We now get a compilation error in the `ProductPage` component because it expects
    to pass `Product` a loading property.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s pass the loading property from the loading state where we reference
    `Product` in `ProductPage`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Whilst still in `ProductPage.tsx`, we should revise the condition that renders
    the `Product` component. We now want to render `Product` if the product is still
    being loaded. This will then render the loading spinner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This gives us another compilation error, though, because the `product` property
    within the `Product` component doesn't expect to be `undefined`. However, it will
    be `undefined` when the product is being loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s make this property optional in `IProps` for the `Product` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This then gives further compilation errors in the JSX in the `Product` component
    where we reference the `product` property because it now will be `undefined` during
    the loading of the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple resolution to this is to render `null` if we don''t have a product.
    The `withLoader` HOC that wraps `Product` will render a loading spinner in this
    case, anyway. So, we are just keeping the TypeScript compiler happy here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the TypeScript compiler is happy, if we go to the product page in
    our shop it will display our loading spinner before rendering the product:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/13a53776-e0bb-4729-8884-3a88283ab8f7.png)'
  prefs: []
  type: TYPE_IMG
- en: So, HOCs are great for enhancing components where the enhancement is something
    that can be applied to many components. Our loader spinner is a common use case
    for a HOC. Another very common usage of the HOC pattern is when using React Router.
    We used the React Router `withRouter` HOC previously in this book to access parameters
    for a path.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about container components and how they can be used
    to manage state and what presentational components need to do. Presentational
    components can then focus on what they need to look like. This allows presentational
    components to be more easily reused in multiple places and unit-tested.
  prefs: []
  type: TYPE_NORMAL
- en: We learned that compound components are components that rely on each other.
    Declaring compound children as static members on the parent class make it clear
    to a consumer that the components should be used together. React context is a
    convenient way for compound components to share their state.
  prefs: []
  type: TYPE_NORMAL
- en: We learned about the special children prop that can be used to access and render
    a component's children. We then learned that we can create our own render props
    to give consumers great flexibility for custom-rendering sections of a component.
  prefs: []
  type: TYPE_NORMAL
- en: In the last section, we learned about higher-order components and how they can
    be used to implement common enhancements to components. We already consumed the
    React Router higher-order component when gaining access to a paths parameters
    earlier in the book.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll learn how we create forms in React. Towards the end
    of the next chapter, we'll use some of these patterns that we have learned in
    this chapter in order to deal with forms in a generic way.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s put what we have learned about component patterns to the test with some
    questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What special property does React give us to access a component's, children?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many components can share state with React context?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When consuming the React context, what pattern does it use to allow us to render
    our content with the context?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many render props can we have in a component?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many children props do we have in a component?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We only used `withLoader` on the product page. We use the following function
    in `ProductData.ts` to get all the products:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Can you use this to implement a loader spinner on the products page by consuming
    the `withLoader` HOC?
  prefs: []
  type: TYPE_NORMAL
- en: 'Is it possible to create a loader spinner using the children props pattern?
    The consuming JSX would be something like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: If so, have a go at implementing it.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React context is explained in detail in the React documentation at the following
    link: [https://reactjs.org/docs/context.html](https://reactjs.org/docs/context.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher-order components are detailed in the React documentation at the following
    link: [https://reactjs.org/docs/higher-order-components.html](https://reactjs.org/docs/higher-order-components.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The render props pattern is explained in the React documentation at the following
    link: [https://reactjs.org/docs/render-props.html](https://reactjs.org/docs/render-props.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
