- en: '*Chapter 5*: Exploring Problem Analysis'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore problem analysis in depth while using some
    of what we have been learning, such as logical reasoning, Boolean logic, and algorithmic
    design. We will work through problem definition, decomposition, and analysis in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the problem definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning to decompose problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to further understand problems, we'll need to look at a more complex
    problem and define it so we can begin the algorithmic design process. In this
    chapter, you will learn how to define problems and decompose them in order to
    design algorithms. In doing so, you'll also learn about dictionaries in Python.
    After reading this chapter, you'll be able to use the computational thinking process
    in order to design and create an algorithm that addresses complex problems.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need the latest version of Python to run the codes in this chapter.
    You will find the full source code used in this chapter here: [https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter05](https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter05)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the problem definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we discussed in [*Chapter 2*](B15413_02_Final_SK_ePub.xhtml#_idTextAnchor043),
    *Elements of Computational Thinking*, computational thinking uses four elements
    in order to solve problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem decomposition**: This is the process of breaking down data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pattern recognition**: This is the process of finding similarities or patterns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Abstraction**: This element deals with generalizing the pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Algorithm design**: This is where we define the set of instructions for the
    solution to the problem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, in order to learn more about how to analyze problems, we're
    going to analyze a larger problem and work through the steps needed to create
    the algorithm. To be able to create algorithms, it is imperative that we analyze
    the problems and clearly identify what we are trying to solve. That is, *what
    is our algorithm for?* *Why do we need to build it?* Looking at the decomposition
    of problems and then defining what we need will provide us with a better algorithm
    at the end.
  prefs: []
  type: TYPE_NORMAL
- en: We will work through a problem in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Problem 5A – Building an online store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following problem. You are starting an online store.
    It''s in its infancy, but you''ll have three different types of item available.
    They are keychains, water bottles, and t-shirts. For this particular problem,
    we will go through a three-step process:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Making assumptions**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Things to consider**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Building a dictionary**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will look the preceding steps in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Making assumptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let me state some assumptions about this store that we are going to use:'
  prefs: []
  type: TYPE_NORMAL
- en: This is a company that provides items for clients to share with their customers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each item can have a logo and/or personalized information, such as name, email,
    and phone number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will now move on to the next section, which is about things to consider.
  prefs: []
  type: TYPE_NORMAL
- en: Things to consider
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let''s take a look at some of the things that you''ll need to think about
    before we even start working on an algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Are the items personalized?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Will personalization be charged by character, line, or item?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Will the price be fixed or will it change when customers make bulk purchases?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Will there be discounts if a client orders more than one type of item?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*How much is the base price-point for each item?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding points are not the only questions that we could go over. But they're
    the questions that we'll start taking a look at when we decompose the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Before we do that, let's talk about how we can include the information in a
    program for each of the items. If you recall from [*Chapter 3*](B15413_03_Final_SK_ePub.xhtml#_idTextAnchor056),
    *Understanding Algorithms and Algorithmic Thinking*, we can use a dictionary in
    **Python** to save our menu of items. In this case, we have keychains, water bottles,
    and t-shirts.
  prefs: []
  type: TYPE_NORMAL
- en: Building a dictionary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we take a look at the complexities presented by this problem and decomposing
    that information, we can build our own dictionary. We can make it so that the
    price for each item in the dictionary is the base price (the price that does not
    contain any customizations or discounts), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Cost per keychain: $0.75'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cost per t-shirt: $8.50'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cost per water bottle: $10.00'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now let''s build the dictionary. Remember that you can do this without the
    dictionary, but creating a dictionary allows you to update the pricing, if necessary,
    at a later date. You can also create functions to solve this problem. We are using
    logic and the dictionary for this problem. The following code shows you how to
    build a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: ch5_storeDictionary.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding code snippet, keep in mind that the `print()` function is
    not needed here, but I use it often in order to ensure that the code is working
    properly while I continue to build the algorithms. Also notice that the names
    of the variables—`keychain`, `tshirt`, and `bottle`—are simplified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what that output will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: What the output shows me is that the prices are saved correctly for each of
    the variables. I'm using that `print` function to test my dictionary and ensure
    that it runs correctly before I start working on what I need from that dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: This helps us when we are writing the code and reuse the variables in multiple
    areas of that code. Having these simple and easy-to-identify variables will allow
    us to change and add to the algorithm without adding errors.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned that the problem analysis and definitions help us
    identify how to best design our solution. Remember, when we are looking at problems,
    the definitions we use, both before we write the algorithm and within the algorithm,
    are critical for our design and final product. Let's now look at the decomposition
    of the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Learning to decompose problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we decompose problems, we're identifying what we need the algorithm to
    provide us with. The end user will need to see something seamless. Look at the
    flowchart in *Figure 5.1*; this is a basic decision-making flowchart to help us
    design our algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make another assumption first, that is, if the user enters more than
    10, the price will be lower. We''re only going to do less than 10 or more than
    or equal to 10 in this case. However, if you needed to subdivide this further,
    you can add more cases, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Less than or equal to 10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More than 10 and less than or equal to 50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More than or equal to 50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can have as many cases as you need. For the purposes of this algorithm,
    we're going to keep it to two cases, since we also have to include personalization
    costs and we don't want to create an overly complicated algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows you the flowchart for the algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Initial decision-making flowchart'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_5.1_B15413.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – Initial decision-making flowchart
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding diagram, this isn't a completed flowchart. After
    we make the decisions about the t-shirts, we need to move on to the bottles. How
    we write the algorithm will depend on what we'd like to output. Right now, we're
    providing the user the information they'd get when they check out of the online
    store that you created.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, let's use the preceding flowchart to create an algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Converting the flowchart into an algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The diagram in *Figure 5.1* allows us to look at the decision-making process
    for the algorithm we''re writing. We''ll want to look at the following key points
    when writing the algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dictionary and input**: Input can be within the algorithm or user-entered;
    dictionaries are built within the algorithm. This means, to use a dictionary,
    we have to define it in our algorithm before we are able to use it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cost**: This is the base cost for each item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Personalization costs**: This is added to the base cost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll now look at the preceding points in detail in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Building a dictionary and giving inputs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we add any of the complications, let''s look at how to grab the price
    of each item and use it at the base price. We''ll need a count for the number
    of each item. The following code shows you this:'
  prefs: []
  type: TYPE_NORMAL
- en: ch5_storeQuantities.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding code snippet, notice that we added the variables under the
    dictionary. This will be useful later. These variables are named `choicekey`,
    `choicetshirt`, and `choicebottle`. Naming the variables allows us to return to
    them and change code, as needed. In this case, each variable asks for input from
    the person running the program in order to get the number of keychains, t-shirts,
    and bottles they are ordering. Again, there are multiple ways to tackle this problem,
    but we're using what we've learned so far to create an algorithmic solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the previous code for `3` keychains, `0` t-shirts, and `10` water
    bottles, this is our output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have a program that takes user input, then confirms to the
    user the choices they have made for each of the items.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see the next section about cost.
  prefs: []
  type: TYPE_NORMAL
- en: Making changes to the cost
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let''s add the changes in cost. Let''s say that if a customer is purchasing
    over 10 items, then the updated costs are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Keychains: $ 0.65'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'T-shirts: $ 8.00'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Water bottles: $ 8.75'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To make the preceding changes, we can make the program update the difference
    in cost, which is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: ch5_storeCost.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have updated the code, I''d like to print out my progress to make
    sure that the code is working properly and changes take place. In this case, I
    wanted to make sure that the costs would update if I had totals greater than 10\.
    (That is, when a customer orders more than 10 of an item, it updates the cost
    for each item to the lower cost.) The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can now see from the preceding output that the dictionary has updated the
    values based on the totals the user provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to go ahead and provide the cost. We can provide the total item
    cost or the total cost of the full purchase, or both (let''s do both). Take a
    look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: ch5_storeTotals.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet is added so that we can have a `print` statement
    to confirm the input from the user. By printing that statement at the end of the
    code, we are checking with the user whether the program can read the numbers correctly,
    and whether the user entered the right numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can continue the code to add the costs per item:'
  prefs: []
  type: TYPE_NORMAL
- en: ch5_storeTotals.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `print` statements at the end of the preceding code snippet provide the
    breakdown of each item total as well as the full order total. After asking for
    the input for all items, the code then prints the sub-totals for the cost of each
    of the items. The result of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the totals of the items without personalization, we need to
    be able to take into account the costs of that personalization, if ordered.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, let's take a look at what personalization costs are and
    the decisions we'll need to make before we move on.
  prefs: []
  type: TYPE_NORMAL
- en: Adding personalization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For now, let''s limit the personalization of keychains, t-shirts, and water
    bottles to binary questions, that is, either the user wants personalization or
    not. We are not looking at tiered costs of personalization, which you may have
    seen. If you wanted to add tiers, you''d need to make more decisions, such as
    cost of choosing fonts, length of the personalization, and so on. We''ll forgo
    those for now, but feel free to add to this code in order to address those kinds
    of customizations. Let''s add another assumption for the personalization:'
  prefs: []
  type: TYPE_NORMAL
- en: $1.00 for the keychains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: $5.00 for the t-shirts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: $7.50 for the water bottles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll need to create the preceding conditions and then implement them into our
    variables. Let's look at the code in parts. The following file contains each of
    the parts we'll break down.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that our algorithm first asked for input for the number of items they
    were purchasing. The following code snippet takes user input in order to take
    personalization into account:'
  prefs: []
  type: TYPE_NORMAL
- en: ch5_storePersonalize.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet asks the user the binary questions on personalization.
    After grabbing the input, the code then makes some decisions based on the user
    input and defines the `keychain`, `tshirt`, and `bottle` variables and the totals
    for the choices. The following snippet then uses the totals to print out the information
    for each item purchased as well as the final total:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding code, notice that the `keychain`, `tshirt`, and `bottle`
    variables are defined after all our customizations based on total numbers and
    personalization. Remember that in algorithm design, the order matters. If we locate
    those variables earlier in the program, the conditions, such as personalization,
    that follow will not affect those variables.
  prefs: []
  type: TYPE_NORMAL
- en: So, to be able to get everything we need for our variables, we need to define
    them after defining some of the conditions that affect them, such as customization.
    Take a look at the preceding code to note where the variables are. Feel free to
    play with the code by changing where you define the variables to see whether your
    end results change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a visual flowchart with the keychain decision-making process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Keychain decision-making flowchart'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_5.2_B15413.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – Keychain decision-making flowchart
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the preceding diagram, this is only for **Keychains**. We
    need to repeat the process for the other two variables. In the diagram, you can
    see the decision-making process for the item. First, the user indicates the number
    of items bought, then whether they will personalize them or not.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on each answer, the total is calculated by the program. For example,
    if there is no personalization, the total is calculated sooner in the decision-making
    tree. We can rewrite this program using functions (as I mentioned before) to simplify
    some of the processes. For now, we are focusing on learning how to break down
    problems, analyze conditions, and how to design algorithms that take into account
    multiple decisions. Remember to complete the diagram for the other items so that
    the decision-making process is easier to code when designing the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to use a flowchart to create an algorithm. We
    also learned about building a dictionary for our algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on, let's look at the process of analyzing problems. While we
    were creating this algorithm, we did that while we decomposed the problem. However,
    there are some key components of problem analysis that we should consider before
    our next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When analyzing problems, there are some steps that we can keep in mind to help
    us ensure that we are creating the best possible algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: Clearly read and understand the problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify the main purpose of the solution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify the constraints of the problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify the decision-making flow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Establish the possible algorithms that could solve the problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify the best possible algorithm tools for the problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test the algorithm pieces frequently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verify that the algorithm provides the solution for the identified problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we go back to our problem, we went through this process throughout the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: We had an online store with three items.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Item cost was dependent on quantity purchased.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Item price was also dependent on personalization customizations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We created flowcharts to help us identify the decision process and how to code
    it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We verified our code through code lines that allowed us to check whether the
    algorithm was producing the correct response multiple times.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We revisited and reordered pieces of code, as needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We verified that the algorithm's output was in line with the problem we had
    identified.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding process bears repeating, that is, this is not a linear process.
    Sometimes we'll write an algorithm and then revisit the decision flowchart, make
    adjustments, then tackle the algorithm again.
  prefs: []
  type: TYPE_NORMAL
- en: The need for analyzing our problems at multiple *stopping points* becomes even
    clearer when we are looking at larger problems. *Should we write hundreds of lines
    of code before testing?* No! Imagine having 300 lines of code, only to find an
    error on *line 20* that is carried forward throughout the rest of the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Testing at every possible progress point will allow us to catch the small mistakes
    that can cost us in the long run. Remember, it's almost impossible to write a
    perfect algorithm on the first try. We all make mistakes, small and large, so
    it is important that we continue to test and analyze our progress.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at one more problem and go through the process again before leaving
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Problem 5B – Analyzing a simple game problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to design a number guessing game. The user has to guess a random number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by defining our problem, which in this case is a game. Let''s
    identify the known information:'
  prefs: []
  type: TYPE_NORMAL
- en: The computer will need to randomly select a number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user will need to input a number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The computer will have to check whether the input from the user matches the
    randomly generated number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Now, that''s not enough! If I don''t match on the first try, do I lose? How
    many chances do I get? Is the random number a number between 1 and 10 or between
    1 and 500?* We''re going to have to make some decisions before we start coding
    this. Let''s add some parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The number is between 1 and 100.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user will get 5 chances to guess.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The computer will tell the user if the answer is too high or too low.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have those parameters, we can create a decision flowchart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Decision flowchart for guessing game'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_5.3_B15413.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 – Decision flowchart for guessing game
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding diagram you can see that the chart is not complete. That's
    because we will use some logic to make the process repeat 5 times. We'll get into
    that in a moment. For now, notice the decisions. First, a number is generated
    by the program (but is not revealed). The user then inputs a guess, which is either
    correct or incorrect. If it's correct, then the user wins the game. If it's incorrect,
    then the program lets the user know if the answer was too low or too high and
    asks for a new guess. The process will then repeat itself, as needed. Now, let's
    write the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s generate the random number and get the user to guess it. Add
    a `print()` function for both the randomly generated number and the input from
    the user so that you can see that the information is working properly. Remember,
    we''ll take those out later, but it''s important to keep checking and rechecking
    our code as part of our problem analysis process. The following code will do the
    same:'
  prefs: []
  type: TYPE_NORMAL
- en: ch5_guess1.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You'll notice from the preceding code, the imported `random` module. We also
    imported it as `rand`. That's just to save time and space. When you import a module
    in Python, you can rename it. The `random` module gives us a way to generate the
    number in the range that we had selected.
  prefs: []
  type: TYPE_NORMAL
- en: The `rand.randint(1, 100)` code line includes `1` and `100`. These are the endpoints,
    or limits for the random number generator. The `rand` function refers to the module,
    as mentioned, while *randint(a, b)* refers to a random integer between *a* and
    *b* (including *a* and *b*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code a few times to see how the number generated by the computer changes
    each time. The following points show three test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is test case 1 of the preceding code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding output, `27` is the computer-generated random
    number and `10` is what the user entered.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is test case 2 results of the previous code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding output of the code, `68` is the value of the
    `compnumber` variable, while the user (me) entered the number `65`. So close,
    yet so far!
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is test case 3 output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding output, the computer chose the number `50`,
    while the user entered `23`.
  prefs: []
  type: TYPE_NORMAL
- en: For our final version of this game, we won't print out the computer number.
    That would be cheating! Right now, we're just testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and add one condition—whether or not the first guess is correct.
    To do so, we''ll have to verify `compnumber == usernumber`. We''re going to test
    this again before going into the additional repetitions and logic, so we''ll just
    say if it''s true, then you win; if it''s false, then you lose:'
  prefs: []
  type: TYPE_NORMAL
- en: ch5_guess2.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s just say I lost on the first try when I ran it. I''m not going to run
    this until I do win, however, because that could take, well, 100 tries or more.
    Here''s what that looks like when you run the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now let's talk about repeating a line of code. We're giving the user 5 guesses.
    *How can we do that in Python?*
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, we can use `for` loops to iterate through code. We know we get 5
    guesses, so we''ll have to use something like `for number in range(5):` to get
    us started with the logic, which is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: ch5_guess3.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, *did you notice that* `i` *variable?* We are using
    that variable so that the user knows how many guesses they have left. So if we
    had 5 guesses, the code will start at `i = 5`; then, if the user is wrong, it
    will use the line `i = i – 1`, which alerts the user they now have 4 guesses left,
    and so on. Take a look at what happens when we run that program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''re not really being fair. As mentioned earlier, we want to give the
    user a hint each time they attempt a guess. Now that we have the condition checking
    whether they are equal, we can add an `elif` condition to check whether it''s
    larger or smaller. The following code shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: ch5_guess4.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code now provides some feedback to the user. If the number was
    greater than the computer-generated number, the user receives the feedback `'Your
    number is too large!'`, and if the user number is less than the computer-generated
    number, then they receive the feedback `'Your number is too small!'`. We also
    used an `exit()` code if the user wins. That's because we want the game to stop
    when we win.
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives us a fighting chance to win this game, take a look at what the output
    looks like now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now look at what happens when we lose the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, you get a different final message. I confess it took me quite
    a few tries to win a game so I could get the output that follows, but you can
    see the game where the second guess was correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to stop this game with that last algorithm. We could actually
    make this game better if we wanted to, but it does the job that we needed it to
    do. Some of the changes that you could consider making to your game are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding an option that alerts the user of a number already guessed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding an option that alerts the user that they ignored a previous hint (so
    if the user gave a number that was too small and gave one that was even smaller,
    the computer would alert them).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I''m sure there are more customizations that you could try. But for now, we
    went through that problem and followed the points that we should consider when
    analyzing problems:'
  prefs: []
  type: TYPE_NORMAL
- en: We read and understood the problem.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We identified the purpose—creating a computer player versus user player guessing
    game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We identified the constraints of the problem—the range of numbers, the number
    of guesses, and providing hints.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We created a decision flowchart.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We wrote and established an algorithm for the problem.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We looked at how to create a simple algorithm that would iterate rather than
    having to write each condition individually.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We tested the algorithm at multiple points.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We verified that the algorithm ran accurately for both wins and losses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What you don't get to see here is the number of errors I went through before
    I got to the algorithms shown. While writing, I had to use the preceding steps
    to help me identify errors, check the best algorithms, and iterate through the
    programs. This is a process that we'll continue to use.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed problem definition, decomposition, and analysis.
    We used problems to help us go through the process of identifying problems, decomposing
    them into the relevant parts and identifying constraints, and analyzing our algorithms.
    We used flowcharts to help us learn about decision-making when designing algorithms
    and how to organize ideas.
  prefs: []
  type: TYPE_NORMAL
- en: We learned to test our algorithms often. This provided us with the skills and
    understanding to identify errors early rather than wait until we had too many
    lines of code, which made it hard to identify those errors. We used an online
    store and a guessing game to help us understand some of the functionalities available
    in Python. Throughout the process, we used Boolean code to verify inputs, we used
    nested `if` statements, and we learned about how to use dictionaries in solving
    the problems presented.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we got a chance to use a dictionary for an algorithm that used
    user input and variables. Using the algorithm gave us flexibility for defining
    some variables and editing the variables once we run the algorithm or within the
    algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will go in depth into the solution process and design,
    delving deeper into more complex problems and the Python language.
  prefs: []
  type: TYPE_NORMAL
