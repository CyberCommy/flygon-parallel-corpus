- en: Appendix B. Database API Reference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django's database API is the other half of the model API discussed in Appendix
    A. Once you've defined a model, you'll use this API any time you need to access
    the database. You've seen examples of this API in use throughout the book; this
    appendix explains all the various options in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout this appendix I''ll refer to the following models, which comprise
    a Weblog application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Creating objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To represent database-table data in Python objects, Django uses an intuitive
    system: a model class represents a database table, and an instance of that class
    represents a particular record in the database table.'
  prefs: []
  type: TYPE_NORMAL
- en: To create an object, instantiate it using keyword arguments to the model class,
    then call `save()` to save it to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming models live in a file `mysite/blog/models.py`, here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This performs an `INSERT` SQL statement behind the scenes. Django doesn't hit
    the database until you explicitly call `save()`.
  prefs: []
  type: TYPE_NORMAL
- en: The `save()` method has no return value.
  prefs: []
  type: TYPE_NORMAL
- en: To create and save an object in a single step, use the `create()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Saving changes to objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To save changes to an object that's already in the database, use `save()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a `Blog` instance `b5` that has already been saved to the database, this
    example changes its name and updates its record in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This performs an `UPDATE` SQL statement behind the scenes. Django doesn't hit
    the database until you explicitly call `save()`.
  prefs: []
  type: TYPE_NORMAL
- en: Saving ForeignKey and ManyToManyField fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Updating a `ForeignKey` field works exactly the same way as saving a normal
    field-simply assign an object of the right type to the field in question. This
    example updates the `blog` attribute of an `Entry` instance `entry`, assuming
    appropriate instances of `Entry`, and `Blog` are already saved to the database
    (so we can retrieve them below):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Updating a `ManyToManyField` works a little differently-use the `add()` method
    on the field to add a record to the relation. This example adds the `Author` instance
    `joe` to the `entry` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To add multiple records to a `ManyToManyField` in one go, include multiple
    arguments in the call to `add()`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Django will complain if you try to assign or add an object of the wrong type.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To retrieve objects from your database, construct a `QuerySet` via a `Manager`
    on your model class.
  prefs: []
  type: TYPE_NORMAL
- en: A `QuerySet` represents a collection of objects from your database. It can have
    zero, one or many filters. Filters narrow down the query results based on the
    given parameters. In SQL terms, a `QuerySet` equates to a `SELECT` statement,
    and a filter is a limiting clause such as `WHERE` or `LIMIT`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You get a `QuerySet` by using your model''s `Manager`. Each model has at least
    one `Manager`, and it''s called `objects` by default. Access it directly via the
    model class, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Retrieving all objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simplest way to retrieve objects from a table is to get all of them. To
    do this, use the `all()` method on a `Manager`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `all()` method returns a `QuerySet` of all the objects in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving specific objects with filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `QuerySet` returned by `all()` describes all objects in the database table.
    Usually, though, you'll need to select only a subset of the complete set of objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create such a subset, you refine the initial `QuerySet`, adding filter conditions.
    The two most common ways to refine a `QuerySet` are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`filter(**kwargs)`. Returns a new `QuerySet` containing objects that match
    the given lookup parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exclude(**kwargs)`. Returns a new `QuerySet` containing objects that do not
    match the given lookup parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lookup parameters (`**kwargs` in the above function definitions) should
    be in the format described in *Field lookups* later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining filters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The result of refining a `QuerySet` is itself a `QuerySet`, so it''s possible
    to chain refinements together. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This takes the initial `QuerySet` of all entries in the database, adds a filter,
    then an exclusion, then another filter. The final result is a `QuerySet` containing
    all entries with a headline that starts with `What`, that were published between
    January 30, 2005, and the current day.
  prefs: []
  type: TYPE_NORMAL
- en: Filtered querysets are unique
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each time you refine a `QuerySet`, you get a brand-new `QuerySet` that is in
    no way bound to the previous `QuerySet`. Each refinement creates a separate and
    distinct `QuerySet` that can be stored, used, and reused.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: These three `QuerySets` are separate. The first is a base `QuerySet` containing
    all entries that contain a headline starting with What. The second is a subset
    of the first, with an additional criterion that excludes records whose `pub_date`
    is today or in the future. The third is a subset of the first, with an additional
    criterion that selects only the records whose `pub_date` is today or in the future.
    The initial `QuerySet` (`q1`) is unaffected by the refinement process.
  prefs: []
  type: TYPE_NORMAL
- en: QuerySets are lazy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`QuerySets` are lazy-the act of creating a `QuerySet` doesn''t involve any
    database activity. You can stack filters together all day long, and Django won''t
    actually run the query until the `QuerySet` is *evaluated*. Take a look at this
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Though this looks like three database hits, in fact it hits the database only
    once, at the last line (`print(q)`). In general, the results of a `QuerySet` aren't
    fetched from the database until you ask for them. When you do, the `QuerySet`
    is *evaluated* by accessing the database.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving a single object with get
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`filter()` will always give you a `QuerySet`, even if only a single object
    matches the query-in this case, it will be a `QuerySet` containing a single element.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you know there is only one object that matches your query, you can use the
    `get()` method on a `Manager` which returns the object directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can use any query expression with `get()`, just like with `filter()`-again,
    see *Field lookups* in the next section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note that there is a difference between using `get()`, and using `filter()`
    with a slice of `[0]`. If there are no results that match the query, `get()` will
    raise a `DoesNotExist` exception. This exception is an attribute of the model
    class that the query is being performed on-so in the code above, if there is no
    `Entry` object with a primary key of 1, Django will raise `Entry.DoesNotExist`.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, Django will complain if more than one item matches the `get()` query.
    In this case, it will raise `MultipleObjectsReturned`, which again is an attribute
    of the model class itself.
  prefs: []
  type: TYPE_NORMAL
- en: Other queryset methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the time you'll use `all()`, `get()`, `filter()`, and `exclude()` when
    you need to look up objects from the database. However, that's far from all there
    is; see the QuerySet API Reference at [https://docs.djangoproject.com/en/1.8/ref/models/querysets/](https://docs.djangoproject.com/en/1.8/ref/models/querysets/),
    for a complete list of all the various `QuerySet` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting querysets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a subset of Python's array-slicing syntax to limit your `QuerySet` to a
    certain number of results. This is the equivalent of SQL's `LIMIT` and `OFFSET`
    clauses.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this returns the first 5 objects (`LIMIT 5`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns the sixth through tenth objects (`OFFSET 5 LIMIT 5`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Negative indexing (that is, `Entry.objects.all()[-1]`) is not supported.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, slicing a `QuerySet` returns a new `QuerySet`-it doesn''t evaluate
    the query. An exception is if you use the step parameter of Python slice syntax.
    For example, this would actually execute the query in order to return a list of
    every *second* object of the first 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To retrieve a *single* object rather than a list (for example, `SELECT foo FROM
    bar LIMIT 1`), use a simple index instead of a slice.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this returns the first `Entry` in the database, after ordering
    entries alphabetically by headline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This is roughly equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note, however, that the first of these will raise `IndexError` while the second
    will raise `DoesNotExist` if no objects match the given criteria. See `get()`
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Field lookups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Field lookups are how you specify the meat of an SQL `WHERE` clause. They''re
    specified as keyword arguments to the `QuerySet` methods `filter()`, `exclude()`,
    and `get()`. Basic lookups keyword arguments take the form `field__lookuptype=value`.
    (That''s a double-underscore). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'translates (roughly) into the following SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The field specified in a lookup has to be the name of a model field. There''s
    one exception though, in case of a `ForeignKey` you can specify the field name
    suffixed with `_id`. In this case, the value parameter is expected to contain
    the raw value of the foreign model''s primary key. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If you pass an invalid keyword argument, a lookup function will raise `TypeError`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete list of field lookups are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`exact`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iexact`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contains`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`icontains`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`in`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gte`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lte`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`startswith`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`istartswith`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`endswith`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iendswith`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`range`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`year`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`month`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`day`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`week_day`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hour`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minute`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`second`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isnull`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`search`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`regex`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iregex`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A complete reference, including examples for each field lookup can be found
    in the field lookup reference at [https://docs.djangoproject.com/en/1.8/ref/models/querysets/#field-lookups](https://docs.djangoproject.com/en/1.8/ref/models/querysets/#field-lookups).
  prefs: []
  type: TYPE_NORMAL
- en: Lookups that span relationships
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Django offers a powerful and intuitive way to follow relationships in lookups,
    taking care of the SQL `JOIN`s for you automatically, behind the scenes. To span
    a relationship, just use the field name of related fields across models, separated
    by double underscores, until you get to the field you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example retrieves all `Entry` objects with a `Blog` whose `name` is `''Beatles
    Blog''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This spanning can be as deep as you'd like.
  prefs: []
  type: TYPE_NORMAL
- en: It works backwards, too. To refer to a reverse relationship, just use the lowercase
    name of the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example retrieves all `Blog` objects which have at least one `Entry` whose
    `headline` contains `''Lennon''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are filtering across multiple relationships and one of the intermediate
    models doesn''t have a value that meets the filter condition, Django will treat
    it as if there is an empty (all values are `NULL`), but valid, object there. All
    this means is that no error will be raised. For example, in this filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '(if there was a related `Author` model), if there was no `author` associated
    with an entry, it would be treated as if there was also no `name` attached, rather
    than raising an error because of the missing `author`. Usually this is exactly
    what you want to have happen. The only case where it might be confusing is if
    you are using `isnull`. Thus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'will return `Blog` objects that have an empty `name` on the `author` and also
    those which have an empty `author` on the `entry`. If you don''t want those latter
    objects, you could write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Spanning multi-valued relationships
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you are filtering an object based on a `ManyToManyField` or a reverse `ForeignKey`,
    there are two different sorts of filter you may be interested in. Consider the
    `Blog`/`Entry` relationship (`Blog` to `Entry` is a one-to-many relation). We
    might be interested in finding blogs that have an entry which has both `Lennon`
    in the headline and was published in 2008.
  prefs: []
  type: TYPE_NORMAL
- en: Or we might want to find blogs that have an entry with `Lennon` in the headline
    as well as an entry that was published in 2008\. Since there are multiple entries
    associated with a single `Blog`, both of these queries are possible and make sense
    in some situations.
  prefs: []
  type: TYPE_NORMAL
- en: The same type of situation arises with a `ManyToManyField`. For example, if
    an `Entry` has a `ManyToManyField` called `tags`, we might want to find entries
    linked to tags called `music` and `bands` or we might want an entry that contains
    a tag with a name of `music` and a status of `public`.
  prefs: []
  type: TYPE_NORMAL
- en: To handle both of these situations, Django has a consistent way of processing
    `filter()` and `exclude()` calls. Everything inside a single `filter()` call is
    applied simultaneously to filter out items matching all those requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Successive `filter()` calls further restrict the set of objects, but for multi-valued
    relations, they apply to any object linked to the primary model, not necessarily
    those objects that were selected by an earlier `filter()` call.
  prefs: []
  type: TYPE_NORMAL
- en: 'That may sound a bit confusing, so hopefully an example will clarify. To select
    all blogs that contain entries with both `Lennon` in the headline and that were
    published in 2008 (the same entry satisfying both conditions), we would write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To select all blogs that contain an entry with `Lennon` in the headline as
    well as an entry that was published in 2008, we would write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Suppose there is only one blog that had both entries containing `Lennon` and
    entries from 2008, but that none of the entries from 2008 contained `Lennon`.
    The first query would not return any blogs, but the second query would return
    that one blog.
  prefs: []
  type: TYPE_NORMAL
- en: In the second example, the first filter restricts the queryset to all those
    blogs linked to entries with `Lennon` in the headline. The second filter restricts
    the set of blogs *further* to those that are also linked to entries that were
    published in 2008.
  prefs: []
  type: TYPE_NORMAL
- en: The entries selected by the second filter may or may not be the same as the
    entries in the first filter. We are filtering the `Blog` items with each filter
    statement, not the `Entry` items.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of this behavior also applies to `exclude()`: all the conditions in a single
    `exclude()` statement apply to a single instance (if those conditions are talking
    about the same multi-valued relation). Conditions in subsequent `filter()` or
    `exclude()` calls that refer to the same relation may end up filtering on different
    linked objects.'
  prefs: []
  type: TYPE_NORMAL
- en: Filters can reference fields on the model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the examples given so far, we have constructed filters that compare the value
    of a model field with a constant. But what if you want to compare the value of
    a model field with another field on the same model?
  prefs: []
  type: TYPE_NORMAL
- en: Django provides `F expressions` to allow such comparisons. Instances of `F()`
    act as a reference to a model field within a query. These references can then
    be used in query filters to compare the values of two different fields on the
    same model instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to find a list of all blog entries that have had more comments
    than pingbacks, we construct an `F()` object to reference the pingback count,
    and use that `F()` object in the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Django supports the use of addition, subtraction, multiplication, division,
    modulo, and power arithmetic with `F()` objects, both with constants and with
    other `F()` objects. To find all the blog entries with more than *twice* as many
    comments as pingbacks, we modify the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To find all the entries where the rating of the entry is less than the sum
    of the pingback count and comment count, we would issue the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You can also use the double underscore notation to span relationships in an
    `F()` object. An `F()` object with a double underscore will introduce any joins
    needed to access the related object.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to retrieve all the entries where the author''s name is the same
    as the blog name, we could issue the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'For date and date/time fields, you can add or subtract a `timedelta` object.
    The following would return all entries that were modified more than 3 days after
    they were published:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `F()` objects support bitwise operations by `.bitand()` and `.bitor()`,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The pk lookup shortcut
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For convenience, Django provides a `pk` lookup shortcut, which stands for primary
    key.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example `Blog` model, the primary key is the `id` field, so these three
    statements are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The use of `pk` isn''t limited to `__exact` queries-any query term can be combined
    with `pk` to perform a query on the primary key of a model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '`pk` lookups also work across joins. For example, these three statements are
    equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Escaping percent signs and underscores in LIKE statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The field lookups that equate to `LIKE` SQL statements (`iexact`, `contains`,
    `icontains`, `startswith`, `istartswith`, `endswith`, and `iendswith`) will automatically
    escape the two special characters used in `LIKE` statements-the percent sign and
    the underscore. (In a `LIKE` statement, the percent sign signifies a multiple-character
    wildcard and the underscore signifies a single-character wildcard.)
  prefs: []
  type: TYPE_NORMAL
- en: 'This means things should work intuitively, so the abstraction doesn''t leak.
    For example, to retrieve all the entries that contain a percent sign, just use
    the percent sign as any other character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Django takes care of the quoting for you; the resulting SQL will look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Same goes for underscores. Both percentage signs and underscores are handled
    for you transparently.
  prefs: []
  type: TYPE_NORMAL
- en: Caching and querysets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each `QuerySet` contains a cache to minimize database access. Understanding
    how it works will allow you to write the most efficient code.
  prefs: []
  type: TYPE_NORMAL
- en: In a newly created `QuerySet`, the cache is empty. The first time a `QuerySet`
    is evaluated-and, hence, a database query happens-Django saves the query results
    in the `QuerySet` class' cache and returns the results that have been explicitly
    requested (for example, the next element, if the `QuerySet` is being iterated
    over). Subsequent evaluations of the `QuerySet` reuse the cached results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep this caching behavior in mind, because it may bite you if you don''t use
    your `QuerySet` correctly. For example, the following will create two `QuerySet`,
    evaluate them, and throw them away:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: That means the same database query will be executed twice, effectively doubling
    your database load. Also, there's a possibility the two lists may not include
    the same database records, because an `Entry` may have been added or deleted in
    the split second between the two requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid this problem, simply save the `QuerySet` and reuse it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: When querysets are not cached
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Querysets do not always cache their results. When evaluating only *part* of
    the queryset, the cache is checked, but if it is not populated then the items
    returned by the subsequent query are not cached. Specifically, this means that
    limiting the queryset using an array slice or an index will not populate the cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, repeatedly getting a certain index in a queryset object will query
    the database each time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if the entire queryset has already been evaluated, the cache will
    be checked instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some examples of other actions that will result in the entire queryset
    being evaluated and therefore populate the cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Complex lookups with Q objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keyword argument queries-in `filter()`, and others.-are ANDed together. If you
    need to execute more complex queries (for example, queries with `OR` statements),
    you can use `Q objects`.
  prefs: []
  type: TYPE_NORMAL
- en: A `Q object` (`django.db.models.Q`) is an object used to encapsulate a collection
    of keyword arguments. These keyword arguments are specified as in Field lookups
    above.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this `Q` object encapsulates a single `LIKE` query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '`Q` objects can be combined using the `&` and `|` operators. When an operator
    is used on two `Q` objects, it yields a new `Q` object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this statement yields a single `Q` object that represents the
    OR of two `"question__startswith"` queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This is equivalent to the following SQL `WHERE` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'You can compose statements of arbitrary complexity by combining `Q` objects
    with the `&` and `|` operators and use parenthetical grouping. Also, `Q` objects
    can be negated using the `~` operator, allowing for combined lookups that combine
    both a normal query and a negated (`NOT`) query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Each lookup function that takes keyword-arguments (for example, `filter()`,
    `exclude()`, `get()`) can also be passed one or more `Q` objects as positional
    (not-named) arguments. If you provide multiple `Q` object arguments to a lookup
    function, the arguments will be ANDed together. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '... roughly translates into the SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Lookup functions can mix the use of `Q` objects and keyword arguments. All
    arguments provided to a lookup function (be the keyword arguments or `Q` objects)
    are ANDed together. However, if a `Q` object is provided, it must precede the
    definition of any keyword arguments. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '... would be a valid query, equivalent to the previous example; but:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '... would not be valid.'
  prefs: []
  type: TYPE_NORMAL
- en: Comparing objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To compare two model instances, just use the standard Python comparison operator,
    the double equals sign: `==`. Behind the scenes, that compares the primary key
    values of two models.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `Entry` example above, the following two statements are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'If a model''s primary key isn''t called `id`, no problem. Comparisons will
    always use the primary key, whatever it''s called. For example, if a model''s
    primary key field is called `name`, these two statements are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Deleting objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The delete method, conveniently, is named `delete()`. This method immediately
    deletes the object and has no return value. Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: You can also delete objects in bulk. Every `QuerySet` has a `delete()` method,
    which deletes all members of that `QuerySet`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this deletes all `Entry` objects with a `pub_date` year of 2005:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that this will, whenever possible, be executed purely in SQL, and
    so the `delete()` methods of individual object instances will not necessarily
    be called during the process. If you've provided a custom `delete()` method on
    a model class and want to ensure that it is called, you will need to manually
    delete instances of that model (for example, by iterating over a `QuerySet` and
    calling `delete()` on each object individually) rather than using the bulk `delete()`
    method of a `QuerySet`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When Django deletes an object, by default it emulates the behavior of the SQL
    constraint `ON DELETE CASCADE`-in other words, any objects which had foreign keys
    pointing at the object to be deleted will be deleted along with it. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This cascade behavior is customizable via the `on_delete` argument to the `ForeignKey`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that `delete()` is the only `QuerySet` method that is not exposed on a
    `Manager` itself. This is a safety mechanism to prevent you from accidentally
    requesting `Entry.objects.delete()`, and deleting *all* the entries. If you *do*
    want to delete all the objects, then you have to explicitly request a complete
    query set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Copying model instances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although there is no built-in method for copying model instances, it is possible
    to easily create new instance with all fields'' values copied. In the simplest
    case, you can just set `pk` to `None`. Using our blog example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Things get more complicated if you use inheritance. Consider a subclass of
    `Blog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Due to how inheritance works, you have to set both `pk` and `id` to None:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This process does not copy related objects. If you want to copy relations,
    you have to write a little bit more code. In our example, `Entry` has a many to
    many field to `Author`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Updating multiple objects at once
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes you want to set a field to a particular value for all the objects
    in a `QuerySet`. You can do this with the `update()` method. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'You can only set non-relation fields and `ForeignKey` fields using this method.
    To update a non-relation field, provide the new value as a constant. To update
    `ForeignKey` fields, set the new value to be the new model instance you want to
    point to. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The `update()` method is applied instantly and returns the number of rows matched
    by the query (which may not be equal to the number of rows updated if some rows
    already have the new value).
  prefs: []
  type: TYPE_NORMAL
- en: 'The only restriction on the `QuerySet` that is updated is that it can only
    access one database table, the model''s main table. You can filter based on related
    fields, but you can only update columns in the model''s main table. Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Be aware that the `update()` method is converted directly to an SQL statement.
    It is a bulk operation for direct updates. It doesn''t run any `save()` methods
    on your models, or emit the `pre_save` or `post_save` signals (which are a consequence
    of calling `save()`), or honor the `auto_now` field option. If you want to save
    every item in a `QuerySet` and make sure that the `save()` method is called on
    each instance, you don''t need any special function to handle that. Just loop
    over them and call `save()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Calls to update can also use `F expressions` to update one field based on the
    value of another field in the model. This is especially useful for incrementing
    counters based upon their current value. For example, to increment the pingback
    count for every entry in the blog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'However, unlike `F()` objects in filter and exclude clauses, you can''t introduce
    joins when you use `F()` objects in an update-you can only reference fields local
    to the model being updated. If you attempt to introduce a join with an `F()` object,
    a `FieldError` will be raised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Related objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you define a relationship in a model (that is, a `ForeignKey`, `OneToOneField`,
    or `ManyToManyField`), instances of that model will have a convenient API to access
    the related object(s).
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the models at the top of this page, for example, an `Entry` object `e`
    can get its associated `Blog` object by accessing the `blog` attribute: `e.blog`.'
  prefs: []
  type: TYPE_NORMAL
- en: (Behind the scenes, this functionality is implemented by Python descriptors.
    This shouldn't really matter to you, but I point it out here for the curious.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Django also creates API accessors for the other side of the relationship-the
    link from the related model to the model that defines the relationship. For example,
    a `Blog` object `b` has access to a list of all related `Entry` objects via the
    `entry_set` attribute: `b.entry_set.all()`.'
  prefs: []
  type: TYPE_NORMAL
- en: All examples in this section use the sample `Blog`, `Author` and `Entry` models
    defined at the top of this page.
  prefs: []
  type: TYPE_NORMAL
- en: One-to-many relationships
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Forward
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If a model has a `ForeignKey`, instances of that model will have access to
    the related (foreign) object via a simple attribute of the model. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'You can get and set via a foreign-key attribute. As you may expect, changes
    to the foreign key aren''t saved to the database until you call `save()`. Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'If a `ForeignKey` field has `null=True` set (that is, it allows `NULL` values),
    you can assign `None` to remove the relation. Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Forward access to one-to-many relationships is cached the first time the related
    object is accessed. Subsequent accesses to the foreign key on the same object
    instance are cached. Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `select_related()` `QuerySet` method recursively prepopulates
    the cache of all one-to-many relationships ahead of time. Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Following relationships backward
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If a model has a `ForeignKey`, instances of the foreign-key model will have
    access to a `Manager` that returns all instances of the first model. By default,
    this `Manager` is named `foo_set`, where `foo` is the source model name, lowercased.
    This `Manager` returns `QuerySets`, which can be filtered and manipulated as described
    in the Retrieving objects section above.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'You can override the `foo_set` name by setting the `related_name` parameter
    in the `ForeignKey` definition. For example, if the `Entry` model was altered
    to `blog = ForeignKey(Blog, related_name=''entries'')`, the above example code
    would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Using a custom reverse manager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, the `RelatedManager` used for reverse relations is a subclass of
    the default manager for that model. If you would like to specify a different manager
    for a given query you can use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: If `EntryManager` performed default filtering in its `get_queryset()` method,
    that filtering would apply to the `all()` call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, specifying a custom reverse manager also enables you to call its
    custom methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Additional methods to handle related objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In addition to the `QuerySet` methods defined in *Retrieving objects* earlier,
    the `ForeignKey` `Manager` has additional methods used to handle the set of related
    objects. A synopsis of each is as follows (complete details can be found in the
    related objects reference at [https://docs.djangoproject.com/en/1.8/ref/models/relations/#related-objects-reference](https://docs.djangoproject.com/en/1.8/ref/models/relations/#related-objects-reference)):'
  prefs: []
  type: TYPE_NORMAL
- en: '`add(obj1, obj2, ...)` Adds the specified model objects to the related object
    set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`create(**kwargs)` Creates a new object, saves it and puts it in the related
    object set. Returns the newly created object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove(obj1, obj2, ...)` Removes the specified model objects from the related
    object set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clear()` Removes all objects from the related object set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set(objs)` Replace the set of related objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To assign the members of a related set in one fell swoop, just assign to it
    from any iterable object. The iterable can contain object instances, or just a
    list of primary key values. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `e1` and `e2` can be full Entry instances, or integer primary
    key values.
  prefs: []
  type: TYPE_NORMAL
- en: If the `clear()` method is available, any pre-existing objects will be removed
    from the `entry_set` before all objects in the iterable (in this case, a list)
    are added to the set. If the `clear()` method is *not* available, all objects
    in the iterable will be added without removing any existing elements.
  prefs: []
  type: TYPE_NORMAL
- en: Each reverse operation described in this section has an immediate effect on
    the database. Every addition, creation and deletion is immediately and automatically
    saved to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Many-to-many relationships
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both ends of a many-to-many relationship get automatic API access to the other
    end. The API works just as a backward one-to-many relationship, above.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only difference is in the attribute naming: The model that defines the
    `ManyToManyField` uses the attribute name of that field itself, whereas the reverse
    model uses the lowercased model name of the original model, plus `''_set''` (just
    like reverse one-to-many relationships).'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example makes this easier to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Like `ForeignKey`, `ManyToManyField` can specify `related_name`. In the above
    example, if the `ManyToManyField` in `Entry` had specified `related_name='entries'`,
    then each `Author` instance would have an `entries` attribute instead of `entry_set`.
  prefs: []
  type: TYPE_NORMAL
- en: One-to-one relationships
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One-to-one relationships are very similar to many-to-one relationships. If you
    define a `OneToOneField` on your model, instances of that model will have access
    to the related object via a simple attribute of the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference comes in reverse queries. The related model in a one-to-one
    relationship also has access to a `Manager` object, but that `Manager` represents
    a single object, rather than a collection of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: If no object has been assigned to this relationship, Django will raise a `DoesNotExist`
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instances can be assigned to the reverse relationship in the same way as you
    would assign the forward relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Queries over related objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Queries involving related objects follow the same rules as queries involving
    normal value fields. When specifying the value for a query to match, you may use
    either an object instance itself, or the primary key value for the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you have a Blog object `b` with `id=5`, the following three
    queries would be identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Falling back to raw SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you find yourself needing to write an SQL query that is too complex for Django's
    database-mapper to handle, you can fall back on writing SQL by hand.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it's important to note that the Django database layer is merely an
    interface to your database. You can access your database via other tools, programming
    languages or database frameworks; there's nothing Django-specific about your database.
  prefs: []
  type: TYPE_NORMAL
