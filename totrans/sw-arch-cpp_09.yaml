- en: Building and Packaging
  prefs: []
  type: TYPE_NORMAL
- en: As an architect, you will need to know about all the elements that make up the
    build process. This chapter will explain all the elements that make up the build
    process. From compiler flags to automation scripts and beyond, we will guide you
    to the point where each possible module, service, and artifact is versioned and
    stored in a central location ready for deployment. We will mainly focus on CMake.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you''ll learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What compiler flags you should consider using
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create build systems based on Modern CMake
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to build reusable components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use external code in CMake cleanly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create DEB and RPM packages, as well as NSIS installers, using CPack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the Conan package manager for installing your dependencies and for
    creating your own packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After reading this chapter, you'll know how to write state-of-the-art code for
    building and packaging your project.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To replicate the examples from this chapter, you should install a recent version
    of **GCC** and **Clang**, **CMake 3.15** or higher, **Conan**, and **Boost 1.69**.
  prefs: []
  type: TYPE_NORMAL
- en: The source code snippets from the chapter can be found at [https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter07](https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter07)[.](https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter07)
  prefs: []
  type: TYPE_NORMAL
- en: Getting the most out of compilers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Compilers are one of the most important tools in every programmer's workshop.
    That's why getting to know them well can help you out in many different ways,
    on countless occasions. In this section, we'll describe a few tips to use them
    effectively. This will only touch the tip of the iceberg as whole books can be
    written about these tools and their vast variety of available flags, optimizations,
    functionalities, and other specifics. GCC even has a wiki page with a list of
    books about compilers! You can find it in the *Further reading* section at the
    end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Using multiple compilers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the things you should consider in your build process is using multiple
    compilers instead of just one, the reason being the several benefits that come
    with it. One of them is that they can detect different issues with your code.
    For instance, MSVC has signedness checks enabled by default. Using several compilers
    can help with potential portability issues you may encounter in the future, especially
    when a decision is made to also compile your code on a different OS, such as moving
    from Linux to Windows or the other way. To make such efforts at no cost, you should
    strive to write portable, ISO C++-compliant code. One of the benefits of **Clang**
    is that it strives for compliance with the C++ standards more than GCC. If you're
    using **MSVC**, try adding the `/permissive-` option (available since Visual Studio
    17; enabled by default for projects created using version 15.5+). For **GCC**,
    try not to use the GNU variants when choosing the C++ standard for your code (for
    example, prefer `-std=c++17` to `-std=gnu++17`). If performance is your goal,
    being able to build your software with a wide range of compilers will also allow
    you to pick the one that will offer the fastest binaries for your specific use
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of which compiler you choose for your release builds, consider using
    Clang for development. It runs on macOS, Linux, and Windows, supports the same
    set of flags as GCC, and aims to provide the fastest build times and concise compilation
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re using CMake, you have two common ways to add another compiler. One
    is to pass the appropriate compilers when invoking CMake, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It's also possible to just set CC and CXX before invoking CMake, but those variables
    are not honored on all platforms (such as macOS).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another approach is to use toolchain files. It''s probably an overkill if you
    just need to use a different compiler, but it''s the go-to solution when you want
    to cross-compile. To use a toolchain file, you should pass it as a CMake argument:
    `-DCMAKE_TOOLCHAIN_FILE=toolchain.cmake`.'
  prefs: []
  type: TYPE_NORMAL
- en: Reducing build times
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every year, programmers spend countless hours waiting for their builds to complete.
    Reducing build times is an easy way to improve the productivity of whole teams,
    so let's discuss a few approaches to doing it.
  prefs: []
  type: TYPE_NORMAL
- en: Using a fast compiler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the simplest ways to have faster builds is sometimes to upgrade your
    compiler. For instance, by upgrading Clang to 7.0.0, you could shave up to 30%
    off of build times using **Precompiled Header** (**PCH**) files. Since Clang 9,
    it has gained the `-ftime-trace` option, which can provide you with information
    on the compilation times of all the files it processes. Other compilers have similar
    switches, too: check out GCC''s `-ftime-report` or MSVC''s `/Bt` and `/d2cgsummary`.
    Often you can get faster compiles by switching the compiler, which is especially
    useful on your development machine; for example, Clang usually compiles code faster
    than GCC.'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have a fast compiler, let's take a look at what it needs to compile.
  prefs: []
  type: TYPE_NORMAL
- en: Rethinking templates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Different parts of the compilation process take a different amount of time
    to complete. This is especially important for compile-time constructs. One of
    Odin Holmes'' interns, Chiel Douwes, created the so-called Rule of Chiel based
    on benchmarking the compile-time costs of various template operations. This, and
    other type-based template metaprogramming tricks, can be seen in the *Type Based
    Template Metaprogramming is Not Dead* lecture by Odin Holmes. From fastest to
    slowest, they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Looking up a memoized type (for example, a template instantiation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a parameter to an alias call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a parameter to a type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling an alias
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instantiating a type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instantiating a function template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using **SFINAE** (**Substitution Failure Is Not an Error**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To demonstrate this rule, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It defines a `conditional` template alias, which stores a type that resolves
    as `T` if condition `B` is true, and to `F` otherwise. The traditional way to
    write such a utility would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: However, this second way is slower to compile than the first because it relies
    on creating template instances instead of type aliases.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now take a look at what tools and their features you can use to keep compile
    times low.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A common technique that can make your builds faster is to use a **single compilation
    unit build,** or **unity build**. It won't speed up every project, but it may
    be worth a shot if there's plenty of code in your header files. Unity builds work
    by just including all your `.cpp` files in one translation unit. Another similar
    idea is to use pre-compiled headers. Plugins such as Cotire for CMake will handle
    both of these techniques for you. CMake 3.16 also adds native support for unity
    builds, which you can enable either for one target, `set_target_properties(<target>
    PROPERTIES UNITY_BUILD ON)`, or globally by setting `CMAKE_UNITY_BUILD` to `true`.
    If you just want PCHs, you might want to take a look into CMake 3.16's `target_precompile_headers`.
  prefs: []
  type: TYPE_NORMAL
- en: If you feel like you are including too much in your C++ files, consider using
    a tool named **include-what-you-use** to tidy them up. Preferring forward declaring
    types and functions to including header files can also go a long way in reducing
    the compilation times.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your project takes forever to link, there are some ways to deal with this
    as well. Using a different linker, such as LLVM''s LLD or GNU''s Gold, can help
    a lot, especially since they allow multi-threaded linking. If you can''t afford
    to use a different linker, you can always experiment with flags such as `-fvisibility-hidden`
    or `-fvisibility-inlines-hidden` and mark only the functions you want to have
    visible in your shared library with an appropriate annotation in the source code.
    This way, the linker will have less work to perform. If you''re using link-time
    optimization, try to only do that for the builds that are performance-critical:
    those that you plan to profile and those meant for production. Otherwise, you''ll
    probably just waste your developers'' time.'
  prefs: []
  type: TYPE_NORMAL
- en: If you're using CMake and aren't tied to a specific generator (for example,
    CLion requires using the `Code::Blocks` generator), you can replace the default
    Make generator with a faster one. **Ninja** is a great one to start with as it
    was created specifically to reduce build times. To use it, just pass `-G Ninja`
    when invoking CMake.
  prefs: []
  type: TYPE_NORMAL
- en: There are still two more great tools that will surely give you a boost. One
    of them is **Ccache**. It's a tool that runs its cache of C and C++ compilation
    outputs. If you're trying to build the same thing twice, it will get the results
    from the cache instead of running the compilation. It keeps the statistics, such
    as cache hits and misses, can remember the warnings that it should emit when compiling
    a specific file, and has many configuration options that you can store in the
    `~/.ccache/ccache.conf` file. To obtain its statistics, just run `ccache --show-stats`.
  prefs: []
  type: TYPE_NORMAL
- en: The second tool is **IceCC** (or Icecream). It's a fork of distcc, essentially
    a tool to distribute your builds across hosts. With IceCC, it's easier to use
    a custom toolchain. It runs the iceccd daemon on each host and an icecc-scheduler
    service that manages the whole cluster. The scheduler, unlike in distcc, makes
    sure to only use the idle cycles on each machine, so you won't end up overloading
    other people's workstations.
  prefs: []
  type: TYPE_NORMAL
- en: To use both IceCC and Ccache for your CMake builds, just add `-DCMAKE_C_COMPILER_LAUNCHER="ccache;icecc"
    -DCMAKE_CXX_COMPILER_LAUNCHER="ccache;icecc"` to your CMake invocation. If you're
    compiling on Windows, instead of the last two tools, you could use clcache and
    Incredibuild or look for other alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to build fast, let's move on to another important topic.
  prefs: []
  type: TYPE_NORMAL
- en: Finding potential code issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even the quickest builds aren't worth much if your code has bugs. There are
    dozens of flags to warn you of potential issues in your code. This section will
    try to answer which ones you should consider enabling.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s start with a slightly different matter: how not to get warned
    about issues with code from other libraries. Getting warned about issues that
    you can''t really fix isn''t useful. Fortunately, there are compiler switches
    to disable such warnings. In GCC, for instance, you have two types of `include`
    files: regular (passed using `-I`) and system ones (passed using `-isystem`).
    If you specify a directory using the latter, you won''t get warnings from the
    headers it contains. MSVC has an equivalent for `-isystem`: `/external:I`. Additionally,
    it has other flags to handle external includes, such as `/external:anglebrackets`,
    which tells the compiler to treat all files included using angle brackets as external
    ones, thus disabling warnings for them. You can specify a warning level for external
    files. You can also keep warnings coming from template instantiations caused by
    your code using `/external:templates-`. If you''re looking for a portable way
    to mark `include` paths as system/external ones, and you''re using CMake, you
    can add the `SYSTEM` keyword to a `target_include_directories` directive.'
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of portability, if you want to be conformant to a C++ standard (and
    you should), consider adding `-pedantic` to your compile options for GCC or Clang,
    or the `/permissive-` option for MSVC. This way, you'll get informed about every
    non-standard extension that you might be using. If you're using CMake, add the
    following line for each of your targets, `set_target_properties(<target> PROPERTIES
    CXX_EXTENSIONS OFF)`, to disable compiler-specific extensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re using MSVC, strive to compile your code with `/W4`, since it enables
    most of the important warnings. For GCC and Clang, try to use `-Wall -Wextra -Wconversion
    -Wsign-conversion`. The first one, despite its name, enables only some common
    warnings. The second, however, adds another bunch of warnings. The third one is
    based on the tips from a great book by Scott Meyers, titled *Effective C++* (it''s
    a set of good warnings, but check that it''s not too noisy for your needs). The
    last two are about type conversions and signedness conversions. All those flags
    together create a sane safety net, but you can, of course, look for more flags
    to enable. Clang has a `-Weverything` flag. Try to periodically run a build with
    it to discover new, potential warnings that could be worth enabling in your codebase.
    You might be surprised at how many messages you get with this flag, although enabling
    some of the warning flags might not be worth the hassle. An MSVC alternative is
    named `/Wall`. Take a look at the following tables to see some other interesting
    options that are not enabled by the preceding 9:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GCC/Clang**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Flag** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| `-Wduplicated-cond` | Warn when the same condition is used in `if` and `else-if`
    blocks. |'
  prefs: []
  type: TYPE_TB
- en: '| `-Wduplicated-branches` | Warn if both branches contain the same source code.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-Wlogical-op` | Warn when operands in logical operations are the same and
    when a bitwise operator should be used instead. |'
  prefs: []
  type: TYPE_TB
- en: '| `-Wnon-virtual-dtor` | Warn when a class has virtual functions but not a
    virtual destructor. |'
  prefs: []
  type: TYPE_TB
- en: '| `-Wnull-dereference` | Warn about null dereferences. This check may be inactive
    in unoptimized builds. |'
  prefs: []
  type: TYPE_TB
- en: '| `-Wuseless-cast` | Warn when casting to the same type. |'
  prefs: []
  type: TYPE_TB
- en: '| `-Wshadow` | A whole family of warnings about declarations that shadow other,
    previous declarations. |'
  prefs: []
  type: TYPE_TB
- en: '**MSVC:**'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Flag** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| `/w44640` | Warn on non-thread-safe static member initialization. |'
  prefs: []
  type: TYPE_TB
- en: 'One last thing worth mentioning is the question: to `-Werror` (or `/WX` on
    MSVC) or not to `-Werror`? This really depends on your personal preferences as
    issuing errors instead of warnings has its pros and cons. On the plus side, you
    won''t let any of your enabled warnings slip by. Your CI build will fail and your
    code won''t compile. When running multi-threaded builds, you won''t lose any warnings
    in the quickly passing compilation messages. However, there are some minuses too.
    You won''t be able to upgrade your compiler if it enables any new warnings or
    just detects more issues. The same goes for dependencies, which can deprecate
    some functions they provide. You won''t be able to deprecate anything in your
    code if it''s used by other parts of your project. Fortunately, you can always
    use a mixed solution: strive to compile with `-Werror`, but disable it when you
    need to do the things it inhibits. This requires discipline, as if any new warnings
    are to slip in, you may have a hard time eliminating them.'
  prefs: []
  type: TYPE_NORMAL
- en: Using compiler-centric tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Nowadays, compilers allow you to do much more with them than a few years back.
    This is owing to the introduction of LLVM and Clang. By providing APIs and a modular
    architecture allowing easy reuse, caused tools such as sanitizers, automatic refactoring,
    or code completion engines to flourish. You should consider taking advantage of
    what this compiler infrastructure offers you. Use clang-format to ensure all the
    code in your code base conforms to a given standard. Consider adding pre-commit
    hooks using the pre-commit tool to reformat new code before commit. You can also
    add Python and CMake formatters to the mix. Statically analyze the code using
    clang-tidy – a tool that actually understands your code instead of just reasoning
    about it. There's a ton of different checks this tool can perform for you, so
    be sure to customize the list and options to your specific needs. You can also
    run nightly or weekly tests of your software with sanitizers enabled. This way,
    you can detect threading issues, undefined behavior, memory access, management
    issues, and more. Running tests using debug builds can also be of value if your
    release builds have assertions disabled.
  prefs: []
  type: TYPE_NORMAL
- en: If you think that more could be done, you can consider writing your own code
    refactorizations using Clang's infrastructure. There's already a `clang-rename`
    tool if you want to see how to create an LLVM-based tool of your own. Additional
    checks and fix-its for clang-tidy are also not that hard to create, and they can
    save you hours of manual labor.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can integrate many tools into your building process. Let''s now discuss
    the heart of the process: the build system.'
  prefs: []
  type: TYPE_NORMAL
- en: Abstracting the build process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll delve into CMake scripts, the de facto standard build
    system generator used for C++ projects worldwide.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing CMake
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What does it mean that CMake is a build system generator and not a build system
    per se? Simply that CMake can be used to generate various types of build systems.
    You can use it to generate Visual Studio projects, Makefile projects, Ninja-based
    ones, Sublime, Eclipse, and a few others.
  prefs: []
  type: TYPE_NORMAL
- en: CMake comes with a set of other tools, such as CTest for executing tests and
    CPack for packaging and creating setup programs. CMake itself allows exporting
    and installing targets too.
  prefs: []
  type: TYPE_NORMAL
- en: CMake's generators can be either single-configuration, such as Make or NMAKE,
    or multi-configuration, such as Visual Studio. For single-configuration ones,
    you should pass the `CMAKE_BUILD_TYPE` flag when running the generation for the
    first time in a folder. For instance, to configure a debug build, you could run
    `cmake <project_directory> -DCMAKE_BUILD_TYPE=Debug`. Other predefined configurations
    are `Release`, `RelWithDebInfo` (release with debug symbols), and `MinSizeRel`
    (release optimized for minimum binary size). To keep your source directories clean,
    always create a separate build folder and run CMake generation from there.
  prefs: []
  type: TYPE_NORMAL
- en: Although it's possible to add your own build type, you should really strive
    not to do so, as this makes using some IDEs much harder and doesn't scale. A much
    better option is to use, well, `option`.
  prefs: []
  type: TYPE_NORMAL
- en: 'CMake files can be written in two styles: an obsolete one, based on variables,
    and a target-based Modern CMake style. We''ll focus just on the latter here. Try
    to avoid setting things through global variables, as this causes issues when you
    want to reuse your targets.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating CMake projects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each CMake project should have the following lines in their top-level `CMakeLists.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Setting a minimum and a maximum supported version is important as it influences
    how CMake will behave by setting policies. You can also set them manually if needed.
  prefs: []
  type: TYPE_NORMAL
- en: The definition of our project specifies its name, version (which will be used
    to populate a few variables), and the programming languages that CMake will use
    to build the project (which populates many more variables and finds the required
    tools).
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical C++ project has the following directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cmake`: For CMake scripts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`include`: For public headers, usually with a subfolder named after the project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src`: For source files and private headers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test`: For tests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can use the CMake directory to store your custom CMake modules. To have
    easy access to scripts from this directory, you can add it to CMake''s `include()`
    search path like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When including CMake modules, you can omit the `.cmake` suffix. This means `include(CommonCompileFlags.cmake)`
    is equal to just `include(CommonCompileFlags)`.
  prefs: []
  type: TYPE_NORMAL
- en: Distinguishing between CMake directory variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Navigating through the directories in CMake has a common pitfall that not everyone
    is aware of. When writing CMake scripts, try to distinguish between the following
    built-in variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PROJECT_SOURCE_DIR`: The directory where the `project` command was last called
    from a CMake script.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PROJECT_BINARY_DIR`: Like the preceding one, but for the build directory tree.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMAKE_SOURCE_DIR`: Top-level source directory (this may be in another project
    that just adds ours as a dependency/subdirectory).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMAKE_BINARY_DIR`: Like `CMAKE_SOURCE_DIR`, but for the build directory tree.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMAKE_CURRENT_SOURCE_DIR`: The source directory corresponding to the currently
    processed `CMakeLists.txt` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMAKE_CURRENT_BINARY_DIR`: The binary (build) directory matching `CMAKE_CURRENT_SOURCE_DIR`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMAKE_CURRENT_LIST_DIR`: The directory of `CMAKE_CURRENT_LIST_FILE`. It can
    be different from the current source directory if the current CMake script was
    included from another one (common for CMake modules that are included).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having cleared that up, let's now start navigating through those directories.
  prefs: []
  type: TYPE_NORMAL
- en: In your top-level `CMakeLists.txt` file, you will probably want to call `add_subdirectory(src)`
    so that CMake will process that directory.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying CMake targets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the `src` directory, you should have another `CMakeLists.txt` file, this
    time probably defining a target or two. Let''s add an executable for a customer
    microservice for the Dominican Fair system we mentioned earlier in the book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Source files can be specified as in the preceding code line or added later using
    `target_sources`.
  prefs: []
  type: TYPE_NORMAL
- en: A common CMake antipattern is the use of globs to specify source files. A big
    drawback of using them is that CMake will not know if a file was added until it
    reruns generation. A common consequence of that is that if you pull changes from
    a repository and simply build, you can miss compiling and running new unit tests
    or other code. Even if you used globs with `CONFIGURE_DEPENDS`, the build time
    will get longer because globs must be checked as part of each build. Besides,
    the flag may not work reliably with all generators. Even the CMake authors discourage
    using it in favor of just explicitly stating the source files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, so we defined our sources. Let''s now specify that our target requires
    C++17 support from the compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `PRIVATE` keyword specifies that this is an internal requirement, that is,
    just visible to this specific target and not to any targets that will depend on
    it. If you were writing a library that provided a user with a C++17 API, you could
    use the `INTERFACE` keyword. To specify both the interface and internal requirements,
    you could use the `PUBLIC` keyword. When the consumer links to our target, CMake
    will then automatically require C++17 support for it as well. If you were writing
    a target that is not built (that is, a header-only library or an imported target),
    using the `INTERFACE` keyword is usually enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should also note that specifying that our target wants to use C++17 features
    doesn''t enforce the C++ standard or disallow compiler extensions for our target.
    To do so, you should instead call the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to have a set of compiler flags to pass to each target, you can
    store them in a variable and call the following if you want to create a target
    that has those flags set as `INTERFACE` and doesn''t have any source and uses
    this target in `target_link_libraries`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The command automatically propagates include directories, options, macros,
    and other properties, aside from just adding a linker flag. Speaking of linking,
    let''s create a library that we shall link with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`add_library` can be used to create static, shared, object, and interface (think
    header-only) libraries, as well as defining any imported libraries.'
  prefs: []
  type: TYPE_NORMAL
- en: The **`ALIAS`** version of it creates a namespaced target, which helps debug
    many CMake issues and is a recommended Modern CMake practice.
  prefs: []
  type: TYPE_NORMAL
- en: Because we gave our target a `lib` prefix already, we set the output name to
    have **`libcustomer.a`** instead of `liblibcustomer.a`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we link our executable with the added library. Try to always specify
    the `PUBLIC`, `PRIVATE`, or `INTERFACE` keyword for the `target_link_libraries`
    command as this is crucial for CMake to effectively manage the transitivity of
    the target dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the output directories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once you build your code using commands such as `cmake --build .`, you might
    want to know where to find the build artifacts. By default, CMake will create
    them in a directory matching the source directory they were defined in. For instance,
    if you have a `src/CMakeLists.txt` file with an `add_executable` directive, then
    the binary will land in your build directory''s `src` subdirectory by default.
    We can override this using code such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This way, the binaries and DLL files will land in the `bin` subdirectory of
    your project's build directory, while static and shared Linux libraries will be
    placed in the `lib` subdirectory.
  prefs: []
  type: TYPE_NORMAL
- en: Using generator expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Setting compile flags in a way to support both single- and multi-configuration
    generators can be tricky, as CMake executes `if` statements and many other constructs
    at configure time, not at build/install time.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that the following is a CMake antipattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, generator expressions are the proper way to achieve the same goal,
    as they''re being processed at a later time. Let''s see an example of their use
    in practice. Assuming you want to add a preprocessor definition just for your
    `Release` configuration, you could write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This will resolve to `RUN_FAST` only when building that one selected configuration.
    For others, it will resolve to an empty value. It works for both single- and multi-configuration
    generators. That's not the only use case for generator expressions, though.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some aspects of our targets may vary when used by our project during builds
    and by other projects when the target is installed. A good example is **include
    directories**. A common way to deal with this in CMake is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we have two generator expressions. The first one tells us that
    when installed, the include files can be found in the `include` directory, relative
    to the install prefix (the root of the installation). If we're not installing,
    this expression will become an empty one. This is why we have another expression
    for building. This one will resolve as the `include` subdirectory of the directory
    where the last used `project()` was found.
  prefs: []
  type: TYPE_NORMAL
- en: Don't use `target_include_directories` with a path outside of your module. If
    you do, you're **stealing** someone's headers instead of explicitly declaring
    a library/target dependency. This is a CMake antipattern.
  prefs: []
  type: TYPE_NORMAL
- en: CMake defines many generator expressions that you can use to query the compiler
    and platform, as well as the targets (such as full name, the list of object files,
    any property values, and so on). Aside from these, there are expressions that
    run Boolean operations, if statements, string comparisons, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, for a more complex example, assuming you''d like to have a set of compile
    flags that you use across your targets and that depend on the compiler used, you
    could define it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This will append one set of flags if the compiler is Clang or AppleClang or
    GCC and another one if MSVC is being used instead. Note that we separate the flags
    with a semicolon because that's how CMake separates elements on a list.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now see how we could add external code for our projects to use.
  prefs: []
  type: TYPE_NORMAL
- en: Using external modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several ways for you to fetch the external projects you depend on.
    For instance, you could add them as a Conan dependency, use CMake's `find_package`
    to look for a version provided by the OS or installed in another way, or fetch
    and compile the dependency yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key message of this section is: if you can, you should use Conan. This
    way, you''ll end up using one version of the dependency that matches your project''s
    and its dependencies'' requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: If you're aiming to support multiple platforms, or even multiple versions of
    the same distribution, using Conan or compiling everything yourself are the ways
    to go. This way, you'll use the same dependency version regardless of the OS you
    compile on.
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss a few ways of grabbing your dependencies offered by CMake itself,
    and then jump to using the multi-platform package manager named Conan.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the possible ways to prepare your dependencies from the source is to
    use CMake's built-in `FetchContent` module. It will download your dependencies
    and then build them for you as a regular target.
  prefs: []
  type: TYPE_NORMAL
- en: The feature arrived in CMake 3.11\. It's a replacement for the `ExternalProject`
    module, which had many flaws. One of them was that it cloned the external repository
    during build time, so CMake couldn't reason about the targets that the external
    project defined, as well as about their dependencies. This made many projects
    resort to manually defining the `include` directories and library paths of such
    external targets and ignoring their required interface compilation flags and dependencies
    completely. Ouch. `FetchContent` doesn't have such issues, so it's recommended
    you use it instead.
  prefs: []
  type: TYPE_NORMAL
- en: Before we show how to use it, you must know that both `FetchContent` and `ExternalProject`
    (as well as using Git submodules and similar methods) have one important flaw.
    If you have many dependencies using the same third-party library themselves, you
    might end up with having multiple versions of the same project, such as a few
    versions of Boost. Using package managers such as Conan can help you avoid such
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of an example, let''s demonstrate how to integrate **GTest** into
    your project using the aforementioned `FetchContent` feature. First, create a
    `FetchGTest.cmake` file and put it in the `cmake` directory in our source tree.
    Our `FetchGTest` script will be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: First, we include the built-in `FetchContent` module. Once the module is loaded,
    we declare the dependency using `FetchContent_Declare`. Now, let's name our dependency
    and specify the repository that CMake will clone, along with the revision that
    it will check out.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can read the properties of our external library and populate (that is,
    check it out) it if that wasn't done already. Once we have the sources, we can
    process them using `add_subdirectory`. The `EXCLUDE_FROM_ALL` option will tell
    CMake to not build those targets if they're not needed by other targets when we
    run a command such as `make all`. After successfully processing the directory,
    our script will print a message denoting the directory in which GTests libraries
    will land after being built.
  prefs: []
  type: TYPE_NORMAL
- en: If you're not fond of building your dependencies together with your project,
    perhaps the next way of integrating your dependencies will be more suitable for
    you.
  prefs: []
  type: TYPE_NORMAL
- en: Using find scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assuming your dependency is available somewhere on your host, you can just call
    `find_package` to try to search for it. If your dependency provides a config or
    targets files (more on those later), then just writing this one simple command
    is all you need. That is, of course, assuming that the dependencies are already
    available on your machine. If not, it's your responsibility to install them before
    running CMake for your project.
  prefs: []
  type: TYPE_NORMAL
- en: To create the preceding files, your dependency would need to use CMake, which
    is not always the case. How could you deal with those libraries that don't use
    CMake? If the library is popular, chances are someone already created a find script
    for you to use. The Boost libraries in versions older than 1.70 were a common
    example of this approach. CMake comes with a `FindBoost` module that you can execute
    by just running `find_package(Boost)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find Boost using the preceding module, you would first need to install it
    on your system. After that, in your CMake lists, you should set any options that
    you find reasonable. For instance, to use dynamic and multi-threaded Boost libraries,
    not linked statically to the C++ runtime, specify the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you need to actually search for the library, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we specified that we want to just use Beast, a great networking library
    that comes as part of Boost. Once found, you could link it to your target as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now that you know how to properly use a find script, let's learn how to write
    one on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Writing find scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If your dependency is neither providing config and target files nor has anyone
    written a find module for it, you can always write such a module yourself.
  prefs: []
  type: TYPE_NORMAL
- en: This is not something you'll do very often, so we'll try to just skim the topic.
    For an in-depth description, you should also read the guidelines in the official
    CMake documentation (linked in the *Further reading* section) or just look at
    a few find modules installed with CMake (usually in a directory such as `/usr/share/cmake-3.17/Modules`
    on Unix systems). For simplicity, we assume there's just one configuration of
    your dependency that you'd like to find, but it's possible to find `Release` and
    `Debug` binaries separately. This will result in different targets with different
    associated variables being set.
  prefs: []
  type: TYPE_NORMAL
- en: The script name determines the argument you'll pass to `find_package`; for example,
    if you wish to end up with `find_package(Foo)`, then your script should be named
    `FindFoo.cmake`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good practice is to start your script with a `reStructuredText` section describing
    what your script will actually do, which variables it will set, and so on. An
    example of such a description could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Usually, you''ll also want to describe the variables your script will set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If `MyDep` has any dependencies itself, now is the time to find them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can start our search for the library. A common way to do so is to use
    `pkg-config`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If `pkg-config` has information on our dependency, it will set some variables
    we can use to find it.
  prefs: []
  type: TYPE_NORMAL
- en: A good idea might be to have a variable that the user of our script can set
    to point us to the location of the library. As per CMake conventions, it should
    be named `MyDep_ROOT_DIR`. To provide CMake with this variable, the user can either
    invoke CMake with `-DMyDep_ROOT_DIR=some/path`, modify the variable in `CMakeCache.txt`
    in their build directory, or use the `ccmake` or `cmake-gui` programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can actually search for the headers and libraries of our dependency
    using the aforementioned paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to also set the found version, as we promised in the header of
    our script. To use the one found from `pkg-config`, we could write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can just manually extract the version either from the contents
    of the header file, from components of the library path, or using any other means.
    Once this is done, let''s leverage CMake''s built-in scripts to decide whether
    the library was successfully found while handling all the possible parameters
    to the `find_package` invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As we decided to provide a target and not just a bunch of variables, now it''s
    time to define it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s hide our internally used variables with users who don''t want
    to deal with them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have a complete find module that we can use in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This is how you can write the find module yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Don't write `Find\*.cmake` modules for your own packages. Those are meant for
    packages that don't support CMake. Instead, write a `Config\*.cmake` module (as
    described later in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Let's now show how to use a proper package manager instead of doing the heavy
    lifting yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Conan package manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Conan is an open source, decentralized package manager for native packages.
    It supports multiple platforms and compilers. It can also integrate with multiple
    build systems.
  prefs: []
  type: TYPE_NORMAL
- en: If a package has not already been built for your environment, Conan will handle
    building it on your machine instead of downloading the already-built version.
    Once built, you can upload it to either the public repositories, your own `conan_server`
    instance, or an Artifactory server.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing Conan profiles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If this is the first time you''re running Conan, it will create a default profile
    based on your environment. You might want to modify some of its settings either
    by creating a new profile or by updating the default one. Assuming we''re using
    Linux and want to compile everything using GCC 9.x, we could run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If our dependencies come from other repositories than the default ones, we can
    add those using `conan remote add <repo> <repo_url>`. You might want to use this
    to configure your company's one, for instance.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've set Conan up, let's show how to grab our dependencies using Conan
    and integrate all of this into our CMake scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying Conan dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our project relies on the C++ REST SDK. To tell this to Conan, we need to create
    a file called `conanfile.txt`. In our case, it will contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You can specify as many dependencies as you want here. Each of them can have
    either a fixed version, a range of the fixed versions, or a tag such as **latest**.
    After the `@` sign, you can find the company that owns the package and the channel
    that allows you to select a specific variant of the package (usually stable and
    testing).
  prefs: []
  type: TYPE_NORMAL
- en: The **generators** section is where you specify what build systems you want
    to use. For CMake projects, you should use `CMakeDeps`. You can also generate
    lots of others, including ones for generating compiler arguments, CMake toolchain
    files, Python virtual environments, and many more.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we don''t specify any additional options, but you could easily
    add this section and configure variables for your packages and for their dependencies.
    For instance, to compile our dependency as a static library, we could write the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Once we have `conanfile.txt` in place, let's tell Conan to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Conan dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To use our Conan packages in CMake code, we must first install them. In Conan,
    this means downloading the sources and building them or downloading prebuilt binaries,
    as well as creating configuration files that we''ll use in CMake. To make Conan
    handle this for us after we have created our build directory, we should `cd` into
    it and simply run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: By default, Conan wants to download all the dependencies as prebuilt binaries.
    If the server doesn't have them prebuilt, Conan will build them instead of bailing
    out as we passed the `--build=missing` flag. We tell it to grab the release versions
    built using the same compiler and environment as we have in our profile. You can
    install packages for more than one build type by simply invoking another commands
    with `build_type` set to other CMake build types. This can help you quickly switch
    between them if needed. If you want to use the default profile (the one Conan
    can detect for you automatically), just don't pass the `-pr` flag.
  prefs: []
  type: TYPE_NORMAL
- en: If the CMake generator we plan to use was not specified in `conanfile.txt`,
    we can append it to the preceding command. For instance, to use the `compiler_args`
    generator, we should append `--generator compiler_args`. Later you could use what
    it produced by passing `@conanbuildinfo.args` to your compiler invocation.
  prefs: []
  type: TYPE_NORMAL
- en: Using Conan targets from CMake
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once Conan finishes downloading, building, and configuring our dependencies,
    we need to tell CMake to use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re using Conan with the `CMakeDeps` generator, be sure to specify a
    `CMAKE_BUILD_TYPE` value. In other cases, CMake will be unable to use the packages
    configured by Conan. An example invocation (from the same directory you ran Conan)
    could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This way, we would build our project in release mode; we must use one of the
    types we installed using Conan. To find our dependencies, we can just use CMake''s
    `find_package`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: First, we add the root build directory to the path CMake will try to find package
    config files in. Then, we find the package config files generated by Conan.
  prefs: []
  type: TYPE_NORMAL
- en: 'To pass Conan-defined targets as our targets'' dependencies, it''s best to
    use the namespaced target name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This way, we'll get an error during CMake's configuration when the package is
    not found. Without the alias, we'd get an error when trying to link.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have compiled and linked our targets just the way we wanted, it's
    time to put them to the test.
  prefs: []
  type: TYPE_NORMAL
- en: Adding tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CMake has its own test driver program named `CTest`. It's easy to add new test
    suites to it from your `CMakeLists` either on your own or using the many integrations
    provided by testing frameworks. Later in the book, we'll discuss testing in depth,
    but let's first show how to quickly and cleanly add unit tests based on the GoogleTest,
    or GTest, testing framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, to define your tests in CMake, you''ll want to write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet will first check whether we are the main project that's
    being built or not. Usually, you just want to run tests for your project and omit
    even building the tests for any third-party components you use. This is why the
    project name is `checked`.
  prefs: []
  type: TYPE_NORMAL
- en: If we are to run our tests, we include the `CTest` module. This loads the whole
    testing infrastructure CTest offers, defines its additional targets, and calls
    a CMake function called `enable_testing`, which will, among other things, enable
    the `BUILD_TESTING` flag. This flag is cached, so you can disable all testing
    when building your project by simply passing a `-DBUILD_TESTING=OFF` argument
    to CMake when generating the build system.
  prefs: []
  type: TYPE_NORMAL
- en: All such cached variables are actually stored in a text file named `CMakeCache.txt`
    in your build directory. Feel free to modify the variables there to change what
    CMake does; it won't overwrite the settings there until you remove the file. You
    can do so using `ccmake`, `cmake-gui`, or just by hand.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `BUILD_TESTING` is true, we simply process the `CMakeLists.txt` file in
    our test directory. It could look like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The first include calls the script for providing us GTest that we described
    previously. After fetching GTest, our current `CMakeLists.txt` loads some helper
    function defined in the GoogleTest CMake module by invoking `include(GoogleTest)`.
    This will enable us to integrate our tests into CTest more easily. Finally, let's
    tell CMake to dive into a directory that contains some tests by calling `add_subdirectory(customer)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `test/customer/CMakeLists.txt` file will simply add an executable with
    tests that is compiled with our predefined set of flags and links to the tested
    module and GTest. Then, we call the CTest helper function that discovers the defined
    tests. All of this is just four lines of CMake code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Voilà!
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now build and execute your tests by simply going to the `build` directory
    and calling the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: You can pass a `-j` flag for CTest. It works just like with Make or Ninja invocations
    – parallelizes the test execution. If you want to have a shorter command for building,
    just run your build system, that is, by invoking `make`.
  prefs: []
  type: TYPE_NORMAL
- en: In scripts, it's usually better to use the longer form of the command; this
    will make your scripts independent of the build system used.
  prefs: []
  type: TYPE_NORMAL
- en: Once your tests have passed, we can now think about providing them to a wider
    audience.
  prefs: []
  type: TYPE_NORMAL
- en: Reusing quality code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CMake has built-in utilities that can come a long way when it comes to distributing
    the results of your builds. This section will describe installing and exporting
    utilities and the differences between them. Later sections will show you how to
    package your code using CPack, and how to do it using Conan.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and exporting is not that important for microservices per se, but
    it's very useful if you're delivering libraries for others to reuse.
  prefs: []
  type: TYPE_NORMAL
- en: Installing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have written or used Makefiles, you've most probably invoked `make install`
    at one point and seen how the deliverables of a project were installed either
    in the OS directories or in another directory of your choosing. If you're using
    `make` with CMake, using the steps from this section will allow you to install
    the deliverables in the same way. If not, you'll still be able to call the install
    target, of course. Aside from that, in both cases, you will then have an easy
    way to leverage CPack for creating packages based on your installation commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re on Linux, it''s probably a good idea to preset some installation
    directories based on the conventions of the OS by calling the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This will make the installer use a directory structure made of `bin`, `lib`,
    and similar other directories. Such directories can be also set manually using
    a few CMake variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating an install target consists of a few more steps. First and foremost
    is to define the targets we want to install, which in our case will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This tells CMake to expose our library and executable defined earlier in this
    chapter as `CustomerTargets`, using the directories we set earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you plan to install different configurations of your library to different
    folders, you could use a few invocations of the preceding command, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You can notice that we specify the directories for executables and libraries,
    but not for include files. We need to provide them in another command, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This means that the top-level include directory's contents will be installed
    in the include directory under the installation root. The slash after the first
    path fixes some path issues, so take note to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we have our set of targets; now we need to generate a file that another
    CMake project could read to understand our targets. This can be done in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This command takes our target set and creates a `CustomerTargets.cmake` file
    that will contain all the info about our targets and their requirements. Each
    of our targets will get prefixed with a namespace; for example, `customer` will
    become `domifair::customer`. The generated file will get installed in a subdirectory
    of the library folder in our installation tree.
  prefs: []
  type: TYPE_NORMAL
- en: To allow dependant projects to find our targets using CMake's `find_package`
    command, we need to provide a `CustomerConfig.cmake` file. If your target doesn't
    have any dependencies, you can just export the preceding targets directly to that
    file instead of the `targets` file. Otherwise, you should write your own config
    file that will include the preceding `targets` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we want to reuse some CMake variables, so we need to create a
    template and use the `configure_file` command to fill it in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `CustomerConfig.cmake.in` file will begin by dealing with our dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The `find_dependency` macro is a wrapper for `find_package` that is meant to
    be used in config files. Although we relied on Conan to provide us with the C++
    REST SDK 2.10.18 as defined in `conanfile.txt`, here we need to specify the dependency
    once more. Our package can be used on another machine, so we require that our
    dependency is installed there too. If you want to use Conan on the target machine,
    you can install the C++ REST SDK as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'After dealing with the dependencies, our config file template will include
    the `targets` file that we created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: When `configure_file` executes, it will replace all those `@VARIABLES@` with
    the contents of their matching `${VARIABLES}` defined in our project. This way,
    based on our `CustomerConfig.cmake.in` file template, CMake will create a `CustomerConfig.cmake`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'When finding a dependency using `find_package`, you''ll often want to specify
    a version of the package to find. To support that in our package, we must create
    a `CustomerConfigVersion.cmake` file. CMake offers us a helper function that will
    create this file for us. Let''s use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The `PACKAGE_VERSION` variable will get populated according to the `VERSION`
    argument we passed when calling `project` at the top of our top-level `CMakeLists.txt`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '`AnyNewerVersion COMPATIBILITY` means our package will be accepted by any package
    search if it is newer or the same as the requested version. Other options include
    `SameMajorVersion`, `SameMinorVersion`, and `ExactVersion`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have created our config and config version files, let''s tell CMake
    that they should be installed along with the binaries and our target file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'One last thing we should install is the license for our project. We''ll leverage
    CMake''s command for installing files to put them in our documentation directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: That's all you need to know to successfully create an install target in the
    root of your OS. You may ask how to install the package into another directory,
    such as just for the current user. To do so, you would need to set the `CMAKE_INSTALL_PREFIX`
    variable, for example, when generating the build system.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if we don't install into the root of our Unix tree, we'll have to
    provide the dependent project with a path to the installation directory, such
    as by setting `CMAKE_PREFIX_PATH`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now look at yet another way you could reuse what you just built.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Exporting is a technique to add information about a package that you built locally
    to CMake's package registry. This is useful when you want your targets to be visible
    right from their build directories, even without installation. A common use for
    exporting is when you have several projects checked out on your development machine
    and you build them locally.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s quite easy to add support for this mechanism from your `CMakeLists.txt`
    files. In our case, it can be done in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This way, CMake will create a targets file similar to the one from the *Installing*
    section, defining our library and executable targets in the namespace we provided.
    From CMake 3.15, the package registry is disabled by default, so we need to enable
    it by setting the appropriate preceding variable. Then, we can put the information
    about our targets right into the registry by exporting our package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we now have a `targets` file without a matching config file. This
    means that if our targets depend on any external libraries, they must be found
    before our package is found. In our case, the calls must be ordered in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: First, we find the C++ REST SDK, and only afterward do we look for our package
    that depends on it. That's all you need to know to start exporting your targets.
    Much easier than installing them, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: Let's now move on to a third way of exposing your targets to the external world.
  prefs: []
  type: TYPE_NORMAL
- en: Using CPack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we'll describe how to use CPack, the packaging tool that comes
    with CMake.
  prefs: []
  type: TYPE_NORMAL
- en: CPack allows you to easily create packages in various formats, ranging from
    ZIP and TGZ archives through to DEB and RPM packages, and even installation wizards
    such as NSIS or a few OS X-specific ones. Once you have your installation logic
    in place, it's not hard to integrate the tool. Let's show how to use CPack to
    package our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to specify variables that CPack will use when creating the packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to give some information by hand, but some variables can be filled
    based on our project version specified when we defined our project. There are
    many more CPack variables and you can read about all of them in the CPack link
    in the *Further reading* section at the end of the chapter. Some of them are common
    for all package generators, while some are specific to a few of them. For instance,
    if you plan to use the installers, you could set the following two:'
  prefs: []
  type: TYPE_NORMAL
- en: '`set(CPACK_RESOURCE_FILE_LICENSE "${PROJECT_SOURCE_DIR}/LICENSE")`'
  prefs: []
  type: TYPE_NORMAL
- en: '`set(CPACK_RESOURCE_FILE_README "${PROJECT_SOURCE_DIR}/README.md")`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve set all the interesting variables, it''s time to choose the generators
    for CPack to use. Let''s start with putting some basic ones in `CPACK_GENERATOR`,
    a variable CPack relies on:'
  prefs: []
  type: TYPE_NORMAL
- en: '`list(APPEND CPACK_GENERATOR TGZ ZIP)`'
  prefs: []
  type: TYPE_NORMAL
- en: This will cause CPack to generate those two types of archives based on the installation
    steps we defined earlier in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can select different package generators based on many things, for example,
    the tools available on the machine you''re running on. An example would be to
    create Windows installers when building on Windows and a DEB or RPM package if
    building on Linux with the appropriate tools installed. For instance, if you''re
    running Linux, you could check whether `dpkg` is installed and if so, create DEB
    packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We used the `CPACK_DEBIAN_PACKAGE_DEPENDS` variable to make the DEB package
    require the C++ REST SDK to be installed first.
  prefs: []
  type: TYPE_NORMAL
- en: 'For RPM packages, you could manually check for `rpmbuild`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Nifty, right?
  prefs: []
  type: TYPE_NORMAL
- en: These generators offer a plethora of other useful variables, so feel free to
    look at CMake's documentation if you need anything more than those basic needs
    described here.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last thing when it comes variables – you can also use them to avoid accidentally
    packaging undesired files. This can be done by using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`set(CPACK_SOURCE_IGNORE_FILES /.git /dist /.*build.* /\\\\.DS_Store)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have all that in place, we can include CPack itself from our CMake
    lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '`include(CPack)`'
  prefs: []
  type: TYPE_NORMAL
- en: Remember to always do this as the last step, as CMake won't propagate any variables
    you used later to CPack.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run it, directly invoke either just `cpack` or the longer form that will
    also check whether anything needs rebuilding first: `cmake --build . --target
    package`. You can easily override the generators if you just need to rebuild one
    type of package using the `-G` flag, for example, `-G DEB` to build just the DEB
    package, `-G WIX -C Release` to pack a release MSI executable, or `-G DragNDrop`
    to obtain a DMG installer.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's now discuss a more barbaric way of building packages.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging using Conan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already showed how to install our dependencies using Conan. Now, let's dive
    into creating our own Conan packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new top-level directory in our project, simply named `conan`,
    where we will store the files needed for packaging using this tool: a script for
    building our package and an environment to test it.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the conanfile.py script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most important file required for all Conan packages is `conanfile.py`.
    In our case, we''ll want to fill in some of its details using CMake variables,
    so let''s create a `conanfile.py.in` file instead. We''ll use it to create the
    former file by adding the following to our `CMakeLists.txt` files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Our file will begin with some boring Python imports, such as those required
    by Conan for CMake projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to create a class that defines our package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we start with a bunch of generic variables, taking the project version
    from our CMake code. Usually, the description will be a multi-line string. The
    topics are useful for finding our library on sites such as JFrog''s Artifactory
    and can tell the readers what our package is about. Let''s now go through other
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '`homepage` should point to, well, the home page of your project: where the
    docs, tutorials, FAQs, and similar stuff are placed. The `url` one, on the other
    hand, is where the package repository is placed. Many open source libraries have
    their code in one repo and the packaging code in another. A common case is when
    the package is being built by the central Conan package server. In this case,
    `url` should point to `https://github.com/conan-io/conan-center-index`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Going forward, we can now specify how our package is being built:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '`settings` will determine whether the package needs to be built or an already-built
    version can be downloaded.'
  prefs: []
  type: TYPE_NORMAL
- en: '`options` and the `default_options` values can be whatever you like. `shared`
    and `fPIC` are the two that most packages provide, so let''s follow this convention.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have defined our variables, let''s start writing methods that Conan
    will use to package our software. First, we specify our libraries that consumers
    of our package should link against:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The `self.cpp_info` object allows setting much more than that, but this is the
    bare minimum. Feel free to take a look at other properties in Conan's documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s specify what other packages requires:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we grab the C++ REST SDK directly from Conan instead of specifying
    what packages the OS''s package manager should depend on. Now, let''s specify
    how (and where) CMake should generate our build system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case, we simply point it to the source directory. Once the build system
    is configured, we will need to actually build our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Conan also supports non-CMake-based build systems. After building our package,
    it''s packaging time, which requires us to provide yet another method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how we''re using the same `_configure_cmake()` function to both build
    and package our project. Aside from installing binaries, we also specify where
    the licenses should be deployed. Finally, let''s tell Conan what it should copy
    when installing our package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code specifies where to unpack the license files, as well as libraries,
    and executables when installing the library.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to build a Conan package, let's also see how to test whether
    it works as desired.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our Conan package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once Conan builds our package, it should test whether it was properly built.
    In order to do so, let's start by creating a `test_package` subdirectory in our
    `conan` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'It will also contain a `conanfile.py` script, but this time a shorter one.
    It should start as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing too fancy here. Now, we should provide the logic to build the test
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll write our `CMakeLists.txt` file in a sec. But first, let''s write two
    more things: the `imports` method and the `test` method. The `imports` method
    can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we have the heart of our package testing logic – the `test` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: We want to run it only if we're building for our native architecture. Otherwise,
    we would most probably be unable to run the compiled executable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now define our `CMakeLists.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Simple as that. We link to all the Conan libraries provided (in our case, just
    our Customer library).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s write our `example.cpp` file with just enough logic to check
    whether the package was successfully created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Before we start running all this, there are a few small changes that we need
    to make in our main tree of CMake lists. Let's now see how to export Conan targets
    from our CMake file properly.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Conan packaging code to our CMakeLists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Remember that installation logic we wrote in the *Reusing quality code* section?
    If you''re relying on Conan for packaging, you probably don''t need to run the
    bare CMake exporting and installation logic. Assuming you want to only export
    and install if Conan is not used, you need to modify the section of your `CMakeLists`
    described in the *Installing* subsection previously to look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Adding an if statement and a generator expression is a reasonable price for
    having clean packages, and that's all we needed to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last thing to make our lives easier – a target that we could **build**
    in order to create the Conan package. We can define it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Now, when we run `cmake --build . --target conan` (or `ninja conan` if we're
    using that generator and want a short invocation), CMake will copy our `test_package`
    directory to the `build` folder, build our Conan package, and test it using the
    copied files.
  prefs: []
  type: TYPE_NORMAL
- en: All done!
  prefs: []
  type: TYPE_NORMAL
- en: 'One last remark: what we described here is just the tip of the iceberg when
    it comes to creating Conan packages. For more information, please refer to Conan''s
    documentation. You can find a link in the *Further reading* section.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you've learned a lot about building and packaging your code.
    You're now able to write faster-building template code, know how to choose the
    tools to compile your code faster (you'll learn more about tooling in the next
    chapter), and know when to use forward declarations instead of `#include` directives.
  prefs: []
  type: TYPE_NORMAL
- en: Aside from that, you can now define your build targets and test suites using
    Modern CMake, manage external dependencies using find modules and `FetchContent`,
    create packages and installers in various formats, and last but not least, use
    Conan to install your dependencies and create your own artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how to write code that would be easy to
    test. Continuous integration and continuous deployment are useful only if you
    have good test coverage. Continuous deployment without comprehensive testing will
    allow you to introduce new bugs to production much quicker. This is not our goal
    when we design software architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What's the difference between installing and exporting your targets in CMake?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you make your template code compile faster?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you use multiple compilers with Conan?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What do you do if you'd like to compile your Conan dependencies with the pre-C++11
    GCC ABI?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to ensure we force a specific C++ standard in CMake?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you build documentation in CMake and ship it along with your RPM package?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'List of compiler books on GCC''s wiki: [https://gcc.gnu.org/wiki/ListOfCompilerBooks](https://gcc.gnu.org/wiki/ListOfCompilerBooks)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Type Based Template Metaprogramming is Not Dead*, a lecture by Odin Holmes,
    C++Now 2017: [https://www.youtube.com/watch?v=EtU4RDCCsiU](https://www.youtube.com/watch?v=EtU4RDCCsiU)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Modern CMake online book: [https://cliutils.gitlab.io/modern-cmake](https://cliutils.gitlab.io/modern-cmake)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Conan documentation: [https://docs.conan.io/en/latest/](https://docs.conan.io/en/latest/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CMake documentation on creating find scripts: [https://cmake.org/cmake/help/v3.17/manual/cmake-developer.7.html?highlight=find#a-sample-find-module](https://cmake.org/cmake/help/v3.17/manual/cmake-developer.7.html?highlight=find#a-sample-find-module)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
