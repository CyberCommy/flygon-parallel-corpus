- en: '*Chapter 3*: Working with Scenes and GameObjects'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：使用场景和游戏对象'
- en: Welcome to the third chapter of the book—here is where the hard work starts!
    In this chapter, we will develop some base knowledge of Unity in order to edit
    a project. We will see how to use several Unity Editor windows to manipulate our
    first scene and its objects. Also, we will learn how an object or Game Object
    is created and composed and how to manage complex scenes with multiple objects
    using Hierarchies and Prefabs. Finally, we will review how we can properly save
    all our work to continue working on it later.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到本书的第三章—这里是艰苦工作开始的地方！在本章中，我们将开发一些关于Unity的基础知识，以便编辑项目。我们将看到如何使用几个Unity编辑器窗口来操作我们的第一个场景及其对象。此外，我们将学习如何创建和组合对象或游戏对象，以及如何使用层次结构和预制件来管理具有多个对象的复杂场景。最后，我们将回顾如何正确保存所有工作，以便以后继续工作。
- en: 'Specifically, we will examine the following concepts in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，在本章中，我们将研究以下概念：
- en: Manipulating scenes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作场景
- en: GameObjects and components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏对象和组件
- en: Object hierarchies
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象层次结构
- en: Prefabs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预制件
- en: Saving scenes and projects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存场景和项目
- en: Manipulating scenes
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作场景
- en: 'A **scene** is one of the several kinds of files (also known as **Assets**)
    in our project. A scene can mean different things according to the type of project
    or the way a company is used to working, but the most common use case is to separate
    your game into whole sections, the most common ones being the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**是我们项目中几种文件（也称为**资源**）之一。根据项目类型或公司习惯的工作方式，场景可能意味着不同的事情，但最常见的用例是将游戏分成整个部分，最常见的部分包括以下内容：'
- en: Main Menu
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主菜单
- en: Level 1, Level 2, Level 3, …, Level N
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第1关，第2关，第3关，…，第N关
- en: Victory Screen, Lose Screen
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 胜利画面，失败画面
- en: Splash Screen, Loading Screen
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动画面，加载画面
- en: 'In this section, we will cover the following concepts related to scenes:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖与场景相关的以下概念：
- en: The purpose of a scene
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 场景的目的
- en: The Scene View
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 场景视图
- en: Our first GameObject
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的第一个游戏对象
- en: Navigating the Scene View
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航场景视图
- en: Manipulating GameObjects
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作游戏对象
- en: The purpose of a scene
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景的目的
- en: The idea of separating your game into scenes is that you will process and load
    just the data needed for the scene; so, if you are in the Main Menu you will have
    only the textures, music, and objects that that particular scene needs—there's
    no need to have the Level 10 Boss loaded in **random-access memory** (**RAM**)
    if you don't need it right now. That's why loading screens exist, just to fill
    the time between unloading the Assets needed in one scene and loading the ones
    needed in another. Maybe you are thinking that open-world games such as **Grand
    Theft Auto** (**GTA**) don't have loading screens while you roam around in the
    world, but they are actually loading and unloading chunks of the world in the
    background as you move, and those chunks are different scenes that are designed
    to be connected to each other.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 将游戏分成场景的想法是，您将处理并加载场景所需的数据；因此，如果您在主菜单中，您将只有该特定场景需要的纹理、音乐和对象—如果您现在不需要，就没有必要在**随机存取内存**（**RAM**）中加载第10关的Boss。这就是加载画面存在的原因，只是为了填补在卸载一个场景中需要的资源和加载另一个场景中需要的资源之间的时间。也许您会认为像**侠盗猎车手**（**GTA**）这样的开放世界游戏在您漫游世界时没有加载画面，但实际上，它们在您移动时实际上在后台加载和卸载世界的块，而这些块是设计为彼此连接的不同场景。
- en: The difference between the Main Menu and a regular level scene are the objects
    (also known as GameObjects) they have. In a menu, you will find objects such as
    a background, music, buttons, and logos, and in a level you will have the player,
    enemies, platforms, health boxes, and so on. So, it is up to you and the GameObjects
    you put in the scene to decide what that scene means for your game.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 主菜单和常规关卡场景之间的区别在于它们拥有的对象（也称为游戏对象）。在菜单中，您会找到背景、音乐、按钮和标志等对象，在关卡中，您将拥有玩家、敌人、平台、生命值盒等。因此，取决于您和放置在场景中的游戏对象来决定该场景对于您的游戏意味着什么。
- en: But how can we create a scene? Let's start with the Scene View.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们如何创建一个场景呢？让我们从场景视图开始。
- en: The Scene View
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景视图
- en: 'When you open a Unity project, you will see the Unity Editor. It will be composed
    of several windows or **panels**, each one helping you to change different aspects
    of your game. In this chapter, we will be looking at the windows that help you
    author scenes. The Unity Editor is shown in the following screenshot:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当您打开一个Unity项目时，您将看到Unity编辑器。它将由几个窗口或**面板**组成，每个面板都可以帮助您更改游戏的不同方面。在本章中，我们将看看帮助您编写场景的窗口。Unity编辑器如下截图所示：
- en: '![Figure 3.1 – Unity Editor'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1 – Unity编辑器'
- en: '](img/Figure_3.01_B14199.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.01_B14199.jpg)'
- en: Figure 3.1 – Unity Editor
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – Unity编辑器
- en: 'If you have ever programmed any kind of application before, you are probably
    used to having a starting function, such as **Main**, where you start writing
    code to create several objects needed for your app, and if we are talking about
    games, you probably create all the objects for the scene here. The problem with
    this approach is that in order to ensure all objects are created properly, you
    will need to run the program to see the results, and if something is misplaced
    you will need to manually change the coordinates of the object, which is a slow
    and painful process. Luckily, in Unity, we have the **Scene** View, an example
    of which is shown in the following screenshot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以前曾经编写过任何类型的应用程序，您可能习惯于拥有一个起始函数，比如**Main**，在那里您开始编写代码来创建应用程序所需的多个对象，如果我们谈论游戏，您可能会在这里创建场景中的所有对象。这种方法的问题在于，为了确保所有对象都被正确创建，您需要运行程序以查看结果，如果有什么错位，您将需要手动更改对象的坐标，这是一个缓慢而痛苦的过程。幸运的是，在Unity中，我们有**场景**视图，以下是其示例截图：
- en: '![Figure 3.2 – Scene View'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.2 – 场景视图'
- en: '](img/Figure_3.02_B14199.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.02_B14199.jpg)'
- en: Figure 3.2 – Scene View
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 场景视图
- en: This window is an implementation of the classic **WYSIWYG (What You See Is What
    You Get)** concept. Here, you can create objects and place them all over the scene,
    all through a scene previsualization where you can see how the scene will look
    when you hit **Play**. But before learning how to use this scene, we need to have
    an object in the scene, so let's create our first object.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个窗口是经典**WYSIWYG（所见即所得）**概念的实现。在这里，您可以创建对象并将它们放置在整个场景中，通过场景预览，您可以看到当您点击**播放**时场景将会呈现什么样子。但在学习如何使用这个场景之前，我们需要在场景中有一个对象，所以让我们创建我们的第一个对象。
- en: Our first GameObject
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的第一个游戏对象
- en: 'The Unity **Universal Render Pipeline** (**URP**) template comes with a construction
    site test scene, but let''s create our own empty scene to start exploring this
    new concept. To do that, you can simply use the **File** | **New Scene** menu
    options to create an empty new scene, as illustrated in the following screenshot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Unity **通用渲染管线**（**URP**）模板带有一个建筑工地测试场景，但让我们创建一个空的场景来开始探索这个新概念。为此，您可以简单地使用**文件**
    | **新建场景**菜单选项来创建一个空的新场景，如下截图所示：
- en: '![Figure 3.3 – Creating a new scene'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.3 – 创建一个新场景'
- en: '](img/Figure_3.03_B14199.png)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.03_B14199.png)'
- en: Figure 3.3 – Creating a new scene
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 创建一个新场景
- en: 'We will learn several ways of creating GameObjects throughout the book, but
    now, let''s start using some basic templates Unity provides us. In order to create
    them, we will need to open the **GameObject** menu at the top of the Unity window,
    and it will show us several template categories, such as **3D Object**, **2D Object**,
    **Effects**, and so on, as illustrated in the following screenshot:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将学习创建游戏对象的几种方法，但现在，让我们开始使用Unity提供的一些基本模板。为了创建它们，我们需要在Unity窗口顶部打开**GameObject**菜单，它将显示我们几个模板类别，如**3D对象**，**2D对象**，**特效**等，如下截图所示：
- en: '![Figure 3.4 – Creating a cube'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.4 – 创建一个立方体'
- en: '](img/Figure_3.4_B14199.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.4_B14199.jpg)'
- en: Figure 3.4 – Creating a cube
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – 创建一个立方体
- en: Under the **3D Object** category, we will see several 3D primitives such as
    **Cube**, **Sphere**, **Cylinder**, and so on, and while using them is not as
    exciting as using beautiful downloaded 3D models, remember that we are prototyping
    our level, also known as gray-boxing. This means that we will use lots of prototyping
    primitive shapes to model our level so that we can quickly test it and see whether
    our idea is good enough to start the complex work of converting it to a final
    version.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在**3D对象**类别下，我们将看到几个3D基本形状，如**立方体**，**球体**，**圆柱体**等，虽然使用它们不如使用精美的下载的3D模型令人兴奋，但请记住，我们正在原型化我们的关卡，也就是灰盒模型。这意味着我们将使用大量的原型形状来模拟我们的关卡，以便我们可以快速测试它，并查看我们的想法是否足够好，可以开始将其转换为最终版本的复杂工作。
- en: I recommend you pick the **Cube** object to start with because it is a versatile
    shape that can represent lots of objects. So, now that we have a scene with an
    object to edit, the first thing we need to learn to do with the scene view is
    to navigate through the scene.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您选择**立方体**对象开始，因为它是一个多功能的形状，可以代表许多对象。因此，现在我们有一个带有要编辑的对象的场景，我们需要学习使用场景视图的第一件事就是浏览场景。
- en: Navigating the Scene View
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览场景视图
- en: 'In order to manipulate a scene, we need to learn how to move through it to
    view the results from different perspectives. There are several ways to navigate
    it, so let''s start with the most common one: the first-person view. This view
    allows you to move through the scene using first-person-shooter-like navigation,
    using the mouse and the *WASD* keys. To navigate like this, you will need to press
    and hold the right mouse button, and while doing so, you can move the mouse to
    rotate the camera and press the *WASD* keys to move it. You can also press *Shift*
    to move faster and press the *Q* and *E* keys to move up and down.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了操作一个场景，我们需要学习如何在其中移动以从不同的角度查看结果。有几种导航方式，让我们从最常见的一种开始：第一人称视角。这个视图允许您使用类似第一人称射击游戏的导航方式在场景中移动，使用鼠标和*WASD*键。要像这样导航，您需要按住鼠标右键，然后在这样做的同时，您可以移动鼠标来旋转相机，并按下*WASD*键来移动它。您还可以按下*Shift*键以加快移动速度，并按下*Q*和*E*键来上下移动。
- en: 'Another common way of moving is to click an object to select it (the selected
    object will have an orange outline), and then press the *F* key to focus it, making
    the Scene View camera immediately move into a position where we to look at that
    object more closely. After that, we can press and hold the left *Alt* key and
    the left mouse button, and start moving the mouse to "orbit" around the object
    and see different angles to check that every part of it is properly placed, as
    demonstrated in the following screenshot:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的移动方式是单击对象以选择它（所选对象将有橙色轮廓），然后按下*F*键将其聚焦，使场景视图相机立即移动到一个位置，我们可以更仔细地查看该对象。之后，我们可以按住左侧*Alt*键和鼠标左键，开始移动鼠标以围绕对象“轨道”，看到不同的角度来检查它的每个部分是否放置正确，如下截图所示：
- en: '![Figure 3.5 – Selecting an object'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.5 – 选择一个对象'
- en: '](img/Figure_3.05_B14199.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.05_B14199.jpg)'
- en: Figure 3.5 – Selecting an object
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – 选择一个对象
- en: Now that we can move freely through the scene, we can start using the Scene
    View to manipulate GameObjects.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以自由地在场景中移动，我们可以开始使用场景视图来操作游戏对象。
- en: Manipulating GameObjects
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作游戏对象
- en: 'Another use of the Scene View is to manipulate the locations of objects. In
    order to do so, we first need to select an object, and then press the *Y* key
    on the keyboard or the sixth button to the right in the top-left corner of the
    Unity Editor, shown in the following screenshot:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 场景视图的另一个用途是操作对象的位置。为了这样做，我们首先需要选择一个对象，然后按键盘上的*Y*键或Unity编辑器左上角的第六个按钮，如下截图所示：
- en: '![Figure 3.6 – Changing the transformation tool'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.6 – 更改变换工具'
- en: '](img/Figure_3.06_B14199.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.06_B14199.jpg)'
- en: Figure 3.6 – Changing the transformation tool
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 – 更改变换工具
- en: 'This will show what is called the **Transform Gizmo** over the selected object,
    which allows us to change the position, rotation, and scale of the object, as
    illustrated in the following screenshot:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Transform Gizmo'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.07_B14199.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.7 – Transform Gizmo
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start translating the object, which is accomplished by dragging the
    red, green, and blue arrows inside the Gizmo´s sphere. While you do this, you
    will see how the object will be moving along the selected axis. An interesting
    concept to explore here is the meaning of the color of those arrows. If you pay
    attention to the top-right area of the Scene View, you will see an axis Gizmo
    that serves as a reminder of those colors'' meaning, as illustrated in the following
    screenshot:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Axis Gizmo'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.08_B14199.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.8 – Axis Gizmo
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Computer graphics use the classic 3D **Cartesian coordinate system** to represent
    objects' locations. The red color is associated with the *x* axis of the object,
    green with the *y* axis, and blue with the *z* axis. But what does each axis mean?
    If you come from another 3D authoring program, this can be different, but in Unity,
    the *z* axis (blue) represents the **Forward Vector**, which means that the arrow
    is pointing along the front of the object; the *x* axis is the **Right Vector**,
    and the *y* axis represents the **Up Vector**. Consider that those axes are **local**,
    meaning that if you rotate the object, they will change the direction they face
    because the orientation of the object changes the way the object is facing. Unity
    can show those axes in **global** coordinates if necessary, but for now, let's
    stick with local.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to be sure that we are working with local coordinates, make sure **Local**
    mode is activated, as shown in the following screenshot:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Switching between pivot and local coordinates'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.9_B14199.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.9 – Switching between pivot and local coordinates
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: If you see **Global** instead of **Local** as the right button, just click it
    and it will change. By the way, try to keep the left button as **Pivot**. If it
    says **Center**, just click it to change it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: I know—we are editing a cube, so there is no clear front or right side, but
    when you work with real 3D models such as cars and characters, they will certainly
    have those sides, and they must be properly aligned with those axes. If by any
    chance in the future you import a car into Unity and the front of the car is pointing
    along the red axis (X), you will need to fix that because our future moving code
    will rely on that convention, but let's keep that for later.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's use this Transform Gizmo to rotate the object using the three colored
    circles around it. If you click and drag, for example, the red circle, you will
    rotate the object along the *x* rotation axis. Here is another interesting tip
    to consider. If you want to rotate the object horizontally, based on the color-coding
    we previously discussed, you will probably pick the *x* axis—the one that is used
    to move horizontally—but, sadly, that's wrong.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'A good way to look at rotation is like the accelerator of a bike: you need
    to take it and roll it. If you rotate the *x* axis like this, you will rotate
    the object up and down. So, in order to rotate horizontally, you would need to
    use the green circle or the *y* axis. The process is illustrated in the following
    screenshot:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Rotating an object'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.10_B14199.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.10 – Rotating an object
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have scaling, which is done through the colored cubes on the outer
    side of the Transform Gizmo sphere. If you click and drag those, you will see
    how our cube is stretched over those axes, allowing you to change the size of
    the object. Also, you will have a gray cube in the center of the gizmo that allows
    you to change the size of the object uniformly along all the axes. The process
    is illustrated in the following screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – Scaling an object'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.11_B14199.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.11 – Scaling an object
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Remember that scaling objects is usually a bad practice in many cases. In the
    final versions of your scene, you will use models with the proper size and scale,
    and they will be designed in a modular way so that you can plug them one next
    to the other. If you scale them, several bad things can happen, such as textures
    being stretched and becoming pixelated, and modules that no longer plug properly.
    There are some exceptions to this rule, such as placing lots of instances of the
    same tree in a forest and changing its scale slightly to simulate variation, and,
    in the case of gray-boxing, it is perfectly fine to take cubes and change the
    scale to create floors, walls, ceilings, columns, and so on, because in the end,
    those cubes will be replaced with real 3D models.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: CHALLENGE
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a room composed of a floor, three regular walls, and a fourth wall with
    a hole for a door (three cubes). In the following screenshot, you can see how
    it should look:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – Room task finished'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.12_B14199.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.12 – Room task finished
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can edit an object's location, let's see how we can edit all its
    other aspects.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: GameObjects and components
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We talked about our project being composed of Assets, and that a Scene (a specific
    type of Asset) is composed of GameObjects; so, how can we create an object? Through
    the composition of **components**.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will cover the following concepts related to components:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Components
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating components
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **component** is one of several pieces a Game Object can be made of; each
    one is in charge of different features of the object. There are several components
    that solve different tasks, such as playing a sound, rendering a mesh, applying
    physics, and so on, and even if Unity has a large number of components, we will
    eventually need to create custom components, sooner or later. In the following
    screenshot, you can see what Unity shows us when we select a Game Object:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – The Inspector panel'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.13_B14199.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.13 – The Inspector panel
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous screenshot, we can see the **Inspector** panel, and if we needed
    to guess what it does, right now we could say it is showing all the properties
    of the selected object and that we can configure them to change the behavior of
    the object, such as the position and rotation, whether it will project shadows
    or not, and so on. That is true, but we are missing a key element: those properties
    don''t belong to the object; they belong to the components of the object. We can
    see some titles in bold before a group of properties, such as **Transform** and
    **Box Collider**, and so on. Those are the components of the object.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: In this case, our object has a **Transform**, a **Mesh Filter**, a **Mesh Renderer**,
    and a **Box Collider** component, so let's review each one of those. **Transform**
    just has location information, such as the position, rotation, and scale of the
    object, and by itself it does nothing—it's just a point in our game—but as we
    add components to the object, that position starts to have more meaning. That's
    because some components will interact with **Transform** and other components,
    each one affecting the other.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: An example of that would be the case of **Mesh Filter** and **Mesh Renderer**,
    both of those being in charge of rendering a 3D model. **Mesh Renderer** will
    render the mesh specified in the **Mesh Filter** in the position specified in
    the Transform component, so **Mesh Renderer** needs to get data from those other
    components and can't work without them. Another example would be the **Box Collider**.
    This represents the physical shape of the object, so when the physics calculates
    collisions between objects, it checks whether that shape is colliding with other
    shapes based on the position specified in the Transform.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: We don't want to explore physics and rendering right now. The takeaway from
    this section is that a GameObject is a collection of components, each component
    adding a specific behavior to our object, and each one interacting with the others
    to accomplish the desired task. To further reinforce this, let's see how we can
    convert a cube into a sphere that falls using physics.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不想探索物理和渲染。本节的要点是GameObject是一组组件，每个组件为我们的对象添加特定的行为，并且每个组件与其他组件互动以完成所需的任务。为了进一步加强这一点，让我们看看如何将一个立方体转换成一个使用物理下落的球体。
- en: Manipulating components
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作组件
- en: The tool to edit an object's components is the **Inspector**. It not only allows
    us to change components' properties, but also lets us add and remove components.
    In this case, we want to convert a cube to a sphere, so we need to change several
    aspects of those components. We can start by changing the visual shape of the
    object, so we need to change the rendered model or **Mesh**. The component that
    specifies the Mesh to be rendered is the **MeshFilter** component. If we look
    at it, we can see a **Mesh** property that says **Cube** and that has a little
    circle with a dot to its right.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑对象组件的工具是**检视器**。它不仅允许我们更改组件的属性，还允许我们添加和移除组件。在这种情况下，我们想要将一个立方体转换成一个球体，因此我们需要改变这些组件的几个方面。我们可以从改变对象的视觉形状开始，因此我们需要改变渲染模型或**网格**。指定要渲染的网格的组件是**MeshFilter**组件。如果我们看一下，我们可以看到一个说**Cube**的**Mesh**属性，右边有一个带点的小圆圈。
- en: Important note
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'If you don''t see any property such as the Mesh we just mentioned, try to click
    the triangle at the left of the component''s name. Doing this will expand and
    collapse all the component''s properties. This is illustrated in the following
    screenshot:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有看到任何像我们刚提到的网格的属性，请尝试点击组件名称左侧的三角形。这样做将展开和折叠所有组件的属性。这在下面的截图中有所说明：
- en: '![Figure 3.14 – Disabling a component'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.14 – 禁用组件'
- en: '](img/Figure_3.14_B14199.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.14_B14199.jpg)'
- en: Figure 3.14 – Disabling a component
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14 – 禁用组件
- en: 'If we click it, the **Select Mesh** window will pop up, allowing us to pick
    several Mesh options; so, in this case, select the **Sphere** component. In the
    future, we will add more 3D models to our project so that the window will have
    more options. The mesh selector is shown in the following screenshot:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击它，**选择网格**窗口将弹出，允许我们选择几个网格选项；因此，在这种情况下，选择**Sphere**组件。在将来，我们将向我们的项目添加更多的3D模型，以便该窗口将有更多的选项。网格选择器显示在下面的截图中：
- en: '![Figure 3.15 – Mesh selector'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.15 – 网格选择器'
- en: '](img/Figure_3.15_B14199.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.15_B14199.jpg)'
- en: Figure 3.15 – Mesh selector
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.15 – 网格选择器
- en: 'Okay—it looks like a sphere, but will it behave like a sphere? Let''s find
    out. In order to do so, we can add a `Rigidbody` in the search box at the top
    of the window. The following screenshot illustrates how to add a component:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，看起来像一个球体，但它会像一个球体一样行为吗？让我们找出来。为了这样做，我们可以在窗口顶部的搜索框中添加一个`Rigidbody`。下面的截图说明了如何添加一个组件：
- en: '![Figure 3.16 – Adding components'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.16 – 添加组件'
- en: '](img/Figure_3.16_B14199.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.16_B14199.jpg)'
- en: Figure 3.16 – Adding components
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.16 – 添加组件
- en: 'If you hit the Play button in the top-middle part of the editor, you can test
    your sphere physics using the **Game** panel. That panel will be automatically
    focused when you hit Play and will show you how the player will see the game.
    One problem that can happen here is that maybe you won''t see anything, and that
    can happen if the game camera is not pointing to where our sphere is located.
    The playback controls are shown in the following screenshot:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击编辑器顶部中间的播放按钮，您可以使用**游戏**面板测试您的球体物理。当您点击播放时，该面板将自动聚焦，并向您展示玩家将如何看到游戏。这里可能出现的一个问题是，也许您看不到任何东西，如果游戏摄像机没有指向我们的球体所在的位置，那就可能会发生这种情况。播放控制显示在下面的截图中：
- en: '![Figure 3.17 – Playback controls'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.17 – 播放控制'
- en: '](img/Figure_3.17_B14199.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.17_B14199.jpg)'
- en: Figure 3.17 – Playback controls
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.17 – 播放控制
- en: 'Here, you can just use the Transform Gizmo to rotate and position your camera
    in such a way that it looks at our sphere. While you are moving, you can check
    the little preview in the bottom-right part of the scene window to check out the
    new camera perspective. Another alternative would be to select the camera in the
    **Hierarchy** and use the shortcut *Ctrl* + *Shift* + *F* (or *command* + *Shift*
    + *F* on a Mac). The camera preview is shown in the following screenshot:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以使用变换图标来旋转和定位摄像机，使其以某种方式看向我们的球体。在移动时，您可以在场景窗口的右下部分检查小预览，以查看新的摄像机视角。另一种选择是在**层次结构**中选择摄像机，然后使用快捷键*Ctrl*
    + *Shift* + *F*（或Mac上的*command* + *Shift* + *F*）。摄像机预览显示在下面的截图中：
- en: '![Figure 3.18 – Camera preview'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.18 – 摄像机预览'
- en: '](img/Figure_3.18_B14199.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.18_B14199.jpg)'
- en: Figure 3.18 – Camera preview
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.18 – 摄像机预览
- en: 'Now, to test whether Physics collisions are executing properly, let''s create
    a cube, scale it until it has the shape of a ramp, and put that ramp below our
    sphere, as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了测试物理碰撞是否执行正常，让我们创建一个立方体，将其缩放直到它呈坡道形状，并将该坡道放在我们的球体下方，如下所示：
- en: '![Figure 3.19 – Ball and ramp objects'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.19 – 球和坡道对象'
- en: '](img/Figure_3.19_B14199.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.19_B14199.jpg)'
- en: Figure 3.19 – Ball and ramp objects
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.19 – 球和坡道对象
- en: 'If you hit Play now, you will see the sphere colliding with our ramp, but in
    a strange way. It looks like it''s bouncing, but that''s not the case. If you
    expand the **Box Collider** component of our sphere, you will see that even if
    our object looks like a sphere, the green box gizmo is showing us that our sphere
    is actually a box in the Physics world, as illustrated in the following screenshot:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在点击播放，您将看到球体与我们的坡道发生碰撞，但方式很奇怪。看起来像是在弹跳，但实际并非如此。如果您展开球体的**Box Collider**组件，您将看到即使我们的物体看起来像一个球体，绿色的框图标显示我们的球体实际上是一个盒子在物理世界中，如下面的截图所示：
- en: '![Figure 3.20 – Object with sphere graphic and box collider'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.20 – 具有球体图形和盒碰撞器的对象'
- en: '](img/Figure_3.20_B14199.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.20_B14199.jpg)'
- en: Figure 3.20 – Object with sphere graphic and box collider
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.20 - 具有球形图形和盒碰撞器的对象
- en: Nowadays, video cards can handle rendering highly detailed models (with high
    polygon counts), but the Physics system is executed in the **central processing
    unit** (**CPU**) and it needs to do complex calculations in order to detect collisions.
    To get decent performance in our game (at least 30 **frames per second** (**FPS**))
    the Physics system works using simplified collision shapes that may differ from
    the actual shape the player sees on the screen. That's why we have **Mesh Filter**
    and the different types of Collider components separated—one handles visual shape
    and the other the physics shape.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，视频卡可以处理渲染高度详细的模型（具有高多边形数量），但是物理系统是在**中央处理单元**（**CPU**）中执行的，它需要进行复杂的计算以侦测碰撞。为了在我们的游戏中获得良好的性能（至少30**帧每秒**（**FPS**）），物理系统使用简化的碰撞形状来工作，这些形状可能与玩家在屏幕上看到的实际形状不同。这就是为什么我们有**Mesh
    Filter**和不同类型的碰撞器组件分开——一个处理视觉形状，另一个处理物理形状。
- en: 'Again, the idea of this section is not to deep dive into those Unity systems,
    so let''s just move on for now. How can we solve this? Simple: by modifying our
    components! In this case, **BoxCollider** can just represent a box shape, unlike
    **MeshFilter**, which supports any shape. So, first, we need to remove it by right-clicking
    the component''s title and selecting the **Remove Component** option, as illustrated
    in the following screenshot:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，本节的目的不是深入研究这些Unity系统，所以让我们继续前进。我们如何解决这个问题呢？简单：通过修改我们的组件！在这种情况下，**BoxCollider**可以表示一个盒子形状，不像**MeshFilter**，它支持任何形状。因此，首先我们需要通过右键单击组件的标题并选择**移除组件**选项来移除它，如下面的屏幕截图所示：
- en: '![Figure 3.21 – Removing components'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.21 - 移除组件'
- en: '](img/Figure_3.21_B14199.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.21_B14199.jpg)'
- en: Figure 3.21 – Removing components
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.21 - 移除组件
- en: 'Now, we can again use the **Add Component** menu to select a **Physics** component,
    this time selecting the **Sphere Collider** component. If you look at the Physics
    components, you will see other types of colliders that can be used to represent
    other shapes, but we will look at them later in [*Chapter 15*](B14199_15_Final_SK_ePub.xhtml#_idTextAnchor194)*,
    Physics Collisions and Health System*. The **Sphere Collider** component can be
    seen in the following screenshot:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以再次使用**添加组件**菜单来选择一个**物理**组件，这次选择**球体碰撞器**组件。如果您查看物理组件，您将看到其他类型的碰撞器，可以用来表示其他形状，但我们将在[*第15章*](B14199_15_Final_SK_ePub.xhtml#_idTextAnchor194)*，物理碰撞和健康系统*中进行讨论。**球体碰撞器**组件可以在下面的屏幕截图中看到：
- en: '![Figure 3.22 – Adding a Sphere Collider component'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.22 - 添加一个球体碰撞器组件'
- en: '](img/Figure_3.22_B14199.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.22_B14199.jpg)'
- en: Figure 3.22 – Adding a Sphere Collider component
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.22 - 添加一个球体碰撞器组件
- en: 'So, if you hit Play now, you will see that our sphere not only looks like a
    sphere, but also behaves as one. Remember: the main idea of this section of the
    book is understanding that in Unity you can create whatever object you want just
    by adding, removing, and modifying components, and we will be doing a lot of this
    throughout the book.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您现在点击播放，您将看到我们的球体不仅外观像一个球体，而且行为也像一个球体。记住：本书本节的主要思想是理解在Unity中，您可以通过添加、移除和修改组件来创建任何您想要的对象，我们将在整本书中大量使用这种方法。
- en: Now, components are not the only thing needed in order to create objects. Complex
    objects may be composed of several sub-objects, so let's see how that works.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，组件不是创建对象所需的唯一内容。复杂的对象可能由多个子对象组成，因此让我们看看它是如何工作的。
- en: Object hierarchies
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象层次结构
- en: Some complex objects may need to be separated in sub-objects, each one with
    its own components. Those sub-objects need to be somehow attached to the main
    object and work together to create the necessary object behavior.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一些复杂的对象可能需要分成子对象，每个子对象都有自己的组件。这些子对象需要以某种方式附加到主对象，并共同工作以创建必要的对象行为。
- en: 'In this section, we will cover the following concepts related to components:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖与组件相关的以下概念：
- en: Parenting of objects
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的父子关系
- en: Possible uses
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能的用途
- en: Parenting of objects
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象的父子关系
- en: '**Parenting** consists of making an object the child of another, meaning that
    those objects will be related to each other. One type of relationship that happens
    is a **Transform relationship**, meaning that a child object will be affected
    by the parent''s Transform. In simple terms, the child object will follow the
    parent, as if it is attached to it. In an example, imagine a player with a hat
    on their head. The hat can be a child of the player''s head, making the hat follow
    the head while they are attached.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**父子关系**包括使一个对象成为另一个对象的子对象，这意味着这些对象将彼此相关联。发生的一种关系类型是**变换关系**，意味着子对象将受到父对象变换的影响。简单来说，子对象将跟随父对象，就像它附加在上面一样。举个例子，想象一个戴着帽子的玩家。帽子可以是玩家头部的子对象，使帽子在附着时跟随头部移动。'
- en: 'In order to try this, let''s create a capsule that represents an enemy and
    a cube that represents the weapon of the enemy. Remember that in order to do,
    so you can use the **GameObject** | **3D Object** | **Capsule** and **Box** options.
    An example capsule can be seen in the following screenshot:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试这个，让我们创建一个代表敌人的胶囊体和一个代表敌人武器的立方体。请记住，为了这样做，您可以使用**GameObject** | **3D Object**
    | **Capsule**和**Box**选项。一个示例胶囊体可以在下面的屏幕截图中看到：
- en: '![Figure 3.23 – A capsule representing a human and box representing a weapon'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.23 - 代表人类的胶囊体和代表武器的盒子'
- en: '](img/Figure_3.23_B14199.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.23_B14199.jpg)'
- en: Figure 3.23 – A capsule representing a human and box representing a weapon
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.23 - 代表人类的胶囊体和代表武器的盒子
- en: 'If you move the enemy object (the capsule), the weapon (the box) will keep
    its position, not following our enemy. So, in order to prevent that, we can simply
    drag the weapon to the enemy object in the **Hierarchy** window, as illustrated
    in the following screenshot:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您移动敌人对象（胶囊体），武器（盒子）将保持其位置，而不会跟随我们的敌人。因此，为了防止这种情况发生，我们可以简单地将武器拖到**层次结构**窗口中的敌人对象上，如下面的屏幕截图所示：
- en: '![Figure 3.24 – Parenting the cube weapon to the capsule character'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.24 - 将立方体武器作为胶囊角色的父对象'
- en: '](img/Figure_3.24_B14199.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.24_B14199.jpg)'
- en: Figure 3.24 – Parenting the cube weapon to the capsule character
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.24 - 将立方体武器作为胶囊角色的父对象
- en: Now, if you move the enemy, you will see the gun moving, rotating, and being
    scaled along with it. So, basically, the gun transform also has the effects of
    the enemy Transform component.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你移动敌人，你会看到枪也随之移动、旋转和缩放。所以，基本上，枪的变换也受到敌人变换组件的影响。
- en: Now that we have done some basic parenting, let's explore other possible uses.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经做了一些基本的父子关系，让我们继续探索其他可能的用途。
- en: Possible uses
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可能的用途
- en: There are some other uses of parenting aside from creating complex objects.
    Another common usage for it is to organize the project Hierarchy. Right now, our
    scene is simple, but in time it will grow, so keeping track of all the objects
    will become difficult. So, to prevent this, we can create empty GameObjects (in
    **GameObject** | **Create Empty**) to act as containers, putting objects into
    them just to organize our scene. Try to use this with caution, because this has
    a performance cost if you abuse it. Generally, having one or two levels of parenting
    when organizing a scene is fine, but more than that can have a performance hit.
    Consider that you can—and will—have deeper parenting for the creation of complex
    objects; the proposed limit is just for scene organization.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建复杂对象之外，父子关系还有一些其他常见的用途。其中一个常见的用途是组织项目的层次结构。现在，我们的场景很简单，但随着时间的推移，它会变得更加复杂，因此跟踪所有对象将变得困难。为了防止这种情况发生，我们可以创建空的游戏对象（在**GameObject**
    | **Create Empty**中），充当容器，将对象放入其中，以便组织我们的场景。请谨慎使用这个功能，因为如果滥用，会有性能成本。通常情况下，在组织场景时，有一到两级的父子关系是可以接受的，但超过这个数量可能会影响性能。请考虑，你可以并且将会在创建复杂对象时有更深层次的父子关系；所提出的限制只是用于场景组织。
- en: 'To keep improving on our previous example, duplicate the enemy a couple of
    times all around the scene, create an empty Game Object called **Enemies**, and
    drag all the enemies into it so that it will act as a container. This is illustrated
    in the following screenshot:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了不断改进我们之前的示例，在整个场景中复制敌人几次，创建一个名为**敌人**的空游戏对象，并将所有敌人拖放到其中，使其充当容器。如下截图所示：
- en: '![Figure 3.25 – Grouping enemies in a parent object'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.25 - 将敌人分组在父对象中'
- en: '](img/Figure_3.25_B14199.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.25_B14199.jpg)'
- en: Figure 3.25 – Grouping enemies in a parent object
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.25 - 将敌人分组在父对象中
- en: Another common usage of parenting is to change the **pivot** or center of an
    object. Right now, if we try to rotate our gun with the Transform Gizmo, it will
    rotate around its center because the creator of that cube decided to put the center
    there. Normally, that's okay, but let's consider the case where we need to make
    the weapon aim at the point where our enemy is looking. In this case, we need
    to rotate the weapon around the weapon handle; so, in the case of this "box" weapon,
    it would be the closest end to the enemy. The problem here is that we cannot change
    the center of an object, so one solution would be to create another "weapon" 3D
    model or mesh with another center, which will lead to lots of duplicated versions
    of the weapon if we consider other possible gameplay requirements such as a rotating
    weapon pickup. We can fix this easily using parenting.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 父子关系的另一个常见用途是改变对象的**枢轴**或中心。现在，如果我们尝试用变换控件旋转我们的枪，它会围绕它的中心旋转，因为立方体的创建者决定将中心放在那里。通常情况下，这是可以接受的，但让我们考虑这样一种情况，即我们需要让武器瞄准敌人所看的点。在这种情况下，我们需要围绕武器手柄旋转武器；所以，在这个"盒子"武器的情况下，它将是最接近敌人的一端。问题在于我们无法改变对象的中心，因此一个解决方案是创建另一个具有不同中心的"武器"3D模型或网格，这将导致大量重复的武器版本，如果我们考虑到其他可能的游戏需求，比如旋转武器拾取物品。我们可以很容易地使用父子关系来解决这个问题。
- en: 'The idea is to create an empty GameObject and locate it where we want the new
    pivot of our object to be. After that, we can simply drag our weapon inside this
    empty GameObject, and, from now on, consider the empty object as the actual weapon.
    If you rotate or scale this weapon container, you will see that the weapon mesh
    will apply those transformations around this container, so we can say the pivot
    of the weapon has changed (actually, it hasn''t, but our container simulates the
    change). The process is illustrated in the following screenshot:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是创建一个空的游戏对象，并将其放在我们希望对象的新枢轴的位置。之后，我们可以简单地将我们的武器拖放到这个空的游戏对象中，并且从现在开始，将空对象视为实际的武器。如果你旋转或缩放这个武器容器，你会发现武器网格会围绕这个容器应用这些变换，所以我们可以说武器的枢轴已经改变了（实际上并没有，但我们的容器模拟了这种变化）。这个过程如下截图所示：
- en: '![Figure 3.26 – Changing the weapon pivot'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.26 - 改变武器的枢轴'
- en: '](img/Figure_3.26_B14199.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.26_B14199.jpg)'
- en: Figure 3.26 – Changing the weapon pivot
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.26 - 改变武器的枢轴
- en: Now, let's continue seeing different ways of managing GameObjects, using Prefabs
    this time.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续看看不同的管理游戏对象的方法，这次使用预制体。
- en: Prefabs
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预制体
- en: In the previous example, we created lots of copies of our enemy around the scene,
    but in doing so, we have created a new problem. Let's imagine we need to change
    our enemy and add a **Rigidbody** component to it, but because we have several
    copies of the same object, we need to take them one by one and add the same component
    to all of them. Maybe later, we will need to change the mass of each enemy, so
    again, we need to go over each one of the enemies and make the change, and here
    we can start to see a pattern.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们在场景中创建了许多敌人的副本，但在这样做的过程中，我们创建了一个新问题。让我们想象一下，我们需要改变我们的敌人并给它添加一个**Rigidbody**组件，但因为我们有几个相同对象的副本，我们需要逐个将它们添加相同的组件。也许以后，我们需要改变每个敌人的质量，所以再一次，我们需要逐个地去改变每一个敌人，这里我们可以开始看到一个模式。
- en: One solution could be to select all the enemies using the *Ctrl* key (*option*
    on a Mac) and modify all of them at once, but that solution won't be of any use
    if we have enemy copies in other scenes. So, here is where Prefabs come in.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will cover the following concepts related to Prefabs:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Creating Prefabs
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prefab-instance relationship
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prefab variants
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Prefabs
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**A Prefab** is a Unity tool that allows us to convert custom-made objects,
    such as our enemy, into an Asset that defines how they can be created. We can
    use them to create new copies of a custom object easily, without needing to create
    its components and sub-objects all over again.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to create a Prefab, we can simply drag our custom object from the
    **Hierarchy** window to the **Project** window, and after doing that you will
    see a new Asset in your project files. The **Project** window is where you can
    navigate and explore all your project files; so, in this case, our Prefab is the
    first Asset we ever created. Now, you can simply drag the Prefab from the **Project**
    window into the Scene to easily create new Prefab copies, as illustrated in the
    following screenshot:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.27 – Creating a Prefab'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.27_B14199.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.27 – Creating a Prefab
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have a little problem here. If you pay attention to the **Hierarchy**
    window, you will see the original Prefab objects and all the new copies with its
    names in blue, while the enemies created before the Prefab will have its names
    in black. The blue in a name means that the object is an **instance** of a Prefab,
    meaning that the object was created based on a Prefab. We can select those blue
    named objects and click the **Select** button in the **Inspector** to select the
    original Prefab that created that object. This is illustrated in the following
    screenshot:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.28 – Detecting Prefabs in the hierarchy'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.28_B14199.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.28 – Detecting Prefabs in the hierarchy
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: So, the problem here is that the previous copies of the Prefab are not instances
    of the original Prefab, and sadly there's no way to make them be connected to
    the Prefab. So, in order to make that happen, we need to simply destroy the old
    copies and replace them with copies created with the Prefab. At first, not having
    all copies as instances doesn't seem to be a problem, but it will be in the next
    section of this chapter, where we will explore the relationship between the Prefabs
    and their instances.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Prefab-instance relationship
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An instance of a Prefab has a binding to the Prefab that helps to revert and
    apply changes easily between them. If you take a Prefab and make some modifications
    to it, those changes will be automatically applied to all instances across all
    the scenes in the project, so we can easily create a first version of the Prefab,
    use it all around the project, and then experiment with changes.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'To practice this, let''s say we want to add a **Rigidbody** component to the
    enemies so that they can fall. In order to do so, we can simply double-click the
    Prefab file and we will enter Prefab Edit Mode, where we can edit the Prefab isolated
    from the rest of the scene. Here, we can simply take the Prefab root object and
    add the **Rigidbody** component to it. After that, we can simply click on the
    **Scenes** button in the top-left part of the **Scene** window to get back to
    the scene we were editing, and now, we can see that all the Prefab instances of
    the enemy have a **Rigidbody** component, as illustrated in the following screenshot:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.29 – Prefab Edit Mode'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.29_B14199.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.29 – Prefab Edit Mode
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, what happens if we change a Prefab instance instead? Let''s say we want
    one specific enemy to fly, so they won''t suffer the effect of gravity. We can
    do that by simply selecting the specific Prefab and unchecking the **Use Gravity**
    checkbox in the **Rigidbody** component. After doing that, if we play the game,
    we will see that only that specific instance will float. That''s because changes
    of an instance of a Prefab became an **override**, and we can see that clearly
    if you see how the **Use** **Gravity** property of that instance becomes bold
    in the **Inspector**. Let''s take another object and change its **Scale** property
    to make it bigger. Again, we will see how the **Scale** property becomes bold,
    and with a little bar at its left. The **Use Gravity** checkbox can be seen in
    the following screenshot:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.30 – Use Gravity being highlighted as an override'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.30_B14199.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.30 – Use Gravity being highlighted as an override
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'The overrides have precedence over the Prefab, so if we change the scale of
    the original Prefab, the one that has a scale override won''t change, keeping
    its own version of the scale, as illustrated in the following screenshot:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.31 – One Prefab instance with an scale override'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.31_B14199.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.31 – One Prefab instance with an scale override
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily locate all overrides of an instance using the **Overrides** dropdown
    in the **Inspector**, locating all the changes our object has. It not only allows
    us to see all the overrides, but also reverts any override we don''t want and
    applies the ones we want. Let''s say we regretted the lack of gravity of that
    specific Prefab—no problem! We can just locate the override and revert it. The
    process is illustrated in the following screenshot:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.32 – Reverting a single override'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.32_B14199.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.32 – Reverting a single override
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, let''s imagine that we really liked the new scale of that instance, so
    we want all instances to have that scale—great! We can simply hit the **Apply**
    button, select the specific change, and all instances will have that scale (except
    the ones with an override), as illustrated in the following screenshot:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.33 – The Apply button'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.33_B14199.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.33 – The Apply button
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Also, we have the **Revert All** and **Apply All** buttons, but use them with
    caution, because you can easily revert and apply changes that you are not aware
    of.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: So, as you can see, Prefab is a really useful Unity tool to keep track of all
    similar objects and apply changes to all of them, and also have specific instances
    with few variations. Talking about variations, there are other cases where you
    will want to have several instances of a Prefab with the same set of variations—as
    an example, flying enemies and grounded enemies—but if you think about that, we
    will have the same problem we had when we didn't use Prefabs, so we need to manually
    update those varied versions one by one.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have two options: one is to create a brand new Prefab just to have
    another version with that variation. This leads to the problem that if we want
    all types of enemies to suffer changes, we need to manually apply the changes
    to each possible Prefab. The second option is to create a Prefab variant. Let''s
    review the latter.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Prefab variants
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **Prefab variant** is the act of creating a new Prefab but based on an existing
    one, so the new one **inherits** the features of the base Prefab. This means that
    our new Prefab can have differences with the base one, but the features that they
    have in common are still connected.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this, let''s create a variation of the enemy Prefab that can
    fly: the flying enemy Prefab. In order to do that, we can select an existing enemy
    Prefab instance in the **Hierarchy** window, name it **Flying Enemy**, and drag
    it again to the **Project** window, and this time we will see a prompt, asking
    which kind of Prefab we want to create. This time, we need to choose **Prefab
    Variant**, as illustrated in the following screenshot:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.34 – Creating Prefab variants'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.34_B14199.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.34 – Creating Prefab variants
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can enter the Prefab Edit Mode of the variant by double-clicking it,
    and then add a cube as the jet pack of our enemy, and also uncheck the **Use Gravity**
    property for the enemy. If we get back to the Scene, we will see the variant instance
    being changed, and the base enemies aren''t changed. You can see this in the following
    screenshot:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.35 – Prefab variant instance'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.35_B14199.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.35 – Prefab variant instance
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, imagine you want to add a hat to all our types of enemies. We can simply
    enter the Prefab Edit Mode of the base enemy Prefab by double-clicking it, and
    add a cube as a hat. Now, we will see that change applied to all the enemies,
    because remember: the **Flying Enemy** Prefab is a variant of the base enemy Prefab,
    meaning that it will inherit all the changes of that one.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: We have created lots of content so far, but if our PC turns off for some reason,
    we will certainly lose it all, so let's see how we can save our progress.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Saving scenes and projects
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As in any other program, we need to save our progress. The difference here is
    that we don't have just one giant file with all the project Assets, but several
    files for each Asset.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will cover the following concepts related to saving:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Saving our changes
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project structure
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving our changes
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start saving our progress by saving the scene, which is pretty straightforward.
    We can simply go to `Assets` folder of our project, but never outside that folder.
    That will generate a new Asset in the **Project** window: a scene file, as illustrated
    in the following screenshot:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.36 – Scene files'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.36_B14199.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.36 – Scene files
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: We can create a folder to save our scene in that dialog, or, if you already
    saved the scene, you can create a folder using the **Create** | **Folder** option
    in the **Project** window and drag the created scene to that folder. Now, if you
    create another Scene with the **File** | **New Scene** menu option, you can get
    back to the previous scene just by double-clicking the Asset in the **Project**
    window.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: This only saved the Scene, but any change in Prefabs and another kind of Assets
    are not saved with that option. Instead, if you want to save every change on the
    Assets except Scenes, you can use the **File** | **Save Project** option. It can
    be a little bit confusing, but if you want to save all your changes, you need
    to both save the scenes and the project, as saving just the project won't save
    the changes on Scenes. Sometimes, the best way to be sure everything is saved
    is just by closing Unity, which is recommended when you try to move your project
    between computers or folders. Let's talk about that in the next section.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Project structure
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have saved all our changes, we are ready to move the project between
    computers or to another folder (if you someday need to). You can close Unity to
    make sure everything is saved and just copy the entire project folder. If you
    don''t remember where you saved your project, you can just right-click the `Assets`
    folder in the **Project** window and select **Show in Explorer** (**Reveal in
    Finder** on a Mac), as illustrated in the following screenshot:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.37 – Locating the project folder'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.37_B14199.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.37 – Locating the project folder
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take the opportunity, now that we are in the project folder, to explore
    a little bit. We will find several folders and files in a full project, but not
    all the files are necessary to copy in order to move the project elsewhere. The
    most important folders are `Assets`, `ProjectSettings`, and `Packages`. These
    folders can be seen in the following screenshot:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.38 –  Project folder structure'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.38_B14199.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.38 –  Project folder structure
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '`ProjectSettings` folder contains several configurations of different Unity
    systems we will fiddle with later in this book, but even if we didn''t change
    any settings, it''s always a good idea to bring that folder with us. `.unitypackage`
    files used to be, but let''s discuss that later. So far, it''s important to note
    that that folder will have settings about which packages our project is using,
    so remember to also bring that one with you.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: No other folders/files are necessary because some are them are temporary and
    others can be regenerated, such as **Library**, where all the converted versions
    of our Assets will live. By converted, we mean externally generated files, such
    as 3D models, images, sounds, and so on. Unity needs to convert those files to
    a Unity-compatible format. The original will live in **Assets** and the converted
    ones in **Library** so that they can be easily regenerated if necessary. Later,
    in [*Chapter 5*](B14199_05_Final_SK_ePub.xhtml#_idTextAnchor085)*, Importing and
    Integrating Assets*, we will discuss integrating externally generated content.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s imagine you have compressed those three folders, copied them to
    a flash drive, and then decompressed the folders into another computer. How can
    we open the project again? As you can see, a project doesn''t have a project file
    or anything like that—it''s just a bunch of folders. In order to open a project,
    the easiest way would be to find a scene file in the `Assets` folder and double-click
    it so that Unity will open the project in that scene. Another option would be
    to use the `Assets` folder). So, we will add that project to the list of our computer
    projects, and later, we can just click the name in that list to open it. The following
    screenshot illustrates this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.39 – Reopening a project'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.39_B14199.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.39 – Reopening a project
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have all the base Unity knowledge we need in order to start diving into
    how to use the different Unity systems so that we can start creating a real game!
    Let's do that in the next chapter!
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw a quick introduction of essential Unity concepts. We
    reviewed all the Unity windows and how we can use all of them to edit a full scene,
    from navigating it and creating premade objects, to manipulating them to create
    our own types of objects using GameObjects and Components. We also discussed how
    to use the **Hierarchy** window to parent GameObjects to create complex object
    hierarchies, as well as creating Prefabs to reutilize and manipulate large amounts
    of the same type of objects. Finally, we discussed how we can save our progress
    and move the project, reviewing the structure of it and which folders are the
    essential ones.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about the different tools that we will use
    to create the first prototype of our game's level.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
