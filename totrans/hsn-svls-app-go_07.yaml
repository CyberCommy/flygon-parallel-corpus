- en: Implementing a CI/CD Pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will discuss advanced concepts, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: How to set up a highly resilient and fault-tolerant CI/CD pipeline to automate
    the deployment of your serverless application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The importance of having a centralized code repository for your Lambda functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to automatically deploy your code changes to production.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before starting this chapter, make sure that you create and upload the source
    code of the functions built in previous chapters to a centralized GitHub repository.
    In addition, previous experience with CI/CD concepts is highly recommended. The
    code bundle for this chapter is hosted on GitHub at [https://github.com/PacktPublishing/Hands-On-Serverless-Applications-with-Go](https://github.com/PacktPublishing/Hands-On-Serverless-Applications-with-Go).
  prefs: []
  type: TYPE_NORMAL
- en: Continuous Integration and deployment workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Continuous Integration, continuous deployment, and continuous delivery are an
    excellent way to accelerate the time-to-market of your software and drive innovation
    from feedback while ensuring you're building high-quality products through each
    iteration. But what do these practices mean? And how can they be applied when
    you're building serverless applications in AWS Lambda?
  prefs: []
  type: TYPE_NORMAL
- en: Continuous Integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Continuous Integration** (**CI**) is the process of having a centralized
    code repository and making all the changes and features go through a complex pipeline
    before integrating them into the central repository. A classic CI pipeline triggers
    a build whenever a code commit occurs, runs the unit tests and all pre-integration
    tests, builds the artifact, and pushes the result to an artifacts-management repository.'
  prefs: []
  type: TYPE_NORMAL
- en: Continuous Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Continuous Deployment** (**CD**) is an extension of Continuous Integration.
    Every change that passes all stages of your Continuous Integration pipeline is
    released automatically to your staging environment.'
  prefs: []
  type: TYPE_NORMAL
- en: Continuous Delivery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Continuous Delivery** (**CD**) is similar to CD but requires human intervention
    or a business decision before deploying the release to production.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the practices are defined, you can use these concepts to leverage
    the power of automation and build an end-to-end deployment process, as described
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea5ed17b-20e6-4887-a819-1a96ad05f26e.png)'
  prefs: []
  type: TYPE_IMG
- en: In the upcoming sections, we will go through how to build this pipeline with
    the most-used CI solutions.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate the concepts, only the `FindAllMovies` function's code will be
    used, but the same steps can be applied over the rest of the Lambda functions.
  prefs: []
  type: TYPE_NORMAL
- en: Automating the deployment of Lambda functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will see how to build a pipeline to automate the deployment
    process of the Lambda functions built in the previous chapter in the following
    different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: AWS-managed solutions, such as CodePipeline and CodeBuild
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On-premise solutions, such as Jenkins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SaaS solutions, such as Circle CI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous Deployment with CodePipeline and CodeBuild
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS CodePipeline is a workflow-management tool that allows you to automate the
    release and deployment process of your software. The user defines a set of steps
    that form a CI workflow that can be executed on AWS-managed services, such as
    CodeBuild and CodeDeploy, or third-party tools, such as Jenkins.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, AWS CodeBuild will be used to test, build, and deploy your
    Lambda function. Therefore, a build specification file with the name of `buildspec.yml`
    should be created in the code repository.
  prefs: []
  type: TYPE_NORMAL
- en: '`buildspec.yml` defines a set of steps that will be executed on the CI server
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The build specification is divided into the following four phases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Install**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up Go workspace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install Go linter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pre-build**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install Go dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check whether our code is well formatted and follows Go best practices and common
    conventions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run unit tests with the `go test` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a single binary with the `go build` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a deployment package, `.zip`, from the generated binary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store the `.zip` file in the S3 bucket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Post-build**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the Lambda function's code with the new deployment package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The unit test command will return an empty response as we will write unit tests
    of our Lambda functions in an upcoming chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Source provider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that our workflow is defined, let''s create a continuous deployment pipeline.
    Open the AWS Management Console ([https://console.aws.amazon.com/console/home](https://console.aws.amazon.com/console/home)),
    navigate to AWS CodePipeline from the **Developer Tools** section, and create
    a new pipeline called MoviesAPI, as shown in the following screenshot, shown as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6db6f695-2630-45c0-9e83-63576d34ac8f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On the Source location page, select GitHub as the Source provider, shown as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7feb1fde-06dc-4999-bca6-e0b6e3e3bb34.png)'
  prefs: []
  type: TYPE_IMG
- en: In addition to GitHub, AWS CodePipeline supports Amazon S3 and AWS CodeCommit
    as code-source providers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the Connect to GitHub button and authorize CodePipeline to access
    to your GitHub repositories; then, select the Github repository on which your
    code is stored and the target git branch you want to build, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e08b129d-2bec-4f09-aecf-54945f743df1.png)'
  prefs: []
  type: TYPE_IMG
- en: Build provider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On the Build stage, choose AWS CodeBuild as the build server. Jenkins and Solano
    CI are also a supported build providers. Note the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/37e4784e-e34f-49aa-9565-0fd685bd95b1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next step in the creation of the pipeline is to define a new CodeBuild
    project, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8cbc481f-cf4f-421f-a11e-6f113046700e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Set the build server to be an Ubuntu instance with Golang as the Runtime environment,
    as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9ae9b608-e711-4bc6-9d36-c5c052dd42b5.png)'
  prefs: []
  type: TYPE_IMG
- en: The build environment can also be based on a Docker image publicly available
    on DockerHub or in a private registry, such as **Elastic Container Registry**
    (**ECR**).
  prefs: []
  type: TYPE_NORMAL
- en: 'CodeBuild will store the artifacts (the `deployment` package) in an S3 bucket
    and update the Lambda function''s `FindAllMovies` code. Hence, an IAM role with
    the following policy should be attached:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code block the `arn:aws:lambda:us-east-1` account ID should
    be replaced with you account ID.
  prefs: []
  type: TYPE_NORMAL
- en: Deploy provider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With our project built, the next step to configure in the pipeline is the deployment
    to an environment. For this chapter, we will select the No Deployment option,
    and let CodeBuild deploy the new code to Lambda using the AWS CLI, as shown in
    the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0b7d842-1fa3-4663-9c84-406a128fd17e.png)'
  prefs: []
  type: TYPE_IMG
- en: This deployment process requires an explanation of Serverless Application Model
    and CloudFormation, which will be explained in further chapters in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Review the details; when you''re ready, click on Save, and a new pipeline should
    be created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c9d03e61-ad1c-4484-8b0e-c7edfa0871ae.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The pipeline will be started, and the Build stage will fail, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0408b126-c629-4b9f-8fdf-6768e30b5714.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we click on the Details link, it will bring you to the CodeBuild project
    page for that particular build. The phases describing the build specification
    file can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ccda68d-2537-4456-b2f1-2887fce22148.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown, the Pre-build phase has failed; in the logs section at the bottom,
    we can see it''s due to the `golint` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3652dce2-7f12-4e5a-bc81-1780af212983.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In Golang, all top-level, exported names (uppercase) should have doc comments.
    Hence, a new comment on top of the Movie struct declaration should be added as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Commit the new changes to GitHub, and a new build will trigger the execution
    of the pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71c96abb-5edc-4974-ad01-e7f4f073733f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You might be wondering how pushing the code change to the code repository triggered
    a new build. The answer is GitHub webhooks. When you created your CodeBuild project,
    a new Webhook is created automatically in your GitHub repository. Therefore, all
    changes to your code repository go through the CI pipeline, as shown in the next
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/447e1a2c-6cc8-497f-bb5e-a5b7f13beac8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the pipeline is completed, all CodeBuild phases should be passed, as shown
    in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e4d8cb20-435f-44d6-b3a2-3eacaae3da54.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Open the S3 Console, then click on the bucket used by the pipeline; a new deployment
    package should be stored with a key name identical to the commit ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31f28b91-80da-4e4b-a8f7-69f8b19aebda.png)'
  prefs: []
  type: TYPE_IMG
- en: Finally, CodeBuild will update the Lambda function's code with the `update-function-code`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous Pipeline with Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For many years, Jenkins has been the tool of choice. It's an open source continuous-integration
    server written in Java, built on top of the Hudson project. It's highly extensible
    due to its plugin-driven architecture and rich ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming sections, we will write our first *Pipeline as Code* with Jenkins
    but first we need to set up our Jenkins environment.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed builds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started, install Jenkins by following the official instructions from
    this guide: [https://jenkins.io/doc/book/installing/](https://jenkins.io/doc/book/installing/).
    Once Jenkins is up and running, point your browser to `http://instance_ip:8080`.
    This link will bring up the Jenkins dashboard, as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90272e44-925b-4db2-84fd-8cbe1ce885a8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'One of the advantages of using Jenkins is its master/slave architecture. It
    allows you to set up a Jenkins cluster with multiple workers (agents) responsible
    for building your application. This architecture has many benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Response time, not a lot of jobs waiting in the queue to be built
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increased number of concurrent builds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports multiple platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following steps describe the configuration process for bringing up a new
    worker for use with the Jenkins build server. The worker is an EC2 instance, with
    `JDK8` and `Golang`, the latest stable version installed (see [Chapter 2](52476096-dfc4-445d-ab4c-df692471bff7.xhtml), *Getting
    Started with AWS Lambda*, for instructions).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the worker is running, copy its IP address to the clipboard, head back
    to the Jenkins master dashboard, click on Manage Jenkins and then click on Manage
    Nodes. Click on New Node, give the worker a name, and select Permanent Agent,
    as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6eb5aa4c-9635-4f22-933c-d7880e1c857c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, set the node root directory to the Go workspace and paste the IP address
    of the node and select the SSH key, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b292f78-f740-42b5-94dd-d43be27c7f15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If everything is configured correctly, the node will be brought online, shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1f68289-1dcd-4cd1-989b-581ab26cd843.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting up a Jenkins job
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our cluster is deployed, we can write our first Jenkins pipeline. This
    pipeline is defined in a text file called `Jenkinsfile`. This definition file
    must be committed to the Lambda function's code repository.
  prefs: []
  type: TYPE_NORMAL
- en: The `Pipeline` plugin must be installed on Jenkins to use the *Pipeline as Code* feature.
    This feature offers a number of immediate benefits, such as code review, rollbacks,
    and versioning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following `Jenkinsfile`, which implements a basic five-stage continuous-delivery
    pipeline for the `FindAllMovies` Lambda function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The pipeline uses a **domain-specific language** (**DSL**) based on Groovy''s
    syntax and it will be executed on the node we added earlier to the cluster. Each
    time a change is pushed to the GitHub repository, your changes will go through
    multiple stages:'
  prefs: []
  type: TYPE_NORMAL
- en: Checking out code-form source control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running unit and quality tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the deployment package and storing this artifact to an S3 bucket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the `FindAllMovies` function's code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note the usage of the git commit ID as a name for the deployment package to
    give a meaningful and significant name for each release and be able to roll back
    to a specific commit if things go wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our pipeline is defined, we need to create a new job on Jenkins by
    clicking on New Item. Then, enter a name for the job and select Multibranch Pipeline.
    Set the GitHub repository on which your Lambda function''s code is stored and
    the path to the `Jenkinsfile` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c2d7eef-3dc1-42ae-9724-7a9060ad836a.png)'
  prefs: []
  type: TYPE_IMG
- en: Prior to the build, an IAM instance role with write access to S3 and the update
    operation to Lambda must be configured on the Jenkins workers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once saved, the pipeline will be executed on the master branch and the job
    should go to green, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5999f09e-3cd7-425c-a278-4c03911f888c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the pipeline is completed, you can click on each stage to see execution
    logs. In the following example, we can see the logs of the `Deploy` stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2ec68058-25b9-4726-840c-a30fc6fb7ffc.png)'
  prefs: []
  type: TYPE_IMG
- en: Git Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, to make Jenkins trigger the build when you push to the code repository,
    click on **Settings** from your GitHub repository, then on **Integrations & Services** search
    for **Jenkins (GitHub plugin)**, and fill it in with a URL similar  to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/22de4b90-b340-41dc-8dbb-50039bfdf719.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, any time you push code to your GitHub repository, the full Jenkins pipeline
    will be triggered, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be76cf6c-6847-458a-addc-59fd7147419e.png)'
  prefs: []
  type: TYPE_IMG
- en: Another way to make Jenkins create a build if it detects changes is by polling
    the target git repository periodically (cron job). This solution is a bit inefficient,
    but might be useful if your Jenkins instance is in a private network.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous Integration with Circle CI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CircleCI is a "CI/CD as a Service". It's a platform that integrates very well
    with GitHub- and BitBuckets-based projects and has built-in support for Golang
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will see how to use CircleCI to automate the deployment
    process of our Lambda functions.
  prefs: []
  type: TYPE_NORMAL
- en: Identity and access management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sign into Circle CI ([https://circleci.com/vcs-authorize/](https://circleci.com/vcs-authorize/))
    with your GitHub account. Then, select the repository on which your Lambda function''s
    code is stored, then click on the Set Up project button so Circle CI can infer
    settings automatically, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/30df529b-2ac3-49b8-adbf-52e0d1a25501.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Similar to Jenkins and CodeBuild, CircleCI will need access to a few AWS services.
    Therefore, an IAM user is needed. Head back to AWS Management Console, and create
    a new IAM user called **circleci**. Generate the AWS credentials, click on Settings
    from the CircleCI project, and then paste the AWS access and secret keys, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e0d21756-8048-4f19-ad06-380ce93e7305.png)'
  prefs: []
  type: TYPE_IMG
- en: Be sure to attach IAM policies with permissions to read/write the S3  bucket
    and Lambda functions to the IAM user.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the CI Pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that our project is set up, we need to define the CI workflow; to do so,
    we need to create a definition file, called the `config.yml` file, inside the `.circleci`
    folder with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The build environment will be a Go official Docker image in DockerHub. From
    this image, a new container will be created and the commands listed in the *steps*
    section will be executed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Check out the code from the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the AWS CLI and the ZIP command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute automated tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build a single binary from the source code and zipp up a deployment package.
    The commit ID corresponding to the build will be used as a name for the zip file
    (note the usage of the `CIRCLE_SHA1` environment variable).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the artefact in the S3 bucket.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the Lambda function's code using the AWS CLI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the template is defined and committed to the GitHub repository, a new
    build will be triggered as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f46c72c5-477e-4220-9556-19942ed5767b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the pipeline is successfully running, it will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e1b70165-60af-4bd9-a945-ec27afc3dbee.png)'
  prefs: []
  type: TYPE_IMG
- en: That’s pretty much it. This chapter merely scratches the surface of what can
    be done with the CI/CD pipeline, but should provide enough of a foundation for
    you to start experimenting and build your end-to-end workflow for your Lambda
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to set up a CI/CD pipeline from scratch to automate
    the deployment process of Lambda functions and how this solution can be implemented
    using different CI tools and services starting with an AWS-managed service to
    a highly extensible build server.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will build an improved version of this pipeline by writing
    automated unit and integration tests for our serverless API and build a single
    page app with REST backend backed with serverless functions.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implement a CI/CD pipeline for other Lambda functions with CodeBuild and CodePipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a similar workflow using Jenkins Pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the same pipeline with CircleCI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new stage to the existing pipeline to publish a new version if the current
    git branch is the master.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the pipeline to send a notification on a Slack channel every time
    a new Lambda function is deployed or updated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
