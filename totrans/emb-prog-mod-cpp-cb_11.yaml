- en: Time Points and Intervals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Embedded applications handle events and control processes happening in the physical
    world—that is why the correct handling of time and delays is crucial for them.
    Switching traffic lights; generation of sound tones; synchronization of data from
    multiple sensors—all these tasks rely on proper time measurements.
  prefs: []
  type: TYPE_NORMAL
- en: Plain C does not provide any standard functions to work with time. It is expected
    that application developers will use a time API specific for the target operating
    system—Windows, Linux, or macOS. For bare-metal embedded systems, developers have
    to create custom functions to work with time, based on a low-level timer API specific
    for the target platform. As a result, the code is hard to port to other platforms.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome the portability issue, C++ (starting with C++11) defines data types
    and functions to work with time and time intervals. This API, referenced as an
    `std::chrono` library, helps developers work with time in a uniform way in any
    environment and on any target platform.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to work with timestamps, time intervals,
    and delays in our applications. We will discuss some of the common pitfalls related
    to time management, along with the proper workarounds for them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the C++ Chrono library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measuring time intervals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with delays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the monotonic clock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using **Portable Operating System Interface** (**POSIX**) timestamps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using these recipes, you will be able to write portable code for time handling
    that works on any embedded platform.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the C++ Chrono library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting from C++11, the C++ Chrono library provides standardized data types
    and functions to work with clocks, time points, and time intervals. In this recipe,
    we will explore the basic capabilities of the Chrono library, and learn how to
    work with time points and intervals.
  prefs: []
  type: TYPE_NORMAL
- en: We will also learn how to use C++ literals for a more readable representation
    of time intervals.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to create a simple application that creates three time points and
    compares them to each other.
  prefs: []
  type: TYPE_NORMAL
- en: In your  `~/test` working directory, create a subdirectory called `chrono`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use your favorite text editor to create a `chrono.cpp` file in the `chrono` subdirectory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Put the following code snippet into the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `CMakeLists.txt` file containing build rules for our program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can now build and run the application.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our application creates three different time points. The first one is created
    using the `now` function of the system clock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Two others are derived from the first one by adding fixed time intervals of
    `1` second and `200` milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note how we specified the time units next to the numeric values. We
    used a feature called C++ literals. The Chrono library defines such literals for
    basic time units. To use these definitions, we added the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This was added before our `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we compared these time points to each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the application, we see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00856d97-097c-4ff9-98ef-4ed42bfda18c.png)'
  prefs: []
  type: TYPE_IMG
- en: As expected, time point `a` is earlier than both `b` and `c`, where time point
    `c`—which is `a` + 200 milliseconds—is earlier than `b` (`a` + 1 second). String
    literals help write more readable code, and C++ Chrono provides a rich set of
    functions to work with time. We will learn how to work with them in the next recipes.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Information about all data types, templates, and functions defined in the Chrono
    library can be found in the Chrono reference at [https://en.cppreference.com/w/cpp/chrono ](https://en.cppreference.com/w/cpp/chrono)
  prefs: []
  type: TYPE_NORMAL
- en: Measuring time intervals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every embedded application interacting with peripheral hardware or responding
    to external events has to deal with timeouts and reaction times. To do this properly,
    developers need the ability to measure time intervals with sufficient precision.
  prefs: []
  type: TYPE_NORMAL
- en: The C++ Chrono library provides an `std::chrono::duration` templated class for
    handling durations of arbitrary span and precision. In this recipe, we will learn
    how to use this class to measure the time interval between two timestamps and
    check it against a reference duration.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application will measure the duration of simple console output and compare
    it to the previous values in the loop.
  prefs: []
  type: TYPE_NORMAL
- en: In your `~/test` working directory, create a subdirectory called `intervals`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use your favorite text editor to create an `intervals.cpp` file in the `intervals` subdirectory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy the following code snippet into the `intervals.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, create a `CMakeLists.txt` file containing build rules for our program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can now build and run the application.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On each iteration of the application loop, we measure the performance of one
    output operation. To do so, we capture a timestamp before the operation and another
    timestamp after the operation is complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We use C++11 `auto` to let the compiler infer data types for the timestamps.
    Now, we need to calculate a time interval between these timestamps. Subtracting
    one timestamp from another does the job. We explicitly define the result variable
    as an `std::chrono::duration` class that tracks a microsecond in a `double` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We use another `duration` variable of the same type to hold the previous value.
    On each iteration except the first one, we calculate the difference between these
    two durations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The duration and the difference are printed to the Terminal on each iteration.
    When we run the application, we get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec323f6d-4496-4050-a609-dc90436a90c5.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, modern C++ provides convenient ways of handling time intervals
    in applications. Thanks to overloaded operators, it is easy to get a duration
    between two time points and add, subtract, or compare durations.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting from C++20, the Chrono library supports direct writing of durations
    into output streams and parsing durations from input streams. There is no need
    to serialize durations into integer or float values explicitly. This makes handling
    durations even more convenient for C++ developers.
  prefs: []
  type: TYPE_NORMAL
- en: Working with delays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Periodic data processing is a common pattern in many embedded applications.
    The code does not need to work all the time. If we know in advance when processing
    is needed, an application or a worker thread can be inactive most of the time,
    waking up and processing data only when needed. It saves power consumption or
    lets other applications running on the device use the CPU resources when the application
    is idle.
  prefs: []
  type: TYPE_NORMAL
- en: There are several techniques to organize periodic processing. A worker thread
    that runs a loop with a delay in it is one of the simplest and most common of
    them.
  prefs: []
  type: TYPE_NORMAL
- en: C++ provides standard functions to add a delay to the current execution thread.
    In this recipe, we will learn two ways of adding a delay into an application and
    discuss their pros and cons.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to create an application with two processing loops. These loops
    use different functions to pause the execution of the current thread.
  prefs: []
  type: TYPE_NORMAL
- en: In your `~/test` working directory, create a subdirectory called `delays`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use your favorite text editor to create a `delays.cpp` file in the `delays` subdirectory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s start by adding a first function, `sleep_for`, along with the necessary
    inclusions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'It is followed by a second function, `sleep_until`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add a simple `main` function that invokes them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, create a `CMakeLists.txt` file containing the build rules for our
    program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can now build and run the application.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our application, we created two functions, `sleep_for` and `sleep_until`.
    They are almost identical, except `sleep_for` uses `std::this_thread::sleep_for`
    to add a delay, while `sleep_until` uses `std::this_thread::sleep_until`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a closer look at the `sleep_for` function. It takes two parameters—`count`
    and `delay`. The first parameter defines a number of iterations in its loop, and
    the second parameter specifies a delay. We use `auto` as a data type of the `delay`
    parameter, letting C++ infer the actual data type for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function body consists of a single loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'On each iteration, we run the `delay` and measure its actual duration by taking
    timestamps before and after the `delay`. The `std::this_thread::sleep_for` function
    accepts a time interval as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual delay is measured in milliseconds, and we use a `double` value as
    a milliseconds counter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `wait_until` function is only slightly different. It uses the `std::current_thred::wait_until` function,
    which accepts a time point to wake up instead of a time interval. We introduce
    an additional `wake_up` variable to track the wake-up time point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Initially, it is set to the current time, and on each iteration, it adds the
    delay passed as a function parameter to its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The rest of the function is identical to the `sleep_for` implementation, except
    the `delay` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We run both functions, using the same number of iterations and the same delay.
    Please note how we use C++ string literals to pass milliseconds into the functions
    to make the code more readable. To use string literals, we added the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This was done above the function definitions, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Do different delay functions make any difference? We use the same delay in
    both implementations, after all. Let''s run the code and compare the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f3b5c599-d2cd-4f38-9cdc-a5a908f9ce68.png)'
  prefs: []
  type: TYPE_IMG
- en: Interestingly, we can see that all actual delays for `sleep_for` are greater
    than `100` milliseconds, while some results for `sleep_until` fall below this
    value. Our first function, `delay_for`, does not account for the time needed to
    print data to the console. `sleep_for` is a good choice when you know exactly
    how long you need to wait. However, if your goal is to wake up with specific periodicity,
    `sleep_until` might be a better choice.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are other subtle differences between `sleep_for` and `sleep_until`. The
    system timer is often not too precise and might be adjusted by time synchronization
    services such as **Network Time Protocol** **daemon **(**ntpd**). These clock
    adjustments do not affect `sleep_for`, but `sleep_until` takes them into account.
    Use it if your application relies on a specific time rather than a time interval;
    for example, if you need to redraw the digits on a clock display every second.
  prefs: []
  type: TYPE_NORMAL
- en: Using the monotonic clock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The C++ Chrono library provides three types of clocks:'
  prefs: []
  type: TYPE_NORMAL
- en: System clock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Steady clock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High-resolution clock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The high-resolution clock is often implemented as an alias of the system clock
    or the steady clock. The system clock and the steady clock, however, are quite
    different.
  prefs: []
  type: TYPE_NORMAL
- en: The system clock reflects the system time and hence is not monotonic. It can
    be adjusted at any time by time synchronization services such as **Network Time
    Protocol** (**NTP**), and, as a result, can even go backward.
  prefs: []
  type: TYPE_NORMAL
- en: This makes the system clock a poor choice for dealing with precise durations.
    The steady clock is monotonic; it is never adjusted and never goes backward. This
    property has its cost—it is not related to wall clock time and is usually represented
    as the time since the last reboot.
  prefs: []
  type: TYPE_NORMAL
- en: The steady clock should not be used for persistent timestamps that need to remain
    valid after reboots—for example, serialized into a file or saved into a database.
    Also, the steady clock should not be used for any time calculations involving
    time from different sources, such as remote systems or peripheral devices.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use the steady clock to implement a simple
    software watchdog. When running a background worker thread, it is important to
    know if it works correctly or hangs because of a coding error or an unresponsive
    peripheral device. The thread periodically updates a timestamp, while a monitoring
    routine compares the timestamp with the current time, and, if the threshold is
    exceeded, performs a certain recovery action.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our application, we are going to create a simple iterative function that
    runs in the background, along with the monitoring loop running in the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: In your `~/test` working directory, create a subdirectory called `monotonic`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use your favorite text editor to create a `monotonic.cpp` file in the `monotonic` subdirectory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s add headers and define global variables used by our routines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'They are followed by the code of the background worker thread routine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `main` function that contains the monitoring routine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, create a `CMakeLists.txt` file containing build rules for our program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You can now build and run the application.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application is multithreaded—it consists of the main thread that runs the
    monitoring and the background worker thread. We use three global variables for
    their synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: The `touched` variable is holding the timestamp that is to be periodically updated
    by the `Worker` thread. Since the timestamp is accessed by both threads, access
    needs to be protected. We use an `m` mutex for this purpose. Finally, to indicate
    that the worker thread has finished its job, an atomic variable, `ready`, is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The worker thread is a loop that contains artificial delays inside. The delay
    is calculated based on the step number, resulting in delays from 100 milliseconds
    to 130 milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'On each iteration, the `Worker` thread updates the timestamp. A lock guard
    is used to synchronize access to the timestamp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The monitoring routine runs in a loop while the `Worker` thread is running.
    On each iteration, it calculates the time interval between the current time and
    the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If it is larger than the threshold, the function prints a warning message,
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In many cases, applications may invoke a recovery function to reset a peripheral
    device or restart the thread. We add a delay of `10` milliseconds in the monitoring
    loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This helps us to reduce resource consumption yet achieve an acceptable reaction
    time. Running the application produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7962b124-e6ed-45a4-b2da-ffa84adf2d9b.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see several warnings in the output, indicating that some iterations in
    the `worker` thread took more time than the threshold of `120` milliseconds. It
    is predictable since the `worker` function is written this way. It is important
    that we use a monotonic `std::chrono::steady_clock` function for monitoring purposes.
    Using the system clock could lead to the spurious invocations of the recovery
    function during the clock adjustments.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++20 defines several other types of clocks, such as `gps_clock`, representing **Global
    Positioning System** (**GPS**) time, or `file_clock`, to work with file timestamps.
    These clocks may, or may not, be steady, or monotonic. Use an `is_steady` member
    function to check if a clock is monotonic or not.
  prefs: []
  type: TYPE_NORMAL
- en: Using POSIX timestamps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: POSIX timestamps are a traditional internal representation of time in Unix-based
    operating systems. A POSIX timestamp is defined as the number of seconds since
    the epoch, or 00:00:00 **Coordinated Universal Time** (**UTC**), January 1, 1970.
  prefs: []
  type: TYPE_NORMAL
- en: Because of its simplicity, this representation is widely used in network protocols,
    file metadata, or serialization.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to convert C++ time points to POSIX timestamps,
    and create C++ time points from POSIX timestamps.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to create an application that converts a time point into a POSIX
    timestamp and then recovers a time point from this timestamp.
  prefs: []
  type: TYPE_NORMAL
- en: In your  `~/test` working directory, create a subdirectory called `timestamps`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use your favorite text editor to create a `timestamps.cpp` file in the `timestamps` subdirectory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Put the following code snippet into the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `CMakeLists.txt` file containing build rules for our program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You can now build and run the application.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Firstly, we create a time point object for the current time, using the system
    clock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Since POSIX timestamps represent the time since the epoch, we cannot use the
    steady clock. The system clock, however, knows how to convert its internal representation
    into POSIX format. It provides a `to_time_t` static function for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is defined as having type `std::time_t`, but this is an integral
    integer type, not an object. Unlike a time point instance, we can write it directly
    into an output stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try to recover a time point from this integer timestamp. We use a `from_time_t` static
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have two timestamps. Are they the same? Let''s calculate and display
    the difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the application, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b9142d4-dd21-4eed-a8f0-d2457fd084f2.png)'
  prefs: []
  type: TYPE_IMG
- en: The timestamps are different, but the difference is always less than 1,000\.
    Since POSIX timestamps are defined as the number of seconds since the epoch, we
    lost the fine granularity time, such as milliseconds and microseconds.
  prefs: []
  type: TYPE_NORMAL
- en: Despite such limitations, POSIX timestamps remain an important and widely used
    transport representation of time, and we learned how to convert them into an internal
    C++ representation when needed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many cases, it is sufficient to work with POSIX timestamps directly. Since
    they are represented as numbers, a simple numeric comparison can be used to decide
    which timestamp is newer or older. Similarly, subtracting one timestamp from another
    gives a time interval in seconds between them. If performance is a bottleneck,
    this approach can be preferable to comparing to native C++ time points.
  prefs: []
  type: TYPE_NORMAL
