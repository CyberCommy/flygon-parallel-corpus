- en: Chapter 2. Messaging with Spring JMS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Java Messaging Services** (**JMS**) is an API used to communicate between
    the components in an application or between applications. The messages can be
    sent and received between applications and components. The messaging agents behave
    like middlemen to create, receive, read, and send messages. The message consumer
    does not need to be available at all times to receive the message. The messaging
    agents store the messages and they can be read whenever required.'
  prefs: []
  type: TYPE_NORMAL
- en: An architect would choose JMS to achieve a loosely coupled design. The messages
    are asynchronous, they are delivered as soon as they arrive, and there is no request
    sent for the messages. It also prevents redundancy and ensures that a particular
    message is delivered only once.
  prefs: []
  type: TYPE_NORMAL
- en: Types of messaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two types of messaging domains to be chosen from, as per the requirement:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Point-to-point messaging:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each message has only one consumer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no timing dependency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Publish-Subscribe messaging:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each message has many consumers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Messages have a timing dependency - when an application sends a message to the
    messaging agent, the consumer needs to subscribe and be active to receive the
    messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message consumers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These are the ways of consuming messages provided by JMS API:'
  prefs: []
  type: TYPE_NORMAL
- en: Message listeners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They provide an asynchronous messaging model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listeners are like event watchers/listeners; whenever a message is available,
    the listener ensures that it reaches its destination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listeners will call the `onMessage()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `receive()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides a synchronous messaging `model()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Messages are consumed by explicitly calling the `receive()` method from the
    connection factory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A message consists of three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Header**: This contains information about the destination and timestamp,
    and has `messageID`, which is set by the `send()` or `publish()` methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Properties**: Some properties can be set for the message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Body**: The message body can be of any of the following five types:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TextMessage`: This is used to send string objects as messages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ObjectMessage`: This is used to send serializable objects as messages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MapMessage`: This is used to send maps with key-value pairs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BytesMessage`: This is used to send bytes in messages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StreamMessage`: This is used to send I/O streams in messages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message-driven POJOs and listeners
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we all know, **Enterprise JavaBeans** (**EJB**) offers a message-driven bean
    to communicate with the EJB container. Similar to this, Spring also offers Message
    Driven Pojos, which communicate with the messaging middleware using the Message
    Listener container.
  prefs: []
  type: TYPE_NORMAL
- en: The Message Listener container communicates between the message-driven Pojo
    and the message provider. It registers the messages and helps with transaction
    and exception handling by acquiring and releasing the messaging resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of message listener containers offered by the Spring
    JMS package:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple Message Listener Container**: Provides a fixed number of JMS sessions
    and doesn''t participate in externally managed transactions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Default Message Listener Container**: Participates in externally managed
    transactions and gives a good performance. This listener container is widely used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server Message Listener Container**: Offers provider-driven runtime tuning
    and provides a pool of message sessions and participates in transactions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open source messaging tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some open source messaging middleware available under open
    source licenses:'
  prefs: []
  type: TYPE_NORMAL
- en: Glassfish OpenMQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apache ActiveMQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JORAM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Presumo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apache ActiveMQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apache ActiveMQ has many features that have made it a choice for messaging.
    The latest release is 5.10\. The advantages of using ActiveMQ are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It supports REST API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports CXF Web services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports AJAX implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides complete support to the Spring framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It works with all the major application servers, such as JBoss, Tomcat, Weblogic
    and Glassfish servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up ApacheMQ for point-to-point messaging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the steps for setting up ApacheMQ:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the latest `Apache ActiveMQ.zip` from [http://activemq.apache.org/download.html](http://activemq.apache.org/download.html).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unzip the ZIP file to `E:\apachemq\`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Command Prompt, go to the location `E:\apachemq\apache-activemq-5.10-SNAPSHOT\bin\win32`
    and then click on `apachemq.bat` to start Apache ActiveMQ.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apache ActiveMQ will run on Jetty Server and is hence accessible through a URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the link `http://localhost:8161/admin/index.jsp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first time you do this, you will be asked for credentials; enter `admin/admin`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the console, you will see a **Welcome** section and a **Broker** section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The **Broker** section gives the following information about Apache message
    broker:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Name: `localhost` or the name of the server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Version 5.10 Snapshot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ID: `ID:BLRLANJANA-55074-1397199950394-0:1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Uptime: 1 hour 24 minutes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Store percent used: 0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Memory percent used: 0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Temp percent used: 0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on **Queues**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `orderQueue` in the **Queue name** field and click on **Create**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use case for ApacheMq with Spring JmsTemplate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, we demonstrated order management using MongoDB. Let
    us consider that the order placed from one application needs to be read into different
    applications and stored in a different database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The design for **Order Management Message Broker** is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Use case for ApacheMq with Spring JmsTemplate](img/7320OS_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's use the same use case with **Message Broker**. The request flows from
    the controller, and when the user enters order details and clicks on **Save**,
    the order bean is set in the controller, which sends the request to the JMS sender,
    that is, the Order Sender.
  prefs: []
  type: TYPE_NORMAL
- en: The order sender sends the message to the queue in the form of a map. The receiver
    reads the message and saves the message into the MongoDB database. The receiver
    can be a different application as well; all the application needs to know is the
    queue name, in case there are many queues configured in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Spring dependency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the same source code from [Chapter 1](ch01.html "Chapter 1. Spring Mongo
    Integration"), *Spring Mongo Integration*, and the `pom.xml` file. Update the
    `pom.xml` file with Spring JMS dependencies. For this chapter, we have the Spring
    4.0.3 release available, which is the latest one to date. The following is the
    code for the `Pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the Order Management Messaging System with SpringJMS and ActiveMQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding section about Apache ActiveMQ, we discussed the steps required
    to create a message queue and created an order queue. Now, let's send messages
    to the queue from the application.
  prefs: []
  type: TYPE_NORMAL
- en: The following table depicts the components of the application with JMS integrated
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: The request flows from JSP to a Spring controller, which sets the order bean
    object and sends it `orderSender` (which is a JMS message sender class). The class
    puts the order object in the queue.
  prefs: []
  type: TYPE_NORMAL
- en: The JMS Receiver is the class which reads from the queue. The read object is
    sent to the `OrderRepository` class, which is a Mongo Repository class, and posts
    the messages to the MongoDB database.
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the Order Management Messaging System with SpringJMS and ActiveMQ](img/7320OS_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following table gives us an overview about the classes used to communicate
    with JMS with a Spring MVC application:'
  prefs: []
  type: TYPE_NORMAL
- en: '| JSP | Controller | Bean | JMS sender | JMS receiver | MongoRepository |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `order.jsp``allorders.jsp` | `Order Controller.java` | `Order.java` | `OrderSender`
    | `OrderReceiver` | `OrderRepository` |'
  prefs: []
  type: TYPE_TB
- en: Configuring dispatcherservlet.xml to use JMS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can see that we have configured the following in the XML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`connectionFactory`: It creates a `jmsconnection` object. This `jmsconnection`
    object connects to **Message Orientated Middleware** (**MOM**), that is, Apache
    ActiveMQ. The `jmsconnection` object provides a JMS session object, and using
    that, the application interacts with Apache ActiveMQ. The broker URL gives information
    about the host and the port the message broker interface is listening at.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`destination`: It''s the name of the queue with which the application needs
    to communicate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`jmstemplate`: This takes the destination and `connectionFactory` bean as the
    argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`orderSender`: This is the class that uses the `jms` template to send a message
    to the queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`orderReceiver`: This class reads the messages from the queue. It has the `connectionFactory`
    so that it can connect to the JMS provider to read the message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The following is the complete configuration of `dispacherservlet.xml`. We will
    observe that the configuration file has been updated with `activemq` configurations.
  prefs: []
  type: TYPE_NORMAL
- en: '**dispatcherservlet.xml**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Order.java**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `OrderController` class calls the sender to send the order to the message
    broker queue. The controller does some basic CRUD operations using MongoDB. The
    following code demonstrates the `Create` operation only.
  prefs: []
  type: TYPE_NORMAL
- en: When `/order/save` is invoked, the controller sends the order object to `orderSender`,
    which keeps the order details in the queue.
  prefs: []
  type: TYPE_NORMAL
- en: '**OrderCOntroller.java**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let's look at the JMS sender and receiver classes. Both classes use the Spring
    JMS template to receive and send messages. The `org.springframework.jms.core.MessageCreator`
    class creates the message to be placed in the queue.
  prefs: []
  type: TYPE_NORMAL
- en: The following is the code for `orderSender`, which gets an object that needs
    to be passed to the queue. The `JMSTemplate` prepares the message format so that
    it is acceptable for the queue.
  prefs: []
  type: TYPE_NORMAL
- en: '**OrderSender**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a screenshot at the time of adding the order case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring dispatcherservlet.xml to use JMS](img/7320OS_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Working with multiple queues in ApacheMQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding section, we demonstrated sending messages using Map Message
    to Order Queue. Now, we can have a look at how to work with multiple queues in
    ApacheMQ:'
  prefs: []
  type: TYPE_NORMAL
- en: Start the Apache ActiveMQ server, and in the console, click on **Queues** and
    create two queues.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let us create two queues and name the queues as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PacktTestQueue1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PacktTestQueue2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Working with multiple queues in ApacheMQ](img/7320OS_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Create a new Spring project with the same dependency as the first example in
    the chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `PacktMessageListener` class that implements the `MessageListener`
    interface. The class overrides the `onMessage(Message message)` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Spring's `DefaultMessageListener` consumes the messages from the queue and calls
    the `onMessage(Message message)` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Let's now look at the message sender class, which sends the text message to
    the queue using `JmsTemplate`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we have provided setters for `JmsTemplate` object and `queue` object and
    we defined a method to send messages. The class has been configured in the XML
    file with the application.
  prefs: []
  type: TYPE_NORMAL
- en: '**PacktMessageSender**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Let us first create resource references in the `context.xml` file under the
    `meta-inf` folder. This is where we will configure **Java Naming and Directory
    Interface** (**JNDI**) for JMS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the configuration changes that need to be made in the `spring-configuration.xml`
    file to configure multiple queues:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use Spring JNDI to look up for `queueNames` and JMS `connectionFactory`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass the `ConnectionFactory` reference to `JmsTemplate`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure the `MessageSender` and `MessageListener` classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `MessageSender` class will have `JmsTemplate` and `queue` object as the
    property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MessageListener` will have `MessageSender` as the property'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure the `DefaultMessageListenerContainer` class, this class consumes the
    message from the queue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the code for the configuration file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Spring-configuration.xml**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The following code will be configuring the `web.xml` file. In `web.xml`, we
    are actually providing the information about the `spring-configuration.xml` file
    location so that the web container can load it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If you are using Maven as the build tool, ensure that you compile the source
    code and run the application on Tomcat or any other server of your choice. Also
    keep the Apache ActiveMQ server console up and running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the ActiveMQ console, click on **Queues**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Send** button to link in the `PacktTestQ``ueue1` row.![Working
    with multiple queues in ApacheMQ](img/7320OS_02_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter some message text and click on the **Send** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the console, you will see that a message was sent from queue 1 to queue 2\.
    Our application consumes messages from `PacktTestQueue1` and push it to `PacktTestQueue2`.![Working
    with multiple queues in ApacheMQ](img/7320OS_02_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's increase the number of messages to send and see how it behaves.![Working
    with multiple queues in ApacheMQ](img/7320OS_02_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **PacktTestQueue2** and you will see all the messages getting pushed
    to `PacktTestQueue2`.![Working with multiple queues in ApacheMQ](img/7320OS_02_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring JMS transactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we use transactions, we can handle the preceding scenario better. The messages
    will be processed within the transactions, and in case of exceptions in the listener,
    will be rolled back for the complete source code. Refer to the source code present
    in `repository-Spring4JMS_TransactionChapter2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps required for including transactions in messaging:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following property to the ActiveMQ connection factory bean configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the listener definition as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us revisit the scenarios to learn what happened after adding transactions
    to the `jmsTemplate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scenario 1**: Success Scenario'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scenario 2**: The message producer sends information to the queues, the consumer
    reads it and processes it into the database; then, an error occurs.![Configuring
    JMS transactions](img/B02116_02_09.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After adding the transaction, the message will be sent by the broker three times.
    On the fourth attempt, it will be sent to a new queue so that the message is not
    lost.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scenario 3**: The message producer sends information to the queues, the consumer
    reads it and processes it into the database; then, an error occurs.![Configuring
    JMS transactions](img/B02116_02_10.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After adding the transaction, if the execution fails with the listener before
    completing the process, the message broker resends the information.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring multiple JMS listeners and adapters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We may come across an instance where we need to have more JMS listeners and
    adapters. We can configure multiple listeners when we have to process multiple
    queues easily with Spring Template. To process multiple listeners, we also need
    adapters, which will delegate to different listeners.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: JMS transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, let's see how we can include transactions in messaging. We
    shall first demonstrate messaging without transactions using a few scenarios.
    We shall first describe the scenarios and write a test case. Then, we shall develop
    an application around it. We shall demonstrate sending messages using the `convertandsendmessage()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scenario 1**: This is a positive use case, which we have seen in previous
    sections as well.![JMS transactions](img/B02116_02_11.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**Scenario 2**: Here, let''s use a negative scenario. The message producer
    sends information to the queues and the consumer reads it, but an exception occurs
    before reaching the database.![JMS transactions](img/B02116_02_12.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this scenario we have lost the message.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scenario 3**: Here, let''s use another negative scenario. The message producer
    sends information to the queues and the consumer reads it and processes it into
    the database; then, an error occurs![JMS transactions](img/B02116_02_13.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The message gets delivered and gets stored in the database before the message
    fails.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned the steps required to install Apache ActiveMQ and
    different types of messaging. We demonstrated integrating Spring `jms` templates
    with the application. We also demonstrated, with screenshots, how to create multiple
    queues and how to communicate with a queue using Spring templates. In the next
    chapter, we will look at Spring JAVA mail APIs.
  prefs: []
  type: TYPE_NORMAL
