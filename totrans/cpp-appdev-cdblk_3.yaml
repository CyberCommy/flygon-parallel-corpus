- en: Chapter 3. App Debugging with Code::Blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging is an essential step in any app development. It is also an essential
    part of an IDE and Code::Blocks is no exception. It offers a vast set of features
    to make app debugging easier.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn about app debugging with Code::Blocks. We'll
    begin with a simple app to show various features of Code::Blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to debugging in Code::Blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Code::Blocks supports two debuggers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GNU Debugger** or, as it is popularly known as **GDB**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft **Console Debugger** or **CDB**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code::Blocks installer bundles GDB together with GCC compiler. CDB can be downloaded
    and installed together with installation of Windows **Software Development Kit**
    (**SDK**) for Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Windows SDK is a collection of tools offered by Microsoft for Microsoft Windows
    platform. It consists of compiler, headers, libraries, debugger, samples, documentation,
    and tools required to develop applications for .NET Framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'CDB can be downloaded and installed from the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://msdn.microsoft.com/en-us/library/windows/hardware/gg463009.aspx](http://msdn.microsoft.com/en-us/library/windows/hardware/gg463009.aspx)'
  prefs: []
  type: TYPE_NORMAL
- en: Our focus will be on GDB throughout this chapter. Debugger related functions
    are available via the **Debug** menu in Code::Blocks as shown in the following
    screenshot. A debugger toolbar is also provided for quicker access to commonly
    used functions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to debugging in Code::Blocks](img/3415_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can access several debugger related windows by navigating to **Debug** |
    **Debugging windows** menu options. The following screenshot shows available menu
    options.
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to debugging in Code::Blocks](img/3415_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can get more information about running process from **Debug** | **Information**
    and then clicking on appropriate menu option. The following screenshot shows available
    menu options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to debugging in Code::Blocks](img/3415_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Debugger settings can be accessed by navigating to **Settings** | **Debugger**
    menu option. The following screenshot shows the debugger settings dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to debugging in Code::Blocks](img/3415_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Select **Default** in the tree on the left-hand side and more debugger related
    options will be available as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to debugging in Code::Blocks](img/3415_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Select the **Evaluate expressions under cursor** option shown in the previous
    screenshot. This option will provide a tooltip containing details whenever cursor
    is moved over a variable.
  prefs: []
  type: TYPE_NORMAL
- en: First app debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us create a new console project `App7` and replace code inside `main.cpp`
    file with following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Ensure that **Debug** target is selected in compiler toolbar and then compile
    it by clicking compile button. `App7` will be compiled for debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Before we ask GDB to debug we have to create breakpoints for it. After the code
    is typed in editor window Code::Blocks will look similar to the following screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '![First app debugging](img/3415_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To set a breakpoint move cursor to the left side of editor window next to the
    indicated line numbers. Now the cursor will change to a right-tilted cursor. Pause
    mouse and left-click. A breakpoint will be set there and will be indicated by
    a red circle. The following screenshot shows that a breakpoint has been set at
    line number `4`.
  prefs: []
  type: TYPE_NORMAL
- en: '![First app debugging](img/3415_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next follow same method and create breakpoints at line numbers 5, 6 and 9\.
    Editor window will now look similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![First app debugging](img/3415_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: All breakpoints are now visually indicated in the editor window.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now start debugging by clicking on the **Debug/Continue** button in
    debugger toolbar. Alternatively the *F8* key may be used to start debugging. The
    following window may appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![First app debugging](img/3415_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This highlights that default layout of Code::Blocks has changed as the **Debugger
    log** window has received focus (refer to the preceding screenshot). Select the
    **Don't annoy me again!** checkbox and then click on **No** button to stop it.
    It won't appear again. Let's look at the entire IDE now.
  prefs: []
  type: TYPE_NORMAL
- en: In the following screenshot execution has stopped at line number `4` and the
    cursor has changed to a yellow colored triangle. This indicates that debugger
    has stopped execution at that position. Debugger log window will also be updated
    when we continue debugging.
  prefs: []
  type: TYPE_NORMAL
- en: '![First app debugging](img/3415_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before continuing with debugging we take a look at debugger related features
    of Code::Blocks. **CPU Registers** can be examined by navigating to the **Debug**
    | **Debugging windows** | **CPU Registers** menu option. A register is a tiny
    but a high speed buffer embedded within the processor hardware.
  prefs: []
  type: TYPE_NORMAL
- en: '![First app debugging](img/3415_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now navigate to the **Debug** | **Debugging windows** | **Disassembly** menu
    option; this can be used to display assembly language representation of current
    C++ code. The following screenshot shows the **Disassembly** window and also indicates
    the position where execution has stopped. Clicking on the **Mixed Mode** checkbox
    will superimpose C++ code and corresponding assembly language code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![First app debugging](img/3415_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This style of assembly language is known as **AT&T** style. We can switch to
    **Intel** style assembly language in the disassembly dialog by navigating to the
    **Settings** | **Debugger** | **GDB/Debugger** | **Default** menu option and selecting
    the **Intel** option in **Choose disassembly flavor** (GDB only) combo box. Now
    close the previously opened disassembly dialog and reopen it. It will now show
    disassembly in Intel flavor as shown in the following screenshot. Please note
    that the choice of AT&T or Intel style is up to the preference of a developer.
    It has no effect on the debugging process.
  prefs: []
  type: TYPE_NORMAL
- en: '![First app debugging](img/3415_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Currently running threads can be examined by navigating to **Debug** | **Debugging
    windows** | **Running threads** menu option. This app is single threaded and thus
    in the following screenshot we find that only one thread is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![First app debugging](img/3415_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Stack frame can be examined by navigating to **Debug** | **Information** |
    **Current stack frame** menu option. Call stack is a data structure that stores
    information about current running function. The following screenshot shows the
    stack frame information of current process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![First app debugging](img/3415_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Call stack is a data structure that works on the principle of (**Last In First
    Out**) and stores information about active subroutines or program. Stack frame
    is part of call stack that stores information (local variables, return address
    and function parameters) of a single subroutine or function.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever an app is run on Windows platform several **Dynamic Link Libraries**
    (**DLL**) or dynamic libraries are loaded in memory. DLL provide functions that
    are accessible by other apps without including a copy of function code inside
    the apps using it. Loaded libraries can be examined by navigating to **Debug**
    | **Information** | **Loaded libraries** menu option.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the loaded libraries for our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![First app debugging](img/3415_03_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The asterisk next to the DLL name indicates whether their source can be debugged.
    We find that none of them allows debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Now we'll continue with debugging after our introduction to several debugger
    related windows. We'll also learn to set watch on a variable. Click on the **Continue**
    button and debugger will stop at line number `5`. Right-click on `radius` variable
    in editor window and then choose watch 'radius' menu option.
  prefs: []
  type: TYPE_NORMAL
- en: '![First app debugging](img/3415_03_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This will create a watch on the variable `radius`. A watch can be defined as
    an instruction to the debugger to track a variable during execution of an app.
    A separate window with the variable under watch will now be opened as shown in
    the following screenshot. Watch window can also be opened via **Debug** | **Debugging
    Windows** | **Watches** menu option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![First app debugging](img/3415_03_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we click on the **Continue** button again then execution of app will advance
    to next line. This will update content of the `radius` variable in our app. Watch
    window will also update its content showing current value of the radius variable
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![First app debugging](img/3415_03_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At this step we''ll learn about another type of breakpoint known as **data
    breakpoint**. Right-click on the `radius` variable in line number `5` in editor
    window shown in the following screenshot and then click on the **Add data breakpoint
    for ''radius''** menu option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![First app debugging](img/3415_03_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Select **Break on read or write** option as in the following screenshot and
    click on the **OK** button. By doing this we are instructing GDB to pause execution
    whenever the `radius` variable is read or written.
  prefs: []
  type: TYPE_NORMAL
- en: '![First app debugging](img/3415_03_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A data breakpoint will now be created. However data breakpoint is not shown
    visually in editor window. It can be verified from **Breakpoints** window by navigating
    to the **Debug** | **Debugging windows** | **Breakpoints** menu option. Last line
    in the following screenshot shows that a data breakpoint has been set.
  prefs: []
  type: TYPE_NORMAL
- en: '![First app debugging](img/3415_03_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click on the **Continue** button in debugger toolbar or press the *F8* key and
    execution will continue. It will now stop at line `7` due to the data breakpoint
    we have set in previous step. Variable `radius` is being read at this line and
    `gdb` has stopped execution as data breakpoint condition has been met.
  prefs: []
  type: TYPE_NORMAL
- en: '![First app debugging](img/3415_03_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click on the **Continue** button to continue execution of app and subsequently
    it will stop at line number `9`. If we continue clicking on the **Continue** button
    app, execution will stop several times due to the data breakpoint we have set
    earlier. This is normal and in order to stop execution immediately click on the
    **Stop** button in debugger toolbar or press *Shift* + *F8* key to stop execution.
  prefs: []
  type: TYPE_NORMAL
- en: This completes our introduction to app debugging with Code::Blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple app debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Real life projects are large in size and may consist of several sub-projects.
    It is essential that an IDE allows debugging of large apps spanning across several
    projects. With Code::Blocks we can do it easily.
  prefs: []
  type: TYPE_NORMAL
- en: To learn multiple app debugging we'll create two projects—first project a DLL
    project and second one is a console project that depends upon first DLL project.
    Then save both projects under same workspace named `App8`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to **File** | **New** | **Project** | **Dynamic Link Library** menu option
    to create a DLL project. Name this project `libobject`. Now rename the `libobject`
    project files. We''ll rename `main.h` file to `dllmain.h` and `main.cpp` to `dllmain.cpp`
    file. To do this, close all open editor files and right-click on the file name
    in the project tree as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multiple app debugging](img/3415_03_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Enter new file name in the dialog box shown in following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multiple app debugging](img/3415_03_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This will avoid ambiguities in file names. Now replace code inside `dllmain.h`
    file with the following code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: A DLL on Windows require special decoration in order to export it from a dynamic
    link library. This decoration statement changes while it is exported and at the
    time it is imported. Decoration `__declspec(dllexport)` is used to export functions
    from a DLL and `__declspec(dllimport)` is used to import function from another
    DLL. Decorations instruct linker to export or import a variable/function/object
    name with or without name mangling. A preprocessor define `DLL_IMP_EXPORT` is
    used to indicate compiler whether a function or a class is being exported or imported.
  prefs: []
  type: TYPE_NORMAL
- en: C++ allows function/method overloading. It is achieved by introducing name mangling
    in the generated code. Name mangling is a process in which a function name is
    converted to a unique name based on function parameters, return type, and other
    parameters. Name mangling is compiler dependent and as a result any DLL written
    is C++ can't be used directly with another compiler.
  prefs: []
  type: TYPE_NORMAL
- en: C++ introduces name mangling by default for all functions. We can stop name
    mangling using `extern "C"` keyword and are using it to stop name mangling for
    the exported `SayHello()` function. By stopping name mangling we can use a DLL
    written in C++ and compiled with one compiler to be used with another compiler.
  prefs: []
  type: TYPE_NORMAL
- en: We have defined a class `base` and this `base` class has a member function `Set()`
    and it sets two internal variables. There is a pure virtual function named `Area()`
    that must be redefined derived classes. A **pure virtual function** is a function
    that has not been implemented in the base class. If a pure virtual function is
    called in any app it may result in a crash.
  prefs: []
  type: TYPE_NORMAL
- en: However, this `base` class is not decorated with `DLL_IMP_EXPORT`. This means
    it will not be exported in DLL and no outside app can use this class.
  prefs: []
  type: TYPE_NORMAL
- en: In order to use feature of the `base` class we'll create two derived classes.
    Class `Rectangle` and `Triangle`, these are derived publicly from the `base` class.
    We have used inheritance of classes here. These classes are declared with decoration
    `DLL_IMP_EXPORT`. Thus these two classes will be exported in the resulting DLL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now replace code inside the `dllmain.cpp` file of the `libobject` project with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Code in the `dllmain.cpp` file mainly defines all the code of publicly exported
    function. There is a `DllMain()` function. It may be used to do any initialization
    or de-initialization for the DLL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next create a console app named `App8`. Now rename workspace as `App8` and
    save workspace as `App8`. This console app will use functions defined in `libobject.dll`.
    Replace code inside the `main.cpp` file of `App8` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to prepare our `App8` project to use this DLL. To do so go to
    **Project** | **Build options** menu option. Select `App8` in the project tree
    and then click on **Search directories** tab. Then add `..\libobject` directory
    to the list in the **Compiler** tab. This instructs compiler to search for header
    files in that directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multiple app debugging](img/3415_03_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also need to point linker to the directory where we have kept import library
    of `libobject.dll` file. To do so select the **Debug** target and click on the
    **Search directories** tab. Then click on the **Linker** tab and add `..\libobject\bin\Debug`
    folder to the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multiple app debugging](img/3415_03_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have to instruct linker to find references of symbols found in `libobject.dll`
    file. To do so click on the **Linker settings** tab and add `libobject.a` to the
    **Link libraries** list.
  prefs: []
  type: TYPE_NORMAL
- en: '![Multiple app debugging](img/3415_03_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We'll set up project dependencies in this step. Go to **Project** | **Properties…**
    menu option and then click on the **Project dependencies…** button. Click on the
    `libobject` and then click on the **Close** button. Finally click **OK** button
    to close the **Project/targets** options window. This completes preparation of
    the `App8` console app.
  prefs: []
  type: TYPE_NORMAL
- en: '![Multiple app debugging](img/3415_03_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now go to **Build** | **Build workspace** menu option. This will build the `libobject`
    project first and subsequently `App8` will be compiled.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to learn debugging multiple projects we''ll set breakpoints at the
    following line number:'
  prefs: []
  type: TYPE_NORMAL
- en: Line number 11, 15, 19 in the `dllmain.cpp` file, `libobject` project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line number 7, 9, 10, 12 in the `main.cpp` file, `App8` project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Breakpoints can be verified from **Breakpoints** window shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multiple app debugging](img/3415_03_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that DLLs can't run as a standalone process and require a host application
    to load them into memory. In order to debug a DLL we have to debug the host application
    that loads and runs it. Alternatively we can specify a host application (in our
    case `App8.exe`) for debugging by navigating to **Project** | **Set programs'
    arguments…** menu option.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use first approach and let our host app to load `libobject.dll`, then
    use it to debug both `libobject.dll` and `App8.exe` file. Ensure that `App8` project
    is activated in the project tree and then click on the debug/continue button in
    debugger toolbar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multiple app debugging](img/3415_03_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot execution has stopped at line number `19` of the
    `dllmain.cpp` file. Whenever `DllMain()` is exported it becomes the first function
    to be called during the loading/unloading of any DLL. As a result execution stops
    there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Loaded libraries window in the following screenshot confirms that `libobject.dll`
    has been loaded in memory and this library can be debugged:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multiple app debugging](img/3415_03_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click on the **Continue** button to continue. Execution will now pause at line
    number `7` of the `main.cpp` file.
  prefs: []
  type: TYPE_NORMAL
- en: '![Multiple app debugging](img/3415_03_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the **Continue** button twice. Execution will stop at line number
    `10` of the `main.cpp` file as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multiple app debugging](img/3415_03_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click on the **Continue** button again and execution will stop at line number
    `11` of `dllmain.cpp` file.
  prefs: []
  type: TYPE_NORMAL
- en: Debugger is now debugging `libobject` project's source file, which is a separate
    project. If cursor is hovered `m_height` variable debugger will evaluate this
    variable and show its value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Multiple app debugging](img/3415_03_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It is evident that we can debug both DLL project and console app project at
    the same time. Larger projects can be debugged using a similar method. With this
    example we conclude our multiple app debugging session. Click on the **Stop**
    button to stop debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we learned app debugging with Code::Blocks using GNU GDB debugger.
    We learned various debugging related tools provided by Code::Blocks. Subsequently
    we learned debugging single and multiple apps.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we'll discuss app development for Windows.
  prefs: []
  type: TYPE_NORMAL
