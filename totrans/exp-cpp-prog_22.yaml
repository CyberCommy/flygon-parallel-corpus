- en: STL Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will cover the following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the erase-remove idiom on `std::vector`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting items from an unsorted `std::vector` in *O(1)* time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing `std::vector` instances the fast or the safe way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping `std::vector` instances sorted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting items efficiently and conditionally into `std::map`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knowing the new insertion hint semantics of `std::map::insert`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Efficiently modifying the keys of `std::map` items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `std::unordered_map` with custom types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering duplicates from user input and printing them in alphabetical order
    with `std::set`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a simple RPN calculator with `std::stack`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a word frequency counter with `std::map`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a writing style helper tool for finding very long sentences in
    texts with `std::set`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a personal to-do list using `std::priority_queue`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the erase-remove idiom on std::vector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A lot of novice C++ programmers learn about `std::vector`, that it basically
    works like an *automatically growing array*, and stop right there. Later, they
    only lookup its documentation in order to see how to do very specific things,
    for example, *removing* items. Using STL containers like this will only scratch
    the surface of how much they help writing *clean*, *maintainable,* and *fast*
    code.
  prefs: []
  type: TYPE_NORMAL
- en: This section is all about removing items from in-between a vector instance. When
    an item disappears from a vector, and sits somewhere in the middle *between* other
    items, then all items right from it must *move* one slot to the *left* (which
    gives this task a runtime cost within *O(n)*). Many novice programmers will do
    that using a *loop*, since it is also not really a hard thing to do. Unfortunately,
    they will potentially ignore a lot of optimization potential while doing that.
    And in the end, a hand crafted loop is neither *faster*, nor *prettier* to read
    than the STL way, which we will see next.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are filling an `std::vector` instance with some example
    integers, and then prune some specific items away from it. The way we are doing
    it is considered the *correct* way of removing multiple items from a vector.
  prefs: []
  type: TYPE_NORMAL
- en: Of course we need to include some headers before we do anything.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Then we declare that we are using namespace `std` to spare us some typing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now we create us a vector of integers and fill it with some example items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to remove the items. What do we remove? There are multiple
    `2` values. Let's remove them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Interestingly, that was only one of the two steps. The vector still has the
    same size. The next line makes it actually shorter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Let's stop by here in order to print the vector's content to the terminal, and
    then continue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's remove a whole *class* of items, instead of specific *values*. In
    order to do that, we define a predicate function first, which accepts a number
    as parameter, and returns `true`, if it is an *odd* number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now we use the `remove_if` function and feed it with the predicate function.
    Instead of removing in two steps as we did before, we do it in one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: All odd items are gone now, but the vector's *capacity* is still at the old
    10 elements. In a last step, we reduce that also to the actual *current* size
    of the vector. Note that this might lead the vector code to allocate a new chunk
    of memory that fits and moves all items from the old chunk to the new one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's print the content after the second run of removing items and that's
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Compiling and running the program yields the following two output lines from
    the two item removing approaches.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What became obvious in the recipe is that when removing items from the middle
    of a vector, they first need to be *removed* and then *erased*. At least the functions
    we used have names like this. This is admittedly confusing, but let's have a closer
    look at it to make sense of these steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code which removes all values of `2` from the vector, looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `std::begin` and `std::end` functions both accept a vector instance as parameter,
    and return us iterators, which point to the *first* item, and *past the last*
    item, just as sketched in the upcoming diagram.
  prefs: []
  type: TYPE_NORMAL
- en: After feeding these and the value `2` to the `std::remove` function, it will
    move the non-`2` values forward, just like we could do that with a manually programmed
    loop. The algorithm will strictly preserve the order of all non-`2` values while
    doing that. A quick look at the illustration might be a bit confusing. In step
    2, there still is a value of `2`, and the vector should have become shorter, as
    there were four values of `2`, which all ought to be removed. Instead, the `4`
    and the `8` which were in the initial array, are duplicated. What's that?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31fad71f-4671-4aae-8626-ff3f3785f7d1.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's only take a look at all the items, which are within the range and which
    spans from the `begin` iterator on the illustration, to the `new_end` iterator.
    The item, to which the `new_end` iterator points, is the *first item past* the
    range, so it's not included. Just concentrating on that region (these are only
    the items from `1` to including `8`), we realize that *this* is the *correct*
    range from which all values of `2` are removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where the `erase` call comes into play: We must tell the vector that
    it shall not consider all items from `new_end` to `end` to be items of the vector
    any longer. This order is easy to follow for the vector, as it can just point
    its `end` iterator to the position of `new_end` and it''s done. Note that `new_end`
    was the return value of the `std::remove` call, so we can just use that.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the vector did more magic than just moving an internal pointer. If
    that vector was a vector of more complicated objects, it would have called all
    the destructors of the to-be-removed items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Afterward, the vector looks like in step 3 of the diagram: it''s considered
    *smaller* now. The old items which are now out of the range, are *still in memory*.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to make the vector occupy only as much memory as it needs, we make
    the `shrink_to_fit` call in the end. During that call, it allocates exactly as
    much memory as needed, moves over all the items and deletes the larger chunk we
    don't need any longer.
  prefs: []
  type: TYPE_NORMAL
- en: In step 8, we define a *predicate* function and use it with `std::remove_if`
    in only one step. This works, because whatever iterator the remove function returns,
    it is safe to be used in the vector's erase function. Even if *no odd item* was
    found, the `std::remove_if` function will do just *nothing*, and return the `end`
    iterator. Then, a call like `v.erase(end, end);` also does nothing, hence it is
    harmless.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `std::remove` function also works on other containers. When used with `std::array`,
     note that it does not support the second step of calling `erase`, because they
    do not have automatic size handling. Just because `std::remove` effectively only
    moves items around and does not perform their actual deletion, it can also be
    used on data structures such as arrays that do not support resizing. In the array
    case, one could overwrite the values past the new end iterator with sentinel values
    such as `''` for strings, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting items from an unsorted std::vector in O(1) time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deleting items from somewhere in the middle of an `std::vector` takes *O(n)*
    time. This is because the resulting gap from removing an item must be filled by
    moving all the items which come after the gap one slot to the left.
  prefs: []
  type: TYPE_NORMAL
- en: While moving items around like this, which might be expensive if they are complex
    and/or very large and include many items, we preserve their order. If preserving
    the order is not important, we can optimize this, as this section shows.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will fill an `std::vector` instance with some example numbers,
    and implement a quick remove function, which removes any item from a vector in
    *O(1)* time.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to include the required header files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Then, we define a main function where we instantiate a vector with example numbers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to delete the value at index `2` (counting from zero of course,
    so it's the third number `789`). The function we will use for that task is not
    implemented yet. We do that some steps later. Afterward, we print the vector's
    content.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will delete another item. It will be the value `123`, and let's say
    we don't know its index. Therefore, we will use the `std::find` function, which
    accepts a range (the vector), and a value, and then searches for the value's position.
    Afterward, it returns us an *iterator* pointing to the `123` value. We will use the
    same `quick_remove_at` function, but this is an *overloaded* version of the *previous*
    one which accepts *iterators*. It is also not implemented, yet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Apart from the two `quick_remove_at` functions, we are done. So let's implement
    these. (Note that they should be at least declared before the main function. So
    let's just define them there.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Both the functions accept a reference to a vector of *something* (in our case,
    its `int` values), so we leave that open what kind of vector the user will come
    up with. For us, it''s a vector of `T` values. The first `quick_remove_at` function
    we used accepts *index* values, which are *numbers*, so the interface looks like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now comes the meat of the recipe--how do we remove the item quickly without
    moving too many others? First, we simply take the value of the last item in the
    vector and use it to overwrite the item which shall be deleted. Second, we cut
    off the last item of the vector. These are the two steps. We surround this code
    with a little sanity check. If the index value is obviously out of the vector
    range, we do nothing. Otherwise, the code would, for example, crash on an empty
    vector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The other implementation of `quick_remove_at` works similar. Instead of accepting
    a numeric index, it accepts an iterator for `std::vector<T>`. Obtaining its type
    in a generic manner is not complicated because STL containers already define such
    types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will access the value, at which the iterator is pointing. Just as in
    the other function, we will overwrite it by the last element in the vector. Because
    we are handling not a numeric index, but an iterator this time, we need to check
    a bit differently if the iterator position is sane. If it points to the artificial
    end position, we are not allowed to dereference it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Within that if block, we do the same thing as before--we overwrite the item
    to be removed with the value of the item from the last position--then we cut off
    the last element from the vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it. Compiling and running the program leads to the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `quick_remove_at` function removes items pretty quickly without touching
    too many other items. It does this in a relatively creative way: It kind of *swaps*
    the *actual item, * which shall be removed with the *last* item in the vector.
    Although the last item has *no connection* to the actually selected item, it is
    in a *special position*: Removing the last item is *cheap*! The vector''s size
    just needs to be shrunk down by one slot, and that''s it. No items are moved during
    that step. Have a look at the following diagram which helps imaging how this happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91627e22-fdaf-41d9-a683-6c96f788f8b8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Both the steps in the recipe code look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the iterator version, which looks nearly identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Logically, we *swap* the selected item and the last one. But the code does not
    swap items, it *moves* the last one over the first one. Why? If we swapped the
    items, then we would have to store the selected item in a *temporary* variable,
    move the last item to the selected item, and then store the temporary value in
    the last slot again. This seems *useless*, as we are just about to *delete* the
    last item anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Ok, fine, so the swap is useless, and a one-way overwrite is a better thing
    to do. Having seen that, we can argue that this step could also be performed with
    a simple `*it = v.back();`, right? Yes, this would be completely *correct*, but
    imagine we stored some very large strings in every slot, or even another vector
    or map--in that situation, that little assignment would lead to a very expensive
    copy. The `std::move` call in between is just an *optimization:* In the example
    case of *strings*, the string item internally points to a large string in the
    *heap*. We do not need to copy that. Instead, when *moving* a string, the destination
    of the move gets to *point at the string data of the other*. The move source item
    is left intact, but in a useless state, which is fine because we are removing
    it anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing std::vector instances the fast or the safe way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `std::vector` is probably the most widely used container in the STL, because
    it holds data just like an array, and adds a lot of comfort around that representation.
    However, wrong access to a vector can still be dangerous. If a vector contains
    100 elements, and by accident our code tries to access an element at index 123,
    this is obviously bad. Such a program could just crash, which might be the best
    case, because that behavior would make it very obvious that there is a bug! If
    it does not crash, we might observe that the program just behaves *strangely* from
    time to time, which could lead to even more headaches than a crashing program.
    The experienced programmer might add some checks before any directly indexed vector
    access. Such checks do not increase the readability of the code, and many people
    do not know that `std::vector` already has built-in bound checks!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will use the two different ways to access an `std::vector`,
    and then see how we can utilize them to write safer programs without decreasing
    readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s include all the needed header files, and fill an example vector with
    `1000` times the value `123`, so we have something we can access:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we access the vector out of bounds using the `[]` operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we access it out of bounds using the `at` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Let's run the program and see what happens. The error message is GCC specific.
    Other compilers would emit different but similar error messages. The first read
    succeeds in a strange way. It doesn't lead the program to crash, but it's a completely
    different *value* than `123`. We can't see the output line of the other access
    because it purposefully crashed the whole program. If that out of bounds access
    was an accident, we would catch it much earlier!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `std::vector` provides the `[]` operator and the `at` function, and they
    basically do exactly the same job. The `at` function, however, performs additional
    bounds checks and throws an *exception* if the vector bounds are exceeded. This
    is super useful in situations like ours, but also makes the program a little bit
    *slower*.
  prefs: []
  type: TYPE_NORMAL
- en: Especially when doing numeric computations with indexed members which need to
    be really fast, it is advantageous to stick to `[]` indexed access. In any other
    situation, the `at` function helps uncovering bugs with usually negligible performance
    loss.
  prefs: []
  type: TYPE_NORMAL
- en: It is good practice to use the `at` function by default. If the resulting code
    is too slow but has proven to be bug-free, the `[]` operator can be used in performance-sensitive
    sections instead.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of course, we can *handle* out of bounds accesses, instead of letting the whole
    app *crash*. In order to handle it, we *catch* the exception, in case it was thrown
    by the `at` function. Catching such an exception is simple. We just surround the
    `at` call with a `try` block and define the error handling in a `catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: By the way, `std::array` also provides an `at` function.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping std::vector instances sorted
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arrays and vectors do not sort their payload objects themselves. But if we need
    that, this does not mean that we always have to switch to data structures, which
    were designed to do that automatically. If an `std::vector` is perfect for our
    use case, it is still very simple and practical to add items to it in a *sorting
    manner*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will fill an `std::vector` with random words, sort it, and
    then insert more words while keeping the vector's sorted word order intact.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first include all headers we're going to need.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We also declare that we are using namespace `std` in order to spare us some
    `std::` prefixes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Then we write a little main function, which fills a vector with some random
    strings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The next thing we do is *sorting* that vector. Let's do that with some assertions
    and the `is_sorted` function from the STL before, which shows that the vector
    really was *not* sorted before, but *is* sorted afterward.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we finally add some random words into the sorted vector using a new `insert_sorted`
    function, which we still need to implement afterward. These words shall be put
    at the right spot so that the vector is still sorted afterward:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: So, let's now implement `insert_sorted` a little earlier in the source file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, back in the main function where we stopped, we can now continue printing
    the vector and see that the insert procedure works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling and running the program yields the following nicely sorted output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The whole program is constructed around the `insert_sorted` function, which
    does what this section is about: For any new string, it locates the position in
    the sorted vector, at which it must be inserted, in order to *preserve* the order
    of the strings in the vector. However, we assume that the vector was sorted before.
    Otherwise, this would not work.'
  prefs: []
  type: TYPE_NORMAL
- en: The locating step is done by the STL function `lower_bound`, which accepts three arguments.
    The first two denote *beginning* and *end* of the underlying range. The range
    is our vector of words in this case. The third argument is the word, which shall
    be inserted. The function then finds the first item in the range, which is *greater
    than or equal* to that third parameter and returns an iterator pointing to it.
  prefs: []
  type: TYPE_NORMAL
- en: Having the right position at hand, we gave it to the `std::vector` member method
    `insert`, which accepts just two arguments. The first argument is an iterator,
    which points to the position in the vector, at which the second parameter shall
    be inserted. It appears very handy that we can use the same iterator, which just
    dropped out of the `lower_bound` function. The second argument is, of course,
    the item to be inserted.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `insert_sorted` function is pretty generic. If we generalize the types of
    its parameters, it will also work on other container payload types, and even on
    other containers such as `std::set`, `std::deque`, `std::list`, and so on! (Note
    that set has its own `lower_bound` member function that does the same as `std::lower_bound`,
    but is more efficient because it is specialized for sets.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: When trying to switch the type of the vector in the recipe from `std::vector`
    to something else, note that not all containers support `std::sort`. That algorithm
    requires random access containers, which `std::list`, for example, does not fulfill.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting items efficiently and conditionally into std::map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes we want to fill a map with key-value pairs and while filling the
    map up, we might run into two different cases:'
  prefs: []
  type: TYPE_NORMAL
- en: The key does not exist yet. Create a *fresh* key-value pair.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The key does exist already. Take the *existing* item and *modify* it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We could just naively use the `insert` or `emplace` methods of `map` and see
    if they succeed. If it doesn't, we have case 2 and modify the existing item. In
    both cases, insert and emplace create the item which we try to insert, and in
    case 2 the freshly created item is dropped. We get a useless constructor call
    in both cases.
  prefs: []
  type: TYPE_NORMAL
- en: Since C++17, there is the `try_emplace` function, which enables us to create
    items only conditionally upon insertion. Let's implement a program that takes
    a list of billionaires and constructs a map that tells us the number of billionaires
    per country. In addition to that, it stores the wealthiest person in every country.
    Our example will not contain expensive to create items, but whenever we find ourselves
    in such a situation in real-life projects, we know how to master it with `try_emplace`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will implement an application that creates a map from a
    list of billionaires. The map maps from each country to a reference to the wealthiest
    person in that country and a counter that tells how many billionaires that country
    has.
  prefs: []
  type: TYPE_NORMAL
- en: As always, we need to include some headers first and we declare that we use
    namespace `std` by default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Let's define a structure that represents billionaire items for our list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the main function, we first define the list of billionaires. There are *many*
    billionaires in the world, so let's construct a limited list with just some of
    the richest persons in some countries. This list is already ordered. The rankings
    are actually taken from the Forbes 2017 list *The World's Billionaires* at [https://www.forbes.com/billionaires/list/:](https://www.forbes.com/billionaires/list/)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's define the map. It maps from the country string to a pair. The pair
    contains a (`const`) copy of the first billionaire of every country from our list.
    That is automatically the richest billionaire per country. The other variable
    in the pair is a counter, which we will increment for every following billionaire
    in that country.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go through the list and try to emplace a new payload pair for every
    country. The pair contains a reference to the billionaire we are currently looking
    at and a counter value of `1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: If that step was successful, then we don't need to do anything else. The pair
    for which we provided the constructor arguments `b, 1` has been constructed and
    inserted into the map. If the insertion was *not* successful because the country
    key exists already, then the pair was not constructed. If our billionaire structure
    was very large, this would have saved us the runtime cost of copying it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: However, in the nonsuccessful case, we still need to increment the counter for
    this country.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Ok, that's it. We can now print how many billionaires there are per country,
    and who is the wealthiest one in each country.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Compiling and running the program yields the following output. (Of course, the
    output is limited, because we limited our input map.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The whole recipe revolves around the `try_emplace` function of `std::map`,
    which is a new C++17 addition. It has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Thus, the key being inserted is parameter `k` and the associated value is constructed
    from the parameter pack `args`. If we succeed in inserting the item, then the
    function returns an *iterator*, which points to the new node in the map, *paired*
    with a Boolean value being set to `true`. If the insertion was *not* successful,
    the Boolean value in the return pair is set to `false`, and the iterator points
    to the item with which the new item would clash.
  prefs: []
  type: TYPE_NORMAL
- en: 'This characteristic is very useful in our case--when we see a billionaire from
    a specific country for the first time, then this country is not a key in the map
    yet. In that case, we must *insert* it, accompanied with a new counter being set
    to `1`. If we *did* see a billionaire from a specific country already, we have
    to get a reference to its existing counter, in order to increment it. This is
    exactly what happened in step 6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Note that both the `insert` and `emplace` functions of `std::map` work exactly
    the same way. A crucial difference is that `try_emplace` will *not* construct
    the object associated with the key if the key already exists. This boosts the
    performance in case objects of that type are expensive to create.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The whole program still works if we switch the type of the map from `std::map`
    to `std::unordered_map`. This way, we can simply switch from one implementation
    to another, which has different performance characteristics. In this recipe, the
    only observable difference is that the billionaire map is not printed in alphabetical
    order any longer, because hash maps do not order their objects the same way as
    search trees do.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the new insertion hint semantics of std::map::insert
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Looking up items in an `std::map` takes *O(log(n))* time. This is the same for
    inserting new items, because the position where to insert them must be looked
    up. Naive insertion of *M* new items would thus take *O(M * log(n))* time.
  prefs: []
  type: TYPE_NORMAL
- en: In order to make this more efficient, `std::map` insertion functions accept
    an optional *insertion hint* parameter. The insertion hint is basically an iterator,
    which points near the future position of the item that is to be inserted. If the
    hint is correct, then we get *amortized* *O(1)* insertion time.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will insert multiple items into an `std::map`, and use insertion
    hints for that, in order to reduce the number of lookups.
  prefs: []
  type: TYPE_NORMAL
- en: We are mapping strings to numbers, so we need the header files included for
    `std::map` and `std::string`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to instantiate a map, which already contains some example characters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We will insert multiple items now, and for each item we will use an insertion
    hint. Since we have no hint in the beginning to start with, we will just do the
    first insertion pointing to the `end` iterator of the map.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We will now insert items from the alphabet backward while always using the iterator
    hint we have, and then reinitialize it to the return value of the `insert` function.
    The next item will be inserted just *before* the hint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: And just for the sake of showing how it is *not* done, we insert a string which
    will be put at the leftmost position in the map, but give it a completely *wrong*
    hint, which points to the rightmost position in the map--the `end`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we just print what we have.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: And this is the output we get when we compile and run the program. Obviously,
    the wrong insertion hint did not hurt too much, as the map ordering is still correct.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The only difference to normal map insertions in this recipe was the additional
    hint iterator. And we spoke about *correct* and *wrong* hints.
  prefs: []
  type: TYPE_NORMAL
- en: A *correct* hint will point to an existing element, which is *greater* than
    the element to be inserted so that the newly inserted key will be just *before*
    the hint. If this does not apply for the hint the user provided during an insertion,
    the insert function will fall back to a nonoptimized insertion, yielding *O(log(n))*
    performance again.
  prefs: []
  type: TYPE_NORMAL
- en: For the first insertion, we got the `end` iterator of the map, because we had
    no better hint to start with. After installing a "z" in the tree, we knew that
    installing "y" will insert a new item just in front of the "z", which qualified
    it to be a correct hint. This applies to "x" as well, if put into the tree after
    inserting the "y", and so on. This is why it is possible to use the iterator,
    which was returned by the *last* insertion for the *next* insertion.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to know, that before C++11, insertion hints were considered
    correct when they pointed *before* the position of the newly inserted item.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interestingly, a wrong hint does not even destroy or disturb the order of the
    items in the map, so how does that even work, and what did that mean, that the
    insertion time is amortized *O(1)*?
  prefs: []
  type: TYPE_NORMAL
- en: The `std::map` is usually implemented using a binary search tree. When inserting
    a new key into a search tree, it is compared against the keys of the other nodes,
    beginning from the top. If the key is smaller or larger than the key of one node,
    then the search algorithm branches left or right to go down to the next deeper
    node. While doing that, the search algorithm will stop at the point where it reached
    the maximum depth of the current tree, where it will put the new node with its
    key. It is possible that this step destroyed the tree's balance, so it will also
    correct that using a re-balancing algorithm afterward as a housekeeping task.
  prefs: []
  type: TYPE_NORMAL
- en: When we insert items into a tree with key values which are direct neighbors
    of each other (just as the integer `1` is a neighbor of the integer `2`, because
    no other integer fits between them), they can *often* also be inserted just next
    to each other in the tree, too. It can easily be checked if this is true for a
    certain key and an accompanying hint. And if this situation applies, the search
    algorithm step can be omitted, which spares some crucial runtime. Afterward, the
    re-balancing algorithm might nevertheless have to be run.
  prefs: []
  type: TYPE_NORMAL
- en: When such an optimization can *often* be done, but not *always*, this can still
    lead to an *average* performance gain. It is possible to show a *resulting* runtime
    complexity which settles down after *multiple* insertions, and then it's called
    **amortized complexity**.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba7cd62b-4541-4793-9475-24b490c8929b.png)'
  prefs: []
  type: TYPE_IMG
- en: If the insertion hint is wrong, the insertion function will simply *waive* the
    hint and start over using the search algorithm. This works correctly but is obviously
    *slower*.
  prefs: []
  type: TYPE_NORMAL
- en: Efficiently modifying the keys of std::map items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the `std::map` data structure maps from keys to values in a way that the
    keys are always unique and sorted, it is of crucial value that users cannot modify
    the keys of map nodes that are already inserted. In order to prevent the user
    from modifying the key items of perfectly sorted map nodes, the `const` qualifier
    is added to the key type.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of restriction is perfectly sane because it makes it harder for the
    user to use `std::map` the wrong way. But what shall we do if we really need to
    change the keys of some map items?
  prefs: []
  type: TYPE_NORMAL
- en: Prior to C++17, we had to remove the items of which we need to change the key
    value from the tree, in order to reinsert them. The downside of this approach
    is that this always needlessly reallocates some memory, which sounds bad in terms
    of performance.
  prefs: []
  type: TYPE_NORMAL
- en: Since C++17, we can remove and reinsert map nodes *without* any reallocation
    of memory. We will see how that works in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We implement a little application that orders the placement of drivers in a
    fictional race in an `std::map` structure. While drivers pass each other during
    the race, we need to change their placement keys, which we do the new C++17 way.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first include the necessary headers and declare that we use namespace
    `std`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We will print the race placements before and after manipulating the map structure,
    so let's implement a little helper function for that.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: In the main function, we instantiate and initialize a map that maps from integer
    values that denote the driver's place to strings that contain the driver's name.
    We also print the map because we will modify it in the next steps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Let's say that during one race lap, Bowser had a little accident and dropped
    to the last place and Donkey Kong Jr. took the chance to jump from the last place
    to the third place. In that case, we first need to extract their map nodes from
    the map because this is the only way to manipulate their keys. The `extract` function
    is a new C++17 feature. It removes items from a map without any allocation-related
    side effects. Let's also open a new scope for this task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Now we can swap Bowser's and Donkey Kong Jr.'s keys. While the keys of map nodes
    are usually not mutable because they are declared `const`, we can modify the keys
    of items which we extracted using the `extract` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '`std::map`''s `insert` method got a new overload in C++17 that accepts the
    handles of extracted nodes, in order to insert them without touching the allocator.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: After leaving the scope, we're done. We print the new race placement and let
    the application terminate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Compiling and running the program yields the following output. We see the race
    placement in the fresh map instance first, and then we see it again after swapping
    Bowser's and Donkey Kong Jr.'s positions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In C++17, `std::map` got a new member function extract. It comes in two flavors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: In this recipe, we used the second one, which accepts a key and then finds and
    extracts the map node that matches the key parameter. The first one accepts an
    iterator, which implies that it is *faster* because it doesn't need to search
    for the item.
  prefs: []
  type: TYPE_NORMAL
- en: If we try to extract an item that doesn't exist with the second method (the
    one that searches using a key), it returns an *empty* `node_type` instance. The `empty()`
    member method returns us a Boolean value that tells whether a `node_type` instance
    is empty or not. Accessing any other method on an empty instance leads to undefined
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: After extracting nodes, we were able to modify their keys using the `key()`
    method, which gives us nonconst access to the key, although keys are usually const.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in order to reinsert the nodes into the map again, we had to *move*
    them into the `insert` function. This makes sense because `extract` is all about
    avoiding unnecessary copies and allocations. Note that while we move a `node_type`
    instance, this does not result in actual moves of any of the container values.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Map nodes that have been extracted using the extract method are actually very
    versatile. We can extract nodes from a `map` instance and insert it into any other
    `map` or even `multimap` instance. It does also work between `unordered_map` and
    `unordered_multimap` instances, as well as with `set`/`multiset` and respective
    `unordered_set`/`unordered_multiset`.
  prefs: []
  type: TYPE_NORMAL
- en: In order to move items between different map/set structures, the types of key,
    value, and allocator need to be identical. Note that even if that is the case,
    we cannot move nodes from a `map` to an `unordered_map`, or from a `set` to an
    `unordered_set`.
  prefs: []
  type: TYPE_NORMAL
- en: Using std::unordered_map with custom types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we use `std::unordered_map` instead of `std::map`, we have a different degree
    of freedom for the choice of the key type which shall be used. `std::map` demands
    that there is a natural order between all key items. This way, items can be sorted.
    But what if we want, for example, mathematical vectors as a key type? There is
    no *meaning* in a *smaller* `<` relation for such types, as a vector `(0, 1)`
    is not *smaller* or *larger* than `(1, 0)`. They just point in different directions.
    This is completely fine for `std::unordered_map` because it will not distinguish
    items via their smaller/greater ordering relationship but via *hash values*. The
    only thing we need to do is to implement a *hash function* for our own type, and
    an *equal to* `==` operator implementation, which tells whether two objects are
    identical. This section will demonstrate this in an example.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will define a simple `coord` struct, which has no *default*
    hash function, so we need to define it ourselves. Then we put it to use by mapping
    `coord` values to numbers.
  prefs: []
  type: TYPE_NORMAL
- en: We first include what's needed in order to print and use `std::unordered_map`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we define our own custom struct, which is not trivially hashable by *existing*
    hash functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'We do not only need a hash function in order to use the structure as a key
    for a hash map, it also needs a comparison operator implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: In order to extend the STL's own hashing capabilities, we will open the `std`
    namespace and create our own `std::hash` template struct specialization. It contains
    the same `using` type alias clauses as other hash specializations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The meat of this `struct` is the `operator()` definition. We are just adding
    the numeric member values of `struct coord`, which is a poor hashing technique,
    but for the sake of showing how to implement it, it's good enough. A good hash
    function tries to distribute values as evenly over the whole value range as possible,
    in order to reduce the amount of *hash collisions*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now instantiate a new `std::unordered_map` instance, which accepts `struct
    coord` instances as a key, and maps it to arbitrary values. As this recipe is
    about enabling our own types for `std::unordered_map`, this is pretty much it
    already. Let''s instantiate a hash-based map with our own type, fill it with some
    items, and print its :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling and running the program yields the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Usually, when we instantiate a hash-based map implementation like `std::unordered_map`,
    we write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'It is not too obvious that there happens a lot of magic in the background when
    the compiler creates our `std::unordered_map` specialization. So, let''s have
    a look at the complete template-type definition of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The first two template types are those we filled with `coord` and `int`, which
    is the simple and obvious part. The other three template types are optional, as
    they are automatically filled with existing standard template classes, which themselves
    take template types. Those are fed with our choice for the first two parameters
    as default values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding this recipe, the `class Hash` template parameter is the interesting
    one: when we do not explicitly define anything else, it is going to be specialized
    on `std::hash<key_type>`. The STL already contains `std::hash` specializations
    for a lot of types such as `std::hash<std::string>`, `std::hash<int>`, `std::hash<unique_ptr>`,
    and many more. These classes know how to deal with such specific types in order
    to calculate optimal hash values from them.'
  prefs: []
  type: TYPE_NORMAL
- en: However, the STL does not know how to calculate a hash value from our `struct
    coord`, yet. So what we did was to just define *another* specialization, which
    knows how to deal with it. The compiler can now go through the list of all `std::hash`
    specializations it knows, and will find our implementation to match it with the
    type we provided as key type.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we did not add a new `std::hash<coord>` specialization, and named it `my_hash_type`
    instead, we could still use it with the following instantiation line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: That is obviously more to type, and not as nice to read as when the compiler
    finds the right hashing implementation itself.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering duplicates from user input and printing them in alphabetical order
    with std::set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`std::set` is a strange container: It kind of works like `std::map`, but it
    contains only keys as values, no key-value pairs. So it can hardly be used as
    a way to map values of one type to the other. Seemingly, just because there are
    less obvious use cases for it, a lot of developers do not even know about its
    existence. Then they start to implement things themselves, although `std::set`
    would be of great help in some of these situations.'
  prefs: []
  type: TYPE_NORMAL
- en: This section shows how to put `std::set` to use in an example where we collect
    potentially many different items, in order to *filter* them and output a selection
    of the *unique* ones.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will read a stream of words from the standard input. All
    *unique* words are put into an `std::set` instance. This way we can then enumerate
    all unique words from the stream.
  prefs: []
  type: TYPE_NORMAL
- en: We will use several different STL types, for which we need to include multiple
    headers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to spare us some typing, we will declare that we are using namespace
    `std`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Now we're already writing the actual program, which begins with the `main` function
    instantiating an `std::set` which stores strings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The next thing to do is to get the user input. We're just reading from standard
    input, and do that using the handy `istream_iterator`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Having a pair of `begin` and `end` iterators, which represent the user input,
    we can just fill the set from it using an `std::inserter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: That's already it. In order to see what *unique* words we got from standard
    input, we just print the content of our set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Let's compile and run our program with the following input. We get the following
    output for the preceding input, where all duplicates are stripped out, and the
    words which were unique, are sorted alphabetically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This program consists of two interesting parts. The first part is using `std::istream_iterator`
    to access the user input, and the second part is to combine this with our `std::set`
    instance using the `std::copy` algorithm, after we wrapped it into an `std::inserter`
    instance! It might look surprising that there is only one line of code which does
    all the work of *tokenizing* the input, *putting* it into the alphabetically *sorted*
    set, and *dropping* all duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: std::istream_iterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This class is really interesting in cases where we want to process masses of
    data of the *same* type from a stream, which is exactly the case in this recipe:
    we parse the whole input word by word and put it into the set in the form of `std::string`
    instances.'
  prefs: []
  type: TYPE_NORMAL
- en: The `std::istream_iterator` takes one template parameter. That is the type of
    the input we want to have. We chose `std::string` because we assume text words,
    but it could also have been `float` numbers, for example. It can basically be
    every type for which it is possible to write `cin >> var;`. The constructor accepts
    an `istream` instance. The standard input is represented by the global input stream
    object `std::cin`, which is an acceptable `istream` parameter in this case.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The input stream iterator `it` which we have instantiated, is able to do two
    things: when it is dereferenced (`*it`), it yields the current input symbol. As
    we have typed the iterator to `std::string` via its template parameter, that symbol
    will be a string containing one word.  When it is incremented (`++it`), it will
    jump to the next word, which we can access by dereferencing again.'
  prefs: []
  type: TYPE_NORMAL
- en: But wait, we need to be careful after every increment before we dereference
    it again. If the standard input ran *empty*, the iterator must *not* be dereferenced
    again. Instead, we should terminate the loop in which we dereference the iterator
    to get at every word. The abort condition, which lets us know that the iterator
    became invalid, is a comparison with the `end` iterator. If `it == end` holds,
    we are past the end of the input.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create the end iterator by creating an `std::istream_iterator` instance
    with its parameterless standard constructor. It has the purpose of being the counterpart
    of the comparison which shall act as the abort condition in every iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: As soon as `std::cin` runs empty, our `it` iterator instance will *notice* that
    and make a comparison with `end` returning `true`.
  prefs: []
  type: TYPE_NORMAL
- en: std::inserter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We used the `it` and `end` pair as *input* iterators in the `std::copy` call.
    The third parameter must be an *output* iterator. For that, we cannot just take
    `s.begin()` or `s.end()`. In an empty set, both are the same, so we are not even
    allowed to *dereference* it, regardless if that is for reading from it or assigning
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: This is where `std::inserter` comes into play. It is a function which returns
    an `std::insert_iterator` that behaves like an iterator but does something else
    than what usual iterators do. When we increment it, it does nothing. When we dereference
    it and assign something to it, it will take the container it is attached to, and
    *insert* that value as a *new* item into it!
  prefs: []
  type: TYPE_NORMAL
- en: 'When instantiating an `std::insert_iterator` via `std::inserter`, two parameters
    are needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The `s` is our set, and `s.end()` is an iterator that points to where the new
    item shall be inserted. For an empty set which we start with, this makes as much
    sense as `s.begin()`. When used for other data structures as vectors or lists,
    that second parameter is crucial for defining where the insert iterator shall
    insert new items.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the end, *all* the action happens during the `std::copy` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: This call pulls the next word token out of `std::cin` via the input iterator
    and pushes it into our `std::set`. Afterward, it increments both iterators, and
    checks whether the input iterator is equal to the input end iterator counterpart.
    If it is not, then there are still words left in the standard input, so it will
    *repeat*.
  prefs: []
  type: TYPE_NORMAL
- en: Duplicate words are automatically dropped. If the set already contains a specific
    word, adding it again has *no effect*. This would be different in an `std::multiset` as,
    in contrast, it would accept duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a simple RPN calculator with std::stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `std::stack` is an adapter class which lets the user push objects *onto*
    it like on a real stack of objects, and pop objects *down from* it again. In this
    section, we construct a reverse polish notation (RPN) calculator around that data
    structure, in order to show how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: The RPN is a notation that can be used to express mathematical expressions in
    a way that is really simple to parse. In RPN, `1 + 2` is `1 2 +`. Operands first,
    then the operation. Another example: `(1 + 2) * 3` would be `1 2 + 3 *` in RPN
    and that already shows why it is easier to parse, as we do not need *parentheses*
    to define subexpressions.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5365787-5e7f-4fab-afe2-ad3ae977ddb5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will read a mathematical expression in RPN from the standard
    input, and then feed it into a function that evaluates it. In the end, we print
    the numeric result back to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use a lot of helpers from the STL, so there are a few includes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: And we do also declare that we are using namespace `std` in order to spare us
    some typing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Then, we immediately start implementing our RPN parser. It will accept an iterator
    pair, which denotes the beginning and end of a mathematical expression in string
    form, which will be consumed token by token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: While we iterate through the tokens, we need to memorize all *operands* on the
    way until we see an *operation*. This is where we need a stack. All the numbers
    will be parsed and saved in double precision floating point, so it's going to
    be a stack of `double` values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: In order to comfortably access elements on the stack, we implement a helper.
    It modifies the stack by pulling the highest item from it and then returns that
    item. This way we can perform this task in one single step later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Another preparation is to define all the supported mathematical operations.
    We save them in a map, which associates every operation token with the actual
    operation. The operations are represented by callable lambdas, which take two
    operands, add or multiply them, for example, and then return the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Now we can finally iterate through the input. Assuming that the input iterators
    give us strings, we feed a new `std::stringstream` per token, because it can parse
    numbers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Now with every token, we try to get a `double` value out of it. If that succeeds,
    we have an *operand*, which we push on the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: If it does *not* succeed, it must be something other than an operator; in that
    case, it can only be an *operand*. Knowing that all the operations we support
    are *binary*, we need to pop the last *two* operands from the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Now we get the operand from dereferencing the iterator `it`, which already emits
    strings. By querying the `ops` map, we get a lambda object which accepts the two
    operands `l` and `r` as parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: We surrounded the application of the math part with a `try` clause, so we can
    catch possibly occurring exceptions. The `at` call of the map will throw an `out_of_range`
    exception in case the user provides a mathematical operation we don't know of.
    In that case, we will rethrow a different exception, which says `invalid argument` and
    carries the operation string which was unknown to us.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: That's already it. As soon as the loop terminates, we have the final result
    on the stack. So we return just that. (At this point, we could assert if the stack
    size is 1\. If it wasn't, then there would be missing operations.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use our little RPN parser. In order to do this, we wrap the standard
    input into an `std::istream_iterator` pair, and feed that into the RPN parser
    function. Finally, we print the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'We do again have that line wrapped into a `try` clause because there''s still
    the possibility that the user input contains operations we did not implement.
    In that case, we must catch the exception which we throw in such cases, and print
    an error message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'After compiling the program, we can play around with it. The input `"3 1 2
    + * 2 /"` represents the expression `( 3 * (1 + 2) ) / 2` and yields the correct
    result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The whole recipe revolves around pushing operands onto the stack until we see
    an operation in the input. In that situation, we pop the last two operands from
    the stack again, apply the operation to them, and push the result onto the stack
    again. In order to understand all of the code in this recipe, it is important
    to understand how we distinguish *operands* and *operations* from the input, how
    we handle our stack, and how we select and apply the right mathematical operation.
  prefs: []
  type: TYPE_NORMAL
- en: Stack handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We push items onto the stack, simply using the `push` function of `std::stack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Popping values from it looks a bit more complicated because we implemented
    a lambda for that, which captures a reference to the `val_stack` object. Let''s
    look at the same code, enhanced with some more comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'This lambda is necessary to get the top value of the stack and *remove* it
    from there in *one* step. The interface of `std::stack` is not designed in a way
    which would allow doing that in a *single* call. However, defining a lambda is
    quick and easy, so we can now get values like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Distinguishing operands from operations from user input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the main loop of `evaluate_rpn`, we take the current string token from the
    iterator and then see whether it is an operand or not. If the string can be parsed
    into a `double` variable, then it is a number, and hence also an operand. We consider
    everything which is not easily parseable as a number (such as `"+"`, for example)
    to be an *operation*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The naked code skeleton for exactly this task is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: The stream operator `>>` tells us if it is a number. First, we wrapped the string
    into an `std::stringstream`. Then we use the `stringstream` object's capability
    to stream from an `std::string` into a `double` variable, which involves parsing.
    If the parsing *fails*, we know that it does so, because we asked it to parse
    something into a number, which is *no number*.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting and applying the right mathematical operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After we realize that the current user input token is not a number, we just
    assume that it is an operation, such as `+` or `*`. Then we query our map, which
    we called `ops`, to look that operation up and return us a function, which accepts
    two operands, and returns the sum, or the product, or whatever is appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The type of the map itself looks relatively complicated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: It maps from `string` to `double (*)(double, double)`. What does the latter
    mean? This type description shall read "*pointer to a function which takes two
    doubles, and returns a double*". Imagine that the `(*)` part is the name of the
    function, such as in `double sum(double, double)`, which is immediately easier to
    read. The trick here is that our lambda `[](double, double) { return /* some double
    */ }` is convertible to a function pointer that actually matches that pointer
    description. Lambdas that *don't capture* anything are generally convertible to
    function pointers.
  prefs: []
  type: TYPE_NORMAL
- en: 'This way, we can conveniently ask the map for the correct operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'The map implicitly does another job for us: If we say `ops.at("foo")`, then
    `"foo"` is a valid key value, but we did not store any operation named like this.
    In such a case, the map will throw an exception, which we catch in the recipe.
    We rethrow a different exception whenever we catch it, in order to provide a descriptive
    meaning of this error case. The user will know better what an `invalid argument` exception
    means, compared to an `out of range` exception. Note that the user of the `evaluate_rpn`
    function might not have read its implementation, hence it might be unknown that
    we are using a map inside at all.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the `evaluate_rpn` function accepts iterators, it is very easy to feed it
    with different inputs than the standard input stream. This makes it very easy
    to test, or to adapt to different sources of user input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Feeding it with iterators from a string stream or from a string vector, for
    example, looks like the following code, for which `evaluate_rpn` does not have
    to be changed at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Use iterators wherever it makes sense. This makes your code very composable
    and reusable.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a word frequency counter with std::map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `std::map` is very useful when categorizing something in order to collect
    statistics about that data. By attaching modifiable payload objects to every key
    which represents an object category, it is pretty simple to implement a histogram
    of word frequencies for example. This is what we will do in this section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will read all user input from standard input, which might,
    for example, be a text file containing an essay. We tokenize the input to words,
    in order to count which word occurs how often.
  prefs: []
  type: TYPE_NORMAL
- en: As always, we need to include all the headers from the data structures we are
    going to use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: To spare us some typing, we declare that we use namespace `std`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: We will use one helper function in order to crop possibly appended commas, dots,
    or colons from words.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Now we start with the actual program. We will collect a map that associates
    every word we see with a counter of that word's frequency. Additionally, we maintain
    a variable which records the size of the longest word we've seen so far, so we
    can indent the word frequency table nicely when we print it at the end of the
    program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: When we stream from `std::cin` into an `std::string` variable, the input stream
    will cut out white space on the way. This way we get the input word by word.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: The word which we have now, could contain a comma, dots,  or a colon, because
    it might be at the end of a sentence or similar. We filter that out with the helper
    function we defined before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: In case this word is the longest word so far, we need to update the `max_word_len`
    variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Now we will increment the counter value of the word in our `words` map. If it
    occurs for the first time, it is implicitly created before we increment it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: After the loop terminated, we know that we saved all unique words from the input
    stream in the `words` map, paired with a counter denoting every word's frequency.
    The map uses words as keys and is sorted by their *alphabetical* order. What we
    want is to print all words sorted by their *frequency*, so the words with the
    highest frequency shall come first. In order to get that, we will first instantiate
    a vector where all these word-frequency pairs fit in and move them from the map
    to the vector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: The vector does now still contain all word-frequency pairs in the same order
    as the `words` map maintained them. Now we sort it again, in order to have the
    most frequent words at the beginning, and the least frequent ones at the end.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: All data is in order now, so we push it out to the user terminal. Using the
    `std::setw` stream manipulator, we format the data in a nicely indented format,
    so it looks kind of like a table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: After compiling the program, we can pipe any text file into it in order to get
    a frequency table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe concentrates on collecting all words in an `std::map` and then shoves
    all items out of the map and into an `std::vector`, which is then sorted differently,
    in order to print the data. Why?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example. When we count the word frequency in the string `"a
    a b c b b b d c c"`, we would get the following map content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: However, that is not the order which we want to present to the user. The program
    should print `b` first because it has the highest frequency. Then `c`, then `a`,
    then `d`. Unfortunately, we cannot request the map to give us the "*key with the
    highest associated value*", then the "*key with the second highest associated
    value*", and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Here, the vector comes into play. We typed the vector to contain pairs of strings
    and counter values. This way it can hold items exactly in the form as they drop
    out of the map.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Then we fill the vector using the word-frequency pairs using the `std::move`
    algorithm. This has the advantage that the part of the strings which is maintained
    on the heap will not be duplicated, but will be moved over from the map to the
    vector. This way we can avoid a lot of copies.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Some STL implementations use short string optimization--if the string is not
    too long, it will *not* be allocated on the heap and stored in the string object
    directly instead. In that case, a move is not faster. But moves are also never
    slower!
  prefs: []
  type: TYPE_NORMAL
- en: 'The next interesting step is the sort operation, which uses a lambda as a custom
    comparison operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: The sort algorithm will take items pairwise, and compare them, which is what
    sort algorithms do. By providing that lambda function, the comparison does not
    just compare if `a` is smaller than `b` (which is the default implementation),
    but also compares if `a.second` is larger than `b.second`. Note that all objects
    are *pairs* of strings and their counter values, and by writing `a.second` we
    access the word's counter value. This way we move all high-frequency words toward
    the beginning of the vector, and the low-frequency ones to the back.
  prefs: []
  type: TYPE_NORMAL
- en: Implement a writing style helper tool for finding very long sentences in text
    with std::multimap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever a lot of items shall be stored in a sorted manner, and the key by which
    they are sorted can occur multiple times, `std::multimap` is a good choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s find an example use case: When writing text in German, it is okay to
    use very long sentences. When writing texts in English, it is *not*. We will implement
    a tool that helps German authors to analyze their English text files, focusing
    on the length of all sentences. In order to help the author in improving the text
    style, it will group the sentences by their length. This way the author can pick
    the longest ones and break them down.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will read all user input from standard input, which we will
    tokenize by whole sentences, and not words. Then we will collect all sentences
    in an `std::multimap` paired with a variable carrying their length. Afterward,
    we output all sentences, sorted by their length, back to the user.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, we need to include all needed headers. `std::multimap` comes from
    the same header as `std::map`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: We use a lot of functions from namespace `std`, so we declare its use automatically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: When we tokenize strings by extracting what's between dot characters in the
    text, we will get text sentences surrounded by white space such as spaces, new
    line symbols, and so on. These would increase their size in a wrong way, so we
    filter them out using a helper function, which we now define.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: The actual sentence length counting function shall take a giant string containing
    all the text, and then return an `std::multimap`, which maps sorted sentence lengths
    to the sentences.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: We begin by declaring the `multimap` structure, which is intended to be the
    return value, and some iterators. As we will have a loop, we need an `end` iterator.
    Then we use two iterators in order to point to consecutive dots within the text.
    Everything between is a text sentence.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: The `it2` will be always one dot further than `it1`. As long as `it1` did not
    reach the end of the text, we are fine. The second condition checks whether `it2`
    is really at least some characters further. If that was not the case, there would
    be no characters left to read between them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: We create a string from all characters between the iterators, and filter all
    white space from its beginning and end, in order to count the length of the pure
    sentence.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: It's possible that the sentence does not contain anything other than white space.
    In that case, we simply drop it. Otherwise, we count its length by determining
    how many words there are. This is easy, as there are single spaces between all
    words. Then we save the word count together with the sentence in the `multimap`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: For the next loop iteration, we put the leading iterator `it1` on the next sentence's
    dot character. The following iterator `it2` is put one character after the *old*
    position of the leading iterator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: After the loop is terminated, the `multimap` contains all sentences paired with
    their word count and can be returned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Now we put the function to use. First, we tell `std::cin` to not skip white
    space, as we want sentences with spaces in one piece. In order to read the whole
    file, we initialize an `std::string` from input stream iterators which encapsulate
    `std::cin`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: As we only need the `multimap` result for printing, we put the `get_sentence_stats`
    call directly in the loop and feed it with our string. In the loop body, we print
    the items line by line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: After compiling the code, we can feed the app with text from any text file. An
    example Lorem Ipsum text yields the following output. As the output is very long
    for long text with many sentences, it prints the shortest sentences first and
    the longest last. This way we see the longest sentences first as terminals usually
    scroll to the end of the output automatically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The whole recipe concentrates on breaking down a large string into sentences
    of text, which are assessed for their length, and then ordered in a `multimap`.
    Because `std::multimap` itself is so easy to use, the complex part of the program
    is the loop, which iterates over the sentences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the code with the following diagram in mind, which consists
    of three sentences:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18c1c74b-9f55-4b94-b150-f5f08f678583.png)'
  prefs: []
  type: TYPE_IMG
- en: The `it1` and `it2` are always moved forward through the string together. This
    way they always point to the beginning and end of *one* sentence. The `std::find`
    algorithm helps us a lot in that regard because it works like "*start at the current
    position and then return an iterator to the next dot character. If there is none,
    return the end iterator*."
  prefs: []
  type: TYPE_NORMAL
- en: After we extract a sentence string, we determine how many words it contains,
    so we can insert it into the `multimap.` We are using the *number of words* as
    the *key* for the map nodes, and the string itself as the payload object associated
    with it. There can easily be multiple sentences which have the same length. This
    would render us unable to insert them all into one `std::map`. But since we use
    `std::multimap`, this is no problem, because it can easily handle multiple keys
    of the same value. It will keep them all *ordered* in line, which is what we need
    to enumerate all sentences by their length and output them to the user.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After having read the whole file into one large string, we iterate through the
    string and create copies of every sentence again. This is not necessary, as we
    also could have used `std::string_view`, which will be covered later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to iteratively get the strings between two consecutive dots is `std::regex_iterator`,
    which will also be covered in a later chapter of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a personal to-do list using std::priority_queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `std::priority_queue` is another container adapter class, such as `std::stack`.
    It is a wrapper around another data structure (`std::vector` by default) and provides
    a queue-like interface for it. This means that items can stepwise be pushed into
    it, and stepwise be popped out of it again. What is pushed into it *first*, will
    be popped out of it *first*. This is usually also abbreviated as a **first in,
    first out** (**FIFO**) queue. This is the opposite of a stack, where the *last*
    item pushed onto it is popped out of it *first*.
  prefs: []
  type: TYPE_NORMAL
- en: While we just described the behavior of `std::queue`, this section shows how
    `std::priority_queue` works. That adapter is special, as it does not only take
    FIFO characteristics into account but also mixes it with priorities. This means
    that the FIFO principle is kind of broken down into sub-FIFO queues, which are
    ordered by the priorities their items have.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will set up a cheap *to-do list organizing* structure. We
    do not parse user input in order to keep this program short and concentrate on
    `std::priority_queue`. So we're just filling an unordered list of to-do items
    with priorities and descriptions into a priority queue, and then read them out
    like from a FIFO queue data structure, but grouped by the priorities of the individual
    items.
  prefs: []
  type: TYPE_NORMAL
- en: We need to include some headers first. `std::priority_queue` is in the header
    file `<queue>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: How do we store to-do items in the priority queue? The thing is, we cannot add
    items and additionally attach a priority to them. The priority queue will try
    to use the *natural order* of all items in the queue. We could now implement our
    own `struct todo_item`, and give it a priority number, and a string to-do description,
    and then implement the comparison operator `<` in order to make them orderable.
    Alternatively, we can just take `std::pair`, which enables us to aggregate two things
    in one type and implements comparison for us automatically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: We now have a new type `item_type`, which consists of an integer priority and
    a string description. So, let's instantiate a priority queue, which maintains
    such items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: We will now fill the priority queue with different items which have different
    priorities. The goal is to provide an *unstructured* list, and then the priority
    queue tells us *what* to do in *which order*. If there are comics to read, and
    homework to do, of course, the homework must be done first. Unfortunately, `std::priority_queue`
    has no constructor, which accepts the initializer lists, which we can use to fill
    the queue from the beginning on. (With a vector or a normal list, it would have
    worked that way.) So we first define the list and insert it in the next step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: We can now comfortably iterate through the unordered list of to-do items and
    insert them step by step using the `push` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: All items are implicitly sorted, and therefore we have a queue which gives us
    out items with the highest priority.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Let's compile and run our program. Indeed, it tells us, to do our homework first,
    and after washing the dishes, we can finally watch TV and read comics.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `std::priority` list is very easy to use. We have only used three functions:'
  prefs: []
  type: TYPE_NORMAL
- en: The `q.push(item)` pushes an item into the queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `q.top()` returns a reference to the item which is coming out of the queue
    first.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `q.pop()` removes the frontmost item in the queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: But how did the item ordering work? We grouped a priority integer and a to-do
    item description string into an `std::pair` and got automatic ordering. If we
    have an `std::pair<int, std::string>` instance `p`, we can write `p.first` to
    access the *integer* part, and `p.second` to access the *string* part. We did
    that in the loop which prints out all to-do items.
  prefs: []
  type: TYPE_NORMAL
- en: But how did the priority queue infer that `{2, "do homework"}` is *more important*
    than `{0, "watch tv"}`, without us telling it to compare the numeric part?
  prefs: []
  type: TYPE_NORMAL
- en: The comparison operator `<` handles different cases. Let's assume we compare
    `left < right` and `left` and `right` are pairs.
  prefs: []
  type: TYPE_NORMAL
- en: The `left.first != right.first`, then it returns `left.first < right.first`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `left.first == right.first`, then it returns `left.second < right.second`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This way, we can order the items as we need. The only important thing is that
    the priority is the *first* member of the pair, and the description is the *second*
    member of the pair. Otherwise, `std::priority_queue` would order the items in
    a way where it looks like the alphabetic order of the items is more important
    than their priorities. (In that case, *watch TV* would be suggested as the *first*
    thing to do, and *do homework* some time *later*. That would at least be great
    for those of us who are lazy!)
  prefs: []
  type: TYPE_NORMAL
