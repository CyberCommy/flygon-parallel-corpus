- en: Messaging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will work with Android broadcasts and use it as a mechanism
    to receive and send messages. We will comprehend it in several steps. First, we
    will explain the mechanism that lies beneath and how to use Android broadcast
    messages. Then, we will listen for some of the most common messages. Since it's
    not enough just to listen, we will create new ones and broadcast them. Finally,
    we will meet with boot, shutdown, and network broadcast messages, so our application
    is aware of this important system event.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Android broadcasts
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listening for broadcasts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating broadcasts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listening for network events
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Android broadcasts
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android applications can send or receive messages. Messages can be system-related
    events or custom ones defined by us. Interested parties are registered for certain
    messages by defining a proper intent filter and broadcast receiver. When a message
    is broadcast, all interested parties are notified. It is important to note that
    once you subscribe for broadcast messages (especially from the `Activity` class),
    you must unsubscribe at some point. When can we use broadcast messages? We use
    broadcast messages when we need a messaging system across our application. For
    example, imagine you started a long running process in the background. At some
    point, you want to notify multiple contexts about processing results. Broadcast
    messages are a perfect solution for this.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: System broadcasts
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'System broadcasts are the ones that are sent by the Android system when various
    system events happen. Every message we send and finally receive is wrapped in
    the `Intent` class containing information about that particular event. Each `Intent`
    must have a proper action set. For example--`android.intent.action.ACTION_POWER_CONNECTED`.
    Information about the event is represented with bundled extra data. For example,
    we may have bundled an extra string field representing particular data related
    to the event we are interested in. Let''s consider an example of charging and
    battery information. Each time the battery status changes, interested parties
    will be notified and receive a broadcast message with information about the battery
    level:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this example, we registered the intent filter for battery information. However,
    we did not pass an instance of broadcast receiver. Why? This is because that battery
    data is sticky. **Sticky intents** are intents that stay around for some time
    after the broadcast is performed. Registering to this data will immediately return
    the intent containing the latest data. We could also pass an instance of a broadcast
    receiver. Let''s do it:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Every time the battery information changes, the receiver will perform a code
    we defined in its implementation; we could also define our receiver in the Android
    Manifest:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Listening for broadcasts
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we displayed in the previous example, we can receive broadcasts in one of
    the two following ways:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Registering the broadcast receiver through Android Manifest
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering the broadcast using the `registerBroadcast()` method in the contexts
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Declaring through Manifest requires the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: The `<receiver>` element with `android:name` and `android:exported` parameters.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The receiver must contain `intent` filters for the actions we subscribe. Take
    a look at the following example:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, the `name` attribute represents a name of our broadcast receiver
    class. Exported means that the application can or can't receive messages from
    sources outside the receiver's application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'If you subclass `BroadcastReceiver`, it should look like this example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Pay attention that the operations you perform in `onReceive()` method implementation
    should not take too much time. Otherwise ANR can occur!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Registering from the context
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we will show you an example of registering a broadcast receiver from the
    Android Context. To register the receiver you need an instance of it. Let''s say
    that our instance is `myReceiver`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This example will register a receiver that will listen for connectivity information.
    Since this receiver is registered from the context, it will be valid as long as
    the context from which we registered is valid. You can also use the `LocalBroadcastManager`
    class. `LocalBroadcastManager` has a purpose to register for and send broadcasts
    of intents to local objects within your process. This is the example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To unregister, perform the following code snippet:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For context subscribed receivers, it's important to pay attention to unregistering.
    For example, if we register a receiver in the `onCreate()` method of activity,
    we must unregister it in the `onDestroy()` method. If we do not do so, we will
    have a receiver leaking! Similarly, if we register in `onResume()` of our activity,
    we must unregister in `onPause()`. If we do not do this, we will register multiple
    times!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Receivers execution
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Code we execute in the `onReceive()` implementation is considered a foreground
    process. The broadcast receiver is active until we return from the method. The
    system will always run your code defined in the implementation, except if extreme
    memory pressure occurs. As we mentioned, you should perform short operations only!
    Otherwise, ANR can occur! A good example of executing a long running operation
    when a message is received is by starting `AsyncTask` and performing all the work
    there. Next, we will show you an example demonstrating this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, we introduced the use of the `goAsync()` method. What does
    it do? The method returns an object of the `PendingResult` type, which represents
    a pending result from calling an `API` method. The Android system considers the
    receiver alive until we call the `finish()` method on this instance. Using this
    mechanism, it's possible to do asynchronous processing in a broadcast receiver.
    After we finish our intensive work, we call `finish()` to indicate to the Android
    system that this component can be recycled.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Sending broadcasts
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Android has the following three ways of sending broadcast messages:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Using the `sendOrderedBroadcast(Intent, String)` method sends messages to one
    receiver at a time. Since receivers execute in order, it's possible to propagate
    a result to the next receiver. Also, it's possible to abort the broadcast so that
    it won't be passed to the rest of the receivers. We can control the order in which
    receivers are executed. We can use the `android:priority` attribute of the matching
    intent filter to prioritize.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `sendBroadcast(Intent)` method sends broadcast messages to all receivers.
    The sending is not ordered.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `LocalBroadcastManager.sendBroadcast(Intent)` method sends broadcasts
    to receivers that are in the same application as the sender.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example of sending a broadcast message to all interested
    parties:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We created a broadcast message containing extra data about `note` a  we created
    (title and message). All interested parties will need a proper `IntentFilter`
    instance for the action:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Don''t get confused with starting activities and sending broadcast messages.
    The `Intent` class is used just as a wrapper for our information. These two operations
    are completely different! You can achieve the same using the local broadcast mechanism:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, when we showed you the most important aspects of broadcast messaging, we
    will continue with extending our application. Journaler will send and receive
    our custom broadcast messages containing data and interact with system broadcasts,
    such as system boot, shutdown, and network.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own broadcast messages
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you probably remember, we did code refactoring for the `NoteActivity` class.
    Let''s show the last state we had in important parts for our further demonstration:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you take a look at this again, you will notice that we sent `intent` to
    our service on the execution, but since we don''t get a return value, we just
    execute the `sendMessage()` method with Boolean `true` as its parameter. Here,
    we expected a value that represents the result of a CRUD operation, that is, success
    or failure. We will connect our service with `NoteActivity` using broadcast messages.
    Each time we insert or update the `note` broadcast, a message will be fired. Our
    listener defined in `NoteActivity` will respond to this message and trigger the
    `sendMessage()` method. Let''s update our code! Open the `Crud` interface and
    extend it with a `companion` object containing constants for an action and a CRUD
    operation result:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, open `DatabaseService` and extend it with a method responsible for sending
    broadcast messages on CRUD operation execution:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We introduced a new method. Everything else is the same. We take the CRUD operation
    result and broadcast it as a message. `NoteActivity` will listen for it:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This was simple and easy! We reconnected the original `sendMessage()` method
    with the CRUD operation result. In the next sections, we will consider some significant
    improvements our application can have by listening to boot, shutdown, and network
    broadcast messages.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Using on boot and on shutdown broadcasts
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, it''s crucial for services to run as the application starts. Also,
    sometimes it is important to do some cleanup work before we terminate it. In the
    following example, we will extend the Journaler application to listen for these
    broadcast messages and do some work. First thing that we will do is create two
    classes that extend the `BroadcastReceiver` class:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '`BootReceiver`: This is to handle the system boot event'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ShutdownReceiver`: This is to handle the system shutdown event'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Register them in your `manifest` file as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `BootReceiver` class will be triggered when we boot or replace the application.
    Shutdown will be triggered when we turn off the device. Let''s create proper implementations.
    Open the `BootReceiver` class and define it like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As you can see, we defined the `receiver` package for these two classes. For
    `ShutdownReceiver`, define the class like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To make this work, we need to apply one more change; otherwise, the application
    will crash. Move by starting the `main` service from the `Application` class into
    the main activity `onCreate()` method. This is the first update `Journaler` class:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then extend the `MainActivity` class by appending lines at the end of the `onCreate()`
    method:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Build your application and run it. First, shut down your phone and then power
    it on. Filter your Logcat so it displays only logs for your application. You should
    have this output:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Keep in mind that, sometimes, it requires more than two minutes to receive on
    an boot event!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Listening for network events
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last improvement we want is the ability for our application to execute
    synchronization when connectivity is established. Create a new class called in
    the same `NetworkReceiver` package. Make sure you have the implementation like
    this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This receiver will receive messages when a connectivity event occurs. Each
    time when we have a context and connectivity, we will bind to the service and
    trigger synchronization. Do not bother with frequent synchronization triggering
    as, in the next chapters, we will protect ourselves from it in the synchronization
    method implementation itself. Register your listener by updating the Journaler
    application class as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Build and run your application. Turn off your connections (Wi-Fi, Mobile) and
    turn it on again. Observe the following Logcat output:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Summary
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to use broadcast messages. We also learned how
    to listen for the system broadcast messages and the ones we create on our own.
    The Journaler application is significantly improved and has become more flexible.
    We will not stop there, but we will continue our progress through the Android
    Framework by learning new stuff and extending our code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用广播消息。我们还学习了如何监听系统广播消息以及我们自己创建的广播消息。Journaler 应用程序得到了显著改进，变得更加灵活。我们不会止步于此，而是将通过学习新知识和扩展我们的代码来继续在
    Android 框架中取得进展。
