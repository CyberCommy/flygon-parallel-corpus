- en: Chapter 26. Advanced UI with Navigation Drawer and Fragment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will see what is (arguably) the most advanced UI. The `NavigationView,`
    or navigation drawer (because of the way it slides out its content), can be created
    simply by choosing it as a template when you create a new project. We will do
    just that, and then we will examine the auto-generated code and learn how to interact
    with it. We will then use everything we know about the `Fragment` class to populate
    each of the "drawers" with different behaviors and views. Then, in the next chapter,
    we will learn about databases to add some new functionality to each `Fragment`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, the following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the `NavigationView` widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with the Age Database app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a `NavigationView` using the project template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding multiple `Fragment` instances and layouts to `NavigationView`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at this extremely cool UI pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the NavigationView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What''s so great about the `NavigationView`? Well the first thing that might
    catch your eye is that it can be made to look extremely stylish. Look at this
    following screenshot, which shows off a `NavigationView` in action in the Google
    Play app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing the NavigationView](img/B12806_26_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To be honest, right from the outset, ours is not going to be as fancy as the
    one in the Google Play app. However, the same functionality will be present in
    our app.
  prefs: []
  type: TYPE_NORMAL
- en: What else is neat about this UI is the way that it slides to hide or reveal
    itself when required. It is because of this behavior that it can be a significant
    size, making it extremely flexible regarding the options that can be added to
    it and, when the user is finished with it, it completely disappears—like a drawer.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I suggest trying the Google Play app now and seeing how it works, if you haven't
    already.
  prefs: []
  type: TYPE_NORMAL
- en: You can slide your thumb or finger from the left-hand edge of the screen and
    the drawer will slowly slide out. You can, of course, slide it away again in the
    opposite direction.
  prefs: []
  type: TYPE_NORMAL
- en: While the navigation drawer is open, the rest of the screen is slightly dimmed
    (as seen in the previous screenshot), helping the user to focus on the navigation
    options offered.
  prefs: []
  type: TYPE_NORMAL
- en: You can also tap anywhere off the navigation drawer while it is open, and it
    will slide itself away, leaving the entire screen clear for the rest of the layout.
  prefs: []
  type: TYPE_NORMAL
- en: The drawer can also be opened by tapping on the menu icon in the top-left corner.
  prefs: []
  type: TYPE_NORMAL
- en: We can also tweak and refine the behavior of the navigation drawer, as we will
    see toward the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the Age Database app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will focus on creating the `NavigationView` and populating
    it with four `Fragment` classes and their respective layouts. In the next chapter,
    we will learn about, and implement, the database functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what our `NavigationView` looks like in all its glory. Note that many
    of the options, and most of the appearance and decoration, is provided by default
    when using the `NavigationView` Activity template:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Examining the Age Database app](img/B12806_26_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The four main options are what we will add to the UI. They are **Insert**, **Delete**,
    **Search**, and **Results**. The layouts are shown, and their purposes described,
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Insert
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first screen allows the user to insert a person''s name and their associated
    age into the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Insert](img/B12806_26_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This simple layout has two `EditText` widgets and a button. The user will enter
    a name and an age, and then click the **INSERT** button to add them to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Delete
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This screen is even simpler. The user will enter a name in the `EditText` widget
    and click the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Delete](img/B12806_26_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If the name entered is present in the database, then the entry (name and age)
    will be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This layout is much the same as the previous layout, but has a different purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Search](img/B12806_26_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The user will enter a name into the `EditText` and then click the button. If
    the name is present in the database, then it will be displayed along with the
    matching age.
  prefs: []
  type: TYPE_NORMAL
- en: Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This screen shows all the entries in the entire database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Results](img/B12806_26_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's get started with the app and the navigation drawer.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the Age Database project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new project in Android Studio. Call it `Age Database`, use the **Navigation
    Drawer Activity** template, and leave all the other settings as we have throughout
    the book. Before we do anything else, it is well worth running the app on an emulator
    to see how much has been auto-generated as part of this template, as can be seen
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting the Age Database project](img/B12806_26_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At first glance, it is just a plain old layout with a `TextView`. But, swipe
    from the left edge, or press the menu button, and the navigation drawer reveals
    itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting the Age Database project](img/B12806_26_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we can modify the options and insert a `Fragment` instance (with a layout)
    for each option. To understand how it works, let's examine the auto-generated
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the auto-generated code and assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `drawable` folder, there are some icons, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring the auto-generated code and assets](img/B12806_26_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: These are the usual icons, but also the ones that appear in the menu of the
    navigation drawer. We will not take the trouble to change these, but if you want
    to personalize the icons in your app, it should be plain by the end of this exploration
    how to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open the `res/menu` folder. Notice that there is an extra file titled
    `activity_main_drawer.xml`. This next code is an excerpt from this file, so we
    can discuss its contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Notice there are four `item` tags within a `group` tag. Now, notice how the
    `title` tags from top to bottom (`Import`, `Gallery`, `Slideshow`, and `Tools`)
    exactly correspond to the first four text options in the menu of the auto-generated
    navigation drawer. Also, notice that within each `item` tag there is an `id` tag,
    so we can refer to them in our Kotlin code, as well as an `icon` tag, which corresponds
    to one of the icons in the `drawable` folder we have just seen.
  prefs: []
  type: TYPE_NORMAL
- en: Also, look in the `layout` folder at the `nav_header_main.xml` file, which contains
    the layout for the header of the drawer.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the files are as we have come to expect, but there are a few more
    key points to note in the Kotlin code. These are in the `MainActivity.kt` file.
    Open it up now and we will look at them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is the extra code in the `onCreate` function that handles various
    aspects of our UI. Look at this additional code, and then we can discuss it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The code gets a reference to a `DrawerLayout,` which corresponds to the layout
    we have just seen. The code also creates a new instance of `ActionBarDrawerToggle`,
    which allows the controlling or toggling of the drawers. The final line of code
    sets a listener on the `NavigationView`. Now, Android will call a special function
    every time the user interacts with the navigation drawer. This special function
    I refer to is `onNavigationItemSelected`. We will see this auto-generated function
    in a minute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, look at the `onBackPressed` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is an overridden function of the `Activity` class and it handles what happens
    when the user presses the back button on their device. The code closes the drawer
    if it is open and, if it is not, simply calls `super.onBackPressed`. This means
    that the back button will close the drawer if it is open or use the default behavior
    if it was already closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, look at the `onNavigationItemSelected` function, which is key to the functionality
    of this app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `when` block branches correspond to the `id` values contained
    in the `activity_main_drawer.xml` file. This is where we will respond to the user
    selecting options in our navigation drawer menu. Currently, the `when` code does
    nothing. We will change it to load a specific `Fragment`, along with its related
    layout, into the main view. This will mean that our app will have entirely separate
    functionality and a separate UI, depending on the user's choice from the menu—as
    described when we discussed the MVC pattern in [Chapter 24](ch24.html "Chapter 24. Design
    Patterns, Multiple Layouts, and Fragments"), *Design Patterns, Multiple Layouts,
    and Fragments*.
  prefs: []
  type: TYPE_NORMAL
- en: Let's code the `Fragment` classes and their layouts, and then we can come back
    and write the code to use them in the `onNavigationItemSelected` function.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the Fragment classes and their layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create the four classes, including the code that loads the layout as
    well as the actual layouts, but we won't put any of the database functionality
    into the Kotlin code until we have learned about Android databases in the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have our four classes and their layouts, we will see how to load them
    from the navigation drawer menu. By the end of the chapter, we will have a fully
    working navigation drawer that lets the user swap between fragments, but the fragments
    won't do anything until the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the empty files for the classes and layouts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create four layout files with vertical `LinearLayout` as their parent view by
    right-clicking on the `layout` folder and selecting **New** | **Layout resource
    file**. Name the first file `content_insert`, the second `content_delete`, the
    third `content_search`, and the fourth `content_results`. All the other options
    can be left at their defaults.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now have four new layout files containing `LinearLayout` parents,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the empty files for the classes and layouts](img/B12806_26_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's code the Kotlin classes.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create four new classes by right-clicking the folder that contains the `MainActivity.kt`
    file and selecting **New** | **Kotlin File/Class**. Name them `InsertFragment`,
    `DeleteFragment`, `SearchFragment`, and `ResultsFragment`. It should be plain
    from the names which fragments will show which layouts.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's add some code to each class to make the classes inherit from `Fragment`
    and load their associated layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `InsertFragment.kt` and edit it to contain the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `DeleteFragment.kt` and edit it so that it contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `SearchFragment.kt` and edit it so that it contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `ResultsFragment.kt` and edit it so that it contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Each class is completely devoid of functionality, except that in the `onCreateView`
    function, the appropriate layout is loaded from the associated layout file.
  prefs: []
  type: TYPE_NORMAL
- en: Let's add the UI to the layout files we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the layouts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw at the start of the chapter, all the layouts are simple. Getting your
    layouts identical to mine is not essential but, as always, the `id` attribute
    values must be the same or the Kotlin code we write in the next chapter won't
    work.
  prefs: []
  type: TYPE_NORMAL
- en: Designing content_insert.xml
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Drag two **Plain Text** widgets from the **Text** category of the palette onto
    the layout. Remember that **Plain Text** widgets are `EditText` instances. Now,
    drag a **Button** onto the layout after the two **EditText**/**Plain Text** widgets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure the widgets according to this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Widget | Attribute and value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Top edit text | id = `editName` |'
  prefs: []
  type: TYPE_TB
- en: '| Top edit text | text = `Name` |'
  prefs: []
  type: TYPE_TB
- en: '| Second edit text | id = `editAge` |'
  prefs: []
  type: TYPE_TB
- en: '| Second edit text | text = `Age` |'
  prefs: []
  type: TYPE_TB
- en: '| Button | id = `btnInsert` |'
  prefs: []
  type: TYPE_TB
- en: '| Button | text = `Insert` |'
  prefs: []
  type: TYPE_TB
- en: 'This is what your layout should look like in the design view in Android Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing content_insert.xml](img/B12806_26_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Designing content_delete.xml
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Drag a **Plain Text**/**EditText** widget onto the layout with a **Button**
    below it. Configure the widgets according to the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Widget | Attribute value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| EditText | id = `editDelete` |'
  prefs: []
  type: TYPE_TB
- en: '| EditText | text = `Name` |'
  prefs: []
  type: TYPE_TB
- en: '| Button | id = `btnDelete` |'
  prefs: []
  type: TYPE_TB
- en: '| Button | text = `Delete` |'
  prefs: []
  type: TYPE_TB
- en: 'This is what your layout should look like in the design view in Android Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing content_delete.xml](img/B12806_26_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Designing content_search.xml
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Drag a **Plain Text**/**EditText** widget, followed by a **Button** and then
    a regular **TextView**, onto the layout, and then configure the widgets according
    to the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Widget | Attribute value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| EditText | id = `editSearch` |'
  prefs: []
  type: TYPE_TB
- en: '| EditText | text = `Name` |'
  prefs: []
  type: TYPE_TB
- en: '| Button | id = `btnSearch` |'
  prefs: []
  type: TYPE_TB
- en: '| Button | text = `Search` |'
  prefs: []
  type: TYPE_TB
- en: '| TextView | id = `textResult` |'
  prefs: []
  type: TYPE_TB
- en: 'This is what your layout should look like in the design view in Android Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing content_search.xml](img/B12806_26_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Designing content_results.xml
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Drag a single `TextView` (not **Plain Text**/**EditText** this time) onto the
    layout. We will see in the next chapter how to add an entire list to this single
    `TextView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure the widget according to the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Widget | Attribute value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| TextView | id = `textResults` |'
  prefs: []
  type: TYPE_TB
- en: 'This is what your layout should look like in the design view in Android Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing content_results.xml](img/B12806_26_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we can use the classes based on the `Fragment` class, and their layouts.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Fragment classes and their layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This stage has three steps. First, we need to edit the menu of the navigation
    drawer to reflect the options the user has. Next, we need a `View` instance in
    the layout to hold whatever the active `Fragment` instance is, and finally, we
    need to add code to `MainActivity.kt` to switch between the different `Fragment`
    instances when the user taps on the menu of the navigation drawer.
  prefs: []
  type: TYPE_NORMAL
- en: Editing the navigation drawer menu
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the `activity_main_drawer.xml` file in the `res/menu` folder of the project
    explorer. Edit the code within the `group` tags that we saw earlier to reflect
    our menu options of **Insert**, **Delete**, **Search**, and **Results**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now would be a good time to add new icons to the `drawable` folder and edit
    the preceding code to refer to them if you wanted to use your own icons.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a holder to the main layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the `content_main.xml` file in the layout folder and add this highlighted
    XML code just before the closing tag of the `ConstraintLayout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have a `FrameLayout` with an `id` attribute of `fragmentHolder` that
    we can get a reference to and load all our `Fragment` instance layouts into.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the MainActivity.kt file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the `MainActivity` file and edit the `onNavigationItemSelected` function
    to handle all the different menu options the user can choose from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Let's go through the code we just added. Most of the code should look familiar.
    For each of our menu options, we create a new `Fragment` instance of the appropriate
    type and insert it into our `FrameLayout` with an `id` value of `fragmentHolder`.
  prefs: []
  type: TYPE_NORMAL
- en: The `transaction.addToBackStack` function call means that the chosen `Fragment`
    will be remembered in order with any others. The result of this is that if the
    user chooses the **Insert** fragment, then the **Results** fragment and then taps
    the back button, the app will return the user to the **Insert** fragment.
  prefs: []
  type: TYPE_NORMAL
- en: You can now run the app and use the navigation drawer menu to flip between all
    our different `Fragment` instances. They will look just as they did in the images
    at the start of this chapter, but they don't have any functionality yet.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how straightforward it is to have an attractive and
    pleasing UI and, although our `Fragment` instances don't have any functionality
    yet, they are set up ready to go once we have learned about databases.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about databases in general, and the specific
    database that Android apps can use, before we add the functionality to our `Fragment`
    classes.
  prefs: []
  type: TYPE_NORMAL
