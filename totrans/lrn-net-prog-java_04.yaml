- en: Chapter 4. Client/Server Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore the process of developing a client/server application
    that is primarily oriented around HTTP. This is an important protocol, and it
    serves as the primary communication medium for a multitude of applications. We
    will examine the protocol, the requirements placed on a client, and the requirements
    placed on a server for various versions of the protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Examine the nature of the HTTP protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Demonstrate how low-level sockets can support the protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `HttpURLConnect` and `HTTPServer` classes to create an HTTP server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examine various open source Java HTTP servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Investigate various configuration issues and how cookies are handled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP servers are used extensively, so a good understanding of how Java supports
    them is important.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP protocol structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTTP is a network protocol that is used to deliver resources across the **World
    Wide Web** (**WWW**). Resources are usually **HyperText Markup Language** (**HTML**)
    files, but they also include a number of other file types, such as images, audio,
    and video. Users often enter a URL into a browser to obtain a resource. The term
    **URL** stands for **Uniform Resource Locator** with the emphasis here on resource.
  prefs: []
  type: TYPE_NORMAL
- en: Most people use a browser to communicate across WWW. The browser represents
    a client application, while the web server responds to client requests. The default
    port used by these servers is port `80`.
  prefs: []
  type: TYPE_NORMAL
- en: '![The HTTP protocol structure](img/B04915_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: HTTP has evolved over the years. HTTP/1.0 originated in the 1980s and 1990s
    with the first documentation released in 1991\. The latest definition of HTTP/1.1
    was released as a six-part specification in June 2014\. A **Request For Comments**
    (**RFC**) for HTTP 2.0 was released in May 2015\. HTTP is an evolving standard.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following links may prove useful for the `interested` reader:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Version | Reference |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| HTTP 1.0 | [http://www.w3.org/Protocols/HTTP/1.0/spec.html](http://www.w3.org/Protocols/HTTP/1.0/spec.html)
    |'
  prefs: []
  type: TYPE_TB
- en: '| HTTP/1.1 | [http://tools.ietf.org/html/rfc2616](http://tools.ietf.org/html/rfc2616)
    |'
  prefs: []
  type: TYPE_TB
- en: '| HTTP/2 | [https://en.wikipedia.org/wiki/HTTP/2](https://en.wikipedia.org/wiki/HTTP/2)
    |'
  prefs: []
  type: TYPE_TB
- en: HTTP servers are used in a variety of situations. The most common use is within
    organizations to support the dissemination of information to users. Often this
    is supported by production-quality servers, such as those provided by the Apache
    Software Foundation ([http://www.apache.org/foundation/](http://www.apache.org/foundation/)),
    or Gemini ([http://www.eclipse.org/gemini/](http://www.eclipse.org/gemini/)).
  prefs: []
  type: TYPE_NORMAL
- en: However, not all servers need to support the level of service typified by production
    servers. They can be quite small and even embedded in remote devices where they
    may affect a change in a device instead of only supplying information.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will examine the various network technologies that are supported
    by Java to address these types of concerns. These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of HTTP protocol syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Low-level socket support for clients/servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `URLConnection` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `HTTPServer` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of open source Java servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP is a complex topic, and we are only able to skim its surface.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Robots**, often called **spiders**, are applications that automatically follow
    links, frequently to collect web pages for use by search engines. If you desire
    to develop such an application, research their use and how they are built ([http://www.robotstxt.org/](http://www.robotstxt.org/)).
    These types of applications can be disruptive if not designed carefully.'
  prefs: []
  type: TYPE_NORMAL
- en: The nature of HTTP messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s examine the format of an HTTP message. Messages are either a request
    message sent from a client to a server, or a response message sent from a server
    to a client. Based on an understanding of the format, we will show you how Java
    supports these messages. HTTP messages are, for the most part, readable by humans.
    Both the request and response messages use this structure:'
  prefs: []
  type: TYPE_NORMAL
- en: A line indicating the type of message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zero or more header lines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A blank line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional message body containing data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example of an HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GET /index HTTP/1.0**'
  prefs: []
  type: TYPE_NORMAL
- en: '**User-Agent: Mozilla/5.0**'
  prefs: []
  type: TYPE_NORMAL
- en: A client request message consists of an initial request line and zero or more
    header lines. A response message consists of an initial response line (called
    the **status line**), zero or more header lines, and an optional message body.
  prefs: []
  type: TYPE_NORMAL
- en: Let's examine these elements in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Initial request line format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The formats of the request and response initial lines differ. The request line
    consists of three parts separated by spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: Request method name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local path of the resource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The HTTP version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method names refer to the action requested by the client. The most common
    method used is the **GET** method, which simply requests that a specific resource
    be returned. The **POST** command is also common and is used to insert and update
    data. A list of HTTP/1.0 methods names is found at [http://www.w3.org/Protocols/HTTP/1.0/spec.html#Methods](http://www.w3.org/Protocols/HTTP/1.0/spec.html#Methods).
    HTTP/1.1 method names can be found at [http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html](http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html).
    Method names are always written in uppercase.
  prefs: []
  type: TYPE_NORMAL
- en: 'The local path typically references the resource desired. It follows the hostname
    in the URL request. For example, in the following URL, the local path is **/books/info/packt/faq/index.html**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**www.packtpub.com/books/info/packt/faq/index.html**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTTP version is always in uppercase and consists of the acronym, HTTP,
    followed by a forward slash, and then the version number:'
  prefs: []
  type: TYPE_NORMAL
- en: '**HTTP/x.x**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of a request initial line:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GET /index HTTP/1.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The response initial line consists of three parts separated by spaces, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A response status code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A response phrase describing the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following line is an example of a response initial line. The response code
    reflects the status of the result and is easily interpreted by a computer. The
    reason phrase is meant to be human readable.
  prefs: []
  type: TYPE_NORMAL
- en: '**HTTP/1.0 404 Not Found**'
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP version uses the same format that is used for the request line.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table contains a list of more commonly used codes. A complete
    list can be found at [https://en.wikipedia.org/wiki/List_of_HTTP_status_codes](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes):'
  prefs: []
  type: TYPE_NORMAL
- en: '| Status code | Standard text | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `200` | **OK** | This indicates that the request was a success |'
  prefs: []
  type: TYPE_TB
- en: '| `301` | **Moved Permanently** | This indicates that the URL has been moved
    permanently and the link should be updated |'
  prefs: []
  type: TYPE_TB
- en: '| `302` | **Found** | This indicates that the resource is temporarily located
    somewhere else, but the URL should still be used |'
  prefs: []
  type: TYPE_TB
- en: '| `307` | **Temporary Redirect** | This is similar to `302`, but the method
    used should not be changed, which may happen with `302` |'
  prefs: []
  type: TYPE_TB
- en: '| `308` | **Permanent Redirect** | This is similar to `301`, but the method
    used should not be changed, which may happen with `301` |'
  prefs: []
  type: TYPE_TB
- en: '| `400` | **Bad Request** | This indicates that request access was incorrect
    |'
  prefs: []
  type: TYPE_TB
- en: '| `401` | **Unauthorized** | This indicates that the resource is restricted
    often because the login attempt failed |'
  prefs: []
  type: TYPE_TB
- en: '| `403` | **Forbidden** | This indicates that access to the requested resource
    is forbidden |'
  prefs: []
  type: TYPE_TB
- en: '| `404` | **Not Found** | This indicates that the resource is no longer available
    |'
  prefs: []
  type: TYPE_TB
- en: '| `500` | **Internal server error** | This reflects some sort of error with
    the server |'
  prefs: []
  type: TYPE_TB
- en: '| `502` | **Bad Gateway** | This indicates that the gateway server received
    an invalid response from another server |'
  prefs: []
  type: TYPE_TB
- en: '| `503` | **Service Unavailable** | This indicates that the server is not available
    |'
  prefs: []
  type: TYPE_TB
- en: '| `504` | **Gateway Timeout** | This indicates that the gateway server did
    not receive a response from another server in a timely manner |'
  prefs: []
  type: TYPE_TB
- en: 'The status code is a three-digit number. The first digit of this number reflects
    the category of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '1xx: This represents an informational message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '2xx: This represents a success'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '3xx: This redirects the client to another URL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '4xx: This represents a client error'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '5xx: This represents a server error'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Header lines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Headers lines provide information regarding the request or response, such as
    the e-mail address of the sender, and an application identifier. The header consists
    of a single line. The format of this line starts with the header identifier, followed
    by a colon, spaces, and then the value assigned to the header. The following header
    illustrates the `User-Agent` header that is used by Firefox 36.0\. This header
    identifies the application as the Firefox browser running on a Windows platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User-Agent: Mozilla/5.0 (Windows NT 6.3; rv:36.0) Gecko/20100101 Firefox/36.0**'
  prefs: []
  type: TYPE_NORMAL
- en: A list of header fields and descriptions is found at [https://en.wikipedia.org/wiki/List_of_HTTP_header_fields](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields).
    A list of agent strings can be found at [http://useragentstring.com/pages/useragentstring.php](http://useragentstring.com/pages/useragentstring.php).
  prefs: []
  type: TYPE_NORMAL
- en: HTTP 1.0 defines 16 headers ([http://www.w3.org/Protocols/HTTP/1.0/spec.html#HeaderFields](http://www.w3.org/Protocols/HTTP/1.0/spec.html#HeaderFields)),
    while HTTP 1.1 has 47 headers ([http://tools.ietf.org/html/rfc2616#section-14](http://tools.ietf.org/html/rfc2616#section-14)).
    Its `Host` header is required.
  prefs: []
  type: TYPE_NORMAL
- en: Headers are useful in helping troubleshoot problems when they occur. It is a
    good idea to include the `From` and `User-Agent` headers for requests so that
    the server can be in a better position to respond to the request.
  prefs: []
  type: TYPE_NORMAL
- en: Message body
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the data constituting the message. While normally a message body is
    included, it is optional and is not needed for some messages. When a body is included,
    the `Content-Type` and `Content-Length` headers are included to provide more information
    about the body.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following headers can be used for a message body:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Content-type: text/html**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Content-length: 105**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The message body may appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**<html><h1>HTTPServer Home Page.... </h1><br><b>Welcome to the new and improved
    web server!</b><BR></html>**'
  prefs: []
  type: TYPE_NORMAL
- en: Client/Server interaction example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following interaction is a simple demonstration of a client sending a request
    and the server responding. The client request message uses the `GET` method against
    a path of `\index`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GET /index HTTP/1.0**'
  prefs: []
  type: TYPE_NORMAL
- en: '**User-Agent: Mozilla/5.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The server will respond with the following message, assuming that it was able
    to process the request. The `Server`, `Content-Type`, and `Content-Length` headers
    are used. A blank line separates the headers and the HTML message body:'
  prefs: []
  type: TYPE_NORMAL
- en: '**HTTP/1.0 200 OK**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Server: WebServer**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Content-Type: text/html**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Content-Length: 86**'
  prefs: []
  type: TYPE_NORMAL
- en: '**<html><h1>WebServer Home Page.... </h1><br><b>Welcome to my web server!</b><BR></html>**'
  prefs: []
  type: TYPE_NORMAL
- en: Other headers lines can be included.
  prefs: []
  type: TYPE_NORMAL
- en: Java socket support for HTTP client/server applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An HTTP client will make a connection to an HTTP server. The client will send
    a request message to the server. The server will send back a response message,
    frequently, as an HTML document. In the early HTTP version, once the response
    was sent, the server would terminate the connection. This is sometimes referred
    to as a stateless protocol because the connection is not maintained.
  prefs: []
  type: TYPE_NORMAL
- en: With HTTP/1.1, persistent connections can be maintained. This improves the performance
    by eliminating the need to open and close connections when multiple pieces of
    data need to be transferred between the server and a client.
  prefs: []
  type: TYPE_NORMAL
- en: We will focus on creating an HTTP server and an HTTP client. While browsers
    typically serve as HTTP clients, other applications can also access web servers.
    In addition, it helps illustrate the nature of HTTP requests. Our server will
    support a subset of the HTTP/1.0 specification.
  prefs: []
  type: TYPE_NORMAL
- en: Building a simple HTTP server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use a class called `WebServer` to support the HTTP/1.0 protocol. The
    server will use a `ClientHandler` class to handle a client. The server will be
    limited to handling only GET requests. However, this will be adequate to illustrate
    the basic server elements needed. Support of other methods can be easily added.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `WebServer` definition is shown next. The `ServerSocket` class is the foundation
    of the server. Its `accept` method will block until a request is made. When this
    happens, a new thread based on the `ClientHandler` class will be started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Mac users may encounter an error when using port `80`. Use port `3000` or `8080`
    instead. Threads are concurrently executing sequences of code within a process.
    In Java, a thread is created using the `Thread` class. The constructor''s argument
    is an object that implements the `Runnable` interface. This interface consists
    of a single method: `run`. When the thread is started using the `start` method,
    a separate program stack is created for the new thread, and the `run` method executes
    on this stack. When the `run` method terminates, the thread terminates. The `ClientHandler`
    class, shown next, implements the `Runnable` interface. Its constructor is passed
    to the socket representing the client. When the thread starts, the `run` method
    executes. The method displays, starting and terminating messages. The actual work
    is performed in the `handleRequest` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `handleRequest` method uses the input and output streams to communicate
    with the server. In addition, it determines what request was made and then processes
    that request.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the code that follows, the input and output streams are created and the
    first line of the request is read. The `StringTokenizer` class is used to token
    this line. When the `nextToken` method is invoked, it returns the first word of
    the line, which should correspond to an HTTP method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: A tokenizer is a process that splits text into a series of tokens. Frequently,
    these tokens are simple words. The `StringTokenizer` class's constructor is passed
    the text to be tokenized. The `nextToken` method will return the next available
    token.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next code sequence handles the `GET` method. A message is displayed on
    the server side to indicate that a `GET` method is being processed. This server
    will return a simple HTML page. The page is built using the `StringBuilder` class
    where the `append` methods are used in a fluent style. The `sendResponse` method
    is then invoked to actually send the response. If some other method was requested,
    then a `405` status code is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to handle other methods, then a series of else-if clauses can
    be added. To further process the `GET` method, we will need to parse the remainder
    of the initial request line. The following statement will give us a string that
    we can process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The previous statement is not needed for this example and should not be included
    in the code. It simply offers one possible way of further processing HTTP queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have created a response, we will use the `sendResponse` method to send
    it to the client as shown next. This method is passed the socket, a status code,
    and the response string. An output stream is then created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If the status code is `200`, then a simple HTML page is returned. If the status
    code is `405`, then a single status code line is returned. Otherwise, a `404`
    response is sent. As we used the `DataOutputStream` class to write, we use its
    `writeBytes` method to handle strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When the server starts, it will display the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connection made**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Waiting for client request**'
  prefs: []
  type: TYPE_NORMAL
- en: 'When a client makes a `GET` request, output similar to the following one will
    be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ClientHandler Started for Socket[addr=/127.0.0.1,port=50573,localport=80]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Get method processed**'
  prefs: []
  type: TYPE_NORMAL
- en: '**ClientHandler Terminated for Socket[addr=/127.0.0.1,port=50573,localport=80]**'
  prefs: []
  type: TYPE_NORMAL
- en: With a simple server in place, let's take a look at how we can build an HTTP
    client application.
  prefs: []
  type: TYPE_NORMAL
- en: Building a simple HTTP client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use the following `HTTPClient` class to access our HTTP server. In
    its constructor, a socket connecting to the server is created. The `Socket` class''s
    `getInputStream` and `getOutputStream` return input and output streams for the
    socket, respectively. The `sendGet` method is called, which sends a request to
    the server. The `getResponse` method returns the response, which is then displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sendGet` method follows this, which sends a `GET` method request using
    a simple path. This is followed by a`User-Agent` header. We used an instance of
    the `OutputStream` class with the `write` method. The `write` method requires
    an array of bytes. The `String` class''s `getBytes` method returns this array
    of bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getResponse` method is as follows and is passed a `BufferedReader` instance
    to get the response from the server. It returns a string created using the `StringBuilder`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When the client application executes, we get the following output reflecting
    the server''s response:'
  prefs: []
  type: TYPE_NORMAL
- en: '**HTTP Client Started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HTTP/1.0 200 OK**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Server: WebServer**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Content-Type: text/html**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Content-Length: 86**'
  prefs: []
  type: TYPE_NORMAL
- en: '**<html><h1>WebServer Home Page.... </h1><br><b>Welcome to my web server!</b><BR></html>**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use the same request from a browser, we will get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a simple HTTP client](img/B04915_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: These client and server applications can be further enhanced. However, we can
    use the `HttpURLConnection` class to achieve similar results.
  prefs: []
  type: TYPE_NORMAL
- en: Client/server development using standard Java classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Specifically, we will use the `HttpURLConnection` and `HTTPServer` classes to
    implement a client and server application. These classes support much of the functionality
    required for clients and servers. Using these classes will avoid writing low-level
    code to implement HTTP functionality. Low-level code refers to the non-specialized
    classes, such as the `Socket` class. Higher-level and more specialized classes,
    such as the `HttpURLConnection` and `HTTPServer` classes, supplement and provide
    additional support for specialized operations.
  prefs: []
  type: TYPE_NORMAL
- en: The `HttpURLConnection` class is derived from the `HttpConnection` class. This
    base class has a number of methods that not are directly concerned with the HTTP
    protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Using the HttpURLConnection class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `HttpURLConnection` class provides a convenient technique to access a web
    server. With this class, we can connect to a site, make a request, and access
    the respond headers and the response message.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the `HttpURLConnectionExample` class that is defined as follows.
    A `sendGet` method supports transmitting the `GET` method request to the server.
    The `HttpURLConnectionExample` class supports other HTTP methods. For this example,
    we are only using the `GET` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sendGet` method implementation is shown next. A Google query ([http://www.google.com/search?q=java+sdk&ie=utf-8&oe=utf-8](http://www.google.com/search?q=java+sdk&ie=utf-8&oe=utf-8))
    is used to illustrate the process where we search for "java sdk". The latter part
    of the query, `&ie=utf-8&oe=utf-8`, is additional information attached to the
    query by the Google search engine. The `openConnection` method will connect to
    the Google server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this connection, the `setRequestMethod` and `setRequestProperty` methods
    set the request method and user agent, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The response code is retrieved, and if we are successful, the `getResponse`
    method will retrieve the response and then display it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getResponse` method is shown next. The `HttpURLConnection` class''s `getInputStream`
    method returns an input stream, which is used to create an instance of the `BufferedReader`
    class. A `StringBuilder` instance is used along with this reader to create and
    return a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When this program executes, you will get output as follows. Due to the length
    of the output, it has been truncated:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sent Http GET request**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Response Code: 200**'
  prefs: []
  type: TYPE_NORMAL
- en: '**response: <!doctype html><html itemscope="" ...**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we used this query in a browser, we will get output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the HttpURLConnection class](img/B04915_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A very interesting discussion of how to use the `URLConnection` class to deal
    with HTTP requests can be found at [http://stackoverflow.com/questions/2793150/using-java-net-urlconnection-to-fire-and-handle-http-requests](http://stackoverflow.com/questions/2793150/using-java-net-urlconnection-to-fire-and-handle-http-requests).
  prefs: []
  type: TYPE_NORMAL
- en: URL encoding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a URL is formed, a specific URL format needs to be used. Some of the characters
    of this format are reserved and others are unreserved. Reserved characters have
    special meaning, such as the forward slash, which is used to separate parts of
    a URL. Unreserved characters do not have any special meaning.
  prefs: []
  type: TYPE_NORMAL
- en: When a reserved character needs to be used in a non-reserved context, URL encoding,
    also known as percent-encoding, is used to represent these characters using special
    character sequences. More information about this process can be found at [https://en.wikipedia.org/wiki/Percent-encoding](https://en.wikipedia.org/wiki/Percent-encoding).
  prefs: []
  type: TYPE_NORMAL
- en: In Java, we can perform URL encoding using the `URLEncoder` class. Specifically,
    the `URLEncoder` class has an `encode` method to convert a string that complies
    with the `application/x-www-form-url` encoded MIME format.
  prefs: []
  type: TYPE_NORMAL
- en: This method is overloaded. The single argument method has been deprecated. The
    two-argument method accepts a string to be converted and a string that specifies
    the character encoding scheme. For HTTP messages, use the UTF-8 format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Previously, we used the following string to create a new URL instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This string was actually formatted by the browser. Instead of using the browser,
    the following code illustrates how to use the `encode` method to achieve similar
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce the string: `http://www.google.com/search?q=java+sd`. You
    can see how the blanks have been converted to `+` symbols for this URL. The latter
    part of the original query, `&ie=utf-8&oe=utf-8`, is not included in our URL encoded
    string.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `URLDecoder` class is available to decode URL encoded strings if necessary.
    For a comprehensive discussion of URL encoding, see: [http://blog.lunatech.com/2009/02/03/what-every-web-developer-must-know-about-url-encoding](http://blog.lunatech.com/2009/02/03/what-every-web-developer-must-know-about-url-encoding).'
  prefs: []
  type: TYPE_NORMAL
- en: Using the HTTPServer class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `HTTPServer` class is found in the `com.sun.net.httpserver` package. It
    provides a powerful set of features to support a simple HTTP server. Many of the
    tasks that we had to perform manually with our previous servers are simplified
    with this server. The interaction between a client and server is referred to as
    an exchange.
  prefs: []
  type: TYPE_NORMAL
- en: This and other supporting classes and interfaces are members of the `com.sun.net.httpserver`
    package. They are normally included with most IDEs. The API documentation can
    be found at [http://docs.oracle.com/javase/8/docs/jre/api/net/httpserver/spec/index.html?com/sun/net/httpserver/package-summary.html](http://docs.oracle.com/javase/8/docs/jre/api/net/httpserver/spec/index.html?com/sun/net/httpserver/package-summary.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'This package consists of a number of classes. The primary classes that we will
    use include:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Class/interface | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `HttpServer` | This class supports the basic functionality of an HTTP server
    |'
  prefs: []
  type: TYPE_TB
- en: '| `HttpExchange` | This class encapsulates the request and response associated
    with a client/server exchange |'
  prefs: []
  type: TYPE_TB
- en: '| `HttpHandler` | This class defines a handle method used to process specific
    exchanges |'
  prefs: []
  type: TYPE_TB
- en: '| `HttpContext` | This class maps a URI path to an `HttpHandler` instance |'
  prefs: []
  type: TYPE_TB
- en: '| `Filter` | This class supports the preprocessing and post-processing of requests
    |'
  prefs: []
  type: TYPE_TB
- en: The server uses an `HttpHandler` derived class to process client requests. For
    example, one handler can process requests for basic web pages, while another handler
    may process service related requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `HttpExchange` class supports the life-cycle activities of an exchange
    between a client and a server. It possesses a number of methods providing access
    to request and response information. These methods are listed in the following
    table in the order that they are normally used. Not all methods need to be used
    for all requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `getRequestMethod` | This method returns the HTTP method requested |'
  prefs: []
  type: TYPE_TB
- en: '| `getRequestHeaders` | This method returns the request headers |'
  prefs: []
  type: TYPE_TB
- en: '| `getRequestBody` | This method returns an `InputStrea` `m` instance for the
    request body |'
  prefs: []
  type: TYPE_TB
- en: '| `getResponseHeaders` | This method returns the response headers except for
    content-length |'
  prefs: []
  type: TYPE_TB
- en: '| `sendResponseHeaders` | This method sends the response headers |'
  prefs: []
  type: TYPE_TB
- en: '| `getResponseBody` | This method returns an `OutputStream` instance used to
    send the response |'
  prefs: []
  type: TYPE_TB
- en: An exchange is closed when the input and output streams are closed. The `sendResponseHeaders`
    method must be used before the `getResponseBody` method is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The performance of the initial version of this class was not very good. However,
    newer versions have better performance. In addition, the filter facility can assist
    in processing exchanges.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `com.sun.*` classes can be used without concerns. Problems can occur
    if the `sun.*` classes are used with different JREs. The `HTTPServer` class fully
    supports HTTP/1.0, but it only provides partial support for HTTP/1.1.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a simple HTTPServer class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The class that follows implements a simple server using the `HTTPServer` class.
    An instance of the `HttpServer` class is created using the localhost and port
    `80` (`3000` or `8080` on a Mac). The `createContext` method associates the `/index`
    path with an instance of the `IndexHandler` class. This handler will process the
    request. The `start` method starts the server. The server will continue running,
    processing multiple requests until it is manually stopped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: When the `createContext` method matches the path expressed as a string to a
    handler, it uses a specific matching process. The details of this process are
    explained in the *Mapping request URIs to HttpContext paths* section of the `HTTPServer`
    class documentation found at [http://docs.oracle.com/javase/8/docs/jre/api/net/httpserver/spec/com/sun/net/httpserver/HttpServer.html](http://docs.oracle.com/javase/8/docs/jre/api/net/httpserver/spec/com/sun/net/httpserver/HttpServer.html).
  prefs: []
  type: TYPE_NORMAL
- en: The `IndexHandler` class is declared next. It implements the `HttpHandler` interface
    by overriding the `handle` method. The `handle` method is passed an `HttpExchange`
    instance, which we can use to process the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this method, we perform the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Display the address of the client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send back a request with a status code of `200`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send the response to the client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `sendResponseHeaders` method will send an initial response line for status
    code `200` and a header for the content length. The `getResponseBody` method returns
    an output stream used to send the message body. The stream is then closed terminating
    the exchange:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sendResponseHeaders` method uses two parameters. The first is the response
    code, and the second controls the transmission of the message body, as detailed
    in the next table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Greater than zero | This is the length of the message. The server must send
    this number of bytes. |'
  prefs: []
  type: TYPE_TB
- en: '| Zero | This is used for chunked transfer where an arbitrary number of bytes
    is sent. |'
  prefs: []
  type: TYPE_TB
- en: '| -1 | This is when no response body is sent. |'
  prefs: []
  type: TYPE_TB
- en: 'The `getResponse` method uses the `StringBuilder` class to construct a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When the server is started, the following output is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**MyHTTPServer Started**'
  prefs: []
  type: TYPE_NORMAL
- en: If we enter the URL `http://127.0.0.1/index` in a browser, the browser will
    display the page similar to the one in the image in the section *Building a simple
    HTTP client*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The server will display the following for each request:'
  prefs: []
  type: TYPE_NORMAL
- en: '**/127.0.0.1:50273**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This class is instrumental in processing client requests. Here, we will illustrate
    several of this class''s methods using a different handler called `DetailHandler`,
    as declared next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To use this handler, replace the `createContext` method, and call in the `MyHTTPServer`
    with this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Let's start by examining the use of the `getRequestHeaders` method, which returns
    an instance of the `Headers` class. This will permit us to display each request
    header sent by the client and perform additional processing based on the headers
    if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `handle` method. The `keyset` method returns
    a `Set` of key/values pairs for each header. In the for-each statement, the `Set`
    interface''s `get` method returns a list of values for each header. This list
    is used to display the headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the previous URL (`http://127.0.0.1/index`) from the Firefox browser,
    we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Accept-encoding = [gzip, deflate]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Accept = [text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connection = [keep-alive]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Host = [127.0.0.1]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**User-agent = [Mozilla/5.0 (Windows NT 10.0; WOW64; rv:40.0) Gecko/20100101
    Firefox/40.0]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Accept-language = [en-US,en;q=0.5]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cache-control = [max-age=0]**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a different browser may return a different set of request headers. The
    `getRequestMethod` method returns the name of the request method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We can use this to differentiate between client requests.
  prefs: []
  type: TYPE_NORMAL
- en: Some request methods will pass a message body along with the request. The `getRequestBody`
    method will return an `InputStream` instance to access this body.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code illustrates how we can obtain and display the message body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As our request did not have a body, nothing is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Managing response headers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The server can send back response headers using the `sendResponseHeaders` method.
    However, these headers need to be created using a combination of the `getResponseHeaders`
    method and the `set` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next code sequence, the `getResponseHeaders` method will return an instance
    of the `Header` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `getResponse` method to get our response. We will need this to compute
    the content length. The `set` method is then used to create **Content-Type** and
    **Server** headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The headers are sent using the `sendResponseHeaders` method described earlier,
    shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'These response headers can be displayed using the following code sequence.
    This performs the same functionality as the for-each statement that we used to
    display the request headers. However, this implementation uses a Java 8 Stream
    class and two lambda expressions instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This implementation uses a stream. The `stream` method returns the keys found
    in the set. The `map` method processes each key using it to look up a list of
    values associated with the key. The list is converted into a string. The `forEach`
    method will then display each of these strings.
  prefs: []
  type: TYPE_NORMAL
- en: The `HTTPServer`, and its accompanying classes provide a simple, but convenient
    to use technique to implement an HTTP server. Support is also provided for secure
    communications using the `HttpsServer` class, which is discussed in [Chapter 8](ch08.html
    "Chapter 8. Network Security"), *Network Security*.
  prefs: []
  type: TYPE_NORMAL
- en: Open source Java HTTP servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While we can develop a web server using any of the technologies discussed in
    this chapter, another option is to use any of a number of open source Java-based
    HTTP servers. Such servers frequently provide a number of features, including:'
  prefs: []
  type: TYPE_NORMAL
- en: Full compliancy with HTTP standards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for logging and monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling of virtual hosts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance tuning capability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chunked data transfer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configurability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for NIO (Grizzly)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Leveraging these systems can save you a lot of time and effort that would otherwise
    be devoted to building a custom server. A partial list of a few Java-based servers
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Jakarta Tomcat ([http://tomcat.apache.org/](http://tomcat.apache.org/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jetty ([http://www.eclipse.org/jetty/](http://www.eclipse.org/jetty/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JLHTTP ([http://www.freeutils.net/source/jlhttp/](http://www.freeutils.net/source/jlhttp/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GlassFish ([https://glassfish.java.net/](https://glassfish.java.net/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grizzly ([https://grizzly.java.net/](https://grizzly.java.net/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple ([http://www.simpleframework.org/](http://www.simpleframework.org/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One list of open source Java servers is found at [http://java-source.net/open-source/web-servers](http://java-source.net/open-source/web-servers).
  prefs: []
  type: TYPE_NORMAL
- en: At a higher level, Java EE is frequently used to support Web Servers. While
    this edition has evolved over the years, servlets form the basis to handle web
    requests. A servlet is a Java application that hides much of the detail surrounding
    the low-level processing of requests and responses. This permits the developer
    to focus on processing requests.
  prefs: []
  type: TYPE_NORMAL
- en: Servlets are held in containers that provide support for tasks, such as database
    access, managing performance, and providing security. A simple servlet is shown
    next to give you a feel as to how they are structured.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `doGet` and `doPost` methods handle `GET` and `POST` type messages, respectively.
    However, as the differences between these two HTTP messages are hidden, only one
    is needed. The `HttpServletRequest` class represents an HTTP request and the `HttpServletResponse`
    class represents the response. These classes provide access to the messages. For
    example, the `getWriter` method returns a `PrintWriter` class instance, which
    allows us to write the HTML response in a clearer fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Servlets are normally developed using the Java EE SDK. The previous example
    will not compile correctly unless developed using this API.
  prefs: []
  type: TYPE_NORMAL
- en: Many technologies have evolved and have hidden servlets. Over the years, this
    has included **JavaServer Pages** (**JSP**) and **JavaServer Faces** (**JSF**),
    which have largely eliminated the need to write servlets directly.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of web servers for Java. A comparison of some of these is
    found at [https://en.wikipedia.org/wiki/Comparison_of_application_servers#Java](https://en.wikipedia.org/wiki/Comparison_of_application_servers#Java).
  prefs: []
  type: TYPE_NORMAL
- en: Server configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The configuration of a server depends on the technology that was used to build
    it. Here, we will focus on the configuration of the `URLConnection` class. This
    class has a number of protected fields that control how the connection behaves.
    These fields are accessed using corresponding get and set methods.
  prefs: []
  type: TYPE_NORMAL
- en: One field deals with user interactions. When set to `true`, it allows users
    to engage in interactions, such as responding to an authentication dialog box.
    A connection can be used for input and/or output. The connection can be configured
    to disallow input or output.
  prefs: []
  type: TYPE_NORMAL
- en: When data is transferred between a client and a server, it may be cached. The
    `UseCaches` variable determines whether caches are ignored or not. If set to `true`,
    then caches are used as appropriate. If `false`, caching is not performed.
  prefs: []
  type: TYPE_NORMAL
- en: The `ifModifiedSince` variable controls whether the retrieval of an object occurs.
    It is a long value that represents time as the number of milliseconds since the
    epoch (January 1, 1970, GMT). If the object has been modified more recently than
    that time, then it is fetched.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table summarizes the methods that are used to configure a connection
    established using the `URLConnection` class. Each of these methods have a corresponding
    `GET` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Default | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `setAllowUserInteraction` | NA | This method controls user interaction |'
  prefs: []
  type: TYPE_TB
- en: '| `setDoInput` | `true` | If its argument is set to `true`, then input is allowed
    |'
  prefs: []
  type: TYPE_TB
- en: '| `setDoInput` | `true` | If its argument is set to `true`, then output is
    allowed |'
  prefs: []
  type: TYPE_TB
- en: '| `setIfModifiedSince` | NA | This sets the `ifModifiedSince` variable |'
  prefs: []
  type: TYPE_TB
- en: '| `setUseCaches` | `true` | This sets the `UseCaches` variable |'
  prefs: []
  type: TYPE_TB
- en: More sophisticated servers, such as Tomcat, have many more options to control
    how it is configured.
  prefs: []
  type: TYPE_NORMAL
- en: When an application is deployed, there are numerous configuration options found
    in the `deployment.properties` file. Many of these options are low level, and
    JRE related. A description of the options is found at [https://docs.oracle.com/javase/8/docs/technotes/guides/deploy/properties.html](https://docs.oracle.com/javase/8/docs/technotes/guides/deploy/properties.html).
    The *21.2.4 Networking* section discusses the network options, while the *21.2.5
    Cache and Optional Package Repository* section is concerned with the configuration
    of caches.
  prefs: []
  type: TYPE_NORMAL
- en: An **HTTP proxy** is a server that acts as an intermediary between a client
    and a server. A proxy is frequently used to manage the network, monitor traffic,
    and improve network performance.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, we are not concerned with the use or configuration of a proxy. However,
    if a proxy needs to be configured, we can control it either using the JVM command
    line or within the code using the `System` class's `getProperties` method. We
    can control the proxy used and specify the user and password to access it if needed.
    A short discussion of these capabilities is found at [http://viralpatel.net/blogs/http-proxy-setting-java-setting-proxy-java/](http://viralpatel.net/blogs/http-proxy-setting-java-setting-proxy-java/).
  prefs: []
  type: TYPE_NORMAL
- en: Handling cookies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A cookie is a string containing a key/value pair representing information of
    interest to the server such as user preferences. It is sent from a server to a
    browser. The browser should save the cookie to a file so that it can be used later.
  prefs: []
  type: TYPE_NORMAL
- en: 'A cookie is a string that consists of a name followed by an equal sign and
    then a value. The following is one possible cookie:'
  prefs: []
  type: TYPE_NORMAL
- en: '**userID=Cookie Monster**'
  prefs: []
  type: TYPE_NORMAL
- en: A cookie can have multiple values. These values will be separated by a semicolon
    and white space.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the `HTTPServer` class and the `HttpURLConnection` classes to demonstrate
    the handling of cookies. In the `MyHTTPServer` class server''s handler class''s
    `handle` method, add the following code after the other headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When the server responds, it will send that cookie.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `HttpURLConnectionExample` class''s `getResponse` method, add the following
    code at the beginning of its try block. A string is built containing the cookie
    text. Multiple `substring` and `indexOf` methods are used to extract the cookie''s
    name and then its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'When the server sends a response, it will include the cookie. The client will
    then receive the cookie. In the server and the client, you should see the following
    output displaying the cookie:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Set-cookie : [userID=Cookie Monster]**'
  prefs: []
  type: TYPE_NORMAL
- en: The previous example handles simple single-value cookies. The code to handle
    multiple values is left as an exercise for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we examined the various Java approaches that can be used to
    develop HTTP client/server applications. Communication using HTTP is a common
    practice. Understanding how Java supports this process is a valuable skill to
    possess.
  prefs: []
  type: TYPE_NORMAL
- en: We started with an overview of HTTP messages. We examined the format of the
    initial request and response lines. Headers lines were also examined, which are
    used to convey information about the message. An optional message body may appear
    in an HTTP message. This is more common in a response where the body is often
    an HTML document.
  prefs: []
  type: TYPE_NORMAL
- en: We demonstrated how a client/server can be developed using simple socket. While
    possible, this approach requires a lot of work to develop a fully functional HTTP
    server. This discussion was followed by the use of the `HTTPServer` and `HttpURLConnection`
    classes to support a server and client, respectively. The use of these classes
    made the development process much easier.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of open source Java-based HTTP servers available. These may
    be viable candidates for some environments. The more complex web servers, typified
    by Apache Tomcat, were also discussed. They work with servlets and hide much of
    the low-level HTTP details from the developer.
  prefs: []
  type: TYPE_NORMAL
- en: We wrapped the chapter up with a brief discussion of server configuration issues
    and how cookies are created and consumed by servers and clients.
  prefs: []
  type: TYPE_NORMAL
- en: While the client/server architecture is very common, the peer-to-peer architecture
    is an alternative to share information across a network. We will delve into this
    topic in the next chapter.
  prefs: []
  type: TYPE_NORMAL
