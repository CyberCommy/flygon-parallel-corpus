- en: User Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will take a more detailed look at QML and sketch out our
    user interface layout. We’ll create placeholder views for all of our screens and
    implement a framework to navigate between them. We will also discuss the content
    within those views, specifically how to anchor and size elements in a flexible
    and responsive way. We will cover these topics:'
  prefs: []
  type: TYPE_NORMAL
- en: User interface design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The StackView component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anchoring elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sizing elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating between views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’ve ever worked with other declarative UI technologies like HTML and XAML,
    they often take a parent/child approach to UI, that is, there is a parent or root
    view that is ever present and contains global functionality, such as top-level
    navigation. It then has dynamic content or child views, which switch in and out
    as needed and present context sensitive commands where necessary.
  prefs: []
  type: TYPE_NORMAL
- en: We will take the same approach, with our MasterView being the root of our UI.
    We will add a global navigation bar and a content pane where we can add and remove
    content as needed. Child views will optionally present a command bar for performing
    actions, for example, saving a record to a database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the basic layout we are aiming for:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f05c5d3-5098-498d-8980-8d761e081b46.png)'
  prefs: []
  type: TYPE_IMG
- en: The Navigation Bar (**1**) will be ever present and contain buttons that will
    navigate the user to key areas within the application. By default, the bar will
    be narrow and the commands associated with the buttons will be represented by
    icons; however, pressing a toggle button will expand the bar to display accompanying
    descriptive text for each button.
  prefs: []
  type: TYPE_NORMAL
- en: The Content Pane (**2**) will be a stack of child views. Navigating to different
    areas of the application will be achieved by replacing the child view in the content
    pane. For example, if we add a New Client button on the navigation bar and press
    it, we will push the **New Client View** onto the content frame stack.
  prefs: []
  type: TYPE_NORMAL
- en: The Command Bar (**3**) is an optional element that will be used to present
    further command buttons to the user. The key difference to the navigation bar
    is that these commands will be context sensitive relating to the current view.
    For example, when creating a new client, we will need a Save button, but when
    we are searching for clients, a Save button makes no sense. Each child view will
    optionally present its own command bar. The commands will be presented by icons
    with a short description underneath.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s plan the flow of screens, or views as we’ll call them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88cb4886-bef2-4acf-8fec-17b997c55f39.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In **cm-ui**, right-click on `views.qrc` and select Add New…. Select Qt > QML
    File and click on Choose...:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ccb03d0d-cb3b-4bd8-ae67-41aa6e02c9c6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create the `SplashView.qml` file in `cm-ui/ui/views`. Repeat this process until
    you’ve created all the following views:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **File** | **Purpose** |'
  prefs: []
  type: TYPE_TB
- en: '| `SplashView.qml` | Placeholder view displayed while the UI is loading. |'
  prefs: []
  type: TYPE_TB
- en: '| `DashboardView.qml` | The central “home” view. |'
  prefs: []
  type: TYPE_TB
- en: '| `CreateClientView.qml` | View for entering details of a new client. |'
  prefs: []
  type: TYPE_TB
- en: '| `EditClientView.qml` | View for reading/updating the existing client details.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `FindClientView.qml` | View for searching for the existing clients. |'
  prefs: []
  type: TYPE_TB
- en: 'Edit `views.qrc` in the Plain Text Editor as we have done previously. You will
    see that our new views have been added to a new `qresource` block with the default
    prefix of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Also note that the Projects navigator is a bit of a mess:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a8cda8d-a97a-4137-9b5e-b475274183ae.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Move all the new files into the `“/views”` prefix block and remove the `“/”`
    block. Add an alias for each of the new files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you save these changes, you should see the navigator clean right
    up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e95063e4-88c2-4ce9-8d72-943414f8359e.png)'
  prefs: []
  type: TYPE_IMG
- en: StackView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our child views will be presented via a **StackView** component, which provides
    a stack-based navigation model with built-in history. New views (and views in
    this context means pretty much any QML) are pushed onto the stack when they are
    to be displayed and can be popped off the stack in order to go back to the previous
    view. We won’t need to use the history capabilities, but they are a very useful
    feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'To gain access to the component, we first need to reference the module, so
    add the import to **MasterView**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'With that done, let’s replace our **Text** element containing our welcome message
    with a `StackView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We assign the component a unique identifier `contentFrame` so that we can reference
    it elsewhere in the QML, and we specify which child view we want to load by default—the
    new `SplashView`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, edit `SplashView`. Update the `QtQuick` module version to 2.9 so that
    it matches **MasterView** (do this for all further QML files if not explicitly
    stated). This is not strictly necessary, but it's a good practice to avoid inconsistencies
    across views. There is generally not much in the way of breaking changes in minor
    releases of Qt, but the same code on two views referencing different versions
    of QtQuick may exhibit different behavior that can cause problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we’ll do with this view, for now, is to make a rectangle 400 pixels wide
    by 200 pixels high, which has a “vibrant” background color so that we can see
    that it has loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Colors can be specified using hexadecimal RGB values as we did here, or named
    SVG colors. I generally find hex easier as I can never remember the names of the
    colors!
  prefs: []
  type: TYPE_NORMAL
- en: If you hover your cursor over the hex string in Qt Creator, you get a really
    useful little pop-up color swatch.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the application, and you should see that the welcome message no longer
    displays and instead, you are presented with a glorious orange-yellow rectangle,
    which is our **SplashView**.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/95abb8ea-4155-403a-85f6-5cd98845a7d4.png)'
  prefs: []
  type: TYPE_IMG
- en: Anchors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One slight problem with our wonderful new **SplashView** is that it doesn’t
    actually fill the window. Sure, we can change the 400 x 200 dimensions to 1024
    x 768 so that it matches **MasterView**, but then what happens if the user resizes
    the window? Modern UI is all about responsive design—dynamic content that can
    adapt to the display it’s being presented on, so hard-coding properties appropriate
    for only one platform aren’t ideal. Fortunately, anchors come to our rescue.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s put our trusty old **scratchpad** project to use and take a look at anchors
    in action.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on `qml.qrc` and add a new `AnchorsDemo.qml` QML file alongside
    the existing `main.qml` file in the `scratchpad` folder. Don’t worry about subfolders
    or `.qrc` prefixes, aliases, or any of that jazz.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dip into `main.cpp` and load our new file instead of `main.qml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, paste the following code into `AnchorsDemo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Build and run the application, and you’ll be presented with this rather bewildering
    sight:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9a0d9a2-5955-42c5-9096-0b79882dc347.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This may all look a bit confusing at first and I apologize if your color perception
    is suboptimal, but all we’ve done is draw a sequence of gaudily colored rectangles
    with differing anchors values. Let’s walk through each rectangle one by one and
    see what is going on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Our first rectangle is the dull yellow brown background; `anchors.fill: parent`
    tells the rectangle to fill its parent, however big that may be. The parent of
    any given QML component is the QML component that contains it—the next level up
    in the hierarchy. In this case, it is the **Window** element. The **Window** element
    is 1024 x 768 pixels, so that’s how big the rectangle is. Note that we don’t need
    to specify width and height properties for the rectangle because they are inferred
    from the anchors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is exactly the behavior we want for our **SplashView**, but let’s look
    at some other capabilities of anchors before we return to our main project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll look at the next two rectangles together. First, we have a black rectangle
    that is 120 pixels square; `anchors.centerIn: parent` positions it at the center
    of its parent. We must specify the **width** and **height** because we are only
    positioning it, not sizing it.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have a slightly smaller green rectangle, also centered in its parent.
    We then use the `anchors.verticalCenterOffset` property to move it 20 pixels further
    down the screen. The *x*, *y* coordinate system used for positioning has its root
    (0, 0) at the top-left of the screen; `verticalCenterOffset` adds to the y coordinate.
    Positive numbers move the item down the screen, and negative numbers move the
    item up the screen. Its sister property—`horizontalCenterOffset`—is used for adjustments
    in the *x* axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last thing to note here is that the rectangles overlap, and it is the green
    rectangle that wins out and is displayed in full. The black rectangle is pushed
    back and obscured. Similarly, all of our small rectangles sit in front of the
    large background rectangle. QML is rendered in a top-down fashion, so when the
    root element (**Window**) gets painted, its children are processed one by one
    from the top of the file to the bottom. So, items at the bottom of the file will
    be rendered in front of those rendered at the top of the file. The same is true
    if you paint a wall white and then paint it black, the wall will appear black
    because that’s what was painted (rendered) last:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Next, we draw a red rectangle and rather than positioning or sizing the whole
    rectangle at once, we just anchor certain sides. We take the anchor on its **top**
    side and align it to the anchor on the **top** side of its parent (**Window**).
    We anchor its l**eft** side to its parent’s **left** side. Hence, it becomes “attached”
    to the top-left corner.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Another helpful piece of syntactic sugar at work here is rather than doing
    that, we can remove the duplication and set the subproperties of the `anchors`
    group within curly braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the blue rectangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This follows the same pattern, though this time rather than attaching only
    to its parent, we also anchor to a sibling (the red rectangle), which we can reference
    though the `id` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The purple rectangle anchors to the bottom of the blue rectangle and to the
    left-hand side of the Window, but here we introduce our first margin. Each side
    has its own margin and in this case, we use `leftMargin` to give us an offset
    from the left anchor in exactly the same way as we saw with `verticalCenterOffset`
    earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Finally, our turquoise rectangle uses some of that empty space over on the right-hand
    side of the screen and demonstrates how we can set the margin on all four sides
    simultaneously using the `margins` property.
  prefs: []
  type: TYPE_NORMAL
- en: Note that all of these bindings are dynamic. Try resizing the window, and all
    the rectangles will adapt automatically. Anchors are a great tool for responsive
    UI design.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s head back to our `SplashView` in our `cm-ui` project and apply what we’ve
    just learned. Replace the fixed **width** and **height** attributes with the more
    dynamic `anchors.fill` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now, the `SplashView` will fill whatever its parent element is. Build and run,
    and you’ll see that rather than our lovely colorful rectangle filling the screen
    as we expected, it has disappeared altogether. Let’s take a look at why that is.
  prefs: []
  type: TYPE_NORMAL
- en: Sizing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our rectangle will fill its parent, so the size of the rectangle depends entirely
    on the size of its parent. Walking up the QML hierarchy, the component that contains
    the rectangle is the `StackView` element back in **MasterView**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Often, QML components are clever enough to size themselves based on their children.
    Previously, we had set our rectangle to a fixed size of 400 x 200\. The `StackView`
    could look at that and say “I need to contain a single **Rectangle** that is 400
    x 200, so I’ll make myself 400 x 200 too. Easy!”. We can always overrule that
    and set it to some other size using its **width** and **height** properties, but
    it can work out what size it wanted to be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in `scratchpad`, create a new `SizingDemo.qml` view and edit `main.cpp`
    to load it on startup, just like we did with `AnchorsDemo`. Edit `SizingDemo`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Run this, and you’ll get another screen full of nonsense:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/464111c3-4326-4a22-bf0e-9c51aed169f8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Of far more interest to us here is what is output to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '`qml: Text1 - implicitWidth:30 implicitHeight:13 width:30 height:13`'
  prefs: []
  type: TYPE_NORMAL
- en: '`qml: Text2 - implicitWidth:30 implicitHeight:13 width:300 height:20`'
  prefs: []
  type: TYPE_NORMAL
- en: '`qml: Text3 - implicitWidth:1218 implicitHeight:13 width:1218 height:13`'
  prefs: []
  type: TYPE_NORMAL
- en: '`qml: Text4 - implicitWidth:1218 implicitHeight:13 width:300 height:13`'
  prefs: []
  type: TYPE_NORMAL
- en: '`qml: Text5 - implicitWidth:1218 implicitHeight:65 width:300 height:65`'
  prefs: []
  type: TYPE_NORMAL
- en: '`qml: ColumnWithText - implicitWidth:1218 implicitHeight:124 width:1218 height:124`'
  prefs: []
  type: TYPE_NORMAL
- en: '`qml: Rectangle - implicitWidth:0 implicitHeight:0 width:0 height:0`'
  prefs: []
  type: TYPE_NORMAL
- en: '`qml: ColumnWithRectangle - implicitWidth:0 implicitHeight:0 width:0 height:0`'
  prefs: []
  type: TYPE_NORMAL
- en: So, what’s going on? We’ve created two **Column** elements, which are invisible
    layout components that arrange their child elements vertically. We’ve stuffed
    the first column with various **Text** elements and added a single **Rectangle**
    to the second. At the bottom of the view is a JavaScript function that will execute
    when the **Window** component has completed (that is, finished loading). All the
    function does is write out the `implicitWidth`, `implicitHeight`, `width`, and
    `height` properties of various elements on the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s walk through the elements and the corresponding console lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`qml: Text1 - implicitWidth:30 implicitHeight:13 width:30 height:13`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This Text element contains a short piece of text, and we have not specified
    any sizes. Its `implicitWidth` and `implicitHeight` properties are the sizes the
    element wants to be based on its content. Its `width` and `height` properties
    are the sizes the element actually is. In this case, it will size itself however
    it wants to, because we haven’t specified otherwise, so its `width`/`height` are
    the same as its `implicitWidth`/`implicitHeight`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`qml: Text2 - implicitWidth:30 implicitHeight:13 width:300 height:20`'
  prefs: []
  type: TYPE_NORMAL
- en: 'With `text2`, the implicit sizes are the same as `text1` as the content is
    virtually identical. However, this time, we have explicitly told it to be 300
    wide and 20 high. The console tells us that the element is doing as it’s told
    and is indeed that size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`qml: Text3 - implicitWidth:1218 implicitHeight:13 width:1218 height:13`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This `text3` takes the same hands-off approach as `text1`, but with a much
    longer piece of text as its content. This time, `implicitWidth` is much larger
    as that is the amount of space it needs to fit the long text in. Note that this
    is actually wider than the window and the text gets cut off. Again, we haven’t
    instructed it otherwise, so it sizes itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`qml: Text4 - implicitWidth:1218 implicitHeight:13 width:300 height:13`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `text4` has the same lengthy block of text, but we’ve told it what width
    we want this time. You’ll notice on screen that even though the element is only
    300 pixels wide, the text is visible all the way across the window. The content
    is overflowing the bounds of its container. You can set the `clip` property to
    `true` to prevent this, but we’re not too concerned with that here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`qml: Text5 - implicitWidth:1218 implicitHeight:65 width:300 height:65`'
  prefs: []
  type: TYPE_NORMAL
- en: The `text5` repeats the same long block of text and constrains the width to
    300, but this time, we bring a bit of order to proceedings by setting the `wrapMode`
    property to `Text.Wrap`. With this setting, the enabled behavior is much more
    like what you would expect from a block of text—it fills up the available width
    and then wraps onto the next line. The `implicitHeight` and, consequently, the
    `height` of the element has increased to accommodate the contents. Note, however,
    that the `implicitHeight` is still the same as earlier; this is still the width
    the control wants to be in order to fit all of its content in, given the constraints
    we have defined, and we have defined no height constraint.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then print out the properties of the column containing all this text:'
  prefs: []
  type: TYPE_NORMAL
- en: '`qml: ColumnWithText - implicitWidth:1218 implicitHeight:124 width:1218 height:124`'
  prefs: []
  type: TYPE_NORMAL
- en: The important thing to note is that the column is able to figure out how wide
    and high it needs to be to accommodate all of its children.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we get to the issue we encountered back in `SplashView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a chicken and egg scenario. The `Column` tries to work out how
    large it needs to be to contain its children, so it takes a look at `Rectangle`.
    `Rectangle` has no explicit size information and no children of its own, it is
    just set to fill its parent, the `Column`. Neither element can figure out how
    big they are supposed to be, so they both default to 0x0, which renders them invisible.
  prefs: []
  type: TYPE_NORMAL
- en: '`qml: Rectangle - implicitWidth:0 implicitHeight:0 width:0 height:0`'
  prefs: []
  type: TYPE_NORMAL
- en: '`qml: ColumnWithRectangle - implicitWidth:0 implicitHeight:0 width:0 height:0`'
  prefs: []
  type: TYPE_NORMAL
- en: Sizing of elements is probably the thing that has caught me out the most with
    QML over the years. As a general guideline, if you write some QML but then can’t
    see it rendered on screen, it’s probably a sizing issue. I usually find that giving
    everything an arbitrary fixed **width** and **height** is a good start when debugging,
    and then one by one, make the sizes dynamic until you recreate the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Armed with this knowledge, let’s head back to `MasterView` and fix our earlier
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add `anchors.fill: parent` to the `StackView` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `StackView` will now fill its parent **Window**, which we have explicitly
    given a fixed size of 1024 x 768\. Run the app again, and you should now have
    a lovely orange-yellow `SplashView` that fills the screen and happily resizes
    itself if you resize the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39e7344e-d964-43d5-ad69-841e8612c143.png)'
  prefs: []
  type: TYPE_IMG
- en: Navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lets make a quick addition to our `SplashView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This just adds the name of the view to the screen, so when we start moving between
    views, we know which one we are looking at. With that done, copy the content of
    `SplashView` into all the other new views, updating the text in each to reflect
    the name of the view, for example, in `DashboardView`, the text could say “Dashboard
    View”.
  prefs: []
  type: TYPE_NORMAL
- en: The first piece of navigation we want to do is when the `MasterView` has finished
    loading and we’re ready for action, load the `DashboardView`. We achieve this
    using one of the QML component slots we’ve just seen—`Component.onCompleted()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line to the root `Window` component in `MasterView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now when you build and run, as soon as the `MasterView` has finished loading,
    it switches the child view to `DashboardView`. This probably happens so fast that
    you no longer even see `SplashView`, but it is still there. Having a splash view
    like this is great if you’ve got an application with quite a lot of initialization
    to do, and you can’t really have non-blocking UI. It’s a handy place to put the
    company logo and a “Reticulating splines...” loading message. Yes, that was a
    Sims reference!
  prefs: []
  type: TYPE_NORMAL
- en: The StackView is just like the history in your web browser.  If you visit [www.google.com](http://www.google.com)
    and then [www.packtpub.com](http://www.packtpub.com), you are *pushing* [www.packtpub.com](http://www.packtpub.com)
    onto the stack.  If you click on Back on the browser, you return to [www.google.com](http://www.google.com). 
    This history can consist of several pages (or views), and you can navigate backward
    and forward through them. Sometimes you don't need the history and sometimes you
    actively don't want users to be able to go back. The `replace()` method we called,
    as its name suggests, pushes a new view onto the stack and clears any history
    so that you can't go back.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Component.onCompleted` slot, we''ve seen an example of how to navigate
    between views directly from QML. We can use this approach for all of our application
    navigation. For example, we can add a button for the user to create a new client
    and when it’s clicked on, push the `CreateClientView` straight on to the stack,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: For UX designs or simple UI heavy applications with little business logic, this
    is a perfectly valid approach. The trouble is that your QML views and components
    become very tightly coupled, and the business logic layer has no visibility of
    what the user is doing. Quite often, moving to a new screen of the application
    isn’t as simple as just displaying a new view. You may need to update a state
    machine, set some models up, or clear out some data from the previous view. By
    routing all of our navigation requests through our **MasterController** switchboard,
    we decouple our components and gain an intercept point for our business logic
    to take any actions it needs to as well as validate that the requests are appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will request navigation to these views by emitting signals from our business
    logic layer and having our **MasterView** respond to them and perform the transition.
    Rather than cluttering up our **MasterController**, we’ll delegate the responsibility
    for navigation to a new controller in `cm-lib`, so create a new header file (there
    is no implementation as such, so we don’t need a `.cpp` file) called `navigation-controller.h`
    in `cm/cm-lib/source/controllers` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We have created a minimal class that inherits from `QObject` and implements
    a signal for each of our new views. Note that we don’t need to navigate to the
    **MasterView** or the **SplashView**, so there is no corresponding signal for
    those. When we navigate to the `EditClientView`, we will need to inform the UI
    which **Client** we want to edit, so we will pass it through as a parameter. Calling
    one of these methods from anywhere within our business logic code fires a request
    into the ether saying “I want to go to the so-and-so view, please”. It is then
    up to the **MasterView** over in the UI layer to monitor those requests and respond
    accordingly. Note that the business logic layer still knows nothing about the
    UI implementation. It's fine if nobody responds to the signal; it is not a two-way
    communication.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you inherit from `QObject`, always remember the `Q_OBJECT` macro and
    also an overloaded constructor that takes a `QObject` parent. As we want to use
    this class outside of this project (in the UI project), we must also remember
    the CMLIBSHARED_EXPORT macro.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve looked forward a little bit here and assumed that our Client class will
    be in the `cm::models` namespace, but the default `Client` class that Qt added
    for us when we created the project is not, so let''s fix that before we move on:'
  prefs: []
  type: TYPE_NORMAL
- en: '**client.h**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`client.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to be able to create an instance of a NavigationController and have
    our UI interact with it. For unit testing reasons, it is good practice to hide
    object creation behind some sort of object factory interface, but we’re not concerned
    with that at this stage, so we''ll simply create the object in **MasterController**.
    Let’s take this opportunity to add the Private Implementation (PImpl) idiom to
    our **MasterController** too. If you haven''t come across PImpl before, it is
    simply a technique to move all private implementation details out of the header
    file and into the definition. This helps keep the header file as short and clean
    as possible, with only the includes necessary for consumers of the public API.
    Replace the declaration and implementation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`master-controller.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`master-controller.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You may have noted that we don’t specify the cm::controllers namespace for the
    NavigationController accessor method, but we do for the `Q_PROPERTY`. This is
    because the property is accessed by the UI QML, which is not executing within
    the scope of the `cm` namespace, so we have to explicitly specify the fullyqualified
    name. As a general rule of thumb, be explicit about namespaces for anything that
    QML interacts with directly, including parameters in signals and slots.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to register the new `NavigationController` class with the QML
    system in the **cm-ui** project, so in `main.cpp`, add the following registration
    next to the existing one for **MasterController**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We’re now ready to wire up **MasterView** to react to these navigation signals.
    Add the following element before the `StackView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We are creating a connection component bound to our new instance of **NavigationController**,
    which reacts to each of the go signals we added and navigates to the relevant
    view via the `contentFrame`, using the same `replace()` method we used previously
    to move to the Dashboard. So whenever the `goCreateClientView()` signal gets fired
    on the **NavigationController**, the `onGoCreateClientView()` slot gets called
    on our `Connections` component and the `CreateClientView` is loaded into the **StackView**
    named `contentFrame`. In the case of `onGoEditClientView` where a `client` parameter
    is passed from the signal, we pass that object along to a property named `selectedClient`, which
    we will add to the view later.
  prefs: []
  type: TYPE_NORMAL
- en: Some signals and slots in QML components are automatically generated and connected
    for us and are convention based. Slots are named `on[CapitalisedNameOfRelatedSignal]`.
    So, for example, if you have a signal called `mySplendidSignal()`, then the corresponding
    slot will be named `onMySplendidSignal`. These conventions are in play with our
    `NavigationController` and `Connections` components.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s add a navigation bar to **MasterView** with some placeholder buttons
    so that we can try these signals out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `Rectangle` to form the background for our bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This draws a black strip 100 pixels wide anchored to the left-hand side of the
    view.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to adjust our `StackView` so that it allows some space for our
    bar. Rather than filling its parent, let’s anchor three of its four sides to its
    parent, but attach the left-hand side to the right-hand side of our bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s add some buttons to our navigation `Rectangle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `Column` component to lay out our buttons for us, rather than having
    to individually anchor the buttons to each other. Each button displays some text
    and when clicked on, calls a signal on the **NavigationController**. Our `Connection`
    component reacts to the signals and performs the view transition for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aad6160f-75eb-4122-a0f4-1b1e6e5790dd.png)'
  prefs: []
  type: TYPE_IMG
- en: Great stuff, we have a functional navigation framework! However, when you click
    on one of the navigation buttons, the navigation bar disappears momentarily and
    comes back again. We are also getting “conflicting anchors” messages in our **Application
    Output** console, which suggest that we’re doing something that’s not quite right.
    Let’s address those issues before we move on.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing conflicts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The navigation bar problem is a simple one. As explained previously, QML is
    hierarchical in structure. This bears out in the way the elements are rendered—child
    elements that appear first are rendered first. In our case, we draw the navigation
    bar and then we draw the content frame. When the **StackView** component loads
    new content, by default it applies funky transitions to make it look nice. Those
    transitions can result in content moving out of bounds of the control and drawing
    over any content below it. There are a couple of ways to address this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we can rearrange the order that the components are rendered in and
    put the navigation bar after the content frame. This will draw the navigation
    bar over the top of the `StackView`, regardless of what was going on with it.
    The second option and the one we will implement is to simply set the `clip` property
    of the **StackView**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This clips any content that overlaps the boundary of the control and doesn’t
    render it.
  prefs: []
  type: TYPE_NORMAL
- en: The next problem is a little more esoteric. As we’ve discussed, the number one
    cause of confused head scratching I’ve encountered over the past few years of
    QML development is the sizing of components. Some components we’ve used, such
    as **Rectangle**, are intrinsically visual elements. If their size is not defined,
    either directly with the `width/height` properties or indirectly with **anchors**,
    then they will not render. Other elements such as **Connections** are not visual
    at all and size properties are redundant. Layout elements such as **Column** may
    have a fixed size in one axis, but be dynamic in the other by nature.
  prefs: []
  type: TYPE_NORMAL
- en: One thing that most components have in common is that they inherit from **Item**,
    which in turn inherits directly from **QtObject**, which is just a plain **QObject**.
    In much the same way that the Qt Framework on the C++ side implements a lot of
    default behavior for plain old **QObject***, QML components often implement default
    behavior for **Item** components that we can leverage here.
  prefs: []
  type: TYPE_NORMAL
- en: In our child views, we have used **Rectangle** as our root object. This makes
    sense as we want to display a rectangle of a fixed size and color. However, this
    causes problems for the **StackView** as it doesn’t know what size it should be.
    To provide this information, we try and anchor it to its parent (the **StackView**),
    but then that causes problems of its own by conflicting with the transitions the
    **StackView** is trying to perform when we switch views.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our way out of this dilemma is to instead have the root of our child views
    be a plain old **Item**. **StackView** components have internal logic to handle
    **Item** components and will just size it for us. Our **Rectangle** component
    then becomes the child of an **Item** component that has already been sized automatically,
    and we can anchor to that instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This is all a bit confusing and feels like Voodoo, but the takeaway here is
    that having **Item** as the root element in your custom QML is often a good thing.
    Go ahead and add a root **Item** component in this way to all the child views
    (but not **MasterView**).
  prefs: []
  type: TYPE_NORMAL
- en: Run the application again, and you should now have nice smooth transitions and
    no warning messages in the console.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have a flexible, decoupled navigation mechanism in place and are successfully
    transitioning between different views. We have the basics of a navigation bar
    in place and a working content pane as designed at the beginning of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Having the UI call the business logic layer to emit a signal that the UI then
    reacts to may seem like a bit of a roundabout way of navigating between views,
    but this business logic signal/UI slot design brings benefits. It keeps the UI
    modular as the views don't need to know about each other. It keeps the logic for
    navigation in the business logic layer and enables that layer to request that
    the UI navigate the user to a particular view without needing to know anything
    about the UI or the view itself. Crucially, it also gives us intercept points
    so that when the user requests navigation to a given view, we can handle it and
    perform any additional processing we need, such as state management or cleanup.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](c3be84d8-850d-4171-9c8a-eb4042d904c9.xhtml)*, Style*, we will
    introduce a shared style component, and QML modules and icons before we complete
    our UI design with a dynamic command bar.
  prefs: []
  type: TYPE_NORMAL
