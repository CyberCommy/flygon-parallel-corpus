- en: '*Chapter 9*: Deploying a Secured Kubernetes Dashboard'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 9 章*：部署安全的 Kubernetes 仪表板'
- en: Kubernetes clusters are made up of more than the API server and the kubelet.
    Clusters are generally made up of additional applications that need to be secured,
    such as container registries, source control systems, pipeline services, GitOps
    applications, and monitoring systems. The users of your cluster will often need
    to interact with these applications directly.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 集群不仅由 API 服务器和 kubelet 组成。集群通常由需要进行安全保护的其他应用程序组成，例如容器注册表、源代码控制系统、流水线服务、GitOps
    应用程序和监控系统。您的集群用户通常需要直接与这些应用程序进行交互。
- en: While many clusters are focused on authenticating access to user-facing applications
    and services, cluster solutions are not given the same first-class status. Users
    often are asked to use kubectl's **port-forward** or **proxy** capability to access
    these systems. This method of access is an anti-pattern from a security and user
    experience standpoint. The first exposure users and administrators will have to
    this anti-pattern is the Kubernetes Dashboard. This chapter will detail why this
    method of access is an anti-pattern and how to properly access the Dashboard.
    We'll walk you through how not to deploy a secure web application and point out
    the issues and risks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 许多集群都专注于对面向用户的应用程序和服务进行身份验证，但集群解决方案并未受到同等重视。用户通常被要求使用 kubectl 的端口转发或代理功能来访问这些系统。从安全和用户体验的角度来看，这种访问方法是一种反模式。用户和管理员将首次接触到这种反模式的是
    Kubernetes 仪表板。本章将详细介绍为什么这种访问方法是一种反模式，以及如何正确访问仪表板。我们将指出如何不部署安全的 Web 应用程序，并指出其中的问题和风险。
- en: We'll use the Kubernetes Dashboard as a way to learn about web application security
    and how to apply those patterns in your own cluster. These lessons will work with
    not just the dashboard, but other cluster focused applications such as the Kiali
    dashboard for Istio, Grafana, Prometheus, and other cluster management applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Kubernetes 仪表板来学习有关 Web 应用程序安全性以及如何在自己的集群中应用这些模式。这些课程不仅适用于仪表板，还适用于其他集群重点应用程序，如
    Istio 的 Kiali 仪表板、Grafana、Prometheus 和其他集群管理应用程序。
- en: Finally, we'll spend some time talking about local dashboards and how to evaluate
    their security. This is a popular trend, but not universal. It's important to
    understand the security of both approaches, and we'll explore them in this chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将花一些时间讨论本地仪表板以及如何评估它们的安全性。这是一个流行的趋势，但并非普遍适用。了解这两种方法的安全性非常重要，我们将在本章中探讨它们。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How does the dashboard know who you are?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仪表板如何知道你是谁？
- en: Is the dashboard insecure?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仪表板是否不安全？
- en: Deploying the dashboard with a reverse proxy
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用反向代理部署仪表板
- en: Integrating the dashboard with OpenUnison
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将仪表板与 OpenUnison 集成
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the exercises in this chapter you will require a KinD cluster running
    with OIDC integration. We created this in [*Chapter 7*](B15514_07_Final_ASB_ePub.xhtml#_idTextAnchor203)*,
    Integrating Authentication into Your Cluster.*
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章的练习，您需要一个运行 OIDC 集成的 KinD 集群。我们在《第 7 章》[*第 7 章*](B15514_07_Final_ASB_ePub.xhtml#_idTextAnchor203)*《将身份验证集成到您的集群中》*中创建了这个集群。
- en: 'You can access the code for this chapter at the following GitHub repository:
    [https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide](https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下 GitHub 存储库中访问本章的代码：[https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide](https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide)。
- en: How does the dashboard know who you are?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仪表板如何知道你是谁？
- en: The Kubernetes Dashboard is a powerful web application for quickly accessing
    your cluster from inside a browser. It lets you browse your namespaces and view
    the status of nodes, and even provides a shell you can use to access Pods directly.
    There is a fundamental difference between using the dashboard and kubectl. The
    dashboard, being a web application, needs to manage your session, whereas kubectl
    does not. This leads to a different set of security issues during deployment that
    are often not accounted for, leading to severe consequences. In this section,
    we'll explore how the dashboard identifies users and interacts with the API server.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Dashboard architecture
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before diving into the specifics of how the dashboard authenticates a user,
    it''s important to understand the basics of how the dashboard works. The dashboard
    at a high level has three layers:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '**User Interface**: This is the Angular + HTML frontend that is displayed in
    your browser and that you interact with.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Middle Tier**: The frontend interacts with a set of APIs hosted in the dashboard''s
    container to translate calls from the frontend into Kubernetes API calls.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API Server**: The middle tier API interacts directly with the Kubernetes
    API server.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This three-layered architecture of the Kubernetes Dashboard can be seen in
    the following diagram:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Kubernetes Dashboard architecture'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Fig_9.1_B15514.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.1 – Kubernetes Dashboard architecture
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: When a user interacts with the dashboard, the user interface makes calls to
    the middle tier, which in turn makes calls to the API server. The dashboard doesn't
    know how to collect credentials, with which most of the applications users would
    generally get access. There's no place to put a username or password. It has a
    very simple session mechanism system based on cookies, but for the most part the
    dashboard doesn't really know, or care, who the currently logged in user is. The
    only thing the dashboard cares about is what token to use when communicating with
    the API server.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: So, how does the dashboard know who you are?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Authentication methods
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three ways that the dashboard can determine who a user is:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '**No credentials**: The dashboard can be told not to collect any tokens or
    credentials. When this happens, the dashboard will interact with the API server
    using the container''s own service account with whatever privileges it is assigned
    via RBAC.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Token from login/uploaded kubectl configuration**: The dashboard can prompt
    the user for their kubectl configuration file or for a bearer token to use. Once
    a token is provided (or extracted from the configuration file uploaded to the
    dashboard), an encrypted cookie is created to store the token. This cookie is
    decrypted by the middle tier, and the token inside is passed to the API server.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**来自登录/上传kubectl配置的令牌**：仪表板可以提示用户提供他们的kubectl配置文件或一个用于使用的令牌。一旦提供了令牌（或从上传到仪表板的配置文件中提取出来），就会创建一个加密的cookie来存储令牌。这个cookie会被中间层解密，里面的令牌会被传递给API服务器。'
- en: '**Token from a reverse proxy**: If there''s an authorization header containing
    a bearer token in requests from the user interface to the middle tier, the middle
    tier will use that bearer token in requests to the API server. This is the most
    secure option and the implementation that will be detailed in this chapter.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**来自反向代理的令牌**：如果用户界面向中间层发出的请求中包含一个包含令牌的授权头，则中间层将在向API服务器发出请求时使用该令牌。这是最安全的选项，也是本章将详细介绍的实现方式。'
- en: Throughout the rest of this chapter, the first two options will be explored
    as anti-patterns for accessing the dashboard, and we will explain why the reverse
    proxy pattern is the best option for accessing a cluster's dashboard implementation
    from a security standpoint and a user experience standpoint.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，将探讨访问仪表板的前两个选项作为反模式，并解释为什么反向代理模式是从安全和用户体验的角度来看访问集群仪表板实现的最佳选项。
- en: Understanding dashboard security risks
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解仪表板安全风险
- en: The question of the dashboard's security often comes up when setting up a new
    cluster. Securing the dashboard boils down to how the dashboard is deployed, rather
    than if the dashboard itself is secure. Going back to the architecture of the
    dashboard application, there is no sense of "security" being built in. The middle
    tier simply passes a token to the API server.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置新集群时，仪表板的安全性问题经常被提出。保护仪表板归结为仪表板的部署方式，而不是仪表板本身是否安全。回到仪表板应用程序的架构，没有安全性的概念被构建进去。中间层只是简单地将令牌传递给API服务器。
- en: When talking about any kind of IT security, it's important to look at it through
    the lens of *defense in depth*. This is the idea that any system should have multiple
    layers of security. If one fails, there are other layers to fill the gap until
    the failed layers can be addressed. A single failure doesn't give an attacker
    direct access.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论任何类型的IT安全时，重要的是通过“深度防御”的视角来看待。这是任何系统都应该有多层安全的理念。如果一层失败，就有其他层来填补漏洞，直到失败的层得到解决。单一的失败不会直接给攻击者提供访问权限。
- en: The most often cited incident related to the dashboard's security was the breach
    of Tesla in 2018 by crypto-miners. Attackers were able to access Pods running
    in Tesla's clusters because the dashboard wasn't secured. The cluster's Pods had
    access to tokens that provided the attackers with access to Tesla's cloud providers
    where the attackers ran their crypto-mining systems.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与仪表板安全性相关的最常引用的事件是2018年加密货币挖矿者入侵特斯拉的事件。攻击者能够访问特斯拉集群中运行的Pods，因为仪表板没有得到保护。集群的Pods可以访问提供攻击者访问特斯拉云供应商的令牌，攻击者在那里运行他们的加密挖矿系统。
- en: Dashboards in general are often an attack vector because they make it easy to
    find what attackers are looking for and can easily be deployed insecurely. Illustrating
    this point, at KubeCon NA 2019 a **Capture the Flag** (**CTF**) was presented
    where one of the scenarios was a developer "accidentally" exposing the cluster's
    dashboard.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，仪表板通常是攻击向量，因为它们很容易找到攻击者寻找的内容，并且很容易被不安全地部署。为了说明这一点，在KubeCon NA 2019上展示了一个“夺旗”（CTF）活动，其中一个场景是开发人员“意外”暴露了集群的仪表板。
- en: Note
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The CTF is available as a home lab at [https://securekubernetes.com/](https://securekubernetes.com/).
    It's a highly recommended resource for anyone learning Kubernetes security. In
    addition to being educational, and terrifying, it's also really fun!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Since the Tesla breach, it's become harder to deploy the dashboard without credentials.
    It's no longer the default and requires updates to both the dashboard and the
    cluster. To demonstrate just how dangerous this can be, let's go through the steps
    to do it and see what damage can be done.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Going through these steps might bring about the thought "does anyone really
    go through all these steps to get to the dashboard?" The answer is probably something
    no one wants to talk about. In the previous chapter, multiple options for authorizing
    access to a cluster and designing multi-tenancy were discussed. One of the options
    was tenancy at the cluster layer, where each tenant gets its own cluster. Unfortunately,
    many of these deployments include cluster-admin access for the tenants, which
    would give them the ability to perform these steps. Cluster administrators are
    a few Google searches away from instructions to easily bypass that pesky VPN developers
    don't like using from home.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Deploying an insecure dashboard
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While this may sound crazy, it's something that we have seen in the wild far
    too often. The recommended dashboard installation states multiple times not to
    use this type of configuration outside of an isolated development lab. The downfall
    is that since it does make deploying the dashboard so easy, many newer administrators
    use it since it's easy to set up, and they often use the same deployment in a
    production cluster.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s show how easy it is to attack a dashboard that is deployed without
    security in mind:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to tell the dashboard to allow users to bypass authentication.
    Edit the **kubernetes-dashboard** deployment in the **kubernetes-dashboard** namespace:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**kubectl edit deployment kubernetes-dashboard -n kubernetes-dashboard**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Look for the **args** option for the container, add **- --enable-skip-login**,
    then save:![Figure 9.2 – Enabling skip-login on the dashboard
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Fig_9.2_B15514.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.2 – Enabling skip-login on the dashboard
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to expose the dashboard to the network by creating a new Ingress
    rule. Create a new Ingress manifest called **insecure-dashboard.yaml** with the
    following YAML. Remember to replace the IP address in the **host** section with
    your Docker host''s IP address:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要通过创建新的Ingress规则将仪表板暴露给网络。使用以下YAML创建一个名为**insecure-dashboard.yaml**的新Ingress清单。记得用你的Docker主机IP地址替换**host**部分的IP地址：
- en: 'apiVersion: networking.k8s.io/v1beta1'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 'apiVersion: networking.k8s.io/v1beta1'
- en: 'kind: Ingress'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 种类：Ingress
- en: 'metadata:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据：
- en: 'name: dashboard-external-auth'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：dashboard-external-auth
- en: 'namespace: kubernetes-dashboard'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间：kubernetes-dashboard
- en: 'annotations:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注释：
- en: 'kubernetes.io/ingress.class: nginx'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 'kubernetes.io/ingress.class: nginx'
- en: 'nginx.ingress.kubernetes.io/affinity: cookie'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 'nginx.ingress.kubernetes.io/affinity: cookie'
- en: 'nginx.ingress.kubernetes.io/backend-protocol: https'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 'nginx.ingress.kubernetes.io/backend-protocol: https'
- en: 'nginx.ingress.kubernetes.io/secure-backends: "true"'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 'nginx.ingress.kubernetes.io/secure-backends: "true"'
- en: 'nginx.org/ssl-services: kubernetes-dashboard'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 'nginx.org/ssl-services: kubernetes-dashboard'
- en: 'spec:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 规格：
- en: 'rules:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 规则：
- en: '- host: k8s-secret-dashboard.apps.192-168-2-129.nip.io'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '- host: k8s-secret-dashboard.apps.192-168-2-129.nip.io'
- en: 'http:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: http：
- en: 'paths:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 路径：
- en: '- backend:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '- 后端：'
- en: 'serviceName: kubernetes-dashboard'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 'serviceName: kubernetes-dashboard'
- en: 'servicePort: 443'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 'servicePort: 443'
- en: 'path: /'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 路径：/
- en: 'Create the Ingress rule by deploying the manifest using **kubectl**. Since
    we added the namespace value to the manifest, we do need to add **-n** to the
    kubectl command:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用**kubectl**部署清单来创建Ingress规则。由于我们在清单中添加了命名空间值，因此需要在kubectl命令中添加**-n**：
- en: '**kubectl create -f insecure-dashboard.yaml**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**kubectl create -f insecure-dashboard.yaml**'
- en: Once the Ingress is created, open a browser and go to your secret dashboard
    using the Nip.io name specified in the **host** section of the Ingress rule.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建Ingress后，打开浏览器，使用Ingress规则的**host**部分指定的Nip.io名称访问您的secret仪表板。
- en: You will see an authentication screen that asks for a token or a Kubeconfig
    file, but since we enabled the option to skip the login when we edited the dashboard,
    you can simply skip the login by clicking on **Skip**:![Figure 9.3 – Kubernetes
    Dashboard with login disabled
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将看到一个要求令牌或Kubeconfig文件的身份验证屏幕，但由于我们在编辑仪表板时启用了跳过登录的选项，您可以通过单击**跳过**来简单地跳过登录：![图9.3
    - 禁用登录的Kubernetes仪表板
- en: '](image/Fig_9.3_B15514.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_9.3_B15514.jpg)'
- en: Figure 9.3 – Kubernetes Dashboard with login disabled
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 - 禁用登录的Kubernetes仪表板
- en: Once in the dashboard, the default service account doesn't have access to anything:![Figure
    9.4 – Kubernetes Dashboard with the default service account
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦进入仪表板，默认服务账户将无法访问任何内容：![图9.4 - 默认服务账户的Kubernetes仪表板
- en: '](image/Fig_9.4_B15514.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_9.4_B15514.jpg)'
- en: Figure 9.4 – Kubernetes Dashboard with the default service account
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 - 默认服务账户的Kubernetes仪表板
- en: So far this may not look too bad. You will see *access forbidden* errors, so
    right now the dashboard will not allow you to do any damage. Unfortunately, many
    people get to this point and go the extra step to change the permissions that
    the default service account has on the cluster.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这可能看起来还不错。您将看到*访问被禁止*的错误，所以目前仪表板不会允许您造成任何损害。不幸的是，许多人到达这一点并采取额外的步骤来更改默认服务账户在集群上的权限。
- en: Right now, the service account isn't authorized for access to the cluster, so
    change that by creating a new **ClusterRoleBinding** to the cluster-admin **ClusterRole**.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，服务账户未被授权访问集群，因此通过创建新的**ClusterRoleBinding**到cluster-admin **ClusterRole**来更改。
- en: 'Create a new file called **dashboard-role.yaml** with the following contents:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为**dashboard-role.yaml**的新文件，内容如下：
- en: 'apiVersion: rbac.authorization.k8s.io/v1'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 'apiVersion: rbac.authorization.k8s.io/v1'
- en: 'kind: ClusterRoleBinding'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 种类：ClusterRoleBinding
- en: 'metadata:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据：
- en: 'name: secret-dashboard-cluster-admin'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：secret-dashboard-cluster-admin
- en: 'roleRef:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 'roleRef:'
- en: 'apiGroup: rbac.authorization.k8s.io'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 'apiGroup: rbac.authorization.k8s.io'
- en: 'kind: ClusterRole'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 种类：ClusterRole
- en: 'name: cluster-admin'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：cluster-admin
- en: 'subjects:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 主题：
- en: '- apiGroup: ""'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '- apiGroup: ""'
- en: 'kind: ServiceAccount'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 'kind: ServiceAccount'
- en: 'namespace: kubernetes-dashboard'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间：kubernetes-dashboard
- en: 'name: kubernetes-dashboard'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：kubernetes-dashboard
- en: 'Create the new **ClusterRoleBinding** by applying it using **kubectl**:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用kubectl应用它来创建新的**ClusterRoleBinding**：
- en: '**kubectl create -f dashboard-role.yaml**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**kubectl create -f dashboard-role.yaml**'
- en: Congratulations! The secret dashboard is now available for anyone who may want
    to use it!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！秘密仪表板现在可以供任何想要使用它的人使用！
- en: Now, you may be thinking *"Who can find my dashboard? They would need to know
    the URL, and I'm not telling anyone what it is."* You feel secure because nobody
    else knows the URL or the IP address to your dashboard. This is called Security
    by Obscurity and is generally accepted to be a terrible approach to securing a
    system.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会想*"谁能找到我的仪表板？他们需要知道URL，而我不会告诉任何人。"* 你感到安全，因为没有其他人知道你的仪表板的URL或IP地址。这被称为安全性通过混淆，通常被认为是一种糟糕的保护系统的方法。
- en: Let's use a scenario of how someone may exploit the dashboard without you knowing.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个场景来说明，有人可能在你不知情的情况下利用仪表板。
- en: 'You are a big Reddit fan, and one day you come across a Reddit post titled
    *This is a great tool for securing your Kubernetes Dashboard*. The post seems
    to be legit and you are excited to test this new tool out. After reading the post,
    you see the link at the bottom to the utility and the command to run it: You can
    download it from [https://raw.githubusercontent.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide/master/chapter9/kubectl-secure-my-dashboard.go](https://raw.githubusercontent.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide/master/chapter9/kubectl-secure-my-dashboard.go)
    to give it a try!'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你是Reddit的忠实粉丝，有一天你看到了一个Reddit帖子，标题是*这是一个用于保护你的Kubernetes仪表板的好工具*。这个帖子看起来很正规，你很兴奋地想测试一下这个新工具。阅读完帖子后，你看到了底部的链接和运行它的命令：你可以从[https://raw.githubusercontent.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide/master/chapter9/kubectl-secure-my-dashboard.go](https://raw.githubusercontent.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide/master/chapter9/kubectl-secure-my-dashboard.go)下载它来试试看！
- en: 'To fully experience this example, you can run the tool on your KinD cluster
    by executing the following command from your cloned repository in the **chapter9**
    directory. Be sure to change the URL to your dashboard''s Ingress host:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完全体验这个例子，你可以在你的KinD集群上运行这个工具，通过在**chapter9**目录下的克隆存储库中执行以下命令。确保将URL更改为你的仪表板的Ingress主机：
- en: go run kubectl-secure-my-dashboard.go https://k8s-secret-dashboard.apps.192-168-2-129.nip.io
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: go run kubectl-secure-my-dashboard.go https://k8s-secret-dashboard.apps.192-168-2-129.nip.io
- en: '**Running analysis on https://k8s-secret-dashboard.apps.192-168-2-129.nip.io**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**在https://k8s-secret-dashboard.apps.192-168-2-129.nip.io上运行分析**'
- en: '**Your dashboard has been secured!**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**你的仪表板已经得到了保护！**'
- en: 'Now, let''s see review what just happened. Open a browser and go to your secret
    dashboard site to view what''s been changed:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一下刚刚发生的事情。打开浏览器，进入你的秘密仪表板网站，查看发生了什么变化：
- en: '![Figure 9.5 – Kubernetes Dashboard showing malware deployed'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.5 - 显示部署恶意软件的Kubernetes仪表板'
- en: '](image/Fig_9.5_B15514.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_9.5_B15514.jpg)'
- en: Figure 9.5 – Kubernetes Dashboard showing malware deployed
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 - 显示部署恶意软件的Kubernetes仪表板
- en: It appears our hardening plugin was a ruse to deploy a bitcoin miner. How rude!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 看来我们的加固插件是一个部署比特币矿工的诡计。太无礼了！
- en: Now that you have seen how easily an insecure dashboard can be exploited, delete
    the deployment using kubectl.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了一个不安全的仪表板是如何容易被利用的，使用kubectl删除部署。
- en: While this attack could be mitigated by preauthorizing registries with approved
    images (this topic will be covered when **OpenPolicyAgent** is covered in [*Chapter
    11*](B15514_11_Final_ASB_ePub.xhtml#_idTextAnchor272), *Extending Security Using
    Open Policy Manager)*, at that point the security is reactive, trying to respond
    to threats instead of preventing them. Using an admission controller won't stop
    someone from extracting secrets from your dashboard either.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种攻击可以通过预授权具有批准图像的注册表来减轻（当**OpenPolicyAgent**在[*第11章*](B15514_11_Final_ASB_ePub.xhtml#_idTextAnchor272)中介绍时，*使用Open
    Policy Manager扩展安全性*将涉及到这个话题），但在那时安全性是被动的，试图应对威胁而不是预防它们。使用准入控制器也无法阻止某人从仪表板中提取机密信息。
- en: 'While this was the simplest way to get access to the dashboard insecurely,
    it''s not the only way. The kubectl utility includes two features that can make
    accessing the dashboard easy. The port-forward utility is often used to create
    a tunnel to a pod inside the cluster. This utility creates a TCP stream to a specific
    port on your pod, making it accessible to your local host (or more if you wanted).
    This still bypasses authentication in the dashboard, requiring that the dashboard''s
    service account has access via RBAC to perform whichever tasks are needed. While
    it is true that the user must have RBAC authorization to port-forward to a pod,
    this leaves the dashboard open via two attack vectors:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是以最简单的方式不安全地访问仪表板的方法，但并不是唯一的方法。kubectl实用程序包括两个功能，可以使访问仪表板变得容易。端口转发实用程序通常用于在集群内部创建到pod的隧道。该实用程序创建到pod上特定端口的TCP流，使其可以被本地主机访问（或者更多，如果你想的话）。这仍然绕过了仪表板中的身份验证，要求仪表板的服务账户通过RBAC具有执行所需任务的访问权限。虽然用户必须具有RBAC授权才能将端口转发到pod，但这样会使仪表板通过两个攻击向量开放：
- en: '**External**: Any script running on a user''s local workstation can access
    the forwarded network tunnel.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部**：运行在用户本地工作站上的任何脚本都可以访问转发的网络隧道。'
- en: '**Internal**: Any pod inside of the cluster can access the dashboard pod.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部**：集群内部的任何pod都可以访问仪表板pod。'
- en: For internal access, network policies can be used to limit which namespaces
    and Pods can access the dashboard's API. It's a good idea to use network policies
    to begin with, but that's a single point of failure in this instance. One misconfigured
    policy will open the dashboard to attack.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于内部访问，可以使用网络策略来限制哪些命名空间和Pod可以访问仪表板的API。最好一开始就使用网络策略，但在这种情况下这是一个单点故障。一个配置错误的策略将会使仪表板暴露于攻击之下。
- en: Threats from external sources will likely come in the form of scripts you (or
    another tool you use) may decide to run. Web browsers aren't able to access the
    ports opened by port-forwarding from a page hosted outside your local system,
    but any script running on your workstation can. For instance, while you could
    access a port-forwarded host by opening your browser and going directly to that
    port, a web page with malicious JavaScript that loads from a remote site can't
    open a connection to your local host. Attempt to run the hardening script from
    earlier in the section against a forwarded port and the same result will occur,
    an unwanted pod on your infrastructure.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 外部来源的威胁可能以您（或您使用的其他工具）决定运行的脚本的形式出现。Web浏览器无法访问从本地系统外部托管的页面通过端口转发打开的端口，但是您工作站上运行的任何脚本都可以。例如，虽然您可以通过打开浏览器并直接转到该端口来访问转发的主机，但是从远程站点加载的恶意JavaScript的网页无法打开到您本地主机的连接。尝试对转发的端口运行之前在本节中运行的加固脚本，将会产生相同的结果，即在您的基础设施上出现一个不需要的pod。
- en: Another technique for providing access is to use the API server's integrated
    proxy utility. Running **kubectl proxy** creates a local network tunnel to the
    API server that can then be used to proxy HTTP requests to any pod, including
    the dashboard. This has the same drawbacks as **kubectl port-forward** and will
    open your cluster up to attacks from any script running locally.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 提供访问的另一种技术是使用API服务器的集成代理实用程序。运行**kubectl proxy**会创建一个到API服务器的本地网络隧道，然后可以用于代理HTTP请求到任何Pod，包括仪表盘。这与**kubectl
    port-forward**具有相同的缺点，并且会使您的集群面临来自本地运行的任何脚本的攻击。
- en: The common thread among these methods is they have a single point of failure
    in their security. Even with mitigations put in place to limit what images can
    be deployed, an unsecured dashboard can still be used to access Secret objects,
    delete deployments, and even remote shell into Pods via the terminal integrated
    into the dashboard.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法中的共同点是它们在安全性上存在单一故障点。即使采取了限制可以部署的图像的措施，一个不安全的仪表盘仍然可以用于访问秘密对象、删除部署，甚至通过仪表盘中集成的终端远程进入Pod。
- en: Having explored how to bypass all authentication on the dashboard, and its implications,
    next we'll look at how to provide a token to the dashboard without deploying additional
    infrastructure.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在探讨了如何绕过仪表盘上的所有身份验证及其影响之后，接下来我们将看看如何向仪表盘提供令牌，而无需部署额外的基础设施。
- en: Using a token to log in
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用令牌登录
- en: A user may upload a token or kubectl configuration file to the dashboard as
    a login to avoid the perils of a secret dashboard. As discussed earlier, the dashboard
    will take the user's bearer token and use it with all requests to the API server.
    While this may appear to solve the problem of giving the dashboard its own privileged
    service account, it brings its own issues. The dashboard isn't kubectl and doesn't
    know how to refresh tokens as they expire. This means that a token would need
    to be fairly long lived to be useful. This would require either creating service
    accounts that can be used or making your OpenID Connect **id_tokens** longer lived.
    Both options would negate much of the security put in place by leveraging OpenID
    Connect for authentication.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以将令牌或kubectl配置文件上传到仪表盘作为登录，以避免秘密仪表盘的危险。正如前面讨论的，仪表板将获取用户的令牌并将其与对API服务器的所有请求一起使用。虽然这似乎解决了为仪表盘提供特权服务帐户的问题，但它也带来了自己的问题。仪表盘不是kubectl，并不知道如何在令牌过期时刷新令牌。这意味着令牌需要相当长的生命周期才能发挥作用。这将要求创建可以使用的服务帐户，或者使您的OpenID
    Connect **id_tokens**更长寿。这两种选择都会抵消通过利用OpenID Connect进行身份验证所实施的大部分安全性。
- en: So far, we've only focused on the wrong way to deploy the dashboard. While it
    is important to understand this, what is the correct method? In the next section,
    we'll detail the correct way to deploy the dashboard using a reverse proxy.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只关注了错误的部署仪表盘的方法。虽然了解这一点很重要，但正确的方法是什么？在下一节中，我们将详细介绍使用反向代理部署仪表盘的正确方法。
- en: Deploying the dashboard with a reverse proxy
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用反向代理部署仪表盘
- en: Proxies are a common pattern in Kubernetes. There are proxies at every layer
    in a Kubernetes cluster. The proxy pattern is also used by most service mesh implementations
    on Kubernetes, creating side cars that will intercept requests. The difference
    between the reverse proxy described here and these proxies is in their intent.
    Microservice proxies often do not carry a session, whereas web applications need
    a session to manage state.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 代理是Kubernetes中常见的模式。在Kubernetes集群的每一层都有代理。代理模式也被大多数Kubernetes上的服务网格实现所使用，创建将拦截请求的sidecar。这里描述的反向代理与这些代理的区别在于它们的意图。微服务代理通常不携带会话，而Web应用程序需要会话来管理状态。
- en: 'The following diagram shows the architecture of a Kubernetes Dashboard with
    a reverse proxy:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Kubernetes Dashboard with a reverse proxy'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Fig_9.6_B15514.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.6 – Kubernetes Dashboard with a reverse proxy
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'The reverse proxy shown in *Figure 9.6* performs three roles:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication**: The reverse proxy intercepts unauthenticated requests (or
    stale sessions) and triggers the authentication process with an OpenID Connect
    identity provider to authenticate the user.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Session management**: Kubernetes'' Dashboard is a user-facing application.
    It should have the typical controls put in place to support session timeouts and
    revocation. Be wary of a reverse proxy that stores all session data in a cookie.
    These methods are difficult to revoke.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identity injection**: Once the proxy has authenticated a user, it needs to
    be able to inject an HTTP authorization header on each request that is a JWT identifying
    the logged-in user, is signed by the same OpenID Connect identity provider, and
    has the same issuer and recipient as the API server. The exception to this is
    using impersonation, which, as discussed in [*Chapter 7*](B15514_07_Final_ASB_ePub.xhtml#_idTextAnchor203)
    *, Integrating Authentication into Your Cluster*, injects specific headers into
    the requests.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reverse proxy does not need to run on the cluster. Depending on your setup,
    it may be advantageous to do so, especially when utilizing impersonation with
    your cluster. When using impersonation, the reverse proxy uses a service account's
    token, so it's best for that token to never leave the cluster.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: The focus of this chapter has been on the Kubernetes project's dashboard. There
    are multiple options for dashboard functionality. Next, we'll explore how these
    dashboards interact with the API server and how to evaluate their security.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Local dashboards
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common theme among third-party dashboards is to run locally on your workstation
    and use a Kubernetes SDK to interact with the API server the same way kubectl
    would. These tools offer the benefit of not having to deploy additional infrastructure
    to secure them.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Visual Studio Code''s Kubernetes plugin is an example of a local application
    leveraging direct API server connections. When launching the plugin Visual Studio
    Code accesses your current kubectl configuration and interacts with the API server
    using that configuration. It will even refresh an OpenID Connect token when it
    expires:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Visual Studio Code with the Kubernetes plugin'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Fig_9.7_B15514.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.7 – Visual Studio Code with the Kubernetes plugin
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: The Kubernetes plugin for Visual Studio Code is able to refresh its OpenID Connect
    Token because it's built with the client-go SDK, the same client libraries used
    by kubectl. When evaluating client dashboards make sure it works with your authentication
    type even if it isn't OpenID Connect. Many of the SDKs for Kubernetes don't support
    OpenID Connect token refreshes. The Java and Python SDKs only recently (as of
    the published date of this book) began supporting the refresh of OpenID Connect
    tokens the way the client-go SDK does. When evaluating a local dashboard, make
    sure it's able to leverage your short-lived tokens and can refresh them as needed,
    just like kubectl can.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Other cluster-level applications
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The introduction of this chapter discussed how a cluster is made up of several
    applications besides Kubernetes. Other applications will likely follow the same
    model as the dashboard for security, and the reverse proxy method is a better
    method for exposing those applications than kubectl port-forward, even when the
    application has no built-in security. Use the common Prometheus stack as an example.
    Grafana has support for user authentication, but Prometheus and Alert Manager
    do not. How would you track who had access to these systems or when they were
    accessed using port-forwarding?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: There's no user context provided. Using a reverse proxy, logs of each URL and
    the user that was authenticated to access the URL can be forwarded to a central
    log management system and analyzed by a **Security Information and Event Manager**
    (**SIEM**) providing an additional layer of visibility into a cluster's usage.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Just as with the dashboard, using a reverse proxy with these applications provides
    a layered security approach. It offloads sessions management from the application
    in question and provides the capability to have enhanced authentication measures
    in place such as multi-factor authentication and session revocation. These benefits
    will lead to a more secure, and easier to use, cluster.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the dashboard with OpenUnison
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The topic of how OpenUnison injected identity headers using impersonation was
    covered in [*Chapter 7*](B15514_07_Final_ASB_ePub.xhtml#_idTextAnchor203)*, Integrating
    Authentication into Your Cluster*, but not how OpenUnison injected user's identity
    into the dashboard with an OpenID Connect integrated cluster. It worked, but it
    wasn't explained. This section will use the OpenUnison implementation as an example
    of how to build a reverse proxy for the dashboard. Use the information in this
    section to get a better understanding of API security or to build your own solution
    for dashboard authentication.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'The OpenUnison deployment comprises two integrated applications:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '**The OpenID Connect Identity Provider & Login Portal**: This application hosts
    the login process and the discovery URLs used by the API server to get the keys
    needed to validate an **id_token**. It also hosts the screens where you can obtain
    your token for kubectl.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The dashboard**: A reverse proxy application that authenticates to the integrated
    OpenID Connect identity provider and injects the user''s **id_token** into each
    request.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This diagram shows how the dashboard's user interface interacts with its server
    side component with a reverse proxy injecting the user's **id_token****:**
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – OpenUnison integration with the dashboard'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Fig_9.8_B15514.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.8 – OpenUnison integration with the dashboard
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: The dashboard uses the same OpenID Connect identity provider as the API server,
    but doesn't use the **id_token** provided by it. Instead, OpenUnison has a plugin
    that will generate a new **id_token** independent of the identity provider with
    the user's identity data in it. OpenUnison can do this because the key used to
    generate an **id_token** for the OpenID Connect identity provider, used by kubectl
    and the API server, is stored in OpenUnison.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: A new, short-lived token is generated separate from the OpenID Connect session
    used with kubectl. This way, the token can be refreshed independently of a kubectl
    session. This process provides the benefits of 1- to 2-minute token life with
    the convenience of a direct login process.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: If you have an eye for security, you may point out that this method has a glaring
    single-point-of-failure in the security model, a user's credentials! Just as with
    the Secret dashboard built earlier in this chapter in the *Understanding dashboard
    security risks section*, an attacker generally just needs to ask for credentials
    in order to get them. This is often done via email in an attack called phishing,
    where an attacker sends a victim a link to a page that looks like their login
    page but really just collects credentials. This is why multi-factor authentication
    is so important for infrastructure systems.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: In a 2019 study, Google showed multi-factor authentication stopped 99% of automated
    and phishing attacks (https://security.googleblog.com/2019/05/new-research-how-effective-is-basic.html).
    Adding multi-factor authentication to the identity provider OpenUnison authenticates
    against, or integrating it directly into OpenUnison, is one of the most effective
    ways to secure the dashboard and your cluster.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the security of the Kubernetes Dashboard in detail.
    First, we walked through the architecture and how the dashboard passes your identity
    information on to the API server. We then explored how the dashboard gets compromised,
    and finally we detailed how to correctly deploy the dashboard securely.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge, you can now provide a secured tool to your users. Many
    users prefer the simplicity of accessing the dashboard via a web browser. Adding
    multi-factor authentication adds an additional layer of security and peace of
    mind. When your security team questions the security of the dashboard, you'll
    have the answers needed to satisfy their concerns.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: The previous three chapters focused on the security of the Kubernetes APIs.
    Next, we'll explore securing the soft underbelly of every Kubernetes deployment,
    nodes!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The dashboard is insecure.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. True
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: B. False
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: How can the dashboard identify a user?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. The options are either no authentication, or a token injected from a reverse
    proxy
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: B. Username and password
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: C. ServiceAccount
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: D. Multi-factor authentication
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: How does the dashboard track session state?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. Sessions are stored in etcd.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: B. Sessions are stored in custom resource objects called **DashboardSession**.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: C. There are no sessions.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: D. If a token is uploaded, it's encrypted and stored in the browser as a cookie.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: When using a token, how often can the dashboard refresh it?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. Once a minute
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: B. Every thirty seconds
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: C. When the token expires
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: C. 当令牌过期时
- en: D. None of the above
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: D. 以上都不是
- en: What's the best way to deploy the dashboard?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署仪表板的最佳方式是什么？
- en: A. Using **kubectl port-forward**
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: A. 使用**kubectl端口转发**
- en: B. Using **kubectl proxy**
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: B. 使用**kubectl代理**
- en: C. With a secret ingress host
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: C. 使用秘密的入口主机
- en: D. Behind a reverse proxy
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: D. 在反向代理后面
- en: The dashboard doesn't support impersonation.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仪表板不支持冒充。
- en: A. True
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: A. 正确
- en: B. False
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: B. 错误
- en: OpenUnison is the only reverse proxy that supports the dashboard.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OpenUnison是唯一支持仪表板的反向代理。
- en: A. True
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: A. 正确
- en: B. False
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: B. 错误
