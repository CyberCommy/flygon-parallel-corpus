- en: Build, Run, and Test Your Service Using Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having designed a working RESTful microservice in the previous chapter, we'll
    see in this chapter how to use it in *the Docker way*, encapsulating the service
    into a self-contained container so that it's immutable and can be deployed on
    its own. This chapter describes very explicitly the dependencies of the service
    and the ways it can be used. The main way to run a service is to run it as a web
    server, but other operations are possible, such as running unit tests, generating
    reports, and others. We'll see also how to deploy the service on your local computer
    for testing and how to share it through an image repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Building your service with a Dockerfile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operating with an immutable container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring your service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying the Docker service locally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pushing your Docker image to a remote registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you'll know how to operate with Docker, create a
    basic service, build an image, and run it. You'll also know how to share the image
    to be run on another computer.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you need to install Docker, version 18.09 or above. See the
    official documentation ([https://docs.docker.com/install/](https://docs.docker.com/install/))
    for how to do so for your platform.
  prefs: []
  type: TYPE_NORMAL
- en: If you install Docker in Linux, you may have to configure the server to run
    for non-root access. Check the documentation at [https://docs.docker.com/install/linux/linux-postinstall/](https://docs.docker.com/install/linux/linux-postinstall/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the version with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You need to install Docker Compose version 1.24.0 or above as well. Note that,
    in some installations, such as macOS, this is automatically installed for you.
    Check the installation instructions in the Docker documentation ([https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The code is available on GitHub, in this directory: [https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter03](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter03).
    There's a copy of `ThoughtsBackend` presented in [Chapter 2](8f5b60ee-fa8e-42ff-aa6c-fb27d4bd574a.xhtml),
    *Creating a REST Service with Python*, but the code is slightly different. We
    will look at the differences in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Building your service with a Dockerfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It all starts with a container. As we said in [Chapter 1](ddb0a00a-6c5b-4ffe-b403-0f5f9f7a7df2.xhtml),
    *Making the Move – Design, Plan, and Execute*, containers are a packetized bundle
    of software, encapsulated in a standard way. They are units of software that can
    be run independently, as they are totally self-contained. To make a container,
    we need to build it.
  prefs: []
  type: TYPE_NORMAL
- en: Remember our description of a container as a process surrounded by its own filesystem.
    Building a container constructs this filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: To build a container with Docker, we need a definition of its content. The filesystem
    is created by applying layer after layer. Each Dockerfile, the recipe for generating
    a container, contains a definition of steps to generate a container.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s create a very simple Dockerfile. Create a file called `example.txt`
    with some example text and another called `Dockerfile.simple` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now build it using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This creates a Docker image that only contains the `example.txt` file. It's
    not very useful, but quite small—only 11 bytes. That's because it inherits from
    the empty container, `scratch`. It then copies the `example.txt` file inside the
    location in the `/example.txt` container.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the `docker build` command. The Dockerfile is defined with
    the `-f` parameter, the tag of the resulting image is defined with `--tag `, and
    the `context` parameter is defined as dot (`.`). The `context` parameter is the
    reference to where to look for the files defined in the steps in the Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: The image also has the image ID `f961aef9f15c`, which is assigned automatically.
    This is a hash of the contents of the filesystem. We'll see later why this is
    relevant.
  prefs: []
  type: TYPE_NORMAL
- en: Executing commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous container was not very exciting. It is definitively possible to
    create your own container totally from scratch, but, typically, you'll look for
    a baseline that contains some sort of Linux distribution that allows you to do
    something useful with the container.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw with the `FROM` command, we can start with a previous container. We
    will use the Alpine Linux ([https://alpinelinux.org/](https://alpinelinux.org/))
    distribution throughout the book, though other distributions are available, such
    as Ubuntu and CentOS. Check out the article at [https://sweetcode.io/linux-distributions-optimized-hosting-docker/](https://sweetcode.io/linux-distributions-optimized-hosting-docker/) for
    distributions aimed at Docker containers.
  prefs: []
  type: TYPE_NORMAL
- en: Why Alpine Linux? It is arguably the most popular distribution for Docker systems
    because it has a very small footprint and it's aimed at security. It is well-maintained
    and regularly updated and patched. It also has a complete package management system
    that allows you to install most of the common tools for web services easily. The
    base image is only around 5 MB in size and contains a working Linux operating
    system.
  prefs: []
  type: TYPE_NORMAL
- en: It has a couple of quirks when working with it, such as using its own package
    management, called `apk`, but it's easy to use and is almost a straight-on drop
    replacement for common Linux distributions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Dockerfile will inherit from the base `alpine` container and
    add the `example.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This container allows us to run commands, as the usual command-line utilities
    are included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how the `cat /opt/example.txt` command line gets executed. This is actually
    happening inside the container. We print the result in `stdout` in our `stdout` console.
    However, if there''s a file created, as the container stops, the file is not saved
    in our local filesystem, but only inside container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The file is actually saved in a stopped container. Once the container has finished
    its run, it remains stopped by Docker until removed. You can see the stopped container
    with the `docker ps -a` command. A stopped container is not very interesting,
    though its filesystem is saved on disk.
  prefs: []
  type: TYPE_NORMAL
- en: When running web services, the command being run won't stop; it will keep running
    until stopped. Remember what we said before about a container being a process
    with a filesystem attached. The command running is the key to the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add a default command, which will be executed when no command is given,
    by adding the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Make it run automatically by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Defining a standard command makes the container really simple. Just run it and
    it will do whatever it is configured to do. Remember to include a default command
    in your containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also execute a shell in the container and interact with it. Remember
    to add the `-it` flag to keep the connection properly open, `-i` to keep `stdin`
    open, and `-t` to create a pseudo Terminal, you can remember it as interactive
    Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is very useful when finding out problems or performing exploratory tests.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Docker cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main points of confusion when building images is understanding how
    the Docker layers work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the commands on a Dockerfile is executed consecutively and on top of
    the previous layer. If you are comfortable with Git, you''ll notice that the process
    is similar. Each layer only stores the changes to the previous step:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/14605f6c-28fa-4b09-be18-960f278ac5f0.png)'
  prefs: []
  type: TYPE_IMG
- en: This allows Docker to cache quite aggressively, as any layer before a change
    is already calculated. For example, in this example, we update the available packages
    with `apk update`, then install the `python3` package, before copying the `example.txt`
    file. Any changes to the `example.txt` file will only execute the last two steps
    over layer `be086a75fe23`. This speeds up the rebuilding of images.
  prefs: []
  type: TYPE_NORMAL
- en: It also means that you need to construct your Dockerfiles carefully to not invalidate
    the cache. Start with the operations that change very rarely, such as installing
    the project dependencies, and finish with the ones that change more often, such
    as adding your code. The annotated Dockerfile for our example has indications
    about the usage of the cache.
  prefs: []
  type: TYPE_NORMAL
- en: This also means that an image will never get smaller in size, adding a new layer
    even if the layer removes data, as the previous layer is still stored on the disk.
    If you want to remove cruft from a step, you'll need to do so in the same step.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping your containers small is quite important. In any Docker system, the
    tendency is to have a bunch of containers and lots of images. Big images for no
    reason will fill up repositories quickly. They'll be slow to download and push,
    and also slow to start, as the container is copied around in your infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: There's another practical consideration. Containers are a great tool to simplify
    and reduce your service to the minimum. With a bit of investment, you'll have
    great results and keep small and to-the-point containers.
  prefs: []
  type: TYPE_NORMAL
- en: There are several practices for keeping your images small. Other than being
    careful to not install extra elements, the main ones are creating a single, complicated
    layer that installs and uninstalls, and multi-stage images. Multi-stage Dockerfiles
    are a way of referring to a previous intermediate layer and copying data from
    there. Check the Docker documentation ([https://docs.docker.com/develop/develop-images/multistage-build/](https://docs.docker.com/develop/develop-images/multistage-build/)).
  prefs: []
  type: TYPE_NORMAL
- en: Compilers, in particular, tend to get a lot of space. When possible, try to
    use precompiled binaries. You can use a multi-stage Dockerfile to compile in one
    container and then copy the binaries to the running one.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about the differences between the two strategies in this
    article: [https://pythonspeed.com/articles/smaller-python-docker-images/](https://pythonspeed.com/articles/smaller-python-docker-images/).'
  prefs: []
  type: TYPE_NORMAL
- en: A good tool to analyze a particular image and the layers that compose it is
    `dive` ([https://github.com/wagoodman/dive](https://github.com/wagoodman/dive)).
    It will also discover ways that an image can be reduced in size.
  prefs: []
  type: TYPE_NORMAL
- en: We'll create a multi-stage container in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Building a web service container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have a specific objective, to create a container that is capable of running
    our microservice, `ThoughtsBackend`. To do so, we have a couple of requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to copy our code to the container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code needs to be served through a web server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, in broad strokes, we need to create a container with a web server, add our
    code, configure it so it runs our code, and serve the result when starting the
    container.
  prefs: []
  type: TYPE_NORMAL
- en: We will store most of the configuration files inside subdirectories in the `./docker`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: As a web server, we will use uWSGI ([https://uwsgi-docs.readthedocs.io/en/latest/](https://uwsgi-docs.readthedocs.io/en/latest/)).
    uWSGI is a web server capable of serving our Flask application through the WSGI
    protocol. uWSGI is quite configurable, has a lot of options, and is capable of
    serving HTTP directly.
  prefs: []
  type: TYPE_NORMAL
- en: A very common configuration is to have NGINX in front of uWSGI to serve static
    files, as it's more efficient for that. In our specific use case, we don't serve
    many static files, as we're running a RESTful API, and, in our main architecture,
    as described in [Chapter 1](ddb0a00a-6c5b-4ffe-b403-0f5f9f7a7df2.xhtml), *Making
    the Move – Design, Plan, and Execute*, there's already a load balancer on the
    frontend and a dedicated static files server. This means we won't be adding an
    extra component for simplicity. NGINX usually communicates to uWSGI using the
    `uwsgi` protocol, which is a protocol specifically for the uWSGI server, but it
    can also do it through HTTP. Check the NGINX and uWSGI documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `docker/app/Dockerfile` file. It has two stages;
    the first one is to compile the dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This stage does the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Names the stage `compile-image`, inheriting from Alpine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installs `python3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installs the build dependencies, including the `gcc` compiler and Python headers
    (`python3-dev`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creates a new virtual environment. We will install all the Python dependencies
    here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The virtual environment gets activated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installs uWSGI. This step compiles it from code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also install the included uWSGI package in the Alpine distribution,
    but I found the compiled package to be more complete and easier to configure,
    as the Alpine `uwsgi` package requires you to install other packages such as `uwsgi-python3`,
    `uwsgi-http`, and so on, then enable the plugin in the uWSGI config. The size
    difference is minimal. This also allows you to use the latest uWSGI version and
    not depend on the one in your Alpine distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Copy the `requirements.txt` file and install all the dependencies. This will
    compile and copy the dependencies to the virtual environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The second stage is preparing the running container. Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'It carries out the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Labels the image as `runtime-image` and inherits from Alpine, as previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installs Python and other requirements for the runtime.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that any runtime required for compilation needs to be installed. For example,
    we install `libffi` in the runtime and `libffi-dev` to compile, required by the
    `cryptography` package. A mismatch will raise a runtime error when trying to access
    the (non-present) libraries. The `dev` libraries normally contain the runtime
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Copy the uWSGI configuration and script to start the service. We'll take a look
    at that in a moment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a user to run the service, and set it as the default using the `USER`
    command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This step is not strictly necessary as, by default, the root user will be used.
    As our containers are isolated, gaining root access in one is inherently more
    secure than in a real server. In any case, it's good practice to not configure
    our public-facing service accessing as root and it will remove some understandable
    warnings.
  prefs: []
  type: TYPE_NORMAL
- en: Copy the virtual environment from the `compile-image` image. This installs all
    the compiled Python packages. Note that they are copied with the user to run the
    service, to have access to them. The virtual environment is activated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the application code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the run parameters. Note that port `8000` is exposed. This will be the
    port we will serve the application on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If running as root, port `80` can be defined. Routing a port in Docker is trivial,
    though, and other than the front-facing load balancer, there's not really any
    reason why you need to use the default HTTP port. Use the same one in all your
    systems, though, which will remove uncertainty.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the application code is copied at the end of the file. The application
    code is likely going to be the code that changes most often, so this structure
    takes advantage of the Docker cache and recreates only the very few last layers,
    instead of having to start from the beginning. Take this into account when designing
    your Dockerfiles.
  prefs: []
  type: TYPE_NORMAL
- en: Also, keep in mind that there's nothing stopping you from changing the order
    while developing. If you're trying to find a problem with a dependency, and so
    on, you can comment out irrelevant layers or add steps later once the code is
    stable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build our container now. See that there are two images created, though
    only one is named. The other is the compile image, which is much bigger as it
    contains the compilers, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can run the container. To be able to access the internal port `8000`,
    we need to route it with the `-p` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Accessing our local browser to `127.0.0.1` shows our application. You can see
    the access logs in the standard output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b89b7dd6-5676-4799-8613-bc8cf531e29a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can access a running container from a different Terminal with `docker exec`
    and execute a new shell. Remember to add `-it` to keep the Terminal open. Inspect
    the currently running containers with `docker ps` to find the container ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can stop the container with *Ctrl* + *C*, or, more gracefully, stop it
    from another Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The logs will show `graceful stop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Capturing `SIGTERM` properly and stopping our services gracefully is important
    for avoiding abrupt terminations of services. We'll see how to configure this
    in uWSGI, as well as the rest of the elements.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring uWSGI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `uwsgi.ini` file contains the uWSGI configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Most of it is information that we have from the Dockerfile, though it needs
    to match so that uWSGI knows where to find the application code, the name of the
    WSGI file to start, the user to start it from, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other parameters are specific to uWSGI behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '`master`: Creates a master process that controls the others. Recommended for
    uWSGI operation as it creates smoother operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http`: Serves in the specified port. The HTTP mode creates a process that
    load balances the HTTP requests toward the workers, and it''s recommended to serve
    HTTP outside of the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`processes`: The number of application workers. Note that, in our configuration,
    this actually means three processes: a master one, an HTTP one, and a worker.
    More workers can handle more requests but will use more memory. In production,
    you''ll need to find what number works for you, balancing it against the number
    of containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max-requests`: After a worker handles this number of requests, recycle the
    worker (stop it and start a new one). This reduces the probability of memory leaks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vacuum`: Clean the environment when exiting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`master-fifo`: Create a Unix pipe to send commands to uWSGI. We will use this
    to handle graceful stops.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The uWSGI documentation ([https://uwsgi-docs.readthedocs.io/en/latest/](https://uwsgi-docs.readthedocs.io/en/latest/))
    is quite extensive and comprehensive. It contains a lot of valuable information,
    both for operating uWSGI itself and understanding details about how web servers
    operate. I learn something new each time that I read it, but it can be a bit overwhelming
    at first.
  prefs: []
  type: TYPE_NORMAL
- en: It's worth investing a bit of time in running tests to discover what are the
    best parameters for your service in areas such as timeouts, the number of workers,
    and so on. However, remember that some of the options for uWSGI may be better
    served with your container's configuration, which simplifies things.
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow graceful stops, we wrap the execution of uWSGI in our `start_server.sh` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The core of the script is the call to `uwsgi` to start the service. It will
    then wait until it stops.
  prefs: []
  type: TYPE_NORMAL
- en: The `SIGTERM` signal will be captured and uWSGI will be stopped gracefully by
    sending the `q` command to the `master-fifo` pipe.
  prefs: []
  type: TYPE_NORMAL
- en: A graceful stop means that a request won't be interrupted when a new container
    version is available. We'll see later how to make rollout deployments, but one
    of the key elements is to interrupt existing servers when they are not serving
    requests, to avoid stopping in the middle of a request and leaving an inconsistent
    state.
  prefs: []
  type: TYPE_NORMAL
- en: Docker uses the `SIGTERM` signal to stop the execution of containers. After
    a timeout, it will kill them with `SIGKILL`.
  prefs: []
  type: TYPE_NORMAL
- en: Refreshing Docker commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve looked at some of the important Docker commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker build`: Builds an image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker run`: Runs an image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker exec`: Executes a command in a running container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker ps`: Shows the currently running containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker images`: Displays the existing images'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While these are the basic ones, knowing most of the available Docker commands
    is very useful for debugging problems and to perform operations such as monitoring,
    copying and tagging images, creating networks, and so on. These commands will
    also show you a lot about how Docker works internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'An important command: be sure to clean up old containers and images with `docker
    system prune` from time to time. Docker is quite space-intensive after working
    with it for a few weeks.'
  prefs: []
  type: TYPE_NORMAL
- en: The Docker documentation ([https://docs.docker.com/v17.12/engine/reference/commandline/docker/](https://docs.docker.com/v17.12/engine/reference/commandline/docker/))
    is quite complete. Be sure to know your way around it.
  prefs: []
  type: TYPE_NORMAL
- en: Operating with an immutable container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker commands such as the ones seen earlier in this chapter are the foundation,
    where it all starts. But, when dealing with more than one, it starts getting complicated
    to handle them. You've seen that some commands can get quite long.
  prefs: []
  type: TYPE_NORMAL
- en: To operate with a container in a clustered operation, we will use `docker-compose`.
    This is Docker's own orchestration tool for defining multi-container operations.
    It gets defined by a YAML file with all the different tasks and services, each
    with enough context to build and run it.
  prefs: []
  type: TYPE_NORMAL
- en: It allows you to store the different services and parameters for each of them in
    this configuration file, called `docker-compose.yaml` by default. This allows
    you to coordinate them and generate a replicable cluster of services.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start by creating a service to run the unit tests. Keep in mind that
    the tests need to run *inside* the container. This will standardize the execution
    of them and ensure that the dependencies are constant.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, in the creation of our container, we include all the requirements
    to execute the tests. There's the option to create the running container and inherit
    from it to add the tests and test dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: This certainly creates a smaller running container but creates a situation where
    the testing container is not 100% exactly the same as the one in production. If
    the size is critical and there's a big difference, this may be an option, but
    be aware of the differentiation if there's a subtle bug.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to define a service in the `docker-compose.yaml` file, in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This section defines a service called `test-sqlite`. The build defines the Dockerfile
    to use and the context, in the same way as we'd do with a `docker build` command.
    `docker-compose` automatically sets the name.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can build the container with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`entrypoint` specifies the command to run, in this case, running the tests
    through the `pytest` command.'
  prefs: []
  type: TYPE_NORMAL
- en: There are some differences between the command and the `entrypoint`, which both
    execute a command. The most relevant ones are that `command` is easier to overwrite
    and `entrypoint` appends any extra arguments at the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the container, call the `run` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You can append `pytest` arguments that will be passed over to the internal
    `entrypoint`. For example, to run tests that match the *validation* string, run
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two extra details: the current code is mounted through a volume and
    overwrites the code in the container. See how the current code in `./ThoughtsBackend`
    is mounted in the position of the code in the container, `/opt/code`. This is
    very handy for the development, as it will avoid having to rebuild the container
    each time a change is made.'
  prefs: []
  type: TYPE_NORMAL
- en: This also means that any write in the mounted directory hierarchy will be saved
    in your local filesystem. For example, the `./ThoughtsBackend/db.sqlite3` database
    file allows you to use it for testing. It will also store generated `pyc` files.
  prefs: []
  type: TYPE_NORMAL
- en: The generation of the `db.sqlite3` file can create permission problems in some
    operating systems. If that's the case, delete it to be regenerated and/or allow
    it to read and write to all users with `chmod 666 ./ThoughtsBackend/db.sqlite3`.
  prefs: []
  type: TYPE_NORMAL
- en: That's why we use the `environment` option to pass a `PYTHONDONTWRITEBYTECODE=1`
    environment variable. This stops Python from creating `pyc` files.
  prefs: []
  type: TYPE_NORMAL
- en: While SQLite is good for testing, we need to create a better structure reflective
    of the deployment and to configure the access to the database to be able to deploy
    the server.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a PostgreSQL database container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to test our code against a PostgreSQL database. This is the database
    that we will be deploying the code in production against.
  prefs: []
  type: TYPE_NORMAL
- en: While the abstraction layer in SQLAlchemy aims to reduce the differences, there
    are some differences in the behavior of the databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in `/thoughts_backend/api_namespace.py`, the following line is
    case-insensitive, which is the behavior that we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Translating that to PostgreSQL, it is case-sensitive, which requires you to
    check it. This would be a bug in production if testing with SQLite and running
    in PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The replaced code, using `ilike` for the expected behavior, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`param = f''%{search_param}%''`'
  prefs: []
  type: TYPE_NORMAL
- en: '`query = (query.filter(ThoughtModel.text.ilike(param)))`'
  prefs: []
  type: TYPE_NORMAL
- en: We kept the old code in a comment to show this issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a database container, we need to define the corresponding Dockerfile.
    We store all the files in the `docker/db/` subdirectory. Let''s take a look at
    Dockerfile and its different parts. The whole file can be found on GitHub ([https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter03/docker/db/Dockerfile](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter03/docker/db/Dockerfile)).
    This Dockerfile can be divided into the following stages:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `ARG` keyword, define the basic PostgreSQL configuration such as the
    name of the database, user, and password. They get set in environment variables
    so that the PostgreSQL commands can use them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These commands are for local development only. They'll need to match with the
    environment set up. The `ARG` keyword defines a parameter for Dockerfile at build
    time. We'll see how they are set up as input parameters in the `docker-compose.yaml`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ARG` elements are also defined as `ENV` variables, so we keep them defined
    as environment variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the `postgresql` package and all its dependencies, such as Python 3
    and its compilers. We will need them to be able to run the application code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Install and run the `postgres-setup.sh` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This initializes the database, setting the correct user, password, and so on.
    Note that this doesn't create the specific tables for our application yet.
  prefs: []
  type: TYPE_NORMAL
- en: As part of our initialization, we create the data files inside the container.
    This means that the data won't persist after the container stops. This is a good
    thing for testing, but, if you want to access the data for debug purposes, remember
    to keep the container up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the requirements for our application and specific commands to run in
    the database container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the application code and database commands stored in `docker/db`. Run
    the `prepare_db.sh` script, which creates the application database structure.
    In our case, it sets up the `thoughts` table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This script first starts the PostgreSQL database running in the background,
    then calls `init_db.py`, and then gracefully stops the database.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that, in each of the steps of Dockerfile, in order to access the
    database, it needs to be running, but it will also be stopped at the end of each
    step. In order to avoid corruption of the data or the abrupt killing of the process,
    be sure to use the `stop_postgres.sh` script until the end. Though PostgreSQL
    will normally recover for an abruptly stopped database, it will slow the startup
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start the database in operation, the CMD is just the `postgres` command.
    It needs to run with the `postgres` user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the database service, we need to set it up as part of the `docker-compose`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `args` parameter will set up the `ARG` values during the build.
    We also route the PostgreSQL port to allow access to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now build and start the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In a different Terminal, you can use a PostgreSQL client to access the database.
    I recommend the fantastic `pgcli`. You can check out its documentation ([https://www.pgcli.com/](https://www.pgcli.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: You can use also the official `psql` client or any other PostgreSQL client of
    your preference. The documentation for the default client can be found here: [https://www.postgresql.org/docs/current/app-psql.html](https://www.postgresql.org/docs/current/app-psql.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we use the `PGPASSWORD` environment variable to show that the password
    is the previously configured one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Being able to access the database is useful for debugging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring your service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can configure the service to use environment variables to change the behavior.
    For containers, this is a fantastic alternative to using configuration files,
    as it allows immutable containers that get their configuration injected. This
    is in line with the Twelve-Factor App ([https://12factor.net/config](https://12factor.net/config))
    principles and allows for good separation between code and configuration, and
    the setting up of the different deploys that the code might be used for.
  prefs: []
  type: TYPE_NORMAL
- en: One of the advantages that we'll look at later with the use of Kubernetes is
    creating new environments on-demand, which can be tweaked for testing purposes
    or tailored for development or demo. Being able to quickly change all the configuration
    by injecting the proper environment makes this operation very easy and straightforward.
    It also allows you to enable or disable features, if properly configured, which
    helps the enablement of features on launch day, with no code rollout.
  prefs: []
  type: TYPE_NORMAL
- en: This allows the configuration of the database to connect to, so we can choose
    between the SQLite backend or PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the system is not limited to open variables, though. Environment
    variables will be used later in the book for storing secrets. Note that a secret
    needs to be available inside the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will configure the tests to access our newly created database container.
    To do that, we first need the ability to choose between either SQLite or PostgreSQL
    through configuration. Check out the `./ThoughtsBackend/thoughts_backend/db.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: When using the `DATABASE_ENGINE` environment variable set to `POSTGRESQL`, it
    will configure it properly. Other environment variables will need to be correct;
    that is, if the database engine is set to PostgreSQL, the `POSTGRES_HOST` variable
    needs to be set up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Environment variables can be stored individually in the `docker-compose.yaml`
    file, but it''s more convenient to store multiple ones in a file. Let''s take
    a look at `environment.env`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note that the definition of users, and so on is in line with the arguments to
    create Dockerfile for testing. `POSTGRES_HOST` is defined as `db`, which is the
    name of the service.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the Docker cluster created for `docker-compose`, you can refer to services
    by their names. This will be directed by the internal DNS to the proper container,
    as a shortcut. This allows easy communication between services, as they can configure
    their access very easily by name. Note that this connection is only valid inside
    the cluster, for communication between containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our testing service using the PostgreSQL container then gets defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This is very similar to the `test-sqlite` service, but it adds the environment
    configuration in `environment.env` and adds a dependency on `db`. This means that
    `docker-compose` will start the `db` service, if not present.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now run the tests against the PostgreSQL database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This environment file will be useful for any service that needs to connect to
    the database, such as deploying the service locally.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the Docker service locally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With all these elements, we can create the service to locally deploy the Thoughts
    service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We need to be sure to add the dependency of the `db` database service. We also
    bound the internal port so that we can access it locally.
  prefs: []
  type: TYPE_NORMAL
- en: We start the service with the `up` command. There are some differences between
    the `up` and the `run` commands, but the main one is that `run` is for single
    commands that start and stop, while `up` is designed for services. For example,
    `run` creates an interactive Terminal, which displays colors, and `up` shows the
    standard output as logs, including the time when they were generated, accepts
    the `-d` flag to run in the background, and so on. Using one instead of the other
    is normally okay, however, `up` exposes ports and allows other containers and
    services to connect, while `run` does not.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start the service now with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now access the service in `localhost:8000` in a browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/741100a2-4db5-4976-9d76-557fb89dcdaf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see the logs in the Terminal. Hitting *Ctrl* + *C* will stop the server.
    The service can also be started using the `-d` flag, to detach the Terminal and
    run in daemon mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the running services, their current state, and open ports with `docker-compose
    ps`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'As we''ve seen before, we can directly access the database and run raw SQL
    commands in it. This can be useful for debugging problems or conducting experiments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the thought is available through the following API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to see the logs in detach mode, you can use the `docker-compose
    logs <optional: service>` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'To totally stop the cluster, call `docker-compose down`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This stops all the containers.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing your Docker image to a remote registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the operations that we've seen work with our local Docker repository. Given
    the structure of Docker images and the fact that each layer can be worked on independently,
    they are easy to upload and share. To do so, we need to use a remote repository,
    or registry in Docker terminology, that will accept images pushed to it, and allow
    images to be pulled from it.
  prefs: []
  type: TYPE_NORMAL
- en: The structure of a Docker image is composed of each of the layers. Each of them
    can be pushed independently, as long as the registry contains the layer it depends
    on. This saves space if the previous layers are already present, as they will
    be stored only once.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining public images from Docker Hub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The default registry is Docker Hub. This is configured by default, and it serves
    as the main source of public images. You can access it freely in [https://hub.docker.com/](https://hub.docker.com/)
    and search for available images to base your images on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11179995-9c90-434a-9807-c307bd277d53.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Each image has information about the way to use it and the tags that are available.
    You don''t need to download the images independently, just to use the name of
    the image or run a `docker pull` command. Docker will automatically pull from Docker
    Hub if no other registry is specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa6ae25c-9a50-42dc-88be-d66941b5743f.png)'
  prefs: []
  type: TYPE_IMG
- en: The name of the image is also the one to use in our `FROM` command in Dockerfiles.
  prefs: []
  type: TYPE_NORMAL
- en: Docker is a fantastic way of distributing a tool. It's very common right now
    for an open source tool to have an official image in Docker Hub that can be downloaded
    and started in a standalone model, standardizing the access.
  prefs: []
  type: TYPE_NORMAL
- en: This can be used either for a quick demo, for something such as Ghost—[https://hub.docker.com/_/ghost](https://hub.docker.com/_/ghost) (a
    blogging platform), or a Redis ([https://hub.docker.com/_/redis](https://hub.docker.com/_/redis))
    instance to act as cache with minimal work. Try to run the Ghost example locally.
  prefs: []
  type: TYPE_NORMAL
- en: Using tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tags are descriptors to label different versions of the same image. There's
    an image, `alpine:3.9`, and another, `alpine:3.8`. There are also official images
    of Python for different interpreters (3.6, 3.7, 2.7, and so on), but other than
    versions, the interpreters may refer to ways the image is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, these images have the same effect. The first one is a full image
    containing a Python 3.7 interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The second one also has a Python 3.7 interpreter. Note the `slim` change in
    the name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the sizes of the images are quite different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Any build uses the `latest` tag automatically if another tag is not specified.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that tags can be overwritten. This may be confusing, given some
    of the similarities between the way Docker and Git work, as the term "tag" in
    Git means something that can't change. A tag in Docker is similar to a branch
    in Git.
  prefs: []
  type: TYPE_NORMAL
- en: 'A single image can be tagged multiple times, with different tags. For example,
    the `latest` tag can also be version `v1.5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Note how `image id` is the same. Using tags allows you to label specific images,
    so we know they are ready to deploy or give them some kind of significance.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing into a registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have our image tagged, we can push it to a shared registry so that it's
    available for other services to use.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to deploy your own Docker registry, but, unless strictly necessary,
    it's better to avoid it. There are cloud providers that allow you to create your
    own registry, either public or private, and even in your own private cloud network.
    If you want to make your image available, the best alternative is Docker Hub,
    as it's the standard and it will be most accessible. In this chapter, we will
    create one here, but we'll explore other options later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s worth saying it again: maintaining your own Docker registry is much more
    expensive than using a provider one. Commercial prices for registries, unless
    you require a lot of repos will be in the range of tens of dollars per month,
    and there are options from well-known cloud providers such as AWS, Azure, and
    Google Cloud.'
  prefs: []
  type: TYPE_NORMAL
- en: Unless you really need to, avoid using your own registry.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a new repo in the Docker Hub registry. You can create a private
    repo for free, and as many public ones as you want. You need to create a new user,
    which was probably the case when downloading Docker.
  prefs: []
  type: TYPE_NORMAL
- en: A repo, in Docker terms, is a set of images with different tags; for example,
    all the tags of `thoughts-backend`. This is different from the registry, which
    is a server that contains several repos.
  prefs: []
  type: TYPE_NORMAL
- en: In more informal terms, it's common to refer to registries as *repos* and to
    repos as *images*, though, speaking purely, an image is unique and may be a tag
    (or not).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you can create a new repo as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d617ceee-0f7b-451a-9bc8-affb75606f9a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the repo is created, we need to tag our image accordingly. This means
    that it should include the username in Docker Hub to identify the repo. An alternative
    is to name the image directly with the username included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'To be able to access the repo, we need to log into Docker with our username
    and password in Docker Hub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Once logged in, you can push your image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: You can now share the image and pull it from anywhere, given that the local
    Docker is properly logged. When we deploy a production cluster, we need to be
    sure that the Docker server executing it is capable of accessing the registry
    and that it's properly logged.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to use Docker commands to create and operate
    containers. We learned most of the commonly used Docker commands, such as `build`,
    `run`, `exec`, `ps`, `images`, `tag`, and `push`.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how to build a web service container, including the preparation of configuration
    files, how to structure a Dockerfile, and how to make our images as small as possible.
    We also covered how to use `docker-compose` to operate locally and, through a
    `docker-compose.yaml` file, connect different containers running in a cluster
    configuration. This included creating a database container that allows testing
    much closer to what the production deployment will be, using the same tools.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how to use environment variables to configure our service and how to
    inject them through `docker-compose` configuration to allow different modes, such
    as testing.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we analyzed how to use a registry to share our images, and how to tag
    them adequately and allow moving them out from local development, ready to be
    used in a deployment.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to leverage the created containers and
    actions to run tests automatically and make automated tools do the heavy lifting
    for us to be sure our code is always high-quality!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What does the `FROM` keyword do in a Dockerfile?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you start a container with its predefined command?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why won't creating a step to remove files in a Dockerfile make a smaller image?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you describe how a multistage Docker build works?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the `run` and `exec` commands?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should we use the`-it` flags when using the `run` and `exec` commands?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you know any alternatives to uWSGI to serve Python web applications?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is `docker-compose` used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you describe what a Docker tag is?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it necessary to push images to a remote registry?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To further your knowledge of Docker and containers, you can check out the *Mastering
    Docker – Third Edition* book ([https://www.packtpub.com/eu/virtualization-and-cloud/mastering-docker-third-edition](https://www.packtpub.com/eu/virtualization-and-cloud/mastering-docker-third-edition)).
    For tweaking containers and learning how to make your applications more performant,
    see *Docker High Performance - Second Edition* ([https://www.packtpub.com/eu/networking-and-servers/docker-high-performance-second-edition](https://www.packtpub.com/eu/networking-and-servers/docker-high-performance-second-edition)),
    which covers a lot of techniques for analyzing and discovering performance problems.
  prefs: []
  type: TYPE_NORMAL
