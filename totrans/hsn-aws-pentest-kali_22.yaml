- en: GuardDuty
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As attackers, it is important to understand what kind of monitoring is going
    on in our target environment, as it can and will shape the entire attack plan.
    If I know that a certain type of monitoring is enabled to trigger whenever XYZ
    happens, then I won't ever perform XYZ because I know that I'll get caught. Instead,
    I'll take another route that is more likely to go under the radar. If I know that
    there is no monitoring in the environment, then I can take the easiest or quickest
    path to my goal without worrying about triggering alerts on certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Amazon Web Services** (**AWS**) offers a variety of security services, but
    the main security monitoring service is known as **GuardDuty**. It is important
    to note that even in an environment where GuardDuty is disabled, this doesn''t
    100% mean that there isn''t any monitoring going on. This is because there are
    plenty of tools, in-house to AWS as well as third-party tools that provide monitoring
    options. This chapter will cover the AWS service for monitoring, GuardDuty, which
    is a cheap, in-house solution to catch low-hanging fruit within an environment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to GuardDuty and its findings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alerting about and reacting to GuardDuty findings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bypassing GuardDuty
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to GuardDuty and its findings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GuardDuty is a continuous monitoring service offered by AWS that identifies
    and alerts about suspicious or unwanted behavior within an account. There are
    currently three data sources that it analyzes, which are **virtual private cloud**
    (**VPC**) flow logs, CloudTrail event logs, and **domain name**** system** (**DNS**) logs.
    Note that VPC flow logging and CloudTrail event logging do not need to be enabled
    on your account for GuardDuty to use them, and there is currently no way to review
    DNS logs in AWS. This means that even if there are no flow logs active in the
    environment and CloudTrail is disabled, GuardDuty will still generate findings
    from VPC flow logs, CloudTrail event logs, and DNS logs.
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to note that GuardDuty can only ingest DNS logs if the
    requests are routed through AWS DNS resolvers, which is the default for EC2 instances.
    If this is changed and requests are using an alternate DNS resolver, such as Google
    or CloudFlare, then GuardDuty cannot ingest and alert on that DNS data.
  prefs: []
  type: TYPE_NORMAL
- en: GuardDuty can be managed cross-account as well, where a single master account
    controls the GuardDuty monitoring and configuration for one or more member accounts.
    If you ever find yourself in the GuardDuty master account of an organization,
    you will potentially be able to manipulate monitoring configuration across every
    account connected with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on cross-account GuardDuty configurations, visit the AWS
    documentation here: [https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_accounts.html](https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_accounts.html).'
  prefs: []
  type: TYPE_NORMAL
- en: GuardDuty generates findings on a variety of different items. For the most up-to-date
    list, visit [https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_finding-types-active.html](https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_finding-types-active.html)
    to review the active set of findings that are generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'At a high level, GuardDuty will basically alert you about events that may resemble
    malicious behavior, such as if an EC2 instance is communicating with a known malware
    command and control server, an EC2 instance is communicating with a known Bitcoin
    mining pool, or a known hacking operating system is being used. These alerts can
    then be set up to send notifications to `CloudWatch` Events, where you can then
    react to the findings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88b2176a-6be5-406d-ad42-0b5cf081201b.png)'
  prefs: []
  type: TYPE_IMG
- en: A list of sample GuardDuty findings reported in an account in the AWS web console
  prefs: []
  type: TYPE_NORMAL
- en: Most GuardDuty finding types rely on machine learning to establish a baseline
    of normal activity by users in an account. It will alert on something if it is
    outside of that baseline and matches that finding type. Consider an example AWS
    account with two IAM users and GuardDuty enabled. One of those users is frequently
    using the IAM service to manage users, groups, and roles, and to manage the permissions
    of all of those. The other user only uses the EC2 service, even though they have
    permission to do more than that. If both users attempted to enumerate permissions
    of IAM users, groups, or roles, GuardDuty will likely not trigger the IAM user,
    because it is part of that user's baseline to interact with the IAM service like
    that. On the other hand, the EC2 user will likely generate the `Recon:IAMUser/UserPermissions` GuardDuty
    finding type, which indicates a user is trying to enumerate permissions in the
    account (and it breaks the baseline established for them).
  prefs: []
  type: TYPE_NORMAL
- en: There are many GuardDuty finding types that are very simple and are meant to
    catch low-hanging-fruit from attackers. These types of findings are generally
    simple or obvious enough that you shouldn't be triggering them anyway, even if
    you aren't directly thinking of them. Some of those findings include things such
    as port scanning an EC2 instance, brute-forcing a **secure shell** (**SSH**)/**remote
    desktop protocol** (**RDP**) server, or using Tor for your communications with
    AWS. In this chapter, we are going to focus on the more AWS-specific findings
    and more advanced findings, as the simple finding types are not necessarily within
    the scope of this book and they should be easy to bypass or avoid anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Another important note to consider is how GuardDuty uses machine learning and
    baselines to determine if it should trigger a finding or not. If you are within
    a sandbox environment that is constantly being attacked because you are testing
    out tools and attack methods, it is possible that GuardDuty will detect this activity
    as the baseline for your account. If that is the case, then it may not trigger
    certain findings that you will expect it to because it has established that type
    of activity as normal within the environment.
  prefs: []
  type: TYPE_NORMAL
- en: Alerting about and reacting to GuardDuty findings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, GuardDuty will generate findings and make them available on the
    web console. It is also possible to set up a `CloudWatch` Events rule to react
    to these findings as they come in. To do this through the AWS web console, we
    can navigate to the `CloudWatch` Events rule page and create a new rule. For this
    rule, we will select GuardDuty as the service to match, and then GuardDuty Finding
    as the event type to match. Then, we will select some sort of target to send the
    information on findings to. The target could be a variety of things, such as **simple
    notification service** (**SNS**) topic to then text or email the data of the finding
    to the security team, or possibly Lambda function, which then reacts to the finding
    type to try and automatically remediate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d67e3d8-1d75-4177-9bc4-269b47379648.png)'
  prefs: []
  type: TYPE_IMG
- en: A new CloudWatch Events rule that targets a Lambda function
  prefs: []
  type: TYPE_NORMAL
- en: This screenshot shows a `CloudWatch` Events rule being created to trigger on
    GuardDuty findings and to target the `ExampleFunction` Lambda function when it
    is triggered. This kind of rule allows you to automate alerting and/or defense
    against findings that GuardDuty is triggering.
  prefs: []
  type: TYPE_NORMAL
- en: An example Lambda function might parse the data that `CloudWatch` Events sends
    it, determine what finding type was triggered, and then react based on that. For
    example, if GuardDuty alerted that an EC2 instance was making connections to a
    known cryptocurrency-related domain, Lambda function might auto-block outbound
    internet access to that domain in the security group that the EC2 instance lies
    within. You could also add another target to the `CloudWatch` Events rule that
    uses SNS to send a text message to your security team. This way, if cryptocurrency-related
    activity was detected, it will automatically be blocked by Lambda function and
    the security team will be alerted, where they could then decide on what steps
    they should followup with to properly secure the environment again.
  prefs: []
  type: TYPE_NORMAL
- en: Bypassing GuardDuty
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many findings that GuardDuty triggers on, and with that, there are
    many ways to bypass those detections so that you do not get caught. Not everything
    can get bypassed, but as an attacker, you should at least understand what GuardDuty
    is looking for so that you can actively work to avoid or bypass it as you attack
    an environment. It is possible that just a single GuardDuty alert on your activity
    could shut down your access to the account, but it is also possible that no one
    is really paying attention to the alerts as they come in, so you won't need to
    worry as much in that situation.
  prefs: []
  type: TYPE_NORMAL
- en: If you wanted to get really advanced with it, you could also purposely trigger
    certain GuardDuty alerts to send any listening defenders on wild goose chases,
    while you are secretly doing something else in the environment. Along with this,
    if you know that the target account is using `CloudWatch` Events to trigger on
    GuardDuty findings, you can even use the `CloudWatch` Events `PutEvents` API to
    supply completely fake GuardDuty findings that may break the target of the `CloudWatch`
    Events rule because it contains unexpected data. Also, you could send data in
    the correct format, but just with false information, as it could really confuse
    a defender and/or their automation when trying to remediate the finding.
  prefs: []
  type: TYPE_NORMAL
- en: Bypassing everything with force
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first bypass we will look at is not really a bypass, but it will prevent
    GuardDuty from alerting about us. This includes either disabling monitoring for
    the GuardDuty detectors in the account or deleting them altogether. You likely
    should not use this method because of how destructive it is and how much of an
    impact it could potentially have on the environment you are attacking, but it
    is good to know it is an option. Bear in mind that this example only targets a
    single region, but it may be necessary to run these commands across every region,
    as GuardDuty must be enabled on a per-region basis.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could identify existing GuardDuty detectors with the `ListDetectors` command,
    such as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If we find one in the current region, we could disable it by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now the detector in our current region will no longer monitor and report on
    any findings.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could even take this a step further and delete the detector, rather than
    disable it. We could do this with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now that it doesn't exist, there is no way that it can be monitoring us.
  prefs: []
  type: TYPE_NORMAL
- en: Bypassing everything with IP whitelisting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The best and most effective way to bypass all of GuardDuty is to just add your
    own attacker IP address to the list of trusted IP addresses in the target account.
    It is a simple process and GuardDuty doesn''t trigger anything to do with the
    enumeration or modification of GuardDuty settings, so it will likely fly under
    the radar, even in more modern, advanced environments. If we look at the Lists tab
    of GuardDuty in the AWS web console, we will see something similar to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5cc880c9-d125-4dd2-bda0-897a23429f0a.png)'
  prefs: []
  type: TYPE_IMG
- en: Showing GuardDuty's trusted IP lists and threat lists in the AWS web console
  prefs: []
  type: TYPE_NORMAL
- en: In this screenshot, we can see that there is a section for Trusted IP lists and
    Threat lists. Respectively, they are basically a way to whitelist and blacklist
    IP addresses, telling GuardDuty to either ignore findings from these IP addresses
    (whitelist) or to trigger on everything from these IP addresses (blacklist).
  prefs: []
  type: TYPE_NORMAL
- en: As an attacker, this is amazing. We can whitelist our own IP address without
    triggering any alerts in the process, then go nuts in the environment without
    worrying about GuardDuty from that point on.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a problem that you may encounter when trying to add yourself as a
    trusted IP and that is that there is a maximum of one trusted IP list per-region
    allowed by GuardDuty. This means that if our target is already utilizing the trusted
    IP list, we''ll have to modify our attack slightly. The first thing to do will
    be to determine whether they are, in fact, using the trusted IP list or not. Note
    that GuardDuty monitors on a per-region basis, so it may be necessary to repeat
    these steps for each GuardDuty detector in each available region. We can do this
    by running the following AWS **command-line interface** (**CLI**) command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This should return the ID of the GuardDuty detector in the current region.
    In our example, that turns out to be `e2b19kks31n78f00931ma8b081642901`. If no
    detector IDs are returned, then that means GuardDuty is not enabled in the current
    region, which is good news if you are trying to bypass it! Then we will check
    this detector to see if there is already a trusted IP list associated with it,
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If there is already a trusted IP set in place, its ID will be returned, and
    if not, an empty list will be returned. The first scenario we will look at will
    assume that they are not using a trusted IP list already. This is the best-case
    scenario for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start off this attack, we will need to create a text file locally on our
    computer that contains the IP address that we want to whitelist. We''ll be naming
    this the `ip-whitelist.txt` file. Then, because GuardDuty requires the file containing
    the IP whitelist to be hosted in S3, we will upload this file to an S3 bucket
    within our own attack account and expose the file publicly. The reason for this
    is so that we are always in control of the whitelist that is being used and we
    could even modify it as needed during an engagement. For this example, we''ll
    say that we are using the `bucket-for-gd-whitelist` S3 bucket. First, we''ll upload
    our file to the bucket with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will want to make sure that our file is publicly readable, so that
    GuardDuty can read it as needed when it is set as the whitelist. We can do this
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Bear in mind that the settings on the bucket itself or your account may prevent
    public objects, so if you receive an access denied message when running this command
    or it does not seem to be working, ensure that the bucket or account public access
    settings are correctly configured to allow public objects.
  prefs: []
  type: TYPE_NORMAL
- en: Now our file should be publicly accessible at this URL (for this example only): [https://s3.amazonaws.com/bucket-for-gd-whitelist/ip-whitelist.txt](https://s3.amazonaws.com/bucket-for-gd-whitelist/ip-whitelist.txt).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will create the new trusted IP list for the GuardDuty detector we
    identified earlier with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If this was successful, you should receive a response that includes the ID of
    the newly-created trusted IP set. Now, that's it. Your IP is in an active trusted
    IP list for GuardDuty in the current region, meaning that GuardDuty will not generate
    findings for it (from the GuardDuty Lists page).
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may have guessed, there''s a Pacu module to automate this process. From
    Pacu, we can use the `guardduty__whitelist_ip` module to do this across every
    region. We can use the following command to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When that is complete, Pacu will have whitelisted your IP address in GuardDuty
    across every AWS region.
  prefs: []
  type: TYPE_NORMAL
- en: Now we are going to look at a scenario where the target AWS account already
    has a GuardDuty trusted IP list setup. We can't just add another list, because
    there is a maximum of one trusted IP list per GuardDuty detector. There are a
    couple different ways we could handle this. After we run the `ListIPSets` command
    and see that there is, in fact, a trusted IP list set up, we could just go ahead
    and delete the existing IP set, then implement one that whitelists our own IP.
    If you are using Pacu, and Pacu detects an existing trusted IP set, it will prompt
    you to delete it and create your own or skip that detector. The only problem with
    this is that deleting an existing trusted IP whitelist may have unintended consequences
    in the environment, which means we might draw more attention to ourselves than
    necessary when trying to stay stealthy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option we have is to update the current trusted IP list to include
    our own IP, as well as all the IPs that were there originally. To do this, let''s
    take the IP set ID that we collected from the `ListIPSets` API call and run the
    `GetIPSet` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run that command on the trusted IP list we just created earlier in this
    section, the output will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We'll consider this trusted IP list as one we haven't seen before (even though
    we set it up ourselves). What we will want to do is to visit the URL and download
    the current list, then we will modify the list to include our own attacker IP
    address. Once that is done, we will go through the same process as earlier, where
    we upload this file to our own personal S3 bucket and make the file publicly readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once that is done, we will then use the `UpdateIPSet` API instead of the `CreateIPSet`
    API like we did earlier. We can update the existing trusted IP list with our new
    one with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will have updated the trusted IP list with our own IP address without
    removing any IPs that were already whitelisted, thus not creating any ruckus in
    the environment that might get us noted.
  prefs: []
  type: TYPE_NORMAL
- en: As a responsible (and smart) attacker, there is one more step we must follow.
    That step is at the very end of the AWS engagement/penetration test/attack, where
    we restore the original whitelist, so that the configuration doesn't look strange
    when viewing it, and our IP is no longer stored in a list they have access to.
    To do this, we should save the URL that was originally associated with the trusted
    IP list until the end of the engagement, and then use the `UpdateIPSet` API again
    to restore it back to that URL. By doing this, our IP is whitelisted with GuardDuty
    for the duration of the engagement, then we leave the environment when are done
    without any major modifications to the resources in it.
  prefs: []
  type: TYPE_NORMAL
- en: One more important note is that if the account you are attacking has GuardDuty
    controlled by another external master account, you will not be able to modify
    the trusted IP list settings. Only the master account can do that when managing
    the GuardDuty cross-account. When a master account uploads a trusted IP list,
    this list is then applied to all GuardDuty members that belong to that master,
    which is amazing for an attacker who has compromised a GuardDuty master account.
  prefs: []
  type: TYPE_NORMAL
- en: Bypassing EC2 instance credential exfiltration alerts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section is going to focus on a single GuardDuty finding type: `UnauthorizedAccess:IAMUser/InstanceCredentialExfiltration`.
    The AWS documentation describes that this finding will be triggered when credentials
    that were created exclusively for an EC2 instance through an instance launch role
    are being used from an external IP address ([https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_unauthorized.html#unauthorized11](https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_unauthorized.html#unauthorized11)).
    Basically, when an EC2 instance is launched and an IAM instance profile is attached
    to it, GuardDuty expects the credentials for that role to only ever be used within
    that single instance, or at least that''s what it makes it sound like, but we''ll
    get into that soon.'
  prefs: []
  type: TYPE_NORMAL
- en: The reason this finding gets its own section in this chapter is because of how
    common the scenarios where you have the possibility to trigger it come up in AWS
    engagements. The most common way to gather these credentials that we have found
    during penetration tests is by gaining server-side request forgery on an EC2 instance
    that has an IAM instance profile attached. You can then make an HTTP request to
    the EC2 metadata URL ([http://169.254.169.254/](http://169.254.169.254/)) and
    request those credentials. In this scenario, you don't have command execution
    on the server, so you are required to exfiltrate the credentials that you acquire
    to use them. This is where the GuardDuty finding steps in and identifies that
    the EC2 instance credentials are coming from an external IP address.
  prefs: []
  type: TYPE_NORMAL
- en: Although this GuardDuty finding is one of the most common ones to encounter
    when attacking an environment, it is also one of the easiest to completely bypass.
    The important thing to note is that when the documentation says, "*are being used
    from* *an external IP address,"* it refers to an IP address that is external to
    all of EC2 and does not mean external to the EC2 instance that the IAM instance
    profile is attached to.
  prefs: []
  type: TYPE_NORMAL
- en: Given that information, the bypass is simple. All we need to do is launch an
    EC2 instance in our own attacker account (in the same region as the server we
    SSRF'd if we know it, so that the source IP is within the regions range), configure
    the credentials with the AWS CLI, Pacu, and so on, and get hacking. For Pacu,
    you will just need to run the `set_keys` command and input the access key ID,
    secret access key, and session token that you stole from the target EC2 instance
    and then you will be able to run any module or API command without worrying about
    the GuardDuty `UnauthorizedAccess:IAMUser/InstanceCredentialExfiltration` alert.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start this EC2 instance in our own account running Ubuntu Server 18.04 LTS,
    we can run the following command, after replacing `<your ec2 ssh key name>` with
    the name of an SSH key that you created in AWS EC2 (you will need to modify the
    image ID and region parameter values to run this command in a region other than
    `us-east-1`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `userdata.txt` file should contain the following contents, which will install
    `Python3`, `Pip3`, `Git`, the AWS CLI, and `Pacu`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the instance is launched, you can then SSH into it with the SSH key you
    provided on the command line. Then, we can run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sudo su`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cd /root/pacu`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`python3 pacu.py`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set_keys`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, you will be prompted to input your role's credentials into Pacu
    so that you can get started. If the `/root/pacu` folder does not exist when you
    try to change directories to it, it is possible the instance is still installing
    the various software defined in the user data script. Wait a minute or two and
    check again. If it still doesn't show up, review the contents of the file at `/var/log/cloud-init-output.log` and
    see if there were any errors that occurred during the installation of any of the
    preceding software, or if it is still running.
  prefs: []
  type: TYPE_NORMAL
- en: Now, as long as you stay within this instance you don't need to worry about
    the GuardDuty finding being alerted about, but if you move to outside of the EC2
    IP range, it will likely trigger on your first API call.
  prefs: []
  type: TYPE_NORMAL
- en: Another important point to make is that the `UnauthorizedAccess:IAMUser/InstanceCredentialExfiltration` GuardDuty
    alert only targets EC2 instances in your account. This means that if you happen
    to gain access to credentials through a server hosted by some other AWS service,
    this GuardDuty alert is not paying attention to what you do with those credentials.
    This means that if you happen to gain remote code execution on a Lambda function
    and you steal the credentials from the environment variables, you can exfiltrate
    those to any system and use them without worrying about getting detected by this
    particular GuardDuty finding type. The same goes for AWS Glue development endpoints;
    if you steal credentials from the metadata API of a Glue development endpoint,
    you can exfiltrate them anywhere without worry, as GuardDuty is not tracking them.
  prefs: []
  type: TYPE_NORMAL
- en: Glue is an interesting example because development endpoints basically seem
    to be EC2 instances launched in someone else's account (owned by AWS themselves),
    with some modifications, of course. That means that credential exfiltration from
    a Glue development endpoint might actually trigger a GuardDuty alert in the AWS-owned
    AWS account that it was actually launched in, but that doesn't matter to us attackers
    because our target will not have this information themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Bypassing operating system (PenTest) alerts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are three GuardDuty alerts under the `PenTest` category of findings types.
    These findings are `PenTest:IAMUser/KaliLinux`, `PenTest:IAMUser/ParrotLinux`,
    and `PenTest:IAMUser/PentooLinux`, which alert when AWS API calls are made from
    a Kali Linux server, Parrot Linux server, or Pentoo Linux server, respectively.
    These are rather simple to bypass, as long as you know what is causing them to
    get detected.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of the client you are using to interact with the API, whether that
    is one of the SDKs from the various languages that are supported (such as Java,
    Python, or Node.js), the AWS CLI (which uses Python behind the scenes), the AWS
    web console, or just raw HTTP requests, you will always have a user agent that
    describes your operating system and version, along with other software and their
    versions that are in use when making the request. This user agent string is then
    logged by CloudTrail, like we saw in [Chapter 15](88017977-3b7b-4e4f-b4fe-60fa603200f3.xhtml),
    *Pentesting CloudTrial*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example user agent that is sent when using the AWS CLI on Kali Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This user agent tells us a few things:'
  prefs: []
  type: TYPE_NORMAL
- en: The AWS CLI, version 1.16.89, was used to make the request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The AWS CLI is using Python version 3.6.8 behind the scenes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The operating system is Kali Linux with a kernel version of 4.19.0, running
    AMD 64.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python is using version 1.12.79 of the `botocore` library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s an example user agent that is sent when using the AWS CLI on Parrot
    Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This user agent tells us a few things:'
  prefs: []
  type: TYPE_NORMAL
- en: The AWS CLI, version 1.16.93, was used to make the request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The AWS CLI is using Python version 3.6.8 behind the scenes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The operating system is Parrot Linux with a kernel version of 4.19.0, running
    AMD 64.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python is using version 1.12.83 of the `botocore` library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example user agent that is sent when using the AWS CLI on Pentoo Linux can
    be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This user agent tells us a few things:'
  prefs: []
  type: TYPE_NORMAL
- en: The AWS CLI, version 1.16.93, was used to make the request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The AWS CLI is using Python version 2.7.14 behind the scenes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The operating system is Pentoo Linux with a kernel version of 4.17.11.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python is using version 1.12.83 of the `botocore` library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When using the AWS web console, most CloudTrail logs will use the following
    user agent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This user agent tells us that the user is logged into the AWS web console, rather
    than using another method of interacting with the API.
  prefs: []
  type: TYPE_NORMAL
- en: For the Kali, Parrot, and Pentoo Linux user agents, we can see that they all
    contain their respective operating system names (`kali`, `parrot`, `pentoo`).
    This is essentially all that GuardDuty is looking for to identify the use of these
    operating systems, when reporting on the `PenTest` finding types that it offers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get your own user agent, you can make any AWS request to the API that will
    get logged in CloudTrail, then you can view the details of that CloudTrail event
    to see what user agent was logged. If you are using the Python `boto3` library
    to interact with the AWS API, you can use the following line of code to print
    out what your user agent is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: To avoid these GuardDuty checks, even if we are using Kali Linux, Parrot Linux,
    or Pentoo Linux, we simply need to modify the user agent we are using before we
    make requests to the AWS API. As long as GuardDuty doesn't detect `kali`, `parrot`,
    or `pentoo` in our user agent, then we are alright.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block shows a small example of how we might detect any of
    these operating systems, how to change the user agent in that scenario, and then
    how to successfully make a request with a modified user agent. This code is following
    the same Python 3 with `boto3` pattern that we have followed throughout the book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Essentially, all this code is doing is checking whether `kali`, `parrot`, or
    `pentoo` are in the user agent string of our client, and if so, changing that
    to a known, safe user agent. This modification to our request will allow us to
    completely bypass the PenTest/user agent checks that GuardDuty makes.
  prefs: []
  type: TYPE_NORMAL
- en: Although it was this easy to bypass these GuardDuty checks with the `boto3`
    library directly, it is a bit trickier (though, not impossible) when working with
    the AWS CLI. You will also need to add this code to any other piece of software
    that you are using, in order to ensure that you are never detected during your
    attack; however, luckily, Pacu takes this into consideration.
  prefs: []
  type: TYPE_NORMAL
- en: When launching Pacu (`python3 pacu.py`), this check for Kali, Parrot, and Pentoo
    Linux is performed for you automatically. If Pacu detects that you are running
    any of those operating systems, then it will automatically select a known safe
    user agent from a list it stores locally, and it will use this new user agent
    for any and all AWS requests that Pacu makes. This check will apply to the entire
    Pacu session that is created, so you will only see the warning that the change
    was made when you create your Pacu session. If you move that session to another
    computer, it will keep the user agent it chose originally, so all requests show
    up as consistent in CloudTrail.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Pacu''s startup, when you create a new session on one of the three operating
    systems we have been looking at, you will see something like the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/42d02d1d-c7d8-48e1-aa21-2cd0dbf870a6.png)'
  prefs: []
  type: TYPE_IMG
- en: Built-in GuardDuty defense in Pacu
  prefs: []
  type: TYPE_NORMAL
- en: Now, anyone who inspects the CloudTrail logs will see that we are using Windows
    10, not Kali Linux. That means GuardDuty will see the same thing and not trigger
    any of those findings on us.
  prefs: []
  type: TYPE_NORMAL
- en: Although these findings are listed under the `PenTest` GuardDuty category, which
    doesn't necessarily sound malicious, these checks are some of the most important
    ones we can work to bypass. This is because the use of any of these three operating
    systems will look highly suspicious to a defender who knows that they are not
    normally (or ever) used in their environment, which means our attack will likely
    be investigated and stopped within a short time.
  prefs: []
  type: TYPE_NORMAL
- en: When modifying our user agent in situations like this, it might not always make
    sense to use a seemingly random user agent as our replacement. Let's say that
    we compromised an account that strictly uses the AWS Java SDK for their API calls,
    but we compromise a user and change our user agent to reflect that we are using
    the Python `boto3` library. This will look suspicious to any defender paying attention
    to this kind of thing. This type of detection is highly unreliable due to the
    user agent being in control of the user, so it probably will not be something
    that you encounter often, but it might be smart to pay attention anyway.
  prefs: []
  type: TYPE_NORMAL
- en: To beat any user agent detection, we could potentially review the CloudTrail
    logs of our target account to find the previous API calls that were made from
    the user that we compromised. Then, we could copy that user agent and use it as
    our own, killing two birds with one stone. We will hide the fact that we are on
    Kali, Parrot, or Pentoo Linux, and we will fit into the norm of the environment
    by using a user agent that has been seen before.
  prefs: []
  type: TYPE_NORMAL
- en: Other simple bypasses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similarly to what we have previously discussed, there are many different things
    that GuardDuty checks for, so each one might require its own individual bypass.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest rules we can follow to bypass the `low-hanging-fruit` checks include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Don't use the Tor network to communicate with AWS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't port scan from or to an EC2 instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't brute-force SSH/RDP servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't communicate with known bad networks, hosts, or IPs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are some others that we should keep in mind, though.
  prefs: []
  type: TYPE_NORMAL
- en: Cryptocurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we want to mine cryptocurrency (which you should never do during a legitimate
    PenTest), we will want to look at the `CryptoCurrency:EC2/BitcoinTool.B!DNS` and
    `CryptoCurrency:EC2/BitcoinTool.B` GuardDuty alerts. These alerts trigger on network
    activity that are associated with domains and IP addresses that are known to be
    associated with cryptocurrency-related activity ([https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_crypto.html](https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_crypto.html)).
    This means that we can bypass this by avoiding direct connections to known cryptocurrency-related
    domains and IP addresses, such as exchanges and mining pools.
  prefs: []
  type: TYPE_NORMAL
- en: Behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bypassing the GuardDuty Behavior checks can also be rather simple.
  prefs: []
  type: TYPE_NORMAL
- en: To bypass the `Behavior:EC2/NetworkPortUnusual` finding, which triggers when
    an EC2 instance is communicating with a remote host on an unusual port, we will
    just need to ensure that any malware command and control we are doing is using
    a common port, such as `80` (HTTP) or `443` (HTTPS), rather than some random high-numbered
    port.
  prefs: []
  type: TYPE_NORMAL
- en: The `Behavior:EC2/TrafficVolumeUnusual` GuardDuty finding triggers when there
    is an unusually large amount of network traffic being sent to a remote host. As
    a defender, this could be an indication of data exfiltration from within your
    internal network. As an attacker, we could bypass this finding when exfiltrating
    data by limiting our outbound bandwidth, so that there never is a high volume
    of traffic happening at once. Instead, there will be a small amount of traffic
    volume over an extended period of time.
  prefs: []
  type: TYPE_NORMAL
- en: ResourceConsumption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ResourceConsumption:IAMUser/ComputeResources` GuardDuty finding triggers
    when an API is detected that aims to launch computer resources into the account
    (EC2). We could bypass this finding type by avoiding the usage of the `RunInstances`
    EC2 API within a region monitored by GuardDuty. If every region is not being monitored,
    we could just launch our EC2 instances in an unmonitored region; however, if every
    region is being monitored, then we could bypass this by just completely avoiding
    the API call or by using another AWS service to launch the servers that we need.
  prefs: []
  type: TYPE_NORMAL
- en: We could do this by using one of the many services within AWS that also launch
    servers, some of which include **Lightsail** instances, Glue development endpoints,
    or **AppStream** instances. In these cases, we will still have servers launched
    within the target account, but they won't be detected by GuardDuty because we've
    avoided the `RunInstances` EC2 API.
  prefs: []
  type: TYPE_NORMAL
- en: Stealth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already covered the two CloudTrail-related GuardDuty finding types,
    but there is also a third one under the **s****tealth** category: `Stealth:IAMUser/PasswordPolicyChange`.
    This will trigger when an accounts password policy is weakened, such as if the
    minimum password length changes from 15 characters to 8 characters. To avoid this
    finding, we simply should not touch the password strength requirements within
    an account that we are attacking.'
  prefs: []
  type: TYPE_NORMAL
- en: Trojan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the findings within the Trojan category of GuardDuty can be avoided
    by never communicating with known bad IP addresses and domains, which is easy
    to do. However, one finding, `Trojan:EC2/DNSDataExfiltration`, is a bit different.
    This finding triggers when an EC2 instance is discovered to be exfiltrating data
    through DNS queries. To avoid this, we can simply decide against the method of
    DNS data exfiltration when within a compromised EC2 instance.
  prefs: []
  type: TYPE_NORMAL
- en: Also, as discussed previously, GuardDuty can only read DNS logs for DNS requests
    that use the AWS DNS servers. It might be possible to customize your malware to
    use alternate DNS resolvers (other than the EC2 default of AWS DNS) for your DNS
    exfiltration, which will completely bypass GuardDuty, because the traffic will
    never be seen by it.
  prefs: []
  type: TYPE_NORMAL
- en: Others
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are other GuardDuty finding categories that we did not discuss, and that
    is because they are generally more difficult to bypass and require a situation-specific
    attack, or they are wrapped into another topic we have discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GuardDuty, in its current state, is in its early stages and looks for a lot
    of low-hanging fruit to detect malicious activity in an environment. Many of these
    checks (and sometimes all of them) are simple to bypass and/or avoid during the
    attack process against an AWS environment. Although this chapter tried to cover
    all of what is known about GuardDuty right now, the service is being slowly updated
    and improved on as time goes by. This is especially because of the machine learning
    involved in its detection.
  prefs: []
  type: TYPE_NORMAL
- en: Because of where GuardDuty is at, it likely is not a great catch-all solution,
    so when you are attacking an AWS environment, it is important to keep in mind
    that it might not be the only thing that is watching you. Even if you are attacking
    an environment with GuardDuty alongside another monitoring tool, it will still
    be useful and practical to try and bypass GuardDuty as much as possible, so that
    you aren't caught because of some low-hanging fruit, or you are caught because
    of a much more advanced monitoring setup within the environment.
  prefs: []
  type: TYPE_NORMAL
