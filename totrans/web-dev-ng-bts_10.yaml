- en: Working with Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start this chapter with a simple guessing game. Can you think of any web
    application that does not have any sort of form, such as, signing up, login, create,
    contact us, edit forms, and so on; the list is endless. (wrong answer—even the
    Google homepage has a search form.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Technically, it''s possible. I am 100% sure there are some websites that may
    not use forms at all, but I am also equally confident they will be static and
    won''t interact or engage with users dynamically, which brings us to the main
    context and focus of this chapter: implementing and using forms in our Angular
    application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, let''s now take a look at what we''ll be covering in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Bootstrap forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bootstrap form classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bootstrap form classes—extended
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template-driven forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Form validations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Submitting and processing form data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bootstrap forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will learn to make use of the awesome Bootstrap library, which offers a rich
    set of classes and utilities for us to design and develop forms in our applications,
    making developers' and designers' life easy!
  prefs: []
  type: TYPE_NORMAL
- en: What are forms?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Forms are sets, collections of input fields gathered together to enable us to
    collect data from the user through the keyboard, mouse, or touch input.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn to stitch input elements together and build some sample forms,
    such as logging in, signing up, or for when the user forgets their password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we jump into creating the forms, here''s a quick list of available HTML
    input elements that we can use in our apps:'
  prefs: []
  type: TYPE_NORMAL
- en: Input (including text, radio, checkbox, or file)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Textarea
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fieldset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want a quick refresher tutorial on HTML tags and elements, you can visit [W3schools.com](https://www.w3schools.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Armed with the knowledge about forms and the available HTML elements, it's hands-on
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap form classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn about the available classes from the Bootstrap
    framework, which we can make use of while building our forms. Each form can consist
    of various input elements, such as textual form controls, file input controls,
    input checkboxes, and radio buttons. The `.form-group` class is an easy way to
    add structure to our forms. Using the `.form-group` class, we can easily group
    input elements, labels, and help text to ensure proper grouping of elements in
    the form. Inside the `.form-group` element, we will add input elements and assign
    them each the `.form-control` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample of a grouping of elements using the `.form-group` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are creating a form group consisting of label and
    input elements of type text.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the same lines, we can easily add the textual input elements, such as `email`,
    `password`, and `textarea`. The following is the code to add the input element
    of type `email`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can easily add an input element of type `password` as well. Again,
    notice that we are making use of `form-group` as a wrapper and adding `form-control`
    to the element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Nice. We learned to use `form-group` and `form-control` classes on input elements.
    Now, let''s add the same classes to the `textarea` element. The following is the
    sample code for adding the classes to a `textarea` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that all of the preceding elements have the same structure and
    grouping. For `select` and `multiple` `select` input elements, it's also exactly
    the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following sample code, we are creating a `select` drop-down element
    and using the `form-control` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We have added a `select` drop-down element and will allow the user to select
    only one option from the list. And just by adding an additional attribute, `multiple`,
    we can easily allow the user to select multiple options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: That was simple and straightforward. Let's keep rolling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s proceed to other important input elements: checkboxes and radio
    buttons. However, the classes are different for `checkbox` and `radio` elements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three new classes that we will learn to implement for `checkbox`
    and `radio` elements:'
  prefs: []
  type: TYPE_NORMAL
- en: To wrap the element, we will use the `form-check` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the input type `checkbox` and the `radio` element, we will use `form-check-input`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For `checkbox` and `radio` elements, we will need to display labels, for which
    we will use the `form-check-label` class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are using the `.form-check` class, `.form-check-input`,
    and `.form-check-label` to our wrapper `div` and `label` elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ditto, on similar lines, we will use the preceding classes to add to input
    `radio` elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are creating two radio buttons for the user to select
    their gender, and the user can make only one selection out of the two options.
  prefs: []
  type: TYPE_NORMAL
- en: In most modern web applications, we will need a user to be able to upload files
    or assets to our applications. Bootstrap provides us class named "form-control-file", which
    we can associate to the file upload element.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the `form-control-file` class to our input type `file` element.
    The sample code for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Great. We have learned to put together all the elements with which we can create
    our beautiful and powerful forms.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap form classes – extended
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned to create forms with input elements and add some of the available
    form classes in Bootstrap to group elements, as well as to improve our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will look at other additional classes and attributes provided
    by the Bootstrap framework, which can be used to improve **user experience** (**UX**),
    as well as extend the behavior of the elements:'
  prefs: []
  type: TYPE_NORMAL
- en: Sizing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Readonly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inline forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forms using Bootstrap grid classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disabled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Help text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plain text inside `form-group`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will go through each one of the aforementioned options and learn to implement
    them and see them in action.
  prefs: []
  type: TYPE_NORMAL
- en: Sizing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can set the size of the input elements in our form. We can control the height
    of the element using various classes for small, medium, and large resolutions.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned to use the `.form-control` class in the previous section and,
    by default, the medium size height with the `.form-control-md` class is applied.
    There are other classes available to set the height as large or small. We can
    use `.form-control-lg` and `.form-control-sm`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the sample code, where we are setting the height of the email
    address element as large using the `.form-control-lg` class, and the password
    field with the `.form-control-sm` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We have added the `form-control-lg` and `form-control-sm` classes to the form
    control's email address and password form elements, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the application, the output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3d8bbef5-a504-4b21-b76e-f3b1feb319b2.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, notice the difference in heights of the input elements.
    The email address text field has increased in height and the password field is
    small.
  prefs: []
  type: TYPE_NORMAL
- en: Readonly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We may come across a use case where we will need to disable a field and make
    it read-only. We can utilize the attribute `readonly`. By adding the Boolean `readonly` attribute
    to any form control element, we can disable that element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sample code showing the usage of the `readonly` attribute on the username
    field is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is displayed as follows. Notice that email
    address field is disabled, and so the user will not be able to add/edit the element:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/62eecb1f-cbae-4243-aaa2-f676a93b5724.png)'
  prefs: []
  type: TYPE_IMG
- en: Inline forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The design is also an equally important aspect of how we display the form. We
    may come across a use case where we have a requirement to place our form horizontally,
    instead of the regular vertical way.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap has the `.form-inline` class to support inline or horizontal forms.
    When the `.form-inline` class is used, the form elements automatically float horizontally.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is some sample code, where we create the login form with an email
    address and password. We make it inline using the `form-inline` class :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the important thing to note is the usage of the `.form-inline` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the preceding code is displayed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2938203b-a18e-44d5-bd43-2958357e0bec.png)'
  prefs: []
  type: TYPE_IMG
- en: By default, all forms designed using Bootstrap are vertical.
  prefs: []
  type: TYPE_NORMAL
- en: Forms using Bootstrap grid classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember the Bootstrap grid classes we learned about in [Chapter 3](6694dd13-5500-4563-9688-74a21a06a9a9.xhtml),
    *Bootstrap – Grid Layout and Components*? Yes, rows, columns, and designing the
    layout of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will learn to use the same row and column grid classes inside
    our forms, which is good news because using these classes, we can design a custom
    layout and update the look and feel of the form.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sample code for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, instead of using the `.form-group` class, we are making
    use of the `row` and `col` classes, which are mainly used for designing layout.
  prefs: []
  type: TYPE_NORMAL
- en: We make a single row with two columns, and in each column, we add input elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7c02ddc6-166a-4b89-ab2b-8db49242f727.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s your homework now. Try out these fun use cases using grid classes with
    forms:'
  prefs: []
  type: TYPE_NORMAL
- en: Add more input elements in the same row by adding more column div elements to
    the same row
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add multiple rows to the form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assign a fixed width for some columns (column 4 or column 3)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disabled
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While developing web applications with critical and complex compliance requirements,
    it's very common that we will have to disable certain input elements based on
    user selections.
  prefs: []
  type: TYPE_NORMAL
- en: A good use case is where some fields are not applicable to a specific country
    the user has selected, so we need to disable other dependent fields.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `disabled` attribute which takes a Boolean value, we can either disable
    a form or a particular element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the `disabled` attribute in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are using the `disabled` attribute. We can see in
    the following screenshot that the email address field is completely disabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2c9b895e-8d4e-40eb-a13f-996cf8394c89.png)'
  prefs: []
  type: TYPE_IMG
- en: We can make any element disabled just by adding the `disabled` attribute to
    the element. This is good, but what if we want to disable the entire form in one
    go? We can do that as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We are adding the `fieldset` tag inside the form to wrap all the elements of
    the form together and apply the `disabled` attribute to the `fieldset` element,
    which will disable the entire form in one go.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the preceding code is displayed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cb30d38d-f476-4547-a2fc-023cba555368.png)'
  prefs: []
  type: TYPE_IMG
- en: Help text inside forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any good web application will have beautiful, yet powerful forms, which talk
    to users and create a good UX experience.
  prefs: []
  type: TYPE_NORMAL
- en: Help text is one of the options we have to notify the user about any errors,
    warnings, or mandatory fields in the form, so that the user can take necessary
    actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are adding text inside the `<small>` tag, and assigning
    the `.form-text` class and `.text-danger`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/245b42fa-42d2-4938-bdad-f1b4eae474d4.png)'
  prefs: []
  type: TYPE_IMG
- en: Displaying input elements as plain text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We may come across a requirement where we need to display an input element as
    just text, and not as an input element.
  prefs: []
  type: TYPE_NORMAL
- en: We can do this simply by customizing our style sheet, or just by using the `.form-control-plaintext` class
    inside the element with the `.form-group` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have added the `.form-control-plaintext` class to
    the input element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1920ea3b-d4f6-4786-a2cc-93d0ee5417e5.png)'
  prefs: []
  type: TYPE_IMG
- en: In this section, we have learned about various classes and attributes that we
    can use to enhance and make our forms more interactive and powerful, and above
    all, add to better user design and experience.
  prefs: []
  type: TYPE_NORMAL
- en: Angular forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section comes the real action of forms in Angular applications. Forms
    are at the heart of any application and are the main building blocks to gather,
    view, capture, and process data provided by the users. We will continue to use
    the Bootstrap library to enhance the design of our forms in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Angular provides two different approaches to building forms inside our apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two approaches provided by Angular for building forms are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Template-driven forms: HTML and data binding defined in template files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive or model-driven forms, using model and validation in the `Component`
    class files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although the form model is a commonality between template-driven forms and reactive
    forms, they are created differently.
  prefs: []
  type: TYPE_NORMAL
- en: The main difference between reactive forms and template-driven forms, when it
    comes to the template, is in the data binding. In template-driven forms, we use
    two-way data binding to bind our data model directly to the form elements. On
    the other hand, with reactive forms, we bind our data model to the form itself
    (as opposed to its individual form elements).
  prefs: []
  type: TYPE_NORMAL
- en: We will explore each of these approaches in detail, learn about the pros and
    cons of the approaches, and finally, we will build some forms using both approaches.
    Let's roll.
  prefs: []
  type: TYPE_NORMAL
- en: Template-driven forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Template-driven forms, as the name suggests, involve all the heavy-duty work
    of forms being performed right inside the template of the component. The approach
    is good and is recommended when dealing with simple, straightforward forms, without
    much complex validation or rules.
  prefs: []
  type: TYPE_NORMAL
- en: All the logic is in the template files, which essentially means that we will
    make use of HTML elements and attributes. With template-driven forms, we use HTML
    to create the form and the input elements and create validation rules as HTML
    attributes. Two-way data binding is the key part, so we can tie the form elements
    to the properties in the `Component` class.
  prefs: []
  type: TYPE_NORMAL
- en: Angular automatically tracks the form and input element states by generating
    the form model automatically for us to use. We can directly take the form as an
    object and process data easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the template-driven approach, we first import the `FormsModule`,
    so we can have access to the following directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ngForm`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngModel`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngModelGroup`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to import the `FormsModule` into our `app.module.ts` file.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the pros and cons of using the template-driven form approach
    in our apps.
  prefs: []
  type: TYPE_NORMAL
- en: Template-driven forms – pros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Template-driven forms can be very useful and helpful if the forms in our application
    are simple and straight forward with less metadata and validations. In this section
    we will highlight the pros of using template-driven forms in our applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Template-driven forms are very easy to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suitable for simple and straightforward use cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy-to-use two-way data binding, so there is minimal code and complexity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular automatically tracks the form and input element state (you can disable
    the Submit button if the form's state is not complete)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not recommended if the form has complex form validations or require custom form
    validations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template-driven forms – cons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we have learned about the advantages of using template-driven
    forms in our application and we have made a strong argument about the pros of
    using the template-driven form approach. In this section, we will learn about
    some of the cons of using template-driven forms in our applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Not recommended or suitable where the requirements of the form are complex and
    comprise custom form validations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing cannot be fully covered to test all use cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template-driven forms – important modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Armed with knowledge about the pros and cons of using the template-driven approach,
    without wasting any time we will deep dive into learning how to implement the
    template-driven forms in our application. We will start by learning about the
    required modules and gradually progress to create forms in our application. As
    explained in the preceding sections, template-driven forms are mostly defined
    in the template file. Before we jump into creating examples of template-driven
    forms, we should understand some of the most important concepts related to forms,
    namely, `ngForm` and `ngModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ngForm`:This is the directive that helps to create the control groups inside
    the form directive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngModel`:When `ngModel` is used on elements inside `ngForm`, all the elements
    and data get registered inside `ngForm`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the Angular form is using `ngForm` and `ngModel`, it means that the form
    is template-driven.
  prefs: []
  type: TYPE_NORMAL
- en: Building our login form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have a good high-level understanding of what template-driven forms
    are. In this section, we will put our knowledge to work by building a form. Let's
    put together a form using the classes we have learned in the preceding section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The use case we will work on is the user login form for our application. First,
    we need to generate our login component. Run the following `ng` command to generate
    the login component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is displayed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We will need to add our route path in the `app-routing.module.ts` file in order
    to access the routes for `login` and `register`.
  prefs: []
  type: TYPE_NORMAL
- en: We are building our form using the template-driven approach, so we will need
    to do most of the work in our template file. Before we start modifying our template
    file, we will need to import a required module into our `app.module.ts` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `app.module.ts` file and add the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Once we have imported `FormsModule` into our `app.module.ts` file, don't forget
    to add it to our list of imports inside `ngModule`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The updated `app.module.ts` file is displayed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/98682a79-39dc-4a24-a378-83d38e562d8c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s open our login component template file and create our login form in
    the `login.component.html` file. The following is the code we will add to our
    template file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Let's analyze the preceding code in depth. We are creating a form using the
    HTML input elements and adding a username, password, and Submit button to the
    form. Important things to note are that for the form itself, we are telling the
    template that the form is `ngForm` and `ngForm` will group all the input elements
    of the form together into the `#loginForm` template variable. For the input elements,
    we have added the `ngModel` attribute and we specify the `name` attribute for
    the elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `ngForm`, we can now easily retrieve the value of the elements inside
    the form. Since we have defined the local `#loginForm` template variable we can
    now use its properties easily. `loginForm` has the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`loginForm.value`:Returns the object containing all the values of the input
    elements inside the form'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loginForm.valid`: Returns if the form is valid or not, based on the HTML attribute
    validators applied in the template'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loginForm.touched`: Returns `true` or `false` depending on whether the form
    was touched/edited by the user or not'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the preceding code, we are passing `loginForm.value` to the component. We
    can pass any of these value to the component for processing or validation. Notice
    that we are also calling a `login` method, which we need to implement in our `Component`
    class file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create a method in our `Component` class to capture the data coming
    in from our `loginForm`. We are collecting the value of the form and displaying
    it in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the app using the `ng serve` command, and we should see the output shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e298edd1-6fd2-426f-ba2e-e99c4e4c88d7.png)'
  prefs: []
  type: TYPE_IMG
- en: Remember that in typical server-side scripting, we used to write `action` and
    `method` attributes for forms. We do not need to define these anymore, since they
    are declared and used in the `Component` class.
  prefs: []
  type: TYPE_NORMAL
- en: This is good stuff and good progress. We will continue to use the preceding
    login form and add validations shortly. Let's keep digging for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Model-driven forms, or reactive forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactive forms are also called model-driven forms. In model-driven forms, the
    model is created in the `Component` class file and is responsible for doing the
    form validation, processing data, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: Angular internally builds a tree structure of the Angular form controls, which
    makes it much easier to push and manage data between the data models and the UI
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: We need to build the form model in our `Component` class by creating the instances
    of the building blocks (that is, `FormControl` and `FormGroup`). Additionally,
    we write the validation rules and the validation error messages in the class as
    well. We even manage the properties (that is, the data model) in the class as
    opposed to using data binding in the HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Template-driven forms put the responsibility for the forms on the template,
    whereas reactive forms shift the responsibility for validation to the `Component`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will use the both terms: model-driven forms and reactive
    forms, as both refer to the same thing.'
  prefs: []
  type: TYPE_NORMAL
- en: Model-driven forms – pros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reactive forms are very useful in creating, validating and applying custom
    form validations to our forms in our applications. We can easily trust the model
    driven approach to do all the heavy duty work that is usually associated with
    any complex forms. In this section, we will list and understand the pros of using
    model-driven forms in our applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Greater flexibility for more complicated validation scenarios and custom, complex
    form validations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data model is immutable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the data model is immutable, no data binding is done
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's easier to add input elements dynamically (such as subtasks on a task form)
    using form arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's easy to bind various events to input elements using `HostListener` and
    `HostBindings`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the code for the form controls and validations is inside the component,
    which makes templates much simpler and easier to maintain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's easier to unit test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model-driven forms – cons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All good things in life has some form of cons attached to them. Reactive forms
    are no different in nature. While the pros and advantages of using reactive forms
    can certainly outweight the cons but still it''s important to learn and understand
    the cons of using reactive forms in our applications. In this section, we will
    list the cons of using model-driven forms in our applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Immediate beginners may find the initial learning curve too high
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The developer is expected to have knowledge about the various modules required
    to work with model-driven forms, such as `ngvalidators`, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model-driven forms – important modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We create the model using the two powerful classes provided by Angular—`formGroup`
    and `formControl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FormControl`: Tracks the value and state of individual form input elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FormGroup`: Tracks the value and state of a group of form controls'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FormBuilder`: Helps us to develop forms with their initial value and their
    validations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just as we imported `FormsModule` in to our template-driven forms, we will need
    to import `ReactiveFormsModule` in to our `app.module.ts` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The updated `app.module.ts` file should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/34059900-9e37-43f3-8b5d-638d8585057b.png)'
  prefs: []
  type: TYPE_IMG
- en: Armed with all the knowledge about the model-driven form approach, it's time
    for a hands-on example.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive forms – registration form example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section while covering template-driven forms, we have created
    our login form for our application. It's time to do a hands-on exercise using
    the reactive forms. The fundamental idea behind implementing login and registration
    forms using different approaches is to show you the difference in implementation
    of each approach. There is no right or wrong approach, the decision is driven
    by the complexity and requirement of our forms in the applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will learn to implement our new user registration form using
    the model-driven approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will need to generate our `register` component. Run the following `ng`
    command to generate the `register` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c044b603-8c86-4bd8-80e7-3012fdba4c7b.png)'
  prefs: []
  type: TYPE_IMG
- en: Since we are talking about model-driven forms, all the hard work had to be done
    in the `Component` class. We will still need to have a template for our reactive
    forms, but we won't be adding any validations or data binding into the template.
  prefs: []
  type: TYPE_NORMAL
- en: We want our registration form to have four form elements—that is, fields for
    full names, email addresses, passwords, and terms and conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update our `Component` class in the `register.component.ts` file and
    create an instance of `formGroup`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You will notice a lot of new stuff in the preceding code. Let's take it slowly, step
    by step. We are importing the required modules, `FormGroup` and `FormControl`,
    from the `angular/core`. Inside the `Component` class, we are creating an instance
    of the `FormGroup` class, `registerForm`. You will notice that we are now creating
    multiple `FormControl` instances, each one for a form element that we want to
    add to our form.
  prefs: []
  type: TYPE_NORMAL
- en: Is that all we need to do? For now, yes. Remember, as explained before, that
    reactive forms also need to have a basic template, but all the logic and validations
    will be inside the component, rather than the template file.
  prefs: []
  type: TYPE_NORMAL
- en: 'So now, let''s update our template file. In the `register.component.html` file,
    add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are creating a dynamic reactive form. There are many
    important concepts that we need to understand in the preceding code. We are using
    the `FormGroup` attribute for model-driven forms. In the template-driven forms,
    we used `ngForm`. Notice carefully that for every form element, we mention the `FormControlName`
    attribute, and the value for this attribute has to be exactly the same as was
    mentioned in the `Component` class during the `FormControl` instance declaration.
    Take a pause and read the last few sentences again.
  prefs: []
  type: TYPE_NORMAL
- en: We don't have to mention `ngModel` for elements anymore, since data binding
    is tightly coupled inside the `Component` class itself. We have also attached
    a `ngSubmit` event, which will call the method register implemented inside the
    component to print the form value on the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Awesome. That''s it. Now serve your application using the `ng serve` command
    and we should see the output as displayed in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/36bf4dd1-b7ec-4f94-baef-76a3565cc72e.png)'
  prefs: []
  type: TYPE_IMG
- en: Congrats on getting your forms up and running using the approaches provided
    by Angular. We have learned to build forms using template-driven and model-driven
    approaches. In the next sections, we will learn to extend them by adding validation
    and custom rules.
  prefs: []
  type: TYPE_NORMAL
- en: Angular form validations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, we understand how important and critical forms are to all our applications.
    Since we will be working on data we receive from users, it's very important to
    make sure that the data we receive from our users is correct and valid.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when we expect the user to enter an email address, we should not
    allow spaces or a few special characters in the email address. One more example,
    if we request the user to enter the phone number, it should not have more than
    10 digits (excluding country code of course).
  prefs: []
  type: TYPE_NORMAL
- en: There can be many such custom valid checkpoints that we may want to have in
    our forms.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will continue to use both the login form and our registration
    form to learn how to add validations in both template-driven forms and model-driven
    forms.
  prefs: []
  type: TYPE_NORMAL
- en: Template-driven form validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bring up our login form that we developed using the template-driven approach.
    Remember, that in the template-driven forms, validation is done in the template
    itself using the HTML attributes.
  prefs: []
  type: TYPE_NORMAL
- en: We can use any of the HTML attributes, such as required, `maxlength`, `minlength`,
    `size`, `email`, `number`, `length`, and so on, to put validation in forms. We
    can also make use of HTML pattern attributes to put regular expression checks
    in our form elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are various classes that we can make use of readily to implement validation
    in our forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ng-touched`: Input controls have been visited'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-untouched`: Input controls have not been visited'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-dirty`: Input controls data was changed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-pristine`: Input controls data has not been changed/updated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-valid`: Input control data is a valid set and makes the form valid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-invalid`: Input control data is not valid and hence the form is not valid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In template-driven forms, Angular will automatically track the state of each
    input element and the state of the form as well. Hence, we can also use the preceding
    classes in our CSS/SCSS to style/design our error notifications, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Alright, now that we know about validations in template-driven forms, it's time
    to update our login form component and make it jazzy. We are updating the `login.component.html`
    file by adding validations to the form elements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a closer look at the preceding code. We have extended the login form
    we had created earlier. Notice that for the username form control, we have the
    HTML attribute `required`, which will be set on the form control. If the user
    does not enter any value for the field and steps out of the focus of the field,
    using the `ngIf` condition, we are checking if the field is touched by the user
    and is if the value is not valid, we are displaying the error message. For the
    `password` field, we are setting other HTML attributes, such as `required` and
    `minlength` validation checks. If the form control data is not valid, we should
    not enable the form, right? That's what we are doing by adding the `disabled`
    attribute to the Submit button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s run the app using the `ng serve` command and we should see the output,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fcbb84dd-9730-4111-9b1e-51c29bdaef9b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For your homework, please try out these use cases in template-driven forms:'
  prefs: []
  type: TYPE_NORMAL
- en: Add minimum and maximum length to the username form element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a new form element and add validation that it should be in an email format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive form, or model-driven form, validations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far all, the validations we have implemented are only in the template file
    using the basic HTML attributes. In this section, we will learn to implement the
    validations in the component using the model-driven forms.
  prefs: []
  type: TYPE_NORMAL
- en: In previous sections, we have learned to create a form using the `formControl`
    and `formGroup` classes in our `Component` class. We will continue to use the
    same registration form to extend and implement validations now.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are adding the validation code in our component by adding validations in
    the `register.component.ts` file. Take a look at the code we will add in the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, you will notice that we have imported the required modules, `FormGroup`,
    `FormControl`, and `Validators` into our `Component` class. We had already imported
    and used `FormGroup` and `FormControl`. The `Validators` module is the only additional
    module that we have imported now. We are passing the validators as options to
    `FormControl`. For `fullname` we are adding the validators as `required` and `maxLength`.
    Note that we can pass multiple validators for each `FormControl`. Similarly, for
    email address form control, we are passing a validator pattern, which has a regular
    expression check on it. We have made all the required changes and validations
    in our component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time to update our template `register.component.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The HTML template is the same as the one we had created earlier for our model-driven
    form. We have added some more functionality to the form. Notice that we have added
    the `disabled` attribute to the Submit button, which will disable the form if
    any form elements are empty or invalid.
  prefs: []
  type: TYPE_NORMAL
- en: See, I told you, our template file will just be a placeholder and almost all
    of the action happens in our `Component` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s serve the app using the `ng serve` command and we should see the
    output, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/419a17df-99f3-4481-b97f-2cd8ebb1483a.png)'
  prefs: []
  type: TYPE_IMG
- en: If you see the preceding screenshot, jump on your desk. As we have now learned
    and implemented forms using both template-driven and model-driven approaches.
  prefs: []
  type: TYPE_NORMAL
- en: If you paid attention to the examples covered during the entire chapter, you
    will also notice that we have created methods to process the form data.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we focus exclusively on the same and learn some best practices
    to process form data.
  prefs: []
  type: TYPE_NORMAL
- en: Submitting form data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have learned to design and develop our forms in our applications.
    In this section, we will take things to downstream systems, which is to capture
    the data and process it.
  prefs: []
  type: TYPE_NORMAL
- en: Angular generates a form model in both approaches, be it template-driven forms
    or reactive forms. The form model holds the data of the form elements and the
    state of the form elements.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous sections, where we have implemented our forms, we have created
    a method to call on `ngSubmit`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our template-driven login form, we added the following code to our `login.component.ts`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We are passing the entire form object to the login method. Now the `loginForm`
    object will have all the details of the form controls, as well as the states.
  prefs: []
  type: TYPE_NORMAL
- en: In our registration form, which is generated using a model-driven approach,
    we have used the instance of `formGroup` that we created in our `Component` class
    `register.component.ts` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code we have added for capturing and processing the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If you notice, for reactive forms, we do not have to pass any form data, since
    we had created the `registerForm` instance of `FormGroup`, so it's available in
    our class using the `this` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have captured the data provided to the user, based on the application
    requirements, we can now implement our custom logic inside the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the common activities we do once we capture data are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Securing data to make sure that we do not allow junk data into our system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing/enhancing the data, such as converting the password into an encrypted
    value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking for any automated bots processing our applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making HTTP calls to backend services using Angular services. We have an entire
    chapter dedicated to this particular topic: [Chapter 12](9610f27b-03db-4258-8a68-24eb3901117b.xhtml), *Integrating
    Backend Data Services. *
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That concludes this chapter on Angular forms. We have covered a lot of ground
    and I am sure at this point you will be excited to create your own forms, write
    custom validations, and process the captured data.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Forms are the very heart and soul of any good application. We started by learning
    the awesome classes and utilities provided by the Bootstrap library. We explored
    in detail the `form-group` and `form-control` classes. We learned and implemented
    various helper and additional attributes that we can use to make our form look
    and behave even better.
  prefs: []
  type: TYPE_NORMAL
- en: We deep-dived into Angular forms by learning the two approaches Angular provides,
    namely template-driven forms and model-driven forms.
  prefs: []
  type: TYPE_NORMAL
- en: We learned in detail about each of the approaches, their pros and cons, and
    above all created our login and registration forms using each of the approaches.
    We also explored the various type of validations that we have used with template-driven
    forms and reactive forms.
  prefs: []
  type: TYPE_NORMAL
- en: Last, but not least, we learned about processing the form data that we receive
    from the forms. It's time to get wings and create your awesome forms.
  prefs: []
  type: TYPE_NORMAL
- en: While developing complex applications with multiple developers working on the
    same application, things can get out of hand. Luckily, Angular supports dependency
    injections and services, which enables us to create reusable services and define
    interface classes. We can define new data types and make sure all team members
    are pushing code without breaking each other's functionality. And how exactly
    will we achieve that? That's covered in the next chapter. Keep reading!
  prefs: []
  type: TYPE_NORMAL
