- en: Working with Forms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start this chapter with a simple guessing game. Can you think of any web
    application that does not have any sort of form, such as, signing up, login, create,
    contact us, edit forms, and so on; the list is endless. (wrong answer—even the
    Google homepage has a search form.)
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'Technically, it''s possible. I am 100% sure there are some websites that may
    not use forms at all, but I am also equally confident they will be static and
    won''t interact or engage with users dynamically, which brings us to the main
    context and focus of this chapter: implementing and using forms in our Angular
    application.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, let''s now take a look at what we''ll be covering in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Bootstrap forms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bootstrap form classes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bootstrap form classes—extended
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular forms
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template-driven forms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive forms
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Form validations
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Submitting and processing form data
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bootstrap forms
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will learn to make use of the awesome Bootstrap library, which offers a rich
    set of classes and utilities for us to design and develop forms in our applications,
    making developers' and designers' life easy!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: What are forms?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Forms are sets, collections of input fields gathered together to enable us to
    collect data from the user through the keyboard, mouse, or touch input.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: We will learn to stitch input elements together and build some sample forms,
    such as logging in, signing up, or for when the user forgets their password.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we jump into creating the forms, here''s a quick list of available HTML
    input elements that we can use in our apps:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Input (including text, radio, checkbox, or file)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Textarea
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Button
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Form
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fieldset
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want a quick refresher tutorial on HTML tags and elements, you can visit [W3schools.com](https://www.w3schools.com/).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Armed with the knowledge about forms and the available HTML elements, it's hands-on
    time.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap form classes
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn about the available classes from the Bootstrap
    framework, which we can make use of while building our forms. Each form can consist
    of various input elements, such as textual form controls, file input controls,
    input checkboxes, and radio buttons. The `.form-group` class is an easy way to
    add structure to our forms. Using the `.form-group` class, we can easily group
    input elements, labels, and help text to ensure proper grouping of elements in
    the form. Inside the `.form-group` element, we will add input elements and assign
    them each the `.form-control` class.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample of a grouping of elements using the `.form-group` class is as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`.form-group`类对元素进行分组的示例如下：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, we are creating a form group consisting of label and
    input elements of type text.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们创建了一个包含标签和文本输入元素的表单组。
- en: 'On the same lines, we can easily add the textual input elements, such as `email`,
    `password`, and `textarea`. The following is the code to add the input element
    of type `email`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在同样的线上，我们可以轻松地添加文本输入元素，比如`email`，`password`和`textarea`。以下是添加类型为`email`的输入元素的代码：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Similarly, we can easily add an input element of type `password` as well. Again,
    notice that we are making use of `form-group` as a wrapper and adding `form-control`
    to the element:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也可以轻松地添加类型为`password`的输入元素。再次注意，我们正在使用`form-group`作为包装，并将`form-control`添加到元素中：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Nice. We learned to use `form-group` and `form-control` classes on input elements.
    Now, let''s add the same classes to the `textarea` element. The following is the
    sample code for adding the classes to a `textarea` element:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 不错。我们学会了在输入元素上使用`form-group`和`form-control`类。现在，让我们将相同的类添加到`textarea`元素上。以下是为`textarea`元素添加类的示例代码：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You will notice that all of the preceding elements have the same structure and
    grouping. For `select` and `multiple` `select` input elements, it's also exactly
    the same.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到所有上述元素都具有相同的结构和分组。对于`select`和`multiple` `select`输入元素，也完全相同。
- en: 'In the following sample code, we are creating a `select` drop-down element
    and using the `form-control` class:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例代码中，我们创建了一个`select`下拉元素，并使用了`form-control`类：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We have added a `select` drop-down element and will allow the user to select
    only one option from the list. And just by adding an additional attribute, `multiple`,
    we can easily allow the user to select multiple options:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经添加了一个`select`下拉元素，并且将允许用户从列表中选择一个选项。只需添加一个额外的属性`multiple`，我们就可以轻松地允许用户选择多个选项：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That was simple and straightforward. Let's keep rolling.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单明了。让我们继续前进。
- en: 'Now, let''s proceed to other important input elements: checkboxes and radio
    buttons. However, the classes are different for `checkbox` and `radio` elements.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续其他重要的输入元素：复选框和单选按钮。但是，`checkbox`和`radio`元素的类是不同的。
- en: 'There are three new classes that we will learn to implement for `checkbox`
    and `radio` elements:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个新的类，我们将学习如何为`checkbox`和`radio`元素实现：
- en: To wrap the element, we will use the `form-check` class
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了包装元素，我们将使用`form-check`类
- en: For the input type `checkbox` and the `radio` element, we will use `form-check-input`
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于输入类型为`checkbox`和`radio`的元素，我们将使用`form-check-input`
- en: 'For `checkbox` and `radio` elements, we will need to display labels, for which
    we will use the `form-check-label` class:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`checkbox`和`radio`元素，我们需要显示标签，为此我们将使用`form-check-label`类：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, we are using the `.form-check` class, `.form-check-input`,
    and `.form-check-label` to our wrapper `div` and `label` elements.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们使用`.form-check`类，`.form-check-input`和`.form-check-label`来包装我们的`div`和`label`元素。
- en: 'Ditto, on similar lines, we will use the preceding classes to add to input
    `radio` elements:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在类似的线上，我们将使用上述类来添加到输入`radio`元素中：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we are creating two radio buttons for the user to select
    their gender, and the user can make only one selection out of the two options.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们为用户创建了两个单选按钮，以选择他们的性别，并且用户只能在两个选项中选择一个。
- en: In most modern web applications, we will need a user to be able to upload files
    or assets to our applications. Bootstrap provides us class named "form-control-file", which
    we can associate to the file upload element.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数现代Web应用程序中，我们需要用户能够上传文件或资源到我们的应用程序。Bootstrap为我们提供了一个名为"form-control-file"的类，我们可以将其关联到文件上传元素。
- en: 'We will use the `form-control-file` class to our input type `file` element.
    The sample code for this is as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`form-control-file`类将其应用于我们的输入类型`file`元素。此示例代码如下：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Great. We have learned to put together all the elements with which we can create
    our beautiful and powerful forms.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。我们已经学会了如何组合所有元素，从而创建我们美丽而强大的表单。
- en: Bootstrap form classes – extended
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bootstrap表单类 - 扩展
- en: We have learned to create forms with input elements and add some of the available
    form classes in Bootstrap to group elements, as well as to improve our application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了创建带有输入元素的表单，并在Bootstrap中添加了一些可用的表单类来对元素进行分组，以及改善我们的应用程序。
- en: 'In this section, we will look at other additional classes and attributes provided
    by the Bootstrap framework, which can be used to improve **user experience** (**UX**),
    as well as extend the behavior of the elements:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看Bootstrap框架提供的其他附加类和属性，这些类和属性可用于改善用户体验（UX），以及扩展元素的行为：
- en: Sizing
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大小
- en: Readonly
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只读
- en: Inline forms
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内联表单
- en: Forms using Bootstrap grid classes
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Bootstrap网格类的表单
- en: Disabled
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁用
- en: Help text
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助文本
- en: Plain text inside `form-group`
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`form-group`内的纯文本'
- en: We will go through each one of the aforementioned options and learn to implement
    them and see them in action.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐个讨论上述选项，并学会实现它们并看到它们的效果。
- en: Sizing
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大小
- en: We can set the size of the input elements in our form. We can control the height
    of the element using various classes for small, medium, and large resolutions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以设置表单中输入元素的大小。我们可以使用各种类来控制元素的高度，适用于小、中和大分辨率。
- en: We have learned to use the `.form-control` class in the previous section and,
    by default, the medium size height with the `.form-control-md` class is applied.
    There are other classes available to set the height as large or small. We can
    use `.form-control-lg` and `.form-control-sm`, respectively.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上一节中学会了使用`.form-control`类，默认情况下，使用`.form-control-md`类应用了中等大小的高度。还有其他类可用于设置高度为大或小。我们可以分别使用`.form-control-lg`和`.form-control-sm`。
- en: 'The following is the sample code, where we are setting the height of the email
    address element as large using the `.form-control-lg` class, and the password
    field with the `.form-control-sm` class:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是示例代码，我们将使用`.form-control-lg`类将电子邮件地址元素的高度设置为大，并使用`.form-control-sm`类将密码字段设置为小：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We have added the `form-control-lg` and `form-control-sm` classes to the form
    control's email address and password form elements, respectively.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将`form-control-lg`和`form-control-sm`类添加到表单控件的电子邮件地址和密码表单元素中，分别。
- en: 'When we run the application, the output of the preceding code is as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行应用程序时，上述代码的输出如下：
- en: '![](assets/3d8bbef5-a504-4b21-b76e-f3b1feb319b2.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3d8bbef5-a504-4b21-b76e-f3b1feb319b2.png)'
- en: In the preceding screenshot, notice the difference in heights of the input elements.
    The email address text field has increased in height and the password field is
    small.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的屏幕截图中，请注意输入元素高度的差异。电子邮件地址文本字段的高度增加了，密码字段很小。
- en: Readonly
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只读
- en: We may come across a use case where we will need to disable a field and make
    it read-only. We can utilize the attribute `readonly`. By adding the Boolean `readonly` attribute
    to any form control element, we can disable that element.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会遇到一个使用情况，需要禁用字段并使其只读。我们可以利用属性`readonly`。通过向任何表单控件元素添加布尔`readonly`属性，我们可以禁用该元素。
- en: 'The sample code showing the usage of the `readonly` attribute on the username
    field is as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 显示在用户名字段上使用`readonly`属性的示例代码如下：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output of the preceding code is displayed as follows. Notice that email
    address field is disabled, and so the user will not be able to add/edit the element:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下所示。请注意，电子邮件地址字段已禁用，因此用户将无法添加/编辑该元素：
- en: '![](assets/62eecb1f-cbae-4243-aaa2-f676a93b5724.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: Inline forms
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The design is also an equally important aspect of how we display the form. We
    may come across a use case where we have a requirement to place our form horizontally,
    instead of the regular vertical way.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap has the `.form-inline` class to support inline or horizontal forms.
    When the `.form-inline` class is used, the form elements automatically float horizontally.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is some sample code, where we create the login form with an email
    address and password. We make it inline using the `form-inline` class :'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, the important thing to note is the usage of the `.form-inline` class.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the preceding code is displayed as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2938203b-a18e-44d5-bd43-2958357e0bec.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
- en: By default, all forms designed using Bootstrap are vertical.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Forms using Bootstrap grid classes
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember the Bootstrap grid classes we learned about in [Chapter 3](6694dd13-5500-4563-9688-74a21a06a9a9.xhtml),
    *Bootstrap – Grid Layout and Components*? Yes, rows, columns, and designing the
    layout of the screen.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will learn to use the same row and column grid classes inside
    our forms, which is good news because using these classes, we can design a custom
    layout and update the look and feel of the form.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'The sample code for this is as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code, instead of using the `.form-group` class, we are making
    use of the `row` and `col` classes, which are mainly used for designing layout.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: We make a single row with two columns, and in each column, we add input elements.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the preceding code is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7c02ddc6-166a-4b89-ab2b-8db49242f727.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
- en: 'Here''s your homework now. Try out these fun use cases using grid classes with
    forms:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Add more input elements in the same row by adding more column div elements to
    the same row
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add multiple rows to the form
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assign a fixed width for some columns (column 4 or column 3)
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disabled
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While developing web applications with critical and complex compliance requirements,
    it's very common that we will have to disable certain input elements based on
    user selections.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: A good use case is where some fields are not applicable to a specific country
    the user has selected, so we need to disable other dependent fields.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Using the `disabled` attribute which takes a Boolean value, we can either disable
    a form or a particular element.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the `disabled` attribute in action:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding code, we are using the `disabled` attribute. We can see in
    the following screenshot that the email address field is completely disabled:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们使用了`disabled`属性。我们可以在以下截图中看到，电子邮件地址字段完全被禁用：
- en: '![](assets/2c9b895e-8d4e-40eb-a13f-996cf8394c89.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2c9b895e-8d4e-40eb-a13f-996cf8394c89.png)'
- en: We can make any element disabled just by adding the `disabled` attribute to
    the element. This is good, but what if we want to disable the entire form in one
    go? We can do that as well.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过向元素添加`disabled`属性来使任何元素被禁用。这很好，但是如果我们想一次性禁用整个表单怎么办？我们也可以做到。
- en: 'Take a look at the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下代码：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We are adding the `fieldset` tag inside the form to wrap all the elements of
    the form together and apply the `disabled` attribute to the `fieldset` element,
    which will disable the entire form in one go.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在表单内部添加`fieldset`标签，将表单的所有元素包装在一起，并将`disabled`属性应用于`fieldset`元素，这将一次性禁用整个表单。
- en: 'The output of the preceding code is displayed as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下所示：
- en: '![](assets/cb30d38d-f476-4547-a2fc-023cba555368.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cb30d38d-f476-4547-a2fc-023cba555368.png)'
- en: Help text inside forms
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单内的帮助文本
- en: Any good web application will have beautiful, yet powerful forms, which talk
    to users and create a good UX experience.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 任何优秀的Web应用程序都将拥有美观而强大的表单，这些表单可以与用户交流，并创造良好的用户体验。
- en: Help text is one of the options we have to notify the user about any errors,
    warnings, or mandatory fields in the form, so that the user can take necessary
    actions.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助文本是我们通知用户有关表单中任何错误、警告或必填字段的选项之一，以便用户可以采取必要的行动。
- en: 'Take a look at the following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下代码：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code, we are adding text inside the `<small>` tag, and assigning
    the `.form-text` class and `.text-danger`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们在`<small>`标签内添加文本，并分配`.form-text`类和`.text-danger`。
- en: 'The output of the preceding code is as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](assets/245b42fa-42d2-4938-bdad-f1b4eae474d4.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/245b42fa-42d2-4938-bdad-f1b4eae474d4.png)'
- en: Displaying input elements as plain text
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将输入元素显示为纯文本
- en: We may come across a requirement where we need to display an input element as
    just text, and not as an input element.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会遇到这样的要求，我们需要将输入元素显示为纯文本，而不是输入元素。
- en: We can do this simply by customizing our style sheet, or just by using the `.form-control-plaintext` class
    inside the element with the `.form-group` class.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过自定义样式表来简单地实现这一点，或者只需在具有`.form-group`类的元素内使用`.form-control-plaintext`类。
- en: 'Take a look at the following code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下代码：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code, we have added the `.form-control-plaintext` class to
    the input element.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们已经将`.form-control-plaintext`类添加到输入元素中。
- en: 'The output of the preceding code is as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](assets/1920ea3b-d4f6-4786-a2cc-93d0ee5417e5.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1920ea3b-d4f6-4786-a2cc-93d0ee5417e5.png)'
- en: In this section, we have learned about various classes and attributes that we
    can use to enhance and make our forms more interactive and powerful, and above
    all, add to better user design and experience.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经了解了各种类和属性，我们可以使用它们来增强和使我们的表单更具交互性和强大性，最重要的是，为更好的用户设计和体验增添内容。
- en: Angular forms
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular表单
- en: In this section comes the real action of forms in Angular applications. Forms
    are at the heart of any application and are the main building blocks to gather,
    view, capture, and process data provided by the users. We will continue to use
    the Bootstrap library to enhance the design of our forms in this section.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，Angular应用程序中的表单真正发挥作用。表单是任何应用程序的核心，也是收集、查看、捕获和处理用户提供的数据的主要构建块。在本节中，我们将继续使用Bootstrap库来增强我们表单的设计。
- en: Angular provides two different approaches to building forms inside our apps.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了两种不同的方法来构建应用程序内的表单。
- en: 'The two approaches provided by Angular for building forms are as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供的构建表单的两种方法如下：
- en: 'Template-driven forms: HTML and data binding defined in template files'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板驱动表单：HTML和数据绑定在模板文件中定义
- en: Reactive or model-driven forms, using model and validation in the `Component`
    class files
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模型和验证在“Component”类文件中的响应式或模型驱动表单
- en: Although the form model is a commonality between template-driven forms and reactive
    forms, they are created differently.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管表单模型是模板驱动表单和响应式表单之间的共同点，但它们的创建方式不同。
- en: The main difference between reactive forms and template-driven forms, when it
    comes to the template, is in the data binding. In template-driven forms, we use
    two-way data binding to bind our data model directly to the form elements. On
    the other hand, with reactive forms, we bind our data model to the form itself
    (as opposed to its individual form elements).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到模板时，响应式表单和模板驱动表单的主要区别在于数据绑定。在模板驱动表单中，我们使用双向数据绑定将我们的数据模型直接绑定到表单元素。另一方面，使用响应式表单时，我们将我们的数据模型绑定到表单本身（而不是其各个表单元素）。
- en: We will explore each of these approaches in detail, learn about the pros and
    cons of the approaches, and finally, we will build some forms using both approaches.
    Let's roll.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细探讨这些方法，了解这些方法的利弊，最后，我们将使用这两种方法构建一些表单。让我们开始吧。
- en: Template-driven forms
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板驱动表单
- en: Template-driven forms, as the name suggests, involve all the heavy-duty work
    of forms being performed right inside the template of the component. The approach
    is good and is recommended when dealing with simple, straightforward forms, without
    much complex validation or rules.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 模板驱动表单，顾名思义，涉及表单的所有繁重工作都在组件模板中进行。这种方法很好，建议在处理简单、直接的表单时使用，而不涉及太多复杂的验证或规则。
- en: All the logic is in the template files, which essentially means that we will
    make use of HTML elements and attributes. With template-driven forms, we use HTML
    to create the form and the input elements and create validation rules as HTML
    attributes. Two-way data binding is the key part, so we can tie the form elements
    to the properties in the `Component` class.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 所有逻辑都在模板文件中，这基本上意味着我们将利用HTML元素和属性。在模板驱动的表单中，我们使用HTML来创建表单和输入元素，并将验证规则创建为HTML属性。双向数据绑定是关键部分，因此我们可以将表单元素与“Component”类中的属性绑定起来。
- en: Angular automatically tracks the form and input element states by generating
    the form model automatically for us to use. We can directly take the form as an
    object and process data easily.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Angular会自动生成表单模型，自动跟踪表单和输入元素的状态供我们使用。我们可以直接将表单作为对象并轻松处理数据。
- en: 'When using the template-driven approach, we first import the `FormsModule`,
    so we can have access to the following directives:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用模板驱动方法时，我们首先导入“FormsModule”，这样我们就可以访问以下指令：
- en: '`ngForm`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “ngForm”
- en: '`ngModel`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “ngModel”
- en: '`ngModelGroup`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “ngModelGroup”
- en: We need to import the `FormsModule` into our `app.module.ts` file.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将“FormsModule”导入到我们的“app.module.ts”文件中。
- en: Let's take a look at the pros and cons of using the template-driven form approach
    in our apps.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看在我们的应用程序中使用模板驱动表单方法的利弊。
- en: Template-driven forms – pros
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板驱动表单-优点
- en: 'Template-driven forms can be very useful and helpful if the forms in our application
    are simple and straight forward with less metadata and validations. In this section
    we will highlight the pros of using template-driven forms in our applications:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们应用程序中的表单简单直接，没有太多元数据和验证，模板驱动表单可以非常有用和有帮助。在本节中，我们将强调在我们的应用程序中使用模板驱动表单的优点：
- en: Template-driven forms are very easy to use
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板驱动表单非常容易使用
- en: Suitable for simple and straightforward use cases
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于简单和直接的用例
- en: Easy-to-use two-way data binding, so there is minimal code and complexity
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于使用的双向数据绑定，因此代码和复杂性很少
- en: Angular automatically tracks the form and input element state (you can disable
    the Submit button if the form's state is not complete)
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular自动跟踪表单和输入元素的状态（如果表单状态不完整，则可以禁用提交按钮）
- en: Not recommended if the form has complex form validations or require custom form
    validations
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果表单具有复杂的表单验证或需要自定义表单验证，则不建议使用
- en: Template-driven forms – cons
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于模板的表单 - 缺点
- en: 'In the previous section, we have learned about the advantages of using template-driven
    forms in our application and we have made a strong argument about the pros of
    using the template-driven form approach. In this section, we will learn about
    some of the cons of using template-driven forms in our applications:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们已经了解了在应用程序中使用基于模板的表单的优势，并且我们已经就使用基于模板的表单方法的优点进行了充分论证。在本节中，我们将了解在我们的应用程序中使用基于模板的表单的一些缺点：
- en: Not recommended or suitable where the requirements of the form are complex and
    comprise custom form validations
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不建议或适用于表单要求复杂且包括自定义表单验证的情况
- en: Unit testing cannot be fully covered to test all use cases
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法完全覆盖单元测试以测试所有用例
- en: Template-driven forms – important modules
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于模板的表单 - 重要模块
- en: 'Armed with knowledge about the pros and cons of using the template-driven approach,
    without wasting any time we will deep dive into learning how to implement the
    template-driven forms in our application. We will start by learning about the
    required modules and gradually progress to create forms in our application. As
    explained in the preceding sections, template-driven forms are mostly defined
    in the template file. Before we jump into creating examples of template-driven
    forms, we should understand some of the most important concepts related to forms,
    namely, `ngForm` and `ngModel`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握了使用基于模板的方法的优缺点的知识，我们将立即深入学习如何在我们的应用程序中实现基于模板的表单。我们将首先学习所需的模块，然后逐渐创建我们应用程序中的表单。如前所述，基于模板的表单大多在模板文件中定义。在我们开始创建基于模板的表单示例之前，我们应该了解与表单相关的一些最重要的概念，即`ngForm`和`ngModel`：
- en: '`ngForm`:This is the directive that helps to create the control groups inside
    the form directive'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngForm`：这是一个指令，用于在表单指令内部创建控件组'
- en: '`ngModel`:When `ngModel` is used on elements inside `ngForm`, all the elements
    and data get registered inside `ngForm`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngModel`：当在`ngForm`内的元素上使用`ngModel`时，所有元素和数据都会在`ngForm`内注册。 '
- en: If the Angular form is using `ngForm` and `ngModel`, it means that the form
    is template-driven.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Angular表单使用`ngForm`和`ngModel`，这意味着该表单是基于模板的。
- en: Building our login form
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的登录表单
- en: So far, we have a good high-level understanding of what template-driven forms
    are. In this section, we will put our knowledge to work by building a form. Let's
    put together a form using the classes we have learned in the preceding section.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们对基于模板的表单有了一个很好的高层次理解。在本节中，我们将把我们的知识付诸实践，通过构建一个表单来实现。让我们使用我们在前一节中学到的类来组合一个表单。
- en: 'The use case we will work on is the user login form for our application. First,
    we need to generate our login component. Run the following `ng` command to generate
    the login component:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将处理的用例是我们应用程序的用户登录表单。首先，我们需要生成我们的登录组件。运行以下`ng`命令以生成登录组件：
- en: '[PRE17]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output of the preceding command is displayed as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出如下所示：
- en: We will need to add our route path in the `app-routing.module.ts` file in order
    to access the routes for `login` and `register`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`app-routing.module.ts`文件中添加我们的路由路径，以便访问`login`和`register`的路由。
- en: We are building our form using the template-driven approach, so we will need
    to do most of the work in our template file. Before we start modifying our template
    file, we will need to import a required module into our `app.module.ts` file.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用模板驱动方法构建我们的表单，因此我们需要在我们的模板文件中做大部分工作。在开始修改我们的模板文件之前，我们需要将一个必需的模块导入到我们的`app.module.ts`文件中。
- en: 'Open the `app.module.ts` file and add the following line of code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`app.module.ts`文件并添加以下代码行：
- en: '[PRE18]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Once we have imported `FormsModule` into our `app.module.ts` file, don't forget
    to add it to our list of imports inside `ngModule`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将`FormsModule`导入到我们的`app.module.ts`文件中，不要忘记将其添加到`ngModule`内的导入列表中。
- en: 'The updated `app.module.ts` file is displayed as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的`app.module.ts`文件显示如下：
- en: '![](assets/98682a79-39dc-4a24-a378-83d38e562d8c.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/98682a79-39dc-4a24-a378-83d38e562d8c.png)'
- en: 'Now, let''s open our login component template file and create our login form in
    the `login.component.html` file. The following is the code we will add to our
    template file:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们打开我们的登录组件模板文件，并在`login.component.html`文件中创建我们的登录表单。以下是我们将添加到模板文件中的代码：
- en: '[PRE19]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Let's analyze the preceding code in depth. We are creating a form using the
    HTML input elements and adding a username, password, and Submit button to the
    form. Important things to note are that for the form itself, we are telling the
    template that the form is `ngForm` and `ngForm` will group all the input elements
    of the form together into the `#loginForm` template variable. For the input elements,
    we have added the `ngModel` attribute and we specify the `name` attribute for
    the elements.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入分析上述代码。我们正在使用HTML输入元素创建一个表单，并向表单添加用户名、密码和提交按钮。需要注意的重要事项是，对于表单本身，我们告诉模板表单是`ngForm`，`ngForm`将把表单的所有输入元素组合到`#loginForm`模板变量中。对于输入元素，我们添加了`ngModel`属性，并为元素指定了`name`属性。
- en: 'Using `ngForm`, we can now easily retrieve the value of the elements inside
    the form. Since we have defined the local `#loginForm` template variable we can
    now use its properties easily. `loginForm` has the following properties:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ngForm`，我们现在可以轻松地检索表单内元素的值。由于我们已经定义了本地`#loginForm`模板变量，我们现在可以轻松地使用它的属性。`loginForm`具有以下属性：
- en: '`loginForm.value`:Returns the object containing all the values of the input
    elements inside the form'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loginForm.value`：返回包含表单内所有输入元素值的对象'
- en: '`loginForm.valid`: Returns if the form is valid or not, based on the HTML attribute
    validators applied in the template'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loginForm.valid`：根据模板中应用的HTML属性验证器返回表单是否有效'
- en: '`loginForm.touched`: Returns `true` or `false` depending on whether the form
    was touched/edited by the user or not'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loginForm.touched`：根据用户是否触摸/编辑表单返回`true`或`false`'
- en: In the preceding code, we are passing `loginForm.value` to the component. We
    can pass any of these value to the component for processing or validation. Notice
    that we are also calling a `login` method, which we need to implement in our `Component`
    class file.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们将`loginForm.value`传递给组件。我们可以将任何这些值传递给组件进行处理或验证。请注意，我们还调用了一个`login`方法，我们需要在我们的`Component`类文件中实现它。
- en: 'Now, let''s create a method in our `Component` class to capture the data coming
    in from our `loginForm`. We are collecting the value of the form and displaying
    it in the console:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在我们的`Component`类中创建一个方法来捕获来自我们的`loginForm`的数据。我们正在收集表单的值并在控制台中显示它：
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Run the app using the `ng serve` command, and we should see the output shown
    in the following screenshot:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ng serve`命令运行应用程序，我们应该看到以下截图中显示的输出：
- en: '![](assets/e298edd1-6fd2-426f-ba2e-e99c4e4c88d7.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e298edd1-6fd2-426f-ba2e-e99c4e4c88d7.png)'
- en: Remember that in typical server-side scripting, we used to write `action` and
    `method` attributes for forms. We do not need to define these anymore, since they
    are declared and used in the `Component` class.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: This is good stuff and good progress. We will continue to use the preceding
    login form and add validations shortly. Let's keep digging for more information.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Model-driven forms, or reactive forms
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactive forms are also called model-driven forms. In model-driven forms, the
    model is created in the `Component` class file and is responsible for doing the
    form validation, processing data, and much more.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Angular internally builds a tree structure of the Angular form controls, which
    makes it much easier to push and manage data between the data models and the UI
    elements.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: We need to build the form model in our `Component` class by creating the instances
    of the building blocks (that is, `FormControl` and `FormGroup`). Additionally,
    we write the validation rules and the validation error messages in the class as
    well. We even manage the properties (that is, the data model) in the class as
    opposed to using data binding in the HTML.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Template-driven forms put the responsibility for the forms on the template,
    whereas reactive forms shift the responsibility for validation to the `Component`
    class.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will use the both terms: model-driven forms and reactive
    forms, as both refer to the same thing.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Model-driven forms – pros
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reactive forms are very useful in creating, validating and applying custom
    form validations to our forms in our applications. We can easily trust the model
    driven approach to do all the heavy duty work that is usually associated with
    any complex forms. In this section, we will list and understand the pros of using
    model-driven forms in our applications:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Greater flexibility for more complicated validation scenarios and custom, complex
    form validations
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data model is immutable
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the data model is immutable, no data binding is done
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's easier to add input elements dynamically (such as subtasks on a task form)
    using form arrays
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's easy to bind various events to input elements using `HostListener` and
    `HostBindings`
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the code for the form controls and validations is inside the component,
    which makes templates much simpler and easier to maintain
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's easier to unit test
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model-driven forms – cons
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All good things in life has some form of cons attached to them. Reactive forms
    are no different in nature. While the pros and advantages of using reactive forms
    can certainly outweight the cons but still it''s important to learn and understand
    the cons of using reactive forms in our applications. In this section, we will
    list the cons of using model-driven forms in our applications:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Immediate beginners may find the initial learning curve too high
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The developer is expected to have knowledge about the various modules required
    to work with model-driven forms, such as `ngvalidators`, and so on
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model-driven forms – important modules
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We create the model using the two powerful classes provided by Angular—`formGroup`
    and `formControl`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '`FormControl`: Tracks the value and state of individual form input elements'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FormGroup`: Tracks the value and state of a group of form controls'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FormBuilder`: Helps us to develop forms with their initial value and their
    validations'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just as we imported `FormsModule` in to our template-driven forms, we will need
    to import `ReactiveFormsModule` in to our `app.module.ts` file.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'The updated `app.module.ts` file should look like the following screenshot:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/34059900-9e37-43f3-8b5d-638d8585057b.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
- en: Armed with all the knowledge about the model-driven form approach, it's time
    for a hands-on example.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Reactive forms – registration form example
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section while covering template-driven forms, we have created
    our login form for our application. It's time to do a hands-on exercise using
    the reactive forms. The fundamental idea behind implementing login and registration
    forms using different approaches is to show you the difference in implementation
    of each approach. There is no right or wrong approach, the decision is driven
    by the complexity and requirement of our forms in the applications.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will learn to implement our new user registration form using
    the model-driven approach.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will need to generate our `register` component. Run the following `ng`
    command to generate the `register` component:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output of the preceding command is as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c044b603-8c86-4bd8-80e7-3012fdba4c7b.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
- en: Since we are talking about model-driven forms, all the hard work had to be done
    in the `Component` class. We will still need to have a template for our reactive
    forms, but we won't be adding any validations or data binding into the template.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: We want our registration form to have four form elements—that is, fields for
    full names, email addresses, passwords, and terms and conditions.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update our `Component` class in the `register.component.ts` file and
    create an instance of `formGroup`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You will notice a lot of new stuff in the preceding code. Let's take it slowly, step
    by step. We are importing the required modules, `FormGroup` and `FormControl`,
    from the `angular/core`. Inside the `Component` class, we are creating an instance
    of the `FormGroup` class, `registerForm`. You will notice that we are now creating
    multiple `FormControl` instances, each one for a form element that we want to
    add to our form.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Is that all we need to do? For now, yes. Remember, as explained before, that
    reactive forms also need to have a basic template, but all the logic and validations
    will be inside the component, rather than the template file.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'So now, let''s update our template file. In the `register.component.html` file,
    add the following code:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding code, we are creating a dynamic reactive form. There are many
    important concepts that we need to understand in the preceding code. We are using
    the `FormGroup` attribute for model-driven forms. In the template-driven forms,
    we used `ngForm`. Notice carefully that for every form element, we mention the `FormControlName`
    attribute, and the value for this attribute has to be exactly the same as was
    mentioned in the `Component` class during the `FormControl` instance declaration.
    Take a pause and read the last few sentences again.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: We don't have to mention `ngModel` for elements anymore, since data binding
    is tightly coupled inside the `Component` class itself. We have also attached
    a `ngSubmit` event, which will call the method register implemented inside the
    component to print the form value on the console.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'Awesome. That''s it. Now serve your application using the `ng serve` command
    and we should see the output as displayed in the following screenshot:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/36bf4dd1-b7ec-4f94-baef-76a3565cc72e.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
- en: Congrats on getting your forms up and running using the approaches provided
    by Angular. We have learned to build forms using template-driven and model-driven
    approaches. In the next sections, we will learn to extend them by adding validation
    and custom rules.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Angular form validations
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, we understand how important and critical forms are to all our applications.
    Since we will be working on data we receive from users, it's very important to
    make sure that the data we receive from our users is correct and valid.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: For example, when we expect the user to enter an email address, we should not
    allow spaces or a few special characters in the email address. One more example,
    if we request the user to enter the phone number, it should not have more than
    10 digits (excluding country code of course).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: There can be many such custom valid checkpoints that we may want to have in
    our forms.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will continue to use both the login form and our registration
    form to learn how to add validations in both template-driven forms and model-driven
    forms.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Template-driven form validation
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bring up our login form that we developed using the template-driven approach.
    Remember, that in the template-driven forms, validation is done in the template
    itself using the HTML attributes.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: We can use any of the HTML attributes, such as required, `maxlength`, `minlength`,
    `size`, `email`, `number`, `length`, and so on, to put validation in forms. We
    can also make use of HTML pattern attributes to put regular expression checks
    in our form elements.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'There are various classes that we can make use of readily to implement validation
    in our forms:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '`ng-touched`: Input controls have been visited'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-untouched`: Input controls have not been visited'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-dirty`: Input controls data was changed'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-pristine`: Input controls data has not been changed/updated'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-valid`: Input control data is a valid set and makes the form valid'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-invalid`: Input control data is not valid and hence the form is not valid'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In template-driven forms, Angular will automatically track the state of each
    input element and the state of the form as well. Hence, we can also use the preceding
    classes in our CSS/SCSS to style/design our error notifications, as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Alright, now that we know about validations in template-driven forms, it's time
    to update our login form component and make it jazzy. We are updating the `login.component.html`
    file by adding validations to the form elements.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Let's take a closer look at the preceding code. We have extended the login form
    we had created earlier. Notice that for the username form control, we have the
    HTML attribute `required`, which will be set on the form control. If the user
    does not enter any value for the field and steps out of the focus of the field,
    using the `ngIf` condition, we are checking if the field is touched by the user
    and is if the value is not valid, we are displaying the error message. For the
    `password` field, we are setting other HTML attributes, such as `required` and
    `minlength` validation checks. If the form control data is not valid, we should
    not enable the form, right? That's what we are doing by adding the `disabled`
    attribute to the Submit button.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s run the app using the `ng serve` command and we should see the output,
    as shown in the following screenshot:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fcbb84dd-9730-4111-9b1e-51c29bdaef9b.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
- en: 'For your homework, please try out these use cases in template-driven forms:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Add minimum and maximum length to the username form element
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a new form element and add validation that it should be in an email format
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive form, or model-driven form, validations
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far all, the validations we have implemented are only in the template file
    using the basic HTML attributes. In this section, we will learn to implement the
    validations in the component using the model-driven forms.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: In previous sections, we have learned to create a form using the `formControl`
    and `formGroup` classes in our `Component` class. We will continue to use the
    same registration form to extend and implement validations now.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'We are adding the validation code in our component by adding validations in
    the `register.component.ts` file. Take a look at the code we will add in the file:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding code, you will notice that we have imported the required modules, `FormGroup`,
    `FormControl`, and `Validators` into our `Component` class. We had already imported
    and used `FormGroup` and `FormControl`. The `Validators` module is the only additional
    module that we have imported now. We are passing the validators as options to
    `FormControl`. For `fullname` we are adding the validators as `required` and `maxLength`.
    Note that we can pass multiple validators for each `FormControl`. Similarly, for
    email address form control, we are passing a validator pattern, which has a regular
    expression check on it. We have made all the required changes and validations
    in our component.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time to update our template `register.component.html` file:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The HTML template is the same as the one we had created earlier for our model-driven
    form. We have added some more functionality to the form. Notice that we have added
    the `disabled` attribute to the Submit button, which will disable the form if
    any form elements are empty or invalid.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: See, I told you, our template file will just be a placeholder and almost all
    of the action happens in our `Component` class.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s serve the app using the `ng serve` command and we should see the
    output, as shown in the following screenshot:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/419a17df-99f3-4481-b97f-2cd8ebb1483a.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
- en: If you see the preceding screenshot, jump on your desk. As we have now learned
    and implemented forms using both template-driven and model-driven approaches.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: If you paid attention to the examples covered during the entire chapter, you
    will also notice that we have created methods to process the form data.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we focus exclusively on the same and learn some best practices
    to process form data.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Submitting form data
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have learned to design and develop our forms in our applications.
    In this section, we will take things to downstream systems, which is to capture
    the data and process it.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Angular generates a form model in both approaches, be it template-driven forms
    or reactive forms. The form model holds the data of the form elements and the
    state of the form elements.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: In the previous sections, where we have implemented our forms, we have created
    a method to call on `ngSubmit`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'For our template-driven login form, we added the following code to our `login.component.ts`
    file:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We are passing the entire form object to the login method. Now the `loginForm`
    object will have all the details of the form controls, as well as the states.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: In our registration form, which is generated using a model-driven approach,
    we have used the instance of `formGroup` that we created in our `Component` class
    `register.component.ts` file.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code we have added for capturing and processing the data:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you notice, for reactive forms, we do not have to pass any form data, since
    we had created the `registerForm` instance of `FormGroup`, so it's available in
    our class using the `this` operator.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Once we have captured the data provided to the user, based on the application
    requirements, we can now implement our custom logic inside the component.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the common activities we do once we capture data are the following:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Securing data to make sure that we do not allow junk data into our system.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing/enhancing the data, such as converting the password into an encrypted
    value.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking for any automated bots processing our applications.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making HTTP calls to backend services using Angular services. We have an entire
    chapter dedicated to this particular topic: [Chapter 12](9610f27b-03db-4258-8a68-24eb3901117b.xhtml), *Integrating
    Backend Data Services. *
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That concludes this chapter on Angular forms. We have covered a lot of ground
    and I am sure at this point you will be excited to create your own forms, write
    custom validations, and process the captured data.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Forms are the very heart and soul of any good application. We started by learning
    the awesome classes and utilities provided by the Bootstrap library. We explored
    in detail the `form-group` and `form-control` classes. We learned and implemented
    various helper and additional attributes that we can use to make our form look
    and behave even better.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: We deep-dived into Angular forms by learning the two approaches Angular provides,
    namely template-driven forms and model-driven forms.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: We learned in detail about each of the approaches, their pros and cons, and
    above all created our login and registration forms using each of the approaches.
    We also explored the various type of validations that we have used with template-driven
    forms and reactive forms.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Last, but not least, we learned about processing the form data that we receive
    from the forms. It's time to get wings and create your awesome forms.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: While developing complex applications with multiple developers working on the
    same application, things can get out of hand. Luckily, Angular supports dependency
    injections and services, which enables us to create reusable services and define
    interface classes. We can define new data types and make sure all team members
    are pushing code without breaking each other's functionality. And how exactly
    will we achieve that? That's covered in the next chapter. Keep reading!
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
