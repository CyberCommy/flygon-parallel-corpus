- en: Chapter 3. Scalability, Limitations, and Effects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 可扩展性、限制和效果
- en: With our media assets ready for HTML5 integration, let's continue this journey
    by looking over some of the new and exciting object manipulation features within
    CSS3 and JavaScript and how they relate to what you are familiar with as a Flash
    Developer. During the course of this chapter, we will review many of the specific
    features of HTML5 that have allowed it to gain extensive usage and popularity,
    becoming more like typical Flash development.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好用于HTML5集成的媒体资产后，让我们继续这个旅程，通过查看CSS3和JavaScript中一些新的和令人兴奋的对象操作功能，以及它们与Flash开发人员熟悉的内容的关系。在本章的过程中，我们将回顾HTML5的许多特定功能，这些功能使其获得了广泛的使用和受欢迎程度，变得更像典型的Flash开发。
- en: 'What we will cover in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Initial development limitations and ways to avoid them
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始开发限制及避免它们的方法
- en: Some of the new and exciting CSS3 additions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些新的和令人兴奋的CSS3新增功能
- en: Developing responsive layouts for mobile and desktop
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为移动和桌面开发响应式布局
- en: Targeting CSS styles for specific displays with CSS Media Queries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CSS媒体查询为特定显示目标CSS样式
- en: Controlling and streaming audio and video, and the limitations compared to Flash
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制和流式传输音频和视频，以及与Flash相比的限制
- en: Client-side file integration and manipulation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端文件集成和操作
- en: Sending heavy processes to the background with HTML5 Web Workers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTML5 Web Workers将繁重的进程发送到后台
- en: Introduction to server-side communication with WebSockets
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍使用WebSockets进行服务器端通信
- en: Understanding what the Canvas element is and why it's important
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Canvas元素是什么以及它的重要性
- en: Introduction to WebGL and its relation to Stage3D
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebGL简介及其与Stage3D的关系
- en: HTML5 limitations
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML5的限制
- en: If you haven't noticed by now, many of the HTML5 features you will use either
    have failsafes, multiple versions, or special syntax to enable your code to cover
    the entire spectrum of browsers and supported HTML5 feature sets within them.
    As time passes and standards become solidified, one can assume that many of these
    failsafes and other content display measures will mature into a single standard
    that all browsers will share. However, in reality this process may take a while
    and even at its best, developers may still have to utilize many of these failsafe
    features indefinitely. Therefore, a solid understanding of when, where, and why
    to use these failsafe measures will enable you develop your HTML5 web pages in
    a way that can be viewed as intended on all modern browsers.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在还没有注意到，您将使用的许多HTML5功能都具有故障保护、多个版本或特殊语法，以使您的代码覆盖整个浏览器范围和其中支持的HTML5功能集。随着时间的推移和标准的巩固，人们可以假设许多这些故障保护和其他内容显示措施将成熟为所有浏览器共享的单一标准。然而，实际上，这个过程可能需要一段时间，即使在最好的情况下，开发人员仍然可能不得不无限期地利用许多这些故障保护功能。因此，对何时、何地以及为什么使用这些故障保护措施有坚实的理解，将使您能够以一种方式开发您的HTML5网页，以便在所有现代浏览器上都能按照预期查看。
- en: To aid developers in overcoming these previously stated issues, many frameworks
    and external scripts have been created and open sourced, allowing for a more universal
    development environment saving developers countless hours when starting each new
    project. Modernizr ([http://modernizr.com](http://modernizr.com)) has quickly
    become a must-have addition for many HTML5 developers as it contains many of the
    conditions and verifications needed to allow developers to write less code and
    cover more browsers. Modernizr does all this by checking for a large majority
    (more then 40) of the new features available in HTML5 in the clients browser and
    reporting back if they are available or not in a matter of milliseconds. This
    will allow you as the developer to determine if you should display an alternate
    version of your content or a warning to the user.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助开发人员克服先前提到的这些问题，许多框架和外部脚本已经被创建并开源，使得在开始每个新项目时，可以拥有更普遍的开发环境，从而节省了开发人员无数的时间。Modernizr（[http://modernizr.com](http://modernizr.com)）已经迅速成为许多HTML5开发人员必不可少的补充，因为它包含了许多条件和验证，使得开发人员可以编写更少的代码并覆盖更多的浏览器。Modernizr通过检查客户端浏览器中HTML5中可用的大多数新功能（超过40个）并在几毫秒内报告它们是否可用来实现所有这些。这将使您作为开发人员能够确定是否应该显示内容的备用版本或向用户发出警告。
- en: Getting your web content to display properly in all browsers is and always has
    been the biggest challenge for any web developer and when it comes to creating
    cutting edge interesting content, the challenge usually becomes harder. This chapter
    will not only cover many of the new HTML5 content manipulation features, but demonstrate
    them in code examples as well. To allow you to better understand how these features
    look without the use of third-party integration, we will avoid using external
    libraries for the time being. It is worth noting how each of these features and
    others look in all browsers. Therefore make sure to test the examples as well
    as your own work in not just your favorite browser, but many of the other popular
    choices as well.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让您的网络内容在所有浏览器中正确显示一直是任何网络开发人员面临的最大挑战，当涉及创建尖端有趣的内容时，挑战通常变得更加艰巨。本章不仅将涵盖许多新的HTML5内容操作功能，还将在代码示例中进行演示。为了让您更好地了解这些功能在没有使用第三方集成的情况下是什么样子，我们将暂时避免使用外部库。值得注意的是，这些功能和其他功能在所有浏览器中的外观。因此，请确保在不仅是您喜欢的浏览器中，而且在许多其他流行的选择中测试示例以及您自己的工作。
- en: Object manipulation with CSS3
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CSS3进行对象操作
- en: Prior to the advent of CSS3, web developers used a laundry list of content manipulation,
    asset preparation, and asset presentation techniques in order to get their web
    page layout the way they wanted in every browser. Most of these techniques would
    be considered "hacks" as they would pretty much be a work around to enable the
    browser to do something it normally wouldn't. Features such as rounded corners,
    drop shadows, and transforms were all absent from a web developer's arsenal and
    the process of getting things the way you want could get mind numbing. Understandably,
    the excitement level surrounding CSS3 for all web developers is very high as it
    enables developers to perform more content manipulation techniques then ever before
    without the need for prior preparation or special browser hacks. Although the
    list of available properties in CSS3 is massive, let's cover some of the newest
    and most exciting of the lot.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在CSS3出现之前，Web开发人员使用了一长串的内容操作、资源准备和资源呈现技术，以便在每个浏览器中获得他们想要的网页布局。其中大部分技术都被认为是“黑客”技术，因为它们基本上都是一种解决方案，使浏览器能够执行通常不会执行的操作。诸如圆角、投影阴影和变换等功能都不在Web开发人员的工具库中，而且要达到想要的效果的过程可能会让人感到无聊。可以理解的是，CSS3对所有Web开发人员的兴奋程度都非常高，因为它使开发人员能够执行比以往更多的内容操作技术，而无需事先准备或特殊的浏览器黑客技术。尽管CSS3中可用属性的列表很庞大，但让我们来介绍一些最新和最令人兴奋的属性。
- en: box-shadow
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: box-shadow
- en: It's true that some designers and developers say drop shadows are a part of
    the past, but the usage of shadowing HTML elements is still a popular design choice
    for many. In the past, web developers needed to perform tricks such as stretching
    small gradient images or creating the shadow directly into their background image
    to achieve this effect in their HTML documents. CSS3 has solved this issue by
    creating the `box-shadow` property to allow for drop shadow like effects on your
    HTML elements.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一些设计师和开发人员说投影阴影已经过时，但在HTML元素中使用阴影仍然是许多人的流行设计选择。在过去，Web开发人员需要进行一些技巧，比如拉伸小的渐变图像或直接在背景图像中创建阴影，以在其HTML文档中实现这种效果。CSS3通过创建`box-shadow`属性来解决了这个问题，允许在HTML元素上实现类似投影阴影的效果。
- en: 'To remind us how this effect was accomplished in ActionScript 3, let''s review
    this code snippet:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提醒我们ActionScript 3中是如何实现这种效果的，让我们回顾一下这段代码：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As mentioned before, the new `box-shadow` property in CSS3 allows you to append
    these shadowing effects with relative ease and many of the same configuration
    properties:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，CSS3中的新`box-shadow`属性允许您相对轻松地附加这些阴影效果，并且具有许多相同的配置属性：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Despite the lack of property names on each of the values applied to this style,
    you can see that many of the value types coincide with what was appended to the
    drop shadow we created in ActionScript 3.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在此样式中应用的每个值都没有属性名称，但您可以看到许多值类型与我们在ActionScript 3中创建的投影阴影所附加的值相符。
- en: 'This `box-shadow` property is assigned to the`.box-shadow-example` class and
    therefore will be applied to any element that has that classname appended to it.
    By creating a `div` element with the `box-shadow-example` class, we can alter
    our content to look something like the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`box-shadow`属性被赋予了`.box-shadow-example`类，因此将被应用到任何具有该类名的元素上。通过创建一个带有`box-shadow-example`类的`div`元素，我们可以改变我们的内容，使其看起来像下面这样：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![box-shadow](img/3325OT_03_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![box-shadow](img/3325OT_03_01.jpg)'
- en: 'As straightforward as this CSS property is to add to your project, it declares
    a lot of values all in a single line. Let''s review each of these values in order
    that we can understand them better for future usage. To simplify the identification
    of each of the variables in the property, each of these have been updated to be
    different:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个CSS属性很容易添加到您的项目中，但它在一行中声明了很多值。让我们按顺序回顾每个值，以便我们更好地理解它们以备将来使用。为了简化属性中每个变量的识别，这些变量已经被更新为不同的值：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'These variables are explained as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量的解释如下：
- en: The initial value (`1px`) is the shadow's **horizontal offset** or if the shadow
    is going to the left or to the right. A positive value would place the shadow
    on the right of the element, a negative offset will put the shadow on the left.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始值（`1px`）是阴影的**水平偏移**，或者阴影是向左还是向右。正值将把阴影放在元素的右侧，负偏移将把阴影放在左侧。
- en: The second value (`2px`) is the **vertical offset**, and just like the horizontal
    offset value, a negative number would generate a shadow going up and a positive
    value would generate the shadow going down.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个值（`2px`）是**垂直偏移**，与水平偏移值一样，负数将生成向上的阴影，正数将生成向下的阴影。
- en: The third value (`3px`) is the **blur radius** that controls how much blur effect
    will be added to the shadow. Declaring a value, for example, `0` would create
    no blur and display a very sharp looking shadow. Negative values placed into the
    blur radius will be ignored and render no different then using 0.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个值（`3px`）是**模糊半径**，控制阴影的模糊程度。声明一个值，例如`0`，将不会产生模糊，显示出一个非常锐利的阴影。放入模糊半径的负值将被忽略，与使用0没有任何不同。
- en: The fourth value (`4px`) and last of the numerical properties is the **spread
    radius**. The spread radius controls how far the drop shadow blur will spread
    past the initial shadow size declaration. If a value `0` is used, the shadow will
    display with the default blur radius set and apply no changes. Positive numerical
    values will yield a shadow that blurs further and negative value will make the
    shadow blur smaller.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个值（`4px`）也是数字属性的最后一个，是**扩展半径**。扩展半径控制了投影阴影模糊超出初始阴影大小声明的距离。如果使用值`0`，阴影将显示默认的模糊半径并且不会应用任何更改。正数值将产生更模糊的阴影，负值将使阴影模糊变小。
- en: The final value is the hexadecimal color value, which states the color that
    the shadow will be in.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个值是十六进制颜色值，表示阴影的颜色。
- en: 'Alternatively, you could use `box-shadow` to apply the shadow effect to the
    interior of your element rather then the exterior. With ActionScript 3, this was
    accomplished by appending `dropShadow.inner = true;` to the list of parameters
    in your `DropShadowFiler` object. The CSS3 syntax to apply `box-shadow` properties
    in this manner is very similar as all that is required is the addition of the
    `inset` keyword. Consider the following code snippet, for example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用`box-shadow`将阴影效果应用于元素的内部而不是外部。使用ActionScript 3，可以通过在`DropShadowFiler`对象的参数列表中附加`dropShadow.inner
    = true;`来实现这一点。在CSS3中应用`box-shadow`属性的语法方式非常相似，只需要添加`inset`关键字。例如，考虑以下代码片段：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This would produce a shadow that would look like the following screenshot:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生一个看起来像下面截图的阴影：
- en: '![box-shadow](img/3325OT_03_02.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![box-shadow](img/3325OT_03_02.jpg)'
- en: Tip
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Included in the code examples for this chapter is a box-shadow tool that will
    allow you to better understand the affect each of the properties will have.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码示例中包含了一个box-shadow工具，它将帮助您更好地理解每个属性的影响。
- en: text-shadow
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: text-shadow
- en: 'Just like the `box-shadow` property, `text-shadow` lives up to its name by
    creating the same drop-shadowing effect, specifically for text:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`box-shadow`属性一样，`text-shadow`通过为文本创建相同的投影效果，实现了其名字的含义。
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Like `box-shadow`, the initial two values for `text-shadow` are the horizontal
    and vertical offsets for the shadow placement. The third value, which is optional
    is the blur size and the fourth value is the hexadecimal color:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 与`box-shadow`一样，`text-shadow`的初始两个值是阴影放置的水平和垂直偏移量。第三个值是可选的模糊大小，第四个值是十六进制颜色：
- en: '![text-shadow](img/3325OT_03_03.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![text-shadow](img/3325OT_03_03.jpg)'
- en: border-radius
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: border-radius
- en: Just like element or text shadowing, adding rounded corners to your elements
    prior to CSS3 was a chore. Developers would usually append separate images or
    use other object manipulation techniques to achieve this effect on the typically
    square or rectangle shaped elements. With the addition of the `border-radius`
    setting in CSS3, developers can easily and dynamically set element corner roundness
    with only a couple of line of CSS all without the usage of vector 9 slicing like
    in Flash.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 就像元素或文本阴影一样，在CSS3之前为元素添加圆角是一件苦差事。开发人员通常会附加单独的图像或使用其他对象操作技术来实现这种效果，通常是在典型的正方形或矩形形状元素上。通过在CSS3中添加`border-radius`设置，开发人员可以轻松动态地设置元素的角落圆度，只需几行CSS代码，而无需像Flash中那样使用矢量9切片。
- en: 'Since HTML elements have four corners, when appending the `border-radius` styling,
    we can either target each corner individually, or all the corners at once. In
    order to easily append a border radius setting to all the corners at once, we
    would create our CSS properties as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于HTML元素有四个角，当附加`border-radius`样式时，我们可以单独针对每个角落，或者一次性针对所有角落。为了轻松地一次性附加边框半径设置到所有角落，我们将创建我们的CSS属性如下：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding CSS not only appends a 10px border radius to all of the corners
    of the `#example` element, by using all the properties, which the modern browsers
    use, we can be assured that the effect will be visible to all users attempting
    to view this content:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的CSS不仅将10px的边框半径附加到`#example`元素的所有角落，还使用了现代浏览器使用的所有属性，我们可以确保这种效果对所有试图查看此内容的用户都是可见的：
- en: '![border-radius](img/3325OT_03_04.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![border-radius](img/3325OT_03_04.jpg)'
- en: 'As mentioned above, each of the individual corners of the element can be targeted
    to only append the radius to a specific part of the element:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，可以针对元素的每个单独角落，只附加半径到元素的特定部分：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding CSS now removes our `#example` element''s left border radius
    by setting it to `0px` and sets a specific radius to each of the other corners.
    It''s worth noting here that setting a border radius equal to `0` is no different
    than leaving that property completely out of the CSS styles:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的CSS现在通过将左边框半径设置为`0px`来移除我们的`#example`元素，并为其他每个角落设置了特定的半径。值得注意的是，在这里将边框半径设置为`0`与完全不在CSS样式中留下该属性没有任何区别：
- en: '![border-radius](img/3325OT_03_05.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![border-radius](img/3325OT_03_05.jpg)'
- en: Fonts
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字体
- en: Dealing with customized fonts in Flash has had its ups and downs over the years.
    Any Flash developer who has needed to incorporate and use customized fonts in
    their Flash applications probably knows the pain that comes with choosing a font
    embedding method as well as making sure it works properly for users who don't
    have the font installed on their computer viewing the Flash application.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，在Flash中处理自定义字体一直有着起伏。任何需要在其Flash应用程序中合并和使用自定义字体的Flash开发人员可能都知道选择字体嵌入方法以及确保它对没有在其计算机上安装字体的用户正常工作的痛苦。
- en: 'CSS3 font embedding has implemented a "no fuss" way to include custom fonts
    into your HTML5 documents with the addition of the `@font-face` declaration:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: CSS3字体嵌入已经实现了一种“无忧无虑”的方式，可以通过`@font-face`声明将自定义字体包含到HTML5文档中：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'CSS can now directly reference your TTF, OTF, or EOT font which can be placed
    on your web server for accessibility. With the font source declared in our CSS
    document and a unique `font-family` identification applied to it, we can start
    using it on specific elements by using the `font-family` property:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: CSS现在可以直接引用您的TTF、OTF或EOT字体，这些字体可以放在您的Web服务器上以实现可访问性。在我们的CSS文档中声明了字体源，并为其应用了唯一的`font-family`标识后，我们可以通过使用`font-family`属性在特定元素上开始使用它：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Since we declared a specific font family name in the `@font-face` property,
    we can use that custom name on pretty much any element henceforth. Custom fonts
    can be applied to almost anything that contains text in your HTML document. Form
    elements such as button labels and text inputs also can be styled to used your
    custom fonts. You can even remake assets such as website logos in pure HTML and
    CSS with the same custom fonts used in the original asset creation.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Acceptable font formats
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like many of the other embedding methods for assets online, fonts needs to be
    converted into multiple formats to enable all common modern browsers to display
    them properly. Almost all of the available browsers will be able to handle the
    common True Type Fonts (`.ttf` file types) or Open Type Fonts (`.otf` file types),
    so embedding one of those two formats will be all that is needed. Unfortunately
    Internet Explorer 9 does not have support built in for either of those two popular
    formats and requires fonts to be saved in the EOT file format.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: External font libraries
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many great services have appeared online in the last couple of years allowing
    web developers to painlessly prepare and embed fonts into their websites. Google's
    Web Fonts archive available at [http://www.google.com/webfonts](http://www.google.com/webfonts)
    hosts a large set of open source fonts which can be added to your project without
    the need to worry about licensing or payment issues. Simply add a couple of extras
    lines of code into your HTML document and you are ready to go.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Another great site that is worth checking out is Font Squirrel, which can be
    found at [http://www.fontsquirrel.com](http://www.fontsquirrel.com). Like Google
    Web Fonts, Font Squirrel hosts a large archive of web-ready fonts with the copy-and-paste-ready
    code snippets to add them to your document. Another great feature on this site
    is the `@font-face` generator which give you the ability to convert your preexisting
    fonts into all the web compatible formats.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Before getting carried away and converting all your favorite fonts into web
    ready formats and integrating them into your work, it is worth noting the End
    User License Agreement or EULA that came with the font to begin with. Converting
    many available fonts for use on the web will break license agreements and could
    cause legal issues for you down the road.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Opacity
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'More commonly known as "alpha" to the Flash developer, setting the opacity
    of an element not only allows you to change the look and feel of your designs,
    but allows you to add features like content that fades in and out. As simple as
    this concept seems, it is relatively new to the available list of CSS properties
    available to web developers. Setting the opacity of an element is extremely easy
    and looks something like the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see from the preceding example, like ActionScript 3, the opacity
    value is a numerical value between 0 and 1\. The preceding example would display
    a element at 50 percent transparency. The opacity property in CSS3 is now supported
    in all the major browsers, so there is no need to worry about using alternative
    property syntax when declaring it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: RGB and RGBA coloring
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When dealing with color values in CSS, many developers would typically use hexadecimal
    values, which would resemble something like `#000000` to declare the usage of
    the color black. Colors can also be implemented in their RGB representation in
    CSS by utilizing the `rgb()` or `rgba()` calls in place of the hexadecimal value.
    As you can see by the method name, the `rgba` color lookup in CSS also requires
    a forth parameter which declares the colors alpha transparency or opacity amount.
    Using RGBA in CSS3 rather than hexadecimal colors can be beneficial for a couple
    of reasons. Consider you have just created a `div` element which will be displayed
    on top of existing content within your web page layout.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'If you ever wanted to set a background color to the `div` as a specific color
    but wish for only that background to be semi transparent and not the interior
    content, the RGBA color declaration now allows you to do this easily as you can
    set the colors transparency:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see in the preceding example, you can freely use RGB and RGBA values
    rather than hexadecimal anywhere color values are required in CSS syntax.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Element transforms
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Personally, I find CSS3 transforms to be one of the most exciting and fun new
    features in CSS. Transforming assets in the Flash IDE as well as with ActionScript
    has always been easily accessible and easy to implement. Transforming HTML elements
    is a relatively new feature to CSS and is still gaining full support by all the
    modern browsers.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Transforming an element allows you to manipulate its shape and size by opening
    up a ton of possibilities for animations and visual effects to assets without
    the need to prepare the source before hand. When we refer to "transforming an
    element", we are actually describing a number of properties that can be applied
    to the transformation to give it different characteristics. If you have transformed
    objects in Flash or possibly in Photoshop before, these properties may be familiar
    to you.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Translate
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As a Flash developer used to primarily dealing with X and Y coordinates when
    positioning elements, the CSS3 Translate Transform property is a very handy way
    of placing elements and it works on the same principal. The `translate` property
    takes two parameters which are the X and the Y values to translate, or effectively
    move the element:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Unfortunately, to get your transforms to work in all browsers, you will need
    to target each of them when you append transform styles. Therefore, the standard
    transform style and property would now look something like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Rotate
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Rotation is pretty self-explanatory and extremely easy to implement. The `rotate`
    properties take a single parameter to specify the amount of rotation, in degrees,
    to apply to the specific element:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It is worth noting that regardless of the fact that the supplied value is always
    intended to be a value in degrees, the value must always have **deg** appended
    for the value to be properly recognized.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Scale
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just like `rotate` transforms, scaling is pretty straightforward. The `scale`
    property requires two parameters, which declare the scale amount for both X and
    Y:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Skew
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Skewing a element will result in the angling of the X and Y axes:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following illustration is a representation of skewing an image with the
    preceding properties:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '![Skew](img/3325OT_03_06.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
- en: Matrix
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `matrix` properties combine all of the preceding transforms into a single
    property and can easily eliminate many extra lines of CSS in your source:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding example utilizes the CSS transform matrix property to apply multiple
    transform styles in a single call. The `matrix` property requires six parameters
    to rotate, scale, move, and skew the element. Using the matrix property is only
    really useful when you actually need to implement all of the transform properties
    at once. If you only need to utilize one aspect of element transforms, you will
    be better off using just that CSS style property.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 3D transforms
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Up until now, all of the transform properties we have reviewed have been two
    dimensional transformations. CSS3 now also supports 3D as well as 2D transforms.
    One of the best parts of CSS3 3D transforms is the fact that many devices and
    browsers support hardware acceleration allowing this complex graphical processing
    to be done on your video cards GPU. At the time of writing this book, only Chrome,
    Safari, and Firefox have support for CSS 3D transforms.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Interested in what browsers will support all these great HTML5 features before
    you start developing? Check out [http://caniuse.com](http://caniuse.com) to see
    what popular browsers support in a simple, easy-to-use website.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with elements in a 3D world, we make use of the Z coordinate, which
    allows the use of some new transform properties.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理3D世界中的元素时，我们使用Z坐标，这允许使用一些新的变换属性。
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s create a 3D cube from HTML elements to put all of these properties into
    a working example. To start creating our 3D cube, we will begin by writing the
    HTML elements which will contain the cube as well as the elements which will be
    making up the cube itself:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从HTML元素创建一个3D立方体，将所有这些属性放入一个工作示例中。要开始创建我们的3D立方体，我们将首先编写包含立方体的HTML元素，以及构成立方体本身的元素：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This HTML creates a simple layout for our cube by not only creating each of
    the six sides, which makes up a cube with specific class names, but the container
    for the entire cube as well as the main container to display all of our page content.
    Of course, since there is no internal content in these containers and no styling
    yet, opening this HTML file in your browser would yield an empty page. So let''s
    start writing our CSS to make all of these elements visible and position each
    to form our three dimensional cube. We will start by setting up our main containers
    which will position our content and contain our cubes sides:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个HTML通过创建每个具有特定类名的六个面的元素，以及整个立方体的容器以及显示所有页面内容的主容器，为我们的立方体创建了一个简单的布局。当然，由于这些容器中没有内部内容，也没有样式，将此HTML文件在浏览器中打开将得到一个空白页面。因此，让我们开始编写CSS，使所有这些元素可见，并将每个元素定位以形成我们的三维立方体。我们将首先设置我们的主容器，这将定位我们的内容并包含我们的立方体面：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `container` class is our main element, which contains all of the other
    elements within this example. After appending a width and height, we set the top
    margin to `200px` to push the display down the page a bit for better viewing and
    the left and right margins to auto which will align this element in the center
    of the page:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: “container”类是我们的主要元素，它包含此示例中的所有其他元素。在附加了宽度和高度后，我们将顶部边距设置为“200px”，以将显示向下推移一点，以便更好地查看页面，并将左右边距设置为自动，这将使该元素在页面中居中对齐。
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: By defining properties to the `#cube div`, we set the styles to every `div`
    element within the `#cube` element. We are also kind of cheating the system of
    cube by setting the width and height to rectangular proportions as the intention
    is to add videos to each of the cube sides once we structure and position it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为“#cube div”定义属性，我们为“#cube”元素内的每个“div”元素设置样式。我们还通过将宽度和高度设置为矩形比例来欺骗立方体系统，因为我们的意图是在结构和位置确定后向立方体的每一面添加视频。
- en: 'With the basic cube-side styles appended, its time to start transforming each
    of the sides to form the three-dimensional cube. We will start with the front
    of the cube by translating it on the Z axis, bringing it closer to the perspective:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 附加了基本的立方体面样式后，现在是时候开始变换每个面，形成三维立方体了。我们将从立方体的前面开始，通过在Z轴上进行平移，使其靠近视角：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In order to append this style to our element in all modern browsers, we will
    need to specify the property in multiple syntaxes for each browser that doesn''t
    support the default `transform` property:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这种样式附加到所有现代浏览器中的元素上，我们需要为每个不支持默认“transform”属性的浏览器指定多种语法的属性：
- en: '![3D transforms](img/3325OT_03_07.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![3D transforms](img/3325OT_03_07.jpg)'
- en: 'The preceding screenshot shows what has happened to the `.front` div after
    appending a Z translation of 320px. The larger rectangle is the `.front` div,
    which is now 320px closer to our perspective. For simplicity''s sake, let''s do
    the same to the `.back` div and push it 320px away from the perspective:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在附加了Z轴平移320px后，前面的屏幕截图显示了“.front” div发生的变化。较大的矩形是“.front” div，现在离我们的视角近了320px。为了简单起见，让我们对“.back”
    div执行相同的操作，将其推离视角320px：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As you can see from the preceding code, to properly move the `.back` element
    into place without placing it upside down, we flip the element by 180 degrees
    on the X axis and then translate Z by 320px just like we did for `.front`. Note
    that we didn''t set a negative value on the translate Z because the element was
    flipped. With the `.back` CSS styles in place, our cube should look like the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，为了正确将“.back”元素移动到位而不使其倒置，我们在X轴上将元素翻转180度，然后像“.front”一样将Z平移320px。请注意，我们没有在translate
    Z上设置负值，因为元素被翻转了。有了“.back” CSS样式，我们的立方体应该看起来像下面这样：
- en: '![3D transforms](img/3325OT_03_08.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![3D transforms](img/3325OT_03_08.jpg)'
- en: Now the smallest rectangle visible is the element with the classname `.back`,
    the largest is our `.front` element, and the middle rectangle is the remaining
    elements to be transformed.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可见的最小矩形是具有类名“.back”的元素，最大的是我们的“.front”元素，中间的矩形是剩下的要变换的元素。
- en: 'To position the sides of our cubes we will need to rotate the side elements
    on the Y axis to get them to face the proper direction. Once they are rotated
    into place, we can translate the position on the Z axis to push it out from the
    center as we did with the front and back faces:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定位立方体的各个面，我们需要绕Y轴旋转侧面元素，使其面向正确的方向。一旦它们旋转到位，我们可以在Z轴上平移位置，使其从中心推出，就像我们对前面和后面的面做的那样：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![3D transforms](img/3325OT_03_09.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![3D transforms](img/3325OT_03_09.jpg)'
- en: 'With the right side in place, we can do the same to the left side but rotate
    it in the opposite direction to get it facing the other way:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧就位后，我们可以对左侧执行相同的操作，但是将其朝相反方向旋转，使其面向另一侧：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![3D transforms](img/3325OT_03_10.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![3D transforms](img/3325OT_03_10.jpg)'
- en: 'Now that we have all four sides of our cube aligned properly, we can finalize
    the cube positioning by aligning the top and bottom sides. To properly size the
    top and bottom we will set their own width and height to override the initial
    values set in the `#cube` div styles:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经正确对齐了立方体的四个面，我们可以通过对齐顶部和底部来最终确定立方体的位置。为了正确设置顶部和底部的大小，我们将设置它们自己的宽度和高度，以覆盖“#cube”
    div样式中设置的初始值：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: To properly position the top and bottom sides, we rotate the `.top` and `.bottom`
    elements +-90 degrees on the X axis to get them to face up and down, and only
    need to translate the top on the Z axis to raise it to the proper height to connect
    with all of the other sides.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确定位顶部和底部，我们需要在X轴上将`.top`和`.bottom`元素旋转+-90度，使它们朝上和朝下，只需要在Z轴上将顶部平移到正确的高度，以连接所有其他面。
- en: 'With all of those transforms appended to our layout, the resulting cube should
    look like the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的布局中添加了所有这些变换后，生成的立方体应该如下所示：
- en: '![3D transforms](img/3325OT_03_11.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![3D变换](img/3325OT_03_11.jpg)'
- en: 'Although it looks 3D, since there is nothing in the containers, the perspective
    isn''t really showing off our cube very well. So let''s add some content such
    as a video in each of the sides of the cube to get a better visualization of our
    work. Within each of the sides, let''s add the same HTML5 video element code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管看起来是3D的，但由于容器中没有内容，透视并没有很好地展示我们的立方体。因此，让我们在立方体的每一面添加一些内容，比如视频，以更好地可视化我们的工作。在每一面中，让我们添加相同的HTML5视频元素代码：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Since we have not added the element playback controls in order to display more
    visible area of the cube, our video element is set to *autoplay* the video as
    well as *loop* the playback on completion. Now we get a result that properly demonstrates
    what 3D transforms can do and is a little more visually appealing:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们尚未添加元素播放控件以显示立方体的更多可见区域，我们的视频元素被设置为在完成后*自动播放*视频以及*循环*播放。现在我们得到了一个正确展示3D变换能做什么并且更具视觉吸引力的结果：
- en: '![3D transforms](img/3325OT_03_12.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![3D变换](img/3325OT_03_12.jpg)'
- en: Since we set the opacity of each of the cube sides, we can now see all four
    videos playing on each side, pretty cool! Since we are already here, why not kick
    it up one more notch and add user interaction to this cube so we can spin it around
    and see the video on each side.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们设置了每个立方体面的不透明度，现在我们可以看到所有四个视频在每一面播放，非常酷！既然我们已经在这里，为什么不再加一点，为这个立方体添加用户交互，这样我们就可以把它转过来，看到每一面的视频。
- en: 'To perform this user interaction, we need to use JavaScript to translate the
    mouse coordinates on the page document to the X and Y 3D rotation of our cube.
    So let''s start by creating the JavaScript to listen for mouse events:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行这种用户交互，我们需要使用JavaScript将页面文档上的鼠标坐标转换为立方体的X和Y 3D旋转。因此，让我们开始创建JavaScript来监听鼠标事件：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see from the preceding code example, when the `mousemove` event fires
    and calls the `onMouseMove` function, we need to run some conditionals to properly
    parse the proper mouse position. Since, like so many other parts of web development,
    retrieving the mouse coordinates differs from browser to browser, we have added
    a simple condition to attempt to gather the mouse X and Y in a couple of different
    ways.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述代码示例中可以看出，当`mousemove`事件触发并调用`onMouseMove`函数时，我们需要运行一些条件语句来正确解析鼠标位置。由于像网页开发的许多其他部分一样，从浏览器中检索鼠标坐标各不相同，我们添加了一个简单的条件来尝试以几种不同的方式收集鼠标X和Y。
- en: 'With the mouse position ready to be translated into the transform rotation
    of our cube, there is one final bit of preparation we need to complete prior to
    setting the CSS style updates. Since different browsers support the application
    of CSS transforms in different syntaxes, we need to figure out, in JavaScript,
    which syntax to use during runtime to allow our script to run on all browsers.
    The following code example does just that. By setting a predefined array of the
    possible property values and attempting to check the type of each as an element
    style property, we can find which element is not undefined and know it can be
    used for CSS transform styles:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 鼠标位置准备好被转换为立方体的变换旋转后，我们需要在设置CSS样式更新之前完成最后一点准备工作。由于不同的浏览器支持不同语法的CSS变换应用，我们需要在JavaScript中找出在运行时使用哪种语法，以允许我们的脚本在所有浏览器上运行。以下代码示例就是这样做的。通过设置可能属性值的预定义数组，并尝试检查每个属性的类型作为元素样式属性，我们可以找到哪个元素不是未定义的，并知道它可以用于CSS变换样式：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now that we have the user''s mouse position and the proper syntax for CSS transform
    updates for our cube, we can put it all together and finally have 3D rotational
    control of our video cube:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经获得了用户的鼠标位置和立方体的CSS变换更新的正确语法，我们可以把它们放在一起，最终实现对我们的视频立方体的3D旋转控制：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Regardless of the fact we have attempted to allow for multi browser use of
    this example, it is worth opening it up in each to see how something like 3D transforms
    with heavy internal content run. During the time of writing this book, all WebKit
    browsers were the easy choice when viewing content like this, as browsers such
    as Firefox and Internet Explorer render this example at a much slower and lower
    quality output:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经尝试允许多浏览器使用此示例，但最好在每个浏览器中打开它，看看类似3D变换的重型内部内容是如何运行的。在撰写本书时，所有WebKit浏览器都是查看此类内容的简单选择，因为诸如Firefox和Internet
    Explorer之类的浏览器以更慢和更低质量的输出渲染此示例：
- en: '![3D transforms](img/3325OT_03_13.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![3D变换](img/3325OT_03_13.jpg)'
- en: Transitions
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过渡
- en: 'With CSS3, we can add an effect when changing from one style to another, without
    using Flash animations or JavaScripts:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CSS3，我们可以在从一种样式更改到另一种样式时添加效果，而无需使用Flash动画或JavaScript：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If the duration is not specified, the transition will have no effect, because
    the default value is 0:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未指定持续时间，过渡将不会产生任何效果，因为默认值为0：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Tip
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It should be worth noting that Internet Explorer currently does not have support
    for CSS3 transitions.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，目前Internet Explorer不支持CSS3过渡。
- en: Browser compatibility
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览器兼容性
- en: If you haven't noticed yet, the battle of browser compatibility is one of the
    biggest aspects of a web developer's job. Over time, many great services and applications
    have been created to help developers overcome these hurdles in a much simpler
    manner than trial-and-error techniques. Websites such as [http://css3test.com](http://css3test.com),
    [http://caniuse.com](http://caniuse.com), and [http://html5readiness.com](http://html5readiness.com)
    are all great resources to keep on top of HTML5 specification developer and browser
    support for all the features within.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有注意到，浏览器兼容性的斗争是网页开发人员工作的最重要方面之一。随着时间的推移，许多出色的服务和应用程序已经被创建，以帮助开发人员以比试错技术更简单的方式克服这些障碍。网站，如[http://css3test.com](http://css3test.com)、[http://caniuse.com](http://caniuse.com)和[http://html5readiness.com](http://html5readiness.com)都是保持HTML5规范开发人员和浏览器对所有功能的支持的重要资源。
- en: Frame rate
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 帧速率
- en: One would assume since you, the reader, are coming from a Flash development
    background, a moment should be taken to talk about frame rates or frames per second
    when developing HTML5 applications. Since every asset in Flash applications is
    based on the timeline model, calculating how many frames of that timeline are
    displayed every second is a pretty simple calculation. However, all the technologies
    that make up HTML5 development do not rely on the use of a timeline during runtime.
    Therefore calculating the frames per second or FPS value of a webpage is not always
    an accurate measure of performance of your HTML5 projects.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一个人会假设，因为你，读者，来自Flash开发背景，当开发HTML5应用程序时，应该花点时间谈论帧速率或每秒帧数。由于Flash应用程序中的每个资源都是基于时间轴模型的，计算每秒显示多少帧时间轴的帧是一个相当简单的计算。然而，组成HTML5开发的所有技术在运行时都不依赖于时间轴的使用。因此，计算网页的每秒帧数或FPS值并不总是衡量HTML5项目性能的准确指标。
- en: Tip
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Our CSS 3D Transform example found in the chapter code examples includes the
    use of a great piece of JavaScript called **Stats.js** to monitor the frames per
    second as well as the ms. Stats.js is a open source project that can be found
    at [https://github.com/mrdoob/stats.js](https://github.com/mrdoob/stats.js).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在章节代码示例中找到的CSS 3D变换示例包括使用一个名为**Stats.js**的优秀JavaScript代码，用于监视每秒帧数以及毫秒数。Stats.js是一个开源项目，可以在[https://github.com/mrdoob/stats.js](https://github.com/mrdoob/stats.js)找到。
- en: Developing for mobile
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为移动设备开发
- en: Another one of the driving forces behind the popularity of HTML5 is the overwhelming
    support for it on most of the modern mobile browsers ([http://mobilehtml5.org](http://mobilehtml5.org)).
    With the loss of Flash Player on all mobile platforms now, the use of HTML5 to
    deliver content is at an all time high and the usage is growing daily. Applications,
    frameworks, and templates such as jQuery Mobile ([http://jquerymobile.com](http://jquerymobile.com)),
    Phone Gap ([http://phonegap.com](http://phonegap.com)), Appcelerator ([http://www.appcelerator.com](http://www.appcelerator.com))
    and the Mobile Boilerplate ([http://html5boilerplate.com/html5boilerplate.com/dist/mobile](http://html5boilerplate.com/html5boilerplate.com/dist/mobile))
    all of which will be covered in detail in [Chapter 5](ch05.html "Chapter 5. Code
    Once, Release Everywhere"), *Code Once, Release Everywhere*, are all specifically
    built to aid web developers for building web content that is specifically targeted
    for mobile viewing. CSS can be set up in a responsive manner to allow the same
    page content to be displayed in an optimized format depending on the device and
    viewport configuration a user is viewing your content with.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5受到现代移动浏览器的全面支持，这是HTML5流行的另一个推动力。随着Flash Player在所有移动平台上的失去，使用HTML5传递内容的使用率达到了历史最高水平，并且每天都在增长。应用程序、框架和模板，如jQuery
    Mobile ([http://jquerymobile.com](http://jquerymobile.com))、Phone Gap ([http://phonegap.com](http://phonegap.com))、Appcelerator
    ([http://www.appcelerator.com](http://www.appcelerator.com))和Mobile Boilerplate
    ([http://html5boilerplate.com/html5boilerplate.com/dist/mobile](http://html5boilerplate.com/html5boilerplate.com/dist/mobile))，所有这些都将在[第5章](ch05.html
    "第5章。一次编码，到处发布")中详细介绍，*一次编码，到处发布*，都是专门为帮助网页开发人员构建专门针对移动视图的网页内容而构建的。CSS可以以响应的方式设置，以便根据用户查看内容的设备和视口配置以优化的格式显示相同的页面内容。
- en: Responsive layouts
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应式布局
- en: The term "responsive layout" seems to get used on a more frequent basis as HTML5
    development has grown in popularity. It has, to some, become a keyword to define
    one of the key features of good HTML5 development. Regardless of how the term
    is used, at the end of the day when we refer to "responsive layouts" in web development,
    we are referring to the usage of modern web development techniques to enable the
    same page content to transition its layout and content within it to adjust for
    the users device and viewing resolution. In other words, making sure your page
    content is set up in an optimized manner for all viewing resolutions and is able
    to transition between any one of the layouts without the need for content of page
    refreshing.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: “响应式布局”这个术语似乎在HTML5开发日益普及的情况下被更频繁地使用。对一些人来说，它已经成为定义良好的HTML5开发的关键特性之一的关键词。无论术语如何使用，归根结底，当我们在网页开发中提到“响应式布局”时，我们指的是使用现代网页开发技术来使同一页面内容能够在用户设备和视图分辨率上进行布局和内容的过渡调整。换句话说，确保您的页面内容以优化的方式设置，适用于所有视图分辨率，并且能够在任何一个布局之间进行过渡，而无需刷新页面内容。
- en: CSS Media Queries
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSS媒体查询
- en: 'One of the most important assets when creating responsive layouts is the use
    of CSS Media Queries. Media Queries allow you to target specific CSS styles depending
    on your user''s device, resolution, rotation, and more. Knowing as much as possible
    about the device and software loading your HTML documents will allow you to not
    only specify how specific devices and browsers are to display your content, but
    it can also allow your code to monitor real-time changes to the viewing methods
    as well. For instance, the following Media Query example changes the background
    color depending on device rotation:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The list of CSS Media Queries properties is short but it is important to understand
    what is available to you when creating your conditions. Therefore, let''s quickly
    review what properties you have at your disposal when writing your Media Queries:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '`width`: Describes the width of the targeted display area.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`height`: Describes the height of the targeted display area.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`device-width`: Describes the width of the rendering display of the output
    device.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`device-height`: Describes the height of the rendering display of the output
    device.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`orientation`: Is `portrait` when the value of the height media feature is
    greater than or equal to the value of the width media feature. Otherwise the orientation
    is `landscape`.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aspect-ratio`: Defined as the ratio of the value of the `width` media feature
    to the value of the `height` media feature.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`device-aspect-ratio`: Defined as the ratio of the value of the `device-width`
    media feature to the value of the `device-height` media feature.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`color`: Describes the number of bits per color component of the output device.
    If the device is not a color device, the value is zero.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`color-index`: Describes the number of entries in the color look up table of
    the output device. If the device does not use a color look up table, the value
    is zero.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`monochrome`: Describes the number of bits per pixel in a monochrome frame
    buffer. If the device is not a monochrome device, the output device value will
    be `0`.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resolution`: Describes the resolution of the output device, that is, the density
    of the pixels. When querying devices with non-square pixels, in `min-resolution`
    queries the least-dense dimension must be compared to the specified value and
    in `max-resolution` queries the most-dense dimensions must be compared instead.
    A `resolution` (without a "min-" or "max-" prefix) query never matches a device
    with non-square pixels.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**scan**: Describes the scanning process of "tv" output devices.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**grid**: Used to query whether the output device is grid or bitmap. If the
    output device is grid-based (for example, a "tty" terminal, or a phone display
    with only one fixed font), the value will be `1`. Otherwise, the value will be
    `0`.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Audio and video playback control
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in the last chapter, integrating audio and video assets with basic
    controls into and HTML5 document is extremely easy. But if you intend to use your
    multimedia in other forms than just a straightforward video playback element,
    you will need to understand the properties available for custom playback code
    integration.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Preloading
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, when an audio or video element is displayed in a HTML5 document,
    the source asset declared within it will be preloaded to allow for instantaneous
    playback when the user initiates the player. Assets will be preloaded only as
    far as the browsers deems necessary to enable fluid uninterrupted playback. To
    override this setting, we can use the `preload` parameter within the audio element
    to declare what we would like to be preloaded when a user views our page.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting the preload parameter to `auto` will preload the entire audio upon
    page load and could be a useful addition to any audio you are almost certain a
    user will watch at some point after the page loads. With the `preload` parameter
    set, our audio element would look something like the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Aside from preloading everything, we can also preload absolutely nothing by
    setting `preload="none"` rather than `auto`. Removing preloading from audio will
    allow users to surf your pages without the need for unnecessary audio downloads
    but will result in longer loading times for audio to player once the user initiates
    the audio playback. Finally we can also just load audio metadata when preloading
    by setting `preload="metatdata"`. This will allow the audio element to view what
    data it is about to load, which can be very useful when dynamically adding audio
    into an audio element and requiring the need to verify if it is fit for playback
    before attempting to do so.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Autoplay
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As described in [Chapter 2](ch02.html "Chapter 2. Preparing for the Battle"),
    *Preparing for the Battle*, with the `autoplay` setting appended to a video element,
    the video will begin to play the moment it is able to do so without the need to
    stop the video for further buffering. Unlike many of the other element parameters
    in HTML, the `autoplay` parameter does not require a value. So just appending
    `autoplay` to the element will be enough to do the job. It is worth keeping in
    mind that the `autoplay` setting will be ignored when loaded on almost all mobile
    browsers. Mobile browsers tend to ignore this setting in an attempt to conserve
    bandwidth on a wireless connection.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Looping
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the loop setting appended to the audio element, the video will restart
    every time is finishes. Like the `autoplay` parameter, the `loop` parameter does
    not require a value. If you only wanted a video to loop a specific number of times,
    you can either watch how many times its loops with the `loop` parameter set and
    then remove it when necessary, or control the entire playback from JavaScript
    to control the loop count without the loop parameter in the video element.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Sound effects
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Playing a sound effect at a specific moment can be accomplished in a number
    of ways with the use of the HTML5 audio element and JavaScript. In its simplest
    form, playing sound effects can be implemented as done the following code example:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When the audio element is created inside the HTML document body, we set the
    `preload="auto"` which will make sure the audio is preloaded completely as soon
    as possible. We do this so there is no latency when the sound is needed during
    the effect event. The audio element is also given an ID to enable referencing
    in JavaScript a couple line down. With the window load event listener, we wait
    for page load then apply an event listener to any `mousedown` event anywhere in
    the browser window. When this fires, we select our audio element by ID and call
    the built in `play()` method resulting in the audio playback on every click of
    the browser window.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Media playback manipulation
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Aside from the `play(`) method in the preceding example, JavaScript has the
    accessibility to control much more of the audio and video element directly. Audio
    volume can be set as a value between `0` and `1` as shown in the following example:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can also gather all the stats on the element by utilizing the following
    exposed objects within it:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Reading local files with the File API
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another feature that brings HTML5 content into a more application-like feature
    set is the addition of the File API. Users can now interact with their local content
    on a much more in depth level than ever before. Users can import files in the
    traditional HTML form manner or now just drag the file into specified drop zones
    in your HTML5 layouts. Once a file has been submitted to the web page by the user,
    your JavaScript File API usage can allow you to view, edit, and manipulate the
    file data prior to ever submitting it to the server. We will dig deeper into the
    the File API in many of the examples in chapters to come.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Web Workers
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the past when executing processor intensive JavaScript, browsers would often
    tend to freeze until the processing had been completed and the results were returned.
    With the advent of HTML5 Web Workers, you can now execute your processor intensive
    JavaScript code as a background process that will not affect the performance of
    the active document. Users will be able to continue using the site as intended
    as they wait for the Web Worker to complete its jobs in the background.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'To easily check if a user''s browser has support for HTML5 Web Workers, we
    can check if the type of the `Worker` object is undefined or not:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Depending on whether the browser supports the usage of Web Workers, we can
    easily create a new worker at anytime by instantiating a new `Worker` object and
    a reference to its JavaScript source:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the preceding example, we created a new worker and referenced it to the
    source within the `worker.js` file. The next step is to create the event listener
    for when the worker posts an update. To create this listener, we create a function
    on the `onmessage` property and retrieve the message from the `event.data` property:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The code within the worker can be anything, although it makes the most sense
    for it to be something that would normally freeze the browser for a short period
    of time. Regardless of what your worker is doing, to enable the callback to your
    code you will use the `postMessage` built-in function:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Tip
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since your Web Worker code is located in external files, it will not have access
    to the window, document or parent object in its JavaScript source.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: You will find more usage of Web Workers in this chapter's example files as well
    as some of the examples in chapters to come when we start building bigger JavaScript
    projects.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: WebSockets
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding server-side communication to your web pages to enable features such as
    multiuser interactivity or push notifications is becoming more and more popular
    with the advent of WebSockets. To put it in a nutshell, WebSockets fill the void
    when you need a server to communicate with the client without requiring the client's
    request.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: When building Flash applications, typically one would use technologies and frameworks
    such as **Real-Time Media Flow Protocol** (**RTMFP**) or SmartFoxServer ([http://www.smartfoxserver.com](http://www.smartfoxserver.com))
    to allow for server-based multiuser applications. This concept is now available
    with the use of WebSockets and is a true testament to how far the development
    of the HTML specification has come.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapters, we will continue to look into more thorough examples
    of WebSockets in action, as well as some other interesting methods for connecting
    users viewing your HTML5 content, such as Socket.io ([http://socket.io](http://socket.io)),
    Node.js ([http://nodejs.org](http://nodejs.org)), and Google V8 ([http://code.google.com/p/v8](http://code.google.com/p/v8)).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: The Canvas element
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can't finish this chapter without at least beginning to make mention of the
    HTML5 Canvas element. The Canvas allows developers to use the Canvas 2D Drawing
    API to draw graphics on the fly into an empty controllable area. From the perspective
    of a Flash developer, the easiest way to understand the Canvas elements feature
    set is that it uses similar features to the ActionScript 3 Drawing and Graphics
    API within an empty area in the HTML layout which is very similar to the Flash
    Stage.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand what all the fuss is about, let''s create a simple drawing
    application with the use of the Canvas. To begin, we need to append the Canvas
    element into the body of our HTML document. There is no content required to be
    inside the element''s tags, as it will only be viewable when the user is attempting
    to view this content from a browser without the support for the Canvas element:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Two important additions have been appended to the Canvas in this example and
    they are the element ID, which will be used in JavaScript in the following steps,
    as well as the width and height declaration. Without the width and height set
    in the element, most browsers will render the Canvas at 300px x 150px. To aid
    us in the development of this application, a 1px border has been added to the
    Canvas to allow us to see exactly where its boundaries are within the browser
    window. Finally as mentioned, the internal content within the Canvas element will
    only display if the element is not supported within the browser rendering it.
    If the application has been also written as a Flash application, the object embed
    for the Flash SWF could be used in place of the text warning we are using in this
    example.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to set up the reference to our Canvas and its 2D context within
    JavaScript, and since we set an ID on our element, we can easily reference it
    to a variable within our code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'With our Canvas referenced and mouse event listeners set up to watch for when
    the user has the mouse button down, let us finalize this example by writing our
    `onMouseMove` function to draw a line when the `isDrawing` variable is `true`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If you notice, the initial code in our `onMouseMove` function is taken from
    our 3D Transforms example and allows us to read the mouse X and Y position on
    the different modern browsers. The condition following the mouse position lookup
    should look semi-familiar if you had used the Drawing API in ActionScript 3\.
    Assuming the mouse is down, we draw a line to the current mouse position and set
    the default stroke on it. In this case, the default stroke is a 1px black solid
    line. When the mouse is not down, we simply move the context to the mouse position
    but do not draw any lines. This allows us to constantly reset and wait for a new
    line to be started. When tested in the browser, this example will look something
    like this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '![The Canvas element](img/3325OT_03_14.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
- en: This example really is only the start of what is available to developers but
    hopefully gives you an idea of how it works. We will continue to look into the
    Canvas element in the next chapter.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Stage3D versus WebGL
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we end this chapter, some mention should be made about the availability
    of WebGL and its similarities and differences to Stage3D in Adobe Flash. WebGL
    is a cross-platform web standard which allows developers to create and manipulate
    low-level 3D graphics, bringing plugin-free 3D development to the Web. WebGL can
    be implemented and viewed in all modern browsers, an exception is Internet Explorer.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Take note that it seems Microsoft is planning to release Internet Explorer 11
    with WebGL support.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: The key aspects of WebGL and Stage 3D are that they both support the use of
    hardware acceleration. This can drastically increase the performance of graphical
    processing loads when viewing content on devices and browsers with proper support.
    Although this book doesn't contain the room to dive too deep into the use of WebGL,
    we will look at a couple of frameworks and libraries which support and use it
    in [Chapter 6](ch06.html "Chapter 6. HTML5 Frameworks and Libraries"), *HTML5
    Frameworks and Libraries*.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information and to see if your current web browser supports the use
    of WebGL, head over to [http://get.webgl.org,](http://get.webgl.org, ) the WebGL
    public wiki ([http://www.khronos.org/webgl/wiki](http://www.khronos.org/webgl/wiki)),
    or view some intriguing examples at [http://www.khronos.org/webgl/wiki/Demo_Repository](http://www.khronos.org/webgl/wiki/Demo_Repository).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we have covered a ton of interesting features during the course of
    this chapter, there are still many very cool additions to HTML5 we will be looking
    at in the upcoming chapters. The key thought to take away from what we have covered
    so far is how the relationships between features in Flash and HTML5 are similar
    yet different at the same time. Understanding what technology will be able to
    allow you to develop your applications in the best possible manner is a key trait
    for any good developer. In the next chapter, we will dig deeper into the use of
    JavaScript and how it relates to ActionScript 3 when programming in an object-oriented
    manner.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在本章的课程中我们已经涵盖了许多有趣的功能，但在接下来的章节中，我们还将看到许多非常酷的HTML5新增功能。到目前为止，我们所涵盖的关键思想是Flash和HTML5之间的特性关系在某种程度上是相似的，但又有所不同。了解什么样的技术能够让你以最佳方式开发应用程序是任何优秀开发者的关键特质。在下一章中，我们将深入探讨JavaScript的使用以及在面向对象编程时与ActionScript
    3的关系。
