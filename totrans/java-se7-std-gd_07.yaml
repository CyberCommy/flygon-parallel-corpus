- en: Chapter 7. Inheritance and Polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will examine how Java supports several important object-oriented
    concepts including inheritance and polymorphism. When the term "inheritance" comes
    to mind, we think of that rich uncle who will leave us his vast fortune. Or we
    say that she has her mother's eyes. In programming terms we talk about classes
    and how they are related to each other. The terms, "parent class" and "child class",
    are used to describe an inheritance relationship between classes where the class
    has access to the capabilities of the parent class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are several terms used to designate a parent class and a child class.
    You may see the parent class referred to as the super class or base class. The
    child class may be called the subclass or the derived class. In this chapter we
    will use the terms **base class** and **derived class** .
  prefs: []
  type: TYPE_NORMAL
- en: The base class typically has methods that implement common functionality needed
    by that class and the classes that are derived from that class. For example, we
    may have a *person* class that represents an individual. It may have methods that
    allow us to maintain the name or age of a person. We may create other classes
    that represent different types of people—butcher, baker, or candle-stick maker.
    These different types of people have different capabilities above and beyond those
    capabilities we define for the *person* class.
  prefs: []
  type: TYPE_NORMAL
- en: When we implement a baker for example, that class might have a method called
    *cook* that is used to cook something. However, the baker still has a name and
    an age. Instead of re-implementing the code to support the modification of the
    name or age we would prefer to re-use the code we developed for the person class.
    The process of doing this is called inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance allows us to re-use the capabilities of the base class. This, in
    turn, promotes the re-use of software and can make the developer more productive.
  prefs: []
  type: TYPE_NORMAL
- en: We will also explain how polymorphism is supported in Java. This concept is
    important and assists in making an application more maintainable. Polymorphism
    is the result of overriding methods of a base class. Overriding is similar to
    overloading but it uses the same signature as a base class method.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism is frequently used in conjunction with abstract classes. An abstract
    class is one which cannot be instantiated. That is, it is not possible to create
    an instance of that class. While we cannot create an instance of an abstract class,
    we can create an instance of a class derived from the abstract class. This capability
    can enhance the structure of an application.
  prefs: []
  type: TYPE_NORMAL
- en: With inheritance comes the need to invoke constructors of a base class. We will
    examine the approach used by Java to control the initialization sequence. Also,
    the idea of determining the type of a class and casting between classes of an
    inheritance hierarchy becomes important in some situations.
  prefs: []
  type: TYPE_NORMAL
- en: The last topic addressed in this chapter is concerned with the organization
    of memory as it relates to inheritance. Understanding how memory is organized
    and handled will deepen your understanding of the language and assist in debugging
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inheritance is concerned with the relationship between two classes—the base
    class and the derived class. In this section we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a subclass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `protected` keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overriding methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `@Override` annotation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `final` keyword with classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating abstract methods and classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of constructors and inheritance is covered in the *The super keyword
    and constructors* section.
  prefs: []
  type: TYPE_NORMAL
- en: When inheritance occurs, the derived class inherits all of the methods and attributes
    of the base class. However, it can only access the public and protected members
    of the class. It cannot access the private members of the class.
  prefs: []
  type: TYPE_NORMAL
- en: When a method is added to a derived class that has the same signature and accessibility
    of a base class method, the method is said to override the base class method.
    This allows the derived class to redefine the meaning of that method. The examples
    in this chapter will use a `Employee` base class and a `SalaryEmployee` class
    that is derived from the base class.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a subclass
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A class is implemented through the use of the `extends` keyword, followed by
    the base classname. In the following example, the `Employee` base class is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SalaryEmployee` class can be derived from the base class `Employee`, as
    shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Inheritance is used extensively throughout Java libraries. For example, applets
    are created by extending the `Applet` class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A significant part of becoming a skilled Java programmer is learning to find,
    understand, and use those classes found in libraries relevant to your application's
    domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the `HelloWorldApplet` class extends and inherits
    all of the methods and properties of this class. In this case, the `paint` method
    is overridden by `HelloWorldApplet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It is possible, and entirely desirable, for a base class to have one or more
    derived classes. In the case of the `Employee` base class, we might create not
    only a `SalaryEmployee` class but also a `HourlyEmployee` class. They will share
    the common capabilities of the base class and yet contain their own unique capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine the `Employee` base class and the `SalaryEmployee` class more
    carefully. First, let''s start with a more detailed implementation of the `Employee`
    class, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this implementation we have only included a private `age` instance variable
    and a getter and setter method for it. In the following `SalaryEmployee` class,
    we have not added any fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'However, even though we haven''t added anything new to the `SalaryEmployee`
    class, it has the capabilities of the base class. In the following sequence we
    create an instance of both classes and use their methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When the code is executed, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As the `getAge` and `setAge` methods were public we can use them with the `SalaryEmployee`
    class even though we haven''t defined new versions. However, if we attempt to
    access the private `age` variable, as shown in the following code snippet, we
    will get a syntax error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax error generated is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the *A review of scope* section, we will explore scoping and inheritance
    in more depth.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Java does not support multiple inheritance between classes. That is, a derived
    class cannot extend more than one class. A derived class can extend one and only
    one class. However, Java does support multiple inheritance between interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Using the protected keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous example, we determined that we cannot access private members
    from an instance variable, `employee2.age` in the example. We cannot access it
    from methods or constructors of the derived class either. In the following implementation
    of the `SalaryEmployee` class, we attempt to initialize the `age` variable in
    its default constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax error is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: However, any base class members declared as public can be accessed from either
    a member method, or constructor of the derived class, or by an instance variable
    referencing the derived class.
  prefs: []
  type: TYPE_NORMAL
- en: There are situations where a member variable should be accessible from a derived
    class constructor, or method, but not from its instance variables. We may want
    to restrict access to the member at a finer level than either public or private.
    In the case of the `age` variable, we may trust the derived class to use the variable
    correctly but we may not trust the user of the instance variable. Using a protected
    field limits where the field can be modified within the application and where
    potential problems can be introduced.
  prefs: []
  type: TYPE_NORMAL
- en: This is where the protected access modifier comes in. By using the keyword,
    `protected`, with a base class member, we restrict access to that member. It is
    accessible from only within the base class or from derived class constructors
    or methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following implementation of the `Employee` class, the `age` variable
    is declared as protected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `age` variable is now accessible from the `SalaryEmployee` class, as illustrated
    below where it is initialized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This initialization does not generate a syntax error. However, we still cannot
    access the `age` variable from an instance reference variable. The following code
    will still result in a syntax error assuming that the class the statement resides
    in is not in the same package as the `SalaryEmployee` class. This is explained
    in the *A review of scope* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `protected` keyword can also be used with methods. Its use with methods
    furthers your ability to control access to class members. As an example, the following
    implementation of the `Employee` class uses the `protected` keyword with the `setAge`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This means that any user of the class can use the `getAge` method but only the
    base class, classes in the same package, or derived classes can access the `setAge`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While methods of a base are automatically available for use in a derived class,
    the actual implementation may not be correct for a derived class. Consider the
    use of a method to compute the pay of an employee. A `computePay` method in the
    `Employee` class may simply return a base amount, as shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This example is based on the float data type which is not necessarily the best
    data type for representing currency values. The `java.math.BigDecimal` class is
    better suited for this purpose. We used the float data type here to simplify the
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, for a derived class such as `HourlyEmployee`, the `computePay` method
    is not correct. This situation can be rectified by overriding the `computePay`
    method, as shown in the following simplified `HourlyEmployee` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'An overridden method possesses two basic characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: Has an identical signature as a base class method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is found in the derived class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The signature of a class is composed of its name, the number of parameters,
    the type of the parameters, and the order of the parameters. This is discussed
    in more detail in the *Signature* section of [Chapter 6](ch06.html "Chapter 6. Classes,
    Constructors, and Methods"), *Classes, Constructors, and Methods*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The terms overloading and overriding are easily confused. The following table
    summarizes the key differences between these terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Characteristic | Overloading | Overriding |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Method name | Same | Same |'
  prefs: []
  type: TYPE_TB
- en: '| Signature | Different | Same |'
  prefs: []
  type: TYPE_TB
- en: '| Class | Same class | In a derived class |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s look at the use of the `computePay` method. In the following sequence,
    the `computePay` method is executed against the `employee1` and `employee3` instance
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `computePay` method of the `Employee` base class is executed against the
    `employee1` reference variable while the `computePay` method of `HourlyEmployee`
    is executed against the `employee3` reference variable. The **Java Virtual Machine**
    (**JVM**) determines which method to use as the program executes. This is actually
    an example of polymorphic behavior, which we will address in the *Polymorphism*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: In a more complex hierarchy of classes, intermediate classes may not override
    a method. For example, if a `SupervisorEmployee` class was derived from the `SalaryEmployee`
    class it is not necessary for the `SalaryEmployee` class to implement the `computePay`
    method. The `SupervisorEmployee` class can override the `computePay` method of
    `Employee`, whether or not its immediate base class overrode it.
  prefs: []
  type: TYPE_NORMAL
- en: The @Override annotation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One Java language design issue concerns method overriding. The problem is that
    a developer may intend to override a method but may not, due to a simple error
    in the method declaration. In the following attempt to override the `computePay`
    method, however, the method name is misspelled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'While it may (or may not be) obvious that the method is misspelled, the developer
    may not notice the mistake. Using the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The program will still execute but will not generate the expected output as
    shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the base class' `computePay` method is used in both cases. This
    is because the `computePay` method was invoked instead of the misspelled `computPay`
    method. As the `HourlyEmployee` class no longer has a `computePay` method, the
    JVM uses the base class method. Obviously, this is not what was intended.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be hard to immediately spot these types of errors. To assist in preventing
    these types of mistakes, we can use the `@Override` annotation with the method
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This annotation informs the compiler to make sure that the method that follows,
    actually overrides a base class method. In this case, it does not because the
    name of the method is misspelled. When this happens, a syntax error is generated
    indicating that there is a problem. The syntax error message is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: When the spelling of the method is corrected, the syntax error message will
    go away.
  prefs: []
  type: TYPE_NORMAL
- en: As the name annotation implies, an annotation is a way of adding additional
    information to parts of a Java application that can be processed at a later time.
    In the case of the `@Override` annotation at compile time, a check is made to
    verify that overriding actually took place. Annotations can be used for other
    purposes, such as marking a method as deprecated.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is a good practice to always use the `@Override` annotation with overridden
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Using the final keyword with classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `public`, `abstract`, and `final` keywords can be used when declaring a
    class. The `public` keyword specifies the scope of the class, as will be explained
    in the *A review of scope* section. The use of the `abstract` keyword is covered
    in the next section, *Abstract methods and classes*. When the `final` keyword
    is used before the `class` keyword, it signifies that the class cannot be extended.
    It will be the last class in that branch of the inheritance hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the `Employee` class is designated as a final class.
    While it will not make sense to make the `Employee` class final for this chapter''s
    examples, it does illustrate the syntax required to make a class final:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: By restricting other classes from extending a class, you can be assured that
    the intended operation of the class will not be compromised by a derived class'
    overriding a base class method. If it is well implemented, this can result in
    a more reliable foundation from which to build applications.
  prefs: []
  type: TYPE_NORMAL
- en: The `java.lang.String` class is an example of a class found in the core JDK
    that is defined as final. It is not possible to extend this class or modify its
    behavior. This means that developers worldwide can use the class and not worry
    about the possibility of inadvertently using a derived class instead of the `String`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: The `final` keyword can also be used with a method definition. When used in
    this context, it means that the method cannot be overridden in a derived class.
    This provides more flexibility than making a class final. The developer can specify
    those methods that may be overridden and those that cannot be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following illustrates making the `getAge` method final in the `Employee`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If we attempt to override the method in a derived class, such as the `SalaryEmployee`
    class, we will get the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Abstract methods and classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Abstract classes are useful in the design of an object-oriented inheritance
    hierarchy. They are typically used to force a derived class to implement a specific
    set of methods. The base class and/or one or more methods of the class are declared
    as abstract. An abstract class cannot be instantiated. A non-abstract class, in
    contrast, must have all of the abstract methods in its hierarchy tree, if any,
    implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates how to make the `Employee` class abstract.
    In this example, there are no abstract methods but the `abstract` keyword was
    used to designate the class as abstract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As the `Employee` class has no abstract methods, none of the derived classes
    will be forced to implement any additional methods. The above definition effectively
    has no effect on the previous examples in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next definition of the `Employee` class makes the `computePay` method abstract.
    Notice that the method does not have a body but is terminated with a semicolon
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: All classes that are immediately derived from the `Employee` class must implement
    the abstract method or they, themselves, will become abstract. If they elect not
    to implement the `computePay` method, the class must be declared as abstract.
  prefs: []
  type: TYPE_NORMAL
- en: When we declare a method as abstract, we are forced to use the `abstract` keyword
    with the class. An abstract class can also possess non-abstract methods.
  prefs: []
  type: TYPE_NORMAL
- en: In complex hierarchies you may find a mixture of non-abstract and abstract classes.
    For example, in the `java.awt` package you will find that the non-abstract `Container`
    class extends the abstract `Component` class that extends the non-abstract `Object`
    class. An abstract class may be introduced at any level in a hierarchy to meet
    the needs of the library.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes can have final methods but they cannot be declared as final.
    That is, the `final` keyword cannot be used as a modifier of an abstract class
    or method. If this was possible, it would be impossible to extend the class. As
    it is abstract it could never be instantiated and, thus, would be useless. However,
    an abstract class can have final methods. These methods must be implemented in
    that abstract class. The class can still be extended, but the final methods cannot
    be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Polymorphism is a key object-oriented programming concept but it can be hard
    to understand initially. The primary purpose of using polymorphism is to make
    applications more maintainable. When we speak of polymorphism, we typically say
    that a method exhibits polymorphic behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A method is said to be polymorphic if the behavior of the method is dependent
    on the object it is executing against.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we want to draw something. Each class may have a method called `draw`
    that it can use to draw itself. For example, a circle class might have a draw
    method that actually draws itself as a circle. A person class might have a draw
    method that displays an image of that person. The signature of the methods is
    identical.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, if we apply the `draw` method against different objects of different classes
    with the same ultimate base class, then the result of the draw will differ depending
    on whether we are applying the `draw` method against a circle or a person. That
    is polymorphic behavior.
  prefs: []
  type: TYPE_NORMAL
- en: By designing our application to use polymorphism, we can add new classes that
    have a draw method and integrate them into our application a lot easier than previously
    possible in non-object oriented programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: When an instance of an object is created, the object goes through a series of
    initialization steps as detailed in the *Java initialization sequence* section
    in [Chapter 6](ch06.html "Chapter 6. Classes, Constructors, and Methods"), *Classes,
    Constructors, and Methods*. This applies to objects that are derived from base
    classes also. Java memory management is dynamic and automatic. When the `new`
    keyword is used, it automatically allocates memory from the heap.
  prefs: []
  type: TYPE_NORMAL
- en: In Java, a reference to a base class and any of its derived classes can be assigned
    to a base class reference variable. This is possible because of the way memory
    is allocated for base and derived classes. In a derived class, the instance variables
    of the base class are allocated first, followed by the instance variables of the
    derived class. When a base class reference variable is assigned to a derived class
    object, it sees the base class instance variables that it expects plus the "extra"
    derived class instance variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the following definitions of the `Employee` and `SalaryEmployee`
    classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, assigning either a `Employee` or a `SalaryEmployee`
    object to the base class reference makes sense from the perspective of the reference
    variable because it expects to see the instance variables `name` and `age`. We
    can assign a new `Employee` object to the `employee` variable, as shown in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This is also illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Polymorphism](img/7324_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also assign a new `SalaryEmployee` object to the `employee` variable
    using the following code. Notice that in the previous figure, and in this figure,
    the `employee` reference variable points to a `name` and a `age` field in that
    order. The `employee` reference variable expects a `Employee` object consisting
    of a `name` field and then an `age` field and that is what it sees:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This scenario is depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Polymorphism](img/7324_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If the following code snippet is executed, based upon the previous declarations
    of the `Employee` and `SalaryEmployee` classes, the `computePay` method of `SalaryEmployee`
    will be executed, and not that of the `Employee` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `computePay` method is said to be polymorphic in relation to the object
    it is running against. If the `computePay` method ran against an `Employee` object,
    the `Employee`'s `computePay` method would execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'A reference to a derived object can be assigned to that class'' object reference
    variable or to any of that class'' base classes. The advantage of polymorphic
    behavior can be better understood through the next example. Here, the sum of all
    of the employee''s pay from the `employees` array is calculated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `computePay` method is executed against each element of the array. Based
    on the object it is executing against, the appropriate `computePay` method is
    invoked. If a new class is derived from the `Employee` class, such as a `SalesEmployee`
    class, the only modification needed to make the summation process work is to add
    a `SalesEmployee` object to the array. No other changes are needed. The result
    is a more maintainable and extensible application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The allocation of the memory for derived classes helps explain how polymorphism
    works. We can assign a reference to a `SalaryEmployee` to either a `SalaryEmployee`
    reference variable or to an `Employee` reference variable. This is illustrated
    in the following code sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'All of the above assignments are legal. It is possible to assign a derived
    class object to a base class reference variable because the base class reference
    variable is actually pointing to the memory whose first part contains the base
    class instance variables. This is illustrated in the following diagram, where
    each stack reflects the cumulative effect of the four assignment statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Polymorphism](img/7324_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that some objects are no longer referenced by the application. These
    objects are eligible for garbage collection. At some point, if needed, they will
    be returned to the heap.
  prefs: []
  type: TYPE_NORMAL
- en: Managing classes and objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section is concerned with a number of issues relating to the general management
    of classes and objects. It includes the:'
  prefs: []
  type: TYPE_NORMAL
- en: Creation and initialization of objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing methods of a base class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining the type of objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use of the `Object` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Casting objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling the scope of classes and members
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The super keyword and constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we saw in the *Using the this Keyword* section of [Chapter 6](ch06.html
    "Chapter 6. Classes, Constructors, and Methods"), *Classes, Constructors, and
    Methods*, the `this` keyword refers to the current object. It can be used to:'
  prefs: []
  type: TYPE_NORMAL
- en: Access instance variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass the current object to a method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return the current object from a method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `super` keyword is used in a complementary fashion within a derived class.
    It is used to:'
  prefs: []
  type: TYPE_NORMAL
- en: Call the base class constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access an overridden method in the base class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling a base class constructor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's examine its use in calling base class constructors. When a derived class
    object is created, it is initialized by calling its constructor. The use of constructors
    is covered in the *Constructors* section of [Chapter 6](ch06.html "Chapter 6. Classes,
    Constructors, and Methods"), *Classes, Constructors, and Methods*. However, before
    a derived class constructor is executed, the base class constructor is invoked.
    This results in the base class being initialized before the derived class. This
    is particularly important should the derived class use any of the base class methods
    in the initialization sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'The invocation of the base class'' default constructor occurs automatically
    unless we use the `super` keyword to invoke an alternative base class constructor.
    The following is an implementation of the `Employee` class which defines two constructors—a
    default constructor and a three argument constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the use of the `this` keyword to call the three argument constructor.
    The following is a partial implementation of the `SalaryEmployee` class. Only
    a default constructor is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the default constructor of the `Employee` class is automatically
    invoked. However, we can make this invocation explicit by using the `super` keyword
    followed by a set of open and close parentheses, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In both cases, member variables of the `Employee` base class in the `SalaryEmployee`
    object are initialized as specified in the base class constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we explicitly use the `super` keyword to invoke a base class constructor,
    it must be the first line of the derived class' constructor. The `this` keyword
    must be the first statement in a constructor to invoke another constructor of
    the same class. Both of these keywords cannot be used in the same constructor
    to invoke another constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are situations where we may wish to invoke some constructor
    other than the default base class constructor. To do this we use the `super` keyword
    as the first statement in a derived class constructor and supply a list of parameters
    that match those of another base class constructor. In the following example,
    the four argument constructor of `SalaryEmployee` calls the base class'' three
    argument constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If we could not choose the base class constructor, then we would need to explicitly
    call the appropriate setter methods to initialize the base class variables after
    the base class'' default constructor has executed. This is illustrated in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This approach is not the preferred approach. It is best to allow the base class
    to initialize its own member variables. A derived class is not always in a position
    to determine how they should be initialized, and if they are completely hidden
    the derived class may not even be aware of their existence.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If a constructor invokes base class methods, these methods should be declared
    as final. Otherwise, a derived class that overrides them could adversely affect
    the initialization sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing an overridden method in the base class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can also use the `super` keyword to access the overridden method of a base
    class method. For example, it is always a good idea to override the `toString`
    method of a class to return a string that represents that instance of the class.
    One possible implementation of this method for the `Employee` class is provided
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'An implementation for the `SalaryEmployee` class is shown in the following
    code snippet, which uses the base class getter methods to return the name and
    age:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: However, this implementation is awkward, as it requires invocation of the getter
    methods. Another problem with this approach is that each derived class may provide
    a different representation of the base class variables resulting in possible confusion
    on the part of the user of this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ideally, we would simply call the base class'' `toString` method in this example
    to get the string representation of the base class. However, calling the `toString`
    method from within the derived class''s `toString` method results in a recursive
    call. That is, the runtime system thinks we are calling the current method. This
    is illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We can avoid these issues by using the `super` keyword to invoke a base class
    method. This is done by prefixing the name of the base class method with the `super`
    keyword and a period, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The effect of using the `super` keyword is illustrated in the next code sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `toString` method is not explicitly invoked in the `println`
    method. When an object reference is used within a `print` or a `println` method,
    the `toString` method is automatically invoked if no other methods are used with
    the reference variable.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike having to use the `super` keyword as the first statement in a constructor
    to invoke a base class constructor, when used to invoke a derived class method
    the `super` keyword can be used anywhere. It does not have to be used in the same
    overridden method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example that follows, the `display` method invokes the base class''s
    `toString` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `display` method is invoked against the `employee2` reference variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting output follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'It is not possible to call a base method above the current base class. That
    is, assuming an inheritance hierarchy of `Employee` – `SalaryEmployee` – `Supervisor`,
    a base class method of the `Employee` class cannot be called directly from a `Supervisor`
    method. The following code will result in a syntax error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Determining the type of an object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are times when it is useful to know an object's class. There are a couple
    of ways to determine its type. The first approach is to get the classname using
    the `Class` class. The second approach is to use the `instanceof` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is actually a class in Java named `Class` and it is found in the `java.lang`
    package. It is used to obtain information regarding the current object. For our
    purposes we will use its `getName` method to return the name of the class. First
    we obtain an instance of `Class` using the `getClass` method. This method is a
    member of the `Object` class. The following illustrates this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'When this sequence is executed, we get the following output. In this example,
    the class names are prefixed with the name of their package. All classes developed
    for this book were placed within the **packt** package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'While knowing the name of the class may be useful in some situations, the `instanceof`
    operator is frequently more useful. We can use the operator to determine whether
    one object is an instance of a class. This is demonstrated in the following example
    where we determine the type of classes referenced by the `employee1` and `employee2`
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This sequence displays a true or false value based on the operator''s operands.
    The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The Object class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Object` class is found in the `java.lang` package. This class is the ultimate
    base class of all Java classes. If a class does not explicitly extend a class,
    Java will automatically extend that class from the `Object` class. To illustrate
    this, consider the following definition of the `Employee` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'While we did not explicitly extend the `Object` class, it is extended from
    the `Object` class. To verify this, consider the following code sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The application of the `instanceof` operator confirms that the `Employee` class
    is ultimately an object of `Object`. The above definition of the `Employee` class
    has the same effect as if we had derived it from the `Object` explicitly, as shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Using a common base class in Java guarantees that all classes have common methods.
    The `Object` class possesses several methods that most classes may need, as listed
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `clone` | Produces a copy of the object. |'
  prefs: []
  type: TYPE_TB
- en: '| `equals` | Returns true if two objects are "equal". |'
  prefs: []
  type: TYPE_TB
- en: '| `toString` | Returns a string representation of the object. |'
  prefs: []
  type: TYPE_TB
- en: '| `finalize` | Performed before an object is returned to the heap manager.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `getClass` | Returns a `Class` object that provides additional information
    about an object. |'
  prefs: []
  type: TYPE_TB
- en: '| `hashCode` | Returns a unique hash code for the object. |'
  prefs: []
  type: TYPE_TB
- en: '| `notify` | Used in thread management. |'
  prefs: []
  type: TYPE_TB
- en: '| `notifyAll` | Also used in thread management. |'
  prefs: []
  type: TYPE_TB
- en: '| `wait` | Overloaded method used in thread management. |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a new class is created it is always a good idea to override the `toString`,
    `equals`, and `hashCode` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before an object can be cloned, its class must implement the `java.lang.Cloneable`
    interface. The `clone` method is protected.
  prefs: []
  type: TYPE_NORMAL
- en: Casting objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Java, we are able to cast an object to a different class, other than that
    of the original object. The cast can be up or down the hierarchy chain. When we
    cast a derived class object to a base class reference variable, it is called **upcasting**
    . When we cast a base class object to a derived class reference variable, it is
    called **downcasting** . Let''s start with the following declaration where `Employee`
    is the base class of `SalaryEmployee`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example illustrates upcasting. An instance of the derived class,
    `SalaryEmployee` is assigned to the base class reference variable `employee1`.
    This is legal and is an important part of polymorphic behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The next statement attempts to perform downcasting. An instance of the base
    class is being assigned to the derived class reference variable. This statement
    will result in a syntax error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the syntax error can be avoided by using the cast operator as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'But, a `ClassCastException` exception, shown as follows, will be thrown when
    the preceding statement is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Upcasting is possible because the derived object contains everything that the
    base class has, plus something more. Downcasting is not a good idea as the reference
    variable expects an object with more capabilities than is supplied.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice, with upcasting, that the methods available to the reference variable
    are those of the base class and not the derived class. Even though the reference
    variable points to the derived class object, it can only use the base class methods
    because that''s what we''ve told the Java compiler the object is. This is illustrated
    in the following statement where we try to use the derived class'' `setStock`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The following syntax error will be generated for this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: A review of scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Scope refers to when a variable is visible and can be accessed. In earlier chapters
    we learned how the `public` and `private` keywords are used to control the scope
    of member variables. In the *Using the protected keyword* section of this chapter,
    we explored how the `protected` keyword works. However, the declaration of a member
    variable does not require the use of any of these keywords. When modifiers are
    not used, the variable declaration is called **package-private** . As the name
    implies, the scope of the variable is restricted to those classes in the same
    package.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to consider the use of the `public` keyword when used with a class
    definition. If a class is declared as public, it is visible to all classes. If
    no declaration is used, its visibility is limited to the current package. The
    class is said to have package-private visibility.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The use of the `private` and `protected` keywords cannot be used with a class
    definition unless the class is an inner class. An inner class is a class that
    is declared within another class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table summarizes the scope of access modifiers as applied to
    class member variables and methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Modifier | Class | Package | Derived Class | Other |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| public | ![A review of scope](img/7324EN_07_icon1.jpg) | ![A review of scope](img/7324EN_07_icon1.jpg)
    | ![A review of scope](img/7324EN_07_icon1.jpg) | ![A review of scope](img/7324EN_07_icon1.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: '| private | ![A review of scope](img/7324EN_07_icon1.jpg) | ![A review of scope](img/7324EN_07_icon2.jpg)
    | ![A review of scope](img/7324EN_07_icon2.jpg) | ![A review of scope](img/7324EN_07_icon2.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: '| protected | ![A review of scope](img/7324EN_07_icon1.jpg) | ![A review of
    scope](img/7324EN_07_icon1.jpg) | ![A review of scope](img/7324EN_07_icon1.jpg)
    | ![A review of scope](img/7324EN_07_icon2.jpg) |'
  prefs: []
  type: TYPE_TB
- en: '| none | ![A review of scope](img/7324EN_07_icon1.jpg) | ![A review of scope](img/7324EN_07_icon1.jpg)
    | ![A review of scope](img/7324EN_07_icon2.jpg) | ![A review of scope](img/7324EN_07_icon2.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s also consider the following package/class arrangement, which provides
    a more detailed look into the scoping rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A review of scope](img/7324_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Assume that class `A` has the following declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table summarizes the scoping rules for these declarations. These
    rules apply to both variables and methods declared in class `A`. It is slightly
    different from the previous table as it illustrates the placement of a derived
    class in a different package. Thus, the access permissions in the protected row
    appear to be different from the previous table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Variable | A | B | C | D | E |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `public int v1;` | ![A review of scope](img/7324EN_07_icon1.jpg) | ![A review
    of scope](img/7324EN_07_icon1.jpg) | ![A review of scope](img/7324EN_07_icon1.jpg)
    | ![A review of scope](img/7324EN_07_icon1.jpg) | ![A review of scope](img/7324EN_07_icon1.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `private int v2;` | ![A review of scope](img/7324EN_07_icon1.jpg) | ![A review
    of scope](img/7324EN_07_icon2.jpg) | ![A review of scope](img/7324EN_07_icon2.jpg)
    | ![A review of scope](img/7324EN_07_icon2.jpg) | ![A review of scope](img/7324EN_07_icon2.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `protected int v3;` | ![A review of scope](img/7324EN_07_icon1.jpg) | ![A
    review of scope](img/7324EN_07_icon1.jpg) | ![A review of scope](img/7324EN_07_icon1.jpg)
    | ![A review of scope](img/7324EN_07_icon2.jpg) | ![A review of scope](img/7324EN_07_icon1.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `int v4;` | ![A review of scope](img/7324EN_07_icon1.jpg) | ![A review of
    scope](img/7324EN_07_icon1.jpg) | ![A review of scope](img/7324EN_07_icon1.jpg)
    | ![A review of scope](img/7324EN_07_icon2.jpg) | ![A review of scope](img/7324EN_07_icon2.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: 'It may be necessary to declare an instance of class `A` in some of these classes
    in order to have access to the instances variables of `A`. For example, in class
    `D` the following code is needed to access class `A`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In general, use the most restrictive access that makes sense. This will improve
    the reliability of the application by avoiding situations where accidental access
    to a member results in unanticipated consequences.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we have studied inheritance and polymorphic behavior, as defined
    by Java. We have examined how objects are allocated in memory to gain a more comprehensive
    understanding of how polymorphism and constructors work. The use of the `this`
    and `super` keywords were examined with regards to their use in constructors and
    derived class methods. In addition, abstract classes were examined, along with
    how they impact on polymorphic behavior.
  prefs: []
  type: TYPE_NORMAL
- en: The `protected` and `final` keywords were covered. We saw how the `final` keyword
    can affect inheritance and overriding methods. The `protected` keyword allowed
    us to better control the access to information in a derived class.
  prefs: []
  type: TYPE_NORMAL
- en: The management of classes and objects was addressed including the organization
    of classes in a package and how to obtain information about objects using the
    `Class` class. The use of package-protected members was introduced. Also covered
    was the use of casting with classes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will cover the important topic of exception handling.
    Knowing how to properly use exception handling will enable you to create more
    robust and maintainable programs.
  prefs: []
  type: TYPE_NORMAL
- en: Certification objectives covered
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The certification objectives addressed in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing the code that demonstrates the use of polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Differentiating between the type of a reference and the type of an object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining when casting is necessary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `super` and `this` to access objects and constructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using abstract classes and interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which set of statements result in `ClassB` and `ClassC` being derived from `ClassA`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `class ClassB extends ClassA {}`
  prefs: []
  type: TYPE_NORMAL
- en: b. `class ClassB extends ClassC {}`
  prefs: []
  type: TYPE_NORMAL
- en: c. `class ClassA extends ClassB {}`
  prefs: []
  type: TYPE_NORMAL
- en: d. `class ClassC extends ClassB {}`
  prefs: []
  type: TYPE_NORMAL
- en: e. No combination will work
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following must be true for a method to support polymorphism?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. The method must override a base class method
  prefs: []
  type: TYPE_NORMAL
- en: b. The method must overload a base class method
  prefs: []
  type: TYPE_NORMAL
- en: c. The method's class must extend a base class that has the overridden method
  prefs: []
  type: TYPE_NORMAL
- en: d. The method must execute against a base class reference variable
  prefs: []
  type: TYPE_NORMAL
- en: What method is used to determine the type of an object?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `isType`
  prefs: []
  type: TYPE_NORMAL
- en: b. `typeOf`
  prefs: []
  type: TYPE_NORMAL
- en: c. `instanceof`
  prefs: []
  type: TYPE_NORMAL
- en: d. `instanceOf`
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following are valid casts?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `num1 = num2;`
  prefs: []
  type: TYPE_NORMAL
- en: b. `num1 = (int)num2;`
  prefs: []
  type: TYPE_NORMAL
- en: c. `num1 = (float)num2;`
  prefs: []
  type: TYPE_NORMAL
- en: d. `num1(int) = num2;`
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the following class definitions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'What statement is needed at the comment line to generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: a. `super();`
  prefs: []
  type: TYPE_NORMAL
- en: b. `super().someMethod;`
  prefs: []
  type: TYPE_NORMAL
- en: c. `super.someMethod();`
  prefs: []
  type: TYPE_NORMAL
- en: d. `someMethod();`
  prefs: []
  type: TYPE_NORMAL
- en: e. None of the above
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following statements are true?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. An abstract class must use the abstract keyword when declared
  prefs: []
  type: TYPE_NORMAL
- en: b. An abstract class must have one or more abstract methods
  prefs: []
  type: TYPE_NORMAL
- en: c. An abstract class cannot extend a non-abstract class
  prefs: []
  type: TYPE_NORMAL
- en: d. An abstract class cannot implement an interface
  prefs: []
  type: TYPE_NORMAL
