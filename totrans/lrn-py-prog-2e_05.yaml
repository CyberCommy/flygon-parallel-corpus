- en: Saving Time and Memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"It''s not the daily increase but daily decrease. Hack away at the unessential."–
    Bruce Lee'
  prefs: []
  type: TYPE_NORMAL
- en: I love this quote from Bruce Lee. He was such a wise man! Especially, the second
    part, <q class="calibre30">"*hack away at the unessential"*</q>, is to me what
    makes a computer program elegant. After all, if there is a better way of doing
    things so that we don't waste time or memory, why not?
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, there are valid reasons for not pushing our code up to the maximum
    limit: for example, sometimes to achieve a negligible improvement, we have to
    sacrifice on readability or maintainability. Does it make any sense to have a
    web page served in 1 second with unreadable, complicated code, when we can serve
    it in 1.05 seconds with readable, clean code? No, it makes no sense.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, sometimes it's perfectly reasonable to try to shave off a
    millisecond from a function, especially when the function is meant to be called
    thousands of times. Every millisecond you save there means one second saved per
    thousands of calls, and this could be meaningful for your application.
  prefs: []
  type: TYPE_NORMAL
- en: In light of these considerations, the focus of this chapter will not be to give
    you the tools to push your code to the absolute limits of performance and optimization
    "no matter what," but rather, to enable you to write efficient, elegant code that
    reads well, runs fast, and doesn't waste resources in an obvious way.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The map, zip, and filter functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comprehensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I will perform several measurements and comparisons, and cautiously draw some
    conclusions. Please do keep in mind that on a different box with a different setup
    or a different operating system, results may vary. Take a look at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Both functions return the square of `n`, but which is faster? From a simple
    benchmark I ran on them, it looks like the second is slightly faster. If you think
    about it, it makes sense: calculating the power of a number involves multiplication
    and therefore, whatever algorithm you may use to perform the power operation,
    it''s not likely to beat a simple multiplication such as the one in `square2`.'
  prefs: []
  type: TYPE_NORMAL
- en: Do we care about this result? In most cases, no. If you're coding an e-commerce
    website, chances are you won't ever even need to raise a number to the second
    power, and if you do, it's likely to be a sporadic operation. You don't need to
    concern yourself with saving a fraction of a microsecond on a function you call
    a few times.
  prefs: []
  type: TYPE_NORMAL
- en: So, when does optimization become important? One very common case is when you
    have to deal with huge collections of data. If you're applying the same function
    on a million `customer` objects, then you want your function to be tuned up to
    its best. Gaining 1/10 of a second on a function called one million times saves
    you 100,000 seconds, which is about 27.7 hours. That's not the same, right? So,
    let's focus on collections, and let's see which tools Python gives you to handle
    them with efficiency and grace.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the concepts we will see in this chapter are based on those of the iterator
    and iterable. Simply put, the ability for an object to return its next element
    when asked, and to raise a `StopIteration` exception when exhausted. We'll see
    how to code a custom iterator and iterable objects in [Chapter 6](part0163.html#4REBM0-2ddb708647cc4530a187c2c6c0e9acfe),
    *OOP, Decorators, and Iterators*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to the nature of the objects we''re going to explore in this chapter, I
    was often forced to wrap the code in a `list` constructor. This is because passing
    an iterator/generator to `list(...)` exhausts it and puts all the generated items
    in a newly created list, which I can easily print to show you its content. This
    technique hinders readability, so let me introduce an alias for list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Of the three sections I have highlighted, the first one is the call we need
    to do in order to show what would be generated by `range(7)`, the second one is
    the moment when I create the alias to list (I chose the hopefully unobtrusive
    underscore), and the third one is the equivalent call, when I use the alias instead
    of list.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully readability will benefit from this, and please keep in mind that I
    will assume this alias to have been defined for all the code in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The map, zip, and filter functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start by reviewing `map`, `filter`, and `zip`, which are the main built-in
    functions one can employ when handling collections, and then we''ll learn how
    to achieve the same results using two very important constructs: **comprehensions**
    and **generators**. Fasten your seatbelt!'
  prefs: []
  type: TYPE_NORMAL
- en: map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'According to the official Python documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: map(function, iterable, ...) returns an iterator that applies function to every
    item of iterable, yielding the results. If additional iterable arguments are passed,
    function must take that many arguments and is applied to the items from all iterables
    in parallel. With multiple iterables, the iterator stops when the shortest iterable
    is exhausted.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will explain the concept of yielding later on in the chapter. For now, let''s
    translate this into code—we''ll use a `lambda` function that takes a variable
    number of positional arguments, and just returns them as a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, you can see why we have to wrap calls in `list(...)`
    (or its alias, `_`, in this case). Without it, I get the string representation
    of a `map` object, which is not really useful in this context, is it?
  prefs: []
  type: TYPE_NORMAL
- en: You can also notice how the elements of each iterable are applied to the function;
    at first, the first element of each iterable, then the second one of each iterable,
    and so on. Notice also that `map` stops when the shortest of the iterables we
    called it with is exhausted. This is actually a very nice behavior; it doesn't
    force us to level off all the iterables to a common length, and it doesn't break
    if they aren't all the same length.
  prefs: []
  type: TYPE_NORMAL
- en: '`map` is very useful when you have to apply the same function to one or more
    collections of objects. As a more interesting example, let''s see the **decorate-sort-undecorate**
    idiom (also known as **Schwartzian transform**). It''s a technique that was extremely
    popular when Python sorting wasn''t providing *key-functions*, and therefore is
    less used today, but it''s a cool trick that still comes in handy once in a while.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a variation of it in the next example: we want to sort in descending
    order by the sum of credits accumulated by students, so to have the best student
    at position 0\. We write a function to produce a decorated object, we sort, and
    then we undecorate. Each student has credits in three (possibly different) subjects.
    In this context, to decorate an object means to transform it, either adding extra
    data to it, or putting it into another object, in a way that allows us to be able
    to sort the original objects the way we want. This technique has nothing to do
    with Python decorators, which we will explore later on in the book.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the sorting, we revert the decorated objects to get the original ones
    from them. This is called to undecorate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start by understanding what each student object is. In fact, let''s
    print the first one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that it''s a dictionary with two keys: `id` and `credits`. The
    value of `credits` is also a dictionary in which there are three subject/grade
    key/value pairs. As I''m sure you recall from our visit in the data structures
    world, calling `dict.values()` returns an object similar to `iterable`, with only
    the values. Therefore, `sum(student[''credits''].values())` for the first student
    is equivalent to `sum((9, 6, 7))`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s print the result of calling decorate with the first student:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If we decorate all the students like this, we can sort them on their total amount
    of credits by just sorting the list of tuples. In order to apply the decoration
    to each item in students, we call `map(decorate, students)`. Then we sort the
    result, and then we undecorate in a similar fashion. If you have gone through
    the previous chapters correctly, understanding this code shouldn't be too hard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Printing students after running the whole code yields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: And you can see, by the order of the student objects, that they have indeed
    been sorted by the sum of their credits.
  prefs: []
  type: TYPE_NORMAL
- en: For more on the *decorate-sort-undecorate* idiom, there's a very nice introduction
    in the sorting how-to section of the official Python documentation ([https://docs.python.org/3.7/howto/sorting.html#the-old-way-using-decorate-sort-undecorate](https://docs.python.org/3.7/howto/sorting.html#the-old-way-using-decorate-sort-undecorate)).
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing to notice about the sorting part: what if two or more students share
    the same total sum? The sorting algorithm would then proceed to sort the tuples
    by comparing the `student` objects with each other. This doesn''t make any sense,
    and in more complex cases, could lead to unpredictable results, or even errors.
    If you want to be sure to avoid this issue, one simple solution is to create a
    three-tuple instead of a two-tuple, having the sum of credits in the first position,
    the position of the `student` object in the `students` list in the second one,
    and the `student` object itself in the third one. This way, if the sum of credits
    is the same, the tuples will be sorted against the position, which will always
    be different and therefore enough to resolve the sorting between any pair of tuples.'
  prefs: []
  type: TYPE_NORMAL
- en: zip
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already covered `zip` in the previous chapters, so let's just define it
    properly and then I want to show you how you could combine it with `map`.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the Python documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: zip(*iterables) returns an iterator of tuples, where the i-th tuple contains
    the i-th element from each of the argument sequences or iterables. The iterator
    stops when the shortest input iterable is exhausted. With a single iterable argument,
    it returns an iterator of 1-tuples. With no arguments, it returns an empty iterator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we're zipping together the average and the grade for
    the last exam, for each student. Notice how easy it is to reproduce `zip` using
    `map` (last two instructions of the example). Here as well, to visualize results
    we have to use our `_` alias.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple example on the combined use of `map` and `zip` could be a way of calculating
    the element-wise maximum amongst sequences, that is, the maximum of the first
    element of each sequence, then the maximum of the second one, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice how easy it is to calculate the max values of three sequences. `zip`
    is not strictly needed of course, we could just use `map`. Sometimes it's hard,
    when showing a simple example, to grasp why using a technique might be good or
    bad. We forget that we aren't always in control of the source code, we might have
    to use a third-party library, which we can't change the way we want. Having different
    ways to work with data is therefore really helpful.
  prefs: []
  type: TYPE_NORMAL
- en: filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'According to the Python documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: filter(function, iterable) construct an iterator from those elements of iterable
    for which function returns True. iterable may be either a sequence, a container
    which supports iteration, or an iterator. If function is None, the identity function
    is assumed, that is, all elements of iterable that are false are removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a very quick example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, notice how the second call to `filter` is equivalent
    to the first one. If we pass a function that takes one argument and returns the
    argument itself, only those arguments that are `True` will make the function return
    `True`, therefore this behavior is exactly the same as passing `None`. It's often
    a very good exercise to mimic some of the built-in Python behaviors. When you
    succeed, you can say you fully understand how Python behaves in a specific situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Armed with `map`, `zip`, and `filter` (and several other functions from the
    Python standard library) we can massage sequences very effectively. But those
    functions are not the only way to do it. So let''s see one of the nicest features
    of Python: comprehensions.'
  prefs: []
  type: TYPE_NORMAL
- en: Comprehensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Comprehensions are a concise notation, both perform some operation for a collection
    of elements, and/or select a subset of them that meet some condition. They are
    borrowed from the functional programming language Haskell ([https://www.haskell.org/](https://www.haskell.org/)),
    and contribute to giving Python a functional flavor, together with iterators and
    generators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python offers you different types of comprehensions: `list`, `dict`, and `set`.
    We''ll concentrate on the first one for now, and then it will be easy to explain
    the other two.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with a very simple example. I want to calculate a list with the
    squares of the first 10 natural numbers. How would you do it? There are a couple
    of equivalent ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example should be nothing new for you. Let''s see how to achieve
    the same result using a `list` comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As simple as that. Isn''t it elegant? Basically we have put a `for` loop within
    square brackets. Let''s now filter out the odd squares. I''ll show you how to
    do it with `map` and `filter` first, and then using a `list` comprehension again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'I think that now the difference in readability is evident. The `list` comprehension
    reads much better. It''s almost English: give me all squares (`n ** 2`) for `n`
    between `0` and `9` if `n` is even.'
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the Python documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: A list comprehension consists of brackets containing an expression followed
    by a for clause, then zero or more for or if clauses. The result will be a new
    list resulting from evaluating the expression in the context of the for and if
    clauses which follow it.
  prefs: []
  type: TYPE_NORMAL
- en: Nested comprehensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see an example of nested loops. It''s very common when dealing with
    algorithms to have to iterate on a sequence using two placeholders. The first
    one runs through the whole sequence, left to right. The second one as well, but
    it starts from the first one, instead of 0\. The concept is that of testing all
    pairs without duplication. Let''s see the classical `for` loop equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you print pairs at the end, you get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'All the tuples with the same letter are those where `b` is at the same position
    as `a`. Now, let''s see how we can translate this in a `list` comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This version is just two lines long and achieves the same result. Notice that
    in this particular case, because the `for` loop over `b` has a dependency on `a`,
    it must follow the `for` loop over `a` in the comprehension. If you swap them
    around, you'll get a name error.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering a comprehension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can apply filtering to a comprehension. Let''s do it first with `filter`.
    Let''s find all Pythagorean triples whose short sides are numbers smaller than
    10\. We obviously don''t want to test a combination twice, and therefore we''ll
    use a trick similar to the one we saw in the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: A **Pythagorean triple** is a triple (*a*, *b*, *c*) of integer numbers satisfying the
    equation *a² + b² = c²*.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, we generated a list of *three-tuples*, `triples`. Each
    tuple contains two integer numbers (the legs), and the hypotenuse of the Pythagorean
    triangle whose legs are the first two numbers in the tuple. For example, when
    `a` is `3` and `b` is `4`, the tuple will be `(3, 4, 5.0)`, and when `a` is `5`
    and `b` is `7`, the tuple will be `(5, 7, 8.602325267042627)`.
  prefs: []
  type: TYPE_NORMAL
- en: After having all the `triples` done, we need to filter out all those that don't
    have a hypotenuse that is an integer number. In order to do this, we filter based
    on `float_number.is_integer()` being `True`. This means that of the two example
    tuples I showed you before, the one with `5.0` hypotenuse will be retained, while
    the one with the `8.602325267042627` hypotenuse will be discarded.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is good, but I don''t like that the triple has two integer numbers and
    a float. They are supposed to be all integers, so let''s use `map` to fix this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the step we added. We take each element in `triples` and we slice it,
    taking only the first two elements in it. Then, we concatenate the slice with
    a one-tuple, in which we put the integer version of that float number that we
    didn''t like. Seems like a lot of work, right? Indeed it is. Let''s see how to
    do all this with a `list` comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: I know. It's much better, isn't it? It's clean, readable, shorter. In other
    words, it's elegant.
  prefs: []
  type: TYPE_NORMAL
- en: I'm going quite fast here, as anticipated in the *Summary* of [Chapter 4](part0108.html#36VSO0-2ddb708647cc4530a187c2c6c0e9acfe), *Functions,
    the Building Blocks of Code*. Are you playing with this code? If not, I suggest
    you do. It's very important that you play around, break things, change things,
    see what happens. Make sure you have a clear understanding of what is going on.
    You want to become a ninja, right?
  prefs: []
  type: TYPE_NORMAL
- en: dict comprehensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dictionary and `set` comprehensions work exactly like the list ones, only there
    is a little difference in the syntax. The following example will suffice to explain
    everything you need to know:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If you print `lettermap`, you will see the following (I omitted the middle
    results, you get the gist):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'What happens in the preceding code is that we''re feeding the `dict` constructor
    with a comprehension (technically, a generator expression, we''ll see it in a
    bit). We tell the `dict` constructor to make *key*/*value* pairs from each tuple
    in the comprehension. We enumerate the sequence of all lowercase ASCII letters,
    starting from `1`, using `enumerate`. Piece of cake. There is also another way
    to do the same thing, which is closer to the other dictionary syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'It does exactly the same thing, with a slightly different syntax that highlights
    a bit more of the *key: value* part.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dictionaries do not allow duplication in the keys, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a dictionary with keys, the letters in the `''Hello''` string, and
    values of the same letters, but with the case swapped. Notice there is only one
    `''l'': ''L''` pair. The constructor doesn''t complain, it simply reassigns duplicates
    to the latest value. Let''s make this clearer with another example; let''s assign
    to each key its position in the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the value associated with the letter `''l'': 3`. The `''l'': 2` pair
    isn''t there; it has been overridden by `''l'': 3`.'
  prefs: []
  type: TYPE_NORMAL
- en: set comprehensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `set` comprehensions are very similar to list and dictionary ones. Python
    allows both the `set()` constructor to be used, or the explicit `{}` syntax. Let''s
    see one quick example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Notice how for `set` comprehensions, as for dictionaries, duplication is not
    allowed and therefore the resulting set has only four letters. Also, notice that
    the expressions assigned to `letters1` and `letters2` produce equivalent sets.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax used to create `letters2` is very similar to the one we can use to
    create a dictionary comprehension. You can spot the difference only by the fact
    that dictionaries require keys and values, separated by columns, while sets don't.
  prefs: []
  type: TYPE_NORMAL
- en: Generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Generators** are very powerful tool that Python gifts us with. They are based
    on the concepts of *iteration*, as we said before, and they allow for coding patterns
    that combine elegance with efficiency.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generators are of two types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Generator functions**: These are very similar to regular functions, but instead
    of returning results through return statements, they use yield, which allows them
    to suspend and resume their state between each call'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generator expressions**: These are very similar to the `list` comprehensions
    we''ve seen in this chapter, but instead of returning a list they return an object
    that produces results one by one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generator functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generator functions behave like regular functions in all respects, except for
    one difference. Instead of collecting results and returning them at once, they
    are automatically turned into iterators that yield results one at a time when
    you call `next` on them. Generator functions are automatically turned into their
    own iterators by Python.
  prefs: []
  type: TYPE_NORMAL
- en: This is all very theoretical so, let's make it clear why such a mechanism is
    so powerful, and then let's see an example.
  prefs: []
  type: TYPE_NORMAL
- en: Say I asked you to count out loud from 1 to 1,000,000\. You start, and at some
    point I ask you to stop. After some time, I ask you to resume. At this point,
    what is the minimum information you need to be able to resume correctly? Well,
    you need to remember the last number you called. If I stopped you after 31,415,
    you will just go on with 31,416, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The point is, you don't need to remember all the numbers you said before 31,415,
    nor do you need them to be written down somewhere. Well, you may not know it,
    but you're behaving like a generator already!
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a good look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the two `print` statements will be the same: `[0, 1, 4, 9, 16,
    25, 36, 49, 64, 81]`. But there is a huge difference between the two functions.
    `get_squares` is a classic function that collects all the squares of numbers in
    [0, *n*) in a list, and returns it. On the other hand, `get_squares_gen` is a
    generator, and behaves very differently. Each time the interpreter reaches the
    `yield` line, its execution is suspended. The only reason those `print` statements
    return the same result is because we fed `get_squares_gen` to the `list` constructor,
    which exhausts the generator completely by asking the next element until a `StopIteration`
    is raised. Let''s see this in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, each time we call `next` on the generator object, we
    either start it (first `next`) or make it resume from the last suspension point
    (any other `next`).
  prefs: []
  type: TYPE_NORMAL
- en: The first time we call `next` on it, we get `0`, which is the square of `0`,
    then `1`, then `4`, then `9`, and since the `for` loop stops after that (`n` is
    `4`), then the generator naturally ends. A classic function would at that point
    just return `None`, but in order to comply with the iteration protocol, a generator
    will instead raise a `StopIteration` exception.
  prefs: []
  type: TYPE_NORMAL
- en: This explains how a `for` loop works. When you call `for k in range(n)`, what
    happens under the hood is that the `for` loop gets an iterator out of `range(n)`
    and starts calling `next` on it, until `StopIteration` is raised, which tells
    the `for` loop that the iteration has reached its end.
  prefs: []
  type: TYPE_NORMAL
- en: Having this behavior built into every iteration aspect of Python makes generators
    even more powerful because once we write them, we'll be able to plug them into
    whatever iteration mechanism we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you''re probably asking yourself why you would want to use a
    generator instead of a regular function. Well, the title of this chapter should
    suggest the answer. I''ll talk about performances later, so for now let''s concentrate
    on another aspect: sometimes generators allow you to do something that wouldn''t
    be possible with a simple list. For example, say you want to analyze all permutations
    of a sequence. If the sequence has a length of *N*, then the number of its permutations
    is *N!*. This means that if the sequence is 10 elements long, the number of permutations
    is 3,628,800\. But a sequence of 20 elements would have 2,432,902,008,176,640,000
    permutations. They grow factorially.'
  prefs: []
  type: TYPE_NORMAL
- en: Now imagine you have a classic function that is attempting to calculate all
    permutations, put them in a list, and return it to you. With 10 elements, it would
    require probably a few dozen seconds, but for 20 elements there is simply no way
    that it can be done.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, a generator function will be able to start the computation
    and give you back the first permutation, then the second, and so on. Of course
    you won't have the time to parse them all, there are too many, but at least you'll
    be able to work with some of them.
  prefs: []
  type: TYPE_NORMAL
- en: Remember when we were talking about the `break` statement in `for` loops? When
    we found a number dividing a *candidate prime* we were breaking the loop, and
    there was no need to go on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes it''s exactly the same, only the amount of data you have to iterate
    over is so huge that you cannot keep it all in memory in a list. In this case,
    generators are invaluable: they make possible what wouldn''t be possible otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: So, in order to save memory (and time), use generator functions whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s also worth noting that you can use the return statement in a generator
    function. It will produce a `StopIteration` exception to be raised, effectively
    ending the iteration. This is extremely important. If a `return` statement were
    actually to make the function return something, it would break the iteration protocol.
    Python''s consistency prevents this, and allows us great ease when coding. Let''s
    see a quick example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code yields all terms of the geometric progression, *a*, *aq*,
    *aq²*, *aq³*, .... When the progression produces a term that is greater than `100000`,
    the generator stops (with a `return` statement). Running the code produces the
    following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The next term would have been `156250`, which is too big.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking about `StopIteration`, as of Python 3.5, the way that exceptions are
    handled in generators has changed. To understand the implications of the change
    is probably asking too much of you at this point, so just know that you can read
    all about it in PEP 479 ([https://legacy.python.org/dev/peps/pep-0479/](https://legacy.python.org/dev/peps/pep-0479/)).
  prefs: []
  type: TYPE_NORMAL
- en: Going beyond next
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the beginning of this chapter, I told you that generator objects are based
    on the iteration protocol. We'll see in [Chapter 6](part0163.html#4REBM0-2ddb708647cc4530a187c2c6c0e9acfe), *OOP,
    Decorators, and Iterators* a complete example of how to write a custom iterator/iterable
    object. For now, I just want you to understand how `next()` works.
  prefs: []
  type: TYPE_NORMAL
- en: What happens when you call `next(generator)` is that you're calling the `generator.__next__()`
    method. Remember, a **method** is just a function that belongs to an object, and
    objects in Python can have special methods. `__next__()` is just one of these
    and its purpose is to return the next element of the iteration, or to raise `StopIteration`
    when the iteration is over and there are no more elements to return.
  prefs: []
  type: TYPE_NORMAL
- en: If you recall, in Python, an object's special methods are also called **magic
    methods**, or **dunder** (from "double underscore") **methods**.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we write a generator function, Python automatically transforms it into
    an object that is very similar to an iterator, and when we call `next(generator)`,
    that call is transformed in `generator.__next__()`. Let''s revisit the previous
    example about generating squares:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The result is exactly as the previous example, only this time instead of using
    the `next(squares)` proxy call, we're directly calling `squares.__next__()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generator objects have also three other methods that allow us to control their
    behavior: `send`, `throw`, and `close`. `send` allows us to communicate a value
    back to the generator object, while `throw` and `close`, respectively, allow us
    to raise an exception within the generator and close it. Their use is quite advanced
    and I won''t be covering them here in detail, but I want to spend a few words
    on `send`, with a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding iterator creates a generator object that will run forever. You
    can keep calling it, and it will never stop. Alternatively, you can put it in
    a `for` loop, for example, `for n in counter(): ...`, and it will go on forever
    as well. But what if you wanted to stop it at some point? One solution is to use
    a variable to control the `while` loop. Something such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This will do it. We start with `stop = False`, and until we change it to `True`,
    the generator will just keep going, like before. The moment we change stop to
    `True` though, the `while` loop will exit, and the next call will raise a `StopIteration`
    exception. This trick works, but I don''t like it. We depend on an external variable,
    and this can lead to issues: what if another function changes that `stop`? Moreover,
    the code is scattered. In a nutshell, this isn''t good enough.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make it better by using `generator.send()`. When we call `generator.send()`,
    the value that we feed to `send` will be passed in to the generator, execution
    is resumed, and we can fetch it via the `yield` expression. This is all very complicated
    when explained with words, so let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Execution of the preceding code produces the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: I think it's worth going through this code line by line, like if we were executing
    it, to see whether we can understand what's going on.
  prefs: []
  type: TYPE_NORMAL
- en: We start the generator execution with a call to `next` (`#C`). Within the generator,
    `n` is set to the same value as `start`. The `while` loop is entered, execution
    stops (`#A`) and `n` (`0`) is yielded back to the caller. `0` is printed on the
    console.
  prefs: []
  type: TYPE_NORMAL
- en: We then call `send` (`#D`), execution resumes, and `result` is set to `'Wow!'`
    (still `#A`), then its type and value are printed on the console (`#B`). `result`
    is not `'Q'`, therefore `n` is incremented by `1` and execution goes back to the
    `while` condition, which, being `True`, evaluates to `True` (that wasn't hard
    to guess, right?). Another loop cycle begins, execution stops again (`#A`), and
    `n` (`1`) is yielded back to the caller. `1` is printed on the console.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we call `next` (`#E`), execution is resumed again (`#A`), and
    because we are not sending anything to the generator explicitly, Python behaves
    exactly like functions that are not using the `return` statement; the `yield n`
    expression (`#A`) returns `None`. `result` therefore is set to `None`, and its
    type and value are yet again printed on the console (`#B`). Execution continues,
    `result` is not `'Q'` so `n` is incremented by `1`, and we start another loop
    again. Execution stops again (`#A`) and `n` (`2`) is yielded back to the caller.
    `2` is printed on the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'And now for the grand finale: we call `send` again (`#F`), but this time we
    pass in `''Q''`, therefore when execution is resumed, `result` is set to `''Q''`
    (`#A`). Its type and value are printed on the console (`#B`), and then finally
    the `if` clause evaluates to `True` and the `while` loop is stopped by the `break`
    statement. The generator naturally terminates, which means a `StopIteration` exception
    is raised. You can see the print of its traceback on the last few lines printed
    on the console.'
  prefs: []
  type: TYPE_NORMAL
- en: This is not at all simple to understand at first, so if it's not clear to you,
    don't be discouraged. You can keep reading on and then you can come back to this
    example after some time.
  prefs: []
  type: TYPE_NORMAL
- en: Using `send` allows for interesting patterns, and it's worth noting that `send`
    can also be used to start the execution of a generator (provided you call it with `None`).
  prefs: []
  type: TYPE_NORMAL
- en: The yield from expression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another interesting construct is the `yield from` expression. This expression
    allows you to yield values from a sub iterator. Its use allows for quite advanced
    patterns, so let''s just see a very quick example of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code prints the numbers `4`, `9`, `16` on the console (on separate
    lines). By now, I expect you to be able to understand it by yourself, but let''s
    quickly recap what happens. The `for` loop outside the function gets an iterator
    from `print_squares(2, 5)` and calls `next` on it until iteration is over. Every
    time the generator is called, execution is suspended (and later resumed) on `yield
    n ** 2`, which returns the square of the current `n`. Let''s see how we can transform
    this code benefiting from the `yield from` expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This code produces the same result, but as you can see `yield from` is actually
    running a sub iterator, `(n ** 2 ...)`. The `yield from` expression returns to
    the caller each value the sub iterator is producing. It's shorter and it reads
    better.
  prefs: []
  type: TYPE_NORMAL
- en: Generator expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now talk about the other techniques to generate values one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax is exactly the same as `list` comprehensions, only, instead of wrapping
    the comprehension with square brackets, you wrap it with round brackets. That
    is called a **generator expression**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, generator expressions behave like equivalent `list` comprehensions,
    but there is one very important thing to remember: generators allow for one iteration
    only, then they will be exhausted. Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Look at the line in which the generator expression is created and assigned the
    name `cubes_gen`. You can see it's a generator object. In order to see its elements,
    we can use a `for` loop, a manual set of calls to `next`, or simply, feed it to
    a `list` constructor, which is what I did (remember I'm using `_` as an alias).
  prefs: []
  type: TYPE_NORMAL
- en: Notice how, once the generator has been exhausted, there is no way to recover
    the same elements from it again. We need to recreate it if we want to use it from
    scratch again.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next few examples, let''s see how to reproduce `map` and `filter` using
    generator expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, `s1` and `s2` are exactly the same: they are the sum
    of `adder(0, 1), adder(1, 2), adder(2, 3)`, and so on, which translates to `sum(1,
    3, 5, ...)`. The syntax is different, though I find the generator expression to
    be much more readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, `odd_cubes1` and `odd_cubes2` are the same: they generate
    a sequence of odd cubes. Yet again, I prefer the generator syntax. This should
    be evident when things get a little more complicated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code creates two generators, `cubes1` and `cubes2`. They are exactly
    the same, and return two-tuples (*n, n³*) when `n` is a multiple of `3` or `5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you print the list (`cubes1`), you get: `[(0, 0), (3, 27), (5, 125), (6,
    216), (9, 729), (10, 1000), (12, 1728), (15, 3375), (18, 5832)]`.'
  prefs: []
  type: TYPE_NORMAL
- en: See how much better the generator expression reads? It may be debatable when
    things are very simple, but as soon as you start nesting functions a bit, like
    we did in this example, the superiority of the generator syntax is evident. It's
    shorter, simpler, and more elegant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let me ask you a question—what is the difference between the following
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Strictly speaking, they all produce the same sum. The expressions to get `s2`
    and `s3` are exactly the same because the brackets in `s2` are redundant. They
    are both generator expressions inside the `sum` function. The expression to get
    `s1` is different though. Inside `sum`, we find a `list` comprehension. This means
    that in order to calculate `s1`, the `sum` function has to call `next` on a list
    a million times.
  prefs: []
  type: TYPE_NORMAL
- en: Do you see where we're losing time and memory? Before `sum` can start calling
    `next` on that list, the list needs to have been created, which is a waste of
    time and space. It's much better for `sum` to call `next` on a simple generator
    expression. There is no need to have all the numbers from `range(10**6)` stored
    in a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, *watch out for extra parentheses when you write your expressions*: sometimes
    it''s easy to skip over these details, which makes our code very different. If
    you don''t believe me, check out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Try running the preceding example. If I run the first line on my old Linux
    box with 8 GB RAM, this is what I get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, if I comment out the first line, and uncomment the second
    one, this is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Sweet generator expressions. The difference between the two lines is that in
    the first one, a list with the squares of the first hundred million numbers must
    be made before being able to sum them up. That list is huge, and we ran out of
    memory (at least, my box did, if yours doesn't try a bigger number), therefore
    Python kills the process for us. Sad face.
  prefs: []
  type: TYPE_NORMAL
- en: But when we remove the square brackets, we don't have a list any more. The `sum`
    function receives `0`, `1`, `4`, `9`, and so on until the last one, and sums them
    up. No problems, happy face.
  prefs: []
  type: TYPE_NORMAL
- en: Some performance considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, we've seen that we have many different ways to achieve the same result.
    We can use any combination of `map`, `zip`, and `filter`, or choose to go with
    a comprehension, or maybe choose to use a generator, either function or expression.
    We may even decide to go with `for` loops; when the logic to apply to each running
    parameter isn't simple, they may be the best option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other than readability concerns though, let''s talk about performance. When
    it comes to performance, usually there are two factors that play a major role:
    **space** and **time**.'
  prefs: []
  type: TYPE_NORMAL
- en: Space means the size of the memory that a data structure is going to take up.
    The best way to choose is to ask yourself if you really need a list (or tuple)
    or if a simple generator function would work as well. If the answer is yes, go
    with the generator, it'll save a lot of space. The same goes for functions; if
    you don't actually need them to return a list or tuple, then you can transform
    them into generator functions as well.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you will have to use lists (or tuples), for example there are algorithms
    that scan sequences using multiple pointers or maybe they run over the sequence
    more than once. A generator function (or expression) can be iterated over only
    once and then it's exhausted, so in these situations, it wouldn't be the right
    choice.
  prefs: []
  type: TYPE_NORMAL
- en: Time is a bit harder than space because it depends on more variables and therefore
    it isn't possible to state that *X is faster than Y* with absolute certainty for
    all cases. However, based on tests run on Python today, we can say that on average, `map`
    exhibits performances similar to `list` comprehensions and generator expressions,
    while `for` loops are consistently slower.
  prefs: []
  type: TYPE_NORMAL
- en: In order to appreciate the reasoning behind these statements fully, we need
    to understand how Python works, and this is a bit outside the scope of this book,
    as it's too technical in detail. Let's just say that `map` and `list` comprehensions
    run at C-language speed within the interpreter, while a Python `for` loop is run
    as Python bytecode within the Python Virtual Machine, which is often much slower.
  prefs: []
  type: TYPE_NORMAL
- en: There are several different implementations of Python. The original one, and
    still the most common one, is CPython ([https://github.com/python/cpython](https://github.com/python/cpython)),
    which is written in C. C is one of the most powerful and popular programming languages
    still used today.
  prefs: []
  type: TYPE_NORMAL
- en: 'How about we do a small exercise and try to find out whether the claims I made
    are accurate? I will write a small piece of code that collects the results of
    `divmod(a, b)` for a certain set of integer pairs, `(a, b)`. I will use the `time`
    function from the `time` module to calculate the elapsed time of the operations
    that I will perform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we''re creating three lists: `floop`, `compr`, and `gener`.
    Running the code produces the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `list` comprehension runs in ~67% of the time taken by the `for` loop. That's
    impressive. The generator expression came quite close to that, with a good ~77%.
    The reason the generator expression is slower is that we need to feed it to the
    `list()` constructor, and this has a little bit more overhead compared to a sheer
    `list` comprehension. If I didn't have to retain the results of those calculations,
    a generator would probably have been a more suitable option.
  prefs: []
  type: TYPE_NORMAL
- en: An interesting result is to notice that, within the body of the `for` loop,
    we're appending data to a list. This implies that Python does the work, behind
    the scenes, of resizing it every now and then, allocating space for items to be
    appended. I guessed that creating a list of zeros, and simply filling it with
    the results, might have sped up the `for` loop, but I was wrong. Check it for
    yourself, you just need `mx * (mx - 1) // 2` elements to be preallocated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a similar example that compares a `for` loop and a `map` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is conceptually very similar to the previous example. The only thing
    that has changed is that we''re applying the `abs` function instead of the `divmod`
    one, and we have only one loop instead of two nested ones. Execution gives the
    following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'And `map` wins the race: ~62% of the `list` comprehension and ~30% of the `for`
    loop. Take these results with a pinch of salt, as things might be different according
    to various factors, such as OS and Python version. But in general, I think it''s
    safe to say that these results are good enough for having an idea when it comes
    to coding for performance.'
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the case-by-case little differences though, it's quite clear that
    the `for` loop option is the slowest one, so let's see why we still want to use
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Don't overdo comprehensions and generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've seen how powerful `list` comprehensions and generator expressions can
    be. And they are, don't get me wrong, but the feeling that I have when I deal
    with them is that their complexity grows exponentially. The more you try to do
    within a single comprehension or a generator expression, the harder it becomes
    to read, understand, and therefore maintain or change.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you check the Zen of Python again, there are a few lines that I think are
    worth keeping in mind when dealing with optimized code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Comprehensions and generator expressions are more implicit than explicit, can
    be quite difficult to read and understand, and they can be hard to explain. Sometimes
    you have to break them apart using the inside-out technique, to understand what's
    going on.
  prefs: []
  type: TYPE_NORMAL
- en: To give you an example, let's talk a bit more about Pythagorean triples. Just
    to remind you, a Pythagorean triple is a tuple of positive integers (*a*, *b*,
    *c*) such that *a² + b² = c²*.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how to calculate them in the *Filtering a comprehension* section, but
    we did it in a very inefficient way because we were scanning all pairs of numbers
    below a certain threshold, calculating the hypotenuse, and filtering out those
    that were not producing a triple.
  prefs: []
  type: TYPE_NORMAL
- en: A better way to get a list of Pythagorean triples is to generate them directly.
    There are many different formulas you can use to do this, we'll use the **Euclidean
    formula**.
  prefs: []
  type: TYPE_NORMAL
- en: 'This formula says that any triple (*a*, *b*, *c*), where *a = m² - n²*, *b
    = 2mn*, *c = m² + n²*, with *m* and *n* positive integers such that *m > n*, is
    a Pythagorean triple. For example, when *m = 2* and *n = 1*, we find the smallest
    triple: (*3*, *4*, *5*).'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one catch though: consider the triple (*6*, *8*, *10*) that is just
    like (*3*, *4*, *5*) with all the numbers multiplied by *2*. This triple is definitely
    Pythagorean, since *6² + 8² = 10²* , but we can derive it from (*3*, *4*, *5*)
    simply by multiplying each of its elements by *2*. Same goes for (*9*, *12*, *15*),
    (*12*, *16*, *20*), and in general for all the triples that we can write as (*3k*,
    *4k*, *5k*), with k being a positive integer greater than *1*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A triple that cannot be obtained by multiplying the elements of another one
    by some factor, *k*, is called **primitive**. Another way of stating this is:
    if the three elements of a triple are **coprime**, then the triple is primitive.
    Two numbers are coprime when they don''t share any prime factor amongst their
    divisors, that is, their **greatest common divisor** (**GCD**) is *1*. For example,
    3 and 5 are coprime, while 3 and 6 are not, because they are both divisible by
    3.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the Euclidean formula tells us that if *m* and *n* are coprime, and *m
    - n* is odd, the triple they generate is *primitive*. In the following example,
    we will write a generator expression to calculate all the primitive Pythagorean
    triples whose hypotenuse (*c*) is less than or equal to some integer, *N*. This
    means we want all triples for which *m² + n² ≤ N*. When *n* is *1*, the formula
    looks like this: *m² ≤ N - 1*, which means we can approximate the calculation
    with an upper bound of *m ≤ N^(1/2)*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to recap: *m* must be greater than *n*, they must also be coprime, and
    their difference *m - n* must be odd. Moreover, in order to avoid useless calculations,
    we''ll put the upper bound for *m* at *floor(sqrt(N)) + 1*.'
  prefs: []
  type: TYPE_NORMAL
- en: The `floor` function for a real number, *x*, gives the maximum integer, *n*,
    such that *n < x*, for example, *floor(3.8) = 3*, *floor(13.1) = 13*. Taking *floor(sqrt(N))
    + 1* means taking the integer part of the square root of *N* and adding a minimal
    margin just to make sure we don't miss any numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put all of this into code, step by step. Let''s start by writing a simple
    `gcd` function that uses **Euclid''s algorithm**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The explanation of Euclid''s algorithm is available on the web, so I won''t
    spend any time here talking about it; we need to focus on the generator expression.
    The next step is to use the knowledge we gathered before to generate a list of
    primitive Pythagorean triples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: There you go. It's not easy to read, so let's go through it line by line. At
    `#3`, we start a generator expression that is creating triples. You can see from
    `#4` and `#5` that we're looping on `m` in *[1, M]* with *M* being the integer
    part of *sqrt(N)*, plus *1*. On the other hand, `n` loops within *[1, m)*, to
    respect the *m > n* rule. It's worth noting how I calculated *sqrt(N)*, that is,
    `N**.5`, which is just another way to do it that I wanted to show you.
  prefs: []
  type: TYPE_NORMAL
- en: 'At `#6`, you can see the filtering conditions to make the triples primitive:
    `(m - n) % 2` evaluates to `True` when `(m - n)` is odd, and `gcd(m, n) == 1`
    means `m` and `n` are coprime. With these in place, we know the triples will be
    primitive. This takes care of the innermost generator expression. The outermost
    one starts at `#2`, and finishes at `#7`. We take the triples (*a*, *b*, *c*)
    in (...innermost generator...) such that `c <= N`.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, at `#1` we apply sorting, to present the list in order. At `#7`, after
    the outermost generator expression is closed, you can see that we specify the
    sorting key to be the sum *a + b + c*. This is just my personal preference, there
    is no mathematical reason behind it.
  prefs: []
  type: TYPE_NORMAL
- en: So, what do you think? Was it straightforward to read? I don't think so. And
    believe me, this is still a simple example; I have seen much worse in my career.
    This kind of code is difficult to understand, debug, and modify. It shouldn't
    find a place in a professional environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s see if we can rewrite this code into something more readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This is so much better. Let's go through it, line by line. You'll see how much
    easier it is to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start looping at `#1` and `#2`, in exactly the same way we were looping
    in the previous example. On line `#3`, we have the filtering for primitive triples.
    On line `#4`, we deviate a bit from what we were doing before: we calculate `c`,
    and on line `#5`, we filter on `c` being less than or equal to `N`. Only when
    `c` satisfies that condition, we do calculate `a` and `b`, and yield the resulting
    tuple. It''s always good to delay all calculations for as much as possible so
    that we don''t waste time and CPU. On the last line, we apply sorting with the
    same key we were using in the generator expression example.'
  prefs: []
  type: TYPE_NORMAL
- en: I hope you agree, this example is easier to understand. And I promise you, if
    you have to modify the code one day, you'll find that modifying this one is easy,
    while to modify the other version will take much longer (and it will be more error-prone).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you print the results of both examples (they are the same), you will get
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The moral of the story is, try and use comprehensions and generator expressions
    as much as you can, but if the code starts to be complicated to modify or to read,
    you may want to refactor it into something more readable. Your colleagues will
    thank you.
  prefs: []
  type: TYPE_NORMAL
- en: Name localization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we are familiar with all types of comprehensions and generator expression,
    let''s talk about name localization within them. Python 3.* localizes loop variables
    in all four forms of comprehensions: `list`, `dict`, `set`, and generator expressions.
    This behavior is therefore different from that of the `for` loop. Let''s see a
    simple example to show all the cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we declare a global name, `A = 100`, and then we exercise
    the four comprehensions: `list`, generator expression, dictionary, and `set`.
    None of them alter the global name, `A`. Conversely, you can see at the end that
    the `for` loop modifies it. The last print statement prints `4`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens if `A` wasn''t there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code would work the same with any of the four types of comprehensions.
    After we run the first line, `A` is not defined in the global namespace. Once
    again, the `for` loop behaves differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code shows that after a `for` loop, if the loop variable wasn''t
    defined before it, we can find it in the global frame. To make sure of it, let''s
    take a peek at it by calling the `globals()` built-in function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Together with a lot of other boilerplate stuff that I have omitted, we can
    spot `''A'': 4`.'
  prefs: []
  type: TYPE_NORMAL
- en: Generation behavior in built-ins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Among the built-in types, the generation behavior is now quite common. This
    is a major difference between Python 2 and Python 3\. A lot of functions, such
    as `map`, `zip`, and `filter`, have been transformed so that they return objects
    that behave like iterables. The idea behind this change is that if you need to
    make a list of those results, you can always wrap the call in a `list()` class,
    and you're done. On the other hand, if you just need to iterate and want to keep
    the impact on memory as light as possible, you can use those functions safely.
  prefs: []
  type: TYPE_NORMAL
- en: Another notable example is the `range` function. In Python 2 it returns a list,
    and there is another function called `xrange` that returns an object that you
    can iterate on, which generates the numbers on the fly. In Python 3 this function
    has gone, and `range` now behaves like it.
  prefs: []
  type: TYPE_NORMAL
- en: But this concept, in general, is now quite widespread. You can find it in the
    `open()` function, which is used to operate on file objects (we'll see it in [Chapter
    7](part0187.html#5IAP60-2ddb708647cc4530a187c2c6c0e9acfe), *Files and Data Persistence*),
    but also in `enumerate`, in the dictionary `keys`, `values`, and `items` methods,
    and several other places.
  prefs: []
  type: TYPE_NORMAL
- en: 'It all makes sense: Python''s aim is to try to reduce the memory footprint
    by avoiding wasting space wherever possible, especially in those functions and
    methods that are used extensively in most situations.'
  prefs: []
  type: TYPE_NORMAL
- en: Do you remember at the beginning of this chapter? I said that it makes more
    sense to optimize the performances of code that has to deal with a lot of objects,
    rather than shaving off a few milliseconds from a function that we call twice
    a day.
  prefs: []
  type: TYPE_NORMAL
- en: One last example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we finish this chapter, I'll show you a simple problem that I used to
    submit to candidates for a Python developer role in a company I used to work for.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is the following: given the sequence `0 1 1 2 3 5 8 13 21 ...`,
    write a function that would return the terms of this sequence up to some limit, `N`.'
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't recognized it, that is the Fibonacci sequence, which is defined
    as *F(0) = 0*, *F(1) = 1* and, for any *n > 1*, *F(n) = F(n-1) + F(n-2)*. This
    sequence is excellent to test knowledge about recursion, memoization techniques,
    and other technical details, but in this case, it was a good opportunity to check
    whether the candidate knew about generators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start from a rudimentary version of a function, and then improve on
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'From the top: we set up the `result` list to a starting value of `[0]`. Then
    we start the iteration from the next element (`next_n`), which is `1`. While the
    next element is not greater than `N`, we keep appending it to the list and calculating
    the next. We calculate the next element by taking a slice of the last two elements
    in the `result` list and passing it to the `sum` function. Add some `print` statements
    here and there if this is not clear to you, but by now I would expect it not to
    be an issue.'
  prefs: []
  type: TYPE_NORMAL
- en: When the condition of the `while` loop evaluates to `False`, we exit the loop
    and return `result`. You can see the result of those `print` statements in the
    comments next to each of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, I would ask the candidate the following question: *What if I
    just wanted to iterate over those numbers?* A good candidate would then change
    the code to what you''ll find here (an excellent candidate would have started
    with it!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This is actually one of the solutions I was given. I don''t know why I kept
    it, but I''m glad I did so I can show it to you. Now, the `fibonacci` function
    is a *generator function*. First we yield `0`, then if `N` is `0`, we return (this
    will cause a `StopIteration` exception to be raised). If that''s not the case,
    we start iterating, yielding `b` at every loop cycle, and then updating `a` and
    `b`. All we need in order to be able to produce the next element of the sequence
    is the past two: `a` and `b`, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code is much better, has a lighter memory footprint and all we have to
    do to get a list of Fibonacci numbers is to wrap the call with `list()`, as usual.
    But what about elegance? I can''t leave it like that, can I? Let''s try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Much better. The whole body of the function is four lines, five if you count
    the docstring. Notice how, in this case, using tuple assignment (`a, b = 0, 1`
    and `a, b = b, a + b`) helps in making the code shorter, and more readable.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the concept of iteration and generation a bit more
    deeply. We looked at the `map`, `zip`, and `filter` functions in detail, and learned
    how to use them as an alternative to a regular `for` loop approach.
  prefs: []
  type: TYPE_NORMAL
- en: Then we covered the concept of comprehensions, for lists, dictionaries, and
    sets. We explored their syntax and how to use them as an alternative to both the
    classic `for` loop approach and also to the use of the `map`, `zip`, and `filter`
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we talked about the concept of generation, in two forms: generator
    functions and expressions. We learned how to save time and space by using generation
    techniques and saw how they can make possible what wouldn''t normally be if we
    used a conventional approach based on lists.'
  prefs: []
  type: TYPE_NORMAL
- en: We talked about performance, and saw that `for` loops are last in terms of speed,
    but they provide the best readability and flexibility to change. On the other
    hand, functions such as `map` and `filter`, and `list` comprehensions, can be
    much faster.
  prefs: []
  type: TYPE_NORMAL
- en: The complexity of the code written using these techniques grows exponentially
    so, in order to favor readability and ease of maintainability, we still need to
    use the classic `for` loop approach at times. Another difference is in the name
    localization, where the `for` loop behaves differently from all other types of
    comprehensions.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will be all about objects and classes. It is structurally similar
    to this one, in that we won't explore many different subjects, just a few of them,
    but we'll try to dive into them a little bit more deeply.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you understand the concepts of this chapter before moving on to the
    next one. We're building a wall brick by brick, and if the foundation is not solid,
    we won't get very far.
  prefs: []
  type: TYPE_NORMAL
