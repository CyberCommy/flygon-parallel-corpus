- en: Saving Time and Memory
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"It''s not the daily increase but daily decrease. Hack away at the unessential."–
    Bruce Lee'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: I love this quote from Bruce Lee. He was such a wise man! Especially, the second
    part, <q class="calibre30">"*hack away at the unessential"*</q>, is to me what
    makes a computer program elegant. After all, if there is a better way of doing
    things so that we don't waste time or memory, why not?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, there are valid reasons for not pushing our code up to the maximum
    limit: for example, sometimes to achieve a negligible improvement, we have to
    sacrifice on readability or maintainability. Does it make any sense to have a
    web page served in 1 second with unreadable, complicated code, when we can serve
    it in 1.05 seconds with readable, clean code? No, it makes no sense.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, sometimes it's perfectly reasonable to try to shave off a
    millisecond from a function, especially when the function is meant to be called
    thousands of times. Every millisecond you save there means one second saved per
    thousands of calls, and this could be meaningful for your application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: In light of these considerations, the focus of this chapter will not be to give
    you the tools to push your code to the absolute limits of performance and optimization
    "no matter what," but rather, to enable you to write efficient, elegant code that
    reads well, runs fast, and doesn't waste resources in an obvious way.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: The map, zip, and filter functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comprehensions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generators
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I will perform several measurements and comparisons, and cautiously draw some
    conclusions. Please do keep in mind that on a different box with a different setup
    or a different operating system, results may vary. Take a look at this code:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Both functions return the square of `n`, but which is faster? From a simple
    benchmark I ran on them, it looks like the second is slightly faster. If you think
    about it, it makes sense: calculating the power of a number involves multiplication
    and therefore, whatever algorithm you may use to perform the power operation,
    it''s not likely to beat a simple multiplication such as the one in `square2`.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Do we care about this result? In most cases, no. If you're coding an e-commerce
    website, chances are you won't ever even need to raise a number to the second
    power, and if you do, it's likely to be a sporadic operation. You don't need to
    concern yourself with saving a fraction of a microsecond on a function you call
    a few times.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: So, when does optimization become important? One very common case is when you
    have to deal with huge collections of data. If you're applying the same function
    on a million `customer` objects, then you want your function to be tuned up to
    its best. Gaining 1/10 of a second on a function called one million times saves
    you 100,000 seconds, which is about 27.7 hours. That's not the same, right? So,
    let's focus on collections, and let's see which tools Python gives you to handle
    them with efficiency and grace.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Many of the concepts we will see in this chapter are based on those of the iterator
    and iterable. Simply put, the ability for an object to return its next element
    when asked, and to raise a `StopIteration` exception when exhausted. We'll see
    how to code a custom iterator and iterable objects in [Chapter 6](part0163.html#4REBM0-2ddb708647cc4530a187c2c6c0e9acfe),
    *OOP, Decorators, and Iterators*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to the nature of the objects we''re going to explore in this chapter, I
    was often forced to wrap the code in a `list` constructor. This is because passing
    an iterator/generator to `list(...)` exhausts it and puts all the generated items
    in a newly created list, which I can easily print to show you its content. This
    technique hinders readability, so let me introduce an alias for list:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Of the three sections I have highlighted, the first one is the call we need
    to do in order to show what would be generated by `range(7)`, the second one is
    the moment when I create the alias to list (I chose the hopefully unobtrusive
    underscore), and the third one is the equivalent call, when I use the alias instead
    of list.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经突出显示的三个部分中，第一个是我们需要执行的调用，以便显示`range(7)`生成的内容，第二个是我创建别名到`list`的时刻（我选择了希望不引人注目的下划线），第三个是等效的调用，当我使用别名而不是`list`时。
- en: Hopefully readability will benefit from this, and please keep in mind that I
    will assume this alias to have been defined for all the code in this chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这样做可以提高可读性，请记住，我将假设这个别名已经在本章的所有代码中定义了。
- en: The map, zip, and filter functions
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: map、zip和filter函数
- en: 'We''ll start by reviewing `map`, `filter`, and `zip`, which are the main built-in
    functions one can employ when handling collections, and then we''ll learn how
    to achieve the same results using two very important constructs: **comprehensions**
    and **generators**. Fasten your seatbelt!'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从回顾`map`、`filter`和`zip`开始，这些是处理集合时可以使用的主要内置函数，然后我们将学习如何使用两个非常重要的构造来实现相同的结果：**推导**和**生成器**。系好安全带！
- en: map
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地图
- en: 'According to the official Python documentation:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 根据官方Python文档：
- en: map(function, iterable, ...) returns an iterator that applies function to every
    item of iterable, yielding the results. If additional iterable arguments are passed,
    function must take that many arguments and is applied to the items from all iterables
    in parallel. With multiple iterables, the iterator stops when the shortest iterable
    is exhausted.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: map(function, iterable, ...)返回一个迭代器，它将函数应用于可迭代对象的每个项目，产生结果。如果传递了额外的可迭代参数，函数必须接受相同数量的参数，并且会并行应用于所有可迭代对象的项目。对于多个可迭代对象，当最短的可迭代对象耗尽时，迭代器会停止。
- en: 'We will explain the concept of yielding later on in the chapter. For now, let''s
    translate this into code—we''ll use a `lambda` function that takes a variable
    number of positional arguments, and just returns them as a tuple:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面解释yielding的概念。现在，让我们将其翻译成代码——我们将使用一个接受可变数量的位置参数的`lambda`函数，并将它们返回为一个元组：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, you can see why we have to wrap calls in `list(...)`
    (or its alias, `_`, in this case). Without it, I get the string representation
    of a `map` object, which is not really useful in this context, is it?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你可以看到为什么我们必须用`list(...)`（或者在这种情况下使用它的别名`_`）来包装调用。没有它，我会得到一个`map`对象的字符串表示，这在这种情况下并不真正有用，是吗？
- en: You can also notice how the elements of each iterable are applied to the function;
    at first, the first element of each iterable, then the second one of each iterable,
    and so on. Notice also that `map` stops when the shortest of the iterables we
    called it with is exhausted. This is actually a very nice behavior; it doesn't
    force us to level off all the iterables to a common length, and it doesn't break
    if they aren't all the same length.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以注意到每个可迭代对象的元素是如何应用于函数的；首先是每个可迭代对象的第一个元素，然后是每个可迭代对象的第二个元素，依此类推。还要注意，`map`在我们调用它的可迭代对象中最短的一个耗尽时停止。这实际上是一种非常好的行为；它不强迫我们将所有可迭代对象平齐到一个公共长度，并且如果它们的长度不相同时也不会中断。
- en: '`map` is very useful when you have to apply the same function to one or more
    collections of objects. As a more interesting example, let''s see the **decorate-sort-undecorate**
    idiom (also known as **Schwartzian transform**). It''s a technique that was extremely
    popular when Python sorting wasn''t providing *key-functions*, and therefore is
    less used today, but it''s a cool trick that still comes in handy once in a while.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当你必须将相同的函数应用于一个或多个对象集合时，`map`非常有用。作为一个更有趣的例子，让我们看看**装饰-排序-解除装饰**惯用法（也称为**Schwartzian
    transform**）。这是一种在Python排序没有提供*key-functions*时非常流行的技术，因此今天使用较少，但偶尔还是会派上用场的一个很酷的技巧。
- en: 'Let''s see a variation of it in the next example: we want to sort in descending
    order by the sum of credits accumulated by students, so to have the best student
    at position 0\. We write a function to produce a decorated object, we sort, and
    then we undecorate. Each student has credits in three (possibly different) subjects.
    In this context, to decorate an object means to transform it, either adding extra
    data to it, or putting it into another object, in a way that allows us to be able
    to sort the original objects the way we want. This technique has nothing to do
    with Python decorators, which we will explore later on in the book.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一个例子中看一个变体：我们想按照学生所累积的学分总和降序排序，以便将最好的学生放在位置0。我们编写一个函数来生成一个装饰对象，然后进行排序，然后进行undecorate。每个学生在三个（可能不同的）科目中都有学分。在这种情况下，装饰对象意味着以一种允许我们按照我们想要的方式对原始对象进行排序的方式来转换它，无论是向其添加额外数据，还是将其放入另一个对象中。这种技术与Python装饰器无关，我们将在本书后面探讨。
- en: 'After the sorting, we revert the decorated objects to get the original ones
    from them. This is called to undecorate:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在排序之后，我们将装饰的对象恢复为它们的原始对象。这被称为undecorate：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s start by understanding what each student object is. In fact, let''s
    print the first one:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先了解每个学生对象是什么。实际上，让我们打印第一个：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can see that it''s a dictionary with two keys: `id` and `credits`. The
    value of `credits` is also a dictionary in which there are three subject/grade
    key/value pairs. As I''m sure you recall from our visit in the data structures
    world, calling `dict.values()` returns an object similar to `iterable`, with only
    the values. Therefore, `sum(student[''credits''].values())` for the first student
    is equivalent to `sum((9, 6, 7))`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到它是一个具有两个键的字典：`id`和`credits`。`credits`的值也是一个字典，在其中有三个科目/成绩键/值对。正如你在数据结构世界中所记得的，调用`dict.values()`会返回一个类似于`iterable`的对象，只有值。因此，第一个学生的`sum(student['credits'].values())`等同于`sum((9,
    6, 7))`。
- en: 'Let''s print the result of calling decorate with the first student:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打印调用decorate与第一个学生的结果：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If we decorate all the students like this, we can sort them on their total amount
    of credits by just sorting the list of tuples. In order to apply the decoration
    to each item in students, we call `map(decorate, students)`. Then we sort the
    result, and then we undecorate in a similar fashion. If you have gone through
    the previous chapters correctly, understanding this code shouldn't be too hard.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'Printing students after running the whole code yields:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: And you can see, by the order of the student objects, that they have indeed
    been sorted by the sum of their credits.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: For more on the *decorate-sort-undecorate* idiom, there's a very nice introduction
    in the sorting how-to section of the official Python documentation ([https://docs.python.org/3.7/howto/sorting.html#the-old-way-using-decorate-sort-undecorate](https://docs.python.org/3.7/howto/sorting.html#the-old-way-using-decorate-sort-undecorate)).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing to notice about the sorting part: what if two or more students share
    the same total sum? The sorting algorithm would then proceed to sort the tuples
    by comparing the `student` objects with each other. This doesn''t make any sense,
    and in more complex cases, could lead to unpredictable results, or even errors.
    If you want to be sure to avoid this issue, one simple solution is to create a
    three-tuple instead of a two-tuple, having the sum of credits in the first position,
    the position of the `student` object in the `students` list in the second one,
    and the `student` object itself in the third one. This way, if the sum of credits
    is the same, the tuples will be sorted against the position, which will always
    be different and therefore enough to resolve the sorting between any pair of tuples.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: zip
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already covered `zip` in the previous chapters, so let's just define it
    properly and then I want to show you how you could combine it with `map`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the Python documentation:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: zip(*iterables) returns an iterator of tuples, where the i-th tuple contains
    the i-th element from each of the argument sequences or iterables. The iterator
    stops when the shortest input iterable is exhausted. With a single iterable argument,
    it returns an iterator of 1-tuples. With no arguments, it returns an empty iterator.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we're zipping together the average and the grade for
    the last exam, for each student. Notice how easy it is to reproduce `zip` using
    `map` (last two instructions of the example). Here as well, to visualize results
    we have to use our `_` alias.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple example on the combined use of `map` and `zip` could be a way of calculating
    the element-wise maximum amongst sequences, that is, the maximum of the first
    element of each sequence, then the maximum of the second one, and so on:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice how easy it is to calculate the max values of three sequences. `zip`
    is not strictly needed of course, we could just use `map`. Sometimes it's hard,
    when showing a simple example, to grasp why using a technique might be good or
    bad. We forget that we aren't always in control of the source code, we might have
    to use a third-party library, which we can't change the way we want. Having different
    ways to work with data is therefore really helpful.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: filter
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'According to the Python documentation:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: filter(function, iterable) construct an iterator from those elements of iterable
    for which function returns True. iterable may be either a sequence, a container
    which supports iteration, or an iterator. If function is None, the identity function
    is assumed, that is, all elements of iterable that are false are removed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a very quick example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code, notice how the second call to `filter` is equivalent
    to the first one. If we pass a function that takes one argument and returns the
    argument itself, only those arguments that are `True` will make the function return
    `True`, therefore this behavior is exactly the same as passing `None`. It's often
    a very good exercise to mimic some of the built-in Python behaviors. When you
    succeed, you can say you fully understand how Python behaves in a specific situation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，注意第二次调用`filter`等同于第一次调用。如果我们传递一个接受一个参数并返回参数本身的函数，只有那些为`True`的参数才会使函数返回`True`，因此这种行为与传递`None`完全相同。模仿一些内置的Python行为通常是一个很好的练习。当你成功时，你可以说你完全理解了Python在特定情况下的行为。
- en: 'Armed with `map`, `zip`, and `filter` (and several other functions from the
    Python standard library) we can massage sequences very effectively. But those
    functions are not the only way to do it. So let''s see one of the nicest features
    of Python: comprehensions.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`map`，`zip`和`filter`（以及Python标准库中的其他几个函数），我们可以非常有效地处理序列。但这些函数并不是唯一的方法。所以让我们看看Python最好的特性之一：推导。
- en: Comprehensions
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推导
- en: Comprehensions are a concise notation, both perform some operation for a collection
    of elements, and/or select a subset of them that meet some condition. They are
    borrowed from the functional programming language Haskell ([https://www.haskell.org/](https://www.haskell.org/)),
    and contribute to giving Python a functional flavor, together with iterators and
    generators.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 推导是一种简洁的表示法，既对一组元素执行某些操作，又/或选择满足某些条件的子集。它们借鉴自函数式编程语言Haskell（[https://www.haskell.org/](https://www.haskell.org/)），并且与迭代器和生成器一起为Python增添了函数式风味。
- en: 'Python offers you different types of comprehensions: `list`, `dict`, and `set`.
    We''ll concentrate on the first one for now, and then it will be easy to explain
    the other two.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Python为您提供不同类型的推导：`list`，`dict`和`set`。我们现在将集中在第一个上，然后解释另外两个将会很容易。
- en: 'Let''s start with a very simple example. I want to calculate a list with the
    squares of the first 10 natural numbers. How would you do it? There are a couple
    of equivalent ways:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个非常简单的例子开始。我想计算一个包含前10个自然数的平方的列表。你会怎么做？有几种等效的方法：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding example should be nothing new for you. Let''s see how to achieve
    the same result using a `list` comprehension:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子对你来说应该不是什么新鲜事。让我们看看如何使用`list`推导来实现相同的结果：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As simple as that. Isn''t it elegant? Basically we have put a `for` loop within
    square brackets. Let''s now filter out the odd squares. I''ll show you how to
    do it with `map` and `filter` first, and then using a `list` comprehension again:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这么简单。是不是很优雅？基本上我们在方括号内放了一个`for`循环。现在让我们过滤掉奇数平方。我将首先向你展示如何使用`map`和`filter`，然后再次使用`list`推导：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'I think that now the difference in readability is evident. The `list` comprehension
    reads much better. It''s almost English: give me all squares (`n ** 2`) for `n`
    between `0` and `9` if `n` is even.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为现在可读性的差异是明显的。列表推导读起来好多了。它几乎是英语：如果n是偶数，给我所有0到9之间的n的平方（n ** 2）。
- en: 'According to the Python documentation:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Python文档：
- en: A list comprehension consists of brackets containing an expression followed
    by a for clause, then zero or more for or if clauses. The result will be a new
    list resulting from evaluating the expression in the context of the for and if
    clauses which follow it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导由包含表达式的括号组成，后面跟着一个for子句，然后是零个或多个for或if子句。结果将是一个新列表，由在for和if子句的上下文中评估表达式得出。
- en: Nested comprehensions
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套推导
- en: 'Let''s see an example of nested loops. It''s very common when dealing with
    algorithms to have to iterate on a sequence using two placeholders. The first
    one runs through the whole sequence, left to right. The second one as well, but
    it starts from the first one, instead of 0\. The concept is that of testing all
    pairs without duplication. Let''s see the classical `for` loop equivalent:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个嵌套循环的例子。在处理算法时，经常需要使用两个占位符对序列进行迭代是很常见的。第一个占位符从左到右遍历整个序列。第二个也是如此，但它从第一个开始，而不是从0开始。这个概念是为了测试所有对而不重复。让我们看看经典的`for`循环等价：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you print pairs at the end, you get:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在最后打印出对，你会得到：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'All the tuples with the same letter are those where `b` is at the same position
    as `a`. Now, let''s see how we can translate this in a `list` comprehension:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 所有具有相同字母的元组都是`b`与`a`处于相同位置的元组。现在，让我们看看如何将其转换为`list`推导：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This version is just two lines long and achieves the same result. Notice that
    in this particular case, because the `for` loop over `b` has a dependency on `a`,
    it must follow the `for` loop over `a` in the comprehension. If you swap them
    around, you'll get a name error.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本只有两行长，但实现了相同的结果。请注意，在这种特殊情况下，因为`for`循环在`b`上有一个对`a`的依赖，所以它必须在推导中跟在`a`上的`for`循环之后。如果你交换它们，你会得到一个名称错误。
- en: Filtering a comprehension
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤推导
- en: 'We can apply filtering to a comprehension. Let''s do it first with `filter`.
    Let''s find all Pythagorean triples whose short sides are numbers smaller than
    10\. We obviously don''t want to test a combination twice, and therefore we''ll
    use a trick similar to the one we saw in the previous example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对推导应用过滤。让我们首先用`filter`来做。让我们找出所有勾股数的短边小于10的三元组。显然，我们不想测试两次组合，因此我们将使用与我们在上一个例子中看到的类似的技巧：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A **Pythagorean triple** is a triple (*a*, *b*, *c*) of integer numbers satisfying the
    equation *a² + b² = c²*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 勾股数是满足整数方程a² + b² = c²的整数三元组（a，b，c）。
- en: In the preceding code, we generated a list of *three-tuples*, `triples`. Each
    tuple contains two integer numbers (the legs), and the hypotenuse of the Pythagorean
    triangle whose legs are the first two numbers in the tuple. For example, when
    `a` is `3` and `b` is `4`, the tuple will be `(3, 4, 5.0)`, and when `a` is `5`
    and `b` is `7`, the tuple will be `(5, 7, 8.602325267042627)`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: After having all the `triples` done, we need to filter out all those that don't
    have a hypotenuse that is an integer number. In order to do this, we filter based
    on `float_number.is_integer()` being `True`. This means that of the two example
    tuples I showed you before, the one with `5.0` hypotenuse will be retained, while
    the one with the `8.602325267042627` hypotenuse will be discarded.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'This is good, but I don''t like that the triple has two integer numbers and
    a float. They are supposed to be all integers, so let''s use `map` to fix this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Notice the step we added. We take each element in `triples` and we slice it,
    taking only the first two elements in it. Then, we concatenate the slice with
    a one-tuple, in which we put the integer version of that float number that we
    didn''t like. Seems like a lot of work, right? Indeed it is. Let''s see how to
    do all this with a `list` comprehension:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: I know. It's much better, isn't it? It's clean, readable, shorter. In other
    words, it's elegant.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: I'm going quite fast here, as anticipated in the *Summary* of [Chapter 4](part0108.html#36VSO0-2ddb708647cc4530a187c2c6c0e9acfe), *Functions,
    the Building Blocks of Code*. Are you playing with this code? If not, I suggest
    you do. It's very important that you play around, break things, change things,
    see what happens. Make sure you have a clear understanding of what is going on.
    You want to become a ninja, right?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: dict comprehensions
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dictionary and `set` comprehensions work exactly like the list ones, only there
    is a little difference in the syntax. The following example will suffice to explain
    everything you need to know:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you print `lettermap`, you will see the following (I omitted the middle
    results, you get the gist):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'What happens in the preceding code is that we''re feeding the `dict` constructor
    with a comprehension (technically, a generator expression, we''ll see it in a
    bit). We tell the `dict` constructor to make *key*/*value* pairs from each tuple
    in the comprehension. We enumerate the sequence of all lowercase ASCII letters,
    starting from `1`, using `enumerate`. Piece of cake. There is also another way
    to do the same thing, which is closer to the other dictionary syntax:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'It does exactly the same thing, with a slightly different syntax that highlights
    a bit more of the *key: value* part.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Dictionaries do not allow duplication in the keys, as shown in the following
    example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We create a dictionary with keys, the letters in the `''Hello''` string, and
    values of the same letters, but with the case swapped. Notice there is only one
    `''l'': ''L''` pair. The constructor doesn''t complain, it simply reassigns duplicates
    to the latest value. Let''s make this clearer with another example; let''s assign
    to each key its position in the string:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Notice the value associated with the letter `''l'': 3`. The `''l'': 2` pair
    isn''t there; it has been overridden by `''l'': 3`.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: set comprehensions
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `set` comprehensions are very similar to list and dictionary ones. Python
    allows both the `set()` constructor to be used, or the explicit `{}` syntax. Let''s
    see one quick example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice how for `set` comprehensions, as for dictionaries, duplication is not
    allowed and therefore the resulting set has only four letters. Also, notice that
    the expressions assigned to `letters1` and `letters2` produce equivalent sets.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: The syntax used to create `letters2` is very similar to the one we can use to
    create a dictionary comprehension. You can spot the difference only by the fact
    that dictionaries require keys and values, separated by columns, while sets don't.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Generators
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Generators** are very powerful tool that Python gifts us with. They are based
    on the concepts of *iteration*, as we said before, and they allow for coding patterns
    that combine elegance with efficiency.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**生成器**是Python赋予我们的非常强大的工具。它们基于*迭代*的概念，正如我们之前所说的，它们允许结合优雅和高效的编码模式。'
- en: 'Generators are of two types:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器有两种类型：
- en: '**Generator functions**: These are very similar to regular functions, but instead
    of returning results through return statements, they use yield, which allows them
    to suspend and resume their state between each call'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成器函数**：这些与常规函数非常相似，但是它们不是通过返回语句返回结果，而是使用yield，这使它们能够在每次调用之间暂停和恢复它们的状态。'
- en: '**Generator expressions**: These are very similar to the `list` comprehensions
    we''ve seen in this chapter, but instead of returning a list they return an object
    that produces results one by one'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成器表达式**：这些与我们在本章中看到的`list`推导非常相似，但是它们不是返回一个列表，而是返回一个逐个产生结果的对象。'
- en: Generator functions
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器函数
- en: Generator functions behave like regular functions in all respects, except for
    one difference. Instead of collecting results and returning them at once, they
    are automatically turned into iterators that yield results one at a time when
    you call `next` on them. Generator functions are automatically turned into their
    own iterators by Python.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器函数在所有方面都像常规函数一样，只有一个区别。它们不是一次性收集结果并返回它们，而是在每次调用`next`时自动转换为产生结果的迭代器。
- en: This is all very theoretical so, let's make it clear why such a mechanism is
    so powerful, and then let's see an example.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都是非常理论的，所以让我们清楚地说明为什么这样的机制是如此强大，然后让我们看一个例子。
- en: Say I asked you to count out loud from 1 to 1,000,000\. You start, and at some
    point I ask you to stop. After some time, I ask you to resume. At this point,
    what is the minimum information you need to be able to resume correctly? Well,
    you need to remember the last number you called. If I stopped you after 31,415,
    you will just go on with 31,416, and so on.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我让你大声数数从1数到1,000,000。你开始了，然后在某个时候我让你停下来。过了一段时间，我让你继续。在这一点上，你需要记住能够正确恢复的最小信息是什么？嗯，你需要记住你最后一个叫的数字。如果我在31,415后停止了你，你就会继续31,416，依此类推。
- en: The point is, you don't need to remember all the numbers you said before 31,415,
    nor do you need them to be written down somewhere. Well, you may not know it,
    but you're behaving like a generator already!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 重点是，你不需要记住31,415之前说的所有数字，也不需要它们被写在某个地方。嗯，你可能不知道，但你已经像一个生成器一样行为了！
- en: 'Take a good look at the following code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看一下以下代码：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The result of the two `print` statements will be the same: `[0, 1, 4, 9, 16,
    25, 36, 49, 64, 81]`. But there is a huge difference between the two functions.
    `get_squares` is a classic function that collects all the squares of numbers in
    [0, *n*) in a list, and returns it. On the other hand, `get_squares_gen` is a
    generator, and behaves very differently. Each time the interpreter reaches the
    `yield` line, its execution is suspended. The only reason those `print` statements
    return the same result is because we fed `get_squares_gen` to the `list` constructor,
    which exhausts the generator completely by asking the next element until a `StopIteration`
    is raised. Let''s see this in detail:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 两个`print`语句的结果将是相同的：`[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]`。但是这两个函数之间有很大的区别。`get_squares`是一个经典函数，它收集[0，*n*)范围内所有数字的平方，并将其返回为列表。另一方面，`get_squares_gen`是一个生成器，行为非常不同。每当解释器到达`yield`行时，它的执行就会被暂停。这些`print`语句返回相同结果的唯一原因是因为我们将`get_squares_gen`传递给`list`构造函数，它通过请求下一个元素直到引发`StopIteration`来完全耗尽生成器。让我们详细看一下：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding code, each time we call `next` on the generator object, we
    either start it (first `next`) or make it resume from the last suspension point
    (any other `next`).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，每次我们在生成器对象上调用`next`时，要么启动它（第一个`next`），要么使它从上次暂停的地方恢复（任何其他`next`）。
- en: The first time we call `next` on it, we get `0`, which is the square of `0`,
    then `1`, then `4`, then `9`, and since the `for` loop stops after that (`n` is
    `4`), then the generator naturally ends. A classic function would at that point
    just return `None`, but in order to comply with the iteration protocol, a generator
    will instead raise a `StopIteration` exception.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次在它上面调用`next`时，我们得到`0`，这是`0`的平方，然后是`1`，然后是`4`，然后是`9`，由于`for`循环在那之后停止了（`n`是`4`），然后生成器自然结束了。经典函数在那一点上只会返回`None`，但为了符合迭代协议，生成器将会引发`StopIteration`异常。
- en: This explains how a `for` loop works. When you call `for k in range(n)`, what
    happens under the hood is that the `for` loop gets an iterator out of `range(n)`
    and starts calling `next` on it, until `StopIteration` is raised, which tells
    the `for` loop that the iteration has reached its end.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这解释了`for`循环的工作原理。当你调用`for k in range(n)`时，在幕后发生的是`for`循环从`range(n)`中获取一个迭代器，并开始在其上调用`next`，直到引发`StopIteration`，这告诉`for`循环迭代已经结束。
- en: Having this behavior built into every iteration aspect of Python makes generators
    even more powerful because once we write them, we'll be able to plug them into
    whatever iteration mechanism we want.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Python的每个迭代方面内置了这种行为，这使得生成器更加强大，因为一旦我们编写它们，我们就能够将它们插入到我们想要的任何迭代机制中。
- en: 'At this point, you''re probably asking yourself why you would want to use a
    generator instead of a regular function. Well, the title of this chapter should
    suggest the answer. I''ll talk about performances later, so for now let''s concentrate
    on another aspect: sometimes generators allow you to do something that wouldn''t
    be possible with a simple list. For example, say you want to analyze all permutations
    of a sequence. If the sequence has a length of *N*, then the number of its permutations
    is *N!*. This means that if the sequence is 10 elements long, the number of permutations
    is 3,628,800\. But a sequence of 20 elements would have 2,432,902,008,176,640,000
    permutations. They grow factorially.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你可能会问自己为什么要使用生成器而不是普通函数。好吧，本章的标题应该暗示了答案。稍后我会谈论性能，所以现在让我们集中在另一个方面：有时生成器允许你做一些用简单列表无法做到的事情。例如，假设你想分析一个序列的所有排列。如果序列的长度为*N*，那么它的排列数就是*N!*。这意味着如果序列长度为10个元素，排列数就是3,628,800。但是20个元素的序列将有2,432,902,008,176,640,000个排列。它们呈阶乘增长。
- en: Now imagine you have a classic function that is attempting to calculate all
    permutations, put them in a list, and return it to you. With 10 elements, it would
    require probably a few dozen seconds, but for 20 elements there is simply no way
    that it can be done.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，你有一个经典函数，它试图计算所有的排列，把它们放在一个列表中，并返回给你。对于10个元素，可能需要几十秒，但对于20个元素，根本不可能完成。
- en: On the other hand, a generator function will be able to start the computation
    and give you back the first permutation, then the second, and so on. Of course
    you won't have the time to parse them all, there are too many, but at least you'll
    be able to work with some of them.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，一个生成器函数将能够开始计算并返回第一个排列，然后是第二个，依此类推。当然你没有时间解析它们所有，因为太多了，但至少你能够处理其中的一些。
- en: Remember when we were talking about the `break` statement in `for` loops? When
    we found a number dividing a *candidate prime* we were breaking the loop, and
    there was no need to go on.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们在谈论`for`循环中的`break`语句吗？当我们找到一个能整除*候选素数*的数时，我们就打破了循环，没有必要继续下去了。
- en: 'Sometimes it''s exactly the same, only the amount of data you have to iterate
    over is so huge that you cannot keep it all in memory in a list. In this case,
    generators are invaluable: they make possible what wouldn''t be possible otherwise.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有时情况完全相同，只是你需要迭代的数据量太大，无法将其全部保存在列表中。在这种情况下，生成器是非常宝贵的：它们使得原本不可能的事情成为可能。
- en: So, in order to save memory (and time), use generator functions whenever possible.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了节省内存（和时间），尽可能使用生成器函数。
- en: 'It''s also worth noting that you can use the return statement in a generator
    function. It will produce a `StopIteration` exception to be raised, effectively
    ending the iteration. This is extremely important. If a `return` statement were
    actually to make the function return something, it would break the iteration protocol.
    Python''s consistency prevents this, and allows us great ease when coding. Let''s
    see a quick example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，你可以在生成器函数中使用return语句。它将产生一个`StopIteration`异常被引发，有效地结束迭代。这是非常重要的。如果`return`语句实际上使函数返回了什么东西，它将打破迭代协议。Python的一致性防止了这种情况，并且在编码时为我们提供了极大的便利。让我们看一个快速的例子：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The preceding code yields all terms of the geometric progression, *a*, *aq*,
    *aq²*, *aq³*, .... When the progression produces a term that is greater than `100000`,
    the generator stops (with a `return` statement). Running the code produces the
    following result:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码产生了等比级数的所有项，*a*，*aq*，*aq²*，*aq³*，.... 当级数产生一个大于`100000`的项时，生成器就会停止（使用`return`语句）。
    运行代码会产生以下结果：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The next term would have been `156250`, which is too big.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个项本来会是`156250`，这太大了。
- en: Speaking about `StopIteration`, as of Python 3.5, the way that exceptions are
    handled in generators has changed. To understand the implications of the change
    is probably asking too much of you at this point, so just know that you can read
    all about it in PEP 479 ([https://legacy.python.org/dev/peps/pep-0479/](https://legacy.python.org/dev/peps/pep-0479/)).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 说到`StopIteration`，从Python 3.5开始，生成器中异常处理的方式已经发生了变化。在这一点上理解这种变化的影响可能要求你付出太多，所以只需知道你可以在PEP
    479中阅读有关它的所有内容即可（[https://legacy.python.org/dev/peps/pep-0479/](https://legacy.python.org/dev/peps/pep-0479/)）。
- en: Going beyond next
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超越next
- en: At the beginning of this chapter, I told you that generator objects are based
    on the iteration protocol. We'll see in [Chapter 6](part0163.html#4REBM0-2ddb708647cc4530a187c2c6c0e9acfe), *OOP,
    Decorators, and Iterators* a complete example of how to write a custom iterator/iterable
    object. For now, I just want you to understand how `next()` works.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我告诉过你生成器对象是基于迭代协议的。我们将在[第6章](part0163.html#4REBM0-2ddb708647cc4530a187c2c6c0e9acfe)中看到一个完整的例子，说明如何编写自定义的迭代器/可迭代对象。现在，我只是希望你理解`next()`是如何工作的。
- en: What happens when you call `next(generator)` is that you're calling the `generator.__next__()`
    method. Remember, a **method** is just a function that belongs to an object, and
    objects in Python can have special methods. `__next__()` is just one of these
    and its purpose is to return the next element of the iteration, or to raise `StopIteration`
    when the iteration is over and there are no more elements to return.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用`next(generator)`时，你调用了`generator.__next__()`方法。记住，**方法**只是属于对象的函数，而Python中的对象可以有特殊的方法。`__next__()`只是其中之一，它的目的是返回迭代的下一个元素，或者在迭代结束时引发`StopIteration`，并且没有更多的元素可以返回。
- en: If you recall, in Python, an object's special methods are also called **magic
    methods**, or **dunder** (from "double underscore") **methods**.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，在Python中，对象的特殊方法也被称为**魔术方法**，或者**dunder**（来自“双下划线”）**方法**。
- en: 'When we write a generator function, Python automatically transforms it into
    an object that is very similar to an iterator, and when we call `next(generator)`,
    that call is transformed in `generator.__next__()`. Let''s revisit the previous
    example about generating squares:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The result is exactly as the previous example, only this time instead of using
    the `next(squares)` proxy call, we're directly calling `squares.__next__()`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'Generator objects have also three other methods that allow us to control their
    behavior: `send`, `throw`, and `close`. `send` allows us to communicate a value
    back to the generator object, while `throw` and `close`, respectively, allow us
    to raise an exception within the generator and close it. Their use is quite advanced
    and I won''t be covering them here in detail, but I want to spend a few words
    on `send`, with a simple example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The preceding iterator creates a generator object that will run forever. You
    can keep calling it, and it will never stop. Alternatively, you can put it in
    a `for` loop, for example, `for n in counter(): ...`, and it will go on forever
    as well. But what if you wanted to stop it at some point? One solution is to use
    a variable to control the `while` loop. Something such as this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This will do it. We start with `stop = False`, and until we change it to `True`,
    the generator will just keep going, like before. The moment we change stop to
    `True` though, the `while` loop will exit, and the next call will raise a `StopIteration`
    exception. This trick works, but I don''t like it. We depend on an external variable,
    and this can lead to issues: what if another function changes that `stop`? Moreover,
    the code is scattered. In a nutshell, this isn''t good enough.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make it better by using `generator.send()`. When we call `generator.send()`,
    the value that we feed to `send` will be passed in to the generator, execution
    is resumed, and we can fetch it via the `yield` expression. This is all very complicated
    when explained with words, so let''s see an example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Execution of the preceding code produces the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: I think it's worth going through this code line by line, like if we were executing
    it, to see whether we can understand what's going on.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: We start the generator execution with a call to `next` (`#C`). Within the generator,
    `n` is set to the same value as `start`. The `while` loop is entered, execution
    stops (`#A`) and `n` (`0`) is yielded back to the caller. `0` is printed on the
    console.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: We then call `send` (`#D`), execution resumes, and `result` is set to `'Wow!'`
    (still `#A`), then its type and value are printed on the console (`#B`). `result`
    is not `'Q'`, therefore `n` is incremented by `1` and execution goes back to the
    `while` condition, which, being `True`, evaluates to `True` (that wasn't hard
    to guess, right?). Another loop cycle begins, execution stops again (`#A`), and
    `n` (`1`) is yielded back to the caller. `1` is printed on the console.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we call `next` (`#E`), execution is resumed again (`#A`), and
    because we are not sending anything to the generator explicitly, Python behaves
    exactly like functions that are not using the `return` statement; the `yield n`
    expression (`#A`) returns `None`. `result` therefore is set to `None`, and its
    type and value are yet again printed on the console (`#B`). Execution continues,
    `result` is not `'Q'` so `n` is incremented by `1`, and we start another loop
    again. Execution stops again (`#A`) and `n` (`2`) is yielded back to the caller.
    `2` is printed on the console.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'And now for the grand finale: we call `send` again (`#F`), but this time we
    pass in `''Q''`, therefore when execution is resumed, `result` is set to `''Q''`
    (`#A`). Its type and value are printed on the console (`#B`), and then finally
    the `if` clause evaluates to `True` and the `while` loop is stopped by the `break`
    statement. The generator naturally terminates, which means a `StopIteration` exception
    is raised. You can see the print of its traceback on the last few lines printed
    on the console.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: This is not at all simple to understand at first, so if it's not clear to you,
    don't be discouraged. You can keep reading on and then you can come back to this
    example after some time.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Using `send` allows for interesting patterns, and it's worth noting that `send`
    can also be used to start the execution of a generator (provided you call it with `None`).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: The yield from expression
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another interesting construct is the `yield from` expression. This expression
    allows you to yield values from a sub iterator. Its use allows for quite advanced
    patterns, so let''s just see a very quick example of it:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The previous code prints the numbers `4`, `9`, `16` on the console (on separate
    lines). By now, I expect you to be able to understand it by yourself, but let''s
    quickly recap what happens. The `for` loop outside the function gets an iterator
    from `print_squares(2, 5)` and calls `next` on it until iteration is over. Every
    time the generator is called, execution is suspended (and later resumed) on `yield
    n ** 2`, which returns the square of the current `n`. Let''s see how we can transform
    this code benefiting from the `yield from` expression:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This code produces the same result, but as you can see `yield from` is actually
    running a sub iterator, `(n ** 2 ...)`. The `yield from` expression returns to
    the caller each value the sub iterator is producing. It's shorter and it reads
    better.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Generator expressions
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now talk about the other techniques to generate values one at a time.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: The syntax is exactly the same as `list` comprehensions, only, instead of wrapping
    the comprehension with square brackets, you wrap it with round brackets. That
    is called a **generator expression**.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, generator expressions behave like equivalent `list` comprehensions,
    but there is one very important thing to remember: generators allow for one iteration
    only, then they will be exhausted. Let''s see an example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Look at the line in which the generator expression is created and assigned the
    name `cubes_gen`. You can see it's a generator object. In order to see its elements,
    we can use a `for` loop, a manual set of calls to `next`, or simply, feed it to
    a `list` constructor, which is what I did (remember I'm using `_` as an alias).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Notice how, once the generator has been exhausted, there is no way to recover
    the same elements from it again. We need to recreate it if we want to use it from
    scratch again.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next few examples, let''s see how to reproduce `map` and `filter` using
    generator expressions:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the previous example, `s1` and `s2` are exactly the same: they are the sum
    of `adder(0, 1), adder(1, 2), adder(2, 3)`, and so on, which translates to `sum(1,
    3, 5, ...)`. The syntax is different, though I find the generator expression to
    be much more readable:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the previous example, `odd_cubes1` and `odd_cubes2` are the same: they generate
    a sequence of odd cubes. Yet again, I prefer the generator syntax. This should
    be evident when things get a little more complicated:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The preceding code creates two generators, `cubes1` and `cubes2`. They are exactly
    the same, and return two-tuples (*n, n³*) when `n` is a multiple of `3` or `5`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'If you print the list (`cubes1`), you get: `[(0, 0), (3, 27), (5, 125), (6,
    216), (9, 729), (10, 1000), (12, 1728), (15, 3375), (18, 5832)]`.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: See how much better the generator expression reads? It may be debatable when
    things are very simple, but as soon as you start nesting functions a bit, like
    we did in this example, the superiority of the generator syntax is evident. It's
    shorter, simpler, and more elegant.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let me ask you a question—what is the difference between the following
    lines of code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Strictly speaking, they all produce the same sum. The expressions to get `s2`
    and `s3` are exactly the same because the brackets in `s2` are redundant. They
    are both generator expressions inside the `sum` function. The expression to get
    `s1` is different though. Inside `sum`, we find a `list` comprehension. This means
    that in order to calculate `s1`, the `sum` function has to call `next` on a list
    a million times.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Do you see where we're losing time and memory? Before `sum` can start calling
    `next` on that list, the list needs to have been created, which is a waste of
    time and space. It's much better for `sum` to call `next` on a simple generator
    expression. There is no need to have all the numbers from `range(10**6)` stored
    in a list.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'So, *watch out for extra parentheses when you write your expressions*: sometimes
    it''s easy to skip over these details, which makes our code very different. If
    you don''t believe me, check out the following code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Try running the preceding example. If I run the first line on my old Linux
    box with 8 GB RAM, this is what I get:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'On the other hand, if I comment out the first line, and uncomment the second
    one, this is the result:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Sweet generator expressions. The difference between the two lines is that in
    the first one, a list with the squares of the first hundred million numbers must
    be made before being able to sum them up. That list is huge, and we ran out of
    memory (at least, my box did, if yours doesn't try a bigger number), therefore
    Python kills the process for us. Sad face.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: But when we remove the square brackets, we don't have a list any more. The `sum`
    function receives `0`, `1`, `4`, `9`, and so on until the last one, and sums them
    up. No problems, happy face.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Some performance considerations
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, we've seen that we have many different ways to achieve the same result.
    We can use any combination of `map`, `zip`, and `filter`, or choose to go with
    a comprehension, or maybe choose to use a generator, either function or expression.
    We may even decide to go with `for` loops; when the logic to apply to each running
    parameter isn't simple, they may be the best option.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'Other than readability concerns though, let''s talk about performance. When
    it comes to performance, usually there are two factors that play a major role:
    **space** and **time**.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Space means the size of the memory that a data structure is going to take up.
    The best way to choose is to ask yourself if you really need a list (or tuple)
    or if a simple generator function would work as well. If the answer is yes, go
    with the generator, it'll save a lot of space. The same goes for functions; if
    you don't actually need them to return a list or tuple, then you can transform
    them into generator functions as well.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you will have to use lists (or tuples), for example there are algorithms
    that scan sequences using multiple pointers or maybe they run over the sequence
    more than once. A generator function (or expression) can be iterated over only
    once and then it's exhausted, so in these situations, it wouldn't be the right
    choice.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Time is a bit harder than space because it depends on more variables and therefore
    it isn't possible to state that *X is faster than Y* with absolute certainty for
    all cases. However, based on tests run on Python today, we can say that on average, `map`
    exhibits performances similar to `list` comprehensions and generator expressions,
    while `for` loops are consistently slower.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: In order to appreciate the reasoning behind these statements fully, we need
    to understand how Python works, and this is a bit outside the scope of this book,
    as it's too technical in detail. Let's just say that `map` and `list` comprehensions
    run at C-language speed within the interpreter, while a Python `for` loop is run
    as Python bytecode within the Python Virtual Machine, which is often much slower.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: There are several different implementations of Python. The original one, and
    still the most common one, is CPython ([https://github.com/python/cpython](https://github.com/python/cpython)),
    which is written in C. C is one of the most powerful and popular programming languages
    still used today.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'How about we do a small exercise and try to find out whether the claims I made
    are accurate? I will write a small piece of code that collects the results of
    `divmod(a, b)` for a certain set of integer pairs, `(a, b)`. I will use the `time`
    function from the `time` module to calculate the elapsed time of the operations
    that I will perform:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As you can see, we''re creating three lists: `floop`, `compr`, and `gener`.
    Running the code produces the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `list` comprehension runs in ~67% of the time taken by the `for` loop. That's
    impressive. The generator expression came quite close to that, with a good ~77%.
    The reason the generator expression is slower is that we need to feed it to the
    `list()` constructor, and this has a little bit more overhead compared to a sheer
    `list` comprehension. If I didn't have to retain the results of those calculations,
    a generator would probably have been a more suitable option.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: An interesting result is to notice that, within the body of the `for` loop,
    we're appending data to a list. This implies that Python does the work, behind
    the scenes, of resizing it every now and then, allocating space for items to be
    appended. I guessed that creating a list of zeros, and simply filling it with
    the results, might have sped up the `for` loop, but I was wrong. Check it for
    yourself, you just need `mx * (mx - 1) // 2` elements to be preallocated.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a similar example that compares a `for` loop and a `map` call:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This code is conceptually very similar to the previous example. The only thing
    that has changed is that we''re applying the `abs` function instead of the `divmod`
    one, and we have only one loop instead of two nested ones. Execution gives the
    following result:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And `map` wins the race: ~62% of the `list` comprehension and ~30% of the `for`
    loop. Take these results with a pinch of salt, as things might be different according
    to various factors, such as OS and Python version. But in general, I think it''s
    safe to say that these results are good enough for having an idea when it comes
    to coding for performance.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the case-by-case little differences though, it's quite clear that
    the `for` loop option is the slowest one, so let's see why we still want to use
    it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Don't overdo comprehensions and generators
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've seen how powerful `list` comprehensions and generator expressions can
    be. And they are, don't get me wrong, but the feeling that I have when I deal
    with them is that their complexity grows exponentially. The more you try to do
    within a single comprehension or a generator expression, the harder it becomes
    to read, understand, and therefore maintain or change.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'If you check the Zen of Python again, there are a few lines that I think are
    worth keeping in mind when dealing with optimized code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Comprehensions and generator expressions are more implicit than explicit, can
    be quite difficult to read and understand, and they can be hard to explain. Sometimes
    you have to break them apart using the inside-out technique, to understand what's
    going on.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: To give you an example, let's talk a bit more about Pythagorean triples. Just
    to remind you, a Pythagorean triple is a tuple of positive integers (*a*, *b*,
    *c*) such that *a² + b² = c²*.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: We saw how to calculate them in the *Filtering a comprehension* section, but
    we did it in a very inefficient way because we were scanning all pairs of numbers
    below a certain threshold, calculating the hypotenuse, and filtering out those
    that were not producing a triple.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: A better way to get a list of Pythagorean triples is to generate them directly.
    There are many different formulas you can use to do this, we'll use the **Euclidean
    formula**.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'This formula says that any triple (*a*, *b*, *c*), where *a = m² - n²*, *b
    = 2mn*, *c = m² + n²*, with *m* and *n* positive integers such that *m > n*, is
    a Pythagorean triple. For example, when *m = 2* and *n = 1*, we find the smallest
    triple: (*3*, *4*, *5*).'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one catch though: consider the triple (*6*, *8*, *10*) that is just
    like (*3*, *4*, *5*) with all the numbers multiplied by *2*. This triple is definitely
    Pythagorean, since *6² + 8² = 10²* , but we can derive it from (*3*, *4*, *5*)
    simply by multiplying each of its elements by *2*. Same goes for (*9*, *12*, *15*),
    (*12*, *16*, *20*), and in general for all the triples that we can write as (*3k*,
    *4k*, *5k*), with k being a positive integer greater than *1*.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'A triple that cannot be obtained by multiplying the elements of another one
    by some factor, *k*, is called **primitive**. Another way of stating this is:
    if the three elements of a triple are **coprime**, then the triple is primitive.
    Two numbers are coprime when they don''t share any prime factor amongst their
    divisors, that is, their **greatest common divisor** (**GCD**) is *1*. For example,
    3 and 5 are coprime, while 3 and 6 are not, because they are both divisible by
    3.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the Euclidean formula tells us that if *m* and *n* are coprime, and *m
    - n* is odd, the triple they generate is *primitive*. In the following example,
    we will write a generator expression to calculate all the primitive Pythagorean
    triples whose hypotenuse (*c*) is less than or equal to some integer, *N*. This
    means we want all triples for which *m² + n² ≤ N*. When *n* is *1*, the formula
    looks like this: *m² ≤ N - 1*, which means we can approximate the calculation
    with an upper bound of *m ≤ N^(1/2)*.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to recap: *m* must be greater than *n*, they must also be coprime, and
    their difference *m - n* must be odd. Moreover, in order to avoid useless calculations,
    we''ll put the upper bound for *m* at *floor(sqrt(N)) + 1*.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: The `floor` function for a real number, *x*, gives the maximum integer, *n*,
    such that *n < x*, for example, *floor(3.8) = 3*, *floor(13.1) = 13*. Taking *floor(sqrt(N))
    + 1* means taking the integer part of the square root of *N* and adding a minimal
    margin just to make sure we don't miss any numbers.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put all of this into code, step by step. Let''s start by writing a simple
    `gcd` function that uses **Euclid''s algorithm**:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The explanation of Euclid''s algorithm is available on the web, so I won''t
    spend any time here talking about it; we need to focus on the generator expression.
    The next step is to use the knowledge we gathered before to generate a list of
    primitive Pythagorean triples:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: There you go. It's not easy to read, so let's go through it line by line. At
    `#3`, we start a generator expression that is creating triples. You can see from
    `#4` and `#5` that we're looping on `m` in *[1, M]* with *M* being the integer
    part of *sqrt(N)*, plus *1*. On the other hand, `n` loops within *[1, m)*, to
    respect the *m > n* rule. It's worth noting how I calculated *sqrt(N)*, that is,
    `N**.5`, which is just another way to do it that I wanted to show you.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'At `#6`, you can see the filtering conditions to make the triples primitive:
    `(m - n) % 2` evaluates to `True` when `(m - n)` is odd, and `gcd(m, n) == 1`
    means `m` and `n` are coprime. With these in place, we know the triples will be
    primitive. This takes care of the innermost generator expression. The outermost
    one starts at `#2`, and finishes at `#7`. We take the triples (*a*, *b*, *c*)
    in (...innermost generator...) such that `c <= N`.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Finally, at `#1` we apply sorting, to present the list in order. At `#7`, after
    the outermost generator expression is closed, you can see that we specify the
    sorting key to be the sum *a + b + c*. This is just my personal preference, there
    is no mathematical reason behind it.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: So, what do you think? Was it straightforward to read? I don't think so. And
    believe me, this is still a simple example; I have seen much worse in my career.
    This kind of code is difficult to understand, debug, and modify. It shouldn't
    find a place in a professional environment.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s see if we can rewrite this code into something more readable:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is so much better. Let's go through it, line by line. You'll see how much
    easier it is to understand.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'We start looping at `#1` and `#2`, in exactly the same way we were looping
    in the previous example. On line `#3`, we have the filtering for primitive triples.
    On line `#4`, we deviate a bit from what we were doing before: we calculate `c`,
    and on line `#5`, we filter on `c` being less than or equal to `N`. Only when
    `c` satisfies that condition, we do calculate `a` and `b`, and yield the resulting
    tuple. It''s always good to delay all calculations for as much as possible so
    that we don''t waste time and CPU. On the last line, we apply sorting with the
    same key we were using in the generator expression example.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: I hope you agree, this example is easier to understand. And I promise you, if
    you have to modify the code one day, you'll find that modifying this one is easy,
    while to modify the other version will take much longer (and it will be more error-prone).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'If you print the results of both examples (they are the same), you will get
    this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The moral of the story is, try and use comprehensions and generator expressions
    as much as you can, but if the code starts to be complicated to modify or to read,
    you may want to refactor it into something more readable. Your colleagues will
    thank you.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Name localization
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we are familiar with all types of comprehensions and generator expression,
    let''s talk about name localization within them. Python 3.* localizes loop variables
    in all four forms of comprehensions: `list`, `dict`, `set`, and generator expressions.
    This behavior is therefore different from that of the `for` loop. Let''s see a
    simple example to show all the cases:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the preceding code, we declare a global name, `A = 100`, and then we exercise
    the four comprehensions: `list`, generator expression, dictionary, and `set`.
    None of them alter the global name, `A`. Conversely, you can see at the end that
    the `for` loop modifies it. The last print statement prints `4`.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens if `A` wasn''t there:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The preceding code would work the same with any of the four types of comprehensions.
    After we run the first line, `A` is not defined in the global namespace. Once
    again, the `for` loop behaves differently:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The preceding code shows that after a `for` loop, if the loop variable wasn''t
    defined before it, we can find it in the global frame. To make sure of it, let''s
    take a peek at it by calling the `globals()` built-in function:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Together with a lot of other boilerplate stuff that I have omitted, we can
    spot `''A'': 4`.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Generation behavior in built-ins
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Among the built-in types, the generation behavior is now quite common. This
    is a major difference between Python 2 and Python 3\. A lot of functions, such
    as `map`, `zip`, and `filter`, have been transformed so that they return objects
    that behave like iterables. The idea behind this change is that if you need to
    make a list of those results, you can always wrap the call in a `list()` class,
    and you're done. On the other hand, if you just need to iterate and want to keep
    the impact on memory as light as possible, you can use those functions safely.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Another notable example is the `range` function. In Python 2 it returns a list,
    and there is another function called `xrange` that returns an object that you
    can iterate on, which generates the numbers on the fly. In Python 3 this function
    has gone, and `range` now behaves like it.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: But this concept, in general, is now quite widespread. You can find it in the
    `open()` function, which is used to operate on file objects (we'll see it in [Chapter
    7](part0187.html#5IAP60-2ddb708647cc4530a187c2c6c0e9acfe), *Files and Data Persistence*),
    but also in `enumerate`, in the dictionary `keys`, `values`, and `items` methods,
    and several other places.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'It all makes sense: Python''s aim is to try to reduce the memory footprint
    by avoiding wasting space wherever possible, especially in those functions and
    methods that are used extensively in most situations.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Do you remember at the beginning of this chapter? I said that it makes more
    sense to optimize the performances of code that has to deal with a lot of objects,
    rather than shaving off a few milliseconds from a function that we call twice
    a day.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: One last example
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we finish this chapter, I'll show you a simple problem that I used to
    submit to candidates for a Python developer role in a company I used to work for.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is the following: given the sequence `0 1 1 2 3 5 8 13 21 ...`,
    write a function that would return the terms of this sequence up to some limit, `N`.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't recognized it, that is the Fibonacci sequence, which is defined
    as *F(0) = 0*, *F(1) = 1* and, for any *n > 1*, *F(n) = F(n-1) + F(n-2)*. This
    sequence is excellent to test knowledge about recursion, memoization techniques,
    and other technical details, but in this case, it was a good opportunity to check
    whether the candidate knew about generators.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start from a rudimentary version of a function, and then improve on
    it:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'From the top: we set up the `result` list to a starting value of `[0]`. Then
    we start the iteration from the next element (`next_n`), which is `1`. While the
    next element is not greater than `N`, we keep appending it to the list and calculating
    the next. We calculate the next element by taking a slice of the last two elements
    in the `result` list and passing it to the `sum` function. Add some `print` statements
    here and there if this is not clear to you, but by now I would expect it not to
    be an issue.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: When the condition of the `while` loop evaluates to `False`, we exit the loop
    and return `result`. You can see the result of those `print` statements in the
    comments next to each of them.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, I would ask the candidate the following question: *What if I
    just wanted to iterate over those numbers?* A good candidate would then change
    the code to what you''ll find here (an excellent candidate would have started
    with it!):'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This is actually one of the solutions I was given. I don''t know why I kept
    it, but I''m glad I did so I can show it to you. Now, the `fibonacci` function
    is a *generator function*. First we yield `0`, then if `N` is `0`, we return (this
    will cause a `StopIteration` exception to be raised). If that''s not the case,
    we start iterating, yielding `b` at every loop cycle, and then updating `a` and
    `b`. All we need in order to be able to produce the next element of the sequence
    is the past two: `a` and `b`, respectively.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'This code is much better, has a lighter memory footprint and all we have to
    do to get a list of Fibonacci numbers is to wrap the call with `list()`, as usual.
    But what about elegance? I can''t leave it like that, can I? Let''s try the following:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Much better. The whole body of the function is four lines, five if you count
    the docstring. Notice how, in this case, using tuple assignment (`a, b = 0, 1`
    and `a, b = b, a + b`) helps in making the code shorter, and more readable.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the concept of iteration and generation a bit more
    deeply. We looked at the `map`, `zip`, and `filter` functions in detail, and learned
    how to use them as an alternative to a regular `for` loop approach.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Then we covered the concept of comprehensions, for lists, dictionaries, and
    sets. We explored their syntax and how to use them as an alternative to both the
    classic `for` loop approach and also to the use of the `map`, `zip`, and `filter`
    functions.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we talked about the concept of generation, in two forms: generator
    functions and expressions. We learned how to save time and space by using generation
    techniques and saw how they can make possible what wouldn''t normally be if we
    used a conventional approach based on lists.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: We talked about performance, and saw that `for` loops are last in terms of speed,
    but they provide the best readability and flexibility to change. On the other
    hand, functions such as `map` and `filter`, and `list` comprehensions, can be
    much faster.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: The complexity of the code written using these techniques grows exponentially
    so, in order to favor readability and ease of maintainability, we still need to
    use the classic `for` loop approach at times. Another difference is in the name
    localization, where the `for` loop behaves differently from all other types of
    comprehensions.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will be all about objects and classes. It is structurally similar
    to this one, in that we won't explore many different subjects, just a few of them,
    but we'll try to dive into them a little bit more deeply.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you understand the concepts of this chapter before moving on to the
    next one. We're building a wall brick by brick, and if the foundation is not solid,
    we won't get very far.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
