- en: Deploying Microsoft SQL Server 2019 and a ASP.NET MVC Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapters have given you a Swiss Army knife for deploying and operating
    hybrid Windows/Linux Kubernetes clusters—now, you have all the essential knowledge
    to deploy a real Windows container application to a Kubernetes cluster. This chapter
    will focus on demonstrating how you can approach containerizing and deploying
    a simple voting application written in C# .NET Framework 4.8 and ASP.NET MVC 5,
    with Microsoft SQL Server 2019 used for the persistence layer. The choice of the
    technology stack may seem a legacy one (why not use .NET Core?!) but it is intentional—if
    you are considering using Windows containers in Kubernetes, there is a good chance
    that you need the classic.NET Framework runtime as you are not ready to migrate
    to .NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topic of migrating existing applications to Kubernetes is broad and will
    not be fully covered in this book. There are numerous documented best practices
    for this process, but we will focus on a basic approach, mainly to demonstrate
    the Deployment instead of focusing on .NET Framework application implementation
    and migration. The goal of this chapter is to show the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How you can quickly containerize a Windows .NET Framework application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to inject environment configuration such as SQL connection strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The recommended approach for container logs on Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to debug the application remotely
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More precisely, in this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating and publishing an ASP.NET MVC application to Docker Hub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing the **Azure Kubernetes Service Engine** (**AKS Engine**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a failover Microsoft SQL Server 2019
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying the ASP.NET MVC application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Windows 10 Pro, Enterprise, or Education (version 1903 or later, 64-bit) installed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft Visual Studio 2019 Community (or any other edition) if you want to
    edit the source code for the application and debug it. **Visual Studio Code**
    (**VS Code**) has limited support for the classic .NET Framework.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Azure account.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Windows/Linux Kubernetes cluster deployed using AKS Engine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To follow along, you will need your own Azure account in order to create Azure
    resources for the Kubernetes cluster. If you haven't already created the account
    for the previous chapters, you can read more about how to obtain a limited free
    account for personal use here: [https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/).
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a Kubernetes cluster using AKS Engine has been covered in [Chapter
    8](ab695a0d-05dc-48f8-8c41-bbd167cfbfa6.xhtml), *Deploying a Hybrid Azure Kubernetes
    Service Engine Cluster*.
  prefs: []
  type: TYPE_NORMAL
- en: You can download the latest code samples for this book chapter from the official
    GitHub repository, at [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter10](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter10).
  prefs: []
  type: TYPE_NORMAL
- en: Creating and publishing an ASP.NET MVC application to Docker Hub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to demonstrate the Deployment of a real Windows container application,
    we will create a Docker image for a voting application that is a small C# .NET
    Framework 4.8 web application for creating surveys. The application is implemented
    using the classic ASP.NET MVC 5 stack as it is the most suitable for demonstrating
    how to approach the containerization of a Windows application. Traditional .NET
    Framework applications, especially enterprise, heavily rely on Windows-only functionalities,
    such as **Windows Communication Foundation** (**WCF**). In many cases, you may
    be lucky to easily migrate to .NET Core and use Linux containers for hosting your
    application, but for some parts of the .NET Framework stack, it may never happen,
    even in .NET 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few assumptions concerning our voting application, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: There is no dependency on Kubernetes or Windows containers in any way. The application
    is unaware of being hosted by a container orchestration system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Entity Framework 6.3** (**EF 6.3**) ([https://docs.microsoft.com/en-us/ef/ef6/](https://docs.microsoft.com/en-us/ef/ef6/))
    with the Code-First approach is used as **object-relational mapping** (**ORM**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft SQL Server is used for voting data storage—this is a common stack
    you see with ASP.NET MVC applications. For local development, we use **Microsoft
    SQL** (**MSSQL**) Server Express LocalDB ([https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/sql-server-express-localdb?view=sql-server-ver15](https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/sql-server-express-localdb?view=sql-server-ver15)),
    whereas, for the Kubernetes Deployment, we are going to use MSSQL Server 2019
    hosted in Linux containers ([https://docs.microsoft.com/en-us/sql/linux/quickstart-install-connect-docker?view=sql-server-ver15&pivots=cs1-bash](https://docs.microsoft.com/en-us/sql/linux/quickstart-install-connect-docker?view=sql-server-ver15&pivots=cs1-bash)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serilog ([https://serilog.net/](https://serilog.net/)) has been chosen as the
    logging framework.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ninject ([https://github.com/ninject/Ninject](https://github.com/ninject/Ninject))
    ties everything together as a dependency injector.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use simple fat controllers that contain all the business logic and the data
    access layer (so there are no repositories or other design patterns). This has
    been chosen specifically to make the application as compact as possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the views and controllers are based on a standard MVC 5 scaffolding
    for the EF model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage of view models is limited to places where it is absolutely necessary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the application source code in the official GitHub repository for
    the book, at [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter10/01_voting-application-src](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter10/01_voting-application-src).
    To open the `VotingApplication.sln` solution file, you need Visual Studio 2019\.
    It is also possible to perform a build by just using the `docker build` command,
    as explained in the next subsections. At the end of this section, you will have
    a Docker image for a voting application, ready to be used in Kubernetes. You may
    follow along with the steps or choose to use a ready-made image from Docker Hub,
    available at [https://hub.docker.com/repository/docker/packtpubkubernetesonwindows/voting-application](https://hub.docker.com/repository/docker/packtpubkubernetesonwindows/voting-application).
  prefs: []
  type: TYPE_NORMAL
- en: Injecting the configuration using environment variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When developing a container-friendly application, you need to consider how
    to inject configuration data such as database connection strings. A general rule
    of thumb is that you should not hardcode any addresses, usernames, passwords,
    or connection strings into your code. You should be always able to inject such
    configuration during runtime and, in general, this is also true for non-containerized
    applications. Kubernetes offers you a wide variety of approaches on how to inject
    the runtime configuration, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Passing arguments to the container commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining system environment variables for the container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mounting ConfigMaps or Secrets as container volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optionally wrapping everything up using PodPresets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can read more about all of them in the official documentation ([https://kubernetes.io/docs/tasks/inject-data-application/](https://kubernetes.io/docs/tasks/inject-data-application/)).
    The important takeaway is that all the features integrate with the containerized
    application using standard **operating system** (**OS)**-level primitives such
    as files or environment variables. This means that if you design your application
    well, you can use it without any changes inside or outside of Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: We will demonstrate how to use environment variables to inject an MSSQL Server
    connection string to our application. This approach is the simplest one but it
    has a significant limitation—you cannot modify the container's environment variables
    when the container is running. Once you set the variable, it will have the same
    value throughout the whole container life cycle. If you need to be able to modify
    the configuration without restarting the container, you should take a look at
    ConfigMaps (combined with Secrets), which are described in the next chapter: [Chapter
    11](9ad8c38e-6d0d-435b-a46c-82a468f18007.xhtml), *Configuring Applications to
    Use Kubernetes Features*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our voting application uses the `VotingApplicationContextFactory` class for
    creating an EF DbContext for **Model-View-Controller** (**MVC**) controllers.
    Let''s take a look at the `Create()` method of this class (available at [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter10/01_voting-application-src/Factories/VotingApplicationContextFactory.cs](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter10/01_voting-application-src/Factories/VotingApplicationContextFactory.cs)),
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a common pattern you can use to inject a configuration into
    your application, especially in the Linux world, where relying on environment
    variables is much more common:'
  prefs: []
  type: TYPE_NORMAL
- en: Check if your chosen environment variable, `CONNECTIONSTRING_VotingApplication`,
    is defined.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it is, create an EF DbContext using the overriddenconnection string from
    the variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If not, create an EF DbContext using the standard connection string. In this
    case, it will be retrieved from the `Web.config` application file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can follow this pattern, especially when you are not using custom configuration
    files. This solution gives you a lot of flexibility and you can use it also when
    running an application without a container!
  prefs: []
  type: TYPE_NORMAL
- en: Another approach would be to inject the whole `Web.config` file as a Kubernetes
    ConfigMap object. We will explore this possibility in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This shows an important principle that you should use when containerizing any
    application—think about the external interfaces of your application (system) and
    how it communicates with the outside world. This is the only way you can influence
    or monitor an application running in a container. Providing and injecting configuration
    is one of the external interfaces for your application. Similarly, logging defines
    an output interface for your application—let's see how you can approach this in
    Windows containers.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring logging for Windows containers log monitor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kubernetes itself provides simple tools for browsing Pod container logs. Generally,
    you will have to implement a good cluster-level logging solution—for example,
    using the Elasticsearch, Logstash, Kibana stack or using Azure Log Analytics (as
    briefly demonstrated in the previous chapters). The official documentation gives
    a good overview of possible architectures for logging solutions: [https://kubernetes.io/docs/concepts/cluster-administration/logging/](https://kubernetes.io/docs/concepts/cluster-administration/logging/).
    In all cases, you will need to expose the application logs from your container
    to the outside world. From a high-level view, there are three main approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a container **standard output** (**stdout**) and **standard error** (**stderr**)
    entry point and let the container runtime handle the logging. This can be later
    consumed using a node-level logging agent (for example, Fluentd, Elastic Beats,
    or Logstash) that forwards the logs to any external logging solution. This works
    especially well if your containerized applications write everything to the console
    output out of the box.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use an additional sidecar container in your application Pod that gathers the
    logs from the filesystem, event log, or other sources, and exposes it as stdout
    or directly to the external logging solution. This approach is useful if your
    application logs to multiple destinations inside the container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embed log streaming into the application itself. For example, in a C# application,
    you can use log4net and a dedicated Elasticsearch appender ([https://github.com/ptylenda/log4net.ElasticSearch.Async](https://github.com/ptylenda/log4net.ElasticSearch.Async))
    for streaming logs to your Elasticsearch cluster. This approach is the most limited—it
    creates a tight dependency on an external logging system and may cause an impact
    on performance that cannot be easily separated from the application workload itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a Windows application, logging to stdout is not common, especially for older
    applications and when using **Internet Information Services** (**IIS**) for hosting
    your web applications. In most cases, using **Event Tracing for Windows** (**ETW**),
    event logs, or custom log files is more common for Windows. For example, our voting
    application is hosted using IIS. Also, when running in a containerized mode, IIS
    does not provide a functionality to expose the stdout of an application. You have
    to rely on event logs or your own log files. On top of that, IIS itself exposes
    additional application logs in a standard location—`c:\inetpub\logs`—and streams
    its own events to ETW.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can approach the gathering of logs for a voting application in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Use an additional sidecar container that runs, for example, Elastic Beats or
    Winlogbeat ([https://www.elastic.co/products/beats/winlogbeat](https://www.elastic.co/products/beats/winlogbeat)),
    which gathers all the logs from the application container and exposes it to stdout
    ([https://www.elastic.co/guide/en/beats/filebeat/current/console-output.html](https://www.elastic.co/guide/en/beats/filebeat/current/console-output.html))
    or any other supported output. The logs need to be shared using a volume between
    the containers inside the Pod.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Extend the container image with Windows containers log monitor, which has been
    recently released ([https://github.com/microsoft/windows-container-tools](https://github.com/microsoft/windows-container-tools)).
    More details regarding the architecture can be found here: [https://techcommunity.microsoft.com/t5/Containers/Windows-Containers-Log-Monitor-Opensource-Release/ba-p/973947](https://techcommunity.microsoft.com/t5/Containers/Windows-Containers-Log-Monitor-Opensource-Release/ba-p/973947)).
    This tool uses a different approach than a sidecar container. In the Docker image,
    instead of directly starting your application, you start `LogMonitor.exe` with
    an appropriate JSON configuration file and pass the command line for starting
    your application as an argument for `LogMonitor.exe`. In other words, `LogMonitor.exe`
    acts as a supervisor for your application process and prints logs to stdout that
    are gathered from different sources based on the configuration file. There are
    plans to further extend this solution to be used in the sidecar container pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are going to use log monitor as it is simple to integrate and easy to configure.
    The details of the Dockerfile for the application will be shown in the next subsection.
    Assuming that the command for starting your application (IIS, in this case) is
    `C:\ServiceMonitor.exe w3svc`, the general pattern for using Log Monitor is customizing
    the Dockerfile in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `LogMonitoringConfig.json` file ([https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter10/01_voting-application-src/LogMonitorConfig.json](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter10/01_voting-application-src/LogMonitorConfig.json))
    for our application has the following JSON configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This configuration file subscribes log monitor to the `system` log and the `VotingApplication`
    log in the Windows event log, monitors logs in `C:\inetpub\logs`, and collects
    ETW data for IIS. The `VotingApplication` log in the event log contains all the
    logs produced by Serilog in our application. This is configured in the `NinjectWebCommon`
    class ([https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter10/01_voting-application-src/App_Start/NinjectWebCommon.cs](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter10/01_voting-application-src/App_Start/NinjectWebCommon.cs)),
    where we initialize the logger sinks, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that due to the fact that Windows containers are not running in privileged
    mode, we cannot automatically create the log in an event log (`manageEventSource:
    false`). This has to be done in the Dockerfile at build time.'
  prefs: []
  type: TYPE_NORMAL
- en: With this setup, our voting application will print all our own logs, together
    with the system and IIS, to stdout of the container. This means you can easily
    investigate them using the `docker logs` command (when running a standalone container)
    or the `kubectl logs` command. If you integrate with Azure Log Analytics, your
    logs will be available for querying using Kusto.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Dockerfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step is preparing a Dockerfile for our application. You can check
    the official documentation on how to approach building .NET Framework applications
    in a Dockerfile at [https://github.com/microsoft/dotnet-framework-docker/tree/master/samples/dotnetapp](https://github.com/microsoft/dotnet-framework-docker/tree/master/samples/dotnetapp).
    Our Dockerfile has to cover the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Restore NuGet packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the application, preferably using a publish profile to the local filesystem.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy tools for applying EF migrations (provided by the EF NuGet package).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `VotingApplication` log in the event log.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy log monitor binaries and configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy voting application binaries to `C:\inetpub\wwwroot` for IIS hosting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to dwell on the topic of EF migrations a bit more. Applying EF database
    migrations without application downtime and when having multiple replicas of the
    application is a complex task. You need to ensure that the migrations can be rolled
    back and that the database schema is fully compatible with the old and the new
    application versions. In other words, backward-incompatible changes such as renames
    have to be handled specially to make them backward-compatible between the individual
    steps. A skeleton for this process could look as follows—for example, for renaming
    a column for an entity:'
  prefs: []
  type: TYPE_NORMAL
- en: Apply database migration that adds a new column with the new name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Roll out a new version of your application that performs writes to both the
    old and the new column. Reads should be performed using the old column because
    it always has the proper data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute a job that copies data from the old column to the new column.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Roll out a new version of your application that reads from the new column.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Roll out a new version of your application that writes to the new column only.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply database migration, which removes the old column.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, properly handling database migrations for applications running
    in Kubernetes with no downtime requires strict rules and compatibility/rollback
    testing—we have brought this topic to your attention, but detailed solutions are
    out of the scope of this book. There is a good article by Spring that explains
    the details of how to approach this problem ([https://spring.io/blog/2016/05/31/zero-downtime-deployment-with-a-database](https://spring.io/blog/2016/05/31/zero-downtime-deployment-with-a-database))
    and another article by Weaveworks dedicated for Kubernetes: [https://www.weave.works/blog/how-to-correctly-handle-db-schemas-during-kubernetes-rollouts](https://www.weave.works/blog/how-to-correctly-handle-db-schemas-during-kubernetes-rollouts).
  prefs: []
  type: TYPE_NORMAL
- en: For applying migrations, we will use the same Docker image—EF database migrations
    are applied using application assembly and EF command-line tools, which we will
    provide in the image. Then, the migrations (and database seeding) will be run
    using a Kubernetes Job that is suitable for running one-time tasks. In a real-world
    scenario, this should be scheduled as part of your **Continuous Integration/Continuous
    Deployment** (**CI/CD)** process, accompanying the Kubernetes Deployment rollout.
  prefs: []
  type: TYPE_NORMAL
- en: 'The voting application contains a Dockerfile named `Dockerfile.production`
    ([https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter10/01_voting-application-src/Dockerfile.production](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter10/01_voting-application-src/Dockerfile.production))
    that has layers based on what we have just summarized. Let''s analyze it, step
    by step:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Dockerfile defines a multi-stage build, which means that multiple base
    images are used throughout the build process. The first stage is the web application
    build, using a `mcr.microsoft.com/dotnet/framework/sdk` image. This image contains
    all the .NET Framework build tools that are not required for the runtime. The
    code for this is illustrated in the following block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The layers are organized in such a way that layer caching during builds is maximized—for
    example, we run `nuget restore` only if certain solution configuration files change.
  prefs: []
  type: TYPE_NORMAL
- en: 'The build process is performed by a standard `msbuild` command, using a dedicated `DockerPublishProfile.pubxml` publish
    profile that has the following form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In principle, it performs a `FileSystem` publish to `obj\Docker\publish`, which
    is later used for creating the final image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we start the second and final build stage based on the `mcr.microsoft.com/dotnet/framework/aspnet`
    image dedicated for runtime scenarios, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the first step, we perform the copying of EF6 migration command-line tools,
    which are provided with the EF NuGet package. Here, the key is to copy from the
    previous stage, using the `--from=build` argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is creating a dedicated log in an event log for our voting application
    (this requirement was mentioned in the previous subsection), as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the `LogMonitor` binary and configuration, also overriding the shell command
    for the container, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the `build` artifacts from the previous stage to the `C:\inetpub\wwwroot` IIS
    application directory, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, define the default entry point for the image to the `ServiceMonitor.exe`
    starting the IIS service. This is a standard approach that you see in the `mcr.microsoft.com/dotnet/framework/aspnet` base
    image. The only difference is that the whole process tree will run under log monitor
    supervision. The code can be seen in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: That's it! The Dockerfile defines the full build process for the ASP.NET MVC
    application—you could optionally extend it with a testing stage whereby you execute
    appropriate tests. Now, let's build the image and push it to the image registry.
  prefs: []
  type: TYPE_NORMAL
- en: Building and pushing the Docker image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The exact details of this process have been covered in [Chapter 3](e00b7610-2513-4513-863f-62a054d8cd98.xhtml), *Working
    with Container Images*. In short, you can use two approaches here:'
  prefs: []
  type: TYPE_NORMAL
- en: Performing a manual build of the image on your local machine and pushing it
    to the public Docker Hub. Currently, setting an autobuild for a Windows container
    image is not possible on Docker Hub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are interested in having automated builds and GitHub hooks integrated
    into your application, you can use **Azure Container Registry** (**ACR**), as
    described in the chapter mentioned previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the sake of simplicity, we will perform a manual build and push the image
    to Docker Hub. In a real-world scenario, you should use at least ACR with GitHub
    integration as part of your CI/CD pipeline. Let''s perform the build of the Docker
    image—in the examples, we will use the `packtpubkubernetesonwindows/voting-application`
    image repository name, but if you are following along, you should use your own `<dockerId>/voting-application`
    repository. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the PowerShell window and navigate to the main `voting-application` source
    directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Execute the Docker build using the following command (remember the final dot,
    which specifies the build context directory):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the build to finish, and tag the image accordingly. This is crucial
    for Kubernetes Deployments as we can specify a particular version of the image
    to be rolled out (using the latest version would be ambiguous and is generally
    not recommended). Using semantic versioning, as described in [Chapter 3](e00b7610-2513-4513-863f-62a054d8cd98.xhtml), *Working
    with Container Images*, is advised, and this is illustrated in the following code
    block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Push all the tags to the image repository, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can verify if the tags are properly visible in the Docker Hub page—for
    example, [https://hub.docker.com/repository/docker/packtpubkubernetesonwindows/voting-application/tags?page=1](https://hub.docker.com/repository/docker/packtpubkubernetesonwindows/voting-application/tags?page=1).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, our Docker image can be used both locally (you need to provide
    a valid connection string to SQL Server using an environment variable) and in
    Kubernetes. Let's begin the preparation of AKS Engine cluster Deployment!
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the AKS Engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have followed [Chapter 8](ab695a0d-05dc-48f8-8c41-bbd167cfbfa6.xhtml), *Deploying
    a Hybrid Azure Kubernetes Service Engine Cluster, *and you have created a hybrid
    Windows/Linux Kubernetes cluster using AKS Engine, you are ready to go—you can
    verify in this section if the topology of the cluster is as required. And, if
    you do not have an AKS Engine cluster deployed yet, we will provide a quick way
    to deploy it using a PowerShell script provided in the GitHub repository for the
    book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our voting application can be hosted on the smallest possible hybrid Windows/Linux
    cluster, one Linux master and one Windows node, where the Linux master acts as
    a regular node. However, to fully demonstrate the principles of Deployment, we
    will use a cluster that resembles a production one: one Linux master running in
    **Virtual Machine Scale Sets** (**VMSS**)** High Availability** (**HA**) mode,
    two Linux nodes, and two Windows nodes. We have used this configuration in the
    previous chapter for AKS Engine cluster Deployments. In order to quickly deploy
    an AKS Engine cluster from scratch, you can perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the following PowerShell script from the book's GitHub repository: [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter08/01_aks-engine/01_CreateAKSEngineClusterWithWindowsNo](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter08/01_aks-engine/01_CreateAKSEngineClusterWithWindowsNodes.ps1)[des.ps1](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter08/01_aks-engine/01_CreateAKSEngineClusterWithWindowsNodes.ps1).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the PowerShell window, execute the script with the appropriate parameters,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This script deploys the cluster to the West Europe location in Azure using the `aks-engine-windows-resource-group`
    resource group. If there are problems with the AKS Engine Deployment, you can
    always try specifying a different region—for example, `-azureLocation westus`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When the Deployment finishes, you need to ensure that your default kubeconfig
    contains the context for the new cluster. You can quickly merge your kubeconfig
    with one that is generated for the West Europe location by AKS Engine by using
    the following commands (remember to double-check the contents of the `config_new`
    file before overwriting your default config file to avoid any loss):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In a new PowerShell window, verify that you are able to access the cluster—for
    example—by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Running an AKS Engine cluster of this size can be costly, so you should always
    check the estimated cost for **virtual machine** (**VM**) hosting. If you do not
    need the cluster anymore, you can simply delete it using the `az group delete
    --name aks-engine-windows-resource-group --yes` command, optionally providing
    a `--no-wait` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you have a cluster ready for running Microsoft SQL Server 2019
    and the voting application, so let's proceed!
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a failover Microsoft SQL Server 2019
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From MSSQL Server 2017, it is possible to host it in a Linux Docker container.
    As our application requires MSSQL Server for data persistence, we are going to
    deploy the latest version—MSSQL Server 2019—to our Kubernetes cluster. Currently,
    it is possible to deploy MSSQL Server to Kubernetes in two modes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A single-node instance with failover guaranteed by a Kubernetes Deployment and
    an Azure Disk persistent volume.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A multi-node, HA cluster using a dedicated Kubernetes operator ([https://kubernetes.io/docs/concepts/extend-kubernetes/operator/](https://kubernetes.io/docs/concepts/extend-kubernetes/operator/)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second mode was announced for preview as of **Community Technology Preview**
    (**CTP**) 2.0 version ([https://cloudblogs.microsoft.com/sqlserver/2018/12/10/availability-groups-on-kubernetes-in-sql-server-2019-preview/](https://cloudblogs.microsoft.com/sqlserver/2018/12/10/availability-groups-on-kubernetes-in-sql-server-2019-preview/))
    but currently, in the **general availability** (**GA**) version, the Docker images
    and Kubernetes manifests are not compatible. If you are interested, you can check
    the official manifest files for this kind of Deployment at [https://github.com/microsoft/sql-server-samples/tree/master/samples/features/high%20availability/Kubernetes/sample-manifest-files](https://github.com/microsoft/sql-server-samples/tree/master/samples/features/high%20availability/Kubernetes/sample-manifest-files).
  prefs: []
  type: TYPE_NORMAL
- en: 'For this reason, we are going to deploy SQL Server in the simpler, single-node
    failover mode. To do this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the PowerShell window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `dev.yaml` manifest file for a new Kubernetes namespace with the following
    content, and apply it using the `kubectl apply -f .\dev.yaml` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a  `storage-class.yaml` manifest file for a Kubernetes storage class
    that uses an Azure Disk provisioner, and apply it using the `kubectl apply -f
    .\storage-class.yaml` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `pvc.yaml` manifest file that defines a `mssql-data` **Persistent
    Volume Claim** (**PVC**) for the SQL Server instance. This PVC will be used for
    mounting data in `/var/opt/mssql` in the container. Apply the manifest using the  `kubectl
    apply -f .\pvc.yaml` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a Kubernetes `mssql` Secret that contains a **System Administrator**
    (**SA**) user password for SQL Server, using your own, safe password, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `sql-server.yaml` manifest file that defines the Kubernetes Deployment
    for SQL Server, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a couple of important parts to this manifest file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need an extra`volume-mount-permissions-fix` init container, which
    is required for ensuring that directories, after mounting PVC, have proper access
    permissions for SQL Server—the container will be run before the regular Pod containers
    are created. This is a good example of how init containers are used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Secondly, we need to accept the **end-user license agreement** (**EULA**) using
    the `ACCEPT_EULA` environment variable and choose an appropriate SQL Server edition
    using the `MSSQL_PID` environment variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are going to use the Developer edition because our application is hosted
    for development purposes only. You can read more about usage of these variables
    in the documentation for the image, at [https://hub.docker.com/_/microsoft-mssql-server](https://hub.docker.com/_/microsoft-mssql-server).
    Additionally, you need to provide a `MSSQL_SA_PASSWORD` environment variable, which
    contains the SA user password for the instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For this, we are using the value from the `mssql` Secret that we created earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to mount the volume provided by the `mssql-data` PVC to the `/var/opt/mssql`
    path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will provide a failover similar to SQL Server shared disk failover instances.
    And lastly, we have to ensure that `nodeSelector` is set to choose only Linux
    machines.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, continue the Deployment using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Apply the manifest file using the `kubectl apply -f .\sql-server.yaml` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `sql-server-service.yaml` manifest file to create a Kubernetes service
    for your SQL Server instance. Depending on your needs, you can use type `ClusterIP`,
    or, if you expose the SQL Server instance for connections outside from the Kubernetes
    cluster (for example, for **SQL Server Management Studio** (**SSMS**)), you can
    use a `LoadBalancer` type. Apply the manifest file using the `kubectl apply -f
    .\sql-server-service.yaml` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You can observe the Pod creation using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you have an MSSQL Server 2019 instance running in your cluster
    in the `dev` namespace that is accessible using an `mssql-deployment` **Domain
    Name System** (**DNS**) name inside of your cluster. Additionally, if you have
    created a LoadBalancer service, you can verify the instance using SSMS, providing
    the service's external IP address, user SA, and your chosen password.
  prefs: []
  type: TYPE_NORMAL
- en: We can now proceed to create manifest files for the voting application and deploying
    the application to the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the ASP.NET MVC application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, it is time for the big show! We will now deploy our voting application
    using a standard Kubernetes Deployment and, in the next section, we will expose
    it to the external users using the LoadBalancer service. First, we need to briefly
    summarize what is required for the proper Deployment of our application, as follow:'
  prefs: []
  type: TYPE_NORMAL
- en: A `packtpubkubernetesonwindows/voting-application:1.0.0` Docker image will be
    used for deploying the application. If you have pushed the image to your own image
    repository, you need to change the manifest file accordingly. We specify a `1.0.0`
    tag explicitly as we want to avoid pulling an unexpected container image version.
    You can read more about the best practices for container images in the documentation
    at [https://kubernetes.io/docs/concepts/configuration/overview/#container-images](https://kubernetes.io/docs/concepts/configuration/overview/#container-images).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application requires a `CONNECTIONSTRING_VotingApplication` environment
    variable to be set if we need a custom connection string. In the case of our Deployment,
    the connection string should have the following form: `Data Source=mssql-deployment;Initial
    Catalog=VotingApplication;MultipleActiveResultSets=true;User Id=sa;Password=$(MSSQL_SA_PASSWORD);`,
    where `$(MSSQL_SA_PASSWORD)` will be retrieved from a Kubernetes Secret.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying the initial database migration is required in order to seed the database
    data. We will do that using a Kubernetes Job—this approach can be generalized
    in your CI/CD pipeline. The migration itself is performed using the `ef6.exe database
    update` command—the image already contains this executable in the `C:/ef6/` directory.
    Please note that in a production environment, you might want to create a separate
    Docker image just for migrations that contains all the required tools. In this
    way, you would keep your application image clean and as small as possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will not create any dedicated liveness and readiness probes yet as this will
    be demonstrated in the next chapter: [Chapter 11](9ad8c38e-6d0d-435b-a46c-82a468f18007.xhtml), *Configuring
    Applications to Use Kubernetes Features*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To deploy the voting application, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the PowerShell window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `voting-application.yaml` manifest file for the Kubernetes Deployment
    with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s explain the most important parts of this manifest file:'
  prefs: []
  type: TYPE_NORMAL
- en: We define it as a Deployment with `5` initial replicas—we can scale it as we
    wish, as the frontend application is stateless in our case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order to have a simple mechanism for preventing the accessing of Pods for
    which IIS is still initializing, we add `minReadySeconds: 5`. In the next chapter,
    we will configure a proper readiness and liveness probe.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also explicitly set the Deployment update strategy to `RollingUpdate` with
    the maximum number of unavailable Pods to `25%`, allowing us to create up to `25%`
    more Pods than the desired number during rollout (this is controlled by the `maxSurge`
    parameter).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, remember to set a proper `nodeSelector` to deploy to Windows nodes only.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The image is specified to use a particular tag—if you use your own image, update
    this accordingly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to create the connection string for the database, we have to first
    retrieve the SA user password from the `mssql` Secret `(6a)` and initialize the
    `MSSQL_SA_PASSWORD` environment variable `(6b)`, which can be used for creating
    the actual connection string stored in the `CONNECTIONSTRING_VotingApplication`
    variable (6c). As demonstrated, you can use existing environment variables to
    initialize new environment variables: `Data Source=mssql-deployment;Initial Catalog=VotingApplication;MultipleActiveResultSets=true;User
    Id=sa;Password=$(MSSQL_SA_PASSWORD);`. This is a common pattern when you want
    to retrieve a value from a Secret and use it for defining another variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, please continue the Deployment using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Apply the manifest file using the `kubectl apply -f .\voting-application.yaml`
    command. Wait for the Pods to start, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The application has been successfully deployed. Before accessing it, we first
    need to apply the initial database migration—technically, you could access the
    application without seeding the database as the schema would get initialized automatically,
    but there would be no data in the tables at all. To perform the database migration,
    please perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `ef6-update-database.yaml` manifest file for the Kubernetes Job with
    the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The key points here are setting a **time-to-live** (**TTL**) seconds value in
    order to trigger automatic cleanup of Pods created by the Job `(1)` and ensuring
    that the Pods are executed on Windows nodes `(2)`. The last part is setting the
    container image `(3)`. In our case, we use the same as for the application, as
    it contains all the migration tools. The `(4)` command is specific to EF, but
    in general, you have to provide the path to the .NET assembly that contains the
    migrations using the `--assembly` parameter, and a proper connection string, using
    the `--connection-string` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Apply the manifest file using the `kubectl apply -f .\ef6-update-database.yaml`
    command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Wait for the Job to run to completion, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check the logs using the standard `kubectl logs` command, but you have
    to provide the `jobs` prefix, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if anything went wrong—for example, you cannot access the logs (because
    the Pod did not even start) or all Job executions completed with a failure—the
    best way to investigate is describing the Job object and finding the Pods that
    it has created, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this information, you can describe any Pods that did not start properly,
    or you can even directly describe them using the Job name, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Our application is ready—we can try accessing it, even if there is no LoadBalancer
    Service for it yet. To do that, we will use the technique described in the previous
    chapters, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the PowerShell window, execute the following command to forward all network
    traffic from the localhost port `5000` to port `80` on one of the Pods in the `voting-application` Deployment,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Without closing the PowerShell session, open your web browser and navigate
    to `http://localhost:5000`. You should see the following screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/c72677f2-25c3-4819-8028-626c9c94f3fb.png)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations! You have successfully deployed the voting application—now,
    we can proceed to expose the Deployment using a LoadBalancer service.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will expose our voting application to external users by
    creating a Kubernetes service of the LoadBalancer type. Services have been covered
    in depth in [Chapter 5](da2ee6af-a754-4fc8-ae62-86d8e68f0bd0.xhtml), *Kubernetes
    Networking*. At the end of this section, anyone who has the external IP of your
    new service will be able to access the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the service, execute the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the PowerShell window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `voting-application-service.yaml` manifest file for the Kubernetes
    service with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, the key points are ensuring that the type of service is `LoadBalancer
    (1)` and using the proper port for the service `(2)`. In our case, the port on
    the physical Azure load balancer will be the same as for the application Pods,
    so we do not need to specify the `targetPort` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Apply the manifest file using the `kubectl apply -f .\voting-application-service.yaml`
    command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Wait for the external IP to be provided for the new service, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the external IP is `104.42.142.217`. Use your web browser and
    navigate to `http://104.42.142.217`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can try refreshing the page multiple times and accessing it from different
    browsers. You will see in the page footer that you are served by different Pods.
    If you experience any delays at the beginning, it is caused by IIS starting the
    app pool in a given Pod when accessed for the first time. The code can be seen
    in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The application is now accessible to all external users! Now, we will take a
    look at how you can scale the application.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our design, the only component that can scale is the ASP.NET MVC frontend.
    SQL Server cannot be scaled as it runs in a single node with automatic failover
    mode. Real scaling of the SQL Server requires the use of **Availability Groups**
    (**AG**) and a dedicated Kubernetes Operator, as mentioned in the earlier sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapter, we have shown different declarative and imperative
    methods on how to scale a Deployment. We will now show the safest, declarative
    way of scaling the Deployment. Autoscaling will not be covered as it is described
    in more detail in the next chapter: [Chapter 11](9ad8c38e-6d0d-435b-a46c-82a468f18007.xhtml), *Configuring
    Applications to Use Kubernetes Features*. To scale the frontend Deployment from
    5 replicas to 10, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the PowerShell window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify your existing `voting-application.yaml` manifest file to change the
    number of replicas, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Apply the manifest file using the `kubectl apply -f .\voting-application.yaml`
    command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Observe the status of the rollout, as illustrated in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You will eventually see that it never reaches 10 ready replicas! What happened?
    The answer to this is that we have exhausted the CPU reservation limits for our
    two Windows nodes—each node was scheduled with four Pods, reserving `500m` CPU
    per Pod. If you check the specification of the Standard_D2_v3 Azure VM, you will
    see that it has two vCPUs, which means that we have reserved all the resources.
    You can verify this theory by inspecting the Pods that are in `Pending` status,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Describe one of the Pods that is in a `Pending` state, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'What can we do in such a case? Consider the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: Scale your Kubernetes cluster up by adding more Windows nodes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not scale the cluster up; decrease the CPU limits for the Deployment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not scale the cluster up; do not change CPU limits for the Deployment, but
    decrease the CPU requests in order to do an overcommit. You can dive deeper into
    this concept by checking out the official documentation at [https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/#how-pods-with-resource-limits-are-run](https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/#how-pods-with-resource-limits-are-run).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In general, to decide what to do, you have to understand the requirements for
    your application and how it behaves under low CPU availability. As a demonstration,
    we will perform an overcommit of CPU resources, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Modify the `voting-application-service.yaml` manifest file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the requested CPU value to `250m`, leaving the limits value unchanged.
    Please note that we also need to modify `maxUnavailable` to allow a larger number
    of Pods to be unavailable during the rollout. With the previous value of `25%`,
    we would run into a deadlock situation, as already, 2 of 10 Pods are not available.
    The code for this is illustrated in the following block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Apply the manifest file using the `kubectl apply -f .\voting-application.yaml` command
    and observe how the Deployment scales to 10 replicas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that you understand how you can scale our voting application, we can move
    to the last section in this chapter, which will show how to debug the application.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Debugging applications is a broad topic and involves a lot of techniques depending
    on the need—it may involve detailed telemetry, traces, or performance counter
    analysis. From a developer perspective, there is one technique that is especially
    important: working with a code debugger. One of the problems with containerized
    workloads is that they are relatively heavy to debug using standard tools such
    as Visual Studio—the processes are not running locally and you cannot easily attach
    the debugger as if it was a local process. In this section we will show the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to access application logs produced by log monitor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to enable Visual Studio remote debugging via `kubectl` port forwarding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Accessing application logs is straightforward as it involves the standard `kubectl
    logs` command. In production scenarios, you would probably use Azure Log Analytics
    or Elasticsearch for browsing logs more efficiently. To access voting application
    logs, execute the following command, which will load logs from all Pods in the
    Deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The current logging settings are quite verbose, but you can see all the log
    messages logged by Serilog to the Windows event log—for example, the preceding
    line comes from the `VotingApplicationContextFactory` class ([https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter10/01_voting-application-src/Factories/VotingApplicationContextFactory.cs#L28](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter10/01_voting-application-src/Factories/VotingApplicationContextFactory.cs#L28)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s move to the more complicated scenario, which is Visual Studio remote
    debugging via `kubectl` port forwarding. This use case is not documented yet,
    but it involves standard techniques known from non-containerized Deployments.
    We will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a dedicated Docker image for debugging that has Visual Studio 2019 remote
    tools installed ([https://docs.microsoft.com/en-us/visualstudio/debugger/remote-debugging?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/debugger/remote-debugging?view=vs-2019)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push the image to the registry with a special tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify our Deployment so that it uses the new image—for production scenarios,
    you would rather create a separate Deployment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy **program database** (**PDB**) symbol files from the container. We have
    to perform this step as building an application in the container may result in
    a slightly different output assembly and symbols.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `kubectl` port forwarding capabilities to expose the remote debugger to
    the local development machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach Visual Studio to the `w3wp.exe` process using the forwarded remote debugger.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load any missing debugging symbols.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our scenario, we are limited to the traditional Visual Studio remote debugger
    because we are running on the classic .NET Framework. For .NET Core, there are
    more approaches, which involve both Visual Studio Enterprise and Visual Studio
    Code. You can read more about Visual Studio Enterprise snapshot debugging for
    .NET Core running on Linux at [https://github.com/Microsoft/vssnapshotdebugger-docker](https://github.com/Microsoft/vssnapshotdebugger-docker),
    and  Visual Studio Code with Azure Dev Spaces at [https://microsoft.github.io/AzureTipsAndTricks/blog/tip228.html](https://microsoft.github.io/AzureTipsAndTricks/blog/tip228.html).
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by creating our modified Dockerfile for debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a debug Dockerfile and publishing a debug image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to create a debug Dockerfile, we will use our original `Dockerfile.production`
    file and perform slight modifications. The resulting file is `Dockerfile.debug`
    ([https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter10/01_voting-application-src/Dockerfile.debug](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter10/01_voting-application-src/Dockerfile.debug)).
    Let''s summarize its contents:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The build stage in the Dockerfile looks almost the same—the only difference
    is that we are using a debug configuration for the build. This will ensure that
    we have proper debug assembly generated, together with PDB symbols, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the final build stage, we first download and install Visual Studio 2019
    remote tools. We are exposing port `4020` as we are going to host the remote debugger
    using that port, as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The rest of the image remains the same except for the `ENTRYPOINT`. We modify
    it so that the remote debugger process (`msvsmon.exe`) is started in the background.
    In principle, it is not a recommended practice to start another process in the
    background in a container, but in our case, we want the quickest way to start
    the remote debugger together with other services. The syntax of this command is
    Powershell-specific, and can be seen in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'With the debug Dockerfile ready, we can create the image and push it to the
    Docker Hub. Please perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use a convention that debug images will have a `-debug` postfix
    in the tag—for example, for a production tag 1.0.0, we will use a debug tag `1.0.0-debug`.
    Another alternative would be creating a new dedicated image repository for debug
    images. To build the image, execute the following command in the root of the voting
    application source (use your own image repository name accordingly):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'When the build finishes, push the new image to Docker Hub, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: With the image pushed, we are ready to roll out a debug Deployment of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Kubernetes Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned earlier, for simplicity, we will reuse the same Kubernetes Deployment
    and service to enable debugging. We need to make the following modifications to
    our original `voting-application.yaml` manifest file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Modifying the number of replicas to `1` ensures that when debugging, we have
    only one Pod to which the traffic is redirected. This means that we can easily
    break on any action performed in the **user interface** (**UI**) using the debugger.
    On top of that, we have to update the image to our new `packtpubkubernetesonwindows/voting-application:1.0.0-debug`
    tag and set `imagePullPolicy` to `Always` to make introducing changes easier.
    For example, if you find a bug and want to quickly redeploy the image and reattach,
    you build the image with the same tag, push it, and manually delete the currently
    running Pod in the Deployment. This will recreate the Pod and thanks to the `Always`
    policy, the image will be pulled again.
  prefs: []
  type: TYPE_NORMAL
- en: Now, apply the manifest file using the `kubectl apply -f .\voting-application.yaml`
    command. Our setup is ready to attach the Visual Studio debugger.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching the Visual Studio remote debugger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The cherry on top is attaching your Visual Studio 2019 to the IIS app pool
    process using a remote debugger running inside the container. This process is
    not fully automated (but could be scripted), and it is possible to further unify
    PDB symbols between the container image and your local development machine. To
    attach the debugger, execute the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the PowerShell window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Determine the name of your application Pod using the following standard command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `kubectl cp` command to copy the `VotingApplication.pdb` file to your
    current directory, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can perform this locally using Docker by creating a temporary
    container and copying the file using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `kubectl port-forward` command to forward all traffic from your local
    `5000` port to port `4020` in your Pod—this is where the Visual Studio remote
    debugger is exposed—as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you are ready to attach Visual Studio 2019 to the remote debugger. Open
    `VotingApplication.sln` in Visual Studio, and navigate to Debug > Attach to Process...:,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/1dae82b3-48ba-4d1a-bc72-456bf4ed43ed.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the dialog, set Connection type as Remote (no authentication), set Connection
    target to the forwarded port `localhost:5000`, select Show processes from all
    users, and click the Refresh button, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/6d9f7929-e738-4a6b-bf3b-7420926c5eee.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You should see the list of all processes running in the container. If, at this
    point, you have encountered connection problems, you can execute into the container
    in Kubernetes and check if the `msvsmon.exe` process is still running. If it is
    not, you can recreate the container or start the process manually using the same
    command as in the Dockerfile, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Now, navigate in the browser to the external IP of the service. We need to ensure
    that the IIS app pool process (`w3wp.exe`) is started.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Attach to Process dialog, refresh the list of processes, find the `w3wp.exe`
    process, and click the Attach button, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/8cbca376-ce7f-4fb1-924d-b04e0a128064.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The debugger is attached, but it may have missing symbols. You can verify this
    by placing a breakpoint anywhere in the code, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/3d43baaf-6ab5-4925-a0c1-ddc793ca773f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If this is the case, to load custom PDB symbols, navigate to Debug > Windows
    > Modules, find the `VotingApplication.dll` assembly, right-click, and choose
    Load Symbols, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/d43f60c1-ee89-4bf6-bb04-ad9bd99dd386.png)'
  prefs: []
  type: TYPE_IMG
- en: Navigate to the directory where you have copied the `VotingApplication.pdb`
    file. The symbols will be loaded automatically and the breakpoint will become
    hittable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the web browser, perform the action that should cause the breakpoint to be
    hit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, depending on your connection speed, Visual Studio may freeze for a bit
    of time (even a couple of minutes) until the debugger fully attaches. But, after
    this initial hiccup, the debugging experience should be satisfying, and is shown
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/21f54b4c-d886-45ed-850a-a8cf42c10cb5.png)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations—you have successfully attached a debugger remotely to a process
    running inside a Kubernetes Pod!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned how to deploy an ASP.NET MVC application to
    a Kubernetes cluster, together with a containerized Microsoft SQL Server 2019\.
    We have shown how to approach making an existing .NET Framework application cloud-ready
    and how to create robust Dockerfiles for such applications. Next, we have prepared
    an AKS Engine cluster Deployment for our voting application and deployed Microsoft
    SQL Server 2019 in single-node failover mode, backed by Azure Disk. The application
    was deployed to the cluster using a Kubernetes Deployment and we have used a Kubernetes
    Job in order to apply EF database migrations. After that, you have learned a bit
    more about scaling the Kubernetes Deployments and overcommitting of computing
    resources. And finally, you had a deep dive into debugging .NET Framework applications
    running inside Kubernetes Pods using Visual Studio 2019's remote debugger via
    `kubectl` port forwarding.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will focus on more advanced Kubernetes features—we will extend
    our voting application to fully utilize the power of Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the possible ways to inject configuration to an application running
    in a Kubernetes Pod?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the Windows container log monitor provided by Microsoft?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is migrating database schema for replicated applications a challenging task?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are we using a persistent volume backed by Azure Disk for Microsoft SQL
    Server data?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you apply EF database migration to an application running in Kubernetes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is CPU/memory resource overcommitting in Kubernetes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do you need `kubectl` port forwarding in order to connect to a Visual Studio
    remote debugger in a container?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can find answers to these questions in the *Assessment* of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information about Kubernetes applications management, please refer
    to the following Packt books:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Complete Kubernetes Guide* ([https://www.packtpub.com/virtualization-and-cloud/complete-kubernetes-guide](https://www.packtpub.com/virtualization-and-cloud/complete-kubernetes-guide)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Getting Started with Kubernetes - Third Edition* ([https://www.packtpub.com/virtualization-and-cloud/getting-started-kubernetes-third-edition](https://www.packtpub.com/virtualization-and-cloud/getting-started-kubernetes-third-edition)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Kubernetes for Developers* ([https://www.packtpub.com/virtualization-and-cloud/kubernetes-developers](https://www.packtpub.com/virtualization-and-cloud/kubernetes-developers)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For alternative approaches to debugging applications running in Kubernetes
    clusters (for example, Telepresence), you can read the following articles:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://kubernetes.io/docs/tasks/debug-application-cluster/local-debugging/](https://kubernetes.io/docs/tasks/debug-application-cluster/local-debugging/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.telepresence.io/tutorials/kubernetes](https://www.telepresence.io/tutorials/kubernetes).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
