- en: '*Chapter 13*: Set Up a Session State Using Express and Redis'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll learn about creating session state using Express and
    the Redis data store. Redis is one of the most popular in-memory data stores.
    It is used by companies such as Twitter, GitHub, Stack Overflow, Instagram, and
    Airbnb. We'll use Express and Redis to create our session state, which will be
    the basis for our application's authentication capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding session state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Redis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building session state with Express and Redis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should have a good understanding of web development using Node.js. We will
    once again be using Node and Visual Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub repository is at [https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node](https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node).
    Use the code in the `Chap13` folder.
  prefs: []
  type: TYPE_NORMAL
- en: To set up the [*Chapter 13*](B15508_13_Final_JC_ePub.xhtml#_idTextAnchor208)
    code folder, go to your `HandsOnTypescript` folder and create a new folder called
    `Chap13`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding session state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll learn what session state is and why it's necessary. We'll
    revisit some of the concepts of how the web works and understand why we need session
    state.
  prefs: []
  type: TYPE_NORMAL
- en: The web is actually not one thing. It is a collection of many technologies.
    The core of the web is the HTTP protocol. This is the communication protocol that
    allows the web to work over the internet. A protocol is simply an agreed-upon
    set of rules for communication. This sounds somewhat straightforward, and for
    some things, it can be. However, for our application, it's a little more complicated.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP protocol is a connectionless protocol. This means that HTTP connections
    are made only at the time a request is made and then released. So, a connection
    is not maintained, even if a user is actively using a website for hours. This
    makes HTTP more scalable. However, this also means certain features that larger
    websites need are more difficult to create when using this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at a real-world example. Let's pretend we are Amazon and we
    have millions of users on our site trying to buy items. Now because people are
    trying to buy things, we need to be able to uniquely identify these users. For
    example, if we were both using Amazon at the same time and you were trying to
    add items into your cart, we would need to make sure that none of your items ended
    up in my cart and vice versa. This seems like it should be easy to do. However,
    with a connectionless protocol like HTTP, it's hard.
  prefs: []
  type: TYPE_NORMAL
- en: In HTTP, every request creates a new connection and each new request knows nothing
    about any prior requests. That is, it holds no state data. So, to go back to our
    Amazon example, this means that if a user makes a request to add an item to a
    cart, there is no built-in facility to distinguish this user's request from any
    other request. Of course, we could intervene with our own capabilities, and certainly,
    that's what we'll be discussing in this chapter. But the point is that there is
    nothing out of the box that we can just use.
  prefs: []
  type: TYPE_NORMAL
- en: To be clear, there are numerous ways of dealing with this particular issue.
    Perhaps we could give each user a unique ID and they could pass it on each call.
    Or maybe we could save session information onto the database, for example, to
    hold purchase items in a cart. And certainly, there are many more options than
    this depending on what specifically is the requirement. However, these simple
    ideas would need to be fleshed out and detailed. Then we would need to spend time
    testing them. So, realistically, wherever we can, we want to avoid rolling our
    own capabilities and, instead, we should select industry-standard solutions. If
    we use these, we know they have been tested for robustness and security and will
    use best practices.
  prefs: []
  type: TYPE_NORMAL
- en: The method we will use for distinguishing users will put the emphasis on server-side
    technology by using Express sessions and Redis as our data store. We will not
    use JWT as it is a client-side technology and is more susceptible to security
    vulnerabilities than a server-side solution.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Every solution has its pros and cons. Certainly, any server can be hacked. And
    having security solutions on a server does not guarantee anything. However, when
    it comes to your server, you can secure and control its settings to at least try
    and maximize its security. On a user's machine, you have no control at all.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about what session state is and why it's necessary.
    We learned about some of the missing features of the HTTP protocol and how we
    can provide ourselves with those capabilities. In the next section, we will continue
    by learning about Redis, the data store that we will use to maintain our session
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn about Redis and install it. We will also give
    a simple introduction to Redis and how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Redis is an in-memory data store. It is extremely fast and scalable. You can
    use Redis to store strings, lists, sets of data, and more. Thousands of companies
    use Redis and it is free and open source. In general, Redis is most often used
    as an in-memory database or cache.
  prefs: []
  type: TYPE_NORMAL
- en: For our use case, we will use Redis to act as the data store for our Express
    sessions. Redis is supported on Linux and Mac. It is not officially supported
    on Windows. You can get unofficial support by using a Docker image on Windows,
    but that is beyond the scope of this book. However, you can usually get free Linux
    VM's on cloud providers for a trial period. So if you're on Windows, you could
    try one of those services.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`Redis.conf` has a setting called bind which sets the local IP address, the
    Redis server will use as well as which external IP addresses will be allowed to
    access it. Leaving this setting commented will allow any IP address to access
    the server. This is ok for development purposes. However, once you go into production
    you should set this to a specific value and only allow the IP addresses you desire
    to have access to the server IP.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by installing Redis. Currently, I am using a Mac:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the Redis website at [https://redis.io/download](https://redis.io/download)
    and select **Download** under the stable version. Here''s a sample screenshot
    of the current 6.0.7 version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Please download a 6.0.x version as higher or lower versions may have breaking
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – Redis download'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.1_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.1 – Redis download
  prefs: []
  type: TYPE_NORMAL
- en: Once you have downloaded and successfully unzipped or unpacked the file into
    a folder, use your terminal and go to that folder. For example, this is what my
    terminal looks like after I have unpacked the tar file:![Figure 13.2 – Redis stable
    unpacked
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_13.2_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.2 – Redis stable unpacked
  prefs: []
  type: TYPE_NORMAL
- en: Now we must `make` our source files into a runnable application. Simply type
    `make` into the terminal and let it run. It will take some time to finish. The
    beginnings of the `make` command run will look like this:![Figure 13.3 – Running
    the make command
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_13.3_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.3 – Running the make command
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve built our server, feel free to move it wherever you would like.
    I moved it into my `Applications` folder. You''ll need to run this command after
    changing directories into the `Redis` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a screenshot of my local Redis server running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4 – Running Redis'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.4_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.4 – Running Redis
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: On Mac, you may get a warning asking if you want to give Redis permission to
    accept incoming network requests. You should allow this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s quickly test that Redis is working. Open a new terminal window while
    Redis is running, and from your Redis `src` folder, type this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we know our server is installed properly, we need to do some minor
    configuration. Shutdown the server first with this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'sudo password, enter your password. This is the default folder for most Redis
    configuration locations. Next, run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, now let''s restart our Redis server, but this time pointing to our new
    `redis.conf` file. Type this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: src/redis-cli
  prefs: []
  type: TYPE_NORMAL
- en: auth <password>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 13.6 – Test restart and auth of Redis'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.6_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.6 – Test restart and auth of Redis
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed what Redis is and did a basic installation of
    the Redis service. In the next section, we will be starting our backend server
    code by creating a bare-bones Node and Express server and setting up Redis-based
    session state.
  prefs: []
  type: TYPE_NORMAL
- en: Building session state with Express and Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will start building out our backend. We'll create our Express
    project and set up Redis-based session state.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand what Redis is and how to install it. Let's go over how
    Express and Redis will work together in our server. As we discussed in [*Chapter
    8*](B15508_08_Final_JC_ePub.xhtml#_idTextAnchor122), *Learning Server-Side Development
    with Node.js and Express*, Express is basically a wrapper around Node. And this
    wrapper provides additional capabilities for Node by using middleware. Session
    state is also an Express middleware.
  prefs: []
  type: TYPE_NORMAL
- en: In our application, Express will provide a session object with relevant capabilities,
    such as creating cookies on the user browser and various functions to help set
    up and maintain the session. Redis will be the data store for our session data.
    Since Redis is ultra-fast at storing and retrieving data, it is a good use case
    of Redis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now create our project using Express and Redis:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create our project folder, `super-forum-server`. Once created,
    we need to initialize it as an NPM project by running this (make sure your terminal
    is already in the `super-forum-server` folder first):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s install our dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now update our `package.json` file to use the `ts-node-dev` helper.
    This package is super useful because it also auto-restarts our server whenever
    we change any of our scripts. Add this line to the `scripts` section of `package.json`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Notice there are two dashes before `respawn`. The `index.ts` file will be our
    root file that starts our server.
  prefs: []
  type: TYPE_NORMAL
- en: Now we should set up TypeScript in our project. We've seen the TypeScript config
    file, `tsconfig.json`, many times before so I won't list it here (you can of course
    find it in our source files). But do notice that we have `target` as `ES6` and
    the production files are saved to the `./dist` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `src` folder on the root of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now let's create our `.env` file and its entries. Copy these settings into your
    own file, but use your own unique secret values:![](img/B15508_13_Table_AM.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now let''s create the `index.ts` file. Let''s create a bare-bones file first,
    just to make sure our server will run. Enter this into the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have imported Express.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are showing which environment we are on – production or development.
    If you have not set your local environment already, use this command on your terminal
    to set it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Mac, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: const app = express();
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'app.listen({ port: process.env.SERVER_PORT }, () => {'
  prefs: []
  type: TYPE_NORMAL
- en: console.log(`Server ready on port ${process.env.   SERVER_PORT}`);
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: npm start
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we know our base server is running properly, let''s add our Express
    session state and Redis:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: To start, you can see we import `expression-session` and our Redis related packages.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've initialized our `router` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `redis` object is the client to our Redis server. As you can see, we've
    hidden the values to our configuration information behind our `.env` file. You
    can imagine how unsafe it would be if we could see the passwords and other security
    information hardcoded into our code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now we've created our `RedisStore` class and the `redisStore` object, which
    we will make the data store for our Express session.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The session object gets some options. One option, `store`, is where we are adding
    our `redisStore` object. The `sameSite` value indicates that cookies from other
    domains are not allowed, which enhances security. The `secret` field is again
    a kind of password or unique ID for our specific session. The `cookie` field sets
    up our cookie that gets saved onto user browsers. The `httpOnly` field means the
    cookie is not available from JavaScript. This makes the cookie much more secure
    and can prevent XSS attacks. The `secure` field is `false` because we are not
    using HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We've set up our `router` object and our one route, which is GET. Basically,
    what we're doing is taking `userid` from the URL query string and then setting
    our user's unique `session.userid` field with it. We also count how many times
    the call was made to show that the session is being kept alive between calls.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're responding by sending the session information as a string return.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we have our `express` server listen on port 5000, which is what
    our `SERVER_PORT` is set to. As shown in the following image, the cookie gets
    created on the first load:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.8 – Two browsers showing distinct session state'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.8_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.8 – Two browsers showing distinct session state
  prefs: []
  type: TYPE_NORMAL
- en: Note that we use two browsers to show that unique sessions are created. If we
    used one browser, the sessions would not be unique as the same cookie would be
    used.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we used our knowledge of Express and Redis and implemented
    a base project for our SuperForum application. We saw the role both Express and
    Redis play in creating the session. And we saw how to use the session to create
    a unique data container for each user that comes onto our site.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about sessions and the Redis data store service.
    We also learned how to integrate Redis with Express so we can create unique sessions
    for our users. This will be critical for building our authentication services
    in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will set up our Postgres server and create our database
    schema. We will also learn about TypeOrm, which will allow us to integrate and
    use Postgres from our application. And finally, we will also build out our authentication
    service and tie it to our session state.
  prefs: []
  type: TYPE_NORMAL
