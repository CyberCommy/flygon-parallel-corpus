- en: '*Chapter 13*: Set Up a Session State Using Express and Redis'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第13章*：使用Express和Redis设置会话状态。'
- en: In this chapter, we'll learn about creating session state using Express and
    the Redis data store. Redis is one of the most popular in-memory data stores.
    It is used by companies such as Twitter, GitHub, Stack Overflow, Instagram, and
    Airbnb. We'll use Express and Redis to create our session state, which will be
    the basis for our application's authentication capabilities.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用Express和Redis数据存储创建会话状态。Redis是最流行的内存数据存储之一。它被Twitter、GitHub、Stack
    Overflow、Instagram和Airbnb等公司使用。我们将使用Express和Redis来创建我们的会话状态，这将成为我们应用程序身份验证功能的基础。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding session state
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解会话状态
- en: Understanding Redis
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Redis
- en: Building session state with Express and Redis
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Express和Redis构建会话状态
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You should have a good understanding of web development using Node.js. We will
    once again be using Node and Visual Studio Code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该对使用Node.js进行Web开发有很好的理解。我们将再次使用Node和Visual Studio Code。
- en: The GitHub repository is at [https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node](https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node).
    Use the code in the `Chap13` folder.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub存储库位于[https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node](https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node)。使用`Chap13`文件夹中的代码。
- en: To set up the [*Chapter 13*](B15508_13_Final_JC_ePub.xhtml#_idTextAnchor208)
    code folder, go to your `HandsOnTypescript` folder and create a new folder called
    `Chap13`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置[*第13章*](B15508_13_Final_JC_ePub.xhtml#_idTextAnchor208)代码文件夹，请转到您的`HandsOnTypescript`文件夹并创建一个名为`Chap13`的新文件夹。
- en: Understanding session state
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解会话状态
- en: In this section, we'll learn what session state is and why it's necessary. We'll
    revisit some of the concepts of how the web works and understand why we need session
    state.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习会话状态是什么以及为什么需要它。我们将重新审视网络工作的一些概念，并理解为什么我们需要会话状态。
- en: The web is actually not one thing. It is a collection of many technologies.
    The core of the web is the HTTP protocol. This is the communication protocol that
    allows the web to work over the internet. A protocol is simply an agreed-upon
    set of rules for communication. This sounds somewhat straightforward, and for
    some things, it can be. However, for our application, it's a little more complicated.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 网络实际上并不是一件事。它是许多技术的集合。网络的核心是HTTP协议。这是允许网络在互联网上工作的通信协议。协议只是一组用于通信的约定规则。这听起来有些简单，对于某些事情来说可能是。然而，对于我们的应用程序来说，情况就有点复杂了。
- en: The HTTP protocol is a connectionless protocol. This means that HTTP connections
    are made only at the time a request is made and then released. So, a connection
    is not maintained, even if a user is actively using a website for hours. This
    makes HTTP more scalable. However, this also means certain features that larger
    websites need are more difficult to create when using this protocol.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP协议是一种无连接的协议。这意味着HTTP连接仅在发出请求时建立，然后释放。因此，即使用户在网站上活跃使用数小时，连接也不会保持。这使得HTTP更具可伸缩性。然而，这也意味着在使用该协议时更难创建大型网站需要的某些功能。
- en: Let's take a look at a real-world example. Let's pretend we are Amazon and we
    have millions of users on our site trying to buy items. Now because people are
    trying to buy things, we need to be able to uniquely identify these users. For
    example, if we were both using Amazon at the same time and you were trying to
    add items into your cart, we would need to make sure that none of your items ended
    up in my cart and vice versa. This seems like it should be easy to do. However,
    with a connectionless protocol like HTTP, it's hard.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个现实世界的例子。假设我们是亚马逊，我们网站上有数百万用户试图购买物品。现在因为人们正在尝试购买物品，我们需要能够唯一标识这些用户。例如，如果我们同时在亚马逊上购物，您试图将物品添加到购物车中，我们需要确保您的物品不会出现在我的购物车中，反之亦然。这似乎应该很容易做到。然而，在像HTTP这样的无连接协议中，这很难。
- en: In HTTP, every request creates a new connection and each new request knows nothing
    about any prior requests. That is, it holds no state data. So, to go back to our
    Amazon example, this means that if a user makes a request to add an item to a
    cart, there is no built-in facility to distinguish this user's request from any
    other request. Of course, we could intervene with our own capabilities, and certainly,
    that's what we'll be discussing in this chapter. But the point is that there is
    nothing out of the box that we can just use.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTTP中，每个请求都会创建一个新的连接，每个新请求都不知道任何先前的请求。也就是说，它不保存状态数据。因此，回到我们的亚马逊例子，这意味着如果用户发出请求将物品添加到购物车中，没有内置的功能可以区分这个用户的请求和其他任何请求。当然，我们可以介入使用我们自己的功能，当然，这正是我们将在本章讨论的内容。但关键是，没有现成的东西可以直接使用。
- en: To be clear, there are numerous ways of dealing with this particular issue.
    Perhaps we could give each user a unique ID and they could pass it on each call.
    Or maybe we could save session information onto the database, for example, to
    hold purchase items in a cart. And certainly, there are many more options than
    this depending on what specifically is the requirement. However, these simple
    ideas would need to be fleshed out and detailed. Then we would need to spend time
    testing them. So, realistically, wherever we can, we want to avoid rolling our
    own capabilities and, instead, we should select industry-standard solutions. If
    we use these, we know they have been tested for robustness and security and will
    use best practices.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 需要明确的是，处理这个特定问题有许多方法。也许我们可以给每个用户一个唯一的ID，并且他们可以在每次调用时传递它。或者我们可以将会话信息保存到数据库中，例如将购买物品保存在购物车中。当然，根据具体的要求，还有许多其他选项。然而，这些简单的想法需要详细阐述并详细说明。然后我们需要花时间测试它们。因此，实际上，无论我们在哪里，我们都希望避免自己开发功能，并且应选择行业标准解决方案。如果我们使用这些解决方案，我们知道它们已经经过了健壮性和安全性测试，并且将使用最佳实践。
- en: The method we will use for distinguishing users will put the emphasis on server-side
    technology by using Express sessions and Redis as our data store. We will not
    use JWT as it is a client-side technology and is more susceptible to security
    vulnerabilities than a server-side solution.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Every solution has its pros and cons. Certainly, any server can be hacked. And
    having security solutions on a server does not guarantee anything. However, when
    it comes to your server, you can secure and control its settings to at least try
    and maximize its security. On a user's machine, you have no control at all.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about what session state is and why it's necessary.
    We learned about some of the missing features of the HTTP protocol and how we
    can provide ourselves with those capabilities. In the next section, we will continue
    by learning about Redis, the data store that we will use to maintain our session
    data.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Redis
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn about Redis and install it. We will also give
    a simple introduction to Redis and how it works.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Redis is an in-memory data store. It is extremely fast and scalable. You can
    use Redis to store strings, lists, sets of data, and more. Thousands of companies
    use Redis and it is free and open source. In general, Redis is most often used
    as an in-memory database or cache.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: For our use case, we will use Redis to act as the data store for our Express
    sessions. Redis is supported on Linux and Mac. It is not officially supported
    on Windows. You can get unofficial support by using a Docker image on Windows,
    but that is beyond the scope of this book. However, you can usually get free Linux
    VM's on cloud providers for a trial period. So if you're on Windows, you could
    try one of those services.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '`Redis.conf` has a setting called bind which sets the local IP address, the
    Redis server will use as well as which external IP addresses will be allowed to
    access it. Leaving this setting commented will allow any IP address to access
    the server. This is ok for development purposes. However, once you go into production
    you should set this to a specific value and only allow the IP addresses you desire
    to have access to the server IP.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by installing Redis. Currently, I am using a Mac:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the Redis website at [https://redis.io/download](https://redis.io/download)
    and select **Download** under the stable version. Here''s a sample screenshot
    of the current 6.0.7 version:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Please download a 6.0.x version as higher or lower versions may have breaking
    changes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – Redis download'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.1_B15508.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.1 – Redis download
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Once you have downloaded and successfully unzipped or unpacked the file into
    a folder, use your terminal and go to that folder. For example, this is what my
    terminal looks like after I have unpacked the tar file:![Figure 13.2 – Redis stable
    unpacked
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_13.2_B15508.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.2 – Redis stable unpacked
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Now we must `make` our source files into a runnable application. Simply type
    `make` into the terminal and let it run. It will take some time to finish. The
    beginnings of the `make` command run will look like this:![Figure 13.3 – Running
    the make command
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_13.3_B15508.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.3 – Running the make command
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve built our server, feel free to move it wherever you would like.
    I moved it into my `Applications` folder. You''ll need to run this command after
    changing directories into the `Redis` folder:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here''s a screenshot of my local Redis server running:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4 – Running Redis'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.4_B15508.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.4 – Running Redis
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: On Mac, you may get a warning asking if you want to give Redis permission to
    accept incoming network requests. You should allow this.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s quickly test that Redis is working. Open a new terminal window while
    Redis is running, and from your Redis `src` folder, type this command:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now that we know our server is installed properly, we need to do some minor
    configuration. Shutdown the server first with this command:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们知道我们的服务器已经正确安装，我们需要进行一些小的配置。首先用这个命令关闭服务器：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'sudo password, enter your password. This is the default folder for most Redis
    configuration locations. Next, run this command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: sudo密码，输入你的密码。这是大多数Redis配置位置的默认文件夹。接下来，运行这个命令：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'OK, now let''s restart our Redis server, but this time pointing to our new
    `redis.conf` file. Type this command:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，现在让我们重新启动我们的Redis服务器，但这次指向我们的新`redis.conf`文件。输入这个命令：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: src/redis-cli
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: src/redis-cli
- en: auth <password>
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: auth <password>
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![Figure 13.6 – Test restart and auth of Redis'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.6 - Redis的测试重启和auth'
- en: '](img/Figure_13.6_B15508.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.6_B15508.jpg)'
- en: Figure 13.6 – Test restart and auth of Redis
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6 - Redis的测试重启和auth
- en: In this section, we discussed what Redis is and did a basic installation of
    the Redis service. In the next section, we will be starting our backend server
    code by creating a bare-bones Node and Express server and setting up Redis-based
    session state.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们讨论了Redis是什么，并进行了Redis服务的基本安装。在下一部分中，我们将通过创建一个最基本的Node和Express服务器并设置基于Redis的会话状态来启动我们的后端服务器代码。
- en: Building session state with Express and Redis
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Express和Redis构建会话状态
- en: In this section, we will start building out our backend. We'll create our Express
    project and set up Redis-based session state.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将开始构建我们的后端。我们将创建我们的Express项目并设置基于Redis的会话状态。
- en: Now that we understand what Redis is and how to install it. Let's go over how
    Express and Redis will work together in our server. As we discussed in [*Chapter
    8*](B15508_08_Final_JC_ePub.xhtml#_idTextAnchor122), *Learning Server-Side Development
    with Node.js and Express*, Express is basically a wrapper around Node. And this
    wrapper provides additional capabilities for Node by using middleware. Session
    state is also an Express middleware.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了Redis是什么以及如何安装它。让我们来看看Express和Redis如何在我们的服务器中一起工作。正如我们在[*第8章*](B15508_08_Final_JC_ePub.xhtml#_idTextAnchor122)中讨论的那样，*使用Node.js和Express学习服务器端开发*，Express基本上是Node的一个包装器。这个包装器通过使用中间件为Node提供了额外的功能。会话状态也是Express的一个中间件。
- en: In our application, Express will provide a session object with relevant capabilities,
    such as creating cookies on the user browser and various functions to help set
    up and maintain the session. Redis will be the data store for our session data.
    Since Redis is ultra-fast at storing and retrieving data, it is a good use case
    of Redis.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，Express将提供一个具有相关功能的会话对象，比如在用户浏览器上创建cookie以及各种函数来帮助设置和维护会话。Redis将是我们会话数据的数据存储。由于Redis在存储和检索数据方面非常快速，它是Redis的一个很好的使用案例。
- en: 'Let''s now create our project using Express and Redis:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用Express和Redis创建我们的项目：
- en: 'First, we need to create our project folder, `super-forum-server`. Once created,
    we need to initialize it as an NPM project by running this (make sure your terminal
    is already in the `super-forum-server` folder first):'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建我们的项目文件夹`super-forum-server`。创建后，我们需要通过运行这个命令将其初始化为一个NPM项目（确保你的终端已经在`super-forum-server`文件夹中）：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now let''s install our dependencies:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们安装我们的依赖项：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s now update our `package.json` file to use the `ts-node-dev` helper.
    This package is super useful because it also auto-restarts our server whenever
    we change any of our scripts. Add this line to the `scripts` section of `package.json`:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们更新我们的`package.json`文件，使用`ts-node-dev`助手。这个包非常有用，因为它在我们更改任何脚本时也会自动重新启动我们的服务器。将这一行添加到`package.json`的`scripts`部分中：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice there are two dashes before `respawn`. The `index.ts` file will be our
    root file that starts our server.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在`respawn`之前有两个破折号。`index.ts`文件将是启动我们服务器的根文件。
- en: Now we should set up TypeScript in our project. We've seen the TypeScript config
    file, `tsconfig.json`, many times before so I won't list it here (you can of course
    find it in our source files). But do notice that we have `target` as `ES6` and
    the production files are saved to the `./dist` folder.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们应该在我们的项目中设置TypeScript。我们之前已经多次看到了TypeScript配置文件`tsconfig.json`，所以我不会在这里列出它（当然你可以在我们的源文件中找到它）。但请注意，我们将`target`设置为`ES6`，并且生产文件保存在`./dist`文件夹中。
- en: Create the `src` folder on the root of the project.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的根目录下创建`src`文件夹。
- en: Now let's create our `.env` file and its entries. Copy these settings into your
    own file, but use your own unique secret values:![](img/B15508_13_Table_AM.jpg)
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们创建我们的`.env`文件及其条目。将这些设置复制到你自己的文件中，但使用你自己的唯一的秘密值！[](img/B15508_13_Table_AM.jpg)
- en: 'Now let''s create the `index.ts` file. Let''s create a bare-bones file first,
    just to make sure our server will run. Enter this into the file:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们创建`index.ts`文件。首先让我们创建一个最基本的文件，只是为了确保我们的服务器能够运行。将这个输入到文件中：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we have imported Express.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经导入了Express。
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we are showing which environment we are on – production or development.
    If you have not set your local environment already, use this command on your terminal
    to set it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们展示了我们所在的环境 - 生产环境还是开发环境。如果你还没有设置你的本地环境，请在终端上使用这个命令来设置。
- en: 'For Mac, use this command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Mac，使用这个命令：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: const app = express();
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: const app = express();
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'app.listen({ port: process.env.SERVER_PORT }, () => {'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 'app.listen({ port: process.env.SERVER_PORT }, () => {'
- en: console.log(`Server ready on port ${process.env.   SERVER_PORT}`);
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: console.log(`服务器已准备就绪，端口为${process.env.   SERVER_PORT}`);
- en: '});'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: npm start
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: npm start
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now that we know our base server is running properly, let''s add our Express
    session state and Redis:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们知道我们的基本服务器已经正确运行，让我们添加我们的Express会话状态和Redis：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To start, you can see we import `expression-session` and our Redis related packages.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以看到我们导入了`expression-session`和我们的与Redis相关的包。
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we've initialized our `router` object.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们初始化了我们的`router`对象。
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `redis` object is the client to our Redis server. As you can see, we've
    hidden the values to our configuration information behind our `.env` file. You
    can imagine how unsafe it would be if we could see the passwords and other security
    information hardcoded into our code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`redis`对象是我们的Redis服务器的客户端。正如你所看到的，我们已经将配置信息的值隐藏在我们的`.env`文件后面。你可以想象一下，如果我们能够看到密码和其他安全信息硬编码到我们的代码中，那将是多么不安全。'
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now we've created our `RedisStore` class and the `redisStore` object, which
    we will make the data store for our Express session.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The session object gets some options. One option, `store`, is where we are adding
    our `redisStore` object. The `sameSite` value indicates that cookies from other
    domains are not allowed, which enhances security. The `secret` field is again
    a kind of password or unique ID for our specific session. The `cookie` field sets
    up our cookie that gets saved onto user browsers. The `httpOnly` field means the
    cookie is not available from JavaScript. This makes the cookie much more secure
    and can prevent XSS attacks. The `secure` field is `false` because we are not
    using HTTPS.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We've set up our `router` object and our one route, which is GET. Basically,
    what we're doing is taking `userid` from the URL query string and then setting
    our user's unique `session.userid` field with it. We also count how many times
    the call was made to show that the session is being kept alive between calls.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we're responding by sending the session information as a string return.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And finally, we have our `express` server listen on port 5000, which is what
    our `SERVER_PORT` is set to. As shown in the following image, the cookie gets
    created on the first load:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.8 – Two browsers showing distinct session state'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.8_B15508.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.8 – Two browsers showing distinct session state
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Note that we use two browsers to show that unique sessions are created. If we
    used one browser, the sessions would not be unique as the same cookie would be
    used.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we used our knowledge of Express and Redis and implemented
    a base project for our SuperForum application. We saw the role both Express and
    Redis play in creating the session. And we saw how to use the session to create
    a unique data container for each user that comes onto our site.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about sessions and the Redis data store service.
    We also learned how to integrate Redis with Express so we can create unique sessions
    for our users. This will be critical for building our authentication services
    in later chapters.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will set up our Postgres server and create our database
    schema. We will also learn about TypeOrm, which will allow us to integrate and
    use Postgres from our application. And finally, we will also build out our authentication
    service and tie it to our session state.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
