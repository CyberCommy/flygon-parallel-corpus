- en: Spring Best Practices and Bean Wiring Configurations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how Spring Framework implements the **Inversion
    of Control** (**IoC**) principle. Spring IoC is the mechanism to achieve loose
    coupling between object dependencies. A Spring IoC container is the program that
    injects dependencies into an object and makes it ready for our use. Spring IoC
    is also known as dependency injection. In Spring, the objects of your application
    are managed by the Spring IoC container and are also known as **beans**. A bean
    is an object that is instantiated, assembled, and managed by a Spring IoC container.
    So, a Spring container is responsible for creating the beans in your application
    and coordinating the relationships between those objects via dependency injection.
    But, it is the developer's responsibility to tell Spring which beans to create
    and how to configure them together. When it comes to conveying a bean wiring configuration,
    Spring is very flexible, offering different writing configurations.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we first start exploring different bean wiring configurations.
    This includes a configuration with Java, XML, and annotations, and also learning
    different best practices of bean wiring configuration. We will also understand
    the performance assessment with different configurations, as well as dependency
    injection pitfalls.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection configurations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance assessment with different configurations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency injection pitfalls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency injection configurations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In any application, objects collaborate with other objects to perform some useful
    task. This relationship between one object and another in any application creates
    a dependency, and such dependencies between objects create tight-coupled programming
    in the application. Spring provides us with a mechanism to convert tight-coupled
    programming to loosely-coupled programming. This mechanism is called **dependency
    injection** (**DI**). DI is a concept or design pattern that describes how to
    create loosely-coupled classes where objects are designed in a manner where they
    receive instances of the objects from other pieces of code, instead of constructing
    them internally. This means that objects are given their dependencies at runtime,
    rather than compile time. So, with DI, we can get a decoupled structure that offers
    us simplified testing, greater reusability, and improved maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will learn about different types of DI configurations,
    which you can use in any of the configurations in your application, as per business
    requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Types of DI patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Spring, the following types of DI are performed:'
  prefs: []
  type: TYPE_NORMAL
- en: Constructor-based DI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setter-based DI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Field-based DI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will learn more about these in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor-based DI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Constructor-based DI** is a design pattern to resolve the dependencies of
    a dependent object. In a constructor-based DI, a constructor is used to inject
    a dependent object. It is accomplished when the container invokes a constructor
    with a number of arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following example for a constructor-based DI. In the following
    code, we show how to use a constructor for injecting a `CustomerService` object
    in a `BankingService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the content of another dependent class file, `CustomerServiceImpl.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The content for the `CustomerService.java` interface is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Advantages of the constructor-based DI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the advantages of a constructor-based DI in your Spring application:'
  prefs: []
  type: TYPE_NORMAL
- en: It's suitable for mandatory dependencies. In a constructor-based DI, you can
    be sure that the object is ready to be used the moment it is constructed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code structure is very compact and clear to understand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you need an immutable object then, through constructor-based dependency,
    you can ensure you get the immutable nature of the object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disadvantages of the constructor-based DI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The only disadvantage of the constructor-based injection is that it may cause
    **circular dependency** between objects. Circular dependency means two objects
    depend on each other. For resolving that, we should use a setter injection instead
    of a constructor injection.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see a different type of DI in Spring, which is a setter-based injection.
  prefs: []
  type: TYPE_NORMAL
- en: Setter-based DI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a constructor-based DI, we saw a dependent object injecting through a constructor
    argument. In a setter-based DI, the dependent object is provided by a setter method
    in the dependent class. Setter-based DI is accomplished by calling setter methods
    on beans after invoking `no-args` constructors through the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we show how to use a setter method for injecting a `CustomerService`
    object in the `BankingService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Advantages of the setter-based DI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the advantages of the setter-based DI in your Spring application:'
  prefs: []
  type: TYPE_NORMAL
- en: It's more readable than the constructor injection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is useful for non-mandatory dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It solves the circular dependency problem in the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It helps us to inject the dependency only when it is required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's possible to reinject dependencies. It is not possible in a constructor-based
    injection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disadvantages of the setter-based DI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although the setter-based DI has higher priority than the constructor-based
    DI, the following are the disadvantages of the former:'
  prefs: []
  type: TYPE_NORMAL
- en: There is no guarantee in a setter-based DI that the dependency will be injected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One can use a setter-based DI to override another dependency. This can cause
    security issues in a Spring application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Field-based DI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding sections, we saw how we can use constructor-based and setter-based
    dependencies in our application. In the following example, we will see field-based
    DI. Actually, field-based DI is easy to use, and it has clean code compared to
    the other two types of injection method; however, it has several serious trade-offs,
    and should generally be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following example of a field-based DI. In the following
    code, we will see how to use a field for injecting a `CustomerService` object
    in the `BankingService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As we discussed, this type of DI has the benefit of removing clutter code over
    setter-or constructor-based dependencies, but it has many drawbacks, such as dependencies
    are invisible from the outside. In constructor-based and setter-based dependencies,
    classes clearly expose these dependencies using the `public` interface or setter
    method. In a field-based DI, the class is inherently hiding the dependencies from
    the outside world. Another difficulty is that field injection cannot be used to
    assign dependencies to final/immutable fields, as these fields must be instantiated
    at class instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, Spring discourages the use of the field-based dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a diagram with the different types of DI that we have learned about
    so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bea0510f-e8d3-431c-b814-6f80cd876106.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Constructor versus setter injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we can see, Spring supports three types of DI methods; however, field-based
    dependency is not recommended by Spring. So, constructor-based and setter-based
    DI are standard ways to injecting beans in your application. The selection of
    constructor or setter methods depends on your application requirements. In this
    table, we will see the different use cases of constructor and setter injection,
    and some best practices that will help us decide when to use setter injection
    over constructor injection, and vice versa:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Constructor injection** | **Setter injection** |'
  prefs: []
  type: TYPE_TB
- en: '| Best choice when the dependency is mandatory. | The suitable choice when
    the dependency is not mandatory. |'
  prefs: []
  type: TYPE_TB
- en: '| Constructor injection makes the bean class object immutable. | Setter injection
    makes the bean class object mutable. |'
  prefs: []
  type: TYPE_TB
- en: '| Constructor injection cannot override setter injected values. | Setter injection
    overrides the constructor injection when we use both constructor and setter injection
    for the same property. |'
  prefs: []
  type: TYPE_TB
- en: '| Partial dependencies are not possible with constructor injection because
    we must pass all the arguments in the constructor, otherwise, it gives an error.
    | Partial dependency is possible with setter injection. Suppose we have three
    dependencies, such as `int`, `string`, and `long`, then with the help of a setter
    injection, we can inject only the required dependency; other dependencies will
    be taken as a default value of those primitives. |'
  prefs: []
  type: TYPE_TB
- en: '| Creates a circular dependency between objects. | Resolves circular dependency
    issue in your application. In case of circular dependency, it is better to use
    a setter instead of constructor injection. |'
  prefs: []
  type: TYPE_TB
- en: Configuring the DI with Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn different types of processes to configure the
    DI. The following diagram is a high-level view of how the configuration process
    works in Spring:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e100f5df-acc2-4ed3-aed8-c99f18d498a0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As per the preceding diagram, the Spring container is responsible for creating
    the bean in your application and building relationships between those beans via
    the DI pattern; however, as we discussed earlier, it's the developer's responsibility
    to tell the Spring container, through the metadata, how to create beans and how
    to wire them together.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are three techniques to configure the metadata of your application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'XML-based configuration: An explicit configuration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Java-based configuration: An explicit configuration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Annotation-based configuration: An implicit configuration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Spring Framework, the preceding three types of configuration mechanisms are
    available, but you must use one of the configuration processes to wire your bean.
    In the next section, we will see each of the configuration techniques in detail
    with examples, and also see which technique in each situation or condition is
    more suitable than others; however, you can use any technique or approach that
    suits you best.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now see the DI pattern with an XML-based configuration in detail.
  prefs: []
  type: TYPE_NORMAL
- en: XML-based configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **XML-based configuration** has been the primary configuration technique
    since Spring started. In this section, we will see the same example as we discussed
    in the DI pattern, and see how the `CustomerService` object is injected in the
    `BankingService` class through an XML-based configuration.
  prefs: []
  type: TYPE_NORMAL
- en: For an XML-based configuration, we need to create an `applicationContext.xml`
    file with a `<beans>` element. The Spring container must be able to manage one
    or more beans in the application. Beans are described using the `<bean>` element
    inside a top-level `<beans>` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the `applicationContext.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding XML file is the basic structure of XML-based configuration metadata
    where we need to define our bean configuration. As we learned earlier, our bean
    configuration pattern may be constructor-based or setter-based, depending on the
    application requirement. Now, we will see how we can configure a bean using both
    design patterns, one by one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the example of a constructor-based DI with an XML-based configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we have injected the `CustomerService` object in the
    `BankingServices` class with a constructor DI pattern. The `ref` attribute of
    the `</constructor-arg>` element is used to pass the reference of the `CustomerServiceImpl`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the example of a setter-based DI with an XML-based configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `ref` attribute of the `</property>` element is used to pass the reference
    of the `CustomerServiceImpl` object to the setter method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the content of the `MainApp.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Java-based configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we saw how to configure a bean using XML-based configuration.
    In this section, we will see the Java-based configuration. The same as XML, Java-based
    configuration also injects dependency explicitly. The following example defines
    the Spring bean and its dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Java-based configuration, we must annotate the class with `@Configuration`,
    and the declaration of the bean can be achieved with the `@Bean` annotation. The
    previous example of a Java-based configuration is equivalent to an XML-based configuration,
    as per the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous `AppConfig` class is annotated with the `@Configuration` annotation,
    which describes that it is a configuration class of the application that contains
    the details on bean definitions. The method is annotated with the `@Bean` annotation
    to describe that it is responsible for instantiating, configuring, and initializing
    a new bean is to be managed by the Spring IoC container. In the Spring container,
    each bean has a unique ID. Whichever method is annotated with `@Bean` then, by
    default, that method name will be the bean ID; however, you can also override
    that default behavior using the `name` attribute of the `@Bean` annotation, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The Spring application context will load the `AppConfig` file and create beans
    for the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the `MainApp.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Annotation-based configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we saw the two bean configuration techniques, Java-based
    and XML-based. Both the techniques inject dependency explicitly. In Java-based,
    we use the `@Bean` annotated method in the `AppConfig` Java file whereas, in XML-based,
    we use the `<bean>` element tag in the XML configuration file. **Annotation-based
    configuration** is another way of creating a bean, where we can move the bean
    configuration into the component class itself using annotations on the relevant
    class, method, or field declaration. Here, we will look at how we can configure
    a bean through annotation, and the different annotations available in Spring Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Annotation-based configuration is turned off by default in Spring, so first,
    you have to turn it on by entering the `<context:annotation-config/>` element
    into the Spring XML file shown as follows. After adding it, you are ready to use
    annotations in your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The changes required to be made in `applicationContext.xml` (as we have used
    it the earlier section) are highlighted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: An XML-based configuration will override annotations because an XML-based configuration
    will be injected after annotations.
  prefs: []
  type: TYPE_NORMAL
- en: The previous XML-based configuration shows that once you configure the `<context:annotation-config/>`
    element, it indicates start of annotating your code. Spring should automatically
    scan the package defined in `<context:component-scan base-package=".." />` and
    identify beans and wire them based on the pattern. Let's understand a few of the
    important annotations, and how they work.
  prefs: []
  type: TYPE_NORMAL
- en: The @Autowired annotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `@Autowired` annotation injects object dependency implicitly. We can use
    the `@Autowired` annotation on a constructor-setter-and field-based dependency
    pattern. The `@Autowired` annotation indicates that auto wiring should be performed
    for this bean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of using the `@Autowired` annotation on a constructor-based
    dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we have `BankingService` that has a dependency of `CustomerService`.
    Its constructor is annotated with `@Autowired`, indicating that Spring instantiates
    the `BankingService` bean using an annotated constructor and passes the `CustomerService`
    bean as a dependency of the `BankingService` bean.
  prefs: []
  type: TYPE_NORMAL
- en: Since Spring 4.3, the `@Autowired` annotation became optional on classes with
    a single constructor. In the preceding example, Spring would still inject an instance
    of the `CustomerService` class if you skipped the `@Autowired` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of using the `@Autowired` annotation on a setter-based
    dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we saw that the setter method `setCustomerService`
    is annotated with the `@Autowired` annotation. Here, the annotation resolves the
    dependency by type. The `@Autowire` annotation can be used on any traditional
    setter method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of using the `@Autowired` annotation on a field-based
    dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As per the preceding example, we can see that the `@Autowire` annotation can
    be added on public and private properties as well. Spring uses the reflection
    API to inject the dependencies when added on the property, and that is the reason
    private properties can also be annotated.
  prefs: []
  type: TYPE_NORMAL
- en: '@Autowired with required = false'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, the `@Autowired` annotation implies that the dependency is required.
    This means an exception will be thrown when a dependency is not resolved. You
    can override that default behavior using the `(required=false)` option with `@Autowired`.
    Let''s see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, if we set the `required` value as `false`, then at the
    time of bean wiring, Spring will leave the bean unwired if the dependency is not
    resolved. As per Spring's best practices, we should avoid setting `required` as
    `false` until it is absolutely required.
  prefs: []
  type: TYPE_NORMAL
- en: The @Primary annotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, in Spring Framework, DI is done by type, which means that when
    there are multiple dependencies with the same type, the `NoUniqueBeanDefinitionException`
    exception will be thrown. It indicates that the Spring container is unable to
    select a bean for DI because of more than one eligible candidate. In that case,
    we can use the `@Primary` annotation and take control of the selection process.
    Let''s see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of the previous example, there are two customer services available:
    `BankingService` and `AccountService`. Due to the `@Primary` annotation, components
    can only use `BankingService` to wire dependencies on `CustomerService`.'
  prefs: []
  type: TYPE_NORMAL
- en: The @Qualifier annotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Handling multiple autowire candidates with `@Primary` is more effective when
    only one primary candidate can be determined for multiple autowire candidates.
    The `@Qualifier` annotation gives you more control over the selection process.
    It allows you to give a reference associated with a specific bean type. That reference
    can be used to qualify the dependency that needs to be autowired. Let''s look
    at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, there are two customer services available: `BankingService` and
    `AccountService`; however, due to `@Qualifier("bankingservice")` being used in
    the `SomeService` class, `BankingService` will be selected for auto wiring.'
  prefs: []
  type: TYPE_NORMAL
- en: Automatic bean detection with stereotype annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we learned about the `@Autowired` annotation that handles
    only wiring. You still have to define the beans themselves so the container is
    aware of them and can inject them for you. Spring Framework provides us with some
    special annotations. These annotations are used to create Spring beans automatically
    in the application context. So, there is no need to configure the bean explicitly
    either using XML-based or Java-based configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the stereotype annotations in Spring:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Component`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Service`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Repository`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Controller`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at the following `CustomerService` implementation class. Its implementation
    is annotated with `@Component`. Please refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, the `CustomerServiceImpl` class is annotated with the
    `@Component` annotation. This means the class that is marked with the `@Component`
    annotation is considered the bean, and the component-scanning mechanism of Spring
    scans that class, creates a bean of this class, and pulls it into the application
    context. So, no need to configure that class explicitly as the bean is either
    using XML or Java. Spring automatically creates the bean of the `CustomerServiceImpl`
    class because it is annotated with `@Component`.
  prefs: []
  type: TYPE_NORMAL
- en: In Spring, `@Service`, `@Repository`, and `@Controller` are meta annotations
    for the `@Component` annotation. Technically, all annotations are the same and
    provide the same result, such as creating a bean in Spring context; but we should
    use more specific annotations at different layers of the application because it
    specifies the intent better, and additional behavior might rely on it in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram describes the stereotype annotation with an appropriate
    layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e80ec68-52cd-4858-ab10-860971c21d6e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As per the previous example, `@Component` is good enough to create a bean of
    `CustomerService`. But `CustomerService` is a service layer class, so as per bean
    configuration best practices, we should use `@Services` instead of the generic
    annotation `@Component`. Let''s look at the following code for the same class
    annotated with the `@Service` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see another example of the `@Repository` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, the class is annotated with the `@Repository` annotation
    because the `CustomerRepository` interface is working at the **Data Access Object**
    (**DAO**) layer of the application. As per bean configuration best practices,
    we have used the `@Repository` annotation instead of the `@Component` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a real-life scenario, you might face very rare situations where you will
    need to use the `@Component` annotation. Mostly, you will be using the `@Controller`, `@Service`,
    and `@Repository` annotations. `@Component` should be used when your class does
    not fall into either of three categories: service, controller, DAO.'
  prefs: []
  type: TYPE_NORMAL
- en: The @ComponentScan annotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring needs to know which packages contain Spring beans, otherwise, you would
    have to register each bean individually. That''s what `@ComponentScan` is used
    for. In Spring, component scanning is not enabled by default. We need to enable
    it with the `@ComponentScan` annotation. This annotation is used with the `@Configuration`
    annotation to allow Spring to know the packages to scan for annotated components
    and to create beans from them. Let''s look at the following simple example of
    `@ComponentScan`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `@ComponentScan` annotation, if the `basePackages` attribute is not
    defined, then scanning will occur from the package of the class that declares
    this annotation. In the preceding example, Spring will scan all classes of `com.packt.springhighperformance.ch2.bankingapp.model`,
    and the subpackage of that package. The `basePackages` attribute can accept an
    array of strings, which means that we can define multiple base packages to scan
    component classes in the application. Let''s look at an example of how we can
    declare multiple packages in the `basePackage` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The @Lazy annotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, all autowired dependencies are created and initialized at startup,
    meaning the Spring IoC container creates all beans at the time of application
    startup; however, we can control this pre-initialization of beans at startup by
    using the `@Lazy` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Lazy` annotation may be used on any class directly or indirectly annotated
    with `@Component`, or on methods annotated with `@Bean`. When we use the `@Lazy`
    annotation, that means the bean will be created and initialized only when it is
    first requested.
  prefs: []
  type: TYPE_NORMAL
- en: We know that annotation requires less code because we don't need to write the
    code to inject the dependency explicitly. It helps us reduce the development time,
    as well. Though annotation offers lots of advantages, it has its drawback, as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Disadvantages of annotation are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Less documentation than explicit wiring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we have a lot of dependency in a program, then it's hard to find it by using
    the `autowire` attribute of bean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Annotation makes the process of debugging hard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It might give unexpected results in case of ambiguity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Annotation can be overridden by explicit configuration, such as Java or XML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring bean scopes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we learned various DI patterns, and saw how to create
    beans in a Spring container. We also learned various DI configuration such as
    XML, Java, and annotation. In this section, we will learn more details about bean
    life and scope available in a Spring container. The Spring container allows us
    to control the bean at configuration level. This is a very flexible way to define
    object scope at configuration level, instead of at the Java-class level. In Spring,
    the bean is controlled through the `scope` attribute that defines what kind of
    object has to be created and returned. When you describe `<bean>`, you have the
    option of defining `scope` for that bean. The bean `scope` describes the life
    cycle and visibility of that bean in the context of where it used. In this section,
    we will see the different types of bean `scope` in Spring Framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of defining bean `scope` at XML-based configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of defining bean `scope` using the `@Scope` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use a constant instead of the string value in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Following are bean scopes available in Spring Framework:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `singleton` bean `scope`: As we saw in the previous example of bean configuration
    in XML-based, if `scope` is not defined in the configuration, then the Spring
    container considers `scope` as `singleton`. The Spring IoC container creates exactly
    only one single instance of the object, even if there are multiple references
    to a bean. Spring stores all `singleton` bean instances in a cache, and all subsequent
    requests of that named bean return the cached object. This is needed to understand
    that the Spring bean `singleton` `scope` is a little different from the typical
    `singleton` design pattern that we are using in Java. In Spring `singleton`, `scope`
    creates one object of that bean per one Spring container, meaning if there are
    multiple Spring containers in single JVM then multiple instances of that bean
    will be created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `prototype` bean `scope`: When `scope` is set to `prototype`, the Spring
    IoC container creates a new bean instance of object every time a bean is requested.
    Prototype-scoped beans are mostly used for stateful beans.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a rule, use `prototype` `scope` for all stateful beans, and the `singleton`
    `scope` for stateless beans.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `request` bean `scope`: The `request` bean `scope` is only available in
    a web-aware application context. The `request` `scope` creates a bean instance
    for each HTTP request. The bean is discarded as soon as the request processing
    is done.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `session` bean `scope`: The `session` bean `scope` is only available in
    a web-aware application context. The `session` `scope` creates a bean instance
    for every HTTP session.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `application` bean `scope`: The `application` bean `scope` is only available
    in a web-aware application context. The `application` `scope` creates a bean instance
    per web application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance assessment with different configurations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how different types of bean configuration impact
    application performance, and also we will see the best practices of bean configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how the `@ComponentScan` annotation configuration impacts the startup
    time of a Spring application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As per the preceding configuration, Spring will scan all the packages of `com`
    and `org` and, because of that, the startup time of the application will be increased.
    So, we should scan only those packages that have annotated classes, as non-annotated
    classes will take time to scan. We should use only one `@ComponentScan` and list
    all packages, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding configuration is considered as a best practice of defining the
    `@ComponentScan` annotation. We should specify which of those packages as `basePackage`
    attribute have annotated classes. It will reduce the startup time of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy loading versus preloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Lazy loading** ensures that beans are loaded on the fly when requested, and
    **preloading** ensures the beans are loaded before they are used. The Spring IoC
    container uses preloading by default. So, loading all classes at the start even
    if they''re not used would not be a wise decision because some Java instances
    would be highly resource-consuming. We should use the required methodology based
    on the application requirement.'
  prefs: []
  type: TYPE_NORMAL
- en: If we need to load our application as fast as possible, then go for lazy loading.
    If we need our application to run as fast as possible and serve a client request
    faster, then go for preloading.
  prefs: []
  type: TYPE_NORMAL
- en: Singleton versus prototype bean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Spring, by default, all beans defined are `singleton`; however, we can change
    the default behavior and make our bean `prototype`. When the bean `scope` is set
    to `prototype`, the Spring IoC container creates a new bean instance of an object
    every time a bean is requested. Prototype beans incur a hit on performance during
    creation, so when a `prototype` bean uses resources, such as network and database
    connection, it should be avoided completely; alternatively, design the action
    carefully.
  prefs: []
  type: TYPE_NORMAL
- en: Spring bean configuration best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will see some of the best practices for configuring a bean
    in Spring:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use ID as bean identifiers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we identified the bean using `id` or `name`. We should
    use `id` to pick the bean instead of `name`. Usually, it does neither increase
    readability nor benefit any performance but it's just an industry standard practice
    which we need to follow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prefer `type` over `index` for constructor argument matching. The constructor
    argument with `index` attribute is shown as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor argument with the `type` attribute is shown as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As per the previous example, we can use `index` or `type` as a constructor argument.
    It is better to use the `type` attribute instead of `index` in a constructor argument
    because it is more readable and less error-prone. But sometimes, type-based arguments
    might create an ambiguity problem when a constructor has more than one argument
    of the same `type`. In that case, we need to use `index` or a name-based argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use dependency check at the development phase: In bean definition, we should
    use the `dependency-check` attribute. It ensures that the container performs explicit
    dependency validation. It is useful when all or some of the properties of a bean
    must be set explicitly, or through auto wiring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Do not specify version numbers in Spring schema references: in Spring configuration
    files, we specify the schema reference for different Spring modules. In schema
    references, we mention the XML namespace and its version number. Specifying the
    version number is not mandatory in the configuration file, so you can skip it.
    In fact, you should skip it all the time. Consider it as a best practice to follow.
    Spring automatically picks the highest version from the project dependencies (`jars`).
    A typical Spring configuration file looks like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'As per best practices, this can be written like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a header comment to each configuration file; it is preferred to add a configuration
    file header that describes the beans defined in the configuration files. The code
    of the `description` tag is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The advantages of the `description` tag is that some tools may catch up the
    description from this tag to help you in other places.
  prefs: []
  type: TYPE_NORMAL
- en: DI pitfalls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we know, there are three DI patterns in the Spring application: constructor-setter-and
    field-based. Each type has different advantages and disadvantages. Only field-based
    DI is an incorrect approach and not even recommended by Spring.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is an example of a field-based injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As per Spring bean best practices, we should not use field-based dependency
    in our Spring application. The main reason is that it is impossible to test without
    Spring context. As we cannot supply the dependency from outside, it will not be
    possible to instantiate the object independently. As per my opinion, this is the
    only problem with field-based injections.
  prefs: []
  type: TYPE_NORMAL
- en: As we learned in an earlier section, constructor-based dependency is more suitable
    for mandatory fields, and we can ensure the immutable nature of the object is
    obtained; however, the main drawback of a constructor-based dependency is that
    it creates circular dependency in your application, and as per Spring documentation, *it
    is generally recommended to not rely on circular dependency between your beans*.
    So, now we have questions like, *Why not rely on circular dependency?* and *What
    will happen if we have a circular dependency in our application?* So, the answer
    to these questions is that it may create two significant and unfortunately silent
    pitfalls. Let's discuss them.
  prefs: []
  type: TYPE_NORMAL
- en: First pitfall
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you call the `ListableBeanFactory.getBeansOfType()` method, you cannot
    be sure which beans will be returned. Let''s look at the code of the `getBeansOfType()`
    method in the `DefaultListableBeanFactory.java` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, you can see that the `getBeansOfType()` method silently
    skips beans under creation, and only returns those already existing. So, when
    you have circular dependency between beans, use of the `getBeansOfType()` method
    during container startup is not recommended. This is because, as per the preceding
    code, if you are not using `DEBUG` or `TRACE` logging-level, then there will be
    zero information in your log that Spring skipped a particular bean which is under
    creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the preceding pitfall with the following example. As per the following
    diagram, we have three beans, `Account`, `Customer`, and `Bank`, and a circular
    dependency between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b0560f4b-859f-43c4-9123-049775d2d115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As per the preceding diagram, the following is the `Account`, `Customer`, and
    `Bank` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is the `Main` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is the log where we can show how Spring internally loads beans and
    resolves classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Spring Framework first loads `Account` and tries to instantiate a bean; however,
    when running `getBeansOfType(Customer.class)`, it discovers `Customer`, so proceeds
    with loading and instantiating that one. Inside `Customer`, we can immediately
    spot the problem: when `Customer` asks for `beanFactory.getBeansOfType(Account.class)`,
    it gets no results (`[]`). Spring will silently ignore `Account` because it''s
    currently under creation. You can see here that after `Bank` is loaded, everything
    is as expected.'
  prefs: []
  type: TYPE_NORMAL
- en: Here now we can understand that, we cannot predict the output of the `getBeansOfType()`
    method when we have a circular dependency. However, we can avoid it with using
    DI properly. In circular dependency, `getBeansOfType()` gives different results,
    based on factors and we have no any control over it.
  prefs: []
  type: TYPE_NORMAL
- en: Second pitfall (with AOP)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will learn AOP in detail in the following chapter. Right now, we are not
    covering this pitfall in detail. I just want you to understand that if you have
    `Aspect` on a bean, then make sure there is no circular dependency between beans;
    otherwise, Spring will create two instances of that bean, one without `Aspect`
    and the other with a proper aspect, without informing you.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about DI, which is the key feature of Spring Framework.
    DI helps us to make our code loosely coupled and testable. We learned various
    DI patterns, including constructor-setter-and field-based. We can use any of the
    DI patterns in our application based on our requirement, as each type has its
    own advantages and disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned how we can configure DI explicitly and implicitly. We can inject
    dependency explicitly with the use of XML-based and Java-based configuration.
    Annotation is used to inject dependency implicitly. Spring provides us with a
    special type of annotation called **stereotype annotation**. Spring will automatically
    register the class which annotated with stereotypes annotation. This makes the
    class available for DI in other classes and this become vital to building out
    our applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be looking at the Spring AOP module. AOP is a powerful
    programming model that helps us to implement the reusable code.
  prefs: []
  type: TYPE_NORMAL
