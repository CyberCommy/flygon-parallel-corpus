- en: '*Chapter 6*'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JavaScript Ecosystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Compare the different JavaScript ecosystems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explain the basic concepts of server-side JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a Node.js and Express server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a React frontend website
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combine a frontend framework with a backend server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final chapter covers the JavaScript Ecosystem in detail, and teaches the
    students how to work with different features and sections of Node.js, as well
    as the Node Package Manager (NPM).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**In** *Chapter 5, Functional Programming*, we covered the **Functional Programming
    paradigm**. We covered **Object Oriented Programming** and Functional Programming,
    discussed the differences between the two, and outlined the reasons why we should
    use functional programming. In the second section, we discussed the key concepts
    of functional programming and demonstrated how they are applied to JavaScript
    code.'
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript ecosystem has grown immensely over the past 10+ years. JavaScript
    is no longer a programming language to be used for adding flair, such as animations,
    on top of a basic HTML web page. JavaScript can now be used to build full backend
    web servers and services, command-line interfaces, mobile apps, and frontend sites.
    In this chapter, we will introduce the JavaScript ecosystem, discuss building
    web servers in JavaScript with Node.js, and discuss building websites with JavaScript
    using the React framework.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript Ecosystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are four main categories of the JavaScript ecosystem that we will discuss:
    **frontend**, **command-line** **interface**, **mobile**, and **backend**.'
  prefs: []
  type: TYPE_NORMAL
- en: Front-end JavaScript is used for user-facing websites.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command-line interface (CLI) JavaScript is used for building command-line tasks
    to assist developers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mobile development JavaScript is used to build mobile phone apps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backend JavaScript is used to build web servers and services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a language that was created originally to embed simple applications in browsers,
    JavaScript has come a long way.
  prefs: []
  type: TYPE_NORMAL
- en: Frontend JavaScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Frontend JavaScript** is used for creating complicated and dynamic user-facing
    websites. Websites such as Facebook, Google Maps, Spotify, and YouTube rely heavily
    on JavaScript. In frontend development, JavaScript is used to manipulate the DOM
    and handle events. Many JavaScript libraries, such as jQuery, have been created
    to increase the efficiency and ease of JavaScript DOM manipulation by wrapping
    the DOM manipulation APIs of each browser into a standardized API. The most prevalent
    DOM manipulation library is jQuery, which was discussed in *Chapter 3, DOM Manipulation
    and Event Handling*. JavaScript frameworks have also been created to more seamlessly
    integrate DOM manipulation and events with the HTML design aspect. Two of the
    most common JavaScript frameworks for frontend development are **AngularJS** and
    **React**. AngularJS was built by and is maintained by Google, and React was built
    by and is maintained by Facebook.'
  prefs: []
  type: TYPE_NORMAL
- en: Facebook and Google manage bug fixes and version releases for their respective
    frameworks. React will be discussed in more detail in a later section of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Command-Line Interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Command-line integration (CLI)** JavaScript is generally used to create utilities
    to assist developers with repetitive or time-intensive tasks. CLI programs in
    JavaScript are generally used for tasks such as linting code, starting a server,
    building releases, transpiling code, minifying files, and installing development
    dependencies and packages. JavaScript CLI programs are generally written in Node.js.
    Node.js is a cross-platform environment that allows developers to execute JavaScript
    code outside a browser. Node.js will be discussed in more detail in a later section
    of this chapter. Many developers rely on CLI utilities in their day-to-day development.'
  prefs: []
  type: TYPE_NORMAL
- en: Mobile Development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Mobile development** with JavaScript is quickly becoming mainstream. Since
    the rise of smartphones, mobile developers have become a hot commodity. While
    JavaScript cannot be run natively on most mobile operating systems, frameworks
    exist that allow JavaScript and HTML to be built into Android and IOS phone apps.
    The most common frameworks for JavaScript mobile development are Ionic, React
    Native, and Cordova/PhoneGap. These frameworks all allow you to write JavaScript
    to build the framework and logic of an application and then compile the JavaScript
    down to the native mobile operating system code. Mobile development frameworks
    are very powerful because they allow us to build full mobile applications in our
    preferred JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: Backend Development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Backend development** with JavaScript is generally done with Node.js. Node.js
    can be used to build powerful web servers and services. As stated earlier in this
    topic, Node.js and its application to backend server development will be discussed
    in more detail in a later section of this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript ecosystem is very extensive. It is possible to write nearly any
    sort of program in JavaScript. Despite the number of frameworks and the capabilities
    of modern JavaScript, it is important to remember that a framework does not replace
    a good understanding of core JavaScript. Frameworks nicely wrap core JavaScript
    to allow us to perform powerful tasks like building mobile and desktop applications
    from it, but if the core principles of JavaScript and asynchronous programming
    are not well understood, flaws may begin to appear in our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Node.js** (Node for short), which was developed in 2009 by Ryan Dahl, is
    the most popular out-of-browser JavaScript engine. Node is an open source, cross-platform
    JavaScript runtime environment that was based on Chrome''s V8 JavaScript engine.
    It is used to run JavaScript code outside of the browser for non-client, side applications.'
  prefs: []
  type: TYPE_NORMAL
- en: Like Google's V8 JavaScript engine in Chrome, Node.js uses a singly-threaded,
    event-driven, asynchronous architecture. It allows developers to use JavaScript's
    event-driven programming style to build web servers, services, and CLI tools.
    As discussed in *Chapter 2, Asynchronous JavaScript*, JavaScript is a non-blocking
    and event-driven programming language. JavaScript's asynchronous nature (a single-threaded
    event loop), along with Node's lightweight design, allows us to build very scalable
    network applications without worrying about threading.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As discussed in *Chapter 2, Asynchronous JavaScript*, JavaScript is single-threaded.
    Synchronous code running on a single thread is blocking. CPU-intensive operations
    will block events as I/O file system operations and network operations.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up Node.js
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Node.js can be downloaded from the Node.js website, which can be found at [https://nodejs.org/en/](https://nodejs.org/en/).
    There are two versions available for download: the **Long Term Support (LTS)**
    version and the current version. We recommend that you download the LTS version.
    The current version has the latest features available, which may not be completely
    bug-free. Be sure to follow your operating system''s specific instructions for
    installing Node. An installer file can be downloaded for all three of the major
    operating systems, and Node.js can be installed with many package managers. Node.js
    installation debugging is outside of the scope of this book. However, installation
    tips and debugging tips can be found easily with a Google search.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Node.js''s download link is as follows: [https://nodejs.org/en/download/](https://nodejs.org/en/download/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Node.js has been downloaded and installed, it can be run from the terminal
    with the `node` command. Executing this command with no arguments following it
    will run the Node.js terminal. JavaScript code can be typed directly into the
    terminal, just like a browser''s debug console. It is important to note that there
    is no state carry over between terminal instances. When the terminal instance
    running the Node.js command-line closes, all computation will stop, and all memory
    being used by the Node.js command line process will be released back to the OS.
    To run a JavaScript code file with Node.js, simply add the file path directly
    after the `node` command. For example, the following command will run the file
    at the`./path/to/file` location with the filename `my_file.js`: `node ./path/to/file/my_file.js`.'
  prefs: []
  type: TYPE_NORMAL
- en: Node Package Manager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Node.js is an open source platform. One of Node's largest assets is the availability
    of open source third-party libraries, called modules. Node uses the **Node Package
    Manager (NPM)** to handle the installation and management of the third-party modules
    that are used by an application. NPM is usually installed with Node.js. To test
    whether NPM was installed correctly with your installation of Node, open a terminal
    window and run the `npm -v` command. If NPM is correctly installed, the current
    version of NPM will be printed in the terminal. If NPM did not install with Node,
    you may have to rerun the Node.js installer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The NPM documentation for all the functionality not covered in this section
    can be found at [https://docs.npmjs.com/](https://docs.npmjs.com/).
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 1, Introducing ECMAScript 6*, we learned about ES6 modules. It is
    very important that we make a distinction between ES6 modules and Node.js modules.
    Node.js modules were created well before ES6 and vanilla JavaScript's support
    for modules. While Node.js modules and ES6 modules are used for the same purpose,
    they do not follow the same technology specification. Node.js modules and ES6
    modules are loaded, parsed, and built differently. Node.js modules are loaded
    from the disk synchronously, parsed synchronously, and built synchronously. No
    other code can run before the modules have been loaded. Unfortunately, ES6 modules
    are not loaded in the same way. They are loaded asynchronously from disk. The
    two different module loading methods are not compatible. At the time of writing
    this book, Node.js support for ES6 modules is in beta and is not enabled by default.
    Support for ES6 modules can be enabled, but we recommend that you use standard
    node modules until full support for ES6 modules is released.
  prefs: []
  type: TYPE_NORMAL
- en: 'NPM packages are installed via the command line with the `npm install` command.
    You can use this command to either add a specific package to the project or install
    all missing dependencies. If no arguments are given to the install command, `npm`
    will look in the current directory for a `package.json` file. Inside the `package.json`
    file, there is a `dependencies` field that contains all of the dependencies that
    have been installed for the Node.js project. NPM will run through the dependency
    list and verify that each package specified in this list is installed. The dependency
    list in `packages.json` will look similar to the code that''s shown in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 6.1: Dependency list in package.json'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The dependencies field in `package.json` lists the NPM modules that have been
    installed for the project, along with the version number. In this snippet, we
    have the `amqplib` module installed at version `0.5.2` or higher, the `body-parser`
    module installed at `1.18.3` or higher, and several others. NPM modules follow
    semantic versioning. The version number is expressed by three numbers, separated
    by periods. The first number is the major version. Increases in the major version
    number indicate major changes that break backwards compatibility. The second number
    is the minor version. Changes to the minor version number indicate a release of
    new features that do not break backward compatibility. The final number is the
    patch number. Increases to the patch number indicate a bug fix or small updates
    to a feature. Increases in patch number do not include new functionality and do
    not break backwards compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: More information about semantic versioning can be found at [https://www.npmjs.com/](https://www.npmjs.com/).
  prefs: []
  type: TYPE_NORMAL
- en: To install a module, you can add an argument to the `npm install` command after
    the word *install* (for example, `npm install express`). The argument can be either
    the package name, a Git repository, a **tarball**, or a folder. If the argument
    is a package, NPM will search through its list of registered packages and install
    the package that matches the name. If the argument is a Git repository, NPM will
    attempt to download and install the files from the Git repository. If the proper
    access credentials are not provided, the installation may fail.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: See the NPM documentation for how to install packages from private git repositories.
  prefs: []
  type: TYPE_NORMAL
- en: If the argument is a tarball, NPM will unpack the tarball and install the files.
    A tarball can be installed through a URL that points to the tarball or through
    a local file. Finally, if the argument that's specified is a folder on the local
    machine, NPM will attempt to install an NPM package from the specified folder.
  prefs: []
  type: TYPE_NORMAL
- en: When installing packages with NPM, it is important to consider how the package
    will be installed. By default, packages are installed in the local project scope
    and not saved as project dependencies. If you are installing an NPM package that
    you want saved in `package.json` as a project dependency, you must include the
    `--save` or `-s` argument after the package name in the install command (for example,
    `npm install express -s`). This argument tells NPM to save the dependency in `package.json`
    so that an `npm install` command at a later time will install it.
  prefs: []
  type: TYPE_NORMAL
- en: 'NPM packages can be installed in two scopes: the **global scope** and the **local
    scope**. Packages installed in the local scope, or local packages, can only be
    used inside the Node.js project where they are installed. Packages installed in
    the global scope, or global packages, can be used by any Node.js project. Packages
    are installed locally by default. To force a module to be installed globally,
    you can add the `-g` or `--global` flag to the `npm install` command after the
    package name (for example, `npm install express -g`).'
  prefs: []
  type: TYPE_NORMAL
- en: It is not always apparent where you should install a package, but you can follow
    the following general rule of thumb if you are unsure. If you are going to use
    the package in a project with the `require()` function, install the package locally.
    If you plan on using the package on the command line, install the package globally.
    If you still cannot decide and need to use the package in a project and on the
    command line, you can simply install it in both places.
  prefs: []
  type: TYPE_NORMAL
- en: Loading and Creating Modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Node.js uses the **CommonJS** style module specification as the standard for
    loading and working with modules. CommonJS is a project that's designed to specify
    a JavaScript ecosystem for JavaScript outside the browser. CommonJS defined a
    specification for modules that was adopted by Node.js. Modules allow the developer
    to encapsulate functionality and expose only the desired parts of the encapsulated
    functionality to other JavaScript files.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Node.js, we use the require function to import modules into our code (`require(''module'')`).
    The `require` function can load any valid JavaScript file, NPM module, or JSON
    file. We will use the `require` function to load any NPM packages that have been
    installed for our project. To load a module, simply pass the name of the module
    as a parameter into the `require` function and save the returned object into a
    variable. For example, we could load the NPM module `body-parser` with the following
    code: `const bodyParser = require( ''body-parser'' )`;. This loads the exported
    functions and variables into the `bodyParser` object. The require function can
    also be used to load JavaScript files and JSON files. To load one of these files,
    you simply need to pass the file path into the `require` function instead of a
    module name. If no file extension is provided, Node.js will look for a JavaScript
    file by default.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A directory can also be loaded through the require function. If a directory
    is provided instead of a JS file, the require function will look for a file named
    `index.js` in the specified directory and load that file. If that file cannot
    be found, an error will be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a module, that is, a Node.js module, we use the `module.exports`
    property. In Node.js, every JavaScript file has a global variable object called
    `module`. The `exports` field in the `module` object defines what items will be
    exported from the module. When a module is imported with the `require()` function,
    the return value of `require()` is the value that''s set in the module''s `module.exports`
    field. Modules usually export a function or an object with properties for each
    function or variable that''s exported. An example of exporting modules is shown
    in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 6.2: Exporting a Node.js module'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Exercise 32: Exporting and Importing NPM Modules'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To build, export, and import NPM modules, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a JavaScript for our module called `module.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `module.exports` property to an object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `exportedConstant` field to the object with the value `An exported constant!`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `exportedFunction` field to the object and set its value to a function
    that logs to the console with the text `An exported function!`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an `index.js` file for our main code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the module from `module.js` with a `require` function and save it into
    the `ourModule` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log the value of `exportedString` from `ourModule`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the `exportedFunction` function from `ourModule`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Code**'
  prefs: []
  type: TYPE_NORMAL
- en: module.js
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 6.3: Exporting code as a module'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: https://bit.ly/2M3SIsT
  prefs: []
  type: TYPE_NORMAL
- en: index.js
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 6.4: Exporting code as a module'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: https://bit.ly/2RwOIXP
  prefs: []
  type: TYPE_NORMAL
- en: '**Outcome**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1: Test values output](image/Figure_6.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: Test values output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You have successfully built, exported, and imported NPM modules.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Node.js Server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most common application for Node.js is web servers. Node.js makes it very
    easy to build very efficient and scalable web servers because developers don't
    need to worry about threading. In this section, we will demonstrate the code that's
    required to make a basic web server in Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Node.js server can be set up as either an HTTP, HTTPS, or HTTP2 server. For
    this example, we will create a basic HTTP server. Node.js has basic functionality
    for an HTTP server available through the HTTP module. Import the HTTP module with
    a require statement. This is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 6.5: Loading the HTTP module'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This line of code will import the functionality contained in the module 'HTTP'
    and save it in the variable `http` for use later. Now that we have loaded the
    HTTP module, we need to choose a hostname and a port to run our server on. Since
    this server will only be running locally to our computer, we can use the IP address
    for the machine's internal local network, localhost ('`127.0.0.1`'), for our hostname
    address. We can run our local server on any network port which isn't already in
    use by another application.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can choose any valid port number, but it is rare that programs use port
    `8000` by default, so that is what is used in this demo. Add a variable to contain
    the port number and hostname to your code. The full code to this point is shown
    in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 6.6: Constants for simple server'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now that we have set up all of the basic parameters for our server, we can
    write the code to create and start the server. The HTTP module contains a function
    called `createServer()` that returns a server object. This function can take in
    an optional callback function that acts as am HTTP request listener. When any
    HTTP request comes into the server, the provided callback method gets called.
    We need to call the `createServer` function with the request listener callback
    so that our server can properly respond to inbound HTTP requests. This is done
    with the lines of code that are shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 6.7: Creating a simple server'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In the preceding snippet, we call the create `server` function and save the
    returned server into the `server` variable. We pass a callback into `createServer()`.
    This callback takes in two arguments: `req` and `res`. The `req` argument represents
    the incoming HTTP request and the `res` argument represents the server HTTP response.
    In the first line of code in the callback, we set the response status code to
    `200`. A `200` status code in the response indicates that the HTTP request to
    the server was successful. In the line after the status code, we set the `Content-Type`
    header in the response to `text/plain`. This step tells the response that the
    data passed into it will be plain text. In the final line of the callback, we
    call the `res.end()` function. This function appends the data passed into it to
    the response, then closes the response and sends it back to the requester. In
    this snippet, we pass in the `Welcome to my server!` string to the `end()` function.
    The response has the string appended to it and the text is sent back to the requester.
    Our server now handles all HTTP calls to it with this handler.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step to get our mini server up and running is to call the `.listen()`
    function on the server object. The `listen` function starts the HTTP server on
    the specified `port` and `hostname`. Once the server has begun listening, it can
    accept HTTP requests. The code in the following snippet shows how to make the
    server listen to the specified `port` at the specified `hostname`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 6.8: Server begins listening on hostname and port'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The preceding snippet shows how to call the `server.listen()` function. The
    first argument passed into the function is the port number that our server will
    be exposed on. The second argument is the hostname that our server will be accessed
    from. In this example, the port evaluates to `8000` and the hostname evaluates
    to `127.0.0.1` (the local network for your computer). In this example, our server
    will be listening on `127.0.0.1:8000`. The final argument passed in to `.listen()`
    is a callback function. Once the server begins listening for HTTP requests at
    the specified port and hostname, the provided callback function is called. In
    the preceding snippet, the callback function simply prints the URL that our server
    can be accessed from locally. You can enter this URL into your browser and a web
    page will load.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 33: Creating a Basic HTTP Server'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To build a basic HTTP server, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `http` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up variables for the hostname and port and give them the values `127.0.0.1`
    and `8000,` respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the server with `http.createServer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide a callback to the `createServer` function that takes in the arguments
    `req` and `res`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the response status code to `200`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the response content type to `text/plain`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Respond to the request with `My first server!`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the server listen on the specified port and host with the `server.listen`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide a callback to the `listen` function that logs `Server running at ${server uri}`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the server and load the logged web page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Code**'
  prefs: []
  type: TYPE_NORMAL
- en: index.js
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 6.9: Simple HTTP server'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: https://bit.ly/2sihcFw
  prefs: []
  type: TYPE_NORMAL
- en: '**Outcome**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2: Returning the new cart array'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.2: Returning the new cart array'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![Figure 6.3: Returning the new cart array'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.3: Returning the new cart array'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You have successfully built a basic HTTP server.
  prefs: []
  type: TYPE_NORMAL
- en: Streams and Pipes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Streaming data can be one of the most complicated and misunderstood aspects
    of Node.js. Streams are also arguably one of the most powerful features Node.js
    has to offer. Streams are simply collections of data, just like the standard array
    or string. The main difference is that, with streams, all of the data may not
    be available at one time. You can think of it like streaming a video off YouTube
    or Netflix. You do not need to download the entire video before you can begin
    to watch it. The video provider (YouTube or Netflix) sends, or "streams", the
    video to your computer in small pieces. You can begin watching a part of the video
    without waiting for any other parts to be loaded first. Streams are very powerful
    because they allow the server and the client to not need to load an entire large
    collection of data into memory at one time. In JavaScript servers, streams are
    crucial to memory management.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the built-in modules in Node.js rely on streams. These modules include
    the request and response objects in the HTTP module (`http`), the file system
    module `(fs)` file the cryptography module (crypto), and the child process module
    (`child_process`). In Node.js, streams come in four types— **readable**, **writeable**,
    **duplex**, and **transform**. Understanding what they do is pretty straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Types of Streams
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Data is consumed from **Readable Streams**. They abstract the loading and chunking
    of a source. Data is presented for consumption (use) by the readable stream, one
    chunk at a time. After the data chunk has been consumed, it is let go by the stream
    and the next chunk is presented. A readable stream cannot have data pushed into
    it by the consumer. An example of a readable stream is an HTTP request body.
  prefs: []
  type: TYPE_NORMAL
- en: A **readable stream** comes in two modes— **flowing** and **paused**. These
    modes determine the data flow of the stream. When the stream is in flowing mode,
    data is automatically read from the underlying stream system and is being provided
    to consumers. When the stream is in paused mode, data is not automatically read
    from the underlying system. The consumer must explicitly request data from the
    stream with the `stream.read()` function. All readable streams start in paused
    mode and can be switched to flowing by either attaching a `data` event handler,
    calling `stream.resume()`, or `calling stream.pipe()`. Event handlers and stream
    piping are covered later in this section. A readable stream can be switched from
    flowing to paused with the `stream.pause()` method or the `stream.unpipe()` method.
  prefs: []
  type: TYPE_NORMAL
- en: A **writeable stream** is a stream to which data can be written or pushed. **Writeable
    streams** abstract away the combining and handling of the source. Data is presented
    to the stream for consumption by the provider. The stream will consume data one
    chunk at a time until it is told to stop. After the stream has consumed a chunk
    of data and handled it appropriately, it will consume or request the next chunk
    of data that's available. An example of a writeable stream is the filesystem module
    function `createWriteStream`, which allows us to stream data to a file on the
    disk.
  prefs: []
  type: TYPE_NORMAL
- en: A **duplex stream** is a stream that is both readable and writeable. Data can
    be pushed in chunks by a provider to the stream or consumed in chunks by a consumer
    from the stream. An example of a duplex stream is a network socket such as a TCP
    socket.
  prefs: []
  type: TYPE_NORMAL
- en: A **transform stream** is a duplex stream that allows the data chunks to be
    mutated as they move through the stream. An example of a transform stream is the
    `gzip` method in Node.js's `ZLib` module, which compresses data with the `gzip`
    compression method.
  prefs: []
  type: TYPE_NORMAL
- en: Streams load data in chunks instead of all at once, so to effectively use streams,
    we need some way to determine if data has been loaded by the stream. In Node.js,
    streams are instances of the `EventEmitter` prototype. Streams emit events when
    key events happen, such as errors or data availability. Events listeners can be
    attached to streams with the `.on()` and `.once()` methods. Readable streams and
    writeable streams have events for data handling, error handling, and steam management.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following tables show the available events and their purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Writeable Stream Events:'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![Figure 6.4: Writeable Stream Events'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.4.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.4: Writeable Stream Events'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Readable Stream Events:'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![Figure 6.5: Readable Stream Events'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.5.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.5: Readable Stream Events'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: These event listeners can be attached to the stream to handle data flow and
    manage the state of the stream. Complete documentation can be found on the Node.js
    site under the Stream API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you understand the basics of streams, we must implement them. Readable
    streams follow a basic workflow. Generally, a method that returns a readable stream
    is called. An example of this is the filesystem API function `createReadStream(),`
    which creates a readable stream that streams a file off the disk. After the readable
    stream is returned, we can begin to pull data from the stream by attaching a `data`
    event handler. An example of this is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 6.10: Using a readable stream'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding example, we imported the `fs` module and call the `createReadStream`
    function. This function returns a readable stream. We then attach an event listener
    to the `data` event. This puts the stream in flowing mode, and every time a data
    chunk is ready, the callback provided will be called. In this example, our callback
    simply logs the data that the readable stream relinquishes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like readable streams, writable streams also follow a pretty standard
    workflow as well. The most basic workflow for a writable stream is to first call
    a method that returns a writable stream. An example of this is the `fs` module
    function `createWriteStream`. After the writeable stream has been created, we
    can write to it with the `stream.write()` function. This function will write the
    data that''s passed into it to the stream. An example of this is shown in the
    following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 6.11: Using a writeable stream'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding snippet, we loaded the `fs` module and called the `createWriteStream`
    function. This returns a writeable stream that writes data to the filesystem.
    We then call the `stream.write()` function several times. Each time we call the
    `write` function, the data we pass into the function is pushed into the writeable
    stream and written to the disk.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most powerful features in Node.js is the ability to pipe streams.
    Piping a stream simply takes the source and "pipe" it to a destination. You take
    the data output from one stream and pipes it to the input of another stream. This
    is extremely powerful because it allows us to simplify the process of connecting
    streams.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the problem where we must load a file from the disk and send it in
    an HTTP response to a client. We can do this in two ways. The first implementation
    we can build is to load the entire file into memory, then push it all at once
    to the client. This is hugely inefficient for our server. The second is to make
    use of streams. We stream the file from the disk and push the data chunks to the
    request stream. To do this without pipes, we must attach listeners to the read
    stream and catch each data chunk, then push the data chunk to the HTTP response.
    The pseudocode for this is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 6.12: Sending data to HTTP response with a stream'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the pseudocode in the preceding snippet, we created a stream that loads from
    the specified file path. We then add an event handler for the `data` event and
    the `end` event. Every time the data event has data for us, we push that data
    to the `HTTP_Response` stream. Once there is no more data and the end event is
    fired, we close the `HTTP_Response` stream the data is sent to the client. This
    requires several lines of code and requires the developer to manage the data and
    data flow. We can build the exact same functionality with stream piping on a single
    line of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Piping streams is done with the `Stream.pipe()` function. Pipe is called on
    the source stream and is passed the destination stream as an argument (for example,
    `readableStream.pipe( writeableStream )`). Pipe returns the destination stream,
    which allows it to be used for chaining pipe commands. Using the same scenario
    as in the preceding example, we can simplify the pseudocode down to one line with
    the pipe command. This is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 6.13: Piping data pseudo code'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding snippet, we loaded the file data and piped it to the `HTTP_response`.
    Each chunk of data loaded by the readable stream is automatically passed to the
    writeable stream `HTTP_Response`. When the readable stream finishes loading the
    data, it automatically closes and tells the write stream to also close.
  prefs: []
  type: TYPE_NORMAL
- en: Filesystem Operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Node''s filesystem module, named ''`fs`,'' provides an API with which we can
    interact with the filesystem. The filesystem APIs are modeled around the POSIX
    standard. The **POSIX (Portable Operating System Interface)** standard is a standard
    specified by the IEEE Computer Society to help keep general compatibility between
    different operating system filesystems. You do not need to learn the details of
    the standard but understand that the fs modules follow it to maintain cross-platform
    compatibility. To import the filesystem module, we can use the following command:
    `const fs = require( ''fs'' );`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most filesystem functions in Node.js require that you specify a path to the
    file that will be used. When specifying a file path for the fs module, the path
    can be specified in one of three ways: as a **string**, as a **buffer**, or as
    a **URL** object using the `file:` protocol. When the path is a string, the filesystem
    module will attempt to parse the string for a valid file path. If the file path
    is a buffer, the filesystem module will attempt to parse the contents of the buffer
    into a valid file path. If the path is a URL object, the filesystem will convert
    the object into a valid URL string and then attempt to parse the string for a
    valid file path. An example of the three ways to show file paths is shown in the
    following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 6.14: Filesystem path formats'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you saw in the preceding example, we used the `existsSync` function from
    the `fs` module. In the first line, we pass in a file path as a string. In the
    second line, we create a buffer from the file path string and pass the buffer
    into the `existsSync` function. In the final example, we create a URL object from
    the `file:` protocol URL of the file path and pass the URL object into the `existsSync`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: File paths can be parsed as either **relative** or **absolute paths**. An absolute
    path is resolved from the root folder of the operating system. A relative path
    is resolved from the current working directory. The current working directory
    can be obtained with the `process.cwd()` function. Paths specified via a string
    or a buffer can be either relative or absolute. Any path specified with a URL
    object must be the absolute path to the object.
  prefs: []
  type: TYPE_NORMAL
- en: The filesystem module brings in many functions that allow us to interact with
    the hard disk. For a large portion of these functions, there are both synchronous
    and asynchronous implementations. The synchronous fs functions are blocking! It
    is very important to remember this when you are writing any code that uses the
    fs module.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Remember the definition of blocking operations from *Chapter 2, Asynchronous
    JavaScript*? Blocking operations will prevent any events from being handled by
    the event loop.
  prefs: []
  type: TYPE_NORMAL
- en: If you use a synchronous `fs` function to load a large file, it will block the
    event loop. No events will be handled until the synchronous `fs` function has
    finished its work. Nothing else will be done by the Node.js thread, including
    responding to HTTP requests, handling events, or any other asynchronous work.
    You should almost always use the asynchronous versions of the `fs` functions.
    The only instances where you may need to use the synchronous version is when you
    must perform a file system action that must occur before ANY other operation.
    An example of this may be loading files that an entire system or server depends
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Express Server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We discussed the basic Node.js HTTP server in an earlier section of this topic.
    The server we created was very basic and lacked a lot of functionality that we
    come to expect from true web servers. In Node.js, one of the most common modules
    for creating minimal and flexible web servers is **Express**. Express takes a
    Node.js server object and wraps it in an API that simplifies functionality. Express
    can be installed through NPM (`npm install express --save`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The full documentation for Express can be found at [https://expressjs.com](https://expressjs.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic Express server is very easy to create. Let''s look back at the basic
    Node.js HTTP server that we created earlier in this chapter. In the basic HTTP
    server example, we first created a server with the `HTTP.createServer()` function
    and passed a basic request handler. We then started the server with the `server.listen()`
    function. An Express server is created in a similar manner. Just like with the
    HTTP server, we must first require our modules. Add a `require` statement for
    the `Express` module and create variables to hold our hostname and port number.
    Next, we must create our Express server. This is done simply by calling the function
    that is imported by default from the `require(''express'')` statement. Call the
    imported function and save the result in a variable. This is shown in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The code for the simple HTTP server can be found under the code for Exercise 33.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 6.15: Setting up Express server'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding snippet, we imported the `Express` module and save it to the
    variable `Express`. We then created two constant variables — one to hold the hostname
    and one to hold the port number. In the final line of code, we called the function
    that was imported by the require statement. This creates a basic `Express` server
    with all the default parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step we must do to replicate our basic HTTP server is to add a basic
    HTTP request handler. This can be done with the `app.get()` function. `App.get`
    sets up an HTTP GET request handler for the path provided to it. It takes in two
    parameters— a path and a callback. The path specifies the URL path that the handler
    will catch requests to. `callback` is the function that gets called when the HTTP
    request is handled. We should add a route handler for the root path of the server
    (''`/`''). This is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 6.16: Setting up the route handler'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In the preceding snippet of code, we added a route handler with `app.get()`.
    We pass in the root path (''`/`'') so that when the base (''`localhost/`'') path
    is hit with an HTTP request, the specified callback will be called. In our callback,
    we pass in a function that has two parameters: `req` and `res`. Just like with
    the simple HTTP server, `req` represents the incoming HTTP request and `res` represents
    the outgoing HTTP response. In the body of the function, we close the HTTP response
    with the string `Working express server!`. This tells `Express` to use the base
    200 HTTP response code and to send the text as the body of the response.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the final step, we must take to get our basic `Express` server working is
    to make it listen for HTTP requests. To do this, we can use the `app.listen()`
    function. This function tells the server to begin listening for HTTP requests
    at the specified port. We will pass three parameters into `app.listen()`. The
    first parameter is the **port number**. The second parameter is the **hostname**.
    The third parameter is a **callback function**, which gets called once the server
    begins listening. Call the `listen` function with the correct port, hostname,
    and a callback that prints the URL we can access the server from. An example of
    this is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 6.17: Making the Express server listen for incoming requests'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding snippet, we called the `listen` function. We pass in the port
    number, which resolves to `8000`; the hostname, which resolves to '`127.0.0.1`';
    and a `callback` function that logs the server URL. Once the server begins listening
    to HTTP requests at port `8000` on the local network, the `callback` function
    is called. Go to the URL logged to the console to see your basic server in action!
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 34: Creating a Basic Express Server'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To build a basic Express server, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `express` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the variables for the hostname and port and give them the values `127.0.0.1`
    and `8000,` respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the server app by calling `express()` and save it to the `app` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a get request handler to the base route `/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide the `callback` function that takes in `req` and `res`, and closes the
    response with the text `Working express server!.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the server listen on the specified port and host with `app.listen()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide a callback to `app.listen()` that logs `Server running at ${server uri}`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the server and load the specified URL in your browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Code**'
  prefs: []
  type: TYPE_NORMAL
- en: index.js
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 6.18: Simple Express server'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: https://bit.ly/2Qz4Z93
  prefs: []
  type: TYPE_NORMAL
- en: '**Outcome**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6: Returning the new cart array'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.6.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.6: Returning the new cart array'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![Figure 6.7: Returning the new cart array'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.7.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.7: Returning the new cart array'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You have successfully built a basic Express server.
  prefs: []
  type: TYPE_NORMAL
- en: Routing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of Express'' most powerful features is its flexible routing. **Routing**
    refers to how a web server''s endpoint URIs respond to client requests. When a
    client makes a request to a web server, it requests a specified endpoint (URI
    or path) with a specified HTTP method (`GET`, `POST`, and so on). A web server
    must explicitly handle the paths and methods that it will accept, along with callback
    functions that state how to handle the request. In Express, this can be done with
    the following line of code: `app.METHOD( PATH, HANDLER );`. The `app` variable
    is the instance of the Express server. Method is the HTTP method that the handler
    is being set up for. The method should be in lowercase. The path is the URI path
    on the server that the handler will respond to. The handler is the callback function
    that will be executed if the path and method match the request. An example of
    this functionality is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 6.19: Examples of Express routing'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding snippet, we set up three route handlers for our Express server.
    The first is set up with the `.get()` function. This means that the server will
    look for `GET` requests to the specified route. We pass in the base route for
    our server (`/`). When the base route is hit with a `GET` request, the provided
    callback function will be called. In our callback function, we respond with the
    string `GET request at /`. In the second line of code, we set up our server to
    respond to `POST` requests at the path `/user`. When a `POST` request hits our
    Express server, we call the provided callback which closes the response with the
    string `POST request at /user.` In the final line of code, we set up a handler
    for `DELETE` requests. When a `DELETE` request comes into the URI `/cart/item,`
    we respond with the provided callback.
  prefs: []
  type: TYPE_NORMAL
- en: Express also supports the special function `app.all()`. If you have worked with
    HTTP requests a lot, you will recognize that ALL is not a valid HTTP method. `app.all()`
    is a special handler function that tells Express to respond to all valid HTTP
    request methods to the specified URI with the specified callback. It was added
    to Express to help reduce duplicated code if a route was intended to accept any
    request method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Express supports having more than one callback function for a request URI and
    HTTP method. To do this, we must add a third parameter to the callback function:
    `next`. `next` is a function, and when `next` is called, Express will move to
    the next callback handler that matches the method and URI. An example of this
    is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 6.20: Multiple request handlers for the same route'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding snippet, we set up two different route handlers and `GET` requests
    to the base URI. When a `GET` request to the base route is caught, the first handler
    will be called. This handler only calls the `next()` function, which tells Express
    to look for the next matching handler. Express sees that there is a second matching
    handler and calls the second handler function, which closes the HTTP response.
    It is important to note that HTTP responses can only be closed and set back to
    the client one time. If you set up multiple handlers for a URI server and HTTP
    method, you must ensure that only one of the handlers closes the HTTP request,
    otherwise an error will occur. The functionality provided with multiple handlers
    is critical for middleware and error handling in Express. These applications will
    be discussed in more detail later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Routing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As explained earlier, in Express, route paths are the path URIs that it matches,
    along with an HTTP method, when checking which handler callbacks to call. Route
    paths are passed into functions, such as `app.get()`, as the first parameter.
    Express's power comes from the ability to create extremely dynamic route paths
    that match multiple URIs. In Express, a route path can be a string, string pattern,
    or regular expression. Express will parse string-based routes for the special
    characters `?`, `+`, `*`, `()`, `$`, `[`, and `]`. When used in string paths,
    the special characters `?`, `+`, `*`, and `()` are subsets of the regular expression
    counterparts. The `[` and `]` characters are used to escape parts of a URL. They
    are not interpreted literally in the string. The `$` character is a reserved character
    in the Express path parsing module. If you must use the `$` character in a path
    string, you must escape it with the `[ and ]`. For example, `/user/$22515` should
    be written in the Express route handler as `/data/[\$]22515`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wish to incorporate special characters in our routes to add flexibility
    we can use the characters `?`, `+`, `*`, and `()`. These characters operate the
    same way as their regular expression counterparts. This means that the `?` character
    is used to symbolize optional characters. Any character or character group followed
    by the `?` symbol will be considered optional and Express will match URIs that
    either match the full string literally with the optional character(s) or match
    the full string literally without the optional character(s). This is shown in
    the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 6.21: Optional characters in the route path'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding snippet, we set up a `GET` handler for the URL path '`/abc?de`.'
    When this URL is hit, the callback is called, which logs the two possible URI
    match options. Since the `?` character follows the `c` character, the `c` character
    is considered optional. Express will match both `GET` requests to the URI that
    contains or does not contain the optional character. Requests to both `/abde`
    and `/abcde` will match.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `+` symbol is used to indicate zero or more repetitions of the character
    or character group it follows. Express will match a route that matches literally
    with the string with zero of the repeated character, and any string that contains
    one or more sequential repetitions of the marked character. An example of this
    is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 6.22: Routing with zero or more repeated characters'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding snippet, we set up a `GET` handler for the URL path `fo+d`.
    When this URI is hit, the callback is called, which logs some of the matching
    options. Since the o character is followed by the `+` character, Express will
    parse any route with zero or more `o`'s in it. Express will match `fd`, `fod`,
    `food`, `foooooooooooood`, and any other string URI with consecutive `o`'s.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `*` character functions similar to the `+` character, but matches zero
    or more repetitions of any character. Express will match routes that match literally
    with the string without the extra characters. One or more consecutive characters
    of any type are used in place of the asterisk. An example of this is shown in
    the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 6.23: Routing with zero or more characters'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding snippet, we set up a `GET` handler for the URL path `'fo*d`.'
    When this URI is hit, the callback is called, which logs some of the matching
    options. Since the `o` character is followed by the `*` character, Express will
    parse any route with zero or more additional characters in it. Express will match
    `fd`, `fod`, `fad`, `foood`, `faeioud`, and any other string URI with consecutive
    characters in place of the `*`. Notice the difference between the matching strings
    when comparing the `+` and `*` characters. The `*` character will match all of
    the strings that the `+` character matches, with the addition of strings with
    any valid character in place of the asterisk.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final set of characters is the `()`. The parentheses groups a set of characters
    together. Grouped characters are treated as single units when used in conjunction
    with the other special characters `(?, +, or *)`. For example, the URI `/ab(cd)?ef`
    will match the URIs `/abef` and `/abcdef`. The characters `cd` are grouped together,
    and the entire group is subject to the `?` character. An example of this interaction
    with each of the special characters is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 6.24: Routing with character groups'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding snippet, we set up `GET` request handlers for the paths `b(es)?t`,
    `b(es)+t`, `b(es)*t`. Each handler calls a callback that logs some of the match
    options. In the all of the handlers, the characters `es` are grouped together.
    In the first handler, the grouped characters are subject to the `?` character
    and are considered optional. The handler will match URIs that contain the full
    string and do only contain the non-optional characters. The two options are `bt`
    and `best`. In the second handler, the character group is subject to the `+` character.
    URIs with zero or more consecutive repetitions of the character group will match.
    The match options are `bt`, `best,` `besest`, `besesest`, and any other string
    with more consecutive repetitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Express also allows us to set up route parameters in the route strings. Route
    parameters are named route sections, and allow us to specify sections of the route
    URL to capture and save into variables. The captured sections of the URL are saved
    into the `req.params` object under the key name that matches the name of the capture.
    URL params are specified with the : character, followed by the capture name. Whatever
    string falls in that part of the route is captured and saved. An example of this
    is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 6.25: Routing with URL params'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In the preceding snippet, we set up a get parameter for the route `/amazon/audible/:userId/books/:bookId`.
    This route has two named parameter captures: one for `userId` and one for `bookId`.
    The two named captures can contain any set of valid URL characters. Whatever characters
    are contained between `audible/` and `/books` will be saved into the `req.params.userId`
    variable and whatever characters are after `books/` will be saved into `req.params.bookId`.
    It is important to note that the `/` character is what is used to split sections
    of the URL. The capture groups saved will not contain the `/` character because
    Express parses it as a URL separator.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Express routes can also use regular expressions in place of a path strings.
    If a regular expression is passed into the first argument of a request handler
    instead of a string, Express will parse the regular expression and any string
    that matches the regular expression will fire the provided callback handler. If
    you are unfamiliar with regular expressions, you can find many tutorials online
    that teach the basics. An example of regular expression paths is shown in the
    following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 6.26: Routing with regular expressions'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding snippet, we set up a `GET` handler for the regular expression
    route `/^web.*/`. If this handler is matched, the server will log two examples
    of strings that match. The regular expression that we provided to the `GET` handler
    specifies that the URI must start with the string `web` and may be followed by
    any number of characters. This will match URIs such as `/web`, `/website`, and
    `/webmail`.
  prefs: []
  type: TYPE_NORMAL
- en: Middleware
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Express also expands on server flexibility with a feature called middleware.
    Express is a routing and middleware framework that has little functionality on
    its own. **Middleware** are functions that have access to the HTTP requests request
    and response objects and run somewhere in the middle of the handling sequence.
    Middleware can perform one of four tasks: execute code, make changes to request
    and response objects, end the HTTP request-response sequence, and call the next
    middleware that applies to the request.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Middleware functions can be manually written, or they can be downloaded through
    third-party NPM modules. Before writing a middleware, check that the middleware
    does not already exist. Official middleware modules and some select popular modules
    can be found at [https://expressjs.com/en/resources/middleware.html](https://expressjs.com/en/resources/middleware.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Middleware functions have three input variables: `req`, `res`, and `next`.
    `Req` represents the request object, `res` represents the response object, and
    `next` is a function that tells Express to continue to the next middleware handler.
    We saw the `next` function earlier in this section when registering multiple route
    handlers to one URI. The `next` function tells the middleware handlers to pass
    control to the next middleware in the handler stack. In simpler terms, it tells
    the `nex`t middleware to run. If a middleware does not end the request-response
    sequence, it must call the `next` function. If it does not, the request will hang
    and eventually time out. Middleware can be attached with the functions `app.use()`
    and `app.METHOD()`, where method is the lowercase HTTP method the middleware is
    being attached to. A middleware set up with `app.use()` will fire for all HTTP
    methods that match the specified optional path. Middleware attached with an HTTP
    method function will fire for all requests that match the method and specified
    path. An example of middleware is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 6.27: Setting up middleware'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding snippet, we set up a middleware function using `app.use()`.
    We do not provide a path to `app.use(),` so all requests will trigger the middleware.
    The middleware updates the request object by setting the `currentTime` field in
    the request to a new date object. The middleware then calls the next function,
    which passes control to the next middleware or route handler. Assuming a request
    to the base URI, the next handler that gets hit is the registered handler, which
    prints the value held in `req.currentTime`.
  prefs: []
  type: TYPE_NORMAL
- en: Error Handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final important aspect of Express is error handling. **Error handling**
    is the process through which Express handles and manages errors. Express can handle
    synchronous errors and asynchronous errors. Express has built-in error handling,
    so you do not need to write your own. Express's built-in error handler will return
    the error to the client in the response body. This may include error details such
    as the stack trace. If you want the user to see a custom error message or page,
    then you must attach your own error handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'The built-in Express error handler will catch any error thrown in synchronous
    code in a route handler or middleware function. This includes runtime errors and
    errors thrown with the throw keyword. Express will not, however, catch errors
    thrown in asynchronous functions. To invoke errors in asynchronous functions,
    you must add the `next` function to the callback handler. If an error occurs,
    you must call next with the error you want to handle. An examples of synchronous
    and asynchronous error handling with the default error handler are shown in the
    following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 6.28: Synchronous and asynchronous error handling'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding snippet, we first created a `GET` request handler to the path
    `/synchronousError`. If this handler is hit, we call the callback function, which
    throws an error in a block of synchronous code. Since the error is thrown in a
    synchronous code block of code, Express automatically catches the error and passes
    it to the client. In the second example, we create a `GET` request handler for
    the path `/asynchronousError`. When this handler is hit, we call a callback function
    that begins a timeout and calls the `next` function with an error. The error occurs
    in an asynchronous block of code, so it must be passed to Express through the
    next function. When Express catches an error, either synchronously through thrown
    events or asynchronously through the next function, it immediately skips all applicable
    middleware and route handlers in the stack and jumps to the first applicable error
    handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define our own error handler middleware function, we add it in the same
    way as other middleware functions, except with one key difference. Error handler
    middleware callback functions have four arguments in the callback instead of three.
    The arguments, in order, are `err`, `req`, `res`, and `next`. They are explained
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`err` represents the error that is being handled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`req` represents the request object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`res` represents the response object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`next` is a function that tells Express to move on to the next error handler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Custom error handlers should be the last defined middleware. An example of
    custom error handling is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 6.29: Adding a custom error handler'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding snippet, we added a `GET` request handler for the base route.
    When the handler is hit, it calls a callback function, which throws an error.
    This error is automatically caught by Express and passed to the next error handler.
    The next error handler is the one we defined with the `app.use()` function. This
    error handler catches the error and then responds to the client with an error
    message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 35: Building a Backend with Node.js'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You have been tasked with building a Node.js Express server for a note taking
    application. The server should serve a basic HTML page (provided in the activity
    folder under `index.html`) to the base route (`/`). The server will need to have
    an API route to load a saved note from a text file in the server's local filesystem
    and an API route to save changes to the note to the text file on the server's
    local filesystem. The server should accept a `GET` request to the URI `/load`
    when loading the note and accept a `POST` request to the URI `/save` when saving
    the note. The provided HTML file will assume that these are the API paths used
    on the server. When building the server, you may want to use the body-parser middleware
    with the strict option set to false to simplify the handling of requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build a working Node.js server that serves an HTML file and accepts API
    calls, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up the project with `npm init`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install `express` and `body-parser` with npm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the modules `express`, `http`, and `body-parser` saved as `bodyParser`,
    and `fs`, and save them in variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable called `notePath` that contains the path to the text file
    (`./note.txt`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log that we are creating a server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the server app with `express()` and save it in the `app` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an HTTP server from the Express app with `http.createServer(app)` and
    save it in the server variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log that we are configuring the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `body-parser` middleware to parse JSON request bodies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tell the Express app to use the middleware with `app.use()`.
  prefs: []
  type: TYPE_NORMAL
- en: Pass in `bodyParser.json()` to the use function.
  prefs: []
  type: TYPE_NORMAL
- en: Pass an options object into `bodyParser.json()` with the `key/value pair. strict:false`.
  prefs: []
  type: TYPE_NORMAL
- en: Create a router to handle the routing with `express.Router()` and save it to
    the variable router.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a get route handler for the base route with `router.route('/').get`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a callback function that takes in `req` and `res`.
  prefs: []
  type: TYPE_NORMAL
- en: In the callback`,` send the `index.html` file with `res.sendFile()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pass in `index.html` for the first parameter and the options object {`root:
    __dirname` } for the second parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: Add a route for the `/save` route that accepts a `POST` request with `router.route(
    '/save' ).post`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The route handler callback should take in the parameters `req` and `res`.
  prefs: []
  type: TYPE_NORMAL
- en: In the callback, call the `fs` function `writeFile()` with the `notePath` and
    `req.body` parameters and a `callback` function.
  prefs: []
  type: TYPE_NORMAL
- en: In the callback function, take in the arguments `err` and `data`.
  prefs: []
  type: TYPE_NORMAL
- en: If an `err` is provided, close the response with the status code `500` and the
    error in JSON form.
  prefs: []
  type: TYPE_NORMAL
- en: If no error is provided, close the response with the `200` status code and the
    JSON of the data object.
  prefs: []
  type: TYPE_NORMAL
- en: Add a route for the `/load` route that accepts a get request with `router.route(
    '/load ).get`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The route handler callback should take in the parameters `req` and `res`.
  prefs: []
  type: TYPE_NORMAL
- en: In the callback, call the `fs` function `readFile` with the `notePath` and `utf8`
    parameters, and a callback function.
  prefs: []
  type: TYPE_NORMAL
- en: In the callback function, take in the arguments `err` and `data`.
  prefs: []
  type: TYPE_NORMAL
- en: If an `err` is provided, close the response with the status code `500` and the
    error in JSON form.
  prefs: []
  type: TYPE_NORMAL
- en: If no error is provided, close the response with the `200` status code and the
    JSON of the data object.
  prefs: []
  type: TYPE_NORMAL
- en: Make the `express` app use the router to handle requests at the base route with
    `app.use('/', router)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the server up to listen on the correct port and hostname and pass in a callback
    using `server.listen( port, hostname, callback )`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The callback should take in an error parameter. If an error is found, throw
    that error.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, log the port that the server is listening on.
  prefs: []
  type: TYPE_NORMAL
- en: Start the server and load the URL that is running at `(localhost:PORT)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the server's routing and functionality by saving a note, refreshing the
    web page, loading the saved note (should match what was saved before), then updating
    the note.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Code**'
  prefs: []
  type: TYPE_NORMAL
- en: index.js
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 6.30: Express server routing for complicated application'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: https://bit.ly/2C4FR64
  prefs: []
  type: TYPE_NORMAL
- en: '**Outcome**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8: Listening on port 8000'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.8.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.8: Listening on port 8000'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![Figure 6.9: Loading the test note'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.9.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.9: Loading the test note'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You have successfully built a working Node.js server that serves an HTML file
    and accepts API calls.
  prefs: []
  type: TYPE_NORMAL
- en: React
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**React** is a JavaScript library for building user interfaces. React is maintained
    primarily by FaceBook. React was first created by Jordal Walke, a Facebook software
    engineer, and open sourced in 2013\. React is designed to simplify web development
    and allow developers to build single-page web sites and mobile applications with ease.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'React''s full documentation, along with extended tutorials, can be found at
    their home page: [https://reactjs.org/](https://reactjs.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: React uses a declarative approach for designing a view to improve the predictability
    and debugging of pages. The developer can declare and design simple views for
    each state in the application. React will handle the updating and rendering of
    the views as states change. React relies on a component-based model. The developer
    builds encapsulated components that track and handle their own internal states.
    We can combine our components to make complex user interfaces, similar to how
    we use function composition to build complex functions from simple functions.
    With components, we can pass rich data types from component to component, through
    our application. This is allowed because component logic is written purely in
    JavaScript. Finally, React allows us to be very flexible in our transition into
    the framework. No assumptions are made about the technology stack behind the application.
    React can be compiled on load in the browser, on a Node.js server, or into a mobile
    app with React Native. This allows React to be slowly incorporated into new features
    without requiring existing code to be refactored. You can begin to incorporate
    React at any point in the technology stack.
  prefs: []
  type: TYPE_NORMAL
- en: Installing React
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: React can be installed through NPM and compiled on the server or integrated
    into an application through script tags. There are several ways to install React
    and add it to a project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The quickest way to add React to your application is to include the built-in
    libraries through a `<script>` tag. This method is generally the easiest if you
    have an existing project and you want to slowly start incorporating React into
    it. Adding React in this way takes less than a minute and can prepare you to begin
    adding components immediately. First, we need to add a DOM container to our HTML
    page where we want our React components to attach. This is generally a div with
    a unique ID. We then add the **React** and `ReactDOM` modules with script tags.
    Once the script tags have been added, we can load our React components with a
    script tag. An example of this is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 6.31: Adding React to a web page'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The next simplest way to set up a React app and install React into a new project
    is with the React app creator. This module is a Node.js command-line interface
    that automatically sets up a React project with a simple predefined folder structure
    and the basic dependencies installed. The CLI tool can be installed with the command-line
    command `npm install create-react-app -g`. This command tells NPM to install the
    CLI module in the global scope so that it can be run from the command line. Once
    the CLI has been installed, you can create a new React project by running the
    `create-react-app my-app-name` command. The CLI tool will create a folder in the
    working directory with the name provided (`my-app-name` from the example command),
    install the React dependencies, and create two folders for your application's
    resources. The CLI tool will populate the source code folder, named `src`, with
    an example app. You can start the app with the `npm start` command. From this
    point, you can begin hacking and modifying the files to see how React works, or
    you can delete all the files in `src` and begin writing your own application.
  prefs: []
  type: TYPE_NORMAL
- en: The most difficult way to install React is to install the individual dependencies
    one at a time. This method provides the most flexibility and allows you to integrate
    React into your existing toolchain. To install React, you must install the modules
    `react` and `react-dom` with NPM. Both modules can be installed in the local project
    scope and should be saved to the `package.json` dependency list with the `--save`
    or `-s` flag. Once the modules are installed, React components can be created
    and built with your existing toolchain.
  prefs: []
  type: TYPE_NORMAL
- en: In this topic, we will use React with JSX. **JSX** is a JavaScript syntactic
    sugar and is not supported by default in browsers. JSX must be transpiled into
    valid JavaScript code with Babel. To finalize the setup of React, you will need
    to set up Babel to transpile your React and JSX code into JavaScript. If Babel
    has not been installed for your project, you can install it with the `npm install
    babel -s` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will save Babel as a dependency for your project. To add the React JSX
    plugin to Babel, run the `npm install babel-preset-react-app -s` command. This
    command adds the JSX transpiling libraries for Babel. After babel has been set
    up, we must create a build script that we can run to transpile all of our code.
    In package.json, add the following line: `build": "npx babel src -d lib --presets
    react-app/prod`. Note that `npx` is not a typo. It is a package runner tool that
    comes with NPM. This line tells Babel to compile code from the `src` directory
    to the `lib` directory with the `react-app/prod` preset. This command should be
    run each time we make changes to our React code and want to reflect this in the
    front-end. You are now ready to start building a React application.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can provide the Babel setup commands stated in the previous paragraph to
    demonstrate how to set the project up for transpilation.
  prefs: []
  type: TYPE_NORMAL
- en: React Basics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'React is built around small encapsulated pieces of code called components.
    Components in React are defined by subclassing `React.Component` or `React.PureComponent`.
    The most common method is to use `React.Component`. In the simplest form, a React
    component takes in properties (commonly called `props`) and returns the view to
    display via a call to `render()`. Properties are defined when the components are
    initialized. Each component that''s created must have a method called `render()`
    defined in the subclass. The render function returns a description of what will
    be rendered on the screen in JSX form. An example component declaration is shown
    in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 6.32: Basic React element'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding snippet, we have defined a new React component `class` called
    `HelloWorld`. This new class extend the basic `React.Component`. Inside the declaration,
    we define the `render()` function. The `render()` function returns a block of
    JSX that defines what will be rendered on the screen. In this block of JSX, we
    create a `div` with the text `Hello World!!! Made by *!!!`, where the `*` character
    is replaced with the value passed in through the by property. In the final few
    lines, we call the `ReactDom.render()` function. This tells the `ReactDom` module
    to render all of the components and views we have passed into the `render()` function.
    In the preceding snippet, we passed our `HelloWorld` component with the property
    `by` set to `Zach`, and we tell the render function to attach the rendered DOM
    to the root element. The data that's passed into the property is passed into `this.props`
    inside our component and filled into the `Hello World!!! div`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If your code base does not use ES6 or ES6 classes, you can use the create-react-class
    module, however, the specifics of this module are outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have learned about the most basic form of React. By expanding
    on this one example, you can now build basic static web pages. This may not seem
    very useful, but it is the most basic building block of all web development.
  prefs: []
  type: TYPE_NORMAL
- en: React Specifics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From our very basic example in the preceding snippet, we can see that React
    uses an odd syntactic sugar called JSX. JSX is neither HTML nor JavaScript. It
    is a syntax extension for JavaScript that incorporates some concepts from HTML
    and XML to help describe what a user interface should look like. JSX is not necessary
    for a React app, however it is recommended that you use it when building a React
    UI. It looks like a template language but comes with the full power of JavaScript.
    It can be compiled into standard JavaScript with the Babel React plugin. An example
    of JSX and the equivalent JavaScript is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 6.33: JSX vs JS'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding snippet, we defined a variable called `elementJSX` and saved
    a JSX element into it. In the second line, we created a variable called `elementJS`
    and saved the equivalent element into it with pure JavaScript. In this example,
    you can clearly see how the markdown style of JSX simplifies the approach to defining
    an element in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: JSX
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**JSX** can have expressions embedded into it much like template literals in
    standard JavaScript. The main difference, however, is that JSX uses just curly
    braces (`{}`) to define an expression. Much like template literals, the expressions
    used in JSX can be variables, object references, or function calls. This allows
    us to use JSX to create dynamic elements in React. An example of JSX expressions
    is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 6.34: JSX expressions'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding snippet, we first created a variable called name that contains
    the string `David` and a function called `multiplyBy2` that takes in a number
    and returns the number multiplied by `2`. We then create a variable called `element1`
    and save a JSX element into it. This JSX element contains a `div` that contains
    an expression that references the `name` variable. When this JSX element is built,
    the expression evaluates the `name` variable to the string `David` and inserts
    that into the final markup. In the final line of code, we create a variable called
    `element2` and save another JSX element into it. This JSX element contains a div
    with an expression that references the `multiplyBy2` function. When the JSX element
    is created, the expression evaluates the code inside it and calls the function.
    The function return value is put into the final markup. As you can see, expressions
    in JSX work much like expressions in template literals.
  prefs: []
  type: TYPE_NORMAL
- en: ReactDOM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we create React elements, we must have some way to render them into the
    DOM. This was touched on very briefly in the React introduction example. In that
    example, we used the `ReactDOM` library to render the component we created. The
    `ReactDOM` object, which was imported from the `react-dom` module, provides DOM
    specific methods that can be used through your app; however, most components do
    need these methods. The function you will use most is the `render()` function.
    This function takes in three parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first parameter is the React element that we will rendering, or attaching,
    to the DOM. The second parameter is the container or DOM node that the React component
    will be rendered into. The final parameter is an optional callback method. The
    callback function will be executed after the component is rendered. For full React
    apps, `ReactDOM.render()` is usually only needed at the top level of the application,
    and is used to render the entire app in the view. In applications where React
    is being slowly incorporated into an existing code base, `ReactDOM.render()` may
    be used at each new point where a React component is being incorporated into non-React
    code. An example of `ReactDOM.render()` is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 6.35: Rendering elements into the DOM'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding example, we first imported the `ReactDOM` module. We then created
    a new React element with JSX. This simple element contains only a `div` with the
    text `HELLO WORLD!!!` inside it. We then called the `ReactDOM.render()` function
    with all three arguments. This function call is telling the browser to select
    the root DOM node and attach the markup rendered by our React element. When the
    rendering completes, the provided callback is called and the `Done rendering`
    string is logged to the console.
  prefs: []
  type: TYPE_NORMAL
- en: React.Component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'React revolves around components. As we learned earlier, the simplest way to
    create a new component is by creating a new subclass that extends the `React.Component`
    class. The `React.Component` class can be accessed through the React object that''s
    imported from the React NPM module. When we define a React component we must,
    at the very least, define a `render()` function. The `render` function returns
    the JSX description of what the component will contain. If we wish to make more
    complex components, such as components with states, we can add a constructor to
    our component. The constructor must take in the `props` variable and it must call
    the `super()` function with the `props` variable. The `props` variable will contain
    an object with the properties assigned when creating the React component. An example
    of a React component with a constructor is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 6.36: React class constructor'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding snippet, we created a new component called `ConstructorExample`.
    In the same snippet, we call the `constructor` function. The `constructor` function
    takes in one parameter, which is the object that contains the properties. In the
    constructor, we call the `super()` function and pass in the `props` variable.
    We then create a `class` variable called `variable` and assign the value `test`.
    At the end of the class, as required for all React components, we add a `render()`
    function that returns the JSX markup for the component.
  prefs: []
  type: TYPE_NORMAL
- en: State
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To add a local state to a React component, we simply initialize the variable
    state, in the this scope, inside the constructor (`this.state = {}`;). The state
    variable is a special variable keyword name in React. Any changes to `this.state`
    will cause the `render()` function be called. This allows us to have the view
    dynamically change, depending on the current state of the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to know three key things about the state variable. First, you
    should never modify the state directly with a statement such as `this.state.value
    = ''value''`. Modifying the state in this way will not result in a call to `render()`
    and a view update. Instead, you must use the `setState()` function. This will
    update the state with the data passed into the function. For example, we must
    set the state like so: `this.setState( { name: ''Zach'' } )`. The second key detail
    is that state updates may be asynchronous. React may batch multiple `setState`
    calls into a single update to boost performance. Because of this fact, and because
    `this.props` and `this.state` can be changed asynchronously, we cannot rely on
    their values for calculating a state. If we must use the current state or current
    value of a property to calculate the next state, we can use a second form of `setState`
    that accepts a function instead of an object. The function will receive the previous
    state as the first argument and the properties object at the time the state update
    was applied as the second argument. This reliably allows us to use the previous
    state and property information for calculating the next state. Finally, state
    updates are merged instead of overwritten. Much like the `Object.assign` function,
    `setState` does a shallow merge of the state object and the new state. When setting
    a state, the new object will be merged with into old state object. Only the properties
    specified in the new state object will change. All of the properties in the old
    state object that are not in the new state object will be left untouched.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In React components, the property object is read-only from inside the component.
    This means that changes to the properties object from inside component will not
    be reflected to any variable inside the parent component or DOM structure. Data
    only flows downward. Consequently, any change to the parent component''s JSX markup
    for the child component''s properties will cause the child to re-render with the
    new property values. To get data to flow in an upward direction, we must pass
    in functions from the parent component to the child component in the form of properties.
    An example of this is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 6.37: Rendering a child component'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this snippet, we created two components. The first one is called `ChildElement`
    and the second is called `ParentElement`. `ChildElement` simply contains JSX for
    a button that, when clicked, calls the function that's passed in through the `onClick`
    property. `ParentElement` contains a function called clicked that logs to the
    console and, when rendered, returns JSX with a `ChildElement` instance. The `ChildElement`
    that's created in the JSX of `ParentElement` has the property `onClick` set to
    the `clicked()` function of `ParentElement`. When the button in `ChildElement`
    is clicked, the `clicked()` function gets called. In this example, bind the parent
    scope to this.clicked when we pass it into the child element (`this.clicked.bind(this)`).
    If `this.clicked` needs to access anything in the parent component, we must bind
    it's scope to the scope of the parent component. In your React applications, you
    can use this functionality to create upward data flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Handling DOM events in React is very similar to HTML DOM element event handling,
    with a few main differences. First, in React, event names are using `camelcase`
    instead of lowercase. This means that at each "new word" in the name, the first
    letter of that word is upper case. For example, the DOM event `onclick` becomes
    `onClick` in React. Second, in JSX, function event handlers are passed into the
    handler definition directly as the function, instead of as a string containing
    the handler function name. An example of the differences between standard HTML
    and React are shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 6.38: JSX versus HTML events'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding snippet, we created two buttons. The first is in HTML and has
    an `onclick` listener attached to it that calls the `doSomething` function. The
    second button is in JSX format and also has an `onclick` listener that calls the
    `doSomething` function. Note the difference in how the listeners are defined.
    The JSX event name is in `camelcase` and the HTML event name is in lower case.
    In JSX, we set the handler function via an expression, which evaluates to the
    function. In HTML, we set the event handler to a string that calls the function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We learned in *Chapter 3, DOM Manipulation and Event Handling*, that it is a
    bad practice to attach events directly in the DOM. JSX is not HTML and this practice
    is acceptable because JSX prevents injection attacks by escaping any values embedded
    in JSX.
  prefs: []
  type: TYPE_NORMAL
- en: Another significant difference between React event handling and standard DOM
    event handling is that, in React, the event handler function cannot return false
    to prevent the default behavior. You must explicitly call the `preventDefault()`
    function on the event object.
  prefs: []
  type: TYPE_NORMAL
- en: When attaching event listeners in React, we must be careful with the `this`
    scope. In JavaScript, class methods are not bound to the `this` scope by default.
    If the functions are passed somewhere else and called from somewhere else, the
    `this` scope may not be properly set. You should be sure to bind the `this` scope
    correctly when attaching them to listeners or passing methods around as properties.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional Rendering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In React, we create distinct components to encapsulate the views or behaviors
    we need. We need a way to only render some of the components we have created,
    based on the state of the application. In React, this is referred to as **Conditional
    Rendering**. In React, conditional rendering works the same way as JavaScript
    conditional statements. We can use JavaScript's if or the conditional operator
    to decide what elements to render. This can be done in several ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'Out of two simple ways, one is to have a function that returns a React element
    (JSX) based on the current state, while the second is have a conditional statement
    in JSX that returns a React element based on the current state. An example of
    these forms of conditional rendering are shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 6.39: Conditional rendering'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding snippet, we created an element called `AccountControl`. In
    the constructor, we set the local state to an object that contains account information
    that's passed in from the property variable. The render function simply returns
    a `div` with two expressions. Both expressions take advantage of conditional rendering
    to display information based off of the current state. The first expression calls
    the `isLoggedIn` function, which checks `this.state.account` and returns either
    a `LogoutButton` or a `LoginButton,` depending on the current state. The second
    expression uses the conditional operator to check `this.state.account` inline
    and returns either a `LogoutButton` or a `LoginButton` depending on the local
    state.
  prefs: []
  type: TYPE_NORMAL
- en: List of Items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Rendering lists of items in React is extremely simple. It is based on the concepts
    of JSX and expressions. As we learned earlier, JSX uses expressions to create
    dynamic code. If an expression evaluates to an array of components, all the components
    will be rendered as if they were added inline in JSX. We can build a collection,
    or array, of components, save the collection in a variable, and include the variable
    in a JSX expression. An example of this is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 6.40: Rendering lists'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding snippet, we created an element called `ListElement`. This element
    simply takes in an array of items and maps the array to an array of JSX elements
    that contains the array item value in a `<li>` tag. The resulting array of list
    items is then returned into a `<ul>` tag. When JSX compiles this into HTML each
    item in the array is inserted, in order, into the `<ul>` element.
  prefs: []
  type: TYPE_NORMAL
- en: HTML Forms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final key concept of React that we must discuss is HTML forms. HTML forms
    work differently in React than other DOM elements because HTML forms track their
    own internal state. If we only need to handle the default behavior of a form,
    then we can use them off the shelf with React and have no issues. However, we
    run into a complication when we want to have a JavaScript handle the form submission
    and have access to all of the data in the form. This issue arises because both
    the element and React component try to track the state of the form at the same
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way to achieve this is with controlled components. The goal of controlled
    components is to remove state control from the form element and make React the
    controlling component. This is done by adding a React event listener for a field''s
    value change event (`onChange`) and having React set its internal `state` variable
    value equal to the form''s value. Then, React sets the value of the field equal
    to the value that''s saved in the `state` variable. React reads any changes from
    the `input` field and forces the `input` field to adopt any changes that happen
    to the data stored in the React component. An example of this is shown in the
    following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 6.41: React component states'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding snippet, we created a component called `ControlledInput`. This
    component has a state variable called value that will store the value of the text
    input. We create a function called `handleChange` that simply updates the components
    state by setting a value equal to the value of the read from the event. In the
    render function, we create a div that contains an `input` field and another `div`.
    This input field has its value mapped to `this.state.value` and an event listener
    that calls the `handleChange` function. The second `div` simply mirrors the value
    of `this.state.value`. When we make a change inside of the text input, the `onChange`
    listener gets called and the components `state.value` gets set to the current
    value of the input field. Whenever `this.state.value` gets changed, that changes
    gets reflected back to the `input` field. The component's value for `this.state.value`
    is absolute and the `input` field is forced to mirror it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 6: Building a Frontend with React'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The front-end team working on your note taking app from *Exercise 32* has unexpectedly
    quit. You must build the frontend for this application using React. Your frontend
    should have two views, a Home view and an Edit view. Create a `R``eact` component
    for each view. The `home` view should have a button that changes the view to the
    `edit` view. The `edit` view should have a button that switches back to the `home`
    view, a text input that contains the `Note Text`, a **Load** button that calls
    the API load route, and a **Save** button that calls the API save route. A Node.js
    server has been provided to you. Write your React code in `activities/activity6/activity/src/index.js`.
    When you are ready to test your code, run the build script (defined in `package.json`)
    before starting the server. You can reference the `index.html` file from *Exercise
    35* for hints on how to call the API routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build a working React front-end and integrate it with a Node.js Express
    server, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the starter activity at `activity/activity6/activity`. Run `npm install`
    to install the required dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `Home` and `Editor` component in the `src/index.js` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `home` view should display the app name and have a button that changes the
    app state to the `edit` view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `edit` view should have a return home button that changes the app state
    to the `edit` view, a text input that is controlled by the `edit view` state,
    a **Load** button that makes a request to the server for the saved `Note Text`,
    and a **Save** button that makes a request to the server to save the note text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `App` component, use the `app` state to decide which view (`home` or
    `editor`) to show.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Code**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Outcome**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10: Home view'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.10: Home view'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![Figure 6.11: Edit View'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.11: Edit View'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![Figure 6.12: Server View](image/Figure_6.12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.12: Server view'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You have successfully built a working React front-end and integrate it with
    a Node.js Express server.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 293.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The JavaScript ecosystem has grown immensely over the past 10+ years. In this
    chapter, we first discussed the JavaScript Ecosystem first. JavaScript can be
    used to build full backend web servers and services, command-line interfaces,
    mobile apps, and front-end sites. In the second section, we introduced Node.js.
    We discussed how to set up Node.js for out of browser JavaScript development,
    the Node Package Manager, loading and creating modules, basic HTTP servers, streams
    and piping, filesystem operations, and the Express server. In the final topic,
    we introduced the React framework for frontend web development. We discussed installing
    React and the basics and specifics of React.
  prefs: []
  type: TYPE_NORMAL
- en: This rounds up the book. In this book, you examined major features in ES6 and
    implemented these features to build applications. Then, you handled JavaScript
    browser events and created programs that follow the TDD pattern. Lastly, you constructed
    the backend framework Node.js and the frontend framework React. Now, you should
    be equipped with the tools to put what you have learned into practice in the real
    world. Thank you for choosing this advanced JavaScript book.
  prefs: []
  type: TYPE_NORMAL
