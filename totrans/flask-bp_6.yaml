- en: Chapter 6. Hublot – Flask CLI Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often when administering a web application, there are tasks that we like to
    accomplish without having to create an entire administrative web interface; even
    though this may be accomplished relatively easily with tools such as Flask-Admin.
    Many developers first turn to a shell scripting language. Bash is near universal
    on most modern Linux operating systems, favored by system administrators, and
    is powerful enough to script any administrative task that may be required.
  prefs: []
  type: TYPE_NORMAL
- en: While the venerable Bash script is most definitely always an option, it would
    be nice to write a Python-based script that could utilize some of the application-specific
    data handling that we have crafted for our web application. In doing so, we can
    avoid duplicating a fair amount of energy and effort that was put in the painstaking
    process of creating, testing, and deploying the data models and domain logic that
    is the core of any web application. This is where Flask-Script comes in.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of writing this, Flask has not yet shipped the 1.0 release, which
    includes an integrated CLI script handling via the `Click` library developed by
    the author of Flask. As the API of the Flask/Click integration may change significantly
    between now and the release of Flask 1.0, we've chosen to implement the CLI tools
    discussed in this chapter via the Flask-Script package, which has been the de
    facto solution for Flask for quite some time now. The creation of administrative
    tasks via the Click API can, however, be considered for any new Flask application—the
    fundamental principles are similar enough even though the implementations differ
    greatly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the infrequent tasks that we may require of a shell script,
    such as exporting computed data, sending e-mails to a subset of users, and so
    on, there are certain tasks from our previous applications that may be ported
    over to the Flask-Script CLI commands:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating/deleting our current database schema, thus replacing our `database.py`
    from previous projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running our Werkzeug development server, replacing `run.py` from previous projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, as Flask-Script is the current de facto solution to write reusable
    CLI scripts for Flask applications, many other extensions publish CLI commands
    that can be integrated in your existing application.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be creating an application that stores the data pulled
    from the `Github` API in a local database.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Git is a **distributed version control system** (**DVCS**) that has become incredibly
    popular in the last few years and with good reason. It has quickly become the
    go-to version control system for an incredible amount of open source projects
    written in a variety of languages.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub, the most well-known hosting platform for Git repositories of open and
    close source code, is also endowed with a wonderfully complete API that allows
    for a programmatic access to the data and metadata (comments, pull requests, issues,
    and so on) that is available, depending on the authenticated credentials provided.
  prefs: []
  type: TYPE_NORMAL
- en: To fetch this data, we will create a simple Flask extension to encapsulate the
    REST-based API queries in order to fetch the relevant data, and we will then use
    this extension to create a CLI tool (via Flask-Script) that can be manually run
    or hooked up to a event-based or time-based scheduler, such as cron.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get into any of this, however, let's set up a very simple application
    skeleton so that we can begin the Flask-Script integration.
  prefs: []
  type: TYPE_NORMAL
- en: Starting off
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We once again reach for our basic Blueprint-based application structure and
    create a whole new virtual environment and directory for this new venture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The application layout that we''ll start off with is very similar to what we
    used in previous Blueprint-based projects, with the main difference being the
    `manage.py` script, which will be the main entry point for our Flask-Script CLI
    commands. Also note the lack of `run.py` and a `database.py`, which we alluded
    to previously and will explain in more detail shortly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In keeping with our previous work, we continue to use the `Application Factory`
    pattern to allow the instantiation of our application to happen at runtime instead
    of at module import time, as we shall do with the Flask-SQLAlchemy extension that
    we have become quite familiar with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `application/__init__.py` file contains the following, which you should
    recognize quite well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `application/settings.py` file contains the very basics that we require
    for a Flask-SQLAlchemy application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will be using SQLite as our database of choice for this particular project;
    adjust the URI accordingly in case you decide to use a different database.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of expediency, we''ll introduce simplified `Repository` and `Issue`
    models that will contain the data we want to collect. These models will exist
    in `application/repositories/models.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: A `Repository` model instance will contain metadata that pertains to a given
    Git repository hosted on GitHub with a one-to-many relationship to the `Issue`
    model, which we will define next. The fields that we have declared in this `Repository`
    class should be self-explanatory for the most part, the one exception being `__table__args__
    dunder`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A **dunder** is a Python-specific neologism that is used to refer to any variable
    or method that begins with two underscores: a *double underscore* or *dunder*,
    for short. There are several built-in dunder methods (for example, `__init__`)
    and attributes (for example, `__name__`), and any attributes / methods / functions
    that you declare and prefix with two underscores will fall under this category
    as well.'
  prefs: []
  type: TYPE_NORMAL
- en: This class attribute allows us the ability to specify a table-specific configuration
    to the underlying SQLAlchemy table that is created. In our case, we will use it
    to specify a UniqueConstraint key on a compound value, the combination of the
    name and owner, which would otherwise not be possible via the typical attribute-based
    field definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we defined an issues attribute whose value is a relationship to
    the `Issue` model; this is the classic one-to-many relationship, and accessing
    the issues attribute of a repository instance will yield the list of issues that
    are attached to the repository in question.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the specified relationship does not include any arguments pertaining
    to the nature of the query or loading behavior of the related data. We are using
    the default behavior for this application, which is not a good idea for the repositories
    that contain a significant amount of issues—a dynamic lazyload approach as was
    used in a previous chapter may be a better choice in such a situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Issue` model, which we alluded to in the `Repository` model that we defined,
    is designed to contain the GitHub issue metadata associated with a Git repository
    hosted here. As issues only make sense in the context of a repository, we ensure
    that the `repository_id` foreign key exists for all the issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Each instance of an `Issue` model will encapsulate a very limited set of information
    regarding a GitHub issue that was created, including the issue number, state of
    the issue (*closed* or *open*), and title that was given to the issue.
  prefs: []
  type: TYPE_NORMAL
- en: At this point in previous chapters, we would have created a `database.py` script
    to initialize the construction of our SQLAlchemy models in our database. In this
    chapter, however, we will use Flask-Script to write a small CLI command that will
    do the same thing but provide us with a more consistent framework to write these
    little administrative tools and avoid the dozens of independent script files that
    end up plaguing any nontrivial application over time.
  prefs: []
  type: TYPE_NORMAL
- en: The manage.py file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By convention, the main entry point for Flask-Script is a Python file named
    `manage.py` that we place sibling to the `application/` package as we described
    in our project layout in the beginning of this chapter. While Flask-Script contains
    quite a few options—configurations and customizability—we'll use the simplest
    of the available invocations to encapsulate the functionality of the `database.py`
    Python script that we used in previous chapters in order to handle the initialization
    of our database.
  prefs: []
  type: TYPE_NORMAL
- en: 'We instantiate a `Manager` instance, which will handle the registration of
    our various commands. The `Manager` constructor takes a Flask application instance
    as an argument, but it can also (thankfully!) accept a function or class that
    implements the callable interface that returns an application instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a `manager` instance, we use the `command` method of this
    instance to decorate functions that we would like to turn into CLI commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that, by default, the function name that we wrap with the `command` method
    will be the identifier used in the CLI invocation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the whole thing running, we call the `run` method of the manager instance
    when we invoke the `manage.py` file directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we can execute our CLI command via the Python interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Assuming everything worked as expected, we should see no results (or errors,
    for that matter) and our database should be initialized with the tables, columns,
    and indexes that we specified in our model definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a diametrically opposite command that will allow us to destroy
    our local database; this can sometimes be handy when making a lot of changes to
    our data model during development:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We invoke this newly created `drop_db` command in exactly the same manner as
    we invoked the previously defined `init_db` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The built-in default commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In addition to giving us the ability to quickly define our own CLI commands,
    Flask-Script includes a few defaults so that we don''t have write them ourselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Flask-Script automatically generates a help text for the registered commands
    based on `docstrings` of the relevant functions. Additionally, running the `manage.py`
    script without a specified command or with the `help` option will display the
    full list of the top-level commands available.
  prefs: []
  type: TYPE_NORMAL
- en: 'If, for whatever reason, we''d like to customize the defaults, it''s relatively
    easy to accomplish. For example, we need the development server to run on port
    6000 instead of the 5000 default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've used the alternative method of defining a CLI command using the
    `manager.add_command` method, which takes a name and subclass of `flask.ext.script.command`
    as the second argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can override the default shell command so that our interactive
    Python shell contains a reference to our configured Flask-SQLAlchemy database
    object in addition to the Flask app object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can verify that our `db` object has been included by executing the `manage.py`
    script to invoke the interactive shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that the default Flask application server runs on the port that we specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Flask-Script provides several configuration options for the default `runserver`
    and `shell` commands, including the ability to disable them completely if you
    want. You can consult the online documentation for additional details.
  prefs: []
  type: TYPE_NORMAL
- en: The Flask-Script commands across Blueprints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ability to create ad hoc CLI commands in our application-level `manage.py`
    is both a blessing and curse: A blessing because it requires very little boilerplate
    to get up and running and a curse because it can very easily spiral into an unmanageable
    mess of code.'
  prefs: []
  type: TYPE_NORMAL
- en: To stave off this somewhat inevitable end state for any nontrivial application,
    we will use the underutilized feature of submanagers in Flask-Script in order
    to create a set of CLI commands that will live inside a blueprint but will be
    accessible via the standard `manage.py` invocation. This should allow us to keep
    the domain logic for our command-line interfaces in the same location(s) as the
    domain logic for our web-based components.
  prefs: []
  type: TYPE_NORMAL
- en: Submanagers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our first Flask-Script submanager will contain the logic to parse a GitHub
    project URL to the component pieces that we require to create a valid `Repository`
    model record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The general idea is that we'd like to be able to create a new `Repository` object
    with the name, owner, and description parsed from the positional and named arguments
    provided to the "add" function of the "repositories" submanager.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started by creating the module that will contain our repository
    CLI commands in `application/repositories/cli.py` with an empty `add` function
    for the moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that our `repository_manager` instance was created without an application
    instance or a callable that will return an application instance. Instead of providing
    the application object here, we will register our newly created submanager instance
    with our main application manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This will let us invoke the `repositories` manager and show us the available
    subcommands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'While this will produce no results (due to the function body being a simple
    pass statement), we can invoke our `add` subcommand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The required and optional arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any command registered with a Flask-Script manager may have zero or many required
    arguments in addition to any number of optional arguments with arbitrary defaults.
  prefs: []
  type: TYPE_NORMAL
- en: Our `add` command requires one mandatory argument, the URL of the repository
    to be added to our database, and one optional argument, a description of this
    repository. The command decorator takes care of a large number of the most basic
    cases, turning named function arguments to their CLI argument equivalents and
    function arguments with default values to optional CLI arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that we can specify the following function declaration to match
    what we wrote down previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to capture the arguments provided to our CLI manager and have
    them readily available in our function body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As we''ve managed to properly encode the desired interface for the CLI tool,
    let''s add some parsing to extract out the relevant bits and pieces that we want
    from the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We follow the `*nix` convention of returning a non-zero value between 1 and
    127 (the convention is to return 2 for syntax errors and 1 for any other kind
    of error) when a script encounters an error condition. As we expect our script
    to successfully add a repository object to our database, any situation where this
    does not occur could be considered an error condition and should thus return a
    non-zero value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we capture and process the CLI arguments correctly, let''s use this
    data to create our `Repository` objects and persist them to our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we have taken care of the situation where a duplicate repository (that
    is, with the same name and from the same owner) is added to the database. Without
    capturing `IntegrityError`, the CLI command would fail and spit out a stack trace
    indicating the unhandled exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running our newly implemented CLI command now yields the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The successful creation of our `Repository` object may be verified in our database.
    For SQLite, the following would suffice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Flask extensions – the basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We spent a great deal of time installing, configuring, and using various Flask
    extensions (Flask-Login, Flask-WTF, Flask-Bcrypt, and others). They provide us
    with a consistent interface to configure third-party libraries and tools and often
    integrate some Flask-specific niceties that make application development just
    a bit more enjoyable. One thing that we have not touched upon, however, is how
    to build your own Flask extension.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will only be looking at the framework necessary to create a valid Flask extension
    to be used locally in a project. If you desire to package your custom extension
    and publish it on PyPi or GitHub, you will need to implement the proper `setup.py`
    and setuptools machinery to make this possible. You can follow the setuptools
    documentation for further details.
  prefs: []
  type: TYPE_NORMAL
- en: When should an extension be used?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A Flask extension usually falls under one of the following two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulating the functionality provided by a third-party library, ensuring
    that this third-party library will function correctly when multiple Flask applications
    exist in the same process, and possibly adding some convenient functions/objects
    that make the integration with Flask more concrete; for example, Flask-SQLAlchemy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The codification of patterns and behaviors that do not require a third-party
    library but ensure a set of consistent functionalities for an application; for
    example, Flask-Login
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The majority of the Flask extensions that you will encounter in the wild or
    develop yourself will fall under the first category. The second category is a
    bit of an outlier and often arises from common patterns observed in multiple applications
    that are then abstracted and refined to the point where they can be put in an
    extension.
  prefs: []
  type: TYPE_NORMAL
- en: Our extension – GitHubber
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The extension that we will build in this chapter will encapsulate a small portion
    of the `Github` API that will allow us to fetch the list of issues for a given
    repository that we previously tracked.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Github` API allows for more functionalities than what we need it for and
    the documentation is excellent. Additionally, there exist several third-party
    Python libraries that encapsulate much of the `Github` API, of which we will be
    using one.
  prefs: []
  type: TYPE_NORMAL
- en: 'To simplify the interaction with GitHub''s v3 API, we''re going to install
    the `github3.py` Python package to our local virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As we're developing the extension in our Hublot application, we're not going
    to introduce the additional complexity of a separate project for the custom Flask
    extension. If you intend, however, to release and/or distribute an extension,
    you'll want to ensure that it is structured in such a way that it can be made
    available via the Python Package Index and installable via setuptools (or distutils,
    if you'd rather only use packaging tools that are included in the standard library).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an `extensions.py` module sibling to `application/repositories/
    package` and introduce the basic structure that any Flask extension should contain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: For most extensions, this is all that is required. Note that the basic extension
    is a plain old Python object (colloquially referred to as a POPO) definition,
    augmented with an `init_app` instance method. This method is not strictly necessary.
    If you don't plan on having the extension use the Flask application object (for
    example, to load configuration values) or if you have no intention of using the
    application factory pattern, then `init_app` is superfluous and can be omitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'We flesh out the extension by adding a few configuration-level checks to ensure
    that we have `GITHUB_USERNAME` and `GITHUB_PASSWORD` for API-authenticated API
    access. Additionally, we store the current extension object instance in `app.extensions`,
    which makes the dynamic usage/loading of the extension more straightforward (among
    other things):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Making authenticated requests to the `Github` API requires some form of authentication.
    GitHub supports several of these methods but the simplest is specifying the username
    and password for the account. Generally, this is not something that you want to
    ask your users to give you: it''s better to use the OAuth authorization flow for
    these situations in order to avoid storing user passwords in cleartext. However,
    for our rather simple application and custom extension, we''ll forgo the extended
    OAuth implementation (we''ll look at OAuth more extensively in a later chapter)
    and use the username and password combination.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On its own, the extension that we created doesn''t do very much. Let''s fix
    this by adding a property-decorated method that instantiates the `github3.py Github`
    API client library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding `client` method, we've implemented the caching property pattern,
    which will ensure that we only ever instantiate a single `github3.py` client per
    created application instance. Additionally, the extension will load the `Github`
    API client lazily on the first access, which is generally a good idea. This lets
    us use the client property of the extension to interface directly with the `github3.py`
    Python library once the application object has been initialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the basic setup for our custom Flask extension, let''s initialize
    it and configure the extension itself in our application factory in `application/__init__.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note the `hubber = Githubber()` initialization and assignment that happens outside
    of the factory itself, but the actual `init_app(app)` method call and implied
    extension configuration that occurs in the factory after we've initialized a Flask
    application object. You've probably noticed this split pattern (and we've discussed
    it several times in previous chapters as well), but now you've seen the reasoning
    behind it via the development of your own extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in mind, we add an additional function to our `application/repositories/cli.py`
    module for some additional CLI tooling power:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: After fetching the repository object from the database (based on the ID value
    specified via the CLI argument), we invoke the `client.repository()` method of
    our `Githubber` extension, which we imported as `hubber`, the name it was assigned
    during the instantiation in the factory preamble. As a part of our extension takes
    care of initializing it with the credentials required to make authenticated requests,
    we don't need to handle this in the CLI tool that invokes it.
  prefs: []
  type: TYPE_NORMAL
- en: Once we've obtained a reference to the remote GitHub repository, we iterate
    over the registered issues via the `iter_issues()` method provided by `github3.py`
    and then create the `Issue` instances that we persist to the SQLAlchemy session.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A welcome improvement to the current `Issue` model would be the introduction
    of a compound index on `repository_id` and the number with a unique constraint
    to ensure that imported issues are not duplicated in case we run the preceding
    command more than once on the same repository.
  prefs: []
  type: TYPE_NORMAL
- en: Handling of the raised exception on the insertion of a duplicate would then
    need to happen in the preceding CLI command as well. The implementation is left
    as a (relatively simple) exercise for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: These types of CLI tools are very useful to script actions and behaviors that
    could be considered too costly to occur in-band of a current user request of a
    typical web application. The last thing that you want is for a user of your application
    to wait seconds, if not minutes, for some action to complete that you have almost
    no control over. Instead, it's better to have these events occur out of band.
    Popular methods of accomplishing this include cron jobs and job/task queues such
    as those implemented by Celery (which may be event-driven instead of scheduled
    to run at fixed time intervals such as cron jobs), to name a few.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading through this chapter, you should be more familiar with the inner
    workings of Flask extensions and command line-based interfaces to the application
    via Flask-Script.
  prefs: []
  type: TYPE_NORMAL
- en: We began by creating a simple application for the data corresponding to the
    repositories and issues hosted on GitHub and then installed and configured our
    `manage.py` script to act as our bridge for the Flask-Script default CLI runserver
    and shell commands. We added the `drop_db` and `init_db` global commands to replace
    the `database.py` script that we used in previous chapters. Once this was in place,
    we turned our attention to creating the script submanagers in Blueprints that
    we could control via the main `manage.py` interface script.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we implemented our own Flask extension that wrapped some basic configuration
    and resource instantiation of the `github3.py Github` API client. Once this was
    finished, we went back to our previously created submanager script and added the
    required functionality to fetch the list of issues stored on GitHub for a given
    repository ID.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a deeper dive into third-party APIs, where
    we will build an application that uses the OAuth authorization protocol in order
    to implement user account creation and login via Twitter and Facebook.
  prefs: []
  type: TYPE_NORMAL
