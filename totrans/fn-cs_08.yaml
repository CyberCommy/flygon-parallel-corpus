- en: Chapter 8. Optimizing the Code using Laziness and Caching Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We discussed recursion, which help us to iterate sequences easily, in the previous
    chapter. Furthermore, we need to discuss about optimizing code since it is an
    essential technique if we want to develop a good program. In a functional approach,
    we can use laziness and caching techniques to make our code efficient so that
    it will run faster. By discussing laziness and caching techniques, we will be
    able to develop efficient code. To learn more about laziness and caching techniques,
    in this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing laziness in our code: lazy enumeration, lazy evaluation, nonstrict
    evaluation, and lazy initialization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The benefit of being lazy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching expensive resources using precomputation and memoization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to laziness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we talk about being lazy in our daily activity, we might think about something
    we don't do but we actually have to do. Or, we might put off doing something just
    because we are lazy. In functional programming, laziness is analogous to our laziness
    in daily activities. The execution of particular code is deferred due to the concept
    of laziness thinking. In [Chapter 5](text00039.html#page "Chapter 5. Querying
    Any Collection Easily with LINQ") , *Querying Any Collection Easily with LINQ*
    we mentioned that LINQ implemented deferred execution when querying data from
    a collection.
  prefs: []
  type: TYPE_NORMAL
- en: The query will be executed only when it's enumerated. Now, let's discuss the
    laziness concept we can use in the functional approach.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy enumeration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the .NET framework, there are some techniques to enumerate a collection of
    data, such as array and `List<T>` . However, implicitly, they are eager evaluations
    since in an array, we have to define its size first and then fill in the allocated
    memory before we use it. `List<T>` has a similar concept compared to array. It
    adopts the array mechanism. The difference between these two enumeration techniques
    is that we can easily expand the size in `List<T>` rather than array.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, the .NET framework has `IEnumerable<T>` to enumerate data collection,
    and fortunately, it will be evaluated lazily. Actually, array and `List<T>` implement
    the `IEnumerable<T>` interface, but because it has to be filled by data it has
    to be eagerly evaluated. We used this `IEnumerable<T>` interface when we dealt
    with LINQ in [Chapter 5](text00039.html#page "Chapter 5. Querying Any Collection
    Easily with LINQ") , *Querying Any Collection Easily with LINQ* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The `IEnumerable<T>` interface implements the `IEnumerable` interface, which
    is defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'There is only a single method that the `IEnumerable<T>` interface has: `GetEnumerator()`
    . The definition of this method is similar to what is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `GetEnumerator()` method returns the `IEnumerator<T>` data
    type. This type has only three methods and a single property. Here are the methods
    and properties it has:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Current` : This is a property that stores the element of the collection for
    the current position of the enumerator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Reset()` : This is a method that sets the enumerator to the initial position,
    which is before the first element of the collection. The index of the initial
    position is usually *-1* (minus one).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MoveNext()` : This is a method to move the enumerator to the next collection
    element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dispose()` : This is a method to free, release, or reset unmanaged resources.
    It''s inherited from the `IDisposable` interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s play with the Fibonacci algorithm, which will generate infinite
    numbers. The algorithm will generate sequences by adding the previous two elements.
    In mathematical terms, the formula can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first two numbers for the calculation of this algorithm can be 0 and 1 or
    1 and 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this algorithm, we are going to prove that the `IEnumerable` interface
    is a lazy evaluation. So, we create a class named `FibonacciNumbers` , which implements
    the `IEnumerable<Int64>` interface that we can find in the `LazyEnumeration.csproj`
    project, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the `FibonacciNumbers` class implements the `IEnumerable<T>` interface,
    it has the `GetEnumerator()` method, as we discussed earlier, to enumerate the
    data collection. And because the `IEnumerable<T>` interface implements the `IEnumerator<T>`
    interface, we create the `FibEnumerator` class, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have the `FibEnumerator` class that implements the `IEnumerator<T>`
    interface. Since the class implements `IEnumerator<T>` , it has the `Reset()`
    , `MoveNext()` , and `Dispose()` methods, as we have discussed already. It also
    has the `Current` property from the implementation of the `IEnumerator<T>` interface.
    We add the `Last` property to save the last current number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to create the caller to instantiate the `FibonacciNumbers`
    class. We can create the `GetFibonnacciNumbers()` function, which has an implementation
    similar to what is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the `FibonacciNumbers` class will enumerate infinite numbers, we have
    to use the `Take()` method, as shown in the following code snippet, in order not
    to create an infinite loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose we need to enumerate 40 numbers from the sequence; we can pass 40 as
    an argument to the `GetFibonnacciNumbers()` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And if we run the preceding function, we will get the following output on the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lazy enumeration](img/Image00094.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can get the preceding output on the console since `IEnumerable` is a lazy
    evaluation. This is because the `MoveNext()` method will only be called to calculate
    the result if it's asked to do so. Imagine if it's not lazy and is always called;
    then, our previous code will spin and result in an infinite loop.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy evaluation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simple example we have on lazy evaluation is when we deal with two Boolean
    statements and need to compare them. Let''s take a look at the following code,
    which demonstrates lazy evaluation, which we can find in the `SimpleLazyEvaluation.csproj`
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the `MemberData` class we use in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And if we run the preceding `GetMember()` method, we will get the following
    output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lazy evaluation](img/Image00095.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we know, when we use the `||`  (OR) operator in the Boolean expression,
    it will result in `TRUE` if at least one expression is `TRUE` . Now take a look
    at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, when the compiler finds that member `!= null` is `FALSE`
    , it then evaluates the other expression, which is `member.Age > 50` . Since the
    member is null, it has no `Age` property; so, when we try to access this property,
    it will throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s refactor the preceding code snippet into the following code using
    the `&&` (AND) operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete method named `GetMemberANDOperator()` will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding `GetMemberANDOperator()` method, we will get the following
    output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lazy evaluation](img/Image00096.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, the `if` statement has been successfully executed and it results in `FALSE`
    after being evaluated. However, the `member.Age > 50` expression is never evaluated
    in this case so that the exception is not thrown. The reason why the `member.Age
    > 50` expression is not evaluated is that the compiler is too lazy to do it since
    the first expression, `member != null` , is `FALSE` and the result of this `&&`
    logical operation will result in `FALSE` regardless of the result of other expression.
    We can now say that laziness is ignoring another expression when it can decide
    the result using only one expression.
  prefs: []
  type: TYPE_NORMAL
- en: Nonstrict evaluation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some people may think that lazy evaluation is synonymous with nonstrict evaluation.
    However, it''s not actually synonymous since the evaluation of a particular expression
    will be ignored if it''s not needed in the lazy evaluation, while the reduction
    of evaluation will be applied in a nonstrict evaluation. Let''s take a look at
    the following code in order to distinguish strict and nonstrict evaluation, which
    we can find in the `NonStrictEvaluation.csproj` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are going to calculate the formula of `x + (y * z)`
    . The `InnerFormula()` function will calculate the multiplication of `y` and `z`
    , while the `OuterFormula()` function will calculate the addition of `x` and the
    result of `y * z` . When evaluating the formula in strict evaluation, we first
    calculate the `(y * z)` expression to retrieve the value and then add the result
    to the `x` . The code will be like the following `StrictEvaluation()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, in the preceding code we invoke the `OuterFormula()` function
    like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'And for the strict evaluation we discussed earlier, the output we get on the
    console will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Nonstrict evaluation](img/Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding figure, when we calculate `4 + (3 * 2)` , we
    first calculate the result of `(3 * 2)` and then after getting the result, we
    add it to `4` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s compare it with nonstrict evaluation. In nonstrict evaluation,
    the `+` operator is reduced first and then we reduce the inner formula, which
    is `(y * z)` . We will see that the evaluation will be started from the outside
    to the inside. Now let''s refactor the preceding `OuterFormula()` function to
    the `OuterFormulaNonStrict()` function, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we modify the second parameter of the function into the `Func<int,
    int, int>` delegate. We will call `OuterFormulaNonStrict()` from the `NonStrictEvaluation()`
    function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that we pass the `InnerFormula()` function
    into the second parameter of the `OuterFormulaNonStrict()` function, as shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The expression in the preceding code snippet will be evaluated using nonstrict
    evaluation. To prove this, let''s run the `NonStrictEvaluation()` function, and
    we will get the following output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Nonstrict evaluation](img/Image00098.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that our expression is evaluated from the outside to the inside.
    The `OuterFormulaNonStrict()` function is run first even though the result of
    the `InnerFormula()` function is not retrieved yet. And if we run the `OuterFormula()`
    function and the `OuterFormulaNonStrict()` function consecutively, we will get
    a clear difference in the order of the evaluation, as shown in the following output
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Nonstrict evaluation](img/Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we can compare the difference. In strict evaluation, the calculation of
    `(3 * 2)` is run first and then fed to the `(4 + InnerFormula())` expression,
    while in nonstrict evaluation, the `(4 + InnerFormula())` expression is run before
    the calculation of `(3 * 2)` .
  prefs: []
  type: TYPE_NORMAL
- en: Lazy initialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lazy initialization is an optimizing technique where the object creation is
    deferred until it is used. It means that we can define an object but it won''t
    be initialized if the member of the object is not accessed yet. C# introduced
    the `Lazy<T>` class in C# 4.0, and we can use to lazily initialize the object.
    Now, let''s take a look at the following code in order to demonstrate the lazy
    initialization that we can find in the `LazyInitialization.csproj` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We define the `PersonName` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding `LazyInitName()` function implementation, we
    lazily initialize the `PersonName` object using the `Lazy<T>` class, as shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'By doing this, `PersonName` isn''t actually initialized after we define the
    `pn` variable, like what we usually get when we define the class directly using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, using lazy initialization we access the object''s member in order
    to initialize it, as discussed earlier. `Lazy<T>` has a property named `Value`
    , which gets the value for the `Lazy<T>` instance. It also has the `IsValueCreated`
    property to indicate whether a value has been created for this `Lazy<T>` instance.
    In the `LazyInitName()` function, we use the `Value` property, as shown in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We use `(pn.Value as PersonName).Name` to access the `Name` property of the
    `PersonName` class, which has been instantiated by the `pn` variable. We use the
    `IsValueCreated` property to prove whether or not the `PersonName` class has been
    initialized, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s run the `LazyInitName()` function and pass `Matthew Maxwell` as
    its argument, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lazy initialization](img/Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding screenshot, we have five lines of information. The first
    line we get is when `PersonName` is defined. We then check the value of the `IsValueCreated`
    property to find whether `PersonName` has been initialized. We get the `FALSE`
    result, which means that it's not initialized yet; so we have the second line
    of the information on the console. The next two lines are the interesting things
    we get from lazy initialization. When we access the `Value` property of the `Lazy<T>`
    class to retrieve the `Name` property of the `PersonName` instance, the code calls
    the constructor of `PersonName` before it accesses the `Name` property of `PersonName`
    class. This is why we have lines 3 and 4 in the preceding console. And after we
    check the `IsValueCreated` property again, we find that `PersonName` has now been
    initialized and the `pn` variable has an instance of `PersonName` .
  prefs: []
  type: TYPE_NORMAL
- en: The advantages and disadvantages of being lazy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have learned about laziness so far. We can also elaborate the advantages
    of being lazy, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: We don't need to pay the initialization time for features we don't use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The program execution becomes more efficient because sometimes, in the functional
    approach, the order of the execution is not important compared to the imperative
    approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being lazy will make a programmer write better code by writing efficient code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Besides the advantages, being lazy also has disadvantages, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: The flow of the application is hard to predict and we can lose control over
    our application sometimes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code complexity in laziness can cause a bookkeeping overhead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching expensive resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we have to create an expensive resource in our program. It's not
    a problem if we only do it once. It will be a big problem if we do it over and
    over for the same function. Fortunately, in a functional approach, we will get
    the same output if we pass the exact same input or arguments. We can then cache
    this expensive resource and use it again when the passed argument is the same.
    Now we are going to discuss precomputation and memoization in order to cache the
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: Performing initial computation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the caching techniques we have is precomputation, which performs an
    initial computation in order to create a lookup table. This lookup table is used
    to avoid repetitive computation when a particular process is executed. Now we
    are going to create code to compare the difference in the process with and without
    precomputation. Let''s take a look at the following code, which we can find in
    the `Precomputation.csproj` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding simple `WithoutPrecomputation()` function will calculate the
    square of the two numbers that we input from 0 to 99\. Suppose we want to calculate
    the number `19` and `85` ; we will get the following output on the console window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Performing initial computation](img/Image00101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the function has done its job well. It asks for two input numbers
    from the user with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'It uses the `Math.Pow()` method in the `System` namespace in order to get to
    the power of n, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can refactor the `WithoutPrecomputation()` function to use precomputation
    techniques so that it doesn''t need any repetition calculation every time the
    user asks to calculate the power of the same numbers by two. The function we are
    going to have will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code, we create a lookup table named `powerOfTwos`
    in the beginning of the function, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we ask the user to input a number from 0 to 99, the lookup table will
    store the database of the power of two numbers from the range numbers. Moreover,
    the difference between the `WithPrecomputation()` function and the `WithoutPrecomputation()`
    function is that we have the collection of the power of two result. Now we use
    the `FindThePowerOfTwo()` function, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FindThePowerOfTwo()` function will look for the selected number in the
    lookup table, which in this case is `powerOfTwos` . And the implementation of
    the `FindThePowerOfTwo()` function will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `FindThePowerOfTwo()` function returns the value of the
    lookup table, whose index we specify with the `baseNumber` parameter. We will
    get the following output on the console if we run the `WithPrecomputation()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Performing initial computation](img/Image00102.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Again, we calculate the square of `19` and `85` and, indeed, we have the exact
    same result as what we get when we run the `WithoutPrecomputation()` function.
    Now, we have a lookup table of squared numbers from 0 to 99\. The advantages in
    our program are more effective since every time we ask to calculate the same number
    (`19` and `85` ), it will not need to run the calculation but will look for the
    result in the lookup table.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the precomputation code we explored earlier is not a functional approach
    since, each time the `FindThePowerOfTwo()` function is called, it will iterate
    the squares again. We can refactor it so that it will be functional using the
    power of currying, a technique to change structure arguments by sequence, which
    we discussed in [Chapter 1](text00016.html#ch01 "Chapter 1. Tasting Functional
    Style in C#") , *Tasting Functional Style in C#* . Now let''s take a look at the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If we compare the preceding `WithPrecomputationFunctional()` function with
    the `WithPrecomputation()` function, we can see that it uses the `CurriedPowerOfTwo()`
    function now, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `CurriedPowerOfTwo()` function, we split the function argument so
    that the curried variable can now handle the lookup table and we can call the `WithPrecomputationFunctional()`
    function as many times as we want with no need to iterate the lookup table again.
    The `CurriedPowerOfTwo()` function implementation can be found in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the `WithPrecomputationFunctional()` function, the following output
    will be displayed in our console window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Performing initial computation](img/Image00103.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Again, we have the exact same output compared to our previous functions: the
    `WithoutPrecomputation()` function and the `WithPrecomputation()` function. We
    have successfully refactored the function and the functional approach has been
    fulfilled in this precomputation technique.'
  prefs: []
  type: TYPE_NORMAL
- en: Memoization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides performing precomputation techniques to optimize the code, we can also
    use memoization techniques to make our code more optimal. Memoization is the process
    of remembering the result of the function with a specific input. Each time we
    execute a particular function with a specific input argument, the code will remember
    the result. So, each time we call the function with the exact same input argument
    again, the code doesn't need to run the code; instead. it will get it from the
    place it stores the result in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s borrow the repetitive `GetFactorial()` function we discussed in [Chapter
    5](text00039.html#page "Chapter 5. Querying Any Collection Easily with LINQ")
    , *Querying Any Collection Easily with LINQ* and then refactor it in order to
    use the memoization technique. As we know, the implementation of the `GetFactorial()`
    function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the `GetFactorial()` function use memoization, we have to save the
    result every time the `GetFactorial()` function returns a value. The refactoring
    code of the preceding `GetFactorial()` function will be as follows and we can
    find it in the `Memoization.csproj` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have a `Dictionary` class named `memoizeDict` to store all
    the results when the particular arguments have been passed to the `GetFactorialMemoization()`
    function. The definition of this dictionary is like what is shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Another difference when we compare the `GetFactorialMemoization()` function
    to the `GetFactorial()` function is that it now saves the result when the `GetFactorialMemoization()`
    function is run with the particular arguments that have been called so far. The
    following code snippet shows the code for this algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: First, we check whether the particular argument has been passed to the function.
    If so, it doesn't need to run the function; instead, it just retrieves the result
    from the dictionary. If the parameter arguments haven't been passed yet, the function
    is run and we save the result in the dictionary. Using memoization, we can optimize
    the code since we don't need to run the function over and over again if the arguments
    are exactly the same. Suppose we pass 10 to the `GetFactorialMemoization()` function.
    If we run the function again and pass 10 again, the processing speed time will
    increase since it doesn't need to run the repetitive `GetFactorialMemoization()`
    function. Fortunately, by passing 10 to the function parameter, it will also run
    the function with the 1-9 argument since it's a recursive function. The effect
    and the result of the invocation of these 10 items will be saved in the directory
    and calling the function using these arguments will be much faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s compare the performance of the `GetFactorial()` function with the
    `GetFactorialMemoization()` function. We will pass `9216` as an argument and run
    them it times. The following is the `RunFactorial()` function used to call the
    `GetFactorial()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the `RunFactorial()` function, we will get the following output on
    the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Memoization](img/Image00104.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see from the output, we need `281461 ns` in the first invocation
    of the `GetFactorial()` function and about 75,000- 98,000 nanoseconds in the remaining
    invocations. The process speed is almost the same for all invocations since the
    recursive `GetFactorial()` function is invoked everytime. Now let''s move on to
    the following `RunFactorialMemoization()` function in order to call the `GetFactorialMemoization()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the `RunFactorialMemoization()` function, we will get the following
    output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Memoization](img/Image00105.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now we can see that, by using memoization, the process speed has increased to
    a great extent. Even though it needs the extra time in the first invocation of
    `GetFactorialMemoization()` , in the invocation 3 to 5, the process becomes faster.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We discussed that, by being lazy, we can create efficient code. Lazy enumeration
    is useful when we need to iterate an infinite loop so that it will not overflow
    since the `MoveNext()` method in `IEnumerator` will be run only if asked. Also,
    lazy evaluation makes our code run faster because the compiler does not need to
    check all Boolean expressions if one of them has given the result.
  prefs: []
  type: TYPE_NORMAL
- en: In nonstrict evaluation, we treat a function in programming like we treat a
    mathematical function. Using this evaluation technique, we use the functional
    approach to solve the function.
  prefs: []
  type: TYPE_NORMAL
- en: We have also become acquainted with the lazy initialization provided by the
    `Lazy<T>` class to defer the object's initialization, which means that we can
    define an object but it won't be initialized if the member of the object has not
    been accessed yet.
  prefs: []
  type: TYPE_NORMAL
- en: To optimize our code, we discussed caching techniques using precomputation and
    memoization. In precomputation, we prepare something like a lookup table so we
    don't need to run the function with the exact argument; instead, we just need
    to get the result from the table. We also have memoization in order to remember
    the result of the function with a specific input. Using memoization, every time
    we call the function with the exact same input argument again, the code doesn't
    need to run the code; instead, it will get it from the place where it stores the
    result.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss monads and their use in functional programming.
  prefs: []
  type: TYPE_NORMAL
