- en: Streamlining Development and Refactoring with Type-Safe React Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The tool of focus in this chapter is Flow, a static type checker for JavaScript
    applications. The scope of Flow and what you can do with it is enormous, so I''ll
    be introducing Flow in the context of a tool that''s used to make React components
    better. In this chapter, you''ll learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The problems that are solved by introducing type-safety into your React application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling Flow in your React projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Flow to validate your React components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other ways to enhance React development using type-safety
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does type-safety solve?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Type-safety is no silver bullet. For example, I'm perfectly capable of writing
    a type-safe application that's riddled with bugs. It's the kind of bugs that just
    sort of stop happening after a type-checker is introduced that are interesting.
    So what types of things can you expect after introducing a tool like Flow? I'll
    share three factors that I've experienced while learning Flow. The *Type System*
    section in the Flow docs goes into much more detail on this topic, available at [https://flow.org/en/docs/lang/](https://flow.org/en/docs/lang/).
  prefs: []
  type: TYPE_NORMAL
- en: Replacing guesswork with assurance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the nice features of a dynamically-typed language like JavaScript is
    that you can write code without having to think about types. Types are good and
    they do solve a lot of problems—the point I'm trying to make, believe it or not—but
    sometimes you need to be able to just write code without having to formally validate
    for correctness. In other words, sometimes guesswork is exactly what you need.
  prefs: []
  type: TYPE_NORMAL
- en: If I'm writing a function that I know takes an object as an argument, I can
    just assume that any object that's passed to my function will have the expected
    properties. This allows me to implement what I need to, without having to make
    sure that the correct types are passed as arguments. This will only work for so
    long, though. Because invariably, your code will get something unexpected passed
    to it as input. Once you have a complex application with many moving parts, type-safety
    can remove the guesswork.
  prefs: []
  type: TYPE_NORMAL
- en: Flow takes an interesting approach. Instead of compiling new JavaScript code
    based on types, it simply checks that the source is correct based on type annotations.
    These annotations are then removed from the source so that it can run. By using
    a type checker like Flow, you can be explicit about what each of your components
    is willing to accept as input, and how it iterates with the rest of the application
    by using type annotations.
  prefs: []
  type: TYPE_NORMAL
- en: Removing runtime checks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The solution to handling data with unknown types in dynamic languages such as
    JavaScript is to check values at runtime. Depending on the type of value, you
    might have to perform some alternate action to get the value that your code is
    expecting. For example, a common idiom in JavaScript is to make sure that a value
    is neither undefined or null. If it is, then we either throw an error or provide
    a default value.
  prefs: []
  type: TYPE_NORMAL
- en: When you perform runtime checks, it changes the way you think about your code.
    Once you start performing these checks, they inevitably evolve into more elaborate
    checks and more of them. This frame of mind really amounts to not trusting yourself
    or others to call code with the correct data. You think since it's likely that
    your function will be called with junk arguments, you need to be ready to handle
    anything that is thrown at your function.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, embracing type-safety means that you don't have to rely on
    implementing custom solutions to defend against bad data. Let the type system
    handle this for you instead. You just need to think about what types your code
    needs to work with, and go from there. Think what does my code need, not how do
    I get what my code needs.
  prefs: []
  type: TYPE_NORMAL
- en: Obvious low-severity bugs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you can use a type checker such as Flow to remove the insidious errors that
    creep up on you as a result of bad types, you're left with high-level application
    bugs. These bugs are obvious when they happen because the application is simply
    wrong. It produces the wrong output, it computes the wrong number, one of the
    screens doesn't load, and so on. You can more easily see and interact with these
    kinds of bugs. This makes them obvious, and when bugs are obvious, they're easier
    to track down and fix.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, you have bugs that are subtly wrong. These can result from
    bad types. What makes these types of bugs particularly horrifying is that you
    don't even know something is wrong. Something with your application could be slightly
    off. Or it could be outright broken because part of your code is expecting an
    array, but it sort of works because it's getting another kind of iterable that
    works in one place but not in others.
  prefs: []
  type: TYPE_NORMAL
- en: If you had just used type annotations and checked your source with Flow, it
    would have told you that you're passing something that isn't an array. There's
    no room for these types of errors when types are statically checked. It turns
    out that these are usually the more difficult bugs to figure out.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and initializing Flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you can start implementing type-safe React components, you need to install
    and initialize Flow. I'll show you how this is done with a `create-react-app`
    environment, but the same steps can be followed for almost any React environment.
  prefs: []
  type: TYPE_NORMAL
- en: You can install Flow globally, but I would recommend installing it locally,
    along with all the other packages that your project depends on. Unless there's
    a good reason to install something globally, install it locally. This way, anyone
    installing your application can get every dependency by running `npm install`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Flow locally, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will install the Flow executable locally to your project and will update
    your `package.json` so that Flow is installed as a dependency of your project.
    Now let''s add a new command to `package.json` so that you can run the Flow type
    checker against your source code. Make the `scripts` section look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can run Flow by executing the following command in your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will run the `flow` script as expected, but Flow will complain about not
    being able to find a Flow configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The easiest way to resolve this issue is to use the `flow init` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a `.flowconfig` file in your project directory. You don''t
    need to worry about changing anything in this file right now; it''s just that
    Flow expects it to be present. Now when you run `npm run flow`, you should get
    a message that indicates there are no errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It turns out that none of your source files were actually checked. This is
    because by default, Flow only checks files that have the `// @flow` directive
    as their first line. Let''s go ahead and add this line at the top of `App.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that Flow is checking this module, we''re getting an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'What does this mean? Flow attempts to provide an explanation on the next line
    of the error output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Flow is complaining about the `Component` class that you''re extending with
    `App`. This means that you need to provide at least one `type` argument to `Component`
    for props. Since `App` isn''t actually using any props, this could just be an
    empty type for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now when you run Flow again, there aren't any errors in `App.js`! This means
    that you've successfully annotated your module with type information that Flow
    used to statically analyze your source to make sure everything is sound.
  prefs: []
  type: TYPE_NORMAL
- en: So how did Flow know what the `Component` class from React was expecting in
    terms of its generics? It turns out that React is itself Flow type-annotated,
    and this is how you get specific error messages when Flow detects a problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s add the `// @flow` directive to the top of `index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run `npm run flow` again, you''ll see the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because the value of `root` comes from `document.getElementById(''root'')`.
    Since there''s no DOM for this method to return an element, Flow detects a `null`
    value and complains. Since this is a legitimate concern (the `root` element might
    not be there) and we need path for Flow to follow when there''s no element, you
    can add some logic to handle this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Before calling `ReactDOM.render()`, you can manually check the type of `root`
    to make sure that it's what Flow expects to see. Now when you run `npm run flow`,
    there are no errors.
  prefs: []
  type: TYPE_NORMAL
- en: You're all set! You have Flow installed and configured locally, and you have
    the initial source from `create-react-app` passing the type check. You can now
    proceed to develop type-safe React components.
  prefs: []
  type: TYPE_NORMAL
- en: Validating component properties and state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React was designed with Flow static type-checking in mind. The most common use
    of Flow in React applications is to validate that component properties and state
    are being used correctly. You can also enforce the types of components that are
    allowed as children of another component.
  prefs: []
  type: TYPE_NORMAL
- en: Prior to Flow, React would rely on the prop-types mechanism to validate values
    passed to components. This is now a separate package from React and you can still
    use it today. Flow is a superior choice over prop-types because it performs checks
    statically whereas prop-types performs runtime validation. This means that your
    application doesn't need to run superfluous code during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Primitive property values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most common types of values that are passed to components via props are
    primitive values—strings, numbers, and Booleans for example. Using Flow, you can
    declare your own type that says which primitive values are allowed for a given
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This component renders the name and version of some app. These values are passed
    in through property values. For this component, let''s say that you only want
    string values for the `name` property and number values for the `version` property.
    This module declares a new `Props` type, using the `type` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This Flow syntax allows you to create new types that can then be used to type
    function arguments. In this case, you have a functional React component where
    the props are passed as the first argument. This is where you tell Flow that the
    props object should have a specific type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, Flow can figure out if there's any places where we're passing
    invalid prop types to this component! Even better, this is done statically, before
    anything runs in the browser. Before Flow, you would have to use the `prop-types`
    package to validate component props during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put this component to use, and then we''ll run Flow. Here''s `App.js`
    using the `Intro` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The property values that are passed to `Intro` meet the expectations of the
    `Props` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You can validate this by running `npm run flow`. You should see `No errors!`
    as the output. Let''s see what happens if we change the type of these properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''re passing a string where a number is expected, and a number where
    a string is expected. If you run `npm run flow` again, you should see the following
    errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'These two errors go to great lengths to show you what the problem is. It starts
    by showing you where the component property values were passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, it shows you where the `Props` type is being used—to declare the type
    of the properties argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, it shows you what the exact problem with the type is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The Flow error messages try to give you as much information as possible, meaning
    less time spent by you, hunting down files.
  prefs: []
  type: TYPE_NORMAL
- en: Object property values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding section, you learned how to check for primitive property types.
    React components can also accept objects with primitive values—and other objects.
    If your component is expecting an object as a property value, you can use the
    same approach as you did for primitive values. The difference is how you structure
    your `Props` type declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This component expects a `person` property which is an object. Further, it
    expects this object to have a `name` string property and a number `age` property.
    In fact, if you had other components that required a `person` property, you could
    break this type down into reusable parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s take a look at values being passed to this component as properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of passing the `Person` component several property values, it''s passed
    a single property value, an object that meets the type expectations of the `Props`
    type. If it doesn''t, Flow will complain. Let''s try removing a property from
    this object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when you run `npm run flow`, it complains about the missing property of
    the object passed to `person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: No matter how exotic you get with property values, Flow can figure out if you're
    misusing them. Trying to accomplish the same thing at runtime using something
    like `prop-types` is cumbersome at best.
  prefs: []
  type: TYPE_NORMAL
- en: Validating component state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can validate the properties of functional React components by typing the
    props argument that's passed to the component. Some of your components will have
    state and you can validate a component's state much the same as with properties.
    You can create a type that represents the state of your component, and pass this
    to `Component` as a type argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a container component that has state that is used and
    manipulated by a child component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Child` component rendered by `Container` takes an `on` Boolean property
    and a `toggle` function. The `toggle()` method that is passed to `Child` will
    change the state of `Container`. This means that `Child` can call this function
    in order to change the state of its parent. At the top of the module, above the
    component class, there''s a `State` type that''s used to specify what values are
    allowed to be set as state. In this case, the state is just a simple `on` Boolean
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This type is then passed as a type argument to `Component` when it''s extended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'By passing this type argument to `Component`, you can bow set component state
    however you want. For example, the `toggle()` method is called by the `Child`
    component to change the state of the `Container` component. If this call sets
    the state incorrectly, Flow will detect it and complain. Let''s change the `toggle()`
    implementation so that it fails by setting the state to something that disagrees
    with Flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll get an error that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Setting the state incorrectly on a component is easy to do during development,
    so having Flow tell you what you're doing wrong is a real time saver.
  prefs: []
  type: TYPE_NORMAL
- en: Function property values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's perfectly normal to pass functions from one component to another as a property.
    You can use Flow to ensure that not only are functions passed to the component,
    but also that the correction type of function is passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine this idea by looking at a common pattern in React applications.
    Let''s say that you have the following `Articles` component that renders `Article`
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `Articles` component is a container component because it has state and it
    uses this state to render child `Article` components. It also defines an `onClick()`
    method that changes the `summary` state and the `selected` state. The idea is
    that the `Article` component needs access to this method so that it can trigger
    state changes. If you pay close attention to the `onClick()` method, you'll notice
    that it's actually returning a new event handler function. This is so that when
    the click event actually calls the returned function, it will have scoped access
    to the selected argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s take a look at the `Article` component and see how Flow can help
    you make sure that you''re getting the function you expect passed to your component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onClick` handler of the `<a>` element that this component renders calls
    the `onClick()` function that was pass in as a property, expecting a new function
    in return. If you take a look at the `Props` type declaration, you can see that
    the `onClick` property expects a specific type of function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This tells Flow that this property must be a function that accepts a number
    argument and returns a new function. Passing this component an event handler function
    instead of a function that returns the event handler function is an easy mistake
    to make. Flow can easily spot this and make it easy for you to correct.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcing child component types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to validating the types of state and property values, Flow can also
    validate that your component is getting the right child components as well. The
    following sections will show you common scenarios where Flow can tell you when
    you're misusing a component by passing it the wrong children.
  prefs: []
  type: TYPE_NORMAL
- en: Parents with specific children types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can tell Flow that a component should only work with specific types of
    child components. Let''s say that you have a `Child` component, and this is the
    only type of component that should be allowed as a child of the component you''re
    working on. Here''s how you can tell Flow about this constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start with the first `import` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The reason that you want to import the asterisk as `React` is because this will
    pull in all of the Flow type declarations available within React. In this example,
    you're using the `ChildrenArray` type to specify that the value is in fact a child
    of the component, and `Element` to specify that you need a React element. The
    type argument that's used in this example tells Flow that the `Child` component
    is the only type of component that's acceptable here.
  prefs: []
  type: TYPE_NORMAL
- en: 'This JSX will pass flow validation, given the child constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: There's no restriction on the number of `Child` components that are rendered
    as children of `Parent`, just as long as there's at least one.
  prefs: []
  type: TYPE_NORMAL
- en: Parents with one child
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For some components, it makes no sense to have more than one child. For these
    cases, you would use the `React.Element` type instead of the `React.ChildrenArray`
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the example before this one, you can still specify the type of child
    component that is allowed. In this case, the child component is called `Child`,
    imported from `''./Child''`. Here''s how you would pass this component a child
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If you were to pass it multiple `Child` components, Flow would complain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Once again, the Flow error message shows you exactly what is wrong with your
    code and where.
  prefs: []
  type: TYPE_NORMAL
- en: Parents with an optional child
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Always requiring a child component isn''t necessary and can actually cause
    headaches. For example, what if there is nothing to render because nothing was
    returned from the API? Here''s an example of how to specify that a child is optional
    using Flow syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks a lot like a React component that requires a specific type of element.
    The difference is with the question mark: `children?`. This means that either
    a child component of type `Child` may be passed, or no child at all.'
  prefs: []
  type: TYPE_NORMAL
- en: Parents with primitive child values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s common to render React components that take primitive values as children.
    In some cases, you might want to accept a string or a Boolean type. Here''s how
    you would do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, you can use the `React.ChildrenArray` type to specify that multiple
    child elements are allowed. To specify a specific child type, you pass it to `React.ChildrenArray`
    as a type argument—in this case a string and Boolean union. Now you can render
    this component with a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Or with a Boolean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Or with both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Validating event handler functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React components use functions to respond to events. These are called **event
    handler functions**, and they're passed an event object as an argument when the
    React event system calls them. It can be useful to use Flow to explicitly type
    these event arguments to make sure that your event handler is getting the type
    of element that it expects.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, assume that you''re working on a component that responds to clicks
    from an `<a>` element. Your event handler function also needs to interact with
    the clicked element, in order to get the `href` property. Using the Flow types
    exposed by React, you can ensure that the correct element type is indeed triggering
    the event that is causing your function to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The `clickHandler()` function in this example is assigned as the `onClick`
    handler of an <a> element. Notice the type of the event argument: `SyntheticEvent<HTMLAnchorElement>`.
    Flow will use this to make sure that your code that uses the event is only accessing
    the appropriate properties of the event, and `currentTarget` of the event.'
  prefs: []
  type: TYPE_NORMAL
- en: '`currentTarget` is the element that triggered the event, and in this example,
    you''ve specified that it should be `HTMLAnchorElement`. Had you used another
    type, Flow would complain about you referencing the `href` property, because that
    doesn''t exist in other HTML elements.'
  prefs: []
  type: TYPE_NORMAL
- en: Bringing Flow into the development server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wouldn't it be great if type-checking your React code were more tightly-integrated
    into the `create-react-app` development process? There's been talk of making this
    a reality in a future release of `create-react-app`. For now, you'll have to eject
    from `create-react-app` if you want this functionality for your project.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this approach is to have the development server run Flow for you
    whenever changes are detected. Then, you can see the Flow output in your dev server
    console output, and in the browser console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve ejected from `create-react-app` by running `npm eject`, you need
    to install the following Webpack plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you need to enable the plugin by editing `config/webpack.config.dev.js`.
    First, you need to include the plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you need to add the plugin to the array in the `plugins` option. This
    array should look something like this afterward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all there is to it. Now when you start your dev server, Flow will automatically
    run and type-check your code as part of the Webpack build process. Let''s add
    the `@flow` directive to the top of `App.js` and run `npm start`. Since the `App`
    component won''t validate as a subclass of `Component`, you should get an error
    in the dev server console output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'What I really like about this approach is that the dev server will still start,
    even if there''s a Flow error. If you look at the app in your browser, you''ll
    see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/3b760a4f-2ae2-47cf-afa9-527bb9be4fa1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This means that you don''t even have to look at your dev server console during
    development to catch type errors! And since it''s part of the development dev
    server, your code is rechecked by Flow every time you make a change. So let''s
    fix the current error in `App.js` by passing it a property type argument (`<{}>`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Once this change is made, save the file. Just like that, the error is gone and
    you're back in business.
  prefs: []
  type: TYPE_NORMAL
- en: Bringing Flow into your editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One final option that we'll look at for validating your React code using Flow
    is integrating the process into your code editor. I'm using the popular Atom editor
    so I'll use this as an example, but there are likely options for integrating Flow
    with other editors.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable Flow capabilities in the Atom ([https://atom.io/](https://atom.io/))
    editor, you''ll need to install the `linter-flow` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ae5686bc-9c22-44a0-a10c-e07202c52db4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once installed, you''ll need to change the executable path setting of `linter-flow`.
    By default, the plugin assumes that you have Flow installed globally, which, you
    probably don''t. You have to tell the plugin to look in the local `node_modules`
    directory for the Flow executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/0d2e1839-6db9-4019-ac26-08ffda5f2104.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You''re all set. To verify that this is working as expected, open up `App.js`
    from a fresh `create-react-app` install and add the `@flow` directive at the top
    of the file. This should trigger an error from Flow and should be displayed within
    Atom:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/09fe4981-2a7c-4620-98df-5a60dc5d2b13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Linter will also highlight the problematic code that''s causing Flow to
    complain as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/e0f29729-4e75-4715-a42b-0bc789def958.png)'
  prefs: []
  type: TYPE_IMG
- en: With the in-editor approach to using Flow, you don't even have to save, let
    alone switch windows to have your code type-checked—all you have to do is write
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about why type-checking your React code matters.
    You also learned about Flow—the tool used to type-check React code. Type-checking
    is important for React applications because it removes the need to perform runtime
    checks of values in the majority of cases. This is because Flow is able to statically
    follow code paths and determine whether everything is being used as intended.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you installed Flow locally to a React application and learned how to run
    it. Next, you learned the basics of validating property and state values of React
    components. Then you learned how to validate function types and how to enforce
    child React component types.
  prefs: []
  type: TYPE_NORMAL
- en: Flow can be used in `create-react-app` dev server, but you have to eject first.
    In future versions of `create-react-app`, there will likely be better integrated
    support for running Flow as part of the dev server. Another option is to install
    a Flow plugin in a code editor such as Atom, and have errors displayed right in
    front of your eyes as you write your code.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, you'll learn how to enforce a high quality level with
    your React code with the help of tools.
  prefs: []
  type: TYPE_NORMAL
