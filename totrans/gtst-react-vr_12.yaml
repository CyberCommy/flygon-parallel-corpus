- en: Publishing Your App, and Where to Go from Here
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is fun to develop and experience virtual worlds at home. Eventually though,
    you want the world to see your world. To do that, we need to package and publish
    our app. In the course of development, upgrades to React may come along; before
    publishing, you will need to decide whether you need to "code freeze" and ship
    with a stable version, or upgrade to a new version. This is a design decision.
  prefs: []
  type: TYPE_NORMAL
- en: 'At some point, you will need to upgrade, and you will need to publish. This
    chapter will explain how to do both as well as how to organize your code and check
    your dryer, and your code, for lint. We will cover these topics here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Types of upgrades: Rip and Replace or "Facelift" upgrade, or "Upgrade in place"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to ensure that proper versions of your components are present
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development versus non-development versions, components, and libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distribution licenses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linking and embedding VR content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing to common web hosts and Content Delivery Networks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where VR is going in the next 5 years
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upgrading React VR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the neat things, although it can be frustrating, is that web projects
    are frequently updated. During the writing of this book, React VR was updated.
    There are a couple of different ways to do an upgrade:'
  prefs: []
  type: TYPE_NORMAL
- en: You can install/create a new app with the same name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will then go to your old app and copy everything over
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a **facelift** upgrade or *Rip and Replace*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do an update. Mostly, this is an update to `package.json`, and then delete `node_modules`
    and rebuild it. This is an **upgrade in place**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is up to you which method you use, but the major difference is that an upgrade
    in place is somewhat easier—no source code to modify and copy—but it may or may
    not work. A Facelift upgrade also relies on you using the correct `react-vr-cli`.
    There is a notice that runs whenever you run React VR from the Command Prompt
    that will tell you whether it''s old:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b5176f24-10f5-41f5-8449-3d2cec0094bf.png)The error or warning that
    comes up about an upgrade when you run React VR from a Command Prompt may fly
    by quickly. It takes a while to run, so you may go away for a cup of coffee.'
  prefs: []
  type: TYPE_NORMAL
- en: Pay attention to red lines, seriously.
  prefs: []
  type: TYPE_NORMAL
- en: To do an upgrade in place, you will typically get an update notification from
    Git if you have subscribed to the project. If you haven't, you should go to: [http://bit.ly/ReactVR](http://bit.ly/ReactVR),
    create an account (if you don't have one already), and click on the eyeball icon
    to join the watch list. Then, you will get an email every time there is an upgrade.
    We will cover the most straightforward way to do an upgrade—upgrade in place,
    first.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading in place
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How do you know what version of React you have installed? From a Node.js prompt,
    type this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, check the version of `react-vr-web`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Check the version of `react-vr-cli` (the command-line interface, really only
    for creating the *hello world* app).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the version of `ovrui` (open VR''s user interface):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You can check these against the versions on the documentation. If you've subscribed
    to React VR on GitHub (and you should!), then you will get an email telling you
    that there is an upgrade. Note that the CLI will also tell you if it is out of
    date, although this only applies when you are creating a new application (folder/website).
  prefs: []
  type: TYPE_NORMAL
- en: 'The release notes are at: [http://bit.ly/VRReleases](http://bit.ly/VRReleases) .
    There, you will find instructions to upgrade. The upgrade instructions usually
    have you do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Delete your `node_modules` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open your `package.json` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update `react-vr`, `react-vr-web`, and `ovrui` to "New version number" for example,
    2.0.0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update `react` to "a.b.c".
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update `react-native to` "~d.e.f".
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update `three` to "^g.h.k".
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `npm` install or yarn.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note the ~ and ^ symbols; ~version means *approximately equivalent to version* and ^version
    means *compatible with version*. This is a help, as you may have other packages
    that may want other versions of `react-native` and `three`, specifically. To get
    the values of {a...k}, refer to the release notes.
  prefs: []
  type: TYPE_NORMAL
- en: 'I have also found that you may need to include these modules in the `devDependencies` section
    of `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You may see this error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you do, make the following changes in your projects root folder in the
  prefs: []
  type: TYPE_NORMAL
- en: '`rncli.config.js` file.'
  prefs: []
  type: TYPE_NORMAL
- en: Replace the `var blacklist = require('./node_modules/react-native/packager/blacklist');` line with `var
    blacklist = require('./node_modules/metro-bundler/src/blacklist');`.
  prefs: []
  type: TYPE_NORMAL
- en: Third-party dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have been experimenting and adding modules with `npm install <something>`,
    you may find, after an upgrade, that things do not work. The `package.json` file
    also needs to know about all the additional packages you installed during experimentation.
    This is the project way (npm way) to ensure that Node.js knows we need a particular
    piece of software. If you have this issue, you''ll need to either repeat the `install`
    with the—`save` parameter, or edit the `dependencies` section in your `package.json`
    file. For example (bold line mine), when we were experimenting with random numbers
    in the last chapter, we could add this line manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Again, this is the manual way; a better way is to use `npm install <package>
    -save`.
  prefs: []
  type: TYPE_NORMAL
- en: The `-s` qualifier saves the new package you've installed in `package.json`.
    The manual edits can be handy to ensure that you've got the right versions if
    you get a version mismatch.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you mess around with installing and removing enough packages, you will eventually
    mess up your modules. If you get errors even after removing `node_modules`, issue
    these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm cache clean --force`'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm start -- --reset-cache`'
  prefs: []
  type: TYPE_NORMAL
- en: The cache clean won't do it by itself; you need the `reset-cache`, otherwise,
    the problem packages will still be saved, even if they don't physically exist!
  prefs: []
  type: TYPE_NORMAL
- en: Really broken upgrades – rip and replace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If, however, after all that work, your upgrade *still* does not work, all is
    not lost. We can do a *rip and replace* upgrade. Note that this is sort of a "last
    resort", but it does work fairly well. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure that your `react-vr-cli` package is up to date, globally:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is important, as when there is a new version of React, you may not have
    the most up-to-date `react-vr-cli`. It will tell you when you use it that there
    is a newer version out, but that line frequently scrolls by; if you get bored
    and don't note, you can spend a lot of time trying to install an updated version,
    to no avail.
  prefs: []
  type: TYPE_NORMAL
- en: An npm generates a lot of verbiage, but it is important to read what it says,
    especially red formatted lines.
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that all CLI (DOS) windows, editing sessions, Node.js running CLIs, and
    so on, are closed. (You shouldn't need to reboot, however; just close everything
    using the old directory).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the *old* code to `MyAppName140` (add a version number to the end of
    the old `react-vr` directory).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the application, using `react-vr init MyAppName`, in other words, the
    original app name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step is easiest using a diff program (refer to [http://bit.ly/WinDiff](http://bit.ly/WinDiff)).
    I use Beyond Compare, but there are other ones too. Choose one and install it,
    if needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compare the two directories, `.\MyAppName` (new) and `.\MyAppName140`, and see
    what files have changed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move over any new files from your old app, including assets (you can probably
    copy over the entire static_assets folder).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Merge any files that have changed, except `package.json`. Generally, you will
    need to merge these files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`index.vr.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`client.js` (if you changed it)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `package.json`, see what lines have been added, and install those packages
    in the new app via npm `install <missed package> --save`, or start the app and
    see what is missing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove any files seeded by the *hello world* app, such as `chess-world.jpg`
    (unless you are using that background, of course).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Usually, you don't change the `rn-cli.config.js` file (unless you modified the
    seeded version).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Most code will move directly over. Ensure that you change the application name
    if you changed the directory name, but with the preceding directions, you won't
    have to.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding list of upgrade steps may be slightly easier if there are massive
    changes to React VR; it will require some picking through source files. The source
    is pretty straightforward, so this should be easy in practice.
  prefs: []
  type: TYPE_NORMAL
- en: I found that these techniques will work best if the automatic upgrade did not
    work.
  prefs: []
  type: TYPE_NORMAL
- en: The best time to do an upgrade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, the time to do a major upgrade probably is not right before
    publishing the app, unless there is some new feature you need. You want to adequately
    test your app to ensure that there aren't any bugs.
  prefs: []
  type: TYPE_NORMAL
- en: I'm including the upgrade steps here, though, but not because you should do
    it right before publishing.
  prefs: []
  type: TYPE_NORMAL
- en: Getting your code ready to publish
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Honestly, you should never put off organizing your clothes until, oh, wait,
    we're talking about code. You should never put off organizing your code until
    the night you want to ship it. Even the code you think is throw away may end up
    in production. Learn good coding habits and style from the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: Good code organization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Good code, from the very start, is very important for many reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: If your code uses sloppy indentation, it's more difficult to read. Many code
    editors, such as Visual Studio Code, Atom, and Webstorm, will format code for
    you, but don't rely on these tools.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Poor naming conventions can hide problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An improper case on variables can hide problems, such as using `this.State`
    instead of `this.state`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the time spent coding, as much as 80%, is in maintenance. If you can't
    read the code, you can't maintain it. When you're a starting out programmer, you
    frequently think you'll always be able to read your own code, but when you pick
    up a piece years later and say *"Who wrote this junk?"* and then realize it was
    *you*, you will quit doing things like a, b, c, d variable names and the like.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most software at some point is maintained, read, copied, or used by someone
    other than the author.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most programmers think code standards are for "the other guy," yet complain
    when they have to code well. Who then does?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most programmers will immediately ask for the code documentation and roll their
    eyes when they don't find it. I usually ask to see the documentation they wrote
    for their last project. Every programmer I've hired usually gives me a deer in
    the headlights look. This is why I usually require good comments in the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A good comment is not something like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'A good comment is this:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Cleaning the lint trap (checking code standards)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you wash clothes, the lint builds up and will eventually clog your washing
    machine or dryer, or cause a fire. In the PC world, old code, poorly typed names,
    and all can also build up.
  prefs: []
  type: TYPE_NORMAL
- en: '**Refactoring** is one way to clean up the code. I *highly* recommend that
    you use some form of version control, such as Git or bitbucket to check your code;
    while refactoring, it''s quite possible to totally mess up your code and if you
    don''t use version control, you may lose a lot of work.'
  prefs: []
  type: TYPE_NORMAL
- en: A great way to do a code review of your work, before you publish, is to use
    a **linter**. Linters go through your code and point out problems (crud), improper
    syntax, things that may work differently than you intend, and generally try to
    pick up your room after you, like your mom does. While you might not like it if
    your mom does that, these tools are invaluable. Computers are, after all, very
    picky and why not use the machines against each other?
  prefs: []
  type: TYPE_NORMAL
- en: One of the most common ways to let software check your software for JavaScript
    is a program called **ESLint**. You can read about it at: [http://bit.ly/JSLinter](http://bit.ly/JSLinter).
    To install ESLint, you can do it via npm like most packages—`npm install eslint
    --save-dev`.
  prefs: []
  type: TYPE_NORMAL
- en: The `--save-dev` option puts a requirement in your project while you are developing.
    Once you've published your app, you won't need to pack the ESLint information
    with your project!
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of other things you need to get ESLint to work properly;
    read the configuration pages and go through the tutorials. A lot depends on what
    IDE you use. You can use ESLint with Visual Studio, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Once you've installed ESLint, you need to configure a local configuration file.
    Do this with
  prefs: []
  type: TYPE_NORMAL
- en: '`eslint --init`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `--init` command will display a prompt that will ask you how to configure
    the rules it will follow. It will ask a series of questions, and ask what style
    to use. AirBNB is fairly common, although you can use others; there's no wrong
    choice. If you are working for a company, they may already have standards, so
    check with management. One of the prompts will ask if you need React.
  prefs: []
  type: TYPE_NORMAL
- en: React VR coding style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Coding style** can be nearly religious, but in the JavaScript and React world,
    some standards are very common. AirBNB has one good, fairly well–regarded style
    guide at: [http://bit.ly/JStyle](http://bit.ly/JStyle).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For React VR, some style options to consider are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Use lowercase for the first letter of a variable name. In other words, this.props.currentX,
    not this.props.CurrentX, and don't use underscores (this is called **camelCase**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use **PascalCase** only when naming constructors or classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you're using PascalCase for files, make the filename match the class, so
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: import `MyClass from './MyClass'`.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful about 0 vs {0}. In general, learn JavaScript and React.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always use `const` or let to declare variables to avoid polluting the global
    namespace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid using ++ and --. This one was hard for me, being a C++ programmer. Hopefully,
    by the time you've read this, I've fixed it in the source examples. If not, do
    as I say, not as I do!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn the difference between == and ===, and use them properly, another thing
    that is new for C++ and C# programmers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In general, I highly recommend that you pour over these coding styles and use
    a linter when you write your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/07b6e8fd-0da4-4c28-b92c-dcc10c09dbf3.png)'
  prefs: []
  type: TYPE_IMG
- en: Third-party dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For your published website/application to really work reliably, we also need
    to update `package.json`; this is sort of the "project" way to ensure that Node.js
    knows we need a particular piece of software. We will edit the `"dependencies"`
    section to add the last line,(bold emphasis mine, bold won''t show up in a text
    editor, obviously!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is the manual way; a better way is to use `npm install <package> -s`.
  prefs: []
  type: TYPE_NORMAL
- en: The `-s` qualifier saves the new package you've installed in `package.json`.
    The manual edits can be handy to ensure that you've got the right versions, if
    you get a version mismatch.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you mess around with installing and removing enough packages, you will eventually
    mess up your modules. If you get errors, even after removing `node_modules`, issue
    these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm start -- --reset-cache`'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm cache clean --force`'
  prefs: []
  type: TYPE_NORMAL
- en: The cache clean won't do it by itself; you need the reset–cache, otherwise the
    problem packages will still be saved, even if they don't physically exist!
  prefs: []
  type: TYPE_NORMAL
- en: Bundling for publishing on the web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Assuming that you have your project dependencies set up correctly to get your
    project to run from a web server, typically through an ISP or service provider,
    you need to "bundle" it. React VR has a script that will package up everything
    into just a few files.
  prefs: []
  type: TYPE_NORMAL
- en: Note, of course, that your desktop machine counts as a "web server", although
    I wouldn't recommend that you expose your development machine to the web. The
    better way to have other people experience your new Virtual Reality is to bundle
    it and put it on a commercial web service.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging React VR for release on a website
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The basic process is easy with the React VR provided script:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the VR directory where you normally run `npm start`, and run the `npm
    run bundle` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/c8ecd3f9-66c1-466c-99b2-e5a8e4bface4.png)'
  prefs: []
  type: TYPE_IMG
- en: You will then go to your website the same way you normally upload files, and
    create a directory called `vr`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In your project directory, in our case `f:\ReactVR\WalkInAMaze`, find the following
    files in `.\VR\Build`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`client.bundle.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '`index.bundle.js`'
  prefs: []
  type: TYPE_NORMAL
- en: Copy those to your website.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a directory called `static_assets`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy all of your files (that your app uses) from `AppName\static_assets` to
    the new `static_assets` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ensure that you have MIME mapping set up for all of your content; in particular,
    .obj, .mtl, and .gltf files may need new mappings. Check with your web server
    documentation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For gltf files, use `model/gltf-binary`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any .bin files used by gltf should be `application/octet-stream`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For .obj files, I've used `application/octet-stream`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The official list is at [http://bit.ly/MimeTypes](http://bit.ly/MimeTypes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Very generally, `application/octet-stream` will send the files "exactly" as
    they are on the server, so this is sort of a general purpose "catch all"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the `index.html` from the root of your application to the directory on
    your website where you are publishing the app; in our case, it'll be the `vr` directory,
    so the file is alongside the two .js files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify `index.html` for the following lines (note the change to `./index.vr`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note for a production release, which means if you're pointing to a prebuilt
    bundle on a static web server and not the React Native bundler, the dev and platform
    flags actually won't do anything, so there's no difference between `dev=true`,
    `dev=false`, or even `dev=foobar`.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining releases and attribution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you used any assets from anywhere on the web, ensure that you have the proper
    release. For example, many Daz3D or Poser models do not include the rights to
    publish the geometry information; including these on your website as an OBJ or
    glTF file may be a violation of that agreement. Someone could easily download
    the model, or nearly all the geometry fairly easily, and then use it for something
    else.
  prefs: []
  type: TYPE_NORMAL
- en: I am not a lawyer; you should check with wherever you get your models to ensure
    that you have permission, and if necessary, attribute properly.
  prefs: []
  type: TYPE_NORMAL
- en: Attribution licenses are a little difficult with a VR world, unless you embed
    the attribution into a graphic somewhere; as we've seen, adding text can sometimes
    be distracting, and you will always have scale issues. If you embed a VR world
    in a page with `<iframe>`, you can always give proper attribution on the HTML
    side. However, this isn't really VR.
  prefs: []
  type: TYPE_NORMAL
- en: Checking image sizes and using content delivery sites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of the images you use, especially the ones in a `<pano>` statement, can
    be quite large. You may need to optimize these for proper web speed and responsiveness.
  prefs: []
  type: TYPE_NORMAL
- en: This is a fairly general topic, but one thing that can help is a **content delivery
    network **(**CDN**), especially if your world will be a high-volume one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a CDN to your web server is easy. You host your asset files from a separate
    location, and you pass the root directory as the assetRoot at the `ReactVR.init()`
    call. For example, if your files were hosted at `https://cdn.example.com/vr_assets/`,
    you would change the method call in `index.html` to include the following third
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Optimizing your models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 10](59d8d97d-7730-4dd6-b8cc-af059352b533.xhtml), *Bringing in the
    Real Live World*, we built a maze that had the same *bush* model repeated for
    every square of the maze. If you were watching the web console, you may have noted
    this model being loaded over and over. It is not necessarily the most efficient
    way. Consider other techniques such as passing a model for the various child components
    as a prop.
  prefs: []
  type: TYPE_NORMAL
- en: '**Polygon decimation** is another technique that is very valuable in optimizing
    models for the web and VR. With the glTF file format, you can use "normal maps"
    and still make a low polygon model look like a high-resolution one. Techniques
    to do this are well documented in the game development field. These techniques
    really do work well.'
  prefs: []
  type: TYPE_NORMAL
- en: You should also optimize models to not display unseen geometry. If you are showing
    a car model with blacked out windows, for example, there is no need to have engine
    detail and interior details loaded (unless the windows are transparent). This
    sounds obvious, although I found the lamp that I used to illustrate the lighting
    examples had almost tripled the number of polygons than was needed; the glass
    lamp shade had an inner and outer polygons that were inside the model.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've gotten it published, what's next
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we've gotten our realities built, what do we do? Where do we go?
  prefs: []
  type: TYPE_NORMAL
- en: You wouldn't be reading this book if you didn't have some idea of some kind
    of VR experience to build. I encourage you to play and experiment. You can even
    try things that you've heard are bad (such as moving points of view).
  prefs: []
  type: TYPE_NORMAL
- en: When VR started exploding again, I was briefly somewhat disgruntled; most of
    the things that I'd done in the generation of VR before seemed to have been forgotten;
    people thought "VR UIs are new!". All the while VR academic literature is literally
    decades old, discussing perceptual effectiveness and VR UIs, just for one area
    of VR.
  prefs: []
  type: TYPE_NORMAL
- en: However, this is not a bad thing. If the people flooding into VR can come up
    with some fresh new idea, maybe that will be the "Killer App" that everyone is
    looking for.
  prefs: []
  type: TYPE_NORMAL
- en: Maybe you can be the one to do this! I hope you will.
  prefs: []
  type: TYPE_NORMAL
- en: React VR is a lightweight, VR-enabled rendering system. There are still a lot
    of things that can be added.
  prefs: []
  type: TYPE_NORMAL
- en: Physics – making the world interact with itself
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Real worlds have objects that move and interact with each other. Programming
    such interaction can become tedious; this is where a good physics package can
    excel.
  prefs: []
  type: TYPE_NORMAL
- en: Simply put, if your objects have real-world physics, they will look much more
    *real*.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of the demos I see with physics are *bouncing ball* type demos that show
    objects flying around and smacking things. I think a more subtle approach to physics
    that is nonetheless accurate (physics engine based) will give a sense of verisimilitude
    in VR worlds that should not be overlooked.
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of JavaScript physics engines: **Cannon.JS** and **Oimo.js**.
  prefs: []
  type: TYPE_NORMAL
- en: Cannon.JS is a rigid body physics engine that includes simple collision detection,
    various body shapes, contacts, friction, and constraints. The source code and
    documentation is at: [http://bit.ly/CannonJS](http://bit.ly/CannonJS).
  prefs: []
  type: TYPE_NORMAL
- en: The **collision detection** algorithms are themselves enough reason to use one
    of these packages, even if you don't foresee writing a bowling game or shooting
    spheres at brick walls. Collision detection can be used, for example, to determine
    whether a virtual avatar can navigate to a particular location in the VR world.
  prefs: []
  type: TYPE_NORMAL
- en: A blog post covering React VR and Cannon.js is at: [http://bit.ly/ReactPhysics](http://bit.ly/ReactPhysics).
  prefs: []
  type: TYPE_NORMAL
- en: Oimo.jsis a similar rigid body physics engine; it can be found at: [http://bit.ly/OmioPhysics](http://bit.ly/OmioPhysics).
  prefs: []
  type: TYPE_NORMAL
- en: Note that Oimo.js examples show *native* three.js units, that are smaller than
    React VR (typically 10 to 1,000). In React VR, units are more or less 1 = 1 meter,
    so Oimo.js will integrate fairly smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: Game play engines – letting you interact with others
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few websites that can package the TCP/IP code to enable multiplayer
    games. React VR integrates into these well, as long as they use JavaScript. Once
    such engine is **Lance.gg**, available at: [http://bit.ly/Lance_gg](http://bit.ly/Lance_gg).
  prefs: []
  type: TYPE_NORMAL
- en: 'It is a node-based game server. It was created to enable JavaScript developers
    to build real-time online multiplayer games without worrying about implementing
    net synchronization code. It strives to provide a smooth experience for both developers
    and players, regardless of lag. It has the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Lance takes care of the netcode, so we can focus on the VR parts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can support any type of game or genre
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimized networking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TCP via websockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication is packed and serialized into binary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic handling of network spikes with step correction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intelligent sync strategies for lag handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extrapolation (client-side prediction) with step reenactment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpolation for optimal object motion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools for debugging and tracing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monetizing VR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several ways to make money off of VR. It is a very new art form, and
    a lot of applications are still being discovered. Like any new field, many things
    out there are experiments or funded loss leaders. The major hardware manufacturers
    have even built software ecosystems by funding developers.
  prefs: []
  type: TYPE_NORMAL
- en: It is a "who came first, the hardware or the killer app" situation currently.
    Headset sales are strong, although mobile headsets definitely lead the way, with
    almost ten times as many Samsung GearVR, Google Daydream, and Cardboard headsets
    as the higher-end models such as the Rift and Vive. The PSVR is a good system,
    but it can be difficult for developers who are not part of a game studio to get
    access to.
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget, however, that you don't even need a VR headset to appreciate React
    VR. Most of the code you work on will be viewed in a browser without entering
    full VR mode, and many of your viewers may choose to do the same thing. Embedding
    a VR window on a website will still give a compelling experience to people even
    without VR equipment.
  prefs: []
  type: TYPE_NORMAL
- en: React VR may have an advantage when it comes to monetizing VR, at least from
    advertising.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ways to make money off of VR are as listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sell applications**:To do this on a website, you will probably need to implement
    some type of pay-to-view system. Most people do not like paywalls around websites,
    so this is probably best for full blown VR games, such as something built with
    Unity and Unreal. However, let''s not discount this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Being paid to build a VR experience**: Most web searches for VR Advertising
    will turn up these types of apps. They are almost always free to download, and
    are often pretty compelling. It is not, however, in my mind, a growth model for
    the VR producers; you can be paid fairly well to develop a VR app, but once that
    is done, so is your income stream. I see studio releases of VR sites that play
    content associated with a movie to be essentially the same concept, and an area
    I think React VR will be well suited for.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Embedding VR advertisements in your world**:One advantage of React VR is
    that it has access to all the layout possibilities with React itself, so this
    may be easier and more direct for React VR than any other VR system. One challenge
    is that people immersed in a VR world do not like distractions, so having advertisements
    pop up may have the opposite effect. Still, product placement, or billboards in
    your world can be fairly effective, especially if you are building some kind of
    virtual city.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linking to products or sites from inside your VR world**: This works well
    for regular websites, although the challenge for VR is that you may need to take
    off the VR headset to really interact with what you just clicked on in the VR
    world. Some advertising companies have discussed building in VR advertising worlds
    that you will warp to from within a VR world, although so far most of these have
    been for traditional game engines. Still, we can expect a lot of development in
    this area in the future.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Selling off metadata**: In this model, the app itself will be free, but the
    VR developer will enable gaze tracking.* Hot spots* of areas within the VR world
    can be sold off to advertisers in the same way that clicks or impressions are
    sold with a more flat HTML model. This is another area of emerging standards.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Demo version to full version**: You can build a React VR world with models
    and assets taken from a full blown game engine, then put this on a web page as
    a tie–in or free giveaway to get people interested in your full VR app. Having
    industry standard formats, such as OBJ and glTF, will help do this, although a
    lot of the logic will have to be developed from scratch. A possibly better way
    is to have a free web URL and a for-pay URL behind a paywall.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**In-app purchases**: This will be a way for things in the game to trigger
    purchases outside of it. For example, a video player can request a particular
    video be paid for, then the React VR code will play that video. In-app purchases
    will be fairly straightforward with React VR due to the straightforward way to
    integrate JavaScript.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where VR will go in the next five years
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If I knew exactly where VR would go in the next five years, I would be rich
    in five years, and so would you, if you invest in my predictions. Let me know
    how that works out.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you invest in VR by developing amazing worlds, even if it isn't with
    React VR. I really believe in VR, and want to see it succeed this time.
  prefs: []
  type: TYPE_NORMAL
- en: That brings up what I mean by *this time*. I've been through at least one wave
    of VR; back then, everyone thought VR was the wave of the future. All the great
    things you are hearing about VR, I've heard before. I was doing VR from about
    1995 to 2000 or so. VR crashed hard. There were HMDs being created, data gloves,
    and entire virtual worlds.
  prefs: []
  type: TYPE_NORMAL
- en: Most people say the graphics back then were too crude. There is some truth to
    that, but people that haven't tried VR still, say *"I will wait until the graphics
    get more real"* not realizing, as we've discussed and seen, it doesn't take great
    graphics for VR to appear *real*.
  prefs: []
  type: TYPE_NORMAL
- en: What we called VR is also a little different. Back then, seemingly ages ago,
    any 3D program on a PC was loosely called VR. I even predicted while the VRML
    language was being invented (it is now X3D), that we needed to get all this right
    or people would walk up to strangers from all over the world, in beautiful 3D
    environments, and (virtually) kill them.
  prefs: []
  type: TYPE_NORMAL
- en: In a way, I was right; in the World of Warcraft, for example, this is exactly
    what happens. Modern VR has everything it does due to computer gaming. All of
    those frag games have created a demand for cheap, high-quality video cards. You
    may think that a high-end video card isn't cheap, but compared to the first VR
    hardware, they are amazingly cheap.
  prefs: []
  type: TYPE_NORMAL
- en: 3D computer games on a screen are not what we call VR today, and that is really
    correct. Computer games, no matter how great they look, are not as immersive as
    an HMD-based VR experience.
  prefs: []
  type: TYPE_NORMAL
- en: I am worried that VR might crash again; yet I don't think it will this time.
    The difference this time is that we all have high-powered VR devices in our pocketsour
    cell phones. Modern cell phones are as capable as the $100,000 Reality Engine
    by Silicon Graphics. We can pop a cell phone in a simple, cheap VR headset and
    see VR. It may not be as interactive as something with tracked controllers, but
    it works. Bluetooth controllers are not going away, and neither are cell phones.
  prefs: []
  type: TYPE_NORMAL
- en: VR is thus here to stay, but where will it go?
  prefs: []
  type: TYPE_NORMAL
- en: Do not wait for next year's technology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A long time ago, when I was buying my first stereo, when I was 20, and flush
    with what I thought was a lot of money from working the summer during my college
    break, I really wanted a stereo. I spent weeks pouring over specifications, listening
    tests, comparing features, and was generally a bit parallelized by options.
  prefs: []
  type: TYPE_NORMAL
- en: I went around to stereo stores with a wad of dough, looking to buy something.
  prefs: []
  type: TYPE_NORMAL
- en: I went to one store, and asked the sales guy what stereo system he had.
  prefs: []
  type: TYPE_NORMAL
- en: '*"Oh, I''ve got next years model,"* he said.'
  prefs: []
  type: TYPE_NORMAL
- en: '*What*? I thought. *Is something really great coming out*?'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Oh, so what are you waiting for?"* I asked. *"What is coming out?"*'
  prefs: []
  type: TYPE_NORMAL
- en: '"*Oh, next year I''ll wait for the next year too,"* he said. *"You see, next
    year is always next year, so I never have a stereo that is obsolete,"* he said.
    He simply didn''t ever buy a stereo.'
  prefs: []
  type: TYPE_NORMAL
- en: I see his point. You might be thinking, *Wait till it gets better.*
  prefs: []
  type: TYPE_NORMAL
- en: My point is that in the last 30 years, I've listened to a *lot* more music than
    that salesman ever did.
  prefs: []
  type: TYPE_NORMAL
- en: You shouldn't wait to buy the next great piece of VR gear, get into it now.
    If something new comes out, you'll have enjoyed VR for much longer than if you
    had waited, and you'll know what you like a lot more. There aren't any bad decisions
    right now.
  prefs: []
  type: TYPE_NORMAL
- en: Better HMDs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HMDs we have today, things such as the HTC Vive, the Oculus Rift, the PS
    VR, and mobile-based VR devices such as the Samsung Gear VR, the Google Daydream,
    and Google Cardboard, are pretty good, but they can be a lot better.
  prefs: []
  type: TYPE_NORMAL
- en: The human eye can't really be compared to a pixel display, although we know
    for sure that we see more detail than any current HMDs can show. We also have
    a wider field of view.
  prefs: []
  type: TYPE_NORMAL
- en: Current displays are roughly similar in view; 1,080 x 1,200 pixels with about
    110 degrees field of view. That gives us roughly 10 to 15 pixels per degree. The
    human eye can see anywhere from 500 to about 1,000 pixels per inch at ten inches;
    this gives us about 90 to 177 pixels per degree. This will mean a nearly 20,000
    or 40,000 pixel display. We're not talking about megapixels, but about gigapixels.
  prefs: []
  type: TYPE_NORMAL
- en: Can we get there in 5 years? That's a pretty high resolution, but I think we
    will get resolutions at least 4 or 16 times better than now.
  prefs: []
  type: TYPE_NORMAL
- en: HMDs will probably be more comfortable. I'm not sure they will get significantly
    smaller due to optical issues, although in 10 to 15 years, I expect that they
    will be the size of contacts or glasses. This is a very rough guess.
  prefs: []
  type: TYPE_NORMAL
- en: Better and more realistic graphics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graphics cards get faster as well as cheaper all the time. In five years, we
    will need every ounce of that processing power to generate a display with the
    same visual complexity as we have now—not any better looking—due to the increase
    in pixels. In other words, as displays go up in pixels, making for better and
    wider displays, the amount of processing power to drive those goes up too, so
    there isn't as much of an increase in visual fidelity as you would expect. Is
    there a light at the end of that tunnel? Or is the light at the end of the tunnel
    a train going the other way? There is good news, and it is called Foveated rendering.
    For that, we need eye tracking, which we'll discuss in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of eye tracking and foveated rendering, we'll see more realistic
    rendering and more realistic looking humans. Will it be dramatically better? Will
    it look real? If you remember from the beginning of our book, graphics don't need
    to look like real life to seem real, so although I'm looking forward to better
    graphics, I don't think VR is reliant on them.
  prefs: []
  type: TYPE_NORMAL
- en: Easier content creation and more high-end content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have just discussed technical changes in VR. There are a lot more
    things that I think will happen, that will have a much larger effect on VR. Regardless
    of how the images are generated, sound, look, or even feel, we will need the so-called "Killer
    App". Right now, most VR that makes money are games. Once the larger game development
    studios see a future in VR, they will develop more AAA games (triple A games mean
    games with large budgets, often tens or hundreds of millions of dollars and large
    teams, including artists, developers, designers, authors, and project managers).
    Three AAA games are scheduled to come out shortly after this book is published:
    Doom VR, Fallout 4 VR, and Skyrim VR. Once we have large games with tens or hundreds
    of hours of gameplay, if it is compelling (and I believe it will be very compelling),
    we will see VR take off.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next five years, I think this will surely progress even further. I expect
    to see large persistent worlds, **Massively Multiplayer On-line Role Play Games** (**MMORPGS**)
    become a staple of VR. Instead of playing a game in the World of Warcraft, you
    will be *in* the World of Warcraft. Wow! (pun intended).
  prefs: []
  type: TYPE_NORMAL
- en: On the content side, we will also see more high-end creation software that is
    also in VR. Currently, the more complex creation tools, such as Max, Maya, and
    Blender, make the best models that you see in VR, but they are themselves conventional
    apps. Today, we see some apps, such as *Tilt-brush*, that let us design objects
    in VR. I expect higher–end CAD will have a ubiquitous VR mode themselves.
  prefs: []
  type: TYPE_NORMAL
- en: HMDs can become hot, heavy, and fatiguing after a while (mainly due to convergence accommodation conflict
    as discussed earlier). I don't see all work being done in VR, but it will help
    at the initial stages as well as in checking models.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is quicker: to look at two objects on the screen and drag them around
    with the mouse, or just grab them with your hands and move them? Imagine sculpting
    with magic putty that you have an ***undo*** command. You can''t do that with
    real clay, but you will be able to in VR.'
  prefs: []
  type: TYPE_NORMAL
- en: Eye tracking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the eye tracking that I alluded to earlier? It is a sensor inside the
    HMD that looks at where your eyeballs are pointed. There are a few advantages
    to this kind of scanning, mainly social and rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Social advantages are immense, in my opinion. When you look at someone's avatar,
    which is an in–game representation of another person, they can look very stiff
    and emotionless. Human beings detect an immense amount of emotion from their eyes;
    with eye tracking, your avatar can show some of these expressions. One simple
    test showed a dramatic improvement by simply putting cartoon eyeballs—just a black
    dot in a white ball—and have those eyes look around as the user was looking. The
    avatars, even though cartoons, looked much more real.
  prefs: []
  type: TYPE_NORMAL
- en: The rendering improvements with eye tracking, as briefly mentioned earlier,
    are a type of rendering called foveated rendering. With the eye tracker, instead
    of filling every pixel with high-detail objects, we can just show what you are
    looking at with high detail. The rest of the eye typically does not see in as
    much detail as right where your eyeball is pointed. Our rods and cones in the
    eye are tightly distributed in the center, and are much less dense at the outer
    edges of our eye. Foveated rendering makes use of that by showing less detail
    away from the center point of your gaze.
  prefs: []
  type: TYPE_NORMAL
- en: This really works and can significantly speed up graphics; you don't need to
    compute what you don't display. This was first demonstrated at the annual **Special
    Interest Group for GRAPHics** (**SIGGRAPH**) conference in 2016.
  prefs: []
  type: TYPE_NORMAL
- en: Audio improvements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most people, when it comes to VR audio, are worried about how well the headsets
    work, or if they block out the sound of your cat screeching when you sit down
    on the couch without taking off your HMD. (Let's hope not!) There is a lot more
    to VR audio though; our ears do an amazing thing with pinpointing where a sound
    is coming from with only two sensors (normally, it takes three sensors to detect
    both distance and direction of any 3D source). How do our ears do that? It's done
    with something called a HRTF. Currently, we do have the technology to calculate
    HRTFs in real time. However, *what* HRTF to calculate is not that easy to determine.
    This is no surprise; people are unique.
  prefs: []
  type: TYPE_NORMAL
- en: Everyone's HRTF is different; if we play back a sound that is generated using
    my HRTF, I will hear a noise with my eyes closed as if it was coming directly
    from the spot the designer intended. If you hear the same noise with the same
    headset, you may think it sounds fake, or is coming from a different direction.
    This is just a reality of how we process sound.
  prefs: []
  type: TYPE_NORMAL
- en: There are some solutions currently—either measuring your HRTF in a chamber specially
    designed to calculate this or possibly using additional speakers in a headset.
    Time will tell which of these techniques will be the best; this is still an open
    area.
  prefs: []
  type: TYPE_NORMAL
- en: Along with the HRTF calculations to localize (pinpoint) the sound, we need more
    and better ways in software to locate that sound.
  prefs: []
  type: TYPE_NORMAL
- en: I would think in five years, whatever physics systems we are using for our virtual
    worlds may be able to generate the proper sound effects, not just play back a
    canned noise. For example, if you hit a concrete wall, maybe the software can
    generate the thud noise, at the right location and the right sound, considering
    how thick the wall is, and other parameters. Currently, we just play canned noises
    at the right location (which is still amazing, but can use some improvement).
    That is something I would like to see.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling VR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today's controllers usually consist of two handheld devices with multiple buttons.
    Most have a simple mechanical way to vibrate via software. There is a huge area
    of innovation possible. The VR industry has been working for decades on sophisticated
    devices that allow better haptics, smaller, and more accurate controllers, and
    data gloves. Why use a controller when you can just reach out and grab things?
  prefs: []
  type: TYPE_NORMAL
- en: '**Haptics** are any interaction involving touch. This doesn''t just mean touching
    or holding your mouse; it can be anything from feeling a click or shake when you
    move your controller (the current state of the art), but it can also mean a device
    that pushes back when you move it. These have been demonstrated for years, and
    there are commercial off-the-shelf products that can do things such as allowing
    you to feel a surface. These will become more common and more of mass-produced,
    consumer-level devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data gloves** are devices that you wear that allow every finger joint and
    movement to be tracked in VR. They have been available for decades. There are
    even systems (the Leap Motion device) that will let you reach out with your real
    hand, and have that interact in the virtual world. I believe that this is an area
    with a lot of potential in the next few years.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Whole body** controllers will allow your entire virtual body to be visually
    present, accurate, and tracked in the VR world. This is another area with a lot
    of potential. There are even a few prototype suits that provide full body haptics.
    Imagine putting on a suit and being able to feel and touch the world, not just
    wave a wand through the images.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Social and legal issues and solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you can put a virtual statue in the middle of a public space, is that vandalism?
    What about painting on the side of a business in AR or VR? At first, you might
    think this is perfectly fine; I myself might like to see a model of some sci-fi
    thing in the middle of the park, that people can interact with. What if that model
    is of a Confederate war hero who was in favor of slavery? What if malcontent neighbors
    virtually tag your house with slanderous allegations?
  prefs: []
  type: TYPE_NORMAL
- en: Within social VR, we can harass people in ways just not possible in real life.
    If someone moves into your space, you can push them back, but in VR, bad behavior
    may be very easy to do. VR environments will need to take these kinds of things
    into consideration.
  prefs: []
  type: TYPE_NORMAL
- en: If we have guards in place to prevent virtual desecration, how do we decide
    what is right and what is wrong, especially in public spaces? VR can be similar
    to the real world—libel is libel, yet VR also offers some unique possibilities.
    If you are a southern gentleman, you may want to see rebel statues, and you can.
    The young person next to you may instead see George Washington Carver. We can
    all just get along; or can we? What if the guy next you wants to display chem
    trail deposition?
  prefs: []
  type: TYPE_NORMAL
- en: I do think persistent virtual worlds will flourish, and we will come up with
    innovative and interesting solutions to the preceding issues. Just remember that
    many people who don't like technology, or who fear it generally don't understand
    it. If we can create any worlds we want, we just have to want to create worthwhile
    worlds.
  prefs: []
  type: TYPE_NORMAL
- en: Please do!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to unleash our realities onto the internet.
    Specifically, we covered how to do version upgrades, and if we need to, how to do
    *rip and replace* upgrades. We discussed when to do an upgrade. We really should
    have discussed coding standards earlier, as it's never too soon to start, but
    first we had to get some React VR syntax down, so we covered this before we set
    our code on the world. We further discussed how to use ESLint and other linters
    to help you code well. Once you have good clean code, we talked about how to package
    your development React VR content for the web as well as how to make it fast through
    optimization and **Content Delivery Networks** (**CDN**s).
  prefs: []
  type: TYPE_NORMAL
- en: We discussed how to further make your websites real (through physics), play
    games as well as how to monetize them.
  prefs: []
  type: TYPE_NORMAL
- en: You now know everything you need to learn to use React VR on the web. I'm looking
    forward to finding out what you create!
  prefs: []
  type: TYPE_NORMAL
