- en: Data-Driven Unit Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we discussed the attributes of good unit tests, as well
    as the two types of test supported by xUnit.net, **Fact** and **Theory**. Also,
    we walked through the creation of unit tests using the rich set of test assertions
    that are available in the xUnit.net unit testing framework.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests written for a software project should be run repeatedly right from
    the development stage, during deployment, during maintenance, and, effectively,
    throughout the life cycle of the project. Often, these tests should be run on
    different data inputs following the same execution steps, while the tests, and
    essentially, the code being tested are expected to have consistent behavior, irrespective
    of the data input.
  prefs: []
  type: TYPE_NORMAL
- en: Running tests on different sets of data can be achieved by creating or replicating
    existing tests with similar steps operating on the different desired data inputs.
    The issue with this approach is maintenance, since changes to the test's logic
    will have to be affected in the various replicated tests. xUnit.net solves this
    challenge through its data-driven unit tests feature, known as **theories**, which
    allows tests to be run on different sets of test data.
  prefs: []
  type: TYPE_NORMAL
- en: Data-driven unit tests, which can also be referred to as data-driven testing
    automation in xUnit.net, are tests decorated with the `Theory` attribute and have
    data passed in as parameters to these tests. Data passed to data-driven unit tests
    can come from a variety of sources, which can be inline through the use of the `InlineData`
    attribute. Data can also come from specific data sources, such as obtaining data
    from a flat file, web service, or from a database.
  prefs: []
  type: TYPE_NORMAL
- en: The sample data-driven unit tests explained in [Chapter 4](e51bcf25-f258-4c2d-9180-9a3291a2a406.xhtml), *.NET
    Core Unit Testing*, use an inline approach. There are other attributes that can
    be used for providing data to the tests—`MemberData` and `ClassData`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will walk through the creation of data-driven unit tests
    using the xUnit.net framework and cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of data-driven unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The xUnit.net `Theory` attribute for creating data-driven tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inline data-driven unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Property data-driven unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating data from other sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The benefits of data-driven unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Data-driven unit testing** is a concept known to provide great insight into
    code behavior, due to it being able to execute tests with different sets of data.
    The insight gained through data-driven unit testing can assist in making informed
    decisions about application development approaches and can identify potential
    areas that need improvement. Strategies can be formulated from reports and code
    coverage available from data unit tests, which can later be used to refactor code
    with potential performance issues and bugs in the application logic.'
  prefs: []
  type: TYPE_NORMAL
- en: Some of the benefits of data-driven unit testing are explained in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Tests brevity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Through data-driven tests, it is easier to reduce redundancy while still maintaining
    comprehensive test coverage. This is because test code duplication can be avoided.
    Tests that would have been traditionally duplicated to test different datasets
    can now be reused for different datasets. When there are tests that have similar
    structures but with dissimilar data, this is an indication that the tests can
    be refactored as data-driven tests.
  prefs: []
  type: TYPE_NORMAL
- en: Let's review the `CarLoanCalculator` class and the corresponding `LoanCalculatorTest`
    test class in the following snippets. This will provide a valuable insight into
    why data-driven testing can simplify testing while providing brevity of code when
    compared with the traditional approach to writing tests.
  prefs: []
  type: TYPE_NORMAL
- en: '`CarLoanCalculator` extends the `LoanCalculator` class to override the `CalculateLoan`
    method to perform calculations related to a car loan and returns a `Loan` object
    that will be validated using xUnit.net assertions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify the consistent behavior of the `CarLoanCalculator` class, the `Loan`
    object returned by the `CalculateLoan` method will be validated using the following
    test scenarios when the method argument `LoanDTO` has different `LoanType`, `LocationType`,
    and `JobType` combinations. The `Test_CalculateLoan_ShouldReturnLoan` test method
    in the `CarLoanCalculatorTest` class validates each of the scenarios described:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `Test_CalculateLoan_ShouldReturnLoan` method in the preceding snippet contains
    lines of code with data to test the `CalculateLoan` method twice. This test clearly
    contains duplicate code with the test tightly coupled to the test data. Also,
    the test code is not clean because when more test scenarios are added, the test
    method will have to be modified by adding more lines of code, thereby making the
    test large and clumsy. With data-driven testing, this scenario can be avoided
    and having repeated code in tests can be eliminated.
  prefs: []
  type: TYPE_NORMAL
- en: Inclusive testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software application quality can be improved when business people and quality
    assurance testers are carried along in the automated testing process. They can
    populate the data source with the data required to execute the tests, with little
    technical knowledge required, especially when using data files as a data source.
    The tests can be run multiple times using different datasets to test the code thoroughly in
    order to ensure robustness.
  prefs: []
  type: TYPE_NORMAL
- en: Using data-driven testing, you have a clear separation of your tests and data.
    Tests that would have otherwise been muddled up with the data will now be separated
    using the appropriate logic. This ensures that the data source can be modified
    without making changes to the tests using them.
  prefs: []
  type: TYPE_NORMAL
- en: The overall quality of the application is improved through data-driven unit
    tests as you can have good coverage with the various datasets and have metrics
    to use to fine-tune and optimize the application being developed for improved
    performance in place.
  prefs: []
  type: TYPE_NORMAL
- en: xUnit.net theory attribute for creating data-driven tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In xUnit.net, data-driven tests are known as theories. They are tests decorated
    with the `Theory` attribute. When a test method is decorated with the `Theory`
    attribute, it must additionally be decorated with a data attribute, which will
    be used by the test runner to determine the source of the data to be used in executing
    the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When a test is marked as data theory, the data fed into it from the data source
    is directly mapped to the parameters of the test method. Unlike the regular test
    decorated with the `Fact` attribute, which is executed only once, the number of
    times a data theory is executed is based on the available data rows fetched from
    the data source.
  prefs: []
  type: TYPE_NORMAL
- en: At least one data attribute is required to be passed as the test method argument
    for xUnit.net to treat the test as data-driven and execute it successfully. The
    data attribute to be passed to the test can be any of `InlineData`, `MemberData`,
    and `ClassData`. These data attributes are derived from `Xunit.sdk.DataAttribute`.
  prefs: []
  type: TYPE_NORMAL
- en: Inline data-driven unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Inline data-driven testing** is the most basic or simplest way of writing
    data-driven tests using the *xUnit.net framework*. Inline data-driven tests are
    written using the `InlineData` attribute, which is used to decorate the test method
    in addition to the `Theory` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Inline data-driven tests can be used when the test method requires parameters
    that are simple and does not accept class instantiation as an `InlineData` parameter.
    The major drawback of using the inline data-driven test is the lack of flexibility.
    Inline data used with a test cannot be reused with another test.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are using the `InlineData` attribute in a data theory, the data rows
    are hard-coded and passed inline into the test method. The desired data to be
    used for the test can be of any data type and is passed as a parameter into the
    `InlineData` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'An inline data-driven test can have more than one `InlineData` attribute with
    the parameters to the test method specified. The syntax of multi `InlineData`
    data theory is specified in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `TestCheckWordLength_ShouldReturnBoolean` method can be changed to have
    three inline data rows, and more data rows can be added to the test as desired.
    To have clean tests, it is recommended to not have more than the necessary or
    required inline data per test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When writing inline data-driven unit tests, you must ensure that the number
    of parameters in the test method match the parameters in the data rows passed
    to the `InlineData` attribute; otherwise, the xUnit test runner will throw a `System.InvalidOperationException`.
    The `InlineData` attribute in the `TestCheckWordLength_ShouldReturnBoolean` method
    in the following snippet has been modified to take two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the data theory test in the preceding snippet, the xUnit test
    runner test fails with `InvalidOperationException`, as shown in the following
    screenshot, because two parameters `"word"` and `"name"` were passed to the `InlineData`
    attribute instead of the expected one parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23ebb8d6-1117-4d33-ab01-019ba6d8ba69.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When you run an inline data-driven test, xUnit.net will create the number of
    tests, based on the number of `InlineData` attributes or data rows added to the
    test method. In the following snippet, xUnit.net will create two tests, one for
    the `InlineData` attribute with the argument `"name"` and the second for the argument
    `"city"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the `TestCheckWordLength_ShouldReturnBoolean` test method in Visual
    Studio using the test runner, the test should successfully run and pass. The two
    tests created based on the attributes can be differentiated by the parameters
    passed into them from the `InlineData` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/134d525d-7134-4729-85a3-735ad3552326.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s modify the `Test_CalculateLoan_ShouldReturnCorrectRate` test method
    in the section, *The benefits of data-driven unit testing*, to use `InlineData`
    to load the test data instead of hard-coding the test data directly in the code
    of the test method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In Visual Studio, the preceding code snippet will give a syntax error, with
    the IntelliSense context menu showing the error—An attribute argument must be
    a constant expression, type of expression or array creation expression of an attribute
    parameter type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cbdb20bd-06a9-498b-be91-9f33f13b6bbc.png)'
  prefs: []
  type: TYPE_IMG
- en: Using properties or custom types as parameter types in the `InlineData` attribute
    is not allowed, which indicates that the new instance of the `LoanDTO` class cannot
    be used as an argument to the `InlineData` attribute. This is the limitation of
    the `InlineData` attribute as it cannot be used to load data from properties,
    classes, methods, or custom types.
  prefs: []
  type: TYPE_NORMAL
- en: Property data-driven unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The lack of flexibility encountered when writing inline data-driven tests can
    be overcome through the use of property data-driven tests. Property data-driven
    unit tests are written in xUnit.net through the use of the `MemberData` and `ClassData`
    attributes. Using the two attributes, data theories can be created with data loaded
    from disparate data sources, such as files or databases.
  prefs: []
  type: TYPE_NORMAL
- en: MemberData attribute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `MemberData` attribute is used when data theories are to be created and
    loaded with data rows coming from following data sources:'
  prefs: []
  type: TYPE_NORMAL
- en: Static property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using `MemberData`, the data source must return independent object sets
    that are compatible with `IEnumerable<object[]>`. This is because the `return`
    property is enumerated by the `.ToList()` method before the test method is executed.
  prefs: []
  type: TYPE_NORMAL
- en: '`The Test_CalculateLoan_ShouldReturnCorrectRate` test method in the,*The benefits
    of data-driven unit testing* section, can be refactored to use the `MemberData`
    attribute to load the data for the test. A static `IEnumerable` method, `GetLoanDTOs`,
    is created to return a `LoanDTO` object using the `yield` statement to return
    the object to the test method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`The MemberData` attribute requires that the name of the data source is passed
    to it as a parameter for subsequent invocation to load the data rows for the test
    execution. The name of the static method, property, or field can be passed as
    a string into the `MemberData` attribute in this form—`MemberData("methodName")`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, the data source name can be passed to the `MemeberData` attribute
    through the use of the `nameof` expression, which is a C# keyword that is used
    to get the string name of a variable, type, or member. The syntax is `MemberData(nameof(methodName))`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Similar to using static method with the `MemberData` attribute, static fields
    and properties can be used to provide datasets to data theories.
  prefs: []
  type: TYPE_NORMAL
- en: '`Test_CalculateLoan_ShouldReturnCorrectRate` can be refactored to use a static
    property in place of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'A static property, `LoanDTOs`, is created to return `IEnumerable<object[]>`,
    which is required to make it qualify for use as a parameter to the `MemberData`
    attribute. `LoanDTOs` is subsequently used as a parameter to the attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Whenever `Test_CalculateLoan_ShouldReturnCorrectRate` is run, two tests are
    created that correspond to the two datasets returned by either the static method
    or property used as the data source.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the preceding approach requires that the static method, field, or
    property used to load the tests data is located in the same class as the data
    theory. In order to have tests well-organized, it is sometimes required that the
    tests method is separated in different classes from the static methods or properties
    used for loading the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When the test method is written in a separate class different from the static
    method, you have to specify the class containing the method in the `MemberData`
    attribute, using `MemberType`, and assign the containing class, using the class
    name, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When using the static method, the method can also have a parameter, which you
    might want to use when processing the data. For example, you can pass an integer
    value to the method to specify the number of records to return. This parameter
    can be passed directly from the `MemberData` attribute to the static method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GetLoanDTOs` method in `DataClass` can be refactored to take an integer
    parameter to be used to limit the number of records to be returned for populating
    the data rows required for the execution of `Test_CalculateLoan_ShouldReturnCorrectRate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: ClassData attribute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ClassData` is another attribute that can be used to create data-driven tests
    by using data coming from a class. The `ClassData` attribute takes a class that
    can be instantiated to fetched data that will be used to execute the data theories.
    The class with the data must implement `IEnumerable<object[]>` with each data
    item returned as an `object` array. The `GetEnumerator` method must also be implemented.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `LoanDTOData` class to be used to provide data to test the
    `Test_CalculateLoan_ShouldReturnCorrectRate` method. `LoanDTOData` will return
    `IEnumerable` objects of `LoanDTO`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'After the `LoanDTOData` class has been implemented, `Test_CalculateLoan_ShouldReturnCorrectRate`
    can be decorated with the `ClassData` attribute with `LoanDTOData` passed as the
    attribute parameter to specify that `LoanDTOData` will be instantiated to return
    data required for the execution of the test method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the enumerator can be flexibly done using any suitable approach,
    either by using a class property or a method. Before the test is run, the xUnit.net
    framework will call `.ToList()` on the class. While using the `ClassData` attribute
    for passing data to your tests, you always have to create a dedicated class to
    contain your data.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating data from other sources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While you can write basic data-driven tests with the xUnit.net theory attributes
    discussed earlier, there are times where you want to do more, such as connecting
    to an SQL Server database table to fetch data to be used in executing your tests.
    Earlier versions of xUnit.net had other attributes from `xUnit.net.extensions`
    that allow you to easily get data from different sources to be used in your tests.
    The `xUnit.net.extensions` package is no longer available in **xUnit.net v2**.
  prefs: []
  type: TYPE_NORMAL
- en: However, the classes in `xUnit.net.extensions` are available in sample projects
    at: [https://github.com/xUnit.net/samples.xUnit.net.](https://github.com/xUnit.net/samples.xUnit.net) The
    code from the sample projects can be copied to your project if you wish to use
    this attribute.
  prefs: []
  type: TYPE_NORMAL
- en: SqlServerData attribute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inside the `SqlDataExample` folder of the projects, there are files that can
    be copied to your project to give you the functionality of getting data by connecting
    directly to an SQL Server database or any data source that can be accessed using
    *OLEDB*. The four classes located in the folder are `DataAdapterDataAttribute`,
    `DataAdapterDataAttributeDiscoverer`, `OleDbDataAttribute`, and `SqlServerDataAttribute`.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that since .NET Core does not support OLEDB, the preceding
    extension cannot be used in a .NET Core project. This is because OLEDB technology
    was based on COM, which is dependent on components that are available only on
    Windows. But you can use this extension in a regular .NET project.
  prefs: []
  type: TYPE_NORMAL
- en: The code listing provided in the xUnit.net repository on GitHub has the `SqlServerData`
    attribute that can be used to decorate data theories to fetch data for test execution
    directly from Microsoft SQL Server database tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the `SqlServerData` attribute, you should create a database in your
    instance of SQL Server and name it `TheoryDb`. Create a table with the name `Palindrome`;
    it should have a column named `varchar`. Populate the table with sample data to
    be used for the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PalindronmeChecker` class runs with an `IsWordPalindrome` method to verify
    a word is a palindrome, as shown in the following snippet. A palindrome is a word
    that can be read in both directions—for example, `dad` or `civic`. A quick way
    to check this without an algorithm implementation is to reverse the word and use
    the string `SequenceEqual` method to check if the two words are equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To test the `IsWordPalindrome` method, a test method, `Test_IsWordPalindrome_ShouldReturnTrue`,
    will be implemented which will be decorated with the `SqlServerData` attribute.
    This attribute requires three parameters—the database server address, the database
    name, and the select statement for retrieving the data from the table or view
    containing the data to be loaded for the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When `Test_IsWordPalindrome_ShouldReturnTrue` is run, the `SqlServerData` attribute
    is executed to fetch the records from the database table to be used for executing
    the test method. The number of tests to be created depends on the available records
    in the table. In this case, three tests will be created and executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f7472981-0328-44c8-8843-367ee078defd.png)'
  prefs: []
  type: TYPE_IMG
- en: Custom attribute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to the `SqlServerData` attribute available in the xUnit.net GitHub repository,
    you can create a custom attribute to load data from any source. A custom attribute
    class must implement `DataAttribute`, which is an abstract class that represents
    a data source to be used by a theory. The custom attribute class must override
    and implement the `GetData` method. This method returns `IEnumerable<object[]>`,
    which is used to wrap the content of the dataset to be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a `CsvData` custom attribute that can be used to load data from
    a `.csv` file for use in data-driven unit tests. The class will have a constructor
    that takes two parameters. The first is a string argument containing the full
    path to the `.csv` file. The second argument is a Boolean value, which when `true`,
    specifies if the first row of data contained in the `.csv` file should be used
    as the column header and when `false`, specifies ignoring column headers in the
    file, meaning the CSV data starts from the first row.
  prefs: []
  type: TYPE_NORMAL
- en: 'The custom attribute class is `CsvDataAttribute`, which implements the `DataAttribute`
    class. The class is decorated with the `AttributeUsage` attribute, which has the
    following parameters—`AttributeTargets` to specify the valid application elements
    to apply the attribute, `AllowMultiple` to specify if the multiple instances of
    the attribute can be specified on a single application element, and `Inherited`
    to specify if the attribute can be inherited by derived classes or overriding
    members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to implement the `GetData` method, which will override the
    implementation available in the `DataAttribute` class. This method uses the `StreamReader`
    class in the `System.IO` namespace to read the contents of the `.csv` file a line
    at a time. A second utility method, `ConverCsv`, is implemented to convert the
    CSV data to an integer for integer values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The created custom attribute can now be used with the xUnit.net `Theory` attribute
    to provide data to theories from `.csv` files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Test_IsWordPalindrome_ShouldReturnTrue` test method will be modified to
    use the newly created `CsvData` attribute to get the data for the test execution
    from a `.csv` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the `Test_IsWordPalindrome_ShouldReturnTrue` test method in the
    preceding snippet in Visual Studio, there will be three tests created by the test
    runner. This should correspond to the number of records or data lines retrieved
    from the `.csv` file. The test information can be viewed from the Test Explorer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7bae2c94-06b8-4b72-9505-3493b7cfb2c8.png)'
  prefs: []
  type: TYPE_IMG
- en: The `CsvData` custom attribute can retrieve data from any `.csv` file, irrespective
    of the numbers of columns present on a single line. The records will be fetched
    and passed to the `Theory` attribute in the test method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a method with two integer parameters, `firstNumber` and `secondNumber`.
    The method will calculate the greatest common divisor of integer values, `firstNumber`
    and `secondNumber`. The greatest common divisor of the two integers is the largest
    value that divides the two integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s write a test method to verify the `GetGcd` method. `Test_GetGcd_ShouldRetunTrue`
    will be a data theory and have three integer parameters—`firstNumber`, `secondNumber`,
    and `gcdValue`. The method will check if `gdcValue` supplied in the parameter
    matches what the `GetGcd` method returns when called. The data for the tests will
    be loaded from a `.csv` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on the value provided in the `.csv` file, the tests will be created.
    The following screenshot shows the outcome of `Test_GetGcdShouldReturnTrue` when
    run. Three tests were created; one passed and two failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53b2079c-961e-4f2b-983f-04c88278c973.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data-driven unit testing is an important concept of TDD that brings many benefits,
    by allowing you to test your code base extensively with real-life data from multiple
    data sources, giving you the insight needed to tweak and refactor code for better
    performance and robustness.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we covered the benefits of data-driven testing and how to write
    effective data-driven tests using the inline and properties attributes of xUnit.net.
    Furthermore, we explored data-driven unit testing using the `Theory` attribute
    available in xUnit.net. This allows you to unit test your code for appropriate
    validation and verification over a wide range of inputs coming from different
    data sources.
  prefs: []
  type: TYPE_NORMAL
- en: While the default data source attributes provided by xUnit.net are very useful,
    you can further extend the `DataAttribute` class and create a custom attribute
    to load data from another source. We walked through the implementation of the `CsvData`
    custom attribute to load test data from a `.csv` file.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will delve into another important and useful TDD concept,
    dependencies mocking. Mocking allows you to effectively unit test your methods
    and classes in isolation without having to construct or execute the code of the
    dependencies directly.
  prefs: []
  type: TYPE_NORMAL
