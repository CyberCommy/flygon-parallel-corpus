- en: '*Chapter 1*: An Overview of Modern JavaScript'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will talk about some core JavaScript concepts. If you are
    new to JavaScript and need an introduction, check out [*Chapter 13*](B17076_13_ePub_RK.xhtml#_idTextAnchor222),
    *Appendix*: *Essential JavaScript Concepts*.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding some of the modern concepts of JavaScript is not a prerequisite
    to using Danfo.js, but we recommend going through this chapter if you're new to
    JavaScript or coming from a Python background, the reason being that we'll be
    using most of the concepts introduced here when building applications with Danfo.js.
    Also, it is worth mentioning that many of the concepts introduced here will, in
    general, help you to write better JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter introduces you to some modern JavaScript concepts, and by the
    end, you will have learned and understand the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the difference between let and var
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destructuring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spread syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of scopes and closures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Array and Object methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the this property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrow functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promises and async/await
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object-oriented programming and JavaScript classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a modern JavaScript environment with transpilers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing with Mocha and Chai
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The major requirement is to have Node.js and NPM installed. You can follow
    the official installation guide available at [https://nodejs.org/en/download/](https://nodejs.org/en/download/)
    to install Node for your operating system. The code for this chapter can be found
    in the GitHub repo here: [https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter01](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter01).'
  prefs: []
  type: TYPE_NORMAL
- en: We will start this section by understanding the difference between `let` and
    `var`, and why you should use `let` more often.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the difference between let and var
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before ECMA 6, the common way of creating a variable was with the use of `var`.
    However, using `var` sometimes introduces bugs that mostly show up at runtime
    and others that are not revealed at runtime but may affect the way your code works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the properties of `var` that introduce bugs as mentioned in the previous
    paragraph are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`var` allows the redeclaration of variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`var` is not blocked scope; hence, it is either attached to the global scope
    or to a function scope.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's discuss the two properties listed above in detail.
  prefs: []
  type: TYPE_NORMAL
- en: var allows the redeclaration of variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`var` gives users access to redeclare variables along the line, hence overriding
    the previous variable of the same name. This feature might not show an error if
    not caught, but will certainly affect the behavior of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, there won't be any error, but the main objective
    of the code is altered just because `var` did not alert us that such a variable
    has been declared already.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we replace `var` with `let`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can see from the preceding error output that `let`, unlike `var`, will not
    allow you to declare a variable in the same namespace twice.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's look at the scope property of variables declared with `var`.
  prefs: []
  type: TYPE_NORMAL
- en: var is not a blocked scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Variables declared with `var` have the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: They are readily available in the scope to which they are defined.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are available to scope within the range they are being declared.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following code, we will check how the `estimate` variable declared with
    `var` is accessible across all the scope within the variable declaration scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, for a blocked scope such as `if`, `while` loop, and `for` loop, the code
    within the blocked scope is meant to be run when the scope is available. Likewise,
    the variable is meant to exist only when the scope is available, and once the
    scope is not available again, the variable should not be accessible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Declaring variables with `var` makes the preceding statement not possible.
    In the following code, we declare a variable using `var` and investigate its availability
    across all possible scopes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output the estimate as `6000`. The variable is not meant to exist
    outside the `if` block. Using `let` helps to solve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This shows that using `let` to declare variables helps reduce unprecedented
    bugs in your code. In the next section, we'll discuss another important concept
    called destructuring.
  prefs: []
  type: TYPE_NORMAL
- en: Destructuring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`20`, `John`, `Doe`, and `2019` into specified variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Destructuring makes it possible to assign the element of an array to a variable,
    unlike the old conventional method of accessing an array element as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Destructuring also works on objects, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In object destructuring, notice that we use `{}` instead of `[]`, as used for
    arrays. This is because the type on the left-hand side must be the same as the
    type on the right-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If we are to use `[]` while destructuring for an object, we receive an error,
    showing `{}` for array destructuring, you might not obtain any error, but the
    variables will be undefined.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we take a look at spread syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Spread syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Spread syntax** is another form of destructuring for iterable elements such
    as strings and arrays. The spread syntax can be used in many situations involving
    arrays and objects. In this section, we''ll quickly look at some of the use cases
    of spread syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: Spreading or unpacking an iterable into an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An iterable can be expanded/unpacked into an array. In the following example,
    we will show how to use the spread operator to unpack a string variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The code expands the `name` string into `name_array`, hence, `name_array` will
    have the following values: [`''s'', ''t'', ''e'',''p'', ''h'', ''e'',''n''`].'
  prefs: []
  type: TYPE_NORMAL
- en: 'While expanding the string element into the array, we can add other values
    alongside, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that any iterable can be spread into an array. This shows that we
    can also spread one array into another, as demonstrated in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Next, we'll apply the spread operator to objects.
  prefs: []
  type: TYPE_NORMAL
- en: Creating new objects from existing ones
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating new objects from existing ones follows the same pattern as the **Spread**
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a new object having the same property as the former object. While
    expanding the former object into the new one, new properties can be added alongside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Function arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For functions requiring a lot of arguments, the spread syntax can help pass
    in a lot of arguments at once into the function, thereby reducing the stress of
    filling in the function's arguments one after the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we will see how an array of arguments can be passed
    into a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, first, we created a function called `data_func` and defined
    a set of arguments to be passed in. We then created an array containing a list
    of parameters to pass to `data_func`.
  prefs: []
  type: TYPE_NORMAL
- en: By using spread syntax, we were able to pass the data array and assign each
    of the values in the array as an argument value – `data_func(...data)`. This becomes
    handy whenever a function takes many arguments.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at scope and closures, and how to use them
    to understand your JavaScript code better.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of scopes and closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Understanding the difference between let and var* section, we discussed
    scope and talked about how `var` is available in the global scope, as well as
    in the function scope. In this section, we will be moving into scope and closures
    in a little more depth.
  prefs: []
  type: TYPE_NORMAL
- en: Scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand scope, let''s start with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `food` variables and `data` function are both assigned to the global scope;
    hence, they are termed **a global variable** and **global function**. These global
    variables and functions are always accessible to every other scope and program
    in the JavaScript file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **local** scope can further be grouped as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Function scope**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Block scope**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Function scope is only available within a function. That is, all variables
    and functions created within a function scope are not accessible outside the function,
    and only exist when the function scope is available, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The block scope exists in specific contexts only. For instance, it can exist
    within a curly brace, `{ }`, along with the `if` statement, `for` loop, and `while`
    loop. Two more examples are presented in the following code snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding `if` statement, you can see that the block scope only exists
    inside the curly braces, and all variables declared inside the `if` statement
    are local to it. Another example is a `for` loop, as shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The block scope also exists inside the curly braces of a `for...`loop. Here,
    you have access to the `i` counter, and any variables declared inside cannot be
    accessed outside the block.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's understand the concept of closures.
  prefs: []
  type: TYPE_NORMAL
- en: Closure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Closure** makes use of the idea of scope within functions. Remember we agreed
    that the variables declared within a function scope are not accessible outside
    the function scope. Closure gives us the ability to make use of these private
    properties (or variables).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we want to create a program that will always add the values `2`
    and `1` to an `estimate` variable representing a population estimate. One way
    to do this is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: There's nothing wrong with the preceding code, but as the code base becomes
    very big, we might lose track of the `estimate` value, perhaps a function along
    the line to update the value, and we may also want to make the global scope clean
    by making the global `estimate` variable a local variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, we can create a function scope to do this for us and ultimately, clean
    the global scope. Here is an example in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet is similar to the first one we defined, with just
    a tiny difference, that is, the function accepts the `estimate` value and then
    creates the `add_2` and `add_1` functions inside the `calc_estimate` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better way to showcase closure using the preceding code is to have the ability
    to update the estimate value whenever we want and not at the instance where the
    function is called. Let''s see an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, the inner function, `add_2`, will add the value
    `2` to the `estimate` variable, thereby changing the value. `calc_estimate` is
    called and assigned to a variable, `add_2`. With this, whenever we call `add_2`,
    we update the estimated value by `2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We update the `add_2` function inside `calc_estimate` to accept a value that
    can be used to update the `estimate` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now that you've learned about scopes and closures, we will move to arrays, objects,
    and string methods in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs: []
  type: TYPE_NORMAL
- en: To go into closures in greater detail, check out the book *Mastering JavaScript*,
    by *Ved Antani*.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Array and Object methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Arrays** and **Objects** are the two most important data types in JavaScript.
    As such, we have dedicated a section to talking about some of their methods. We
    will start with the Array methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Array methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can't discuss how to build a data-driven product without discussing Array
    methods. Knowing different Array methods gives us the privilege of accessing our
    data and creating tools to manipulate/handle our data.
  prefs: []
  type: TYPE_NORMAL
- en: 'An array can be created in two different forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `[ ]` method is mostly used for initializing arrays, while the `new Array()`
    method is used mostly to create an empty array of an *n* size, as shown in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The empty array created can later be filled with values as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating such an empty array is not limited to using the `new Array()` method.
    It can also be created with the `[ ]` method, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we explicitly set the length after creation, and as such, the
    `new Array()` method is more convenient.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now look at some of the common array methods that will be used in building
    some of our data-driven tools.
  prefs: []
  type: TYPE_NORMAL
- en: Array.splice
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Deleting and updating array values will always be one of the essential things
    in a data-driven product. JavaScript has a `delete` keyword to delete a value
    at a particular index in an array. This method does not actually delete the value,
    but replaces it with an empty or undefined value, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `data` variable, if we try to access the value at index `4`, we will
    see that it returns `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'But whenever we use `splice` to delete a value in an array, the index of the
    array is re-arranged, as demonstrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`Array.splice` takes in the following argument, `start,[deleteCount, value-1,......N-values]`.
    In the preceding code snippet, since we are only deleting, we make use of `start`
    and `deleteCount`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `data.splice(4,1)` command deletes the value starting at index `4`, with
    only one count, hence it deletes the value at index `5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we replace the value `1` in `data.splice(4,1)` with `2`, resulting in `data.splice(4,2)`,
    two values (`5` and `6`) from the `data` array will be deleted, starting from
    index `4`, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`data.splice(4,0,10, 20);` specifies starting at index `4`, and `0` specifies
    that no values should be deleted, while adding the new values (`10` and `20`)
    between `5` and `6`.'
  prefs: []
  type: TYPE_NORMAL
- en: Array.includes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This method is used for checking whether an array contains a particular value.
    We show an example in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Array.slice
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Array.slice` is used to obtain an array element by specifying the range; `Array.slice(start-index,
    end-index)`. Let''s see an example of using this method in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code extracts elements, starting from index `2` (having element
    `3`) to index `5`. Note that the array did not output `[3,4,5]`, but [`3,4]`.
    `Array.splice` always excludes the end index value, and so it uses a close end
    range.
  prefs: []
  type: TYPE_NORMAL
- en: Array.map
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Array.map` method iterates through all the elements of an array, applies
    some operations to each iteration, and then returns the result as an array. The
    following code snippet is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `data2` variable is created by iterating over each data element by using
    a `map` method. In the `map` method, we are adding each element (value) of the
    array to its index.
  prefs: []
  type: TYPE_NORMAL
- en: Array.filter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Array.filter` method is used to filter out some elements in an array.
    Let''s see this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, the array element of data at every even index
    is filtered out using the modulus (%) of `2`.
  prefs: []
  type: TYPE_NORMAL
- en: There are lots of Array methods, but we covered these few methods because they
    are always handy during data handling, and we will not be able to cover all of
    them.
  prefs: []
  type: TYPE_NORMAL
- en: However, if any new method is used in later chapters of this book, we will certainly
    provide an explanation. In the next section, we'll discuss Object methods.
  prefs: []
  type: TYPE_NORMAL
- en: Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Objects** are the most powerful and important data type in JavaScript, and
    in this section, we''ll introduce some important properties and methods of objects
    that make working with them easier.'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing object elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Accessing keys/values in an object is important, so there exists a special
    `for...in` loop for doing that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `for...in` loop returns all the keys in an object, and this can be used
    to access Object values, as demonstrated in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will show how to test the existence of properties.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for the existence of property
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To check whether a property exists, you can use the `"key"` `in` object syntax,
    as demonstrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Deleting properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `delete` keyword used before an object property will remove a specified
    property from an object. Look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the `age` property has been successfully removed from the `user_profile`
    object. Next, let's look at how to copy and clone objects.
  prefs: []
  type: TYPE_NORMAL
- en: Copying and cloning objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Assigning an old object to a new one simply creates a reference to the old
    object. That is, any modification made to the new object also affects the old
    one. For instance, in the following example, we assign the `user_profile` object
    to a new variable, `new_user_profile`, and then proceed to delete the `age` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that deleting the `age` property from the `user_profile` object
    also deletes it from `new_user_profile`. This is because the copy is simply a
    reference to the old object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to copy/clone objects as new and independent ones, you can use the
    `Object.assign` method, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Object.assign` method can also be used to copy properties from more than
    one object at the same time. We present an example in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we were able to copy properties from two objects (`education`
    and `permissions`) into our original object, `user_profile`. In this way, we can
    copy any number of objects into another one by simply listing all the objects
    when you call the `Object.assign` method.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also perform a deep copy with a **spread** operator. This is actually
    quicker and easier to write, as demonstrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`let user_profile = {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`name: ''Mary'',`'
  prefs: []
  type: TYPE_NORMAL
- en: '`sex: ''Female''`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`let education = { graduated: true, degree: ''BSc'' }`'
  prefs: []
  type: TYPE_NORMAL
- en: '`let permissions = { isAdmin: true }`'
  prefs: []
  type: TYPE_NORMAL
- en: '`const allObjects = {...user_profile, ...education, ...permissions}`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will talk about another important concept relating to
    JavaScript objects called the **this** property.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the this property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **this** keyword is an object property. When used within a function, it
    takes the form of the object to which the function is bound at invocation.
  prefs: []
  type: TYPE_NORMAL
- en: In every JavaScript environment, we have a global object. In Node.js, the global
    object is named **global** and, in the browser, the global object is named **window**.
  prefs: []
  type: TYPE_NORMAL
- en: 'By global object, we mean that all the variable declarations and functions
    are represented as a property and method of this global object. For example, in
    a browser script file, we can access the global objects, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code block, the `name` variable and `print` function are declared
    at the global scope, hence they can be accessed as an attribute (`window.name`)
    and method (`window.print()`) of the **window** global object.
  prefs: []
  type: TYPE_NORMAL
- en: The statement made in the previous sentence can be summarized as the global
    name and function are binded (or assigned) by default to the global object window.
  prefs: []
  type: TYPE_NORMAL
- en: This also means that we can always bind this variable to any object having the
    same `name` variable and the same function, called `print`.
  prefs: []
  type: TYPE_NORMAL
- en: To get this concept, first, let's re-write `window.print()` as `print.call(window)`.
    This new method is called de-sugaring in JavaScript; it is like seeing an implementation
    of a method in its real form.
  prefs: []
  type: TYPE_NORMAL
- en: The `.call` method simply takes in the object we want to bind a function call
    to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how `print.call()` and how this property works. We''ll rewrite the
    `print` function to access the `name` variable, as shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a custom object and also give it the same property as the
    `window` object, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This concept can be applied to all Object methods, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we can also bind the `print()` method from `data` to another object,
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This method shows how this property depends on the function invocation runtime.
    This concept also affects how some event operations work in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs: []
  type: TYPE_NORMAL
- en: To get a deeper understanding of this concept, Yehuda Katz, one of the creators
    of *Emberjs and Members of TC39*, sheds more light on this in his article, *Understanding
    JavaScript Function Invocation and "this"*.
  prefs: []
  type: TYPE_NORMAL
- en: Arrow functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Arrow functions are just unnamed or anonymous functions. The general syntax
    of **arrow** functions is shown in the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Arrow functions provide a means of creating concise callable functions. By this,
    we mean arrow functions are not constructible, that is, they can't be instantiated
    with the new keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are different ways of how and when to use arrow functions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The arrow function can be assigned to a variable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Arrow functions can be used as an **IIFE** (**Immediately Invoked Function
    Expression**). IIFEs are functions that once encountered by the JavaScript compiler
    are called immediately:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Arrow functions can be used as callbacks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: While arrow functions are great in some situations, there is a downside to using
    them. For example, arrow functions do not have their own `this` scope, hence its
    scope is always bound to the general scope, thereby changing our whole idea of
    function invocation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the *Understanding the this property* section, we talked about how functions
    are bounded to their invocation scope and using this ability to support **closure**,
    but using the arrow function denies us this feature by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though in the object, as shown in the code snippet, we make use of the
    anonymous function (but not the arrow function), we have access to the object''s
    `Obj` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The arrow function used makes the `Obj.func` output `undefined`. Let''s see
    how it works if we have a variable called `name` in the global scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, `Obj.func` makes a call to the variable in the global scope.
    Hence, we must know when and where to use the arrow functions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will talk about Promises and async/await concepts. This
    will give us the power to easily manage long-running tasks and avoid callback
    hell (callbacks having callbacks).
  prefs: []
  type: TYPE_NORMAL
- en: Promises and async/await
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's dive a bit into the world of Asynchronous functions, functions that we
    call now but finish later. In this section, we will see why we need **Promise**
    and **async/await**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with a simple problem as shown in the following code snippet.
    We are given a task to update an array with a function, after `1` second of calling
    the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '`console.log(syncarray)` is executed before the `addB()` function, hence we
    see the `syncarray` output before it is being updated. This is an Asynchronous
    behavior. One of the ways to solve this is to use a callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the preceding callback approach means that we always pass in callbacks
    in order to perform other operations on the updated `syncarray` function. Let''s
    update the code a little, and this time we''ll also add the string `"A"` to `syncarray`
    and then print out the updated array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code block shows a quick way of passing `callback`. Based on the
    arrow function we discussed, it can be more organized by creating a named function.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning callbacks with promises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using callbacks quickly becomes unwieldy and can quickly descend into callback
    hell. One method of freeing ourselves from this is to make use of Promises. Promises
    makes our callbacks more organized. It gives a chainable mechanism to unify and
    orchestrate code that is dependent on previous functions, as you''ll see in the
    following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, `setTimeout` is wrapped inside the `Promise`
    function. A `Promise` is always instantiated using the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: A `Promise` is either resolved or rejected. When it is resolved, then we are
    free to do other things, and when it is rejected, we need to handle the error.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s ensure that the following `Promise` is rejected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'And whenever we have multiple promises, we can use the `.then()` method to
    handle each one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The use of multiple `.then()` methods to handle numerous promises can quickly
    become unwieldy. To prevent this, we can use methods such as `Promise.all()`,
    `Promise.any()`, and `Promise.race()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Promise.all()` method takes in an array of promises to be executed, and
    will only resolve when all promises are fulfilled. In the following code snippet,
    we add another Asynchronous function to our previous example and use `Promise.all()`
    to handle them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: From the output in the preceding section, you can see that each Asynchronous
    function gets executed in the order it was added, and the final result is the
    effect of both functions on the `syncarray` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `promise.race` method, on the other hand, will return as soon as any promise
    in the array is resolved or rejected. You can think of this as a race where each
    promise tries to resolve or reject first, and as soon as this happens, the race
    is over. To see an in-depth explanation as well as code examples, you can visit
    the MDN docs here: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any).'
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally, the `promise.any` method will return on the first fulfilled promise
    irrespective of any other rejected `promise` function. If all promises are rejected,
    then `Promise.any` rejects promises by providing errors for all of them. To see
    an in-depth explanation as well as code examples, you can visit the MDN docs here:
    [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race).'
  prefs: []
  type: TYPE_NORMAL
- en: While using promises to work with callback solves a lot of issues, there is
    an even better way of implementing or using them. These are called **async/await**
    functions. We'll introduce these functions and show you how to use them in the
    following section.
  prefs: []
  type: TYPE_NORMAL
- en: async/await
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As said earlier, async/await provides a more elegant way of working with promises.
    It gives us the power to control how and when each promise function gets called
    inside a function, instead of using `.then()` and `Promise.all()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how you can use async/await in your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `async` function can contain as many promise functions as possible,
    each waiting for the other to execute before being executed. Also, note that an
    `a``sync` function is resolved as a `Promise`. that is, you can only obtain the
    return variable of the preceding `anyName` function (or resolve the function)
    using `.then()` or by calling it in another `async`/`await` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'With this knowledge, here is how we can rewrite the promise execution from
    the previous section instead of using `Promise.all([addA(), addB()])`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: You can see from the preceding output that we have the same output as when using
    the `Promise.all` syntax, but are adopting a minimal and cleaner approach.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: One drawback of using multiple awaits as opposed to `promise.all` is efficiency.
    Though minor, `promise.all` is the preferred and recommended way to handle multiple
    independent promises.
  prefs: []
  type: TYPE_NORMAL
- en: This thread ([https://stackoverflow.com/questions/45285129/any-difference-between-await-promise-all-and-multiple-await](https://stackoverflow.com/questions/45285129/any-difference-between-await-promise-all-and-multiple-await))
    on Stack Overflow clearly explains why this is the recommended way to handle multiple
    promises.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll discuss **object-oriented programming** (**OOP**)
    in JavaScript, and how to use ES6 classes.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented programming and JavaScript classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OOP is a common programming paradigm supported by most high-level languages.
    In OOP, you typically program an application using the concept of objects, which
    can be a combination of data and code.
  prefs: []
  type: TYPE_NORMAL
- en: Data represents information about the object, while code represents attributes,
    properties, and behaviors that can be carried out on objects.
  prefs: []
  type: TYPE_NORMAL
- en: OOP opens up a whole new world of possibilities as many problems can be simulated
    or designed as the interaction between different objects, thereby making it easier
    to design complex programs, as well as maintain and scale them.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript, like other high-level languages, provides support for OOP concepts,
    although not fully ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes)),
    but in essence, most of the important concepts of OOP, such as **objects**, **classes**,
    and **inheritance**, are supported, and these are mostly enough to solve many
    problems you wish to model using OOP. In the following section, we will briefly
    look at classes and how these are related to OOP in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Classes in OOP act like a blueprint for an object. That is, they define a template
    of an abstract object in such a way that multiple copies can be made by following
    that blueprint. Copies here are officially called **instances**. So, in essence,
    if we define a class, then we can easily create multiple instances of that class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In ECMA 2015, the `User` object using the ES16 `class` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: By using the `class` keyword, you can wrap both data (names and email) with
    functionality (functions/methods) in a cleaner way that aids easy maintenance
    as well as understanding.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on, let's break down the class template in more detail for a
    better understanding.
  prefs: []
  type: TYPE_NORMAL
- en: The first line starts with the `class` keyword and is usually followed by a
    class name. A class name, by convention, is written in camel case, for instance,
    `UserModel` or `DatabaseModel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An optional constructor can be added inside a `class` definition. A `constructor`
    class is an initialization function that runs every time a new instance is created
    from a class. Here, you''ll normally add code that initializes each instance with
    specific properties. For instance, in the following code snippet, we create two
    instances from the `User` class, and initialize them with specific properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The next important part of a class is the addition of functions. Functions
    act as `class` methods and generally add a specific behavior to the class. Functions
    are also available to every instance created from the class. In our `User` class,
    methods such as `getFirstName`, `getLastName`, `getEmail`, and `setEmail` are
    added to perform different functions based on their implementation. To call functions
    on class instances, you typically use a dot notation, as you would when accessing
    an object''s property. For example, in the following code, we return the full
    name of the `Person1` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: With classes out of the way, we now move to the next concept in OOP, called
    *inheritance*.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Inheritance** in OOP is the ability of one class to use properties/methods
    of another class. It is an easy way of extending the characteristics of one class
    (subclass/child class) using another class (superclass/parent class). In that
    way, the child class inherits all the characteristics of the parent class and
    can either extend or change these properties. Let''s use an example to better
    understand this concept.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our application, let''s assume we already have the `User` class defined
    in the previous section, but we want to create a new set of users called `Teachers`.
    Teachers are also a class of users, and they will also require basic properties,
    such as the name and email that the `User` class already has. So, instead of creating
    a new class with these existing properties and methods, we can simply extend it,
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we use the `extends` keyword. This keyword simply makes all the properties
    in the parent class (`User`) available to the child class (`Teacher`). With just
    the basic setup, the `Teacher` class automatically has access to all the properties
    and methods of the `User` class. For instance, we can instantiate and create a
    new `Teacher` in the same way we created a `User` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'After extending a class, we basically want to add new features. We can do this
    by simply adding new functions or properties inside the child class template,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we added a new method, `getUserType`, which returns
    a string of the `user` type. In this way, we can add more features that were not
    originally in the `parent` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth mentioning that you can replace parent functions in the `child`
    class by creating a new function in the `child` class with the same name. This
    process is called `getFullName` function in the `Teacher` class, we can do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'A question may arise here: What if we want to initialize the `Teacher` class
    with additional instances besides `firstname`, `lastname`, and `email`? This is
    achievable, and we can easily extend the constructor function by using a new keyword,
    `super`. We demonstrate how to do this in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are performing two new things. First, we add two new
    instance properties (`userType` and `subject`) to the `Teacher` class, and then
    we are calling the `super` function. The `super` function simply calls the parent
    class (`User`), and performs the instantiation, and immediately after, we initialize
    the new properties of the `Teacher` class.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, we are able to first initialize the parent properties before initializing
    the class properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Classes are very useful in OOP and the `class` keyword provided in JavaScript
    makes working with OOP easy. It is worth mentioning that under the hood, JavaScript
    converts the classes template to an object, as it does not have first-class support
    for classes. This is because JavaScript, by default, is a prototype-based, object-oriented
    language. Hence, the class interface provided is called **syntactic sugar** over
    the underlying prototype-based model, which JavaScript calls under the hood. You
    can read more about this at the following link: [http://es6-features.org/#ClassDefinition](http://es6-features.org/#ClassDefinition).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a basic understanding of OOP in JavaScript, we are ready to
    create complex applications that can be easily maintained. In the next section,
    we will discuss another important aspect of JavaScript development, which is setting
    up a development environment with modern JavaScript support.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a modern JavaScript environment with transpilers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the unique features of JavaScript, and the reason why it is very popular,
    is its cross-platform support. JavaScript runs almost everywhere, from browsers
    and desktops to even on the server side. While this is a unique feature, getting
    JavaScript to run optimally in these environments requires some setup and configuration
    using third-party tools/libraries. Another reason why you need to set up tooling
    is that you can write JavaScript in different flavors, and because these modern/newer
    flavors may not be supported by older browsers. This means that the code you write
    in newer syntax, typically post-ES15, will need to be transpiled into pre-ES16
    format for it to run properly in most browsers.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will learn how to set up and configure a JavaScript project
    to support cross-platform and modern JavaScript code. You will use two popular
    tools – **Babel** and **webpack** – to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: Babel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Babel is a tool for converting JavaScript code written in ES15 code into a
    backward-compatible version of JavaScript in modern or older browsers. Babel can
    help you to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Transform/transpile syntax.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polyfill features that are missing in your target environment. Some modern features
    that are not available in older environments are automatically added by Babel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transform source code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following code, we show an example of a Babel-transformed code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that in the preceding code snippet, the modern arrow function
    is automatically transpiled to the function keyword that is supported by all browsers.
    This is what Babel does under the hood to your source code.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's understand where webpack comes in.
  prefs: []
  type: TYPE_NORMAL
- en: Webpack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: webpack is also a transpiler, and can perform the same function as Babel, and
    even more. webpack can package and bundle just about anything, including *images*,
    *HTML*, *CSS*, and *JavaScript*, into a single optimized script that can easily
    be used in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll leverage both Babel and webpack to show you how to set
    up a cross-platform JavaScript project. Let's dive right in.
  prefs: []
  type: TYPE_NORMAL
- en: Example project using Babel and webpack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we''re going to create a simple JavaScript project using `npm`.
    As such, you should have Node.js installed locally in order to follow along. Perform
    the following steps to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a terminal in your preferred directory and create a folder with the following
    commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `package.json` file. While you can do this manually, it is easier
    to create one using `npm`. Run the following command in your terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, install all the relevant packages that will help us to perform bundling
    and transpilation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"name": "cross-env-js",'
  prefs: []
  type: TYPE_NORMAL
- en: '"version": "1.0.0",'
  prefs: []
  type: TYPE_NORMAL
- en: '"description": "",'
  prefs: []
  type: TYPE_NORMAL
- en: '"main": "index.js",'
  prefs: []
  type: TYPE_NORMAL
- en: '"scripts": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"test": "echo \"Error: no test specified\" && exit 1"'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '"keywords": [],'
  prefs: []
  type: TYPE_NORMAL
- en: '"author": "",'
  prefs: []
  type: TYPE_NORMAL
- en: '"license": "ISC",'
  prefs: []
  type: TYPE_NORMAL
- en: '"devDependencies": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"@babel/cli": "^7.12.8",'
  prefs: []
  type: TYPE_NORMAL
- en: '"@babel/core": "^7.12.9",'
  prefs: []
  type: TYPE_NORMAL
- en: '"@babel/preset-env": "^7.12.7",'
  prefs: []
  type: TYPE_NORMAL
- en: '"babel-loader": "^8.2.2",'
  prefs: []
  type: TYPE_NORMAL
- en: '"webpack": "^5.9.0",'
  prefs: []
  type: TYPE_NORMAL
- en: '"webpack-cli": "^4.2.0"'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '"dependencies": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"@babel/polyfill": "^7.12.1"'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Add some code, which we'll transpile and test. For this section, you can either
    create files and folders from the terminal or use a code editor. I'll use the
    Visual Studio Code editor here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In your code editor, open the `cross-env-js` project folder and then create
    the files and folders as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: That is, you will create two folders called `dist` and `src`. `dist` will contain
    an HTML file (`index.html`), which will be used to test our bundled application,
    and `src` will contain our modern JavaScript code that we want to transpile.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating these files and folders, your entire directory structure should
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you're using version control such as Git, you will typically add a `.gitignore`
    file to specify that `node_modules` can be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `dist` folder, and in that folder, create an `index.html` file with
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The HTML file should be familiar to you, but notice that we added a `script`
    tag pointing to a `bundle.js` file. This file does not yet exist and will be generated
    by webpack using Babel under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: Write some modern JavaScript in the `src` folder. Starting with `utils.js`,
    we'll create and export some functions, and then import them to be used in `index.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Starting with `utils.js`, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The `utils.js` script uses some modern JS syntax, such as `export` and arrow
    functions, and these will only be compatible with older browsers after transpilation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in the `index.js` script, you''ll import these functions and use them.
    Add the following code to your `index.js` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: You'll notice that we are also using arrow functions and the destructuring import
    in the `index.js` file. Here, we're importing the exported array (names) and the
    `getSubject` function from the `utils.js` script. We are also using a combination
    of the arrow function and template literals (`` ``) to retrieve and log the details
    of each `Teacher`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our modern JS files are ready, we'll create a configuration file that
    tells webpack where to find our source code to bundle as well as which transpiler
    to use, in our case, Babel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In your root directory, create a `webpack.config.js` file and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s understand what is going on in this file:'
  prefs: []
  type: TYPE_NORMAL
- en: a) The first part of the config file requires the `path` module, which will
    help resolve all path-related functions.
  prefs: []
  type: TYPE_NORMAL
- en: b) Next, you will notice the `entry` field. This field simply tells webpack
    where to find the starting/main script. webpack will use this file as a starting
    point, and then recursively walk through each import dependency to link all files
    relating to the entry file.
  prefs: []
  type: TYPE_NORMAL
- en: c) The next field is `output`, and this tells webpack where to save the bundled
    file. In our example, we are saving bundled files to the `dist` folder under the
    name `bundle.js` (remember we referenced `bundle.js` in our HTML file).
  prefs: []
  type: TYPE_NORMAL
- en: d) Finally, in the `module` field, we specify that we want to transpile each
    script using Babel, and we also exclude transpiling `node_modules`. With this
    webpack configuration file, you're ready to transpile and bundle your source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `package.json` file, you''ll add a script command that will call `webpack`,
    as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'In your terminal, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 1.2 – webpack bundling successful output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_01_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.2 – webpack bundling successful output
  prefs: []
  type: TYPE_NORMAL
- en: Upon successful completion of the preceding steps, you can navigate to the `dist`
    folder where you will find an extra file – `bundle.js`. This file has already
    been referenced by the `index.html` file, and as such will be executed anytime
    we load the `index.html` file in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: To test this, open the `index.html` file in your default browser. This can be
    done by navigating to the directory and double-clicking on the `index.html` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the `index.html` file opened in your browser, you should open
    the developer console, where you can find your code output, as in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3 – index.js output in the browser console'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_01_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.3 – index.js output in the browser console
  prefs: []
  type: TYPE_NORMAL
- en: This shows that you have successfully transpiled and bundled your modern JS
    code into a format that can be executed in any browser, be it old or new.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs: []
  type: TYPE_NORMAL
- en: 'Bundling files can quickly become difficult and confusing, especially as the
    project gets bigger. If you require further understanding of how to bundle files,
    you can reference the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '* Getting Started ([https://webpack.js.org/guides/getting-started/](https://webpack.js.org/guides/getting-started/))
    with webpack'
  prefs: []
  type: TYPE_NORMAL
- en: '* Usage Guide ([https://babeljs.io/docs/en/usage](https://babeljs.io/docs/en/usage))
    for Babel'
  prefs: []
  type: TYPE_NORMAL
- en: '* How to enable ES6 (and beyond) syntax with Node and Express ([https://www.freecodecamp.org/news/how-to-enable-es6-and-beyond-syntax-with-node-and-express-68d3e11fe1ab/](https://www.freecodecamp.org/news/how-to-enable-es6-and-beyond-syntax-with-node-and-express-68d3e11fe1ab/))'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you'll learn how to set up testing and perform unit testing
    in your JavaScript application.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing with Mocha and Chai
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing tests for your application code is very important, but rarely talked
    about in most books. This is why we have decided to add this section on unit testing
    with Mocha. While you may not necessarily write verbose tests for every sample
    app you'll be building in this book, we will show you the basics you need to get
    by and you can even use them in your own project.
  prefs: []
  type: TYPE_NORMAL
- en: Testing, or automated testing, is used during development to check that our
    code actually behaves as expected. That is, you, the writer of a function, will
    generally know beforehand how the function behaves and therefore can test the
    outcome with the expected outcome.
  prefs: []
  type: TYPE_NORMAL
- en: '`it` and `describe`, which can be used to write and run tests automatically.
    The beautiful thing about Mocha is that it can run in both node and browser environments.
    Mocha also supports integration with various assertion libraries such as *Chai*
    ([https://www.chaijs.com/](https://www.chaijs.com/)), *Expect.js* ([https://github.com/LearnBoost/expect.js](https://github.com/LearnBoost/expect.js)),
    *Should.js* ([https://github.com/shouldjs/should.js](https://github.com/shouldjs/should.js)),
    or even Node.js'' built-in *assert* ([https://nodejs.org/api/assert.html](https://nodejs.org/api/assert.html))
    module. In this book, we''ll use the Chai assertion library, as it is one of the
    most commonly used assertion libraries with Mocha.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a test environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we begin writing tests, we''ll set up a basic Node.js project. Perform
    the following steps to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your current working directory, create a new folder called `unit-testing`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize a new Node.js project using `npm`, as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Install Mocha and Chai as development dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Following successful installation, open your `package.json` file and change
    the `test` command in `scripts` to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: This means that we can run tests by running the `npm run test` command in the
    terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create two folders, `src` and `test`. The `src` folder will contain our source
    code/scripts, while the `test` folder will contain corresponding tests for our
    code. Your project tree should look like the following after creating the folders:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `src` folder, create a script called `utils.js`, and add the following
    functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The preceding functions perform some basic computation. The first one adds two
    numbers and returns the result, while the second function computes the mean of
    numbers in an array.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We are writing pre-ES16 JavaScript here. This is because we do not plan to set
    up any transpiler for this sample project. In a project using modern JavaScript,
    you'll typically transpile source code before testing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `test` folder, add a new file, also called `utils.js`. This naming
    convention is recommended, as different files should bear the same name as their
    corresponding source code. In the `utils.js` file in your `test` folder, add the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: In the first three lines of the preceding code snippet, we are importing `chai`
    and `expect`, as well as the `utils` scripts, which contain our source code.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use Mocha's `describe` and `it` functions to define our test cases.
    Note that we have two `describe` functions corresponding to the two functions
    we have in our source code. This means that each `describe` function will contain
    individual unit tests that test different aspects of our code.
  prefs: []
  type: TYPE_NORMAL
- en: The first `describe` function tests the `addTwoNumber` function and includes
    three unit tests, one of which tests whether the correct error is thrown on a
    passing string data type. The second `describe` function tests the `mean` function
    by providing different values.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run our test, go to your terminal and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 1.4 – Mocha test output showing all tests passed'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_01_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.4 – Mocha test output showing all tests passed
  prefs: []
  type: TYPE_NORMAL
- en: By following the preceding steps, we were able to write and run some tests that
    passed on the first run. This may not be the case most times, as your test will
    generally fail a lot before passing, especially when you have numerous unit tests
    for different edge cases.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, we'll add a new test case that expects an error when the array
    passed to the mean function contains no element.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the test script, under the second `describe` function, add the following
    unit test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'By running the test again, we''ll see the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5 – Mocha test output showing one failed test'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_01_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.5 – Mocha test output showing one failed test
  prefs: []
  type: TYPE_NORMAL
- en: 'The error message provided by Mocha tells us that our function is expected
    to throw an error when an empty array is passed, but it is currently not doing
    that. To fix this error, we''ll go to our source code and update the `mean` function,
    as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we run the test again, we should see it pass successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6 – Mocha test output showing that all tests passed'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_01_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.6 – Mocha test output showing that all tests passed
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs: []
  type: TYPE_NORMAL
- en: 'Mocha is versatile and provides support for almost all test cases and scenarios
    you''ll encounter. To learn more, you can visit the official documentation here:
    [https://mochajs.org/](https://mochajs.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chai, on the other hand, provides numerous assertion statements and functions
    that you can use to enrich your test. You can learn more about these assertions
    here: [https://www.chaijs.com/api/](https://www.chaijs.com/api/).'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations on making it to the end of this chapter! It was a lengthy one,
    but the concepts covered are important, as they will help you build better data-driven
    products, as you'll see in future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced and discussed some of the modern JavaScript syntax
    introduced in ECMA 6\. We first considered the difference between `let` and `var`
    and discussed why `let` is the preferred method for initializing variables. Following
    that, we discussed destructuring, the spread operator, scopes, and also closures.
    We then went on to introduce some important methods of arrays, objects, and strings.
    Following that, we talked about arrow functions, including their advantages over
    traditional functions, and then we moved on to discuss JavaScript promises and
    async/await.
  prefs: []
  type: TYPE_NORMAL
- en: We then looked briefly at OOP concepts and support in JavaScript with examples
    showing how to write classes. We also learned how to set up a modern JavaScript
    environment with transpiling and bundling support using tools such as Babel and
    webpack. Finally, we introduced unit testing using Mocha and the Chai library.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce Dnotebook, an interactive computing environment
    that enables quick and interactive experimentation in JavaScript.
  prefs: []
  type: TYPE_NORMAL
