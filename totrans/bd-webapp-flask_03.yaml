- en: Chapter 3. Man, Do I Like Templates!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As stated previously, Flask gives you the VC of MVC out-of-the-box. In this
    chapter, we will discuss what Jinja2 is, and how Flask uses Jinja2 to implement
    the View layer and awe you. Be prepared!
  prefs: []
  type: TYPE_NORMAL
- en: What is Jinja2 and how is it coupled with Flask?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Jinja2 is a library found at [http://jinja.pocoo.org/](http://jinja.pocoo.org/);
    you can use it to produce formatted text with bundled logic. Unlike the Python
    format function, which only allows you to replace markup with variable content,
    you can have a control structure, such as a `for` loop, inside a template string
    and use Jinja2 to parse it. Let''s consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have a very simple example where we create a template
    string with a `for` loop control structure ("for tag", for short) that iterates
    over a list variable called `my_list` and prints the element inside a "li HTML
    tag" using curly braces `{{ }}` notation.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that you could call `render` in the template instance as many times as
    needed with different key-value arguments, also called the template context. A
    context variable may have any valid Python variable name—that is, anything in
    the format given by the regular expression *[a-zA-Z_][a-zA-Z0-9_]**.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a full overview on regular expressions (**Regex** for short) with Python,
    visit [https://docs.python.org/2/library/re.html](https://docs.python.org/2/library/re.html).
    Also, take a look at this nice online tool for Regex testing [http://pythex.org/](http://pythex.org/).
  prefs: []
  type: TYPE_NORMAL
- en: A more elaborate example would make use of an environment class instance, which
    is a central, configurable, extensible class that may be used to load templates
    in a more organized way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do you follow where we are going here? This is the basic principle behind Jinja2
    and Flask: it prepares an environment for you, with a few responsive defaults,
    and gets your wheels in motion.'
  prefs: []
  type: TYPE_NORMAL
- en: What can you do with Jinja2?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jinja2 is pretty slick. You can use it with template files or strings; you can
    use it to create formatted text, such as HTML, XML, Markdown, and e-mail content;
    you can put together templates, reuse templates, and extend templates; you can
    even use extensions with it. The possibilities are countless, and combined with
    nice debugging features, auto-escaping, and full unicode support.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Auto-escaping is a Jinja2 configuration where everything you print in a template
    is interpreted as plain text, if not explicitly requested otherwise. Imagine a
    variable *x* has its value set to `<b>b</b>`. If auto-escaping is enabled, `{{
    x }}` in a template would print the string as given. If auto-escaping is off,
    which is the Jinja2 default (Flask's default is on), the resulting text would
    be `b`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's understand a few concepts before covering how Jinja2 allows us to do our
    coding.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have the previously mentioned curly braces. Double curly braces are
    a delimiter that allows you to evaluate a variable or function from the provided
    context and print it into the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we see how to use curly braces to evaluate variables
    in your template. First, we evaluate a string and then an integer. Both result
    in a unicode string. If we evaluate a class of our own, we must make sure there
    is a `__unicode__` method defined, as it is called during the evaluation. If a
    `__unicode__` method is not defined, the evaluation falls back to `__str__` and
    `__repr__`, sequentially. This is easy. Furthermore, what if we want to evaluate
    a function? Well, just call it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To output the result of a function in a template, just call the function as
    any regular Python function. The function return value will be evaluated normally.
    If you're familiar with Django, you might notice a slight difference here. In
    Django, you do not need the parentheses to call a function, or even pass arguments
    to it. In Flask, the parentheses are *always* needed if you want the function
    return evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following two examples show the difference between Jinja2 and Django function
    call in a template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also evaluate Python math operations. Take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Other math operators will also work. You may use the curly braces delimiter
    to access and evaluate lists and dictionaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: To access a list or dictionary value, just use normal plain Python notation.
    With dictionaries, you can also access a key value using variable access notation,
    which is pretty neat.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the curly braces delimiter, Jinja2 also has the curly braces/percentage
    delimiter, which uses the notation `{% stmt %}` and is used to execute statements,
    which may be a control statement or not. Its usage depends on the statement, where
    control statements have the following notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The first tag has the statement name, while the second is the closing tag,
    which has the name of the statement appended with `end` in the beginning. You
    must be aware that a non-control statement *may* not have a closing tag. Let''s
    look at some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example is a little more complex than what we have been seeing.
    It uses a control statement `for` loop inside a block statement (you can have
    a statement inside another), which is not a control statement, as it does not
    control execution flow in the template. Inside the `for` loop you see that the
    `i` variable is being printed together with the associated price (defined elsewhere).
  prefs: []
  type: TYPE_NORMAL
- en: 'A last delimiter you should know is `{# comments go here #}`. It is a multi-line
    delimiter used to declare comments. Let''s see two examples that have the same
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Both comment delimiters hide the content between `{#` and `#}`. As can been
    seen, this delimiter works for one-line comments and multi-line comments, what
    makes it very convenient.
  prefs: []
  type: TYPE_NORMAL
- en: Control structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have a nice set of built-in control structures defined by default in Jinja2\.
    Let's begin our studies on it with the `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `if` control statement is beautiful! It behaves just like a `python if`
    statement. As seen in the preceding code, you can use it to compare objects in
    a very easy fashion. "`else`" and "`elif`" are also fully supported.
  prefs: []
  type: TYPE_NORMAL
- en: You may also have noticed that `true` and `false`, non-capitalized, were used
    together with plain Python Booleans, `True` and `False`. As a design decision
    to avoid confusion, all Jinja2 templates have a lowercase alias for `True`, `False`,
    and `None`. By the way, lowercase syntax is the preferred way to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'If needed, and you should avoid this scenario, you may group comparisons together
    in order to change precedence evaluation. See the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The expected output for the preceding example is `true`, `true`, and `false`.
    The first two lines are pretty straightforward. In the third line, first, `(10<15)`
    is evaluated to `True`, which is a subclass of `int`, where `True == 1`. Then
    `5` < `True` is evaluated, which is certainly false.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `for` statement is pretty important. One can hardly think of a serious
    Web application that does not have to show a list of some kind at some point.
    The `for` statement can iterate over any iterable instance and has a very simple,
    Python-like syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the first statement, we have the opening tag indicating that we will iterate
    over `my_list` items and each item will be referenced by the name `item`. The
    name `item` will be available inside the `for` loop context only.
  prefs: []
  type: TYPE_NORMAL
- en: In the second statement, we have an iteration over the key value tuples that
    form `my_dictionary`, which should be a dictionary (if the variable name wasn't
    suggestive enough). Pretty simple, right? The `for` loop also has a few tricks
    in store for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'When building HTML lists, it''s a common requirement to mark each list item
    in alternating colors in order to improve readability or mark the first or/and
    last item with some special markup. Those behaviors can be achieved in a Jinja2
    for-loop through access to a loop variable available inside the block context.
    Let''s see some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `for` loop statement, as in Python, also allow the use of `else`, but with
    a slightly different meaning. In Python, when you use `else` with `for`, the `else`
    block is only executed if it was *not* reached through a `break` command like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As seen in the preceding code snippet, the `else` block will only be executed
    in a `for` loop if the execution was never broken by a `break` command. With Jinja2,
    the `else` block is executed when the `for` iterable is empty. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As we are talking about loops and breaks, there are two important things to
    know: the Jinja2 `for` loop does not support `break` or `continue`. Instead, to
    achieve the expected behavior, you should use loop filtering as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first tag you see a normal `for` loop together with an `if` condition.
    You should consider that condition as a real list filter, as the index itself
    is only counted per iteration. Run the preceding example and the output will be
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Look at the last observation in the preceding example—in the second tag, do
    you see the dash in `{%-`? It tells the renderer that there should be no empty
    new lines before the tag at each iteration. Try our previous example without the
    dash and compare the results to see what changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll now look at three very important statements used to build templates
    from different files: `block`, `extends`, and `include`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`block` and `extends` always work together. The first is used to define "overwritable"
    blocks in a template, while the second defines a parent template that has blocks,
    for the current template. Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Do you see the inheritance happening, between `child.txt` and `parent.txt`?
    `parent.txt` is a simple template with two `block` statements, called `template`
    and `past`. When you render `parent.txt` directly, its blocks are printed "as
    is", because they were not overwritten. In `child.txt`, we extend the `parent.txt`
    template and overwrite all its blocks. By doing that, we can have different information
    in specific parts of a template without having to rewrite the whole thing.
  prefs: []
  type: TYPE_NORMAL
- en: With `other.txt`, for example, we extend the `child.txt` template and overwrite
    only the block-named template. You can overwrite blocks from a direct parent template
    or from any of its parents.
  prefs: []
  type: TYPE_NORMAL
- en: If you were defining an `index.txt` page, you could have default blocks in it
    that would be overwritten when needed, saving lots of typing.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the last example, Python-wise, is pretty simple. First, we create
    a Jinja2 environment (we talked about this earlier) and tell it how to load our
    templates, then we load the desired template directly. We do not have to bother
    telling the environment how to find parent templates, nor do we need to preload
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `include` statement is probably the easiest statement so far. It allows
    you to render a template inside another in a very easy fashion. Let''s look at
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we render the `joke.txt` template inside `base.txt`.
    As `joke.txt` is rendered inside `base.txt`, it also has full access to the `base.txt`
    context, so `myvar` is printed normally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have the `set` statement. It allows you to define variables for
    inside the template context. Its use is pretty simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, if `x` was given by a complex calculation or a database
    query, it would make much more sense to have it *cached* in a variable, if it
    is to be reused across the template. As seen in the example, you can also assign
    a value to multiple variables at once.
  prefs: []
  type: TYPE_NORMAL
- en: Macros
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Macros are the closest to coding you''ll get inside Jinja2 templates. The macro
    definition and usage are similar to plain Python functions, so it is pretty easy.
    Let''s try an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we create a macro that accepts a `name` argument
    and two optional arguments: `value` and `label`. Inside the `macro` block, we
    define what should be output. Notice we can use other statements inside a macro,
    just like a template. In `index.html` we import the input macro from inside `formfield.html`,
    as if `formfield` was a module and input was a Python function using the `import`
    statement. If needed, we could even rename our input macro like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also import `formfield` as a module and use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'When using macros, there is a special case where you want to allow any named
    argument to be passed into the macro, as you would in a Python function (for example,
    `**kwargs`). With Jinja2 macros, these values are, by default, available in a
    `kwargs` dictionary that does not need to be explicitly defined in the macro signature.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `kwargs` is available even though you did not define a `kwargs`
    argument in the macro signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Macros have a few clear advantages over plain templates, that you notice with
    the `include` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: You do not have to worry about variable names in the template using macros
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can define the exact required context for a macro block through the macro
    signature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can define a macro library inside a template and import only what is needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commonly used macros in a Web application include a macro to render pagination,
    another to render fields, and another to render forms. You could have others,
    but these are pretty common use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Regarding our previous example, it is good practice to use HTTPS (also known
    as, Secure HTTP) to send sensitive information, such as passwords, over the Internet.
    Be careful about that!
  prefs: []
  type: TYPE_NORMAL
- en: Extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Extensions are the way Jinja2 allows you to extend its vocabulary. Extensions
    are not enabled by default, so you can enable an extension only when and if you
    need, and start using it without much trouble:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have an example where you create an environment with
    two extensions enabled: `do` and `with`. Those are the extensions we will study
    in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As the name suggests, the `do` extension allows you to "do stuff". Inside a
    `do` tag, you''re allowed to execute Python expressions with full access to the
    template context. Flask-Empty, a popular Flask boilerplate available at [https://github.com/italomaia/flask-empty](https://github.com/italomaia/flask-empty)
    uses the `do` extension to update a dictionary in one of its macros, for example.
    Let''s see how we could do the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we create the `x` variable with a dictionary, then
    we update it with `{3: ''bar''}`. You don''t usually need to use the `do` extension
    but, when you do, a lot of coding is saved.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `with` extension is also very simple. You use it whenever you need to create
    block scoped variables. Imagine you have a value you need cached in a variable
    for a brief moment; this would be a good use case. Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As seen in the example, `age` exists only inside the `with` block. Also, variables
    set inside a `with` block will only exist inside it. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Filters are a marvelous thing about Jinja2! This tool allows you to process
    a constant or variable before printing it to the template. The goal is to implement
    the formatting you want, strictly in the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a filter, just call it using the pipe operator like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Its name is passed to the **capitalize** filter that processes it and returns
    the capitalized value. To inform arguments to the filter, just call it like a
    function, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `join` filter will join all values from the passed iterable, putting the
    provided argument between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Jinja2 has an enormous quantity of available filters by default. That means
    we can''t cover them all here, but we can certainly cover a few. `capitalize`
    and `lower` were seen already. Let''s look at some further examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Try the preceding example to see exactly what each filter does.
  prefs: []
  type: TYPE_NORMAL
- en: 'After reading this much about Jinja2, you''re probably thinking: "Jinja2 is
    cool but this is a book about Flask. Show me the Flask stuff!". Ok, ok, I can
    do that!'
  prefs: []
  type: TYPE_NORMAL
- en: Of what we have seen so far, almost everything can be used with Flask with no
    modifications. As Flask manages the Jinja2 environment for you, you don't have
    to worry about creating file loaders and stuff like that. One thing you should
    be aware of, though, is that, because you don't instantiate the Jinja2 environment
    yourself, you can't really pass to the class constructor, the extensions you want
    to activate.
  prefs: []
  type: TYPE_NORMAL
- en: 'To activate an extension, add it to Flask during the application setup as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Messing with the template context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As seen in [Chapter 2](ch02.html "Chapter 2. First App, How Hard Could it Be?"),
    *First App, How Hard Could it Be?*, you can use the `render_template` method to
    load a template from the `templates` folder and then render it as a response.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to add values to the template context, as seen in some of the examples
    in this chapter, you would have to add non-positional arguments to `render_template`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, `my_age` would be available in the `index.html` context,
    where `{{ my_age }}` would be translated to 28\. `my_age` could have virtually
    any value you want to exhibit, actually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, what if you want *all* your views to have a specific value in their context,
    like a version value—some special code or function; how would you do it? Flask
    offers you the `context_processor` decorator to accomplish that. You just have
    to annotate a function that returns a dictionary and you''re ready to go. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how to render templates using only Jinja2, how control
    statements look and how to use them, how to write a comment, how to print variables
    in a template, how to write and use macros, how to load and use extensions, and
    how to register context processors. I don't know about you, but this chapter felt
    like a lot of information! I strongly advise you to run the experiment with the
    examples. Knowing your way around Jinja2 will save you a lot of headaches.
  prefs: []
  type: TYPE_NORMAL
- en: Next chapter, we will be studying forms with Flask. Expect a lot of examples
    and complementary code, as forms are the doors you open from your Web application
    to the Web. Most problems arise from the Web, as well as most of your data.
  prefs: []
  type: TYPE_NORMAL
