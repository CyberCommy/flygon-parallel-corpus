- en: Smoke/Load Testing – Testing Major Parts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining a subset of test cases using import statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leaving out integration tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Targeting end to end scenarios
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Targeting the test server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding a data simulator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recording and playing back live data in real time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recording and playing back live data as fast as possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating your management demo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Smoke testing is not very widely embraced by teams that write automated tests.
    Writing tests to verify things are working or to expose bugs is a commonly adopted
    practice, and many teams pick up the idea of using acceptance testing to verify
    whether their applications are meeting customer demands.
  prefs: []
  type: TYPE_NORMAL
- en: But smoke testing is a little different. One of the key ideas with smoke testing
    is to see whether the system has a pulse. What does this mean? It's similar to
    when a doctor first sees a patient. The first thing they do is check the patient's
    pulse, along with other vital signs. No pulse; critical pulse! So, what exactly
    in software constitutes a pulse? That is what we'll explore in the recipes in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of thinking about comprehensive test suites that make sure every corner
    of the system has been checked, smoke testing takes a much broader perspective.
    A set of smoke tests is meant to make sure the system is up and alive. It's almost
    like a ping check. Compare it to sanity tests. Sanity tests are used to prove
    a small set of situations actually work. Smoke testing, which is similar in the
    sense that it is quick and shallow, is meant to see whether the system is in an
    adequate state to proceed with more extensive testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you imagine an application built to ingest invoices, a set of smoke tests
    could include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Verify the test file has been consumed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verify the number of lines parsed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verify the grand total of the bill
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does this sound like a small set of tests? Is it incomplete? Yes it is. And
    that's the idea. Instead of verifying our software parsed everything correctly,
    we are verifying just a few key areas that *must* be working. If it fails to read
    one file, then there is a major issue that needs to be addressed. If the grand
    total of the bill is incorrect, again, something big must be taken care of.
  prefs: []
  type: TYPE_NORMAL
- en: A key side effect of smoke testing is that these tests should be quick to run.
    What if we altered the function that handles files? If our test suite involves
    parsing lots of different file types, it could take a long time to verify we didn't
    break anything. Instead of spending 30 minutes to run a comprehensive test suite,
    wouldn't it be better to run a one minute quick test and then spend the other
    29 minutes working on the software?
  prefs: []
  type: TYPE_NORMAL
- en: Smoke tests are also good to use when preparing for a customer demo. With the
    tension turned up, it's good to run tests more often to make sure we haven't broken
    anything. Before launching a demo, one last pulse check to know the system is
    alive may be needed.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also dives into load testing. Load testing is crucial to verify
    whether our applications can handle the strain of real-world situations. This
    often involves collecting real-world data and playing it back through our software
    for a reproducible environment. While we need to know our system can handle today's
    load, how likely is it that tomorrow's load will be the same? Not very likely.
  prefs: []
  type: TYPE_NORMAL
- en: It is very useful to seek out the next bottleneck in our application. That way,
    we can work towards eliminating it before we hit that load in production. One
    way to stress the system is to play back real-world data as quickly as possible.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at some recipes in which we both smoke test and
    load test the network management application. The types of load we will be placing
    on the application could also be described as **soak testing** and **stress testing**.
    **Soak testing** is described as putting a significant load on the system over
    a significant period of time. **Stress testing** is described as loading down
    a system until it breaks.
  prefs: []
  type: TYPE_NORMAL
- en: In my opinion, soak testing and stress testing are different sides of the same
    coin of load testing. That is why this chapter simply uses the term load testing
    when the various recipes can easily extend to these types of testing.
  prefs: []
  type: TYPE_NORMAL
- en: The code in this chapter also uses several utilities provided by Spring Python
    ([http://springpython.webfactional.com](http://springpython.webfactional.com)).
  prefs: []
  type: TYPE_NORMAL
- en: Many of the recipes in this chapter interact with a MySQL database. Install
    the Python MySQLdb library by typing `pip install mysql-python`.
  prefs: []
  type: TYPE_NORMAL
- en: Several of the recipes in this chapter use **Python Remote Objects** (**Pyro**)
    ([http://www.xs4all.nl/~irmen/pyro3/](http://www.xs4all.nl/~irmen/pyro3/)). It
    is a **Remote****Procedure****Call** (**RPC**) library that supports communicating
    between threads and processes. Install Pyro by typing `pip install pyro`.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a subset of test cases using import statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a Python module that selectively imports which test cases to run.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With these steps, we will explore selectively picking a smaller set of tests
    to facilitate a faster test run:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a test module called `recipe59_test.py`, which will be used to write
    some tests against our network application, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a test case that removes the database connection and stubs out the data
    access functions, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a test method that creates a set of canned data values, invokes the
    application''s process method, and then verifies the values, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Create another test case that preloads the database using a SQL script, as
    shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a test method that calls the network application''s process method and
    then prints out the results, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new file called `recipe59.py` that only imports the SQL-based test
    case, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the test module. Take a look at the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00136.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to write various test cases to cover the different levels of testing
    we need. By separating the test runner from the test case, we are able to decide
    to only run the test that integrated with the database.
  prefs: []
  type: TYPE_NORMAL
- en: Why would we do this? In our situation, we have only one unit test, and it runs
    pretty quickly. Do you think that a real-world application with months or years
    of development and a corresponding test suite will run as quickly? Of course not!
  prefs: []
  type: TYPE_NORMAL
- en: Some of the tests may be complex. They may involve talking to real systems,
    parsing huge sample data files, and other time-consuming tasks. This could realistically
    take minutes or hours to run.
  prefs: []
  type: TYPE_NORMAL
- en: When we are about to make a presentation to a customer, we don't need a long-running
    test suite. Instead, we need to be able to run a quick subset of these tests that
    gives us the confidence that things are working. Using Python's import statements
    makes this easy to define.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some suites we may want to think about include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pulse.py`: Import a set of test cases that provide broad, yet shallow testing
    of the application, to verify the system has a pulse'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`checkin.py`: Import a set of test cases that are currently functioning, and
    provide enough confidence that code is ready to be committed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`integration.py`: Import a set of test cases that start up, interact, and then
    shut down external systems such as LDAP, databases, or other subsystems'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`security.py`: Import a set of test cases that are focused on various security
    scenarios, confirming both good and bad credential handling'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`all.py`: Import all test cases to make sure everything is working'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is just a sample of the types of test module we could define. It's possible
    to define a module for each subsystem we handle. But since we are talking about
    smoke testing, we may want to think more broadly, and instead pick some key tests
    from each subsystem and tie them together to give us a sense that the application
    is working.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's have a look at these too.
  prefs: []
  type: TYPE_NORMAL
- en: Security, checking, and integration aren't smoke tests!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That is absolutely right. The previous list shows that using Python import statements
    isn't confined to defining smoke test suites. It can be used to bundle together
    test cases that serve a variety of needs. So why bring this up, since we are talking
    about smoke tests? Well, because I wanted to convey how useful this mechanism
    is for organizing tests, and that it extends beyond smoke testing.
  prefs: []
  type: TYPE_NORMAL
- en: What provides good flexibility?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To have good flexibility in being able to pick test classes, we should avoid
    making the test classes too big. But putting each test method inside a different
    class is probably too much.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Leaving out integration tests* recipe in this chapter
  prefs: []
  type: TYPE_NORMAL
- en: Leaving out integration tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A fast test suite avoids connecting to remote systems, such as databases and
    LDAP. Just verifying the core units and avoiding external systems can result in
    a faster-running test suite with more coverage. This can lead to a useful smoke
    test that gives developers confidence in the system without running all the tests.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With these steps, we will see how to cut out test cases that interact with
    external systems:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a test module called `recipe60_test.py`, which will be used for writing
    some tests for our network application, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a test case that removes the database connection and stubs out the data
    access functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a test method that creates a set of canned data values, invokes the
    applications process method, and then verifies the values, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Create another test case that preloads the database using a SQL script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a test method that calls the network application''s process method and
    then prints out the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a module called `recipe60.py` that only imports the unit test that avoids
    making SQL calls. Take a look at this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the test module. Take a look at the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00137.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This test suite runs the unit tests and avoids running test cases that integrate
    with a live database. It uses Python `import` statements to decide which test
    cases to include.
  prefs: []
  type: TYPE_NORMAL
- en: In our contrived scenario, there is little gained performance. But with a real
    project, there are probably a lot more computer cycles spent on integration testing,
    due to the extra costs of talking to external systems.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is to create a subset of tests that verify to some degree that our
    application works by covering a big chunk of it in a small amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: The trick with smoke testing is deciding what constitutes a good enough test.
    Automated testing cannot completely confirm that our application has no bugs.
    We are foiled by the fact that either a particular bug doesn't exist, or we haven't
    written a test case that exposes such a bug. To engage in smoke testing, we are
    deciding to use a subset of these tests for a quick pulse read. Again, deciding
    which subset gives us a good enough pulse may be more art than science.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe focuses on the idea that unit tests will probably run more quickly,
    and that cutting out the integration tests will remove the slower test cases.
    If all the unit tests pass, then we have some confidence that our application
    is in good shape.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I must point out that test cases don't just easily fall into the category of
    **unit test** or **integration test**. It is more of a continuum. In this recipe's
    sample code, we wrote one unit test and one integration test, and then we picked
    the unit test for our smoke test suite.
  prefs: []
  type: TYPE_NORMAL
- en: Does this appear arbitrary and perhaps contrived? Sure it does. That is why
    smoke testing isn't cut and dried but instead requires some analysis and judgment
    about what to pick. And as development proceeds, there is room for fine-tuning.
  prefs: []
  type: TYPE_NORMAL
- en: I once developed a system that ingested invoices from different suppliers. I
    wrote unit tests that set up empty database tables, ingested files of many formats,
    and then examined the contents of the database to verify processing. The test
    suite took over 45 minutes to run. This pressured me to not run the test suite
    as often as desired. I crafted a smoke test suite that involved running only the
    unit tests that did *not* talk to the database (since they were quick), combined
    with ingesting one supplier invoice. It ran in fewer than five minutes, and provided
    a quicker means to assure myself that fundamental changes to the code did not
    break the entire system. I could run this many times during the day, and only
    run the comprehensive suite about once a day.
  prefs: []
  type: TYPE_NORMAL
- en: Should a smoke test include integration or unit tests?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Does this code appear to be similar to that shown in the *Defining a subset
    of test cases using import statements *recipe? Yes, it does. So, why include it
    in this recipe? Because what is picked for the smoke test suite is just as critical
    as the tactics used to make it happen. The other recipe decided to pick up an
    integration test while cutting out the unit tests to create a smaller, faster-running
    test suite.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe shows that another possibility is to cut out the lengthier integration
    tests and instead run as many unit tests as possible, considering they are probably
    faster.
  prefs: []
  type: TYPE_NORMAL
- en: As stated earlier, smoke testing isn't cut and dried. It involves picking the
    best representation of tests without taking up too much time running them. It
    is quite possible that none the tests written up to this point precisely target
    the idea of capturing a pulse of the system. A good smoke test suite may involve
    mixing together a subset of unit and integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Defining a subset of test cases using import statements* recipe
  prefs: []
  type: TYPE_NORMAL
- en: Targeting end-to-end scenarios
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pick a complement of tests that runs enough parts to define a thread of execution.
    This is sometimes referred to as thread testing. Not because we are using software
    threading, but instead because we are focusing on a story thread. Many times,
    our threads either come from customer scenarios, or they are at least inspired
    by them. Other threads can involve other groups, such as operations.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a network management system may push out customer-affecting alarms,
    but the internal operations team that has to solve the network problems may have
    a totally different perspective. Both of these situations demonstrate valid end-to-end
    threads that are good places to invest in automated testing.
  prefs: []
  type: TYPE_NORMAL
- en: If the different teams are viewed as different types of customers, then the
    concepts of acceptance testing certainly apply. And it's also possible to overlap
    this with the concepts of BDD.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Copy the SQL script into a new file called `recipe61_network.sql` and replace
    the insert statements at the bottom with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this set of test data, `pyhost1` and `pyhost2` map into `service-abc`. `pyhost3`
    doesn't map into any service.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With these steps, we will build up an end-to-end test scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Create a test module called `recipe61_test.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a test case where each test method captures a different thread of execution,
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a test method that captures the thread of failing and recovering a piece
    of equipment, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Have the test method inject a single, faulting alarm and then confirm that
    a related piece of equipment has failed, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same test method, add code that injects a single, clearing alarm and
    confirms that the equipment has recovered, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Create another test method that captures the thread of failing and clearing
    a service, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a test method that injects a single, faulting alarm and confirms that
    both a piece of equipment and a related service fails, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same test method, add code that injects a single, clearing alarm and
    confirms that both the equipment and the service have recovered, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a test runner called `recipe61.py` that imports both of these thread
    tests, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the test suite. Look at the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00138.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe we coded two end to end test scenarios. Now consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The first scenario tested how our application processes a fault, followed by
    a clear that only impacts a piece of the equipment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second scenario tested how our application processes a fault, followed by
    a clear that impacts a service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We injected a fault and then checked the results to confirm that the proper
    piece of inventory failed. Then we injected a clear, and again we confirmed that
    the proper piece of inventory recovered.
  prefs: []
  type: TYPE_NORMAL
- en: Both of these scenarios show how our application processes different types of
    events from the beginning to the end.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a more complex, realistic version of this application, what other systems
    do you think would be involved in an end to end thread? What about security? Transactions?
    Publishing results to an external interface?
  prefs: []
  type: TYPE_NORMAL
- en: This is where we need to define where the ends are. Imagine that our application
    was grown to the point where incoming events are received by a web request and
    equipment and service updates are pushed out as JSON data to be received by a
    web page.
  prefs: []
  type: TYPE_NORMAL
- en: A good end-to-end test would include these parts as well. For the JSON output,
    we can use Python's JSON library to decode the output and then confirm the results.
    For the incoming web request, we can use many different techniques, including 
    acceptance testing tools such as the Robot Framework.
  prefs: []
  type: TYPE_NORMAL
- en: How does this define smoke tests?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If it takes too long run all the end-to-end tests, we should pick a subset of
    them that covers some key parts. For example, we could skip the equipment-based
    thread but keep the service-based one.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Testing Web Basics with the Robot Framework* recipe in [Chapter 10](https://www.packtpub.com/sites/default/files/downloads/Web_UI_Testing_Using_Selenium.pdf), *Web
    UI Testing Using Selenium*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using Robot to Verify Web Application Security *recipe in [Chapter 10](https://www.packtpub.com/sites/default/files/downloads/Web_UI_Testing_Using_Selenium.pdf), *Web
    UI Testing Using Selenium*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Targeting the test server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Does your test server have all the parts? If not, then define an alternative
    set of tests.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe assumes that the production server has an enterprise grade MySQL
    database system, while the developer's workstation does not. We will explore writing
    some tests that use the MySQL database. But when we need to run them in the development
    lab, we will make adjustments so they run on SQLite, which comes bundled with
    Python.
  prefs: []
  type: TYPE_NORMAL
- en: Are you wondering why MySQL isn't on the developer's workstation? It is true
    that MySQL is easy to install and not a huge performance load. But this scenario
    applies just the same if the production server is Oracle and management deems
    it too costly for our developers to be granted an individual license. Due to the
    cost of setting up a commercial database, this recipe is uses MySQL and SQLite
    rather than Oracle and SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure the MySQL production database server is up and running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00139.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Open a command-line MySQL client shell as the root user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a database for this recipe called `recipe62` and a user with permission
    to access it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Exit the shell. Contrary to what is shown in the following screenshot, never,
    ever, ever create a live production database with passwords stored in the clear.
    This database is for demonstration purposes only:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00140.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In these steps, we will see how to build tests that are aimed at different
    servers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an alternate version of the SQL script called `recipe62_network.mysql`
    used in earlier recipes that uses MySQL conventions, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You might not have noticed, but this schema definition has no foreign key constraints.
    In a real-world SQL script, they should definitely be included. They were left
    out in this case to reduce complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new module called `recipe62_test.py` to put our test code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an abstract test case that has one test method verifying event-to-service
    correlation, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a concrete subclass that connects to the MySQL database and uses the
    MySQL script, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a corresponding production test runner called `recipe62_production.py`,
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Run it and verify that it connects with the production database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00141.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now create a SQLite version of the SQL script called `recipe62_network.sql`,
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Create another concrete subclass of the abstract test case, have it connect
    as SQLite using the SQLite script, and add it to `recipe62_test.py`, as shown
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a corresponding development workstation test runner called `recipe62_dev.py`,
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Run it and verify that it connects with the development database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00142.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is not uncommon to have a production environment with full-fledged servers
    and software installed while at the same time having a smaller development environment.
    Some shops even have a test bed that is somewhere in between these configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Our network application handles this situation by allowing database connection
    information to get injected into it. In each test case, we used the exact same
    application, but with different database systems.
  prefs: []
  type: TYPE_NORMAL
- en: We wrote a test case that used the production MySQL database, and we wrote a
    test case that used the development SQLite database. Of course, MySQL, even though
    it is used in many production environments, doesn't sound like something that's
    not available to developers. But it provides an easy-to-see example of having
    to switch database systems.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we showed the need to switch database systems. This isn't the
    only type of external system that may require alternate configurations for test
    purposes. Other things, such as LDAP servers, third-party web services, and separate
    subsystems, may have totally different configurations.
  prefs: []
  type: TYPE_NORMAL
- en: I have worked on several contracts and have often seen members of management
    cut development lab resources to save costs. They seem to conclude that the cost
    of maintaining multiple configurations and handling non-reproducible bugs is less
    than the cost of having the exact same complement of equipment and software. I
    feel that this conclusion is faulty, because, at some time in the future, they
    end up buying more hardware and upgrade things due to increasing issues involving
    platform variance.
  prefs: []
  type: TYPE_NORMAL
- en: This means we can't always write tests that target the production environment.
    Writing our software so that it has maximum flexibility, such as injecting database
    configuration, as we did earlier, is a minimum requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s important that we write as many tests as possible that work on the developer''s
    platform. When developers have to start sharing server-side resources, then we
    run into resource collisions. For example, two developers sharing a single database
    server will have to do one of these things:'
  prefs: []
  type: TYPE_NORMAL
- en: Have separate schemas so they can empty and load test data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coordinate times when they each have access to the same schema
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have different servers set up for each developer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third option is highly unlikely, given that we are talking about a development
    lab with a smaller footprint than the production one.
  prefs: []
  type: TYPE_NORMAL
- en: A positive note is that developers are getting faster and more powerful machines.
    Compared to 10 years ago, a commonly seen workstation far exceeds old server machines.
    But, even though we may each be able to run the entire software stack on our machine,
    it doesn't mean management will pay for all the necessary licensing.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, this limitation may never change. Hence, we have to be ready
    to write tests for alternate configurations and manage the discrepancies with
    the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: How likely is it that a development and production environment would use two
    different database systems?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Admittedly, it is unlikely to have something as big as switching between SQLite
    and MySQL. That alone requires slightly different dialects of SQL to define the
    schema. Some would immediately consider this too difficult to manage. But there
    are smaller differences in environment that can still yield the same need for
    reduced testing.
  prefs: []
  type: TYPE_NORMAL
- en: I worked on a system for many years where the production system used Oracle
    9i RAC, while the development lab just had Oracle 9i. RAC required extra hardware,
    and we were never allocated the resources for it. To top it off, Oracle 9i was
    too big to install on the relatively lightweight PCs we developed with. While
    everything spoke Oracle's dialect of SQL, the uptime differences between RAC and
    non-RAC generated a fair number of bugs that we couldn't reproduce in the development
    lab. It really did qualify as two different database systems. Given that we couldn't
    work in the production environment, we tested as much as we could in the development
    lab and then scheduled time in the test lab where an RAC instance existed. Since
    many people needed access to that lab, we confined our usage to RAC-specific issues
    to avoid schedule delays.
  prefs: []
  type: TYPE_NORMAL
- en: This isn't just confined to database systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As stated earlier, this isn't just about database systems. We have discussed
    MySQL, SQLite, and Oracle, but this also involves any sort of system we work with
    or depend on that varies between production and development environments.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to code subsets of tests to achieve confidence can help cut down
    on the actual issues we will inevitably have to deal with.
  prefs: []
  type: TYPE_NORMAL
- en: Coding a data simulator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Coding a simulator that spits out data at a defined rate can help simulate real
    load.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe assumes that the reader's machine is installed with MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Make sure the MySQL production database server is up and running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a command-line MySQL client shell as the root user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a database for this recipe called `recipe63` as well as a user with permission
    to access it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Exit the shell as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00143.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With these steps, we will explore coding a test simulator:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a test generator script called `recipe63.py` that uses various Python
    libraries, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a usage method that prints out command-line options, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Use Python''s getopt library to parse command-line arguments, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Add a switch so when it's not in demo mode, it uses Spring Python's `PyroProxyFactory`
    to connect to a server instance of the network management application*:*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Code an infinite loop that creates a random event, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If in demo mode, print out the event, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If not in demo mode, make a remote call through the proxy to the network app''s
    process method, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Sleep for a certain amount of time before repeating the loop, by using this
    code line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the generator script. In the following screenshot, notice there is an error
    because we haven''t started the server process yet. This can also happen if the
    client and server have mismatched URLs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00144.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a server script called `recipe63_server.py` that will run our network
    management app connected to MySQL using the `recipe62_network.sql` SQL script from
    the *Targeting the test server* recipe, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Add code to expose the app using Pyro, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the server script in a different shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00145.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The default rate is 10 events/second. Run the generator script with a rate
    of one event/second. In the following screenshot, notice how the script generated
    a clear, fault, and then another fault. The service started at Operational, moved
    to Outage, and stayed there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00146.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python's `random.choice` method makes it easy to create a range of random events.
    By using the `time.sleep` method, we can control the rate at which the events
    are created.
  prefs: []
  type: TYPE_NORMAL
- en: We used Pyro to connect the test generator to the network management application.
    This isn't the only way to connect things together. We could have exposed the
    application through other means, such as REST, JSON, or perhaps by communicating
    through a database table. That's not important. What is important is that we built
    an independent tool that fed data into our application as if it came from a live
    network.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We built a test generator. It's easy to run multiple copies of it in different
    shells, at different rates. We have an easy way to simulate different subnets
    producing different volumes of traffic.
  prefs: []
  type: TYPE_NORMAL
- en: We could also add more command-line options to fine-tune the events. For example,
    we could make the event condition a parameter, and emulate different rates for
    different types of events.
  prefs: []
  type: TYPE_NORMAL
- en: Why does the server script initialize the database?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A production version of the server wouldn't do this. For the demonstration purposes
    of this recipe, it is convenient to put it there. Every time we stop and start
    the server script, it relaunches the database.
  prefs: []
  type: TYPE_NORMAL
- en: Why MySQL instead of SQLite?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQLite has some limitations when it comes to multithreading. Pyro uses multithreading,
    and SQLite can't pass objects across threads. SQLite is also relatively lightweight
    and probably not well-suited for a real network management application.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Targeting the test server* recipe
  prefs: []
  type: TYPE_NORMAL
- en: Recording and playing back live data in real time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nothing beats live production data. With this recipe, we will write some code
    to record live data. Then we will play it back with delays added to simulate playing
    back the live data stream.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the MySQL production database server is up and running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a command line MySQL client shell as the root user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a database for this recipe called `recipe64` as well as a user with permission
    to access it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Exit the shell, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00147.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With these steps, we will see how to record and play back data in real-time
    pace:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write a script called `recipe64_livedata.py` that simulates live data being
    sent every one to ten seconds, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a server script called `recipe64_server.py` that initializes the database
    using the SQL script `recipe62_network.mysql` from *Targeting the test server*,
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Add some code that creates an instance of the network management application
    and advertises it using Pyro and Spring Python, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Add some more code that defines an interceptor that captures incoming event
    data along with a time stamp to disk, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Add some code that wraps the network management application with the interceptor
    and advertises it using Pyro, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Start up the server app by typing `python recipe64_server.py`. Notice in the
    following screenshot that there is both a `network` service and a `network_advised`
    service registered with Pyro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00148.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the live data simulator by typing `python recipe64_livedata.py` until it
    generates a few events, and then hit Ctrl+C to break out of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00149.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Look at the server-side of things, and notice how it recorded several events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00150.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Inspect the `recipe64_data.txt` data file, noting how each line represents a
    separate event and time stamp. While it's hard to decipher the data stored in
    a pickled format, it's possible to spot bits and pieces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a script called `recipe64_playback.py` that de-pickles each line of
    the data file, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a function that finds the time interval between the current event and the
    previous one, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a client proxy to connect to the unadvised interface to our network
    management application, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Add code that iterates over each event, calculating the difference, and then
    delaying the next event by that many seconds, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the playback script by typing `python recipe64_playback.py` and observe
    how it has the same delays as the original live data simulator did:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00151.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Normally, we would be recording data coming in from the live network. In this
    situation, we need a simulator that generates random data. The simulator we coded
    in this recipe is very similar to the one shown in the *Coding a data simulator*
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'To capture the data, we coded an interceptor that is embedded between Pyro
    and the network management application. Every event published to the `network_advised`
    Pyro service name seamlessly passes through this interceptor. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Each event that comes in is appended to the data file that was initialized when
    the interceptor was first created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The event is also stored with a copy of `datetime.now()` to capture a time stamp.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The event and time stamp are combined into a tuple and pickled, making it easy
    to write and later read back from disk.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The data is pickled to make it easy to transfer to and from disk.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After writing it on to the disk, the interceptor calls the target service and
    passes the results back to the original caller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we have a playback script that reads in the data file, one event per
    line. It de-pickles each line into the tuple format it was originally stored in
    and builds a list of events.
  prefs: []
  type: TYPE_NORMAL
- en: The list of events is then scanned, one at a time. By comparing the current
    event's time stamp with the previous one, a difference in seconds is calculated
    to use Python's `time.sleep()` method to play the events back at the same rate
    they were recorded.
  prefs: []
  type: TYPE_NORMAL
- en: The playback script uses Pyro to send the events into the network management
    application. But it talks to a different exposure point. This is to avoid re-recording
    the same event.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code in this recipe uses Pyro as the mechanism connecting clients and servers
    communicate in a publish/subscribe paradigm. This isn't the only way to build
    such a service. Python has XML-RPC built in as well. It just isn't as flexible
    as Pyro. A more thorough analysis of real traffic is needed to determine whether
    this interface is good enough. Alternatives include pushing events through a database
    EVENT table where the client inserts rows and the server polls the table for new
    rows, and then removes them as they are consumed.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe also makes heavy use of Spring Python for its **aspect-oriented
    programming** features to insert the data recording code ([http://static.springsource.org/spring-python/1.1.x/reference/html/aop.html](http://static.springsource.org/spring-python/1.1.x/reference/html/aop.html)).
    This provides a clean way to add the extra layer of functionality we need to sniff
    and record network traffic without having to touch the already-built network management
    code.
  prefs: []
  type: TYPE_NORMAL
- en: I thought this recipe was about live data!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, the recipe is more about **recording** the live data and controlling the
    speed of playback. To capture this concept in a reusable recipe requires that
    we simulate the live system. But the fundamental concept of inserting a tap point
    in front of the network management processor, as we have done, is just as valid.
  prefs: []
  type: TYPE_NORMAL
- en: Is opening and closing a file for every event a good idea?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The recipe was coded to ensure that stopping the recording would incur a minimal
    risk of losing captured data not yet written to disk. Analysis of production data
    is required to determine the most efficient way of storing data. For example,
    it may take less I/O intense to write data in batches of 10, or perhaps 100 events.
    But the risk is that data can be lost in similar bundles.
  prefs: []
  type: TYPE_NORMAL
- en: If the volume of traffic is low enough, writing each event one by one, as shown
    in this recipe, may not be a problem at all.
  prefs: []
  type: TYPE_NORMAL
- en: What about offloading the storage of data?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is not uncommon to have the actual logic of opening the file, appending the
    data, and then closing the file contained in a separate class. This utility could
    then be injected into the interceptor we built. This may become important if some
    more elaborate means to storing or piping the data is needed. For example, another
    Pyro service may exist in another location that wants a copy of the live data
    feed.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting the data consumer into the aspect we coded would give us more flexibility.
    In this recipe, we don't have such requirements, but it's not hard to imagine
    making such adjustments as new requirements arrive.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Writing* *a data simulator* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Recording and playing back live data as fast as possible* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recording and playing back live data as fast as possible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Replaying production data as fast as possible (instead of in real time) can
    give you insight into where your bottlenecks are.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Make sure the MySQL production database server is up and running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a command-line MySQL client shell as the root user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a database for this recipe called `recipe65` as well as a user with permission
    to access it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Exit the shell, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00152.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In these steps, we will write some code that lets us put a big load on our
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write a script called `recipe65_livedata.py` that simulates live data being
    sent every one to ten seconds, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a server script called `recipe65_server.py` that initializes the database
    using the SQL script `recipe62_network.mysql` from the *Targeting the test server *recipe,
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Add some code that creates an instance of the network management application
    and advertises it using Pyro and Spring Python, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Add some more code that defines an interceptor that captures incoming event
    data along with a time stamp on disk, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Add some code that wraps the network management application with the interceptor
    and advertises it using Pyro, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Start up the server app by typing `python recipe65_server.py`. In the following
    screenshot, notice that there is both a `network` service and a `network_advised`
    service registered with Pyro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00153.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the live data simulator by typing `python recipe65_livedata.py` and watch
    it run until it generates a few events, and then hit *Ctrl*+*C* to break out of
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00154.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Look at the server side of things, and notice how it recorded several events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00155.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Inspect the `recipe65_data.txt` data file, noting how each line represents a
    separate event and time stamp. While it's hard to decipher the data stored in
    a pickled format, it's possible to spot bits and pieces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a playback script called `recipe65_playback.py` that de-pickles each
    line of the data file, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a client proxy to connect to the unadvised interface to our network
    management application, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Add code that iterates over each event, playing back the events as quickly
    as possible, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the playback script by typing `python recipe65_playback.py`, observing
    how it doesn''t delay events but instead plays them back as quickly as possible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00156.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Normally, we would be recording data coming in from the live network. In this
    situation, we need a simulator that generates random data. The simulator we coded
    in this recipe is very similar to the one shown in the *Coding a data simulator*
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'To capture the data, we coded an interceptor that is embedded between Pyro
    and the network management application. Every event published to the `network_advised`
    Pyro service name seamlessly passes through this interceptor. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Each event that comes in is appended to the data file that was initialized when
    the interceptor was first created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The event is also stored with a copy of `datetime.now()` to capture a time stamp.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The event and time stamp are combined into a tuple, and pickled, making it easy
    to write and later read back from disk.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data is pickled to make it easy to transfer to and from disk.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After writing it to disk, the interceptor calls the target service and passes
    the results back to the original caller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we have a playback script that reads in the data file, one event per
    line. It de-pickles each line into the tuple format it was originally stored in,
    and builds a list of events.
  prefs: []
  type: TYPE_NORMAL
- en: The list of events is then scanned, one at a time. Instead of evaluating the
    time stamps to figure out how long to delay playing back the events, they are
    injected immediately into the network management application.
  prefs: []
  type: TYPE_NORMAL
- en: The playback script uses Pyro to send the events in to the network management
    application, but it talks to a different exposure point. This is to avoid re-recording
    the same event.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code in this recipe uses Pyro as the mechanism connecting clients and servers
    communicates in a publish/subscribe paradigm. This isn't the only way to build
    such a service. Python has XML-RPC built in as well. It just isn't as flexible
    as Pyro. A more thorough analysis of real traffic is needed to determine whether
    this interface is good enough. Alternatives include pushing events through a database
    EVENT table where the client inserts rows and the server polls the table for new
    rows, and then removes them as they are consumed.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe also makes heavy use of Spring Python for its **aspect-oriented
    programming** features to insert the data recording code ([http://static.springsource.org/spring-python/1.1.x/reference/html/aop.html](http://static.springsource.org/spring-python/1.1.x/reference/html/aop.html)).
    This provides a clean way to add the extra layer of functionality we need to sniff
    and record network traffic without having to touch the existing network management
    code.
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between this and playing back in real time?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Real-time playback is useful to see how the system handles production load.
    But this doesn't answer the question of where the system is expected to break.
    Traffic flow is never steady. Instead, it often has bursts that are not expected.
    That is when playing back live data at an accelerated rate will help expose the
    system's next breakpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Preemptively addressing some of these concerns will make our system more resilient.
  prefs: []
  type: TYPE_NORMAL
- en: Where are the breaking points of this application?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Admittedly, this recipe didn't break when we played back four events as fast
    as possible. Would this be the same result in production? Things break in different
    ways. We may not get a real exception or error message but instead discover that
    certain parts of the system become backlogged.
  prefs: []
  type: TYPE_NORMAL
- en: That is where this recipe reaches its limit. While we have demonstrated how
    to overload the system with a large volume of traffic, we are not showing how
    to monitor where the bottlenecks are.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the application under load uses database tables to queue up work, then we
    would need to write the code that monitors them all and report the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Which one is the longest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which one is getting longer, and showing no sign of catching up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which one is the earliest in the pipeline of activity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In systems with stages of processing, there is often one bottleneck that makes
    itself known. When that bottleneck is fixed, it is rarely the only bottleneck.
    It was simply either the most critical one or the first one in a chain.
  prefs: []
  type: TYPE_NORMAL
- en: Also, this recipe cannot solve your bottleneck. The purpose of this recipe is
    to find it.
  prefs: []
  type: TYPE_NORMAL
- en: I once built a network load tester very much like this one. The code could handle
    processing lots of traffic in parallel, but events from the same device had to
    be processed in order. Replaying a days worth of events all at once exposed the
    fact that too many events from the same device caused the entire queue system
    to become overloaded and starve out handling other devices. After improving the
    service update algorithm, we were able to replay the same load test and verify
    it could keep up. This helped avoid non-reproducible outages that happened after
    hours or on weekends.
  prefs: []
  type: TYPE_NORMAL
- en: What amount of live data should be collected?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is useful for capturing things such as a 24-hour block of traffic to allow an
    entire day of events to be played back. Another possibility is an entire week.
    Live systems may be apt to have different loads on weekends rather than weekdays,
    and a week of data will allow better investigation.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this much data is that it is hard to pick out a window to investigate.
    This is why 24 hours of data from the weekend and 24 hours of data during the
    week may be more practical.
  prefs: []
  type: TYPE_NORMAL
- en: If there is some sort of network instability where huge outages are occurring
    and causing a huge flow of traffic, it may be useful to turn on the collector
    and wait for another similar outage to occur. After such an outage occurs, it
    may be useful to shift through the data file and trim it down to where the uptick
    in traffic occurred.
  prefs: []
  type: TYPE_NORMAL
- en: These types of captured scenarios are invaluable in load testing new releases,
    because they confirm that new patches either improve performance as expected,
    or at least don't reduce performance when fixing non-performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Writing a data simulator* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Recording and playing back live data in real-time* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating your management demo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Got a demo coming? Write automated tests that simulate the steps you'll be taking.
    Then print out your test suite, and use it like a script.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With these steps, we will see how to write our management demo script in a
    runnable fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `recipe66.py` for the test code for our management
    demo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `unittest` test scenario to capture your demo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a series of operations as if you were driving the application from this
    automated test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Include asserts at every point where you will vocally point out something during
    the demo. Take a look at this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the test suite by typing `python recipe66.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00157.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is more philosophical and less code-based. While the concept of
    this recipe is valuable, it is hard to capture in a single nugget of reusable
    code.
  prefs: []
  type: TYPE_NORMAL
- en: In this test case, I inject an event, process it, and then confirm what it impacts.
    This test case is headless, but our demo probably won't be. So far in this chapter,
    we haven't built any user screens. As we develop user screens, we need to ensure
    they call the same APIs this automated test calls.
  prefs: []
  type: TYPE_NORMAL
- en: Given this, we are set up to use the screens to define the same event shown
    in the test. After the event is digested, another screen will probably exist that
    shows current service status. We would expect it to reflect the update to Outage.
  prefs: []
  type: TYPE_NORMAL
- en: During our management demo, we will then point out/zoom in to this part of the
    screen and show how `service-abc` switched from *Operational* to *Outage.*
  prefs: []
  type: TYPE_NORMAL
- en: If the screens are built to delegate to this underlying logic, then the screen
    logic is little more than components put together to display information. The
    core logic being tested maintains its headless and easy-to-test nature.
  prefs: []
  type: TYPE_NORMAL
- en: Our code sample isn't complete, and wouldn't amount to more than a one minute
    demo. But the concept is sound. By capturing the steps we plan to execute in our
    demo in a runnable form, our management demo should go off without a hitch.
  prefs: []
  type: TYPE_NORMAL
- en: Did I say without a hitch? Well, demos rarely work that well. Doesn't something
    about management appearances cause things to break? At one time, I began prepping
    for a senior management demo a month in advance using this recipe. I uncovered
    and subsequently fixed several bugs, such that my demo worked flawlessly. Management
    was impressed. I'm not making any promises here, but sincerely making your demo
    100% runnable will greatly increase your odds.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the secret to this recipe? It seems to be a bit short on code. While
    it's important to make the demo 100 percent runnable, the key is then printing
    out the test and using it like a script. That way, the only steps you are taking
    have already been proven to work.
  prefs: []
  type: TYPE_NORMAL
- en: What if my manager likes to take detours?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your manager likes to ask lots of what-if questions that pull you off-script,
    then you are sailing into uncharted territory. Your odds for a successful demo
    may drop quickly.
  prefs: []
  type: TYPE_NORMAL
- en: You can politely dodge this by capturing their what-ifs for a future demo and
    try to keep the current one on track. If you take the plunge to try other things
    out, realize the risk you are taking.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t be afraid to promise a future demo where you will travel down the path
    requested instead of risking it in this demo. Managers are actually pretty open
    to accepting a response such as: *I haven''t tested that yet. How about another
    demo next month where we cover that?* Failed demos leave a bad taste in the mouth
    of management and put your reputation in jeopardy. Successful ones have an equally
    positive effect on your reputation as a developer. Management tends to have a
    more optimistic view of seeing 70% of the system succeed 100% rather than 100%
    of the system succeed 70%.'
  prefs: []
  type: TYPE_NORMAL
- en: This is where the line between engineer and manager needs to be observed. While
    managers want to see what's available, it is our job to show them what is currently
    working and give an accurate status on what is and isn't available. Asking to
    see something we haven't tested yet definitely warrants pushing back and telling
    them such a demo isn't ready yet.
  prefs: []
  type: TYPE_NORMAL
