- en: Chapter 2. HTML5 Typography
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our environment set up, we're ready to take a deep dive into
    the actual code behind HTML5\. This is where the book begins to take off, since
    no matter how much theory you learn, it's very difficult to master a programming
    language without some keyboard time.
  prefs: []
  type: TYPE_NORMAL
- en: The game we'll be developing in this chapter will be a typing game, with some
    emphasis in the typography aspect of it. Again, I remind you that the focus of
    this book is not to teach game development, but rather to teach you all about
    HTML5\. Thus, the general approach we'll take to coding the games will not necessarily
    be most optimal for general game development, although all of the games covered
    in the book will perform fairly well in most major browsers.
  prefs: []
  type: TYPE_NORMAL
- en: The game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For lack of creativity, and to steer away from a possible lawsuit from a grumpy
    game company, we'll name this first game simply `Typography Game`. I know, that's
    not the most impressive game you've heard of, but at least it does a great job
    of explaining what the game is generally about.
  prefs: []
  type: TYPE_NORMAL
- en: 'The overall storyline for the game, as well as its general point, goes as follows:
    correctly type a phrase that is shown to you word-by-word, and win your dream
    boat. If you don''t type each character correctly and fast enough then **Snooty
    McSnootington** wins the boat and you lose the game skills.'
  prefs: []
  type: TYPE_NORMAL
- en: '![The game](img/6029OT_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It's hard to convey all the details about this user interface from a single
    screenshot, but the waves in that beautiful ocean are actually very smoothly animated,
    as well as the boat, which floats freely and is tossed about by the waves. Also,
    although there are exactly six images in the entire game, all of the components
    used in this game are DOM elements. The boat, the waves, and the characters are
    done using divs, images, and other semantic HTML5 elements. All of the animations
    are done using native CSS3 features.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the chapter will list all of the HTML, CSS, and JavaScript features
    used in the game, show examples of how to use them, and how they were used in
    the game. The coding style used is geared towards simplicity, so don't mind the
    global variables, the inconsistent use of object oriented principles, and the
    overall rudimentary graphics. With the basic HTML5 concepts in place, you can
    take the game to the next level by applying whatever additional improvements you
    may feel are necessary to make the game more polished or scalable from a development
    perspective.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll organize the game into three separate files: an `index.html` file, where
    we''ll host all of the HTML structures and bring together the other two files,
    namely a CSS file and a JavaScript file. This should be a pretty standard file
    structure but feel free to adjust things to best fit your needs and habits.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the file structure convention we created last chapter when we built
    our web portal, we''ll need to create a directory inside the root directory of
    our project, and call it typography. Inside this directory, we''ll create the
    following files and directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`packt/typography`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`packt/typography/index.html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`packt/typography/fonts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`packt/typography/css`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`packt/typography/css/style.css`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`packt/typography/js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`packt/typography/main.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`packt/typography/img`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I'll walk you through the process of finding and downloading custom fonts, when
    we get to that section later in the chapter. As for the images, you can draw or
    buy your own, or download the same ones I drew for the game from the website `http://www.CHANGE-THIS-FOR-A-REAL-WEBSITE`.
  prefs: []
  type: TYPE_NORMAL
- en: Game elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There were nine HTML5 elements used in this game. Each will be explained within
    its main category of either HTML, CSS, or JavaScript. The game itself is composed
    of roughly 15 elements, as depicted in the illustrations as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Game elements](img/6029OT_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The main game screen, with a subtle options widget as part of it.
  prefs: []
  type: TYPE_NORMAL
- en: After a game is finished, whether or not the player wins the game, a score board
    is shown, where the player is given the opportunity to enter his or her name as
    well as start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: '![Game elements](img/6029OT_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows a messaging widget to indicate that the player
    has won or lost, as well as a leaderboard widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for us to easily identify each of the major visual game components,
    we''ll list them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The options widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This widget allows the player to select a preset difficulty level. Selecting
    a harder difficulty level will make the enemy move faster across his track towards
    the boat. Additionally, we could have made it so that the phrases that the player
    would need to type would be harder or easier based on the difficulty setting.
    However, we have left this implementation detail as an exercise to the reader.
  prefs: []
  type: TYPE_NORMAL
- en: The game title
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This text based widget simply displays the main title of the game. Note that
    the type face used there is pure text (no images), using a custom web font. Its
    only purpose is to decorate the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Boat
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This animated widget serves the purpose of strengthening the user interface
    by helping to tell the story of the game. The boat is a simple HTML element (`div`),
    with a background image representing the boat. The animated path that the boat
    follows is done strictly in CSS, and is managed completely by the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Sky
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section of HTML is used to encapsulate all the elements located on the
    top half of the user interface, as well as to make it possible to animate the
    sky. As the game goes on, the color of the sky changes subtly, so as to emulate
    the setting and rising of the sun.
  prefs: []
  type: TYPE_NORMAL
- en: Waves
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a section of HTML classed as *ocean*, which is a section that encapsulates
    the area where the waves are stored. Each wave (there are two in use in this case)
    is a `div` element with a width of 100 percent, and a background image that represents
    the wave. This background image is repeated throughout the entire width of the
    `div` element, and is animated through CSS in order to give the illusion of motion,
    following a pattern of waves in the ocean.
  prefs: []
  type: TYPE_NORMAL
- en: Tracks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This widget is a section of HTML that encapsulates the individual track widgets,
    along with the player that uses that track.
  prefs: []
  type: TYPE_NORMAL
- en: Players
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each of those icons represent the individual players in this game. To keep
    things as simple as possible, there are only two players in the game: you (the
    hero), and Mr. Snooty McSnootington (the enemy). Additionally, we could have very
    easily added functionality to the options widget to allow the player to choose
    specific icons for both, the hero and the enemy, since the code that controls
    what icons are used is a simple CSS class that can be added to or removed from
    the icon objects.'
  prefs: []
  type: TYPE_NORMAL
- en: The main container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section of HTML holds the elements that control the game, which is everything
    below the sky widget.
  prefs: []
  type: TYPE_NORMAL
- en: Words to write
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here is where we display the words that the user must type when the game starts.
    Behind the scenes, this is a simple block-level HTML element, whose only purpose
    is just to display a few words.
  prefs: []
  type: TYPE_NORMAL
- en: Words written
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although, this widget is identical to the words to write widget (with slightly
    different styling, of course), this widget is a bit more dynamic, as it will respond
    to user actions. When a user presses a key on the keyboard, that input will be
    displayed there. If the character typed matches the expected character based on
    whatever is shown in the Words to write widget, then the character is displayed
    in white. If the character is incorrect, it'll be displayed in red, with a line
    through it, indicating very strongly that a mistake was made. The user can use
    the *Backspace* key to delete any or all characters displayed in this widget.
    As each correct character is typed in, the hero will move to the right proportionally
    to the percentage of characters entered, relative to the total amount to be typed.
  prefs: []
  type: TYPE_NORMAL
- en: The message container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section of HTML is displayed atop a semitransparent element to give the
    appearance of an overlay box. The widget is primarily meant to be a generic communication
    tool, through which we can inform the player of events, such as letting them know
    that the game is over, or that he or she won or lost the game. Additionally, we
    have added four other elements to it in order to make the game more engaging.
  prefs: []
  type: TYPE_NORMAL
- en: The message title
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Very similar in styling and purpose to main game title widget, this element
    simply notifies the user of the contents of the rest of the message container
    widget.
  prefs: []
  type: TYPE_NORMAL
- en: The new champion form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea behind this form is to simulate those old-school leaderboards used
    in old arcade games. Once you win a game against Mr. Snooty McSnootington, you
    are given the opportunity to enter your name and e-mail address to be shown in
    the leaderboard as in the following screenshot. Of course, that information is
    symbolic, and only serves the purpose of illustrating how we can use HTML5's web
    forms. The information generated by the form is not saved anywhere, and thus,
    it goes away after each page refresh (or when the game is closed or navigated
    away from). Again, it would be a trivial task to either email the contents of
    that form, save it to a backend server, or even stored it locally in the browser,
    through any one of the many persistence or storage APIs that we'll discuss in
    [Chapter 4](ch04.html "Chapter 4. Using HTML5 to Catch a Snake"), *Using HTML5
    to Catch a snake*, later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Leaderboard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any data entered in the new champion form (provided that the data entered is
    valid) is displayed here. The number next to each name simply shows the order
    that each name was entered. The asterisk to the right of the name indicates the
    difficulty level that the game was played (level 1—easy; in this particular case).
    For a more engaging experience, we could have kept track of how long it took the
    player to complete the game, how many mistakes were made, or somehow calculate
    an overall score and display it here. The reason we chose a full name and an email
    address was to show how to perform form validation in HTML5\. This alone is probably
    the most powerful and exciting feature of HTML5 used in this game. What used to
    take developers hundreds of lines of code, and often lots of repeated code, now
    only takes a couple of HTML attributes that the browser enforces.
  prefs: []
  type: TYPE_NORMAL
- en: Game controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, the message container widget includes controls that allows the player
    to start a new game.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to make the code more concise and easier to explain, we'll be aiming
    at less portable code, where the only requirement will be that the code runs properly
    in at least one browser.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the APIs used are indeed very portable (meaning that the code executes
    the same in most major browsers), but certainly not all of it, especially any
    experimental CSS APIs that require vendor prefixes. For maximum compatibility
    with the following examples, I recommend you use the latest version of Google
    **Chrome** or Google **Chromium**, or at least any webkit-based browser, such
    as Apple Safari.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this approach, first and foremost, is to simplify the teaching
    process. There's no need to explain a given feature, then show code example that
    is 99 percent identical, but differs only in the first part of the feature name,
    which is the vendor name. The reasoning behind selecting webkit as the browser
    engine of choice is also very simple; we had to choose something, so why not webkit?
    Besides, Google Chrome and Apple Safari have great market penetration, as well
    as an incredible set of tools to help us in the development process (such as Google
    Chrome's Developer Tools).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the *nine* HTML5 elements used in the game, along with their corresponding
    category:'
  prefs: []
  type: TYPE_NORMAL
- en: HTML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both of the HTML features used in this game can be used in JavaScript or by
    the browser directly. The web form elements and attributes add great functionality
    to the browser out of the box, while the data attributes are more meaningful when
    tied to the JavaScript. In the game of our `Typography Game`, we have built these
    elements within a context that made sense, but we could certainly have used other
    techniques (such as storing the data represented by the data attributes strictly
    in code), or used the elements and attributes we did use in different ways.
  prefs: []
  type: TYPE_NORMAL
- en: The web form
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The new form API added in HTML5 is one of the most visible additions to the
    language. With it you have access to 13 new input types, as well as countless
    new attributes that make form development fast, fun, and fascinating. Most of
    the additions will probably look familiar to you visually, since the effects that
    they add natively to the browser had already been done for a long time. These
    effects include things such as placeholder text, form validation, auto focusing
    fields, and so on so forth.
  prefs: []
  type: TYPE_NORMAL
- en: Two of the 13 new input types were used in the game, along with a handful of
    attributes for each of them, including form validation and field placeholders.
    Following is a brief explanation of how these elements were used in the game.
    An in-depth discussion of how they work and how to use them is found the the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Range input
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The new range input type is a slider that allows the user to select a value
    by moving the slider horizontally. In the game, we used the range input as a means
    to select a difficulty level. The range specified in this game is from 1 to 3,
    with 1 being the easiest difficulty level and 3 being the toughest.
  prefs: []
  type: TYPE_NORMAL
- en: '![Range input](img/6029OT_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The container that holds the input type range uses CSS to toggle the options
    menu and fade it out when not in use.
  prefs: []
  type: TYPE_NORMAL
- en: Email input
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The email input type looks exactly the same as the old text input type, but
    with a few benefits. First, when used in a mobile device, the input type hints
    to the operating system what kind of information it expects, in which case the
    operating system can display a special keyboard to the user. For example, if the
    user attempts to enter data into a number input type, where only numbers are allowed,
    a mobile operating system can display a keyboard that only has numbers. In the
    case of the email type, the keyboard displayed is normally one that includes the
    **@** symbol which makes it easier and more convenient for the user to enter the
    information into the web form.
  prefs: []
  type: TYPE_NORMAL
- en: The second benefit of using the email input type, which is also a benefit to
    desktop users, is that the browser itself can validate the data entered by the
    user. If the field is set to be validated and the data in the field does not match
    the basic format of an email address, the browser will tell the user that there
    is a problem and the form will not be submitted.
  prefs: []
  type: TYPE_NORMAL
- en: In the game, we use this feature whenever a player wins, by asking the user
    to enter his or her full name and email address. That information is used in a
    leaderboard, like you have probably seen in older games. While the user is not
    forced to enter any of the information asked for in the form, if the user does
    choose to input any information the data will be validated automatically by the
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: The exciting thing about automatic form validation is that you can customize
    your form through the HTML attributes included, making only required fields validated,
    what the error message says, and so on so forth. Also, even if the user disables
    JavaScript functionality in the browser the form will still be validated and handled
    by the browser. Of course, as you well know, one of the main rules about taking
    input from the user is that you should never trust the user and always validate
    and sanitize any, and all user input in the server as well.
  prefs: []
  type: TYPE_NORMAL
- en: '![Email input](img/6029OT_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If no data is entered or is in the wrong format, the browser will tell you about
    it and keep the form from being submitted.
  prefs: []
  type: TYPE_NORMAL
- en: Data attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As part of the effort, for more semantic document structure, HTML5 allows us
    to create our own, custom element attributes. Before HTML5, most browsers simply
    ignored element attributes that it did not understand (for example, a custom attribute
    made specially for one's application) but the downsides to this practice included
    the fact that the document could not be validated, the behavior was somewhat unpredictable,
    and there was a chance that a new release of the language introduced attributes
    of the same name, thus making your old custom attributes invalid. Now, we can
    safely create custom attributes for elements and none of the downsides just mentioned
    would apply.
  prefs: []
  type: TYPE_NORMAL
- en: In our game, we used data attributes to do two things, namely to specify the
    minimum speed that a player can move across the track and to specify that a generic
    button should trigger a new game (so that any button with that data attribute
    did not need any extra logic within JavaScript in order to act like a special
    button).
  prefs: []
  type: TYPE_NORMAL
- en: CSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since this game was intended to show off the more visual aspects of HTML5, we
    focused most of our efforts in making the interface of the game a real eye-candy.
    Since CSS is all about that visual presentation, most of the featured employed
    fall under this category.
  prefs: []
  type: TYPE_NORMAL
- en: Web fonts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Prior to HTML5's ability to handle custom fonts, web designers and developers
    were limited to a handful of type faces that could be used in a website or web
    application. Over time, there were a few solutions developed to solve this problem,
    but none were particularly impressive and most (if not all) broke some of the
    browser's functionality. For example, one common technique to display custom text
    involved the use of JavaScript to dynamically replace each character in a string
    with an actual image of that character using the custom font. The problems with
    this approach included the fact that one needed to create and manage all of those
    images. The user had to download all of those images, and worst of all, the resulting
    text could not be selected, copied, resized, and the color could not be changed.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can simply specify the name of a font, along with the actual font file,
    which the browser can download if the user's operating system doesn't have that
    font installed and use just as any other font.
  prefs: []
  type: TYPE_NORMAL
- en: In the game, we use three different custom fonts to create just the right visual
    effect and make the texts in the game match the desired visual theme. The three
    fonts used are open source fonts, which can be downloaded from the internet and
    used for free. The fonts used were Lemon, Mystery Quest, and Fredericka the Great.
    Amazing names, don't you agree?
  prefs: []
  type: TYPE_NORMAL
- en: '![Web fonts](img/6029OT_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Prior to looking for some fonts for the game, I had no idea that these fonts
    existed. Best of all, it only took me a couple of minutes to go through a large
    collection of open source fonts (from Google's Web Fonts tool) and find just what
    I wanted.
  prefs: []
  type: TYPE_NORMAL
- en: Since a font file is an external asset just like anything else that is downloaded
    from the server, there is a period of time between the time the browser starts
    downloading a font file and the time when the page is ready to be rendered. Different
    browsers handle this situation differently. For example, webkit hides the text
    until the font asset is ready. Other browsers may render the text with a fallback
    or default font until the web font file is ready, then swap the fonts and re-render
    the text.
  prefs: []
  type: TYPE_NORMAL
- en: Transitions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A CSS transition attribute tells the browser what attributes it applies to and
    how long the transition should last. Once those properties change, the browser
    will interpolate the beginning and end states and generate a very smooth transition
    for the duration specified. Of course, this can only be applied to attributes
    represented by some numerical value, such as font size, background color (represented
    by either an RGB or HSL value, or a hexadecimal number, all of which can be converted
    to percentages), element position, and so on. Values that do not get smoothly
    interpolated in CSS transitions include font-family, background images, or any
    other attribute that don't have in-between values, such as display block and display
    none.
  prefs: []
  type: TYPE_NORMAL
- en: In the game, the only uses of transition were with the options menu, the message
    container, and in moving the players across the tracks. The options menu is set
    to be pushed off the left side of the screen and the main icon that represents
    it is 75 percent transparency. Once the user hovers the mouse over that icon,
    it transitions to zero percent transparency (fully visible) and the rest of the
    menu transitions onto its left side to move to the right until its left edge snaps
    to the left edge of the browser.
  prefs: []
  type: TYPE_NORMAL
- en: The message container uses a similar effect, and that it is always positioned
    at the top of the screen, its width being 100 percent the window viewport and
    its height is set to zero by default (when the container is `closed`). When we
    want to display a message to the user, add the CSS class `open` to the container
    widget which sets the container's height to 100 percent, thus triggering a smooth
    transition that simulates a slide-in effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we used transitions to move the players from right to left within
    the tracks to which they are each bound. This was a very easy task to accomplish,
    even though the hero and the enemy are controlled slightly different. The way
    the enemy moves is simple: at every tick of the game timer we increment the enemy''s
    horizontal position (by changing its left style attribute) by whatever value is
    set in its data-speed data attribute. The smooth transition between the two points
    is handled by the browser. The way the hero moves is similar, with the exception
    that the data-speed is always set to zero (otherwise it''d be moving automatically
    without the user having to type anything) and at each key press we check whether
    the character typed in was what was expected, in which case we advance the hero
    a percentage of the way to the end of the track, which is relative to the percentage
    of characters typed in properly and relative to the total amount of characters.
    For example, if the user correctly typed in the tenth character of a phrase that
    has 100 characters, then we move the hero 10 percent of the way across its track.
    Both, the hero and the enemy, have checks in place so that they can''t be moved
    beyond the width of their respective tracks.'
  prefs: []
  type: TYPE_NORMAL
- en: Animations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Probably the most powerful feature of CSS3, the animation attribute, allows
    for named keyframe animation very similar to the formerly popular Adobe Flash.
    The way it works is incredibly simple: you create an animation sequence, give
    it a name, and specify one or more CSS attributes to be applied at each keyframe.
    Each keyframe represents a moment in time when those attributes should be added
    to whatever element you associate with that animation sequence. Then, every moment
    in time between two keyframes are smoothly interpolated by the browser and the
    illusion of animation is achieved.'
  prefs: []
  type: TYPE_NORMAL
- en: In the game, we use animations to give life to the ocean waves, to move the
    boat in its path, and to make the sky fade darker and lighter with the passing
    of time, thus simulating the rising and setting of the sun. Although this may
    seem like a complicated task, animating elements is so easy that the main limitation
    you're likely to run into may be creativity. If you're somewhat familiar with
    CSS and how to use it to apply various styles to elements, then learning and using
    the animation API should be a natural next step.
  prefs: []
  type: TYPE_NORMAL
- en: '![Animations](img/6029OT_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each animated object was nothing more than a `div` element with a background
    image set to it. The waves' background image was set to repeat about the x axis,
    whereas the boat's background image was set to no-repeat. The boat's width and
    height was set to match the image it represented, whereas the waves had a different
    height set for each of them (the wave positioned behind everything was a bit taller
    so that it could be seen behind the other wave), but with a width of 100 percent,
    so that it always fills the width of the monitor viewing the app, no matter how
    wide that monitor is. At the end of this animation cycle, the objects follow that
    same path, but in reverse, making the animation seem continuous and always smooth.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest element to animate was the sky, since it only had two keyframes.
    At the first keyframe, the `div` element that represented the sky was set to have
    a light blue color for its background. The last keyframe changed that background
    color to a slightly darker blue. For a more dramatic effect, we could have had
    this last keyframe define a very dark color for the background. For an even more
    drastic effect representing this night fall, we could also have added another
    `div` on top of this sky element, with its background image being a transparent
    image with white dots scattered about it. Each dot would represent a star. Then,
    at the same pace that the sky gets darker, we set the opacity of this element
    to become more visible (less transparent), so that it animates from fully transparent
    to fully opaque. The final effect would be that as the sky gets darker, then stars
    would appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'The boat was animated with three keyframes: the first placed it at some position
    slightly above the waves, the second moved it to the right and up, and the third
    keyframe moved it significantly higher, and a bit to the left. The trick to making
    the animation between these points seem somewhat natural, and more like something
    would move on the ocean in real life, is to make the distance the object moves
    between two different keyframes different. For example, the horizontal distance
    the boat moves between the first and second keyframe is different than the horizontal
    displacement used between the second and third keyframes. The vertical displacement
    between those keyframes are even more drastic. If the distances were all the same,
    our eye would get used to the same familiar pattern of motion, and the animation
    would soon appear too repetitive and uninteresting.'
  prefs: []
  type: TYPE_NORMAL
- en: Animating the waves was equally easy. Although there were two sets of waves,
    they both use the same animation set. The only difference is that the set of waves
    positioned behind the other (the back wave) was set to move slower, so that it
    looked like it was farther away, and the animations didn't seem to be the same.
  prefs: []
  type: TYPE_NORMAL
- en: All that was animated in these wave elements (remember, a wave element is just
    a `div` with a repeating background image) was the position of the background
    image. The `div` elements themselves were always static and absolutely positioned
    atop each other. Since the elements were transparent wherever their background
    images were transparent, we were able to apply a background color to the element
    holding all three of these elements (both waves and the boat), which we set to
    be the sky element, which animated the background color.
  prefs: []
  type: TYPE_NORMAL
- en: Although the final result looks fun and slightly complex, the work required
    to put this sort of thing together is really no more complicated or difficult
    than setting up any other design using plain CSS, especially because this is nothing
    more than plain old CSS.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of this writing, there were a handful of tools aimed at helping
    developers create and manage keyframe animations. While many of these tools were
    free and many are completely cloud-based (written using HTML5 technologies), if
    you're looking for an enterprise level tool to help you build professional animations
    truly similar to what we're used to seeing with Adobe Flash, you'll need to invest
    in some cash in more advanced and fine tuned tools. Although some of these tools
    may not be the best option for a developer on a budget (or one with no budget
    at all), their quality and power are normally orders of magnitude beyond whatever
    any of the free tools can provide.
  prefs: []
  type: TYPE_NORMAL
- en: If you're only developing for fun, or for the learning experience, the plethora
    of free tools available online should be more than enough to get you going with
    CSS3 keyframe animations. However, if your goal is to build high-end applications
    and you need the high precision and control over the animations, then a professional
    tool might be well worth your investment.
  prefs: []
  type: TYPE_NORMAL
- en: One particularly popular free web-based CSS animation generator can be found
    at [http://www.css3maker.com/](http://www.css3maker.com/). On the other hand,
    Adobe makes a terrific product called Adobe Edge Animate, which can be purchased
    at [http://html.adobe.com/edge/animate/](http://html.adobe.com/edge/animate/).
  prefs: []
  type: TYPE_NORMAL
- en: The text shadows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This new text attribute in CSS allows you to simulate a shadow effect around
    text. Behind the scenes, what the browser really does is create a copy of the
    text that the shadow is being applied to, then displace it behind the original
    text based on the values you specify as the vertical and horizontal offset. You
    can also tell the browser how much to blur this "shadow" version of the text by
    specifying a values between zero and whatever integer value you desire. After
    a point, depending on the size of the original text, the blur is so high that
    the text is virtually invisible, so supplying very large numbers can be counter
    productive.
  prefs: []
  type: TYPE_NORMAL
- en: The only instance in the game where text shadow is used is in the message container's
    title. Since the rest of the user interface for the game used pretty flat graphics
    with very subtle or no gradients at all, I thought I'd use text shadows to add
    a solid, lighter shadow to give continuation to the theme of flat, single dimensional
    graphics.
  prefs: []
  type: TYPE_NORMAL
- en: '![The text shadows](img/6029OT_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The CSS3 text shadow API allows you to specify an arbitrary number of displaced
    and blurred copies of a text string.
  prefs: []
  type: TYPE_NORMAL
- en: The box shadows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to text shadows, box shadows place one or more boxes behind a particular
    element, with a vertical and horizontal offset specified as parameters, with a
    third parameter being the amount of blur to be applied to the shadow. You can
    specify solid colors or use the optional alpha channel in order to add varying
    levels of opacity to it. Alternatively, the shadow can be applied to the inside
    of the container to which it is bound. Note that any box shadow applied to elements,
    if they're placed behind the box, are placed outside the border, if one is available,
    ignoring any margin the element may have. Shadows placed inside an element are
    placed just inside the border, if one is present, ignoring any padding added to
    the element.
  prefs: []
  type: TYPE_NORMAL
- en: In the game, there are two instances of a CSS box shadow. One shows off the
    traditional shadow behind an element, and is applied to the message container.
    The other instance of box shadow in the game is applied to the tracks that hold
    each player. In this case, the shadow is intended to convey the effect that the
    tracks are pressed in into the page, which is done by using the attribute that
    places the shadow inside the box. If the shadow is placed outside the box, the
    effect given is that of the box being stacked over the page.
  prefs: []
  type: TYPE_NORMAL
- en: '![The box shadows](img/6029OT_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The white line on the bottom of each track is just a bottom border, but the
    same effect could have been accomplished by adding a second box shadow.
  prefs: []
  type: TYPE_NORMAL
- en: The border radius
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before the border radius property was available, the same effect it provides
    could be achieved by positioning images of rounded corners to the corners of elements.
    This was a tedious task to do and the final effect was rarely as impressive as
    intended. With the CSS3 border radius property, we can apply an arbitrary amount
    of roundness to one or more corners of a `container` element.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep in mind that, although it is possible to make a `container` element look
    completely round by specifying a border radius value to all four corners large
    enough proportional to each side's length, the element is still a rectangle to
    the browser. In other words, if you float two or more elements that have been
    made to look round through CSS, they will behave like rectangles and not circles.
  prefs: []
  type: TYPE_NORMAL
- en: The flow of elements and text in HTML5 is still rectangular based, although
    there are experimental APIs that allow us to specify arbitrary shapes through
    which text flows. For more information about these particular CSS APIs (called
    **regions** and **exclusions**), see [Chapter 6](ch06.html "Chapter 6. Adding
    Features to Your Game"), *Adding Features to Your Games*.
  prefs: []
  type: TYPE_NORMAL
- en: There was only one use of CSS border radius in the game, which was on the right
    side of the navigation options widget. The API allows us to specify which specific
    side to apply a border radius to, and to demonstrate this feature, only two of
    the four sides of the container were rounded.
  prefs: []
  type: TYPE_NORMAL
- en: The player icons could have been more HTML5-ish instead of just being a transparent
    image applied to the background of the element. One possibility could be to have
    each icon be a rectangular image, which we could apply to the background of the
    container representing each player, then we could have used border radius to make
    the element look completely circular. An optional box shadow could also have been
    added to create the same shadow effect achieved by the photo editing software
    used to create the images. One benefit of using this technique would be that the
    native effects would scale much better, meaning that if you zoom the page in or
    out, the image will eventually look distorted and pixelated, whereas any border
    radius, box shadow, or borders added to the element would always look smooth and
    fresh.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the logic that drives this game is fairly simple, and quite a bit limited,
    there is still a decent amount of JavaScript code in order to make the game work.
    Since we're trying to focus on HTML5 features, we'll only look at one particular
    API used in the code that can more or less be considered HTML5\. This is the **selectors
    API** , which was first drafted by the W3C back on May of 2006.
  prefs: []
  type: TYPE_NORMAL
- en: Query selectors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have been doing any web development at all in the last several years,
    you've certainly heard or, used, and have fallen in love with the popular JavaScript
    library jQuery. Among its many powerful features, one of jQuery's most useful
    tools is its amazing DOM selector API, which allows you to retrieve the DOM elements
    by simply using CSS selectors and pseudo selectors, as opposed to using the limited
    `document.getElementById()`, `document.getElementsByClassName()`, and `document.getElementsByName()`
    methods, among other equally limited ones.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that this powerful nodes selector API is now all native to
    modern browsers. Since the feature is native to the browser, it is much faster
    and more stable. Furthermore, since the feature is native to the browser, there
    is no need to import a library to handle the task.
  prefs: []
  type: TYPE_NORMAL
- en: This game, as well as all the others described in this book, uses the new selectors
    API level 1\. Since there are no visual elements that can be seen form query selectors,
    we'll deepen the discussion about its usage in the next section, where we'll also
    take a look at some code examples.
  prefs: []
  type: TYPE_NORMAL
- en: API usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've discussed what all of the game elements are and how each HTML5
    feature was used to fulfill that role, let's take a deeper look at how to make
    the most out of each of these APIs. For each of the following APIs, we'll provide
    a more concrete definition of the feature, what its intended use is, and a code
    example will follow. You may also refer to the complete source code attached at
    the end of the chapter in order to fill the gap between the code sample and how
    that feature fits in with the rest of the game code base. It is also recommended
    that you code along and play with the various settings and values in order to
    experiment with and more fully understand each API.
  prefs: []
  type: TYPE_NORMAL
- en: Web forms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The new HTML5 web forms API adds 13 new input types that allows for a much more
    flexible and powerful experience. What's more, web forms are also able to validate
    themselves requiring zero JavaScript intervention.
  prefs: []
  type: TYPE_NORMAL
- en: New input types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following are the new input types defined in the new web forms chapter
    of the HTML5 specification:'
  prefs: []
  type: TYPE_NORMAL
- en: Date
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The date input type allows the user to select a specific date from a browser-supplied
    calendar. The specific format and styling of this calendar is unique to the browser
    and platform used. The data that results from a date selection is of the form
    `YYYY-MM-DD`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The optional attributes `min` and `max` can be used to force validation of
    the date selected by the user to be within a given range. Other valid attributes
    for the `date` input type include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` (value must be a string): Identifies a particular field by the string
    value associated with the attribute'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`disabled` (acceptable values include `disabled`, `""`, or empty): Specifies
    that the element is disabled and cannot receive control'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autocomplete` (acceptable values include `on` or `off`): Specifies whether
    the browser should store values entered by the user, so inputting a stored value
    in the future can be automatically completed by the browser upon hint by user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autofocus` (acceptable values include `autofocus`, "", or empty): Specifies
    to the browser that the element must receive focus immediately after the document
    finishes loading'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min` (value must be a valid date in the form of "yyyy-mm-dd"): Specifies the
    lowest date allowed to be selected by the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max` (value must be a valid date in the form of "yyyy-mm-dd"): Specifies the
    highest date allowed to be selected by the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readonly` (acceptable values include `readonly`, `""`, or empty): Specifies
    that the value of this element cannot be changed by the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`step` (acceptable values include `any` or any positive integer): Specifies
    how the value attribute of the element is to change'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`required` (acceptable values include `required`, `""`, or empty): Specifies
    that this element must have a valid value in order for the form to be allowed
    to submit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value` (value must be a valid date in the form of "yyyy-mm-dd"): Specifies
    the actual date represented by this element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Month
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The month input type allows the user to select a specific month and year from
    a browser-supplied calendar. The specific format and styling of this calendar
    is unique to the browser and platform used. The data that results from a date
    selection is of the form `YYYY-MM`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Other valid attributes for the date input type include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` (value must be a string): Identifies a particular field by the string
    value associated with the attribute'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`disabled` (acceptable values include `disabled`, `""`, or empty): Specifies
    that the element is disabled and cannot receive control.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autocomplete` (acceptable values include `on` or `off`): Specifies whether
    the browser should store values entered by the user so inputting a stored value
    in the future can be automatically completed by the browser upon hint by user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autofocus` (acceptable values include `autofocus`, `""`, or empty): Specifies
    to the browser that the element must receive focus immediately after the document
    finishes loading'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min` (value must be a valid date in the form of "yyyy-mm"): Specifies the
    lowest date allowed to be selected by the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max` (value must be a valid date in the form of "yyyy-mm"): Specifies the
    highest date allowed to be selected by the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readonly` (acceptable values include `readonly`, `""`, or empty): Specifies
    that the value of this element cannot be changed by the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`step` (acceptable values include `any` or any positive integer): Specifies
    how the value attribute of the element is to change'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`required` (acceptable values include `required`, `""`, or empty): Specifies
    that this element must have a valid value in order for the form to be allowed
    to submit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value` (value must be a valid date in the form of "yyyy-mm"): Specifies the
    actual date represented by this element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Week
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The week input type allows the user to select a specific week of a year from
    a browser-supplied calendar. The specific format and styling of this calendar
    is unique to the browser and platform used. The data that results from a date
    selection is of the form `YYYY-Www` (for example, 2013-W05).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Other valid attributes for the date input type include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` (value must be a string): Identifies a particular field by the string
    value associated with the attribute'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`disabled` (acceptable values include `disabled`, `""`, or empty): Specifies
    that the element is disabled and cannot receive control'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autocomplete` (acceptable values include `on` or `off`): Specifies whether
    the browser should store values entered by the user so inputting a stored value
    in the future can be automatically completed by the browser upon hint by user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autofocus` (acceptable values include `autofocus`, `""`, or empty): Specifies
    to the browser that the element must receive focus immediately after the document
    finishes loading'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min` (value must be a valid date in the form of "yyyy-Www", where "ww" must
    be a two digit representation of the week number): Specifies the lowest date allowed
    to be selected by the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max` (value must be a valid date in the form of "yyyy-Www", where "ww" must
    be a two digit representation of the week number): Specifies the highest date
    allowed to be selected by the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readonly` (acceptable values include `readonly`, `""`, or empty): Specifies
    that the value of this element cannot be changed by the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`step` (acceptable values include `any` or any positive integer): Specifies
    how the value attribute of the element is to change'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`required` (acceptable values include `required`, `""`, or empty): Specifies
    that this element must have a valid value in order for the form to be allowed
    to submit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value` (value must be a valid date in the form of "yyyy-Www", where "ww" must
    be a two digit representation of the week number): Specifies the actual date represented
    by this element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The time input type allows the user to select a specific time of day. The data
    in this element is of the form `HH:MM:SS.Ms`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Other valid attributes for the date input type include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` (value must be a string): Identifies a particular field by the string
    value associated with the attribute'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`disabled` (acceptable values include `disabled`, `""`, or empty): Specifies
    that the element is disabled and cannot receive control'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autocomplete` (acceptable values include `on` or `off`): Specifies whether
    the browser should store values entered by the user so inputting a stored value
    in the future can be automatically completed by the browser upon hint by user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autofocus` (acceptable values include `autofocus`, `""`, or empty): Specifies
    to the browser that the element must receive focus immediately after the document
    finishes loading'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min` (value must be a valid partial time in the form of "HH:MM:SS.Mss", "HH:MM:SS",
    or "HH:MM"): Specifies the lowest date allowed to be selected by the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max` (value must be a valid partial time in the form of "HH:MM:SS.Mss", "HH:MM:SS",
    or "HH:MM"): Specifies the highest date allowed to be selected by the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readonly` (acceptable values include `readonly`, `""`, or empty): Specifies
    that the value of this element cannot be changed by the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`step` (acceptable values include `any` or any positive integer): Specifies
    how the value attribute of the element is to change'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`required` (acceptable values include `required`, `""`, or empty): Specifies
    that this element must have a valid value in order for the form to be allowed
    to submit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value` (value must be a valid partial time in the form of "HH:MM:SS.Mss",
    "HH:MM:SS", or "HH:MM"): Specifies the actual date represented by this element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Datetime
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The datetime input type allows the user to select a specific date and time (including
    time zone) from a browser-supplied calendar. The specific format and styling of
    this calendar is unique to the browser and platform used. The data that results
    from a date selection is of the form `YYYY-MM-DDTHH:MM:SS-UTC`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Other valid attributes for the date input type include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` (value must be a string): Identifies a particular field by the string
    value associated with the attribute'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`disabled` (acceptable values include `disabled`, `""`, or empty): Specifies
    that the element is disabled and cannot receive control'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autocomplete` (acceptable values include `on` or `off`): Specifies whether
    the browser should store values entered by the user so inputting a stored value
    in the future can be automatically completed by the browser upon hint by user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autofocus` (acceptable values include `autofocus`, `""`, or empty): Specifies
    to the browser that the element must receive focus immediately after the document
    finishes loading'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min` (value must be a valid date time, as defined in the RFC 3339): Specifies
    the lowest date allowed to be selected by the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max` (value must be a valid date time, as defined in the RFC 3339): Specifies
    the highest date allowed to be selected by the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readonly` (acceptable values include `readonly`, `""`, or empty): Specifies
    that the value of this element cannot be changed by the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`step` (acceptable values include `any` or any positive integer): Specifies
    how the value attribute of the element is to change'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`required` (acceptable values include `required`, `""`, or empty): Specifies
    that this element must have a valid value in order for the form to be allowed
    to submit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value` (value must be a valid date time, as defined in the RFC 3339): Specifies
    the actual date represented by this element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Datetime-local
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The datetime-local input type allows the user to select a specific date and
    time (not including time zone) from a browser-supplied calendar. The specific
    format and styling of this calendar is unique to the browser and platform used.
    The data that results from a date selection is of the form `YYYY-MM-DDTHH:MM:SS`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Other valid attributes for the date input type include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` (value must be a string): Identifies a particular field by the string
    value associated with the attribute'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`disabled` (acceptable values include `disabled`, `""`, or empty): Specifies
    that the element is disabled and cannot receive control'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autocomplete` (acceptable values include `on` or `off`): Specifies whether
    the browser should store values entered by the user so inputting a stored value
    in the future can be automatically completed by the browser upon hint by user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autofocus` (acceptable values include `autofocus`, `""`, or empty): Specifies
    to the browser that the element must receive focus immediately after the document
    finishes loading'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min` (value must be a valid partial time in the form of "YYYY-MM-DDTHH:MM:SS.Mss",
    "YYYY-MM-DDTHH:MM:SS", or "YYYY-MM-DDTHH:MM"): Specifies the lowest date allowed
    to be selected by the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max` (value must be a valid partial time in the form of "YYYY-MM-DDTHH:MM:SS.Mss",
    "YYYY-MM-DDTHH:MM:SS", or "YYYY-MM-DDTHH:MM"): Specifies the highest date allowed
    to be selected by the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readonly` (acceptable values include `readonly`, `""`, or empty): Specifies
    that the value of this element cannot be changed by the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`step` (acceptable values include `any` or any positive integer): Specifies
    how the value attribute of the element is to change'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`required` (acceptable values include `required`, `""`, or empty): Specifies
    that this element must have a valid value in order for the form to be allowed
    to submit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value` (value must be a valid partial time in the form of "YYYY-MM-DDTHH:MM:SS.Mss",
    "YYYY-MM-DDTHH:MM:SS", or "YYYY-MM-DDTHH:MM"): Specifies the actual date represented
    by this element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Color
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The color input type allows the user to select a specific color from a browser-supplied
    color picker. The specific format and styling of this color picker widget is unique
    to the browser and platform used. Although some implementations of the widget
    may provide values in different format (RGB or HSL), the data that results from
    a color selection is a hexadecimal representation of the color in the form `#RRGGBB`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Other valid attributes for the date input type include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` (value must be a string): Identifies a particular field by the string
    value associated with the attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`disabled` (acceptable values include `disabled`, `""`, or empty): Specifies
    that the element is disabled and cannot receive control.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autocomplete` (acceptable values include `on` or `off`): Specifies whether
    the browser should store values entered by the user so inputting a stored value
    in the future can be automatically completed by the browser upon hint by user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autofocus` (acceptable values include `autofocus`, `""`, or empty): Specifies
    to the browser that the element must receive focus immediately after the document
    finishes loading.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value` (value must be a valid hexadecimal color with exactly seven characters
    in length and of the form "#rrggbb" or "#RRGGBB"): Specifies the actual color
    represented by this element. Keywords, such as Color, are not allowed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Email
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The email input type allows the user to input an e-mail address. In mobile devices
    where a digital keyboard is provided for data entry, this input type hints to
    the system that the keyboard to be provided should be the most appropriate for
    entering an e-mail address.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Other valid attributes for the date input type include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` (value must be a string): Identifies a particular field by the string
    value associated with the attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`disabled` (acceptable values include `disabled`, `""`, or empty): Specifies
    that the element is disabled and cannot receive control.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autocomplete` (acceptable values include `on` or `off`): Specifies whether
    the browser should store values entered by the user so inputting a stored value
    in the future can be automatically completed by the browser upon hint by user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autofocus` (acceptable values include `autofocus`, `""`, or empty): Specifies
    to the browser that the element must receive focus immediately after the document
    finishes loading.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxlength` (value must be a non-negative integer): Specifies the maximum length
    of characters that the element can contain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pattern` (value must be a valid regular expression pattern as defined by ECMA
    262): Specifies a pattern that the browser must validate the specified input against.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size` (value must be a positive integer): Specifies the maximum number of
    characters displayed by the element, although more characters may be allowed to
    be entered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`placeholder` (value must be a string): Specifies a string to be shown to the
    user as a hint as to what information the field expects. This string disappears
    when data is entered into the field and is shown when the field becomes empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`multiple` (acceptable values include `multiple`, `""`, or empty): Specifies
    that multiple values are allowed in this element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readonly` (acceptable values include `readonly`, `""`, or empty): Specifies
    that the value of this element cannot be changed by the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`required` (acceptable values include `required`, `""`, or empty): Specifies
    that this element must have a valid value in order for the form to be allowed
    to submit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value` (value must be a valid e-mail address and must adhere to any further
    restrictions specified by the pattern attribute, if any): Specifies the actual
    e-mail address represented by this element or a comma-separated list of valid
    e-mail addresses when the multiple attribute is present.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For those not familiar with JavaScript''s regular expression language, or who
    need a refresher, following is a summary of the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[rodig]` (brackets): used to match anything found within the brackets. For
    example: match any one of the letters within the brackets.'
  prefs: []
  type: TYPE_NORMAL
- en: '`[^rodig]` (negative brackets): Used to match anything not found within the
    brackets. For example, match any character except one of the letters within the
    brackets.'
  prefs: []
  type: TYPE_NORMAL
- en: '`[D-M]` (range): Used to match a range of characters or numbers. For example,
    match any characters between the capital letters D and M.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(me|you|us)` (pipe): Used to match alternative options. For example, match
    either of the words within the parenthesis.'
  prefs: []
  type: TYPE_NORMAL
- en: '`.` (period): Match any characters, expect for a new line character or a line
    terminator character.'
  prefs: []
  type: TYPE_NORMAL
- en: '`\w` (word character): Match any letter, number, or an underscore.'
  prefs: []
  type: TYPE_NORMAL
- en: '`\W` (non-word character): Match any character that is not a word characters.'
  prefs: []
  type: TYPE_NORMAL
- en: '`\d` (digit): Match any single digit.'
  prefs: []
  type: TYPE_NORMAL
- en: '`\D` (non-digit): Match any non-digit character.'
  prefs: []
  type: TYPE_NORMAL
- en: '`\s` (space): Match a white space.'
  prefs: []
  type: TYPE_NORMAL
- en: '`\S` (non-space): Match any character that''s not a space character.'
  prefs: []
  type: TYPE_NORMAL
- en: '`\b` (word boundary): Find a match at the beginning or end of a word.'
  prefs: []
  type: TYPE_NORMAL
- en: '`\B` (non-word boundary): Find a match that is not a word boundary.'
  prefs: []
  type: TYPE_NORMAL
- en: '`\0` (null character): Matches the NULL character in a string.'
  prefs: []
  type: TYPE_NORMAL
- en: '`\n` (new line character): Matches the new line character.'
  prefs: []
  type: TYPE_NORMAL
- en: '`\f` (form feed character): Matches the form feed character.'
  prefs: []
  type: TYPE_NORMAL
- en: '`\r` (return carriage character): Matches the form carriage character.'
  prefs: []
  type: TYPE_NORMAL
- en: '`\t` (tab character): Matches the tab character.'
  prefs: []
  type: TYPE_NORMAL
- en: '`\v` (vertical tab): Matches a vertical tab character.'
  prefs: []
  type: TYPE_NORMAL
- en: '`+` (plus quantifier): Matches the previous expression or character one or
    more times.'
  prefs: []
  type: TYPE_NORMAL
- en: '`*` (star quantifier): Matches the previous expression or character zero or
    more times.'
  prefs: []
  type: TYPE_NORMAL
- en: '`?` (question mark quantifier): Matches the previous expression or character
    zero or one time.'
  prefs: []
  type: TYPE_NORMAL
- en: '`{3,5}` (bracket quantifier): Matches the previous expression a minimum and
    maximum of times respectively. If the maximum digit is missing, the matches will
    continue until a non-match is found. For example: \d{1,} matches one or more digits.'
  prefs: []
  type: TYPE_NORMAL
- en: '`^` (hat modifier): Matches an expression at the beginning of a string.'
  prefs: []
  type: TYPE_NORMAL
- en: '`$` (dollar modifier): Matches an expression at the end of a string.'
  prefs: []
  type: TYPE_NORMAL
- en: Number
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The number input type allows the user to select number from any mechanism provided
    by the browser or to simply enter a numerical value if only a standard input field
    is provided by the browser. The value is validated by the browser to ensure that
    a number is indeed entered by the user. In mobile devices, where a digital keyboard
    is provided for data entry, this input type hints to the system that the keyboard
    to be provided should be the most appropriate for entering numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Other valid attributes for the date input type include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` (value must be a string): Identifies a particular field by the string
    value associated with the attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`disabled` (acceptable values include `disabled`, `""`, or empty): Specifies
    that the element is disabled and cannot receive control.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autocomplete` (acceptable values include `on` or `off`): Specifies whether
    the browser should store values entered by the user so inputting a stored value
    in the future can be automatically completed by the browser upon hint by user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autofocus` (acceptable values include `autofocus`, `""`, or empty): Specifies
    to the browser that the element must receive focus immediately after the document
    finishes loading.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min` (value must be a floating point number): Specifies the lowest number
    allowed to be selected by the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max` (value must be a floating point number): Specifies the highest number
    allowed to be selected by the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readonly` (acceptable values include `readonly`, `""`, or empty): Specifies
    that the value of this element cannot be changed by the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`placeholder` (value must be a string): Specifies a string to be shown to the
    user as a hint as to what information the field expects. This string disappears
    when data is entered into the field and is shown when the field becomes empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`step` (acceptable values include `any` or any positive integer): Specifies
    how the value attribute of the element is to change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`required` (acceptable values include `required`, `""`, or empty): Specifies
    that this element must have a valid value in order for the form to be allowed
    to submit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value` (value must be a floating point number): Specifies the actual floating
    point number represented by this element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Range
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The range input type allows the user to select a number from a specified range
    using a browser-supplied slider widget. The specific format and styling of this
    slider widget is unique to the browser and platform used. The data that results
    from a range selection is a floating point number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Other valid attributes for the date input type include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` (value must be a string): Identifies a particular field by the string
    value associated with the attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`disabled` (acceptable values include `disabled`, `""`, or empty): Specifies
    that the element is disabled and cannot receive control.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autocomplete` (acceptable values include `on` or `off`): Specifies whether
    the browser should store values entered by the user so inputting a stored value
    in the future can be automatically completed by the browser upon hint by user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autofocus` (acceptable values include `autofocus`, `""`, or empty): Specifies
    to the browser that the element must receive focus immediately after the document
    finishes loading.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min` (value must be a floating point number): Specifies the lowest number
    allowed to be selected by the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max` (value must be a floating point number): Specifies the highest number
    allowed to be selected by the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readonly` (acceptable values include `readonly`, `""`, or empty): Specifies
    that the value of this element cannot be changed by the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`placeholder` (value must be a string): Specifies a string to be shown to the
    user as a hint as to what information the field expects. This string disappears
    when data is entered into the field, and is shown when the field becomes empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`step` (acceptable values include `any` or any positive integer): Specifies
    how the value attribute of the element is to change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`required` (acceptable values include `required`, `""`, or empty): Specifies
    that this element must have a valid value in order for the form to be allowed
    to submit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value` (value must be a floating point number): Specifies the actual floating
    point number represented by this element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The search input type allows the user to enter a string intended for a search.
    Overall, the search input type looks and behaves very much like a regular text
    input type. Some browsers might add miscellaneous behavior to this field, such
    as built-in icons or widgets to instantly clear the field, but none of these are
    officially part of the specification.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Other valid attributes for the date input type include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` (value must be a string): Identifies a particular field by the string
    value associated with the attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`disabled` (acceptable values include `disabled`, `""`, or empty): Specifies
    that the element is disabled, and cannot receive control.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autocomplete` (acceptable values include `on` or `off`): Specifies whether
    the browser should store values entered by the user so inputting a stored value
    in the future can be automatically completed by the browser upon hint by user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autofocus` (acceptable values include `autofocus`, `""`, or empty): Specifies
    to the browser that the element must receive focus immediately after the document
    finishes loading.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxlength` (value must be a non-negative integer): Specifies the maximum length
    of characters that the element can contain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pattern` (value must be a valid regular expression pattern as defined by ECMA
    262): Specifies a pattern that the browser must validate the specified input against.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size` (value must be a positive integer): Specifies the maximum number of
    characters displayed by the element although more characters may be allowed to
    be entered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`placeholder` (value must be a string): Specifies a string to be shown to the
    user as a hint as to what information the field expects. This string disappears
    when data is entered into the field and is shown when the field becomes empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`multiple` (acceptable values include `multiple`, `""`, or empty): Specifies
    that multiple values are allowed in this element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readonly` (acceptable values include `readonly`, `""`, or empty): Specifies
    that the value of this element cannot be changed by the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`required` (acceptable values include `required`, `""`, or empty): Specifies
    that this element must have a valid value in order for the form to be allowed
    to submit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value` (value must be a string with no line feed or carriage return character):
    Specifies the actual search query represented by this element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tel
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The tel input type allows the user to enter a telephone number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Other valid attributes for the date input type include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` (value must be a string): Identifies a particular field by the string
    value associated with the attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`disabled` (acceptable values include `disabled`, `""`, or empty): Specifies
    that the element is disabled and cannot receive control.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autocomplete` (acceptable values include `on` or `off`): Specifies whether
    the browser should store values entered by the user so inputting a stored value
    in the future can be automatically completed by the browser upon hint by user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autofocus` (acceptable values include `autofocus`, `""`, or empty): Specifies
    to the browser that the element must receive focus immediately after the document
    finishes loading.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxlength` (value must be a non-negative integer): Specifies the maximum length
    of characters that the element can contain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pattern` (value must be a valid regular expression pattern as defined by ECMA
    262): Specifies a pattern that the browser must validate the specified input against.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size` (value must be a positive integer): Specifies the maximum number of
    characters displayed by the element although more characters may be allowed to
    be entered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`placeholder` (value must be a string): Specifies a string to be shown to the
    user as a hint as to what information the field expects. This string disappears
    when data is entered into the field and is shown when the field becomes empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`multiple` (acceptable values include `multiple`, `""`, or empty): Specifies
    that multiple values are allowed in this element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readonly` (acceptable values include `readonly`, `""`, or empty): Specifies
    that the value of this element cannot be changed by the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`required` (acceptable values include `required`, `""`, or empty): Specifies
    that this element must have a valid value in order for the form to be allowed
    to submit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value` (value must be a string with no line feed or carriage return character):
    Specifies the actual phone number represented by this element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Url
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The url input type allows the user to enter a website url.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Other valid attributes for the date input type include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` (value must be a string): Identifies a particular field by the string
    value associated with the attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`disabled` (acceptable values include `disabled`, `""`, or empty): Specifies
    that the element is disabled, and cannot receive control.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autocomplete` (acceptable values include `on` or `off`): Specifies whether
    the browser should store values entered by the user so inputting a stored value
    in the future can be automatically completed by the browser upon hint by user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autofocus` (acceptable values include `autofocus`, `""`, or empty): Specifies
    to the browser that the element must receive focus immediately after the document
    finishes loading.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxlength` (value must be a non-negative integer): Specifies the maximum length
    of characters that the element can contain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pattern` (value must be a valid regular expression pattern as defined by ECMA
    262): Specifies a pattern that the browser must validate the specified input against.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size` (value must be a positive integer): Specifies the maximum number of
    characters displayed by the element although more characters may be allowed to
    be entered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`placeholder` (value must be a string): Specifies a string to be shown to the
    user as a hint as to what information the field expects. This string disappears
    when data is entered into the field and is shown when the field becomes empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`multiple` (acceptable values include `multiple`, `""`, or empty): Specifies
    that multiple values are allowed in this element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readonly` (acceptable values include `readonly`, `""`, or empty): Specifies
    that the value of this element cannot be changed by the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`required` (acceptable values include `required`, `""`, or empty): Specifies
    that this element must have a valid value in order for the form to be allowed
    to submit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value` (value must be a string with no line feed or carriage return character):
    Specifies the actual url represented by this element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Form validation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although a form submission will automatically validate data inserted into the
    form and alert the user of any possible errors, there is a nicely defined API
    that gives us much more control over the validation process and reporting, than
    just the default.
  prefs: []
  type: TYPE_NORMAL
- en: Validity state object
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Each `form` element has an object attached to it of type **ValidityState**
    , which contains a list of properties related to the validation status of that
    node. You can access this object directly from a `form` element and inspect its
    properties manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: With these properties, we're able to inspect each `form` element and really
    customize the validation routine for the form. However, seeing that automatic
    validation is such an attractive feature designed to save time and effort, we'll
    focus on the functionality that can best help us with respect to this auto validation.
  prefs: []
  type: TYPE_NORMAL
- en: Custom validation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One of the properties of **ValidState** is the Boolean `customError`, which
    specifies whether a custom error message has been set to the field element or
    if the browser is to display a generic error message for this element in case
    the form does not validate. To set a custom error message, we can call the `setCustomValidity()`
    method of the `form` element itself and assign a message for the browser to use
    when needed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![Custom validation](img/6029OT_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first entry in the form just seen is invalid because it doesn't contain
    the string `packtpub.com`. The second form is valid because it conforms to the
    pattern specified. Note the customized error message on the first form, which
    is guaranteed to be the same in any browser that supports the features, as opposed
    to having a generic error message which can vary from browser to browser.
  prefs: []
  type: TYPE_NORMAL
- en: Used in the game
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There were two separate instances in the game where the web forms API was used.
    The first was in the game options widget, where a range input type was used to
    allow the user to select the difficulty of the game, and the other was used in
    the new champion form, allowing the user to enter his or her full name along with
    an email address.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here we set up a basic range input, specifying the maximum value as `3`. By
    default, most browsers will set the value for the `step`, `min`, and `value` attributes
    all to `1`, but just to be safe, we'll specify those values in case a browser
    handles that differently in case the attributes aren't specified.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Normally, you'll want to have two separate fields in your forms when asking
    for a first and last name. However, asking for a full name in a single field makes
    the field a great candidate for a custom pattern attribute.
  prefs: []
  type: TYPE_NORMAL
- en: The pattern used to validate a full name in this case is pretty simple; we look
    that the input as a word between 2 and 16 word characters (letters, and in this
    case possibly even numbers), followed by a single white space, which is in turn
    followed by another word of length greater than two, but less than 16 characters.
  prefs: []
  type: TYPE_NORMAL
- en: A placeholder string is added to both `input field` elements to avoid the need
    for extra labels in the form. This way the form can be nice and concise, yet descriptive
    enough that the user is never confused about what the form is asking.
  prefs: []
  type: TYPE_NORMAL
- en: Data attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you need to need to store data in an HTML element and there is no other
    attribute that would be more appropriate to hold that data, the HTML5 specification
    provides a special attribute for this very situation. Although the specification
    specifically refers to this attribute a `custom data` attribute, most people simply
    call them as the `data` attributes.
  prefs: []
  type: TYPE_NORMAL
- en: The way these `custom data` attributes work is very simple. Simply create the
    attribute name of your choice starting the name keyword with the prefix `data-`,
    then using any keyword of your choice that is at least one character in length.
    The only restriction is that the keyword must not contain any uppercase letters,
    although all HTML element attributes get lowercased automatically by default.
    You may add an arbitrary amount of such custom attributes to a single element.
    Finally, any `custom data` attributes may have any value of your choice, have
    the empty string as its value, or be empty, in either case the attribute is considered
    to have the value true (and the value false in its absence).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the example code just seen, we have some DOM node that happens to be an `input`
    tag and represents the score for some game. The first two sample data attributes,
    `data-is-high-score` and `data-score-to-beat`, are good examples. Just by looking
    at the names chosen for each attribute, we can infer the context in which they
    were meant to be used.
  prefs: []
  type: TYPE_NORMAL
- en: The first attribute is meant to hold a Boolean value that represents whether
    or not the score displayed by the heading element is a new high score. Since it
    currently holds the value false, then obviously the current score is not yet a
    new high score.
  prefs: []
  type: TYPE_NORMAL
- en: The second attribute stores the current high score, meaning that if the player
    gets a score higher than that value, his or her score will become a new high score
    and the attribute `data-is-high-score` should be updated to hold the value true.
    Keep in mind that these attributes are static and meaningless and the logic of
    your application is in charge of adding meaning to them based on their context
    as well as handling any updates to them, such as the example described previously.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, note the third `data` attribute example. This is not a very practical
    use of data attributes because there exists another HTML element attribute that
    exists for that very purpose, namely, to specify that an element is disabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add, remove, and check for an element''s attributes and their values programmatically,
    you can use the following JavaScript APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Used in the game
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There were a couple of usages of custom `data attributes` in the game with different
    purposes and for different reasons. As mentioned previously, one use was to specify
    a player's current speed. Two other instances of the attribute were used to identify
    and distinguish a player from the other and to group separate buttons that were
    intended to behave the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While the official specification states that you should always use the most
    appropriate attribute to store data in a DOM element, you should also keep in
    mind that the line that separates a possible `custom data` attribute and some
    other existing attribute may at times become gray. When this happens, you should
    prioritize your specific needs and goals.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you are trying to use a `custom data` attribute to name a group
    of related elements, the question might arise that a simple CSS class can achieve
    the same result. Some people might argue that since CSS classes already exist
    and their purpose is to group related elements, others may also argue that if
    no specific style is shared among these elements, then use of such a custom data
    attribute is well justified. However, the overruling factor should be the specific
    application goals and needs, so if, for example, adding a symbolic CSS class to
    group these elements would make it confusing, since no real corresponding CSS
    class exists, then the use of the custom data attribute is indeed well justified.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note that each span element inside the `div.track` element has both, a data
    attribute of name, which distinguishes the hero player from the enemy player,
    and a data attribute of speed, which specifies how much each element moves by
    on each tick of the game timer. Whether that number represents pixels, percentages,
    or any other unit is irrelevant, since both players have the value set to zero,
    meaning that they move nothing per timer cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Whether the data attribute name could be better represented by a CSS class can
    be argued in either direction. In this case, I chose to use a data attribute because
    then the styling can be independent of anything, and that concern can be delegated
    to another part of the application without any hesitation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here we have two separate buttons that share the same data attribute `intent
    = "play"`. With that attribute present, and that value assigned, we can then some
    JavaScript logic to handle those, and any other buttons, making their behavior
    predictable and universal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Query selectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two different, yet very similar, APIs as part of the new selectors
    interface. One selects a collection of elements that match the query used and
    the other only matches one. If multiple nodes are matched by a query used in the
    single selector version, only the first occurrence is returned.
  prefs: []
  type: TYPE_NORMAL
- en: To use this interface, you call the appropriate function on the document object
    and supply a string representing a CSS query. Now you can stop selecting an element
    by its ID, then navigating weird sub paths, in order to finally get to the element
    you want to target programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before this feature was available, it was common for developers to clutter their
    document structure with ID and class attributes just to make targeting those elements
    programmatically a bit easier. While using CSS expressions to target specific
    nodes may be easy enough that you may feel that you no longer need to add a unique
    ID or a class to an element just so it's easier to target that element through
    code, keep in mind that long CSS expressions might be so complex that the performance
    of your application might be compromised because of the time it takes to navigate
    to those elements. Remember that the shorter the CSS query, the easier it is for
    the browser to match the elements involved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet from the game, where we try to register
    a click event listener to the image element found inside a navigation menu holding
    the game options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You will note that the demonstration of the old way of selecting elements uses
    a very defensive programming style. While trivial selections may not need such
    paranoiac measures, a large application would definitely benefit from such an
    approach in case a particular element is not found in the DOM, and an event listener
    is attempted to be added to a variable holding a null reference. Either way, you
    can see how the new selectors API solves this problem in this particular situation,
    since no matter what other elements are possibly added to, or taken away from
    that `#navOptions` subtree, the CSS query used in the `querySelector("#navOptions
    img")` statement would still hold true, whereas `nav.children[1]` might not refer
    to the same element, should the structure of `#navOptions` change.
  prefs: []
  type: TYPE_NORMAL
- en: Also, you will note that the call to `querySelector` will return null if no
    elements are matched with the CSS query provided. When using the `querySelectorAll`
    interface, remember that a list will be returned whenever a match is found, whether
    one or more elements are selected. Thus, if only a single element is matched,
    you would still need to index into the result set in order to match the only element
    returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Used in the game
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned previously, every node selection was done using query selectors
    in the game. It is worth mentioning that it is not possible to register an event
    listener to a collection of nodes at once. You will need to iterate through the
    entire list (or at least a part of it) in order to touch one or more individual
    nodes in the list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If you attempt to call any function that would normally call on an individual
    node directly on a result set from a `querySelectorAll` call, you will get a `TypeError`
    since the function called is applied to the array element and not each and all
    of its elements.
  prefs: []
  type: TYPE_NORMAL
- en: Web fonts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The new web fonts API is particularly exciting and liberating to all those web
    developers out there who have had to rely on images in order to make the web truly
    beautiful up until now.
  prefs: []
  type: TYPE_NORMAL
- en: To use custom fonts, we use the CSS property `@font-face` and specify a few
    attributes, such as the name of the font and the font file, which the browser
    will follow and download to the client much like it does with assets such as images,
    videos, and sound files that are called by the client.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The only caveat with web fonts is that not all browsers support the same font
    types. The solution, though simple, can be a bit of a pain, since it involves
    uploading the different file format to your server then specifying each and all
    of them in the font-face declaration. When a browser comes across your custom
    font declaration, it can then download the file format that it can handle and
    serve that to the client.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As of this writing, Google Chrome, Firefox 3.6, and Microsoft Internet Explorer
    9 accept the `.woff` font files, while Safari, Opera, and Android support the
    `.ttf` files. Apple's iOS only supports the `.svg` font files.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can encode the entire font file into a `Data-URI` string
    and embed that into your CSS.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One great resource for free, open source, web fonts is Google''s Web Fonts
    project. There you can find a directly with several hundred different font files
    that you can search from and import right into your projects. Each file is hosted
    on Google servers, which means that the availability of these fonts is very high
    and the delivery speed is Google fast. What''s more, through their service, once
    you find a font that you''d like to import into your project, Google provides
    you with three options to import it: a standard link `rel="stylesheet"` tag, a
    CSS `@import` statement, or a JavaScript alternative. Either choice you make,
    the font file that eventually gets served to your end users is the exact format
    that the requesting browser supports. This way you don''t need to specify the
    multiple `src: url` attributes in your CSS file.'
  prefs: []
  type: TYPE_NORMAL
- en: Transitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CSS transitions is a great and simple way to add that special effect to any
    existing website. It is likely that your existing projects already use some sort
    of state change to elements based on different events, such as a hover effect,
    which may cause elements to change size, color, or position.
  prefs: []
  type: TYPE_NORMAL
- en: By adding a CSS transition attribute to these elements, you can more closely
    control the various states between the `original` state and the `final` state.
    For example, if a link is set to have a blue color by default and the font color
    changes to purple when the user moves the mouse cursor over that text, a CSS transition
    would cause the text to smoothly and gradually change the blue into the purpose
    color, instead of simply changing the color property in the blink of an eye.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, only properties that can possibly have intermediate states can transition
    between states. Normally, you can determine if that is the case with a particular
    attribute by looking at the value assigned to the attribute. If the value is a
    number, such as 10px, 2.5em, or 50%, then you can be sure that a transition property
    would result in an incremental change into the `final` state. Since colors are
    ultimately represented by numbers, whether they're hexadecimal values or something
    else, we are able to apply transition properties to colors as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the element with the `ID` property of `navOptions` is given
    a transition attribute. By default, that element has a left position of `-230px`,
    a patting of `10px`, and no background color. Then we define a class called `open`,
    and specifically associate it with the name `#navOptions` element. This class
    specify different values for the left, padding, and background properties. Thus,
    whenever the `#navOptions` element gets assigned to the class `.open`, those three
    properties will change gradually from the default into the new values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the transition property is assigned with a browser-specific prefix.
    This was done for simplicity, but in your production code you might want to check
    the status of each browser in regards to that specific property, and specify all
    values possibly needed, along with a plain, non-prefixed version for when the
    prefix is removed from a browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The example just seen uses short hand to define all four possible properties,
    but they can also be declared individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In short hand, the order of these parameters are: `property`, `duration`, `timing
    function`, and `delay`. You can also specify multiple properties in the same declaration
    by using a comma-separated list of properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note that you can have any arbitrary number of properties specified, or simply
    use the keyword `all`. Also, as shown in the previous example, not all values
    need to be the same (each property can have a different duration, timing function,
    or delay). The default delay is `0` (meaning that the transition starts right
    away as soon as the property change is triggered), and the default value for the
    timing function is ease.
  prefs: []
  type: TYPE_NORMAL
- en: Animations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The animations API is somewhat similar to the transitions API, but the main
    difference is that we get to specify two or more keyframes and the browser transitions
    between these keyframes. A keyframe is simply a point in time, with a series of
    properties specified for that particular point.
  prefs: []
  type: TYPE_NORMAL
- en: To use a CSS animation, you'll first need to create a named keyframe sequence,
    specify all the properties for each keyframe, then assign that keyframe sequence
    to some element. Similar to transitions, when you specify the keyframe sequence
    to an element, you also specify the configurations for that sequence, such as
    animation name, duration, timing function, delay, iteration count (how many times
    to play the entire keyframe sequence), direction (whether the animation plays
    from the first keyframe to the last or from the last to the first), and the play
    state (indicating whether the animation is running or paused).
  prefs: []
  type: TYPE_NORMAL
- en: To set up a keyframe sequence, simply use the `@keyframes` keyword, followed
    by a string identifying that sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in a way slightly different from other CSS properties, we nest other
    expressions inside this declaration, where each sub-expression is an individual
    keyframe declaration. Since each keyframe is a point in time (where the total
    time is specify when the animation sequence is applied to an element, as we''ll
    see shortly), we specify each keyframe in one of two ways: we can either specify
    a percentage of the time for when a keyframe is called into action, or we can
    use the keywords `from` and `to`, indicating the point in time when 0 percent
    and 100 percent of the total animation time has elapsed.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `from` keyword behaves the exact same way as 0 percent and the
    `to` keyword the same as 100 percent. Whether to use one over the other is purely
    a matter of preference.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Needless to say, the same issues regarding vendor prefixes apply to the animations
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The text shadow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The text shadow interface is much simpler to use than the transition or animation
    APIs since it only has four basic parameters, but can be equally as powerful in
    adding beautiful visual elements to make the user experience great. The parameters
    are the horizontal and vertical offset of the shadow relative to where the text
    is, the amount of blur to apply to the shadow, and finally, the color of the shadow,
    which can have the optional alpha channel for added opacity.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiply shadows may be added to the same element by adding them in a comma-separated
    listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, text shadows may be added to custom fonts embedded onto the page through
    HTML5''s web fonts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The box shadow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Box shadows are identical to text shadow, except for a few very important distinctions.
    First and for most, they are not applied to text but only to box elements. You
    could in fact apply a box-shadow property to a text element (such as a `p` tag,
    h1, h2, h3, and so on), but the effect would be drastically different. While the
    text shadow effect, essentially, simply renders an offset and blurred copy of
    the text to which the shadow is applied, a box shadow effect is simply a copy
    of the rectangle created by the elements width, height, margin, and border which
    is rendered with the specified color, offset, and blur values assigned in CSS.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Again, just like with text shadows, we can apply multiple box shadows to the
    same element through a comma-separated list of shadow declarations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: If you apply multiple shadows as just shown, any subsequent shadows should be
    drawn behind shadows drawn earlier, should they so happen to overlap. For example,
    the following set of shadows would display as a single, red shadow, since the
    red (`#cc0000`) was declared first and they both just so happen to cover the same
    area. Should the shadows have any amount of blur, the effect would be a mixture
    of the shadows. Since in this particular example, the shadows are completely solid,
    no blending takes place and the shadow in front takes precedence (since it's drawn
    higher in the rendering stack).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: There is also a fourth value that can be specified in a box shadow, which specifies
    the spread (or size) of the shadow. The default value is zero, which means the
    blur will begin right at the edge of the container created by the containing element.
    The effect created by a shadow spread is similar to a border placed between the
    blur of the shadow and the container created by the containing element.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the optional `inset` keyword tells the browser to draw the shadow from
    the border of the container inwards, as opposed to from the border (or where the
    border would be, had there been a border width greater than zero) outwards in
    the direction of the horizontal and vertical offsets.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note that in a multiple shadow declaration, each shadow can specify its own
    rendering orientation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The border radius
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The border radius property allows us to round the corners of the container formed
    by an element's dimensions. If there is any content where the rounding of the
    corner reduces the physical area of the container, that content is not drawn.
    Finally, the border radius declaration can be specified by a single value, where
    that value is applied to all corners (observe that here we refer to corners, not
    sides, as in a border declaration), by supplying four different values (where
    the corners would be targeted in the order top-left, top-right, bottom-right,
    and bottom-left), or by targeting each corner individually.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you are familiar with the HTML5 APIs used in this fun game, let's look
    under the covers and see how the game was put together. Due to brevity and ease
    of explanation, only the main portions of the source code for this game will be
    listed or explained here. Be sure to download the complete source code for the
    game at the book's website.
  prefs: []
  type: TYPE_NORMAL
- en: The HTML structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first component of this game was the HTML structure. The main pieces of
    it are the tracks where each player moves, along with each individual player,
    and the containers that show the text that needs to be typed by the user. There
    is also a second container that displays whatever text the player actually types
    in. For customization, there is an input type range that allows the player to
    change the difficulty level of the game, which for all practical purposes, only
    increases the speed attribute of the enemy player.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Other elements only add to the experience, either visually (through animations
    and other visual components) or with more interaction. But these are the basic
    game components without which the game cannot work.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript and logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The logic for this game is separated into three very basic components, namely,
    a `Player` class that encapsulates the behavior of each player, a game loop function
    that is called at a regular interval based on a game timer, and a few global functions
    that encapsulate various pieces of logic used throughout the life cycle of the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: The `Player` class holds a reference to the DOM nodes that represent the player,
    the track where the player runs, and defines some basic behavior to control the
    player.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In the global scope, we create two instances of this player class, one representing
    the hero of the game and the other the enemy that we try to defeat.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: When the game starts, we initialize some code, which is among a few other things,
    means that we determine how fast the game timer is to run, how fast the enemy
    player is to move, what phrase the user is to type in, and most importantly, we
    register a keyboard event on the body element of our HTML structure. In other
    words, we listen to every key press anywhere on the page, so that we can detect
    what the user has typed in after the game has begun.
  prefs: []
  type: TYPE_NORMAL
- en: This is probably the most complex function in the game because we have to handle
    every key press by ourselves. This means that we need to take into account whether
    or not the user has pressed a key while holding the *Shift* key (in which case
    they have entered a capital letter), or whether a special key combination was
    pressed. For example, if the user presses the *Backspace* key, by default the
    browser will respond to this event by navigating the web page back to the last
    page navigated. Obviously, we don't want the browser to navigate away from our
    game. Instead we want the last character typed in by the user to be deleted. Thus,
    small details such as this must be taken into account.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, at each letter typed in by the user, we must check whether that letter
    was the same letter we were expecting (the correct letter) or whether the user
    has typed in a wrong letter. Based on this decision, we output to the screen the
    letter just typed, along with some HTML that allows us to render that letter differently
    based on whether or not it was the right key.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: At every tick of the main game timer, which we can make faster or slower based
    on the difficulty that the player has selected, we call our main game loop, which
    performs some basic tasks. First we move each player, then check if any of them
    has reached the end of their track. This is done by calling each player's `isFinished()`
    function, defined by the `Player` class. If that is the case, then we know that
    the game is over. If that is so, we unregister the keyboard event we had bound
    to the body element, so that we no longer inspect any keyboard input from the
    user. After we've determined that the game is over, we determine if the user has
    actually won or lost the game. If they have won, we record their victory. If they
    have lost, we tell them so, and allow them to play a new game. If the game is
    not yet over, we simply wait for the game loop to run again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we finally jumped off the spring board we set up in the previous
    chapter, and dove headfirst into the very deep world of HTML5 game development.
    We started out by setting up the project structure used in constructing this game
    and discussed the main goals and objectives of the game. Next, we looked at each
    of the components used in the game and discussed how and why they were used. Finally,
    we look a deeper look at each of the HTML5 APIs, that make up each of these components,
    and looked at some code examples to make them work.
  prefs: []
  type: TYPE_NORMAL
- en: Since the complete source code for the game is fairly lengthy, we only took
    a brief peek at the main structure of the code, so that when you download the
    full source from Packt's website, the code looks somewhat familiar to you. Again,
    I want to remind you that because the focus of this book is not game development
    but rather HTML5, the methods and techniques used to make this game may or may
    not be the most optimal approach to game development. Although, the way this game
    was coded in pure HTML5, it works and performs great in any modern webkit-based
    browser. A discussion in game development as well as more sophisticated techniques
    is beyond the scope of the book.
  prefs: []
  type: TYPE_NORMAL
