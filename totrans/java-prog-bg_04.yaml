- en: Data Structures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn some of the most important data structures
    in Java. We'll look at what arrays are and how they are useful when we need to
    work with sequences of variables. We'll write a program in NetBeans using arrays
    to understand how they work. This chapter will also walk us through the concept
    of multidimensional arrays. We'll write a program to create a chessboard using
    a two-dimensional array.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Next, this chapter will illustrate what ArrayLists are and how they provide
    increased functionality when compared to arrays. Finally, we'll look at the `Map`
    data structure and implement it in NetBeans.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'More specifically, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Arrays and their syntax
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An array example to print the English alphabet
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multidimensional arrays
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A program to create a chessboard using a 2D array
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ArrayList and its example
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maps and their implementation in NetBeans
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with arrays
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section we're going to learn about Java arrays. Arrays are Java's most
    basic and commonly used data structure. Data structures are tools that allow us
    to store and access sequences of information rather than using individual variables.
    Variables are great when we have one specific piece of information that we need
    in our local programming space, but data structures are used when we want to store
    large or complicated sets or series of information. We're going to start this
    section with some visual learning modes, and then we'll jump into our NetBeans
    IDE to write some actual Java code and make use of arrays.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Declaring and initializing an array
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin by taking a look at the syntax behind declaring and initializing
    an array in Java. The following line of code will cause an array to come into
    being with enough space to hold seven characters:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To the left of our assignment operator (`=`), the syntax looks pretty familiar,
    not unlike the syntax we would use when declaring any other primitive or object.
    We begin by telling Java what type of element we're going to declare here. In
    this case, we're declaring a character array. The empty square brackets lets Java
    know that rather than creating a single character variable, we'd like to declare
    an array type variable because our array is a variable just like any other. We'll
    access the elements of the array through the array's variable name itself, not
    through the individual variable names of the elements, which we don't need to
    assign as they are being stored in an array. Once we've told Java what type of
    array we're going to create, we give our array variable a name. I've called this
    one `arrayVar`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: To the right of our equality operator, things look a little different. You may
    have seen the `new` keyword used in the past when we needed to create a new instance
    of an object, not a primitive element. When we create a primitive element in Java,
    Java knows exactly how much memory space is needed to store the primitive element,
    no matter what its value is. However, objects and arrays can have many different
    size requirements. Because a single array variable can be assigned to arrays of
    different lengths, we're going to need to tell Java how much memory to put aside
    for each of these different length arrays when we create them. When creating an
    object or an array, therefore, we use the `new` keyword to tell Java that it should
    set aside memory space to place what we're about to cause to come into being,
    and that thing is a character array of length seven.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'After declaring and initializing our seven character array, what exists in
    our program''s local memory is something like the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d309c8b-43d4-4a06-8e54-171a1043da0e.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: Our array is basically a block of memory large enough to store seven individual
    characters.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Assigning values to an array
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The location of our array is accessed by our program when we call the `arrayVar`
    variable. This allows us to run lines of code such as the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Our `arrayVar` variable gives us access, essentially, to seven different character
    variables. When we don''t want to assign a new array to our `arrayVar` variable,
    we''re probably going to be accessing these character variables as individuals.
    We do this simply using the variable name of `arrayVar`, following it with square
    brackets, which include the index of the individual character we''d like to access.
    Remember, when our computers count indexes, they almost always begin with **0**.
    So, in Java, our seven-character array has these indexes: **0**, **1**, **2**,
    **3**, **4**, **5**, and **6**. If we execute the preceding line of code while
    setting the value of index `2` in our `arrayVar` to `c`, we will take the third
    block of memory and assign its value to the character `c`, as shown in the following
    diagram:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23e6c8b8-c4a9-4b21-8862-53c6b33889f4.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
- en: 'Sometimes when we declare an array, we just want to go ahead and assign values
    to all of its memory blocks right there in the code explicitly. When we want to
    do this, rather than using the `new` keyword and having our computer space out
    the new memory space by telling it how long the array is, we can explicitly declare
    an array, like we explicitly declare a primitive type. For example, we would do
    this for our `arrayVar` variable with the following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding statement will create an array of length seven simply because
    seven elements are declared, and of course, it will map the values accordingly:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f96737c2-efd9-4c2f-bdb4-9c62057f3c8f.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: Now, let's jump into some Java code and put arrays to work.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Array example in NetBeans
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Alright, I think it's time to employ our newfound knowledge and write a computer
    program. Arrays allow us to manipulate amounts of information that would be unwieldy
    to deal with at the individual element level. So, we're going to jump right into
    hard-hitting stuff and create a cool computer program. Arrays are a big logic
    step, and if you haven't worked with something like them before, it can take a
    little time to wrap your head around them. The good news is if you make it through
    arrays in Java, you're probably going to be just fine with anything else the language
    can throw at you.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'The program I would like to write will print the English alphabet to our screen.
    We could, of course, do all of this by ourselves by just doing something along
    the lines of the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: However, employing this is pretty mind-numbing and it's not going to teach us
    much. Instead, the program that we're going to write is going to learn, store,
    and print out the English alphabet.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we're going to need to employ our newfound knowledge of arrays,
    our existing knowledge of how characters work and mapping integer values on an
    ASCII table, and a single `for` loop.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Creating an array
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin our programming by declaring and initializing a character array
    in which to store the characters of the English language. So, we tell Java that
    we''re going to need a variable to point to an array of characters. I''ll call
    this variable `alpha`. Then we''re going to ask Java to set aside memory space
    by using the `new` keyword for `26` characters, because the English language has
    26 letters:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, if you remember, character values can also map to integer values. To find
    these, we will look for an ASCII table. (You can access the ASCII table at [www.asciitable.com](http://www.asciitable.com/).)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9f6be8e-6290-44ce-97ce-b9bb46a323d6.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
- en: 'The value we''re looking for is **97**, the integer value of a lowercase **a**,
    which is the first character in the English language. So let''s create a little
    comment in our program and store the value `97` for later use:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Creating a for loop
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s begin creating our `for` loop. Our `for` loop is going to run 26
    times; each time it runs, it will take the next character in the English alphabet
    and place it in our character array: `alpha`.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure our `for` loop runs exactly 26 times, we should declare a counting
    variable, say `i`, and set it to `0`, that is, (`i=0`). Next, let''s say that
    our `for` loop should continue to run as long as the value of our counting variable
    is less than `26`, that is, it should take values between `0` and `25` (`i<26`).
    Lastly, every time our `for` loop runs, we need to increase the value of our counting
    variable by one so that it goes up each time, and after 26 iterations, the `i<26`
    statement will no longer be true and our loop will stop at (`i++`):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, inside our `for` loop, we're going to assign values to the spaces in our
    character array one by one. To access one of these spaces, we will use the name
    of the variable assigned to our array, that is, `alpha`, followed by a number
    (or index) within square brackets to tell Java which character in our array we
    would like to assign a value to.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: The index of our array should be different each time we run through the loop.
    This is the beauty of `for` loops. By starting our counting variable `i` at `0`,
    we can use it to map to the index of our array. That is, we can use `alpha[i]`
    to access elements of the array one by one. Our counting variable's value, as
    our loop runs, will range from 0 to 25\. The index values of our array (because
    computers start counting at zero) also ranges from 0 to 25.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what value do we assign to each character so that our computer will learn
    the alphabet? Well, I like to think of it this way: when we run through the loop
    for the first time, the value of the first element of our array, when `i` is `0`,
    should be `97`, which is the integer value of the character **a**. Now, when we
    should assign `97+i` as the value of each character in our array. When we run
    through our loop the second time, `i` is incremented by one, and we''ll be assigning
    the value 97 + 1, or **98**, which is the integer value of the character **b**:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this instance, Java is asking us to explicitly let it know that we would
    like to cast this integer value to a character and then store it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Printing the alphabet
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, to finish off our program, all we need to do is print out our `alpha`
    array. To do this, let''s make use of a nifty function in an always accessible
    object called `Arrays`. The `Arrays.toString()` function will convert a single
    dimension array, which is the kind of array that we''ve created, that is capable
    of being converted into a string:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, if we run our program, we''ll see Java''s representation of the English
    alphabet in array form:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f64fbff0-7f63-4e4b-bc9b-42930ad80643.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
- en: If you have followed along with this, you should give yourself a solid pat on
    the back. That's some heavy lifting we just did.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Default initialization of arrays in Java
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s jump back into theory for the rest of this section. I misled you
    earlier when I led you to believe that our newly created arrays were filled with
    empty memory space. In fact, when we declare a new array of a primitive type,
    that is, characters, integers, Booleans, floats, and so on, Java fills it with
    default values. For example, our new array of seven characters was filled by seven
    space characters, that is, what you''d get if you pressed the spacebar on your
    keyboard:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/83398f87-f920-4c84-9b7d-3a7227bb310a.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, an array of integers would be filled with seven zeros:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c2e6f3b3-fef4-445f-9385-8a0f2eb177a9.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: I recommend that you boot up a Java IDE and create some empty primitive arrays
    and print them out using `println` to see what the default values are.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Now we can create arrays of any object available to us. However, objects, unlike
    primitives, do not have default values that they set themselves to when they are
    initialized as part of an array. This is an important thing to realize.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Anything that we would need to use the `new` keyword to create will not default-initialize
    in an array.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say for some reason we decided that we must have seven `Scanner` objects
    in an array. The following statement does not create seven `Scanner` objects for
    us; it simply sets aside memory space:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cc6f82a1-e7e7-4e04-a449-682ff95ee803.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
- en: We can create `Scanner` objects and assign them to these memory spaces, but
    if we try and call one of these memory spaces and use a Scanner-specific function
    from it before we've assigned a `Scanner` object to the memory location, our program
    will crash. We'll get what's called `NullReferenceException`, which means that
    Java asked nothingness to behave like a `Scanner` object.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Multidimensional arrays
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Java, our most basic data structure is the array, which allows us to store
    sequences of light-typed information and access this through a single location
    in memory. Sometimes, however, arrays are unwieldy, and we want to use more strongly
    organized data structures so that they can be easier for humans to understand
    and write programs around. Oftentimes, what's appropriate here is a multi-dimensional
    array.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '"Multidimensional array" is a pretty scary-sounding name, but in fact the concept
    behind it is very basic. The question is what happens if we create an array of
    arrays? The following line of code shows the syntax to do just that:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This line of code will create a two-dimensional multidimensional array. You''ll
    see it''s very much like the syntax for simply creating an array of characters
    under normal circumstances, but in every instance where we reference the array
    variable now, Java is going to need two pieces of information (or two indexes).
    The preceding line of code will tell Java to create three arrays, each of which
    has enough space to store seven characters or three arrays of length seven:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb6fae9f-b50e-4a72-bd5a-41c9a46a2c66.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
- en: To cement our understanding of this concept, let's write a Java program that
    utilizes two-dimensional arrays.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: A multidimensional array example in NetBeans
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we can use multidimensional arrays to store information in abstract manners,
    it will probably be easiest for us to learn them by representing an actual two-dimensional
    object with our two-dimensional array, in this case, a chessboard.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: The classic chessboard is divided into black and white squares; it's eight squares
    in width and eight squares in height. The program we're about to write will store
    a virtual board in Java with the squares correctly labeled black and white. Then,
    at the end, we'll have it print this board out to us so that we can check whether
    we had written to our program correctly.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Creating a multidimensional array
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin by simply declaring and initializing the array we''re going to
    be using. We''ll use an array of characters for this task, giving the white squares
    the character value of `W` and the black squares the character value of `B`. Since
    a chessboard is an eight by eight grid, we''re going to want to declare a two-dimensional
    array of eight arrays, each of which should contain eight characters:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s make things even more difficult for someone to inadvertently break in
    by storing the dimensions of our board in a separate location. To do this, simply
    create a variable called `boardDim`, for board dimensions, assign it the value
    `8`, and then reference it when we create our arrays. Arrays will be perfectly
    happy to use an integer in a variable to initialize themselves, letting us create
    dynamically linked arrays if our program calls for it. Now, if someone wants to
    go to this program and scale up our chessboard, they need to only change the value
    of `boardDim`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In order to assign our squares their proper values, we're going to need to loop
    through this array to get to each individual node and give it the value we want
    it to have.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Using nested loops for multidimensional arrays
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Loops and arrays get along great because arrays always know how long they are,
    but a single `for` loop doesn't allow us to meaningfully loop through a two-dimensional
    array. A `for` loop really just goes in one direction, and our two-dimensional
    arrays have two directions.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: To solve this, we're going to make use of nested `for` loops, or a `for` loop
    within a `for` loop. Our outer `for` loop will loop through each array in turn,
    while the job of our inner `for` loop will be to loop through the nodes that those
    arrays contain.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: A common practice when creating `for` loops is to use the integer variable `i`
    for your initial `for` loop, and then `j`, `k`, and so on for subsequent `for`
    loops. However, because we're creating a chessboard, which is an actual object,
    I'm going to choose the value `y` as our outer loop's counting variable. This
    is because what our loop is doing is iterating down the *y*-axis of our chessboard.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, `for` loops and arrays get along great because arrays
    know how long they are. We could simply state that we would like this loop to
    run eight times (`y<8`), but that's not good dynamic programming because if someone
    were to go along and change the size of our chessboard, our program would now
    break. We can write this loop such that it will work for a chessboard of any size.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, rather than explicitly saying our loop should run eight times,
    we should have it start by asking our array how long it is. To ask an array its
    length, we just need to write `array.length` and this will returns an integer
    value. This is a two-dimensional array, so simply calling the name of the array
    to use the `length` variable will get us the length of the array''s outermost
    segment. In this case, we''re asking our two-dimensional array, "How many arrays
    do you have?" To finish off this `for` loop, we simply need to increment `y` after
    it runs each time. Thus, our outer `for` loop will loop through each array that
    our 2D array `board` contains:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, let''s do something similar for our inner loop. Because this loop will
    be iterating through the individual elements of our rows, `x` for the *x*-axis
    seems an appropriate variable name to use. Because our array is currently the
    same length in both its segments, an eight by eight array, simply using the `board.length`
    statement, would work for now. But once again, it''s not good dynamic programming.
    If someone was to go through and change the size of our board to be eight by ten,
    this program would no longer execute properly. Instead, at the beginning of this
    inner `for` loop''s execution, let''s ask the array that we''ve currently accessed
    through the outer loop how long it individually is. This once again makes our
    program robust and allows us to accommodate multiple sizes for our board:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'OK, the next step in our program is to assign character values to each node
    in our array: `B` for black squares and `W` for white squares. Let''s start off
    by writing the code to make all the squares white. Our double `for` loop will
    pass through each node in our two-dimensional array when it executes. So, each
    time we execute the code in our inner `for` loop, we''re executing it in terms
    of one of the single two-dimensional array nodes. To get this node, we''re going
    to need to ask our `board` array what is located at row `y` and column `x`, and
    then we''ll change the value of that node:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Assigning different colors to our chessboard
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The thing is, each time this inner loop executes, we're going to want a different
    value for the nodes so that we get a chessboard that is alternating white and
    black squares. To help us do this, let's add another variable to our program.
    It'll be a Boolean variable, and we'll just call it `isWhite`. If `isWhite` is
    `true`, then the next square we add will be white; if `isWhite` is false, the
    square will be black.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: To code this out, let's use some `if` statements. Firstly, the `if(isWhite)`
    code term checks whether `isWhite` is `true`. If it is, then we put a `W` in our
    square. If `isWhite` is `false`, we put a `B` in the square for black. To check
    whether something is not true, we can invert any Boolean value with an exclamation
    point beforehand. This will work for Boolean or even conditional statements.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we simply need to flip the value of `isWhite`. Well, using our knowledge
    of the exclamation point operator, which flips the value of Boolean, we can flip
    the value of `isWhite` from `true` to `false` or `false` to `true` by simply setting
    its value to the knotted version of itself:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Unfortunately, this program is not quite perfect. It turns out that if we do
    this, our chessboard is going to have every single row starting off with a white
    square, while a real chessboard alternates with every other row with a different
    colored square.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, the outer loop runs once for each row of the chessboard. So if
    we were to simply add an extra flip to our `isWhite` Boolean value at the start
    of every row, we would get alternating row starts as well. If we do it like this,
    we need to start `isWhite` off as `false` because it''s going to be immediately
    changed to `true` when the outer loop executes for the first time:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Printing the chessboard
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've followed along thus far, let's go ahead and write the final bit of
    our program, a line of code to print out our chessboard to the screen. Actually,
    we're going to need a bit more than a line of code. We can use the `println()`
    function along with `arrays.toString()` to print the contents of a single array
    to the screen, but this technique won't work well with a two-dimensional or higher
    array.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we''re going to need to use a `for` loop again to grab each array in turn,
    and then print them to the screen. This works pretty well because `println` will
    automatically carriage return, or give us a new line between each row we print.
    Here, let''s use the conventional syntax variable `i` to iterate through our `for`
    loop:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9febda2-dfd7-4516-9fde-4248e4d90dcb.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
- en: 'You''ll notice that Java does not yet understand the `Arrays` keyword as shown
    in the preceding screenshot; that''s because `Arrays` lives in the `java.lang`
    package. It can be kind of annoying when we call a function or a class and Java
    doesn''t immediately know where to find it, and we have to go online and locate
    it on Google. If we''re working in an IDE, such as NetBeans, sometimes there''s
    a shortcut to find common packages. In this case, if we right-click on the problem
    statement and go to Fix Imports, NetBeans will go through the common packages
    and check whether it can figure out what we''re doing:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad6ff3b4-9a65-4431-b208-6bca9a0bfe94.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
- en: 'In this case, NetBeans has located the `Arrays` class and added the import
    statement for us:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, because we don''t want to attempt to print out the contents of the two-dimensional
    array each time our `for` loop executes (which wouldn''t work very well anyway),
    we''re going to tell our `println` statement to print out the contents of `board[i]`,
    or the individual array, within the two-dimensional array that we''ve accessed:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, let''s see whether we got everything right the first time through and
    run our program:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e6cded2-3f5b-4752-8e51-5bd514db59e9.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
- en: Wow! It looks like we did. There's an alternating white and black representation
    of a chessboard that begins with a white square and has rows starting in the proper
    manner. This might not look like much now, but its significance is pretty big.
    We've essentially taught our program how a chessboard looks. This is our first
    step toward creating something much bigger, such as a program that plays chess.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Were we to create a program that plays chess (which is a little out of the
    scope of this section here, but we can talk about it conceptually), we would probably
    want our individual squares to be able to store more information than just what
    color they were. For example, we would probably want them to know what piece was
    on them. To make this happen, we could utilize a three-dimensional array. We could
    create an array that looks like the following so that each square could store
    an array that holds two pieces of information, one character for its color and
    another character to represent what piece it''s on:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建一个下棋程序（这有点超出了本节的范围，但我们可以在概念上讨论一下），我们可能希望我们的每个方块能够存储更多信息，而不仅仅是它们的颜色。例如，我们可能希望它们知道上面有什么棋子。为了实现这一点，我们可以利用三维数组。我们可以创建一个看起来像下面这样的数组，以便每个方块可以存储一个包含两个信息的数组，一个字符表示它的颜色，另一个字符表示它上面有什么棋子：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: So that's the basics of multidimensional arrays in Java.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Java中多维数组的基础。
- en: ArrayLists
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ArrayLists
- en: When we need a Java data structure, we should start by asking ourselves whether
    a simple array is sufficient. If we can write our program easily and neatly using
    just an array, that might be our best option to keep our programs simple by extension.
    If you're writing code that must run as fast as possible and use memory as efficiently
    as possible, arrays will also have very little overhead. But, in today's development
    world, where memory efficiency and speed really aren't concerns for your average
    program, sometimes we need to employ data structures with more built-in functionality,
    or maybe which are designed for a specific purpose.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要一个Java数据结构时，我们应该首先问自己是否简单的数组就足够了。如果我们可以使用一个简单的数组轻松整洁地编写我们的程序，那可能是保持程序简单的最佳选择。如果你正在编写必须尽可能快地运行并尽可能高效地使用内存的代码，数组也将几乎没有额外开销。但是，在今天的开发世界中，内存效率和速度对于普通程序来说真的不是问题，有时我们需要使用具有更多内置功能的数据结构，或者可能是为特定目的而设计的数据结构。
- en: A data structure with additional functionality is called an ArrayList. One of
    the weaknesses of traditional arrays is that when we instantiate them, we have
    to give them a specific length, so we have to know how large we want our array
    to be. An ArrayList is basically an array wrapped in some additional code that
    causes the array to increase or decrease in size to always be the size of the
    number of elements it contains.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 具有附加功能的数据结构称为ArrayList。传统数组的一个弱点是，当我们实例化它们时，我们必须给它们一个特定的长度，因此我们必须知道我们希望数组有多大。ArrayList基本上是一个包装在一些附加代码中的数组，这些代码导致数组的大小增加或减小，以始终保持与其包含的元素数量相同的大小。
- en: An ArrayList example in NetBeans
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NetBeans中的一个ArrayList示例
- en: To see this in action, let's write a program that would actually be a little
    more difficult to write if we just used a standard array instead of an ArrayList.
    I'd like to write a program that will take an input string from the user. It will
    store this input string with every other input string the user has ever given
    it, and then print them all out each time the user inputs a new string.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这个实例，让我们编写一个程序，如果我们只使用标准数组而不是ArrayList，那么编写起来可能会更困难一些。我想编写一个程序，它将从用户那里获取一个输入字符串。它将存储这个输入字符串以及用户以前给它的每个其他输入字符串，然后每次用户输入一个新字符串时都打印它们出来。
- en: This would be really difficult to do with an array because if the user ever
    inputs one more string than the array was designed to hold, our array would, in
    the best-case scenario, not accept the string; in the worst-case scenario, our
    program might crash. But, our ArrayList object will simply resize to fit the number
    of strings that it's currently holding.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是非常困难的，因为如果用户输入的字符串比数组设计的容量多一个，数组将在最好的情况下不接受字符串；在最坏的情况下，程序可能会崩溃。但是，我们的ArrayList对象将简单地调整大小以适应它当前持有的字符串数量。
- en: Creating an ArrayList
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个ArrayList
- en: 'We need to begin by importing `java.util`, because `java.util` is where the
    `Scanner` class, which we''ll need to get user input, and the `ArrayList` class
    itself, live. Once we''ve declared a `Scanner`, which we''ll utilize a bit more
    later, it''s time for us to declare our `ArrayList`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从导入`java.util`开始，因为`java.util`是`Scanner`类（我们需要获取用户输入）和`ArrayList`类本身所在的地方。一旦我们声明了一个`Scanner`，我们稍后会更多地利用它，现在是时候声明我们的`ArrayList`了：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Simply declaring `ArrayList` looks a lot like declaring any other object. We
    say what type of object we'd like to create. We give it a name. We use the `new`
    keyword because Java is going to have to set aside some memory to create this
    object since it's not a primitive. Then, we tell Java to actually create the object.
    Even though we're not going to provide any arguments for our `ArrayList` creation,
    we still need to follow it with the double parentheses. This is actually valid
    code we've just written, but generally when we create an `ArrayList`, we're going
    to do a little bit more.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地声明`ArrayList`看起来很像声明任何其他对象。我们说出我们想创建的对象的类型。我们给它一个名字。我们使用`new`关键字，因为Java将不得不设置一些内存来创建这个对象，因为它不是原始的。然后，我们告诉Java实际创建对象。即使我们不会为我们的`ArrayList`创建提供任何参数，我们仍然需要在其后跟上双括号。这实际上是我们刚刚编写的有效代码，但通常当我们创建一个`ArrayList`时，我们会做更多的事情。
- en: The `ArrayList` memory that we've created will actually store any type of single
    entity we place within it. This might sound really, really great at first, but
    honestly, it's not a good thing to have in our program. It's really easy to get
    confused if we have ArrayLists, or any data structure, really, that's storing
    just about anything, and if we feel the need to do this, we're either doing something
    really complicated, or more likely we're not writing our code as cleanly as we
    should. More importantly, once we store anything in our ArrayList, it's possible
    for us to sneak by our compiler and create code that compiles OK. However, the
    other possibility is that it would break at runtime, causing the kind of bugs
    that are really bad to have in commercial software because they can break when
    people are actually using it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的`ArrayList`内存实际上将存储我们放入其中的任何类型的单个实体。这一开始听起来可能非常好，但老实说，在我们的程序中这不是一件好事。如果我们有ArrayLists，或者任何数据结构，实际上存储了几乎任何东西，很容易感到困惑，如果我们觉得有必要这样做，要么我们正在做一些非常复杂的事情，要么更可能的是我们没有编写我们的代码如我们应该那样清晰。更重要的是，一旦我们在ArrayList中存储任何东西，我们就有可能绕过编译器并创建编译正常的代码。然而，另一种可能性是它会在运行时出错，导致那种在商业软件中非常糟糕的bug，因为它们在人们实际使用时可能会出现问题。
- en: 'To solve this problem, we can tell our ArrayList to only accept information
    of a certain type. We do this by following our `ArrayList` declaration and instantiation
    with double character brackets and placing a type within them:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以告诉我们的ArrayList只接受特定类型的信息。我们通过在`ArrayList`声明和实例化后跟随双字符括号，并在其中放置一个类型来实现这一点：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We've declared and then caused to come into being an `ArrayList` data structure
    that will only allow strings to be stored within it.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明并使`ArrayList`数据结构成为可能，它只允许存储字符串。
- en: Getting user input
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取用户输入
- en: 'We''re going to need a loop so that our user can input more than one string
    to the program. For now, let''s just use an infinite loop. It will run forever,
    but while we''re building our program and debugging it, we can always just stop
    it manually:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个循环，这样我们的用户可以向程序输入多个字符串。现在，让我们只使用一个无限循环。它将永远运行，但在构建程序和调试程序时，我们总是可以手动停止它：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Each time our loop runs, we're going to want to use the `nextLine()` function
    on our Scanner variable, that is, `reader`, to grab a new line of input from the
    user that we're going to store in our ArrayList.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 每次循环运行时，我们都要使用Scanner变量`reader`上的`nextLine()`函数，从用户那里获取一个新的输入行，并将其存储在我们的ArrayList中。
- en: When we're working with object data structures, that is, data structures that
    have code wrapped around them, and functions and methods of their own, we're generally
    not going to have to deal with the individual indices of memory, which can be
    pretty nice. Instead, we use their provided functions to add, remove, and manipulate
    the information within them.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用对象数据结构时，也就是说，具有自己的代码包装、函数和方法的数据结构时，通常不需要处理内存的各个索引，这可能非常好。相反，我们使用它们提供的函数来添加、删除和操作其中的信息。
- en: 'In this case, adding something to an ArrayList is pretty easy. The `add()`
    function in ArrayList will add whatever input we give it, in our case, as long
    as it''s a string, to the end of the array that the ArrayList contains. So, let''s
    add the following line of code that will request a new input string from the user
    and then put it at the end of our ArrayList inside our infinite `while` loop:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，向ArrayList添加内容非常容易。ArrayList中的`add()`函数将添加我们提供的任何输入，也就是说，只要它是一个字符串，就会将其添加到ArrayList包含的数组的末尾。因此，让我们添加以下代码行，它将请求用户输入一个新的字符串，然后将其放在我们的无限`while`循环内的ArrayList末尾：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Printing the ArrayList of user input
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印用户输入的ArrayList
- en: 'Now, we can simply use `println` to print our ArrayList out to the user. Note
    that the `println` code line doesn''t know how to take an ArrayList as input.
    Actually, it might, but we should explicitly use the `toString()` function, which
    almost every object in Java implements:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以简单地使用`println`将我们的ArrayList打印给用户。请注意，`println`代码行不知道如何将ArrayList作为输入。实际上，它可能知道，但我们应该明确使用`toString()`函数，几乎每个Java对象都实现了它：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, when we run our program, we''ll be prompted for some user input, and we''ll
    see the input echoed back out at us. If we give Java some more input, we''ll see
    our more input, and the old input will be stored in our `ArrayList`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行我们的程序时，我们将被提示输入一些用户输入，并且我们将看到输入被回显。如果我们给Java一些更多的输入，我们将看到更多的输入，并且旧的输入将被存储在我们的`ArrayList`中：
- en: '![](img/e01f0a61-f15e-4542-b690-6f8bdfa5e77e.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e01f0a61-f15e-4542-b690-6f8bdfa5e77e.png)'
- en: So that's pretty cool! We've built a really basic program that would be more
    difficult to write with a simple array.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这很酷！我们已经构建了一个非常基本的程序，使用简单的数组写起来会更困难。
- en: Giving control to the user
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将控制权交给用户
- en: ArrayLists have a lot of power contained within them. We can turn them into
    arrays, create them from arrays, and all sorts of things. If we go to the Java
    documentation and check under `java.util` for ArrayList, we can find all of their
    methodologies. Let's add few more features to our ArrayList program so that I
    can walk you through some common ArrayList methods.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ArrayLists内含有很多强大的功能。我们可以将它们转换为数组，从数组创建它们，以及各种其他操作。如果我们去Java文档并在`java.util`下查找ArrayList，我们可以找到它们的所有方法。让我们给我们的ArrayList程序添加一些功能，这样我就可以向您介绍一些常见的ArrayList方法。
- en: 'ArrayLists have a function that takes no input, called `clear()`, which will
    erase our ArrayList. We can utilize this function to give our users some control
    over our program. Let''s say that if the user inputs the string `CLEAR`, we would
    like to erase all of the information in our ArrayList. Well, that''s a conditional
    statement I just made, so we use an `if` statement. We''d utilize the following
    `if` statement code inside our `while` loop to implement this functionality:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ArrayLists有一个不需要输入的函数，称为`clear()`，它将擦除我们的ArrayList。我们可以利用这个函数来让我们的用户对我们的程序有一些控制。假设如果用户输入字符串`CLEAR`，我们想要擦除ArrayList中的所有信息。好吧，这是一个条件语句，所以我们使用`if`语句。我们将在我们的`while`循环内部使用以下`if`语句代码来实现这个功能：
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'First, we need to check the item just added to our ArrayList against the string
    `CLEAR`. This item will be at the very end, that is, it will be the last item
    with the highest index value. Unfortunately, there''s no `lastItem()` function
    implemented for ArrayList, but we can essentially create one ourselves by mashing
    together two ArrayList functions: `get()` and `size()`.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: First, in order to get an item from an ArrayList, we utilize the `get()` function.
    Note that `get()` is very similar to the square brackets we would utilize if we
    were accessing an item from a traditional array. Also, the `get()` function is
    going to take an integer value and it's going to map that integer to the index
    of the array contained within our ArrayList.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: So, to get the last item in our ArrayList, we need to know how many items are
    there in the ArrayList. Then, we want to subtract one from that value, because
    the last index of an array with the length of, let's say seven, would be six,
    since the array starts counting at zero. To get how many items are there in our
    ArrayList, we use the `size()` function, which takes no arguments and simply gives
    us an integer that is the size of the array, that is, how many items it contains.
    We subtract `1` from that value so that we can properly access the last index
    and not the index behind it, which could contain anything. Then, we wrap the whole
    `memory.get(memory.size()-1)` block, which accesses the last item of our `ArrayList`
    in parentheses.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'This block of our `if` statement we just parenthesized gets for us a string
    object. We know that we can compare strings by using the `equals()` method. We
    can actually call that method from the string object that this block of code returns,
    even though we haven''t assigned it a specific variable name yet. Objects exist
    even if we don''t have a name for them, and we can call their methods and do just
    about anything we like with them if we''ve just returned them from something else:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: So, that's a pretty crazy statement we've just written, but as long as we've
    written it right, when our user enters `CLEAR` in the program, we will erase the
    ArrayList.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve written this code, we can write very similar code to give our user
    different functionality options. Let''s also allow our user to type in `END`.
    Currently, we''re in a program that will loop infinitely until we manually turn
    it off. But by using the `break` Java keyword, which will jump us out of whatever
    loop we''re in, or function if we''re in a function, we can make this an escapable
    loop. This way, we let the user essentially turn off our program because once
    we leave this loop, there''s no more code to execute and our program will end:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Be careful when you're using `break` statements. Make sure it makes sense to
    do so, because they can be a little confusing if you're going through someone's
    code. They break and jump the control flow all over the place.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s run this program and see what happens. We''ll start by giving our
    program some input and build the ArrayList:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae823de0-08af-458a-a9c0-062b10bb890b.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s try inputting `CLEAR` and check whether it empties our ArrayList.
    Oh no! I broke it:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/daa354cd-4dd8-4f52-ab30-374efe042f27.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: This is actually a pretty interesting error that we made. I actually made this
    error; it wasn't preplanned. I'm going to leave it in because this is a great
    learning experience for us. It also shows you that even if you're an experienced
    programmer, you're going to make mistakes. One of the reasons why we should use
    typed ArrayLists whenever we can, for example, is so that we can easily figure
    out and fix our mistakes.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing ArrayIndexOutOfBoundsException
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our program has thrown an `ArrayIndexOutOfBoundsException`. This means that
    we tried to access memory that our `memory` array did not have access to. Specifically,
    we tried to look at what was at the index `-1` of the array. Since arrays start
    at index `0`, they don't have anything at index `-1`. Any piece of our computer's
    memory could be there, and for security reasons, programs aren't allowed to just
    go looking through a computer's memory because they want to. So, why did this
    happen? Why did we ask for index `-1` of an array, which is never going to be
    a valid array index?
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Well, our first `if` statement that implemented the functionality to clear our
    ArrayList executed just fine. Our program saw our `CLEAR` command, understood
    our first look at our array index, and cleared the array.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Immediately following this, we asked our program to again check the last item
    added to our array, using the second `if` statement. When we did this, we executed
    `memory.size()-1`. First, we asked Java about the size of our ArrayList. Because
    we just cleared our ArrayList, Java told us that the size of the ArrayList was
    zero, that there was nothing in it. Then we subtracted one from that value to
    get -1\. Post this, we ran `memory.get()` on that `-1` value. Thus, we asked Java
    to take a look at what was at index `-1` of our array, at which point Java said,
    "Whoa! What are you doing? It's not cool, I'm going to crash!"
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: So, how do we solve this? Well, there's a couple of things we could do. We should
    probably just check and make sure that our arrays are not empty before we run
    the functions in the second `if` statement. That option looks like a few more
    lines of code than I want to put. It's not undoable in any sense of the word,
    and I encourage you to try and implement a better solution than this yourself.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, just to get our program quickly up and running without crashing, let''s
    change the pair of `if` blocks to an `if...else` statement as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We've embedded the second `if` statement in the `else` block. This will prevent
    us from ever running both of the `if` blocks back to back. If our first `if` statement
    evaluates to be true and our clear statement gets executed, then we will not check
    for the second `if` statement.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we run our program and give some gibberish input to build up our ArrayList,
    and then type in `CLEAR`, we''re going to properly get the response of an empty
    ArrayList:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7adf9ca8-08b9-4c14-9d90-873227e545ea.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
- en: We'll never hit the second `if` statement with an array of size `0` because
    we're always going to add a line to our array beforehand.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s cross our fingers and check that the `END` input works:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4da83cb8-0be7-42ee-998b-1fb11670670b.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: It does! The break command breaks specifically out of loops and functions, so
    even though we've nested it within an if and else statement, it's still going
    to break us out of the `while` loop.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: I think that little trip up we had was a great learning experience. That's actually
    a pretty interesting error we ran into. Nonetheless, I hope you've seen how different
    data structures have different purposes.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Maps
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''re going to take a look at Java''s `Map` data structure.
    I wanted to start with a bunch of already formatted information, so I have created
    a little program on my own. You will find the following program in the companion
    files for the book. Take a look through it and make sure you understand how it
    works:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: I'm operating on the assumption that we're not yet familiar with file input
    and output, so I dropped all of the data that we'd normally want to store in a
    file, or somewhere more manageable, right in the code of our program. I have created
    a `String` array that I've called `allNames`, and what it is a list of names of
    famous people. Their individual first and last names are also divided. So `Jane`,
    `Addams` comprises the first two elements of the array. Her first name `Jane`
    is part of `allNames[0]`, and then `Addams`, her last name, is at `allNames[1]`,
    and so on, with every two elements in the array being a single person's first
    and last name.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'This is also a good chance for me to show you a nifty little NetBeans feature
    that''s available in most IDEs. We can talk to our IDEs often if they support
    features such as these by putting instructions for them in the comments of our
    code. Because these instructions are commented out, they won''t in any way affect
    the way our Java code compiles and runs, but we can talk to the IDE. The following
    instruction in the program, paired with its ending instruction, tells NetBeans
    that we''d like it to section off the code included between them:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we can use the little box on the left-hand side of our opening instruction
    to expand and contract the block of code as shown in the following screenshots:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/abf0f56c-f800-4b58-ac72-23308b838434.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
- en: 'It doesn''t make the code go away; it just hides it from us so that we can
    develop it without cluttering up our screen:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7535308f-d7b1-46cf-8b1a-43623e9b0262.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s look at a very quick explanation of the program I''ve written to
    start this section off. We have an array of strings called `allNames` that contains
    the first and last names of a bunch of famous people. The program I''ve written
    simply loops through this array and determines whether it''s looking at the first
    or last name. Then it places those names in separate arrays of their own. At the
    end, when we print out these arrays, we have two separate arrays: one of first
    names and one of last names. The relationship of these arrays, because we''ve
    placed them into the two separate arrays (`firstNames` and `lastNames`) in order,
    is that the indexes of the arrays match up. So, at `firstNames[0]` and `lastNames[0]`,
    we have the first and last names of Jane Addams.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'What I''d like to do now is expand this program and place all of this information
    in a single data structure: a Java `Map`. While creating such a Map, we let it
    know the relationship between one set, which we call the keys, and the other set,
    which we call the values, so that each key maps to the value. This will allow
    us to ask our program questions, such as, "Given a famous person''s last name,
    what is the first name that is associated with it?"'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Map
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin, I''ve gone ahead and imported `java.util` where the `Map` interface
    lives. Next, I''ll get rid of the last two `println` statements that prints the
    `firstNames` and `lastNames` arrays. Instead, at this point in our code, when
    our `firstNames` and `lastNames` arrays have been set up, let''s start constructing
    our `Map`. For this, add the following line of code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We begin by using the `Map` keyword and then, as with most data structures,
    we tell Java what type of information our `Map` is going to take. Maps take two
    sets of information, so we'll have to give it two information types that are comma-separated.
    The first information type is the information type for the Map's keys, and the
    second information type is the type for the Map's values.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: We're going to use `lastNames` as our keys because we don't want our `Map` to
    store multiple values in one key, and it's much less likely that we're going to
    have multiple identical last names. Additionally, it's a lot more valuable for
    us to ask for the first name of the famous person named Addams, rather than the
    last name of the famous person named Jane, of which there are probably more. Anyway,
    the data type of `lastNames` is `String`, and the data type of `firstNames` is
    `String`, as well.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we give our new `Map` variable a name: `famousPeople`. Then, we cause
    our `Map` to come into being by instantiating it. To do this, we use the `new`
    keyword. `Map` is not an object, actually, it''s what we call an interface. For
    the most part, we interact with interfaces and objects the same way, but we cannot
    simply declare an instance of an interface. Rather, interfaces are additional
    wrappings of functionality that we place on top of objects, in the way that ArrayLists
    add additional functionality to arrays.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: So, to create a new `Map`, we need a simpler type of object that we can wrap
    the `Map` interface around. A great candidate for this is the `HashMap`. Therefore,
    we create our `HashMap` and assign our Map variable `famousPeople` to it. We'll
    now interact with this `famousPeople` variable just as if it were an object with
    all of the `Map` functionality. Additionally, if we would like, we could call
    only the `HashMap` functionality on this object as well.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'While it''s a little out of the scope of this particular section, the power
    of interfaces is that we can assign them to objects of different types, giving
    common functionalities to otherwise distinct object types. But, for now, we''re
    mostly just interested in the power and function of Java Maps. You''ll notice
    that we didn''t have to explicitly tell Java what type our `HashMap` was going
    to take. This is a stylistic choice really; if we wanted to, we could explicitly
    declare the types that the `HashMap` would take:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: However, since we're only going to interact with our `HashMap` in terms of its
    functionality as a `Map`, simply protecting us from adding anything but strings
    when we interact with our `HashMap` through the variable `famousPeople`, which
    is currently our only way to access it, should be just fine.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Assigning values to our Map
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we set up our `Map`, it''s time for us to go through and fill it with
    information. For this, I think a `for` loop will be appropriate:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We're going to need to add a number of pairs of information to our Map, that
    is, one key and one value, equal to the number of items in either of these arrays.
    This is because they both have the same length. So let's set up a `for` loop that
    iterates through every index from `i` to the length of (`lastNames-1`). The `i`
    values will map to the indexes of the `lastNames` array, and because the `firstNames`
    array has the same length as the `lastNames` array, they will map to the indexes
    of the `firstNames` array as well.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Now, for each `i`, we're going to execute our Map's `put()` function. The `put()`
    function is similar to the `add()` function. It inserts information into our map.
    However, this function expects two pieces of information. First, it expects our
    key, which is the value we're currently looking at in `lastNames`, and then it
    expects the associated value, which is the value we're looking at in `firstNames`.
    Each time we execute the `famousPeople.put(lastNames[i], firstNames[i]);` line
    of code in our `for` loop, we'll be adding a new key value pair to our `Map`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Fetching information from our Map
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we''ve set up the `Map`, with all our information already in our program,
    all we need to do is ask it some questions and make sure we get the right responses:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We use the `get()` function to ask our `Map` the basic question that it''s
    designed to answer, "What is the value paired with a given key?" So, let''s ask
    our `Map`, "What is the value paired with `Addams`?", or in more understandable
    English terms, "What is the first name of the person in our Map whose last name
    is `Addams`?" When we run this program, we get the expected result, that is, `Jane`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0df094d6-336d-4e4a-8b59-fef66961165b.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
- en: 'Let''s just run it one more time to make sure we haven''t made any silly mistakes.
    Let''s see whether our program answers `Frank` when we input `Sinatra`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Indeed it does!
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e045ad4-f16e-4761-865b-25557362080d.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
- en: While it's possible for us to write a program like this by simply looping through
    our arrays when we get user input (finding `lastName`, storing that index, and
    getting it from `firstNames`), our Map interface essentially does that for us.
    Perhaps, more importantly than this, when we're working with other programmers
    or looking at code that we didn't write just yesterday, and we see a `Map`, we
    understand immediately its intended purpose and what functionality it implements.
    In almost all cases, just writing code that works is equally important because
    it makes sense and will be understood by others who might come across the code
    in the future.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at arrays and an example that printed the English
    alphabet by using an array. Next, we looked at multidimensional arrays and wrote
    a program that created a two-dimensional chessboard.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: We walked through what an ArrayList is and how it enhances the functionality
    of arrays. We also wrote a program using an ArrayList with functionality, which
    would have been quite difficult to implement using an array. Finally, we looked
    at Maps and implemented an example to understand this better.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at Java functions in detail.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
