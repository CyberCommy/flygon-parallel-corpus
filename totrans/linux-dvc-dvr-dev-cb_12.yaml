- en: 'Additional Information: Advanced Char Driver Operations'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we have to manage a peripheral, it's quite common to need to modify its
    internal configuration settings, or it may be useful to map it from the user space
    as if it was a memory buffer in which we can modify internal data just by referencing
    a pointer.
  prefs: []
  type: TYPE_NORMAL
- en: For example, frame buffers or frame grabbers are good candidates to be mapped
    as a big chunk of memory from the user space point of view.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, having the support of the `lseek()`, `ioctl()`, and `mmap()` system
    calls is fundamental. If, from the user space, the usage of these system calls
    is not tricky, within the kernel they require some attention by the driver developer,
    especially the `mmap()` system call, which involves the kernel **Memory Management
    Unit** (**MMU**).
  prefs: []
  type: TYPE_NORMAL
- en: Not only that one of the principal tasks a driver developer must pay attention
    to is the data exchanging mechanism with the user space; in fact, realizing a
    good implementation of this mechanism may simplify a lot of the peripheral's management.
    Using read and write memory buffers, for example, may increase the system performance
    when one or more processes get access to the peripheral, giving to the userspace
    developer a good range of setup and management mechanisms to allow them to get
    the maximum from our hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Going up and down within a file with lseek()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here we should remember that the prototypes of the `read()` and `write()` system
    calls were the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When we tested our char driver using the program in the `chapter_03/chrdev_test.c`
    file, we noticed that we weren''t able to reread written data unless we patched
    our file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: That was without closing and then reopening the file connected with our driver
    (in this manner, the kernel automatically resets the value pointed by `ppos` to
    `0`).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this is not the only way to modify the value pointed by `ppos;` in
    fact, we can also use the `lseek()` system call to do it. The prototype of the
    system call, as reported by its man page (`man 2 lseek`), is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `whence` parameter can assume the following values (represented by
    definitions in the following code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'So, for instance, if we wish to move `ppos` to point to the beginning of our
    device''s data buffer as we did in [Chapter 3](1625d420-d3d6-4655-9f08-050a8bb99c90.xhtml), *Working
    with Char Drivers*, but without closing and the reopening the device file, we
    can do so as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that all these modifications are stored in `modify_lseek_to_chrdev_test.patch`
    file from GitHub repository and they can be applied by using the next command
    within the `chapter_03` directory, where the file `chrdev_test.c` is located:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`$ patch -p2 < ../../chapter_07/modify_lseek_to_chrdev_test.patch`**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take a look at the `linux/include/uapi/linux/fs.h` header file, we can
    see how these definitions are declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `lseek()` implementation is so trivial that in the `linux/fs/read_write.c` file we
    can find a default implementation of this method named `default_llseek()`. Its
    prototype is reported as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because if we don''t specify our own implementation, then the kernel
    will automatically use the one in the preceding code block. However, if we take
    a quick look at the `default_llseek( )` function, we notice that it''s not suitable
    for our device because it''s too *file-oriented* (that is, it works well when
    the file against which the `lseek()` operates on is a real file and not a peripheral),
    so we can instead use one of the two next alternative implementations for `lseek()` to
    perform no operations, by using the `noop_llseek()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we can just return an error, and then signal the user space that our device
    is not suitable to be sought by using the  `no_llseek()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The two preceding functions are located in the `linux/fs/read_write.c` file of
    the kernel sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'The different usage of these two functions is well described by the comment
    above regarding `noop_llseek()`; while `default_llseek()` is not usually suitable
    for a char device, we can simply use `no_llseek()` or, in those rare special cases
    when the user space expects the seek to succeed, but the (device) file is actually
    unable to perform the seek, we can use `no_llseek()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This piece of code is referred to by the chrdev character driver as discussed
    in [Chapter 4](5f22a69e-e8b7-402e-8e67-72938d00c914.xhtml), *Using the Device
    Tree*, within the  `chapter_04/chrdev/chrdev.c` file on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Using ioctl() for custom commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](https://cdp.packtpub.com/linux_device_driver_development_cookbook/wp-admin/post.php?post=30&action=edit#post_26), *W**orking
    with Char Drivers*, we discussed the file abstraction and mentioned that a char
    driver is very similar to a usual file, from the user space point of view. However,
    it's not a file at all; it is used as a file but it belongs to a peripheral, and,
    usually, peripherals need to be configured to work correctly, due to the fact
    they may support different methods of operation.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider, for instance, a serial port; it looks like a file where we can (forever) read
    or write using both the `read()` and `write()` system calls, but to do so, in
    most cases, we must also set some communication parameters such as the baud rate,
    parity bit, and so on. Of course, these parameters can't be set with `read()` or `write()`,
    nor by using the `open()` system call (even if it can set some accessing modes
    as read or write only), so the kernel offers us a dedicated system call that we
    can use to set such serial communication parameters. This system call is the `ioctl()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the userspace point of view, it looks like its man page (available by
    using the `man 2 ioctl `command):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As stated in the preceding paragraph, the `ioctl()` system call manipulates
    the underlying device parameters of special files (as with our char devices, but
    not only this in fact, it can be used on net or block devices too) by taking,
    as the first argument, the file descriptor (obtained by opening our device), and
    as the second argument, a device-dependent request code. Finally, as the third
    and optional argument, an untyped pointer to memory that userspace programmers
    can use to exchange data with the driver.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, thanks to this general definition, a driver developer can implement their
    custom commands to manage the underlying device. Even if not strictly required,
    an `ioctl()` command has encoded in it whether the argument is an in parameter
    or out parameter, and the size of the third argument in bytes. Macros and definitions
    used to specify an `ioctl()` request are located in the  `linux/include/uapi/asm-generic/ioctl.h` file, as
    reported in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As we can also read in the preceding comment, the `read()` and `write()` operations
    are from the user space point of view, so when we mark a command as *writing* we
    mean that the userspace is writing and the kernel is reading, while when we mark
    a command as *reading* we mean exactly the inverse.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a really simple example about how to use these macros, we can take a look
    at an implementation regarding watchdogs within the file `linux/include/uapi/linux/watchdog.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: A watchdog (or watchdog timer) is usually used in automated systems. It is an
    electronic timer that is used to detect and recover from computer malfunctions.
    In fact, during its normal operation, a process in the system should regularly
    reset the watchdog timer to prevent it from timing out so, if due to a hardware
    fault or program error, the system fails to reset the watchdog, the timer will
    elapse, and the system automatically restarts.
  prefs: []
  type: TYPE_NORMAL
- en: Here we have the definition of some commands to manage watchdog peripherals,
    each of them defined using the  `_IOR()` macro (used to specify a reading command)
    or the  `_IOWR` macro (used to specify a read/write command). Each command has
    a progressive number followed by the type of data pointed to by the third argument,
    which can be a simple type (as with the preceding `int` type) or a more complex
    one (as with the preceding `struct watchdog_info`). Finally, the `WATCHDOG_IOCTL_BASE` common
    parameter is simply used to add a random value to avoid command duplication.
  prefs: []
  type: TYPE_NORMAL
- en: Usage of the `type` parameter (`WATCHDOG_IOCTL_BASE` in the preceding example)
    in these macros will be more clear later when we're going to explain our example.
  prefs: []
  type: TYPE_NORMAL
- en: Of course this is a pure convention, we can simply use progressive integer numbers
    to define our `ioctl()` commands and it will work perfectly anyway; however, by
    acting this way, we will embed into the command code a lot of useful information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once all commands are defined, we need to add our custom `ioctl()` implementation,
    and by taking a look at the `struct file_operations` in the `linux/include/linux/fs.h`,
    file we see that there exist two of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In kernels older than 2.6.36, there was only one `ioctl()` method that acquired
    the **Big Kernel Lock** (**BKL**), so nothing else could execute at the same time.
    This led to very bad performance on a multiprocessor machine, so there was a big
    effort to get rid of it, which is why `unlocked_ioctl()` was introduced. By using
    it, each driver developer can choose which lock to use instead.
  prefs: []
  type: TYPE_NORMAL
- en: On the other side, `compat_ioctl()`, even though it was added at the same time,
    is actually unrelated to `unlocked_ioctl()`. Its purpose is to allow 32-bit userspace
    programs to make `ioctl()` calls on a 64-bit kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we should first note that the commands and structure definitions must
    be used in both user and kernel spaces, so when we define the exchanged data types,
    we must use those data types available to both spaces (that's why the  `__u32` type has
    been used instead of `u32`, which actually only lives inside the kernel).
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, when we wish to use custom `ioctl()` commands, we must define them
    into a separate header file, which must be shared with the user space; in this
    manner, we can keep kernel codes separate from the userspace. However, just in
    case it was difficult to separate all userspace codes from the kernel space, we
    can use the  `__KERNEL__`definition as in the following snippet to instruct the
    preprocessor to exclude some code according to the space we are compiling into:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: That's why, usually, header files holding `ioctl()` commands are usually located
    under the `linux/include/uapi` directory, which holds all header files needed
    by userspace programs for compilation.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing I/O memory with mmap()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Getting access to I/O memory* recipe in [Chapter 6,](https://cdp.packtpub.com/linux_device_driver_development_cookbook/wp-admin/post.php?post=30&action=edit#post_29) *Miscellaneous
    Kernel Internals,* we saw how the MMU works and how we can get access to a memory-mapped
    peripheral. Within the kernel space, we must instruct the MMU in order to correctly
    translate a virtual address into a proper one, which must point to a well-defined
    physical address to which our peripheral belongs, otherwise, we can't control
    it!
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, in that section, we also used a userspace tool named `devmem2`, which
    can be used to get access to a physical address from the user space, using the `mmap()` system
    call. This system call is really interesting, because it allows us to do a lot
    of useful things, so let''s start by taking a look at its man page (`man 2 mmap`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the preceding snippet, by using `mmap()` we can create a new
    mapping in the virtual address space of the calling process, which can be related
    to the file descriptor, `fd`, passed as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, this system call is used to map a normal file within the system memory
    in such a way that it can be then addressed using a normal pointer and not by
    the usual `read()` and `write()` system calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as a simple example, let''s consider a usual file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a normal text file holding three lines of text. We can read and write
    it on our Terminal just using the `cat` command as stated previously; of course,
    we now know that the `cat` command runs an `open()` and then one or more `read()` operation on
    the file, followed by one or more `write()` operation on the standard output (which,
    in turn, is a file abstraction connected to our terminal). However, this file
    can also be read as it was a memory buffer of chars, using the `mmap()` system
    call, and this can be done through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: A complete code implementation of the preceding example will be presented in
    the following snippet. This is a snippet of the `chrdev_mmap.c` file.
  prefs: []
  type: TYPE_NORMAL
- en: So, as we can see, we first opened the file as usual, but then, instead of using
    the `read()` system call, we did a `mmap()` and, finally, we used the returned
    memory address as a char pointer to print out the memory buffer. Note that after
    the `mmap()` we'll have something like an image of the file within the memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to execute the preceding code on the `textfile.txt `file, we get
    what we expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note that I used the `ls` command to get the file length needed by the `chrdev_mmap`
    program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we should ask ourselves whether there is a way to map a character device
    (which looks very similar to a file from the user space point of view) as we did
    for the text file above; obviously, the answer is yes! We have to use the `mmap()` method
    defined in `struct file_operations` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Besides the usual `struct file` pointer that we already perfectly know, this
    function requires the `vma` argument (which is a pointer to `struct vm_area_struct`)
    used to indicate a virtual address space, in which the memory should be mapped
    by the driver.
  prefs: []
  type: TYPE_NORMAL
- en: A struct `vm_area_struc`t holds information about a contiguous virtual memory
    area, which is characterized by a start address, a stop address, length, and permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Each process owns more virtual memory areas, which can be inspected by looking
    at the relative procfs file named `/proc/<PID>/maps` (where `<PID>` is the PID
    number of the process).
  prefs: []
  type: TYPE_NORMAL
- en: The virtual memory areas are a really complex part of Linux memory manager,
    which is not covered in this book. Curious readers can take a look at [https://www.kernel.org/doc/html/latest/admin-guide/mm/index.html](https://www.kernel.org/doc/html/latest/admin-guide/mm/index.html)
    for further information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The mapping of a physical address to the user address space, as indicated by
    the `vma` parameter, can be easily done using helper functions such as `remap_pfn_range()`, defined
    in the header file `linux/include/linux/mm.h` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'It will map a contiguous physical address space addressed by `pfn` into the
    virtual space represented by the `vma` pointer. In particular, the parameters
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`vma` - The virtual memory space in which mapping is made'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addr` - The virtual address space from where remapping begins'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pfn` - The physical address (expressed in terms of page frame number) to which
    the virtual address should be mapped'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size` - The size in bytes of the memory to be mapped'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prot` - Protection flags for this mapping'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, a really simple `mmap()` implementation, considering a peripheral as having
    a memory area at physical address `base_addr` and size of `area_len`, can be done
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As a final note, we have to keep in mind that `remap_pfn_range()` works with
    a physical address, while memory allocated using `kmalloc()` or `vmalloc()` functions
    and friends (see [Chapter 6](https://cdp.packtpub.com/linux_device_driver_development_cookbook/wp-admin/post.php?post=30&action=edit#post_29), *Miscellaneous
    Kernel Internals*) must be managed using a different approach. For `kmalloc()`,
    we can use something like the following to get the `pfn` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Where kvirt is the kernel virtual address to be remapped returned by `kmalloc()`,
    for `vmalloc()` we can do as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, `vvirt` is the kernel's virtual address to be remapped returned by `vmalloc()`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the memory allocated with `vmalloc()` is not physically contiguous,
    so if we want to map a range allocated with it we have to map each page individually
    and compute the physical address for each page. This is a more complicated action,
    which is not explained in this book due to the fact that it's not device-driver
    related (real peripherals only use physical addresses).
  prefs: []
  type: TYPE_NORMAL
- en: Locking with the process context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's good to understand how to avoid race conditions in case more than one process
    tries to get access to our driver, or how to put to sleep a reading process (we
    talk about reading here, but the same thing also holds true for writing) in case
    our driver has no data to supply. The former case will be presented here, while
    the latter will be presented in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: If we take a look at how `read()` and `write()` system calls have been implemented
    in our chrdev driver, we can easily notice that, if more than one process tries
    to do a `read()` call or even if one process attempts a `read()` call and another
    tries a `write()` call, a race condition will occur. This is because the ESPRESSObin's
    CPU is a multiprocessor composed of two cores and so it can effectively execute
    two processes at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: However, even if our system had just one core, it still may happen that `read()` or `write()` code
    inside these methods' critical sections is executed in an interleaved (that is
    non-atomic) manner due to the fact that, for instance, functions `copy_to_user()` and `copy_from_user()` may
    put to sleep the calling process and so the scheduler may revoke the CPU to one
    of them in favor of another process, which, in turn, calls again into the same
    driver's  `read()` or `write()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid possible race conditions in these situations, a really reliable solution
    is using a mutex as presented in [Chapter 5](cbd6e9f7-f07c-46b8-b751-ece44101ca8b.xhtml), *Managing
    Interrupts and Concurrency*.
  prefs: []
  type: TYPE_NORMAL
- en: We simply need a mutex for each chrdev device to protect multiple access to
    the driver's methods.
  prefs: []
  type: TYPE_NORMAL
- en: Waiting for I/O operations with poll() and select()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a complex system such as a modern computer, it's quite common to have several useful peripherals
    to acquire information about the external environment and/or the system's status.
    Sometimes, we may use different processes to manage them but we may need to manage
    more than one peripheral at a time, but with just a single process.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this scenario, we can imagine doing several `read()` system calls on each
    peripheral to acquire its data, but what happens if one peripheral is quite slow
    and it takes a lot of time to return its data? If we do the following, we may
    slow down all data acquisition (or even lock it if one peripheral doesn''t receive
    new data):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In fact, if one peripheral is slow, or if it takes a long time to return its
    data, our loop will be stopped to wait for it and our program may not work correctly.
  prefs: []
  type: TYPE_NORMAL
- en: One possible solution may be to use the `O_NONBLOCK` flag on the offending peripheral,
    or even on all peripherals, but doing this we may overload the CPU with unnecessary
    system calls. It could be more elegant (and efficient) to ask the kernel to tell
    us which file descriptor belongs to peripheral holding data ready to be read (or
    free to be used for a write).
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we can use the `poll()` or `select()` system calls. The `poll()` man
    page states the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `select()` man page, on the other hand, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Even if they look quite different, they do almost the same things; in fact,
    inside the kernel, they are implemented by using the same `poll()` method, which
    is defined inside the well-known `struct file_operations` as follows (see the
    `linux/include/linux/fs.h` file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'From the kernel''s point of view, the implementation of the `poll()` method
    is really simple; we just need the waitqueue we used above and then we have to
    verify whether our device has some data to return. Simply speaking, a generic `poll()` method
    is like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We simply have to use the  `poll_wait()` function to tell the kernel which waitqueue
    the driver uses to put reading or writing processes to sleep, and then we return
    the variable `mask` equal to 0; if no data is ready to be read or we cannot accept
    new data to write, we return the `EPOLLIN | EPOLLRDNORM` value if there is something
    to read bitwise and if we're willing to accept that data, too.
  prefs: []
  type: TYPE_NORMAL
- en: All of the available `poll()` events are defined in the header file `linux/include/uapi/linux/eventpoll.h`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the `poll()` method has been implemented, we can use it, for instance,
    with `select()` as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: After opening all of the needed file descriptors, we have to use the `FD_ZERO()` macro to
    clean the `read_fds` variable and then we use the  `FD_SET()` macro to add each
    file descriptor to the set of the reading process represented by `read_fds`. When
    done we can pass `read_fds` to `select()` to point out to the kernel which file
    descriptors are to be observed.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, usually, we should pass, as the first parameter of the `select()` system
    call, the highest number plus 1 of the file descriptors within the observed set;
    however, we can also pass the `FD_SETSIZE` value, which is the maximum allowed
    value permitted by the system. This can be a very large value, so programming
    this way leads to inefficiency in scanning the whole file descriptor bitmap; good
    programmers should use the maximum value plus 1 instead.
  prefs: []
  type: TYPE_NORMAL
- en: Note, also, that our example is valid for reading, but exactly the same can
    be used for writing!
  prefs: []
  type: TYPE_NORMAL
- en: Managing asynchronous notifications with fasync()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we considered the special case in which we can have
    a process that must manage more than one peripheral. In this situation, we can
    ask the kernel, which is the ready file descriptor, where to get data from or
    where to write data to using the `poll()` or `select()` system call. However,
    this is not the only solution. Another possibility is to use the `fasync()` method.
  prefs: []
  type: TYPE_NORMAL
- en: By using this method, we can ask the kernel to send a signal (usually `SIGIO`)
    whenever a new event has occurred on a file descriptor; the event, of course,
    is a ready-to-read or read-to-write event and the file descriptor is the one connected
    with our peripheral.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fasync()` method does not have a userspace counterpart due to the already
    presented methods in this book; there is no `fasync()` system call at all. We
    can use it indirectly by utilizing the `fcntl()` system call. If we take a look
    at its man pages, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s do one step at a time. From the kernel point of view, we have to
    implement the `fasync()` method, which is defined, as usual, within `struct file_operations` as
    below (see the `linux/include/linux/fs.h` file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Its implementation is really trivial because by using the `fasync_helper()`
    helper function, the only steps we need are reported for a generic driver in the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Where `fasync_queue` is a pointer of a `struct fasync_struct` that the kernel
    uses to enqueue all processes interested in receiving the `SIGIO` signal whenever
    the driver is ready for reading or writing operations. These events are notified
    using the  `kill_fasync()` function, usually within an interrupt handler or whenever
    we know that new data has arrived or we are ready to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have to use `POLL_IN` when data is available to read, while we
    should use `POLL_OUT` when our peripheral is ready to accept new data.
  prefs: []
  type: TYPE_NORMAL
- en: Please see the  `linux/include/uapi/asm-generic/siginfo.h` file for all available `POLL_*` definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the userspace point of view, we need to take some steps to achieve the `SIGIO` signal:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we have to install a proper signal handler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we have to call `fcntl()` with the  `F_SETOWN` command to set the process
    ID (usually called a PID) that will receive the `SIGIO` related to our device
    (addressed by the file descriptor `fd`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we have to alter the `flags` describing the file access mode by setting
    the `FASYNC` bit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A possible implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
