- en: Platform Device Drivers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We all know about plug and play devices. They are handled by the kernel as soon
    as they are plugged in. These may be USB or PCI express, or any other auto-discovered
    devices. Therefore, other device types also exist, which are not hot-pluggable,
    and which the kernel needs to know about prior to being managed. There are I2C,
    UART, SPI, and other devices not wired to enumeration-capable buses.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are real physical buses you may already know: USB, I2S, I2C, UART, SPI,
    PCI, SATA, and so on. Such buses are hardware devices named controllers. Since
    they are a part of SoC, they can''t be removed, are non-discoverable, and are
    also called platform devices.'
  prefs: []
  type: TYPE_NORMAL
- en: People often say platform devices are on-chip devices (embedded in the SoC).
    In practice, it is partially true, since they are hard-wired into the chip and
    can't be removed. But devices connected to I2C or SPI are not on-chip, and are
    platform devices too, because they are not discoverable. Similarly, there may
    be on-chip PCI or USB devices, but they are not platform devices, because they
    are discoverable.
  prefs: []
  type: TYPE_NORMAL
- en: From an SoC point of view, those devices (buses) are connected internally through
    dedicated buses, and are most of the time proprietary and specific to the manufacturer.
    From the kernel point of view, these are root devices, and connected to nothing.
    That is where the *pseudo platform bus* comes in. The pseudo platform bus, also
    called platform bus is a kernel virtual bus for devices that do not seat on a
    physical bus known to the kernel. In this chapter, platform devices refer to devices
    that rely on the pseudo platform bus.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dealing with platform devices essentially requires two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Register a platform driver (with a unique name) that will manage your devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register your platform device with the same name as the driver, and their resources,
    in order to let the kernel know that your device is there
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That being said, in this chapter, we will discuss the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Platform devices along with their driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Devices and driver-matching mechanisms in the kernel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering platform drivers with devices, as well as platform data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Platform drivers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before going further, please pay attention to the following warning. Not all
    platform devices are handled by platform drivers (or should I say pseudo platform
    drivers). Platform drivers are dedicated to devices not based on conventional
    buses. I2C devices or SPI devices are platform devices, but respectively rely
    on I2C or SPI buses, not on the platform bus. Everything needs to be done manually
    with the platform driver. The platform driver must implement a `probe` function,
    called by the kernel when the module is inserted or when a device claims it. When
    developing platform drivers, the main structure one has to fill is `struct platform_driver`
    , and registering your driver with the platform bus core with dedicated functions
    shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us see what the meaning is of each element that composes the structure,
    and what they are used for:'
  prefs: []
  type: TYPE_NORMAL
- en: '`probe()` : This is the function that gets called when a device claims your
    driver after a match occurs. Later, we will see how `probe` is called by the core.
    Its declaration is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`remove()` : This is called to get rid of the driver when it is not needed
    anymore by devices, and its declaration looks like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`struct device_driver` : This describes the driver itself, providing a name,
    owner, and some field, which we will see later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Registering a platform driver with the kernel is as simple as calling `platform_driver_register()`
    or `platform_driver_probe()` in the `init` function (when the module is loaded).
    The difference between those functions is that:'
  prefs: []
  type: TYPE_NORMAL
- en: '`platform_driver_register()` registers and puts the driver into a list of drivers
    maintained by the kernel, so that its `probe()` function can be called on demand
    whenever a new match occurs. To prevent your driver from being inserted and registered
    in that list, just use the `next` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With `platform_driver_probe()` , the kernel immediately runs the match loop,
    checks if there is a platform device with the matching name, and then calls the
    driver''s `probe()` if a match occurred, meaning that the device is present. If
    not, the driver is ignored. This method prevents the deferred probe, since it
    does not register the driver on the system. Here, the `probe` function is placed
    in an `__init` section, which is freed when the kernel boot has completed, thus
    preventing the deferred probe and reducing the driver''s memory footprint. Use
    this method if you are 100% sure the device is present in the system:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a simple platform driver that registers itself with the kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Our module does nothing else in the `init` /`exit` function but register/unregister
    with the platform bus core. This is the case with most drivers. In this case,
    we can get rid of `module_init` and `module_exit` , and use the `module_platform_driver`
    macro.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `module_platform_driver` macro looks like as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This macro will be responsible for registering our module with the platform
    driver core. No need for `module_init` and `module_exit` macros, nor `init` and
    `exit` function anymore. It does not mean that those functions are not called
    anymore, just that we can forgot writing them by ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: The `probe` function is not a substitute to `init` function. The `probe` function
    is called every time when a given device matches with the driver, whereas the
    `init` function runs only once, when the module gets loaded.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'There are specific macros for each bus that one needs to register the driver
    with. The following list is not exhaustive:'
  prefs: []
  type: TYPE_NORMAL
- en: '`module_platform_driver(struct platform_driver)` for platform drivers, dedicated
    to devices that do not sit on conventional physical buses (we just used it above)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`module_spi_driver(struct spi_driver)` for SPI drivers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`module_i2c_driver(struct i2c_driver)` for I2C drivers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`module_pci_driver(struct pci_driver)` for PCI drivers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`module_usb_driver(struct usb_driver)` for USB drivers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`module_mdio_driver(struct mdio_driver)` for mdio'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[...]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you don't know which bus your driver needs to sit on, then it is a platform
    driver, and you should use `platform_driver_register` or `platform_driver_probe`
    to register the driver.
  prefs: []
  type: TYPE_NORMAL
- en: Platform devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Actually, we should have said pseudo platform device, since this section concerns
    devices that sit on pseudo platform buses. When you are done with the driver,
    you will have to feed the kernel with devices needing that driver. A platform
    device is represented in the kernel as an instance of `struct platform_device`
    , and looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When it comes to the platform driver, before driver and device match, the `name`
    field of both `struct platform_device` and `static struct platform_driver.driver.name`
    must be the same. The `num_resources` and `struct resource *resource` field will
    be covered in the next section. Just remember that, since `resource` is an array,
    `num_resources` must contain the size of that array.
  prefs: []
  type: TYPE_NORMAL
- en: Resources and platform data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the opposite end to hot-pluggable devices, the kernel has no idea of what
    devices are present on your system, what they are capable of, or what they need
    in order to work properly. There is no auto-negotiation process, so any information
    provided to the kernel would be welcome. There are two methods to inform the kernel
    about the resources (irq, dma, memory region, I/O ports, buses) and data (any
    custom and private data structure you may want to pass to the driver) that the
    device needs which are discussed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Device provisioning - the old and depreciated way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This method is to be used with the kernel version that does not support device
    tree. With this method, drivers remain generic, and devices are registered in
    board-related source files.
  prefs: []
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Resources represent all the elements that characterize the device from the
    hardware point of view, and which the device needs, in order to be set up and
    work properly. There are only six types of resources in the kernel, all listed
    in `include/linux/ioport.h` , and used as flags to describe the resource''s type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'A resource is represented in the kernel as an instance of `struct resource`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us explain the meaning of each element in the structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`start/end` : This represents where the resource begins/ends. For I/O or memory
    regions, it represents where they begin/end. For IRQ lines, buses or DMA channels,
    start/end must have the same value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flags` : This is a mask that characterizes the type of resource, for example
    `IORESOURCE_BUS` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name` : This identifies or describes the resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once one has provided the resources, one needs to extract them back in the
    driver in order to work with them. The `probe` function is a good place to extract
    them. Before one goes further, let''s remember the declaration of the `probe`
    function for a platform device driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`pdev` is automatically filled by the kernel, with the data and resource we
    registered earlier. Let''s see how to pick them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `struct resource` embedded in `struct platform_device` can be retrieved
    with the `platform_get_resource()` function. The following is the prototype of
    `platform_get_resource` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter is an instance of the platform device itself. The second
    parameter tells what kind of resource we need. For memory, it should be `IORESOURCE_MEM`
    . Again, please have a look at `include/linux/ioport.h` for more details. `num`
    parameter is an index that says which resource type is desired. Zero indicates
    the first one, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the resource is an IRQ, we must use `int platform_get_irq(struct platform_device
    * pdev, unsigned intnum)` , where `pdev` is the platform device, and `num` is
    the IRQ index within the resource (in case there is more than one). The whole
    `probe` function which we can use to extract the platform data which we registered
    for our device can look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Platform data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Any other data whose type is not a part of the resource types enumerated in
    the preceding section fall here (for example, GPIO ). Whatever their type is,
    the `struct platform_device` contains a `struct device` field, which in turn contains
    a `struct platform_data` field. Usually, one should embed that data in a structure
    and pass it to the `platform_device.device.platform_data` field. Let''s say, for
    example, that you declare a platform device that needs two gpios number as platform
    data, one irq number, and two memory regions as resource. The following example
    shows how to register platform data along with the device. Here, we use `platform_device_register(struct
    platform_device *pdev)` function, which one uses to register a platform device
    with the platform core:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have used `IORESOURCE_IRQ` and `IORESOURCE_MEM`
    in order to inform the kernel about what kind of resource we provided. To see
    all other flag types, have a look at `include/linux/ioport.h` in the kernel tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to retrieve the platform data we registered earlier, we could have
    just used `pdev->dev.platform_data` (remember the `struct platform_device` structure),
    but it is recommended to use the kernel-provided function (which does the same
    thing, admittedly):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Where to declare platform devices?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Devices are registered along with their resources and data. In this old and
    depreciated method, they are declared a separate module, or in the board `init`
    file in the `arch/<arch>/mach-xxx/yyyy.c` , which is `arch/arm/mach-imx/mach-imx6q.c`
    in our case, since we use a UDOO quad based on an i.MX6Q from NXP. The function
    `platform_device_register()` lets you do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The name of the device is very important, and is used by the kernel to match
    the driver with the same name.
  prefs: []
  type: TYPE_NORMAL
- en: Device provisioning - the new and recommended way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the first method, any modification will necessitate rebuilding the whole
    kernel. If the kernel had to include any application/board-specific configurations,
    its size would incredibly increase. In order to keep things simple, and separate
    devices declarations (since they are not really part of the kernel) from the kernel
    source, a new concept has been introduced: *the device tree* . The main goal of
    DTS is to remove very specific and never-tested code from kernel. With the device
    tree, platform data and resources are homogenous. The device tree is a hardware
    description file and has a format similar to a tree structure, where every device
    is represented with a node, and any data or resource or configuration data is
    represented as the node''s property. This way, you only need to recompile the
    device tree when you make some modifications. The device tree forms the subject
    of the next chapter, and we will see how to introduce it to the platform device.'
  prefs: []
  type: TYPE_NORMAL
- en: Devices, drivers, and bus matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before any match can occur, Linux calls the `platform_match(struct device *dev,
    struct device_driver *drv)` . Platform devices are matched with their drivers
    by means of strings. According to the Linux device model, the bus element is the
    most important part. Each bus maintains a list of drivers and devices that are
    registered with it. The bus driver is responsible for devices and drivers matching.
    Any time one connects a new device or adds a new driver to a bus, that bus starts
    the matching loop.
  prefs: []
  type: TYPE_NORMAL
- en: Now, suppose that you register a new I2C device using functions provided by
    the I2C core (discussed in next chapter). The kernel will trigger the I2C bus
    matching loop, by calling the I2C core match function registered with the I2C
    bus driver, to check if there is already a registered driver that matches with
    your device. If there is no match, nothing will happen. If a match occurs, the
    kernel will notify (by means of a communication mechanism called netlink socket)
    the device manager (udev/mdev), which will load (if not loaded yet) the driver
    your device matched with. Once the driver loads, its `probe()` function will immediately
    be executed. Not only does I2C work like that, but every bus has its own matching
    mechanism that is roughly the same. A bus matching loop is triggered at each device
    or driver registration.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can sum up what we have said in the preceding section in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Every registered drivers and devices sit on a bus. This makes a tree. USB buses
    may be children of PCI buses, whereas MDIO buses are generally children of other
    devices, and so on. Thus, our preceding figure changes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you register a driver with the `platform_driver_probe()` function, the
    kernel walks through the table of registered platform devices and looks for a
    match. If any, it calls the matched driver's `probe` function with the platform
    data.
  prefs: []
  type: TYPE_NORMAL
- en: How can platform devices and platform drivers match?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have only discussed how to fill different structures of both devices
    and drivers.But now we will see how they are registered with the kernel, and how
    Linux knows which devices are handled by which driver. The answer is `MODULE_DEVICE_TABLE`
    . This macro lets a driver expose its ID table, which describes which devices
    it can support. In the meantime, if the driver can be compiled as a module, the
    `driver.name` field should match the module name. If it does not match, the module
    won''t be automatically loaded, unless we have used the `MODULE_ALIAS` macro to
    add another name for the module. At compilation time, that information is extracted
    from all the drivers in order to build a device table. When the kernel has to
    find the driver for a device (when a matching needs to be performed), the device
    table is walked through by the kernel. If an entry is found matching the `compatible`
    (for device tree), `device/vendor id` or `name` (for device ID table or name)
    of the added device, then the module providing that match is loaded (running the
    module''s `init` function), and the `probe` function is called. The `MODULE_DEVICE_TABLE`
    macro is defined in `linux/module.h` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the description of each parameter given to this macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '`type` : This can be either `i2c` , `spi` , `acpi` , `of` , `platform` , `usb`
    , `pci` or any other bus which you may find in `include/linux/mod_devicetable.h`
    . It depends on the bus our device sits on, or on the matching mechanism we want
    to use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name` : This is a pointer on a `XXX_device_id` array, used for device matching.
    If we were talking about I2C devices, the structure would be `i2c_device_id` .
    For SPI device, it should be `spi_device_id` , and so on. For the device tree
    **Open Firmware** ( **OF** ) matching mechanism, we must use `of_device_id` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For new non-discoverable platform device drivers, it is recommended not to use
    platform data anymore, but to use device tree capabilities instead, with OF matching
    mechanism. Please do note that the two methods are not mutually exclusive, thus
    one can mix these together.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get deeper into the details for matching mechanisms, except for the OF
    style match which we will discuss in [Chapter 6](text00162.html) , *The Concept
    of Device Tree* .
  prefs: []
  type: TYPE_NORMAL
- en: Kernel devices and drivers-matching function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The function responsible for platform devices and driver-matching functions
    in kernel is defined in `/drivers/base/platform.c` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can enumerate four matching mechanisms. They are all based on the string
    compare. If we have a look at `platform_match_id` , we''ll understand how things
    work underneath:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now let's have a look at the `struct device_driver` structure we discussed in
    [Chapter 4](text00121.html) , *Character Device Drivers:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: I intentionally removed fields that we are not interested in. `struct device_driver`
    forms the basis of every device driver. Whether it is an I2C, SPI, TTY, or other
    device driver, they all embed a `struct device_driver` element.
  prefs: []
  type: TYPE_NORMAL
- en: OF style and ACPI match
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OF style is explained in [Chapter 6](text00162.html) , *The Concept of Device
    Tree* . The second mechanism is an ACPI table-based matching. We'll not discuss
    it at all in this book, but for your information, it uses struct `acpi_device_id`
    .
  prefs: []
  type: TYPE_NORMAL
- en: ID table matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This match style has been for a long time, and is based on the `struct device_id`
    structure. All device id structures are defined in `include/linux/mod_devicetable.h`
    . To find the right structure name, you need to prefix `device_id` with the bus
    name whom your device driver seats on. Examples are: `struct i2c_device_id` for
    I2C, `struct platform_device_id` for platform devices (that don''t sit on a real
    physical bus), `spi_device_id` for SPI devices, `usb_device_id` for USB, and so
    on. The typical structure of a `device_id table` for a platform device is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Anyway, if an ID table is registered, it will be walked through whenever the
    kernel has run the match function to find a driver for an unknown or new platform
    device. If there is a match, the `probe` function of the matched driver will be
    invoked, and given as a parameter a `struct platform_device` , which will hold
    a pointer to the matching ID table entry that originated the match. The `.driver_data`
    element is an `unsigned long` , which is sometimes casted into pointer addresses
    in order to point to anything, just like in the serial-imx driver. The following
    is an example with `platform_device_id` in `drivers/tty/serial/imx.c` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `.name` field must be the same as the device''s name you give when you
    register the device in the board specific file. The function responsible for this
    match style is `platform_match_id` . If you look at its definition in `drivers/base/platform.c`
    , you''ll see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, which is an excerpt from `drivers/tty/serial/imx.c`
    in kernel sources, one can see how the platform data is converted back into the
    original data structure, just by casting. That is how people sometimes pass any
    data structure as platform data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`pdev->id_entry` is a `struct platform_device_id` , which is a pointer to the
    matching ID table entry made available by the kernel, and whose `driver_data`
    element is casted back to a pointer on the data structure.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Per device-specific data on ID table matching**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, we have used `platform_device_id.platform_data` as
    a pointer. Your driver may need to support more than one device type. In this
    situation, you will need specific device data for each device type you support.
    You should then use the device id as an index to an array that contains every
    possible device data, and not as a pointer address anymore. The following are
    detailed steps in an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We define an enumeration, depending on the device type that we need to support
    in our driver:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We define the specific data-type structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We fill an array with default values, and depending on the index in `device_id`
    , we can pick the right data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We define our `platform_device_id` with a specific index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we just have to do the stuff in the `probe` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Name matching - platform device name matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now-a-days most platform drivers do not provide any table at all; they simply
    fill the name of the driver itself in the driver''s name field. But the matching
    works because, if you look at the `platform_match` function, you will see that
    at the end the match falls back to name matching, comparing the driver''s name
    and the device''s name. Some older drivers still use that matching mechanism.
    The following is name matching from `sound/soc/fsl/imx-ssi.c` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: To add a device that matches this driver, one must call `platform_device_register`
    or `platform_add_devices` , with the same name `imx-ssi` , in the board-specific
    file (usually in `arch/<your_arch>/mach-*/board-*.c` ). For our quad core i.MX6-based
    UDOO, it is `arch/arm/mach-imx/mach-imx6q.c` .
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The kernel pseudo platform bus has no secrets for you anymore. With bus matching
    mechanisms, you are able to understand how, when, and why your driver has been
    loaded, as well as which device it was for.We can implement any `probe` function,
    based on the matching mechanism we want. Since the main purpose of a driver is
    to handle a device, we are now able to populate devices in the system (the old
    and depreciated way). To finish in beauty, the next chapter will exclusively deal
    with the device tree, which is the new mechanism used to populate devices, along
    with their configurations, on the system.
  prefs: []
  type: TYPE_NORMAL
