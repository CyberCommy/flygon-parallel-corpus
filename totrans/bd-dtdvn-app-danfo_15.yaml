- en: '*Chapter 12*: Building a Twitter Analysis Dashboard'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main goal of this chapter is to show how you can build a full stack web
    analytics platform using Danfo.js at the backend and the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate this, we will be building a small single-page web app in which
    you can run a search on a Twitter user, obtain all the tweets in which they are
    mentioned on a specific day, and perform some simple analysis such as sentiment
    analysis, drawing insights from the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll look at the following topics for building the web app:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the frontend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is required for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge of React.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code for this chapter, which is available here: [https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter12](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter12)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the project environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this project, we will build a single web page with both a backend and a
    frontend. We will be using the Next.js framework to build the app. Next.js makes
    it possible for you to build the backend and frontend quickly and easily. We will
    also make use of `tailwindcss,` as we have done for some of our previous projects,
    such as the no-code environment project.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up our project environment with Next.js containing the default `tailwindcss`
    configuration, all we need to do is run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `npx` command runs `create-next-app`, which creates Next.js boilerplate
    code, including the `tailwindcss` configuration in the `twitterdashboard` directory.
    Note that the `twitterdashboard` directory (also called *project name*) can be
    given any name of your choice. If everything is successfully installed, you should
    get the output shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Code environment setup'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_12_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.1 – Code environment setup
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we are done with the installation, if everything works correctly,
    you should have the following files in your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – Directory structure'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_12_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.2 – Directory structure
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to test whether the project is well installed and ready to go, let''s
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This command should automatically start the app and open up the browser, showing
    the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Next.js UI'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_12_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.3 – Next.js UI
  prefs: []
  type: TYPE_NORMAL
- en: For this project, we will modify the interface shown in *Figure 12.3* to suit
    our tastes.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the code environment is set up, let's move on to creating our app.
  prefs: []
  type: TYPE_NORMAL
- en: Building the backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will be looking at how to create the following APIs for
    our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/api/tweet`: This API is responsible for fetching a Twitter user and obtaining
    their data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/api/nlp`: This API is responsible for running sentiment analysis on the obtained
    user data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These APIs will be consumed by the frontend components and will be used to create
    different visualizations and analyses. Let's start by creating the API to fetch
    a Twitter user's data.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Twitter API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will build an API that makes it easy to obtain tweets in
    which a Twitter user is mentioned. From each of the tweets, we will obtain their
    metadata, such as the text, the name of the sender, the numbers of likes and retweets,
    the device used to tweet, and the time the tweet was created.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the Twitter API for fetching a Twitter user''s data and structure
    it to our taste for easy consumption in the frontend, we need to install a tool
    that makes it easier to interact with the main Twitter developer API. In the following
    command, we will install `twit.js` for easy access and handling of the Twitter
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once `twit` is installed, we need to configure it. To use `twit`, we will need
    various Twitter developer keys, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you don't have these keys, you will need to create a Twitter developer account
    and then apply to get access to the API via [https://developer.twitter.com/](https://developer.twitter.com/).
    If given access to use the Twitter API, you can visit [https://developer.twitter.com/en/apps](https://developer.twitter.com/en/apps)
    to create an app and set up your credential keys.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Obtaining the Twitter API might take several days, based on how you describe
    your use case. For a proper step-by-step guide with visual aids to setting up
    the Twitter API and obtaining the necessary keys, follow the steps here: [https://realpython.com/twitter-bot-python-tweepy/#creating-twitter-api-authentication-credentials](https://realpython.com/twitter-bot-python-tweepy/#creating-twitter-api-authentication-credentials).'
  prefs: []
  type: TYPE_NORMAL
- en: 'After obtaining the Twitter developer keys needed for the project, we''ll make
    use of them in our code. To prevent exposing the keys to the public, let''s create
    a file named `.env.local`, and in this file, let''s add our API keys as shown
    in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In Next.js, all APIs are created in a `/pages/api` folder. Next.js uses a file
    structure in the `pages/` folder to create the URL route. For example, if you
    have a file named `login.js` located in the `pages/` folder, the content in `login.js`
    will be rendered in `http://localhost:3000/login`.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding paragraph shows how a route is created for web pages in Next.js
    based on the filename and structure. The same thing applies to creating APIs in
    Next.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume we created an API for signing up in `signup.js` located in `pages/api`.
    This API will automatically be available in `http://localhost:3000/api/signup`
    and if we were to use this API within the app itself, we could make a call to
    it like this: `/api/signup`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For our `/api/tweet` API, let''s create a file named `tweet.js` in `pages/api/`
    and update the file with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import `twit.js`, and then create a function to clean each of the
    tweets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `clean_tweet` function takes in tweet text, normalizes the text, removes
    the hashtag character, users' names, URL links, and newlines, and then trims the
    text.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then create a function called `twitterApi`, which will be used to create
    our API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `twitterApi` function takes in two arguments, `req` and `res`, which are
    the server request and response arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now update `twitterApi` with the necessary code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: First, we check whether the `req.method` request method is a `POST` method,
    and then we obtain the username from the request body sent via the search box.
  prefs: []
  type: TYPE_NORMAL
- en: The `Twit` class is instantiated and our Twitter API keys are passed in. Since
    our Twitter developer API keys are stored as environmental keys in `.env.local`,
    we can easily access each of the keys using `process.env`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve configured `twit.js` with our API keys. Let''s now do a search of all
    the tweets that mention a user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We search for all tweets using the `search/tweets` API in the `T.get` method.
    We then pass in the `param` object containing the username of the user we want
    to search for.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `dfData` object is created to structure the data based on how we want the
    API output response to be. `dfData` contains the following keys, which are the
    metadata we want to extract from the tweet:'
  prefs: []
  type: TYPE_NORMAL
- en: '`text`: The texts in the tweet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`length`: The length of the tweet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`date`: The date the tweet was tweeted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`source`: The device used to create the tweet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`likes`: The number of likes the tweet has'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`retweet`: The number of retweets the tweet has'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`users`: The user who created the tweet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The metadata in the preceding list is extracted from the JSON data returned
    from `search/tweets` in the `T.get()` method from the preceding code. All the
    metadata extracted from this JSON data is contained in an array of objects called
    `statuses` and the following shows the structure of the JSON data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The Twitter API is created and ready to use. Let's move ahead to create the
    sentiment analysis API.
  prefs: []
  type: TYPE_NORMAL
- en: Building the text sentiment API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the `/api/tweet` API, we are going to obtain the structured JSON data and
    then perform sentiment analysis.
  prefs: []
  type: TYPE_NORMAL
- en: The sentiment analysis on the data will be fetched via the `/api/nlp` route.
    Hence, in this section, we will see how to create a sentiment analysis API for
    our Twitter data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a file named `nlp.js` in the `/pages/api/` folder and update
    it with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will make use of the `nlp-node.js` package for our sentiment analysis. We''ll
    also make use of `danfojs-node` for data preprocessing, so let''s install these
    two packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We import `SentimentAnalyzer` from `nlp-node` and `DataFrame` from `danfojs-node`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will create a default `SentimentApi` export function, which will contain
    our API code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We will then check whether the request method is a `POST` request, and then
    perform some data preprocessing on the data obtained from the request body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we first instantiated `SentimentAnalyzer`, and then set
    its language configuration to English (`en`). We then obtained `dfData` and `username`
    from the request body.
  prefs: []
  type: TYPE_NORMAL
- en: To analyze and create insights from the data, we only want to consider the user's
    interaction with others and not themself; that is, we don't want to consider tweets
    where the user replied to themself. Hence, we filter out the user's replies from
    the DataFrame generated from `dfData`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, a tweet will just contain a hashtag or reference a user with the
    `@` sign. However, we removed the hashtags and `@` signs during our cleaning process
    earlier, which will result in some tweets ending up not containing any text. Therefore,
    we will create a new `filterBylength` DataFrame that will contain non-empty text:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will move ahead to creating an object that will contain the overall sentiment
    count for the user''s data and is sent to the frontend whenever we make a call
    to the API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we create object data to store the overall sentiment
    analysis. Since sentiment analysis will only be performed on the text data from
    the `filterByLength` DataFrame, we extract the text column values.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then loop through the text column values extracted and pass them into `sentiment.getSentiment`.
    For each piece of text passed into `sentiment.getSentiment`, the following types
    of objects are returned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: For our use case, we only need the key value of `vote`. Hence, we check whether
    the value of `vote` for a text is `negative`, `positive`, or `neutral`, and we
    then increment the count of each of these keys in a data object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, whenever a call is made to `/api/nlp`, we should receive the following
    response, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we saw how we can create APIs in Next.js and, more importantly,
    we saw how it is convenient to use Danfo.js in the backend. In the next section,
    we will implement the frontend part of the app.
  prefs: []
  type: TYPE_NORMAL
- en: Building the frontend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For our frontend design, we will use the default UI that comes with Next.js,
    as shown in *Figure 12.3*. We will implement the following set of components for
    our frontend:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Search` component: Creates a search box to search for Twitter users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `ValueCount` component: Obtains the count of unique values and plots it
    using a bar chart or pie chart.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Plot` component: This component is used to plot our sentiment analysis
    in the form of a bar chart.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Table` component: This is used to display the obtained user data in table
    form.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we'll implement the preceding list of components.
    Let's get started by implementing the `Search` component.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Search component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Search` component is the main component for setting the app in action.
    It provides the input field in which a Twitter user''s name can be inputted and
    then searched for. The `search` component enables us to make a call to the two
    APIs created: `/api/tweet` and `/api/nlp`.'
  prefs: []
  type: TYPE_NORMAL
- en: In our `twitterdashboard` project directory, let's create a directory called
    `components`, and in that directory, we'll create a JavaScript file named `Search.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Search.js`, let''s input the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we created a `Search` function with the following set
    of props:'
  prefs: []
  type: TYPE_NORMAL
- en: '`inputRef`: This prop is obtained from the `useRef` React Hook. It will be
    used to track the current value of the search input field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handleKeyEvent`: This is an event function that will be passed to the search
    input field to enable search by just pressing the *Enter* key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handleSubmit`: This is a function that will be activated anytime you click
    the search button. The `handleSubmit` function is responsible for making a call
    to our API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s move on to `/pages/index.js` to update the file by importing the `Search`
    component and creating the preceding list of required props based on the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will import React, React Hooks, and the `Search` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will create some sets of state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We will then create the `handleSubmit` function to make a call to our API and
    update the state data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: First, in `handleSubmit`, we make a call to the `/api/tweet` API to obtain the
    user's data. In the `fetch` function, we obtain the current value of the `inputRef.current.value`
    search field and convert it into a JSON object, which is passed into the request
    body. A variable result is then used to obtain the JSON data from the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'We further update the `handleSubmit` function to fetch data from `/api/nlp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is the same as that in *Step 3*. The only difference is that
    we make a call to the `/api/nlp` API and then pass the result data from *Step
    3* and the username obtained from the search input field into the request body.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then update the following states in `handleSubmit`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will create the `handleKeyEvent` function to enable search by pressing
    the *Enter* key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we check whether the keypress is an *Enter* key, and
    if it is, we make a call to the `handleSubmit` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we make a call to our `Search` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Remember, we said that we'll be using Next.js's default UI. Hence, in `index.js`,
    let's convert `Welcome to Next.js` to `Welcome to Twitter Dashboard`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After updating `index.js`, you can check your browser for the update at `http://localhost:3000/`.
    You''ll see the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4 – index.js updated with the search component'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_12_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.4 – index.js updated with the search component
  prefs: []
  type: TYPE_NORMAL
- en: The `Search` component is implemented and infused into the main app, and all
    the required state data can easily be updated by the `Search` component. Let's
    go ahead and implement the `ValueCounts` component.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the ValueCounts component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will be creating a simple analysis for the obtained data from `/api/tweet`.
    This analysis involves checking the number of times the unique values in a column
    exist. We'll obtain the value count of the `source` column and the `users` column.
  prefs: []
  type: TYPE_NORMAL
- en: The value count from the `source` column tells us the device used by other Twitter
    users to interact with our searched user. The value count from the `users` column
    tells us the users who interact most with our searched user.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The code used here is copied from the *Implementing the chart component* section
    in [*Chapter 8*](B17076_08_ePub_RK.xhtml#_idTextAnchor149), *Creating a No-Code
    Data Analysis/Handling System*. The code for this section can be obtained here:
    [https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js-/blob/main/Chapter12/components/ValueCounts.js](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js-/blob/main/Chapter12/components/ValueCounts.js).
    Most of the code won''t be explained in detail here.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go to the `components/` directory and create a file named `ValueCounts.js`,
    and then update it with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import the necessary modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create a function called `ValueCounts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The function accepts the following props:'
  prefs: []
  type: TYPE_NORMAL
- en: 'a) `data`: This is the data from `/api/tweet`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'b) `column`: The name of the column from which we want to obtain the value
    count.'
  prefs: []
  type: TYPE_NORMAL
- en: 'c) `username`: The inputted username from the search field.'
  prefs: []
  type: TYPE_NORMAL
- en: 'd) `type`: The type of chart we want to plot.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we update the `ValueCounts` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we first create a DataFrame from the data and then filter
    out the rows containing the searched user since we don't want tweets where the
    user is interacting with themself. We then extract the `value_counts` value from
    the passed-in column. From the created `countSeries` variable, we generate our
    labels and values, which we will use for plotting our chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then create a chart data variable called `dataChart`, which will be in the
    format accepted by the `chart` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `dataChart` object contains the labels and values created in *Step 3*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a conditional rendering to check the type of chart to plot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `ValueCounts` component is set.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now import the `ValueCounts` component into `index.js` using the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We import `ValueCounts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The way we import `ValueCounts` is different from the way we import the `Search`
    component. This is because in `ValueCounts`, we use some core browser-specific
    tools in TensorFlow.js, which is required in Danfo.js. Hence, we need to prevent
    Next.js from rendering the component from the server to prevent an error.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent Next.js from rendering a component from the server, we use `next/dynamic`,
    and we then wrap the component to be imported in the `dynamic` function, as well
    as setting the `ssr` key to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To find out more about `next/dynamic`, check out [https://nextjs.org/docs/advanced-features/dynamic-import](https://nextjs.org/docs/advanced-features/dynamic-import).
  prefs: []
  type: TYPE_NORMAL
- en: 'We make a call to the `ValueCounts` component, which is now named `DynamicValueCounts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We check whether the state data is undefined and that the user's data has been
    fetched from `/api/tweet`. If so, we render the `ValueCounts` component for the
    `source` column.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also add `ValueCounts` for the `users` column:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We specify `BarChart` for the user's `ValueCounts` chart and `PieChart` for
    the `ValueCounts` source.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows the display of `ValueCounts` for the source and user interactions
    whenever a user is searched:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5 – ValueCounts chart result for the source and user columns'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_12_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.5 – ValueCounts chart result for the source and user columns
  prefs: []
  type: TYPE_NORMAL
- en: The value count is done and working okay. Let's move on to create a plot for
    our sentiment analysis data obtained from `/api/nlp`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a plot component for sentiment analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a user is searched by using the search field, the `sentiData` state is
    updated to contain the sentiment data from `/api/nlp`. In this section, we will
    create a `Plot` component for the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `Plot.js` file in the `components/` directory and update it
    with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import the required modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We then create a `Plot` function to plot a chart for sentiment data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The function accepts a `data` prop. We then create a `dataChart` object containing
    the format for the `chart` component. We specify the chart label by obtaining
    the keys in the `data` props and also specify the value of key data in `dataChart`
    by obtaining the values of the `data` props. The `dataChart` object is passed
    into the `BarChart` component. The `Plot` component is now created for the sentiment
    analysis chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to import the `Plot` component inside `index.js` and make
    a call to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'With the preceding update in `index.js`, we should see the following chart
    for sentiment analysis whenever we search for a user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6 – Sentiment analysis chart'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_12_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.6 – Sentiment analysis chart
  prefs: []
  type: TYPE_NORMAL
- en: The sentiment analysis is done and fully integrated into `index.js`. Let's move
    on to create the `Table` component to display our user data.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Table component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will be implementing a `Table` component to display the data obtained.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The table implementation is the same as for the DataTable implementation created
    in [*Chapter 8*](B17076_08_ePub_RK.xhtml#_idTextAnchor149), *Creating a No-Code
    Data Analysis/Handling System*. For a better explanation of the code, kindly check
    out [*Chapter 8*](B17076_08_ePub_RK.xhtml#_idTextAnchor149), *Creating a No-Code
    Data Analysis/Handling System*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `Table.js` file in the `components/` directory and update the
    file with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We import the necessary modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a function called `Table`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The function takes in `dfData` (sentiment data from `/api/nlp`) and `username`
    (from the search field) as props.
  prefs: []
  type: TYPE_NORMAL
- en: 'We update the function with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We create a DataFrame from `dfData`, filter out the rows containing the user's
    tweets, and then extract the column names and the values of the DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then format this column in the format accepted by `ReactTable`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We also format the values to be accepted by `ReactTable`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Once again, the code in *Steps 4*, *5*, and *6* is explained in detail in [*Chapter
    8*](B17076_08_ePub_RK.xhtml#_idTextAnchor149), *Creating a No-Code Data Analysis/Handling
    System*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then make a call to the `ReactTable` component and pass in `dataColumns`
    and `data`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `table` component is completed; the next step is to import the component
    in Next.js and then make a call to the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that since we are using the web version of Danfo.js, we need to load this
    component with `next/dynamic` to prevent the app from crashing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we import the `Table` component dynamically and also
    instantiate the `Table` component inside and pass in the `dfData` and `username`
    prop values.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you switch over to your browser and go to the project''s `localhost` port,
    you should see the full updated app, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7 – Extracted user data'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_12_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.7 – Extracted user data
  prefs: []
  type: TYPE_NORMAL
- en: 'The final result of the app should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8 – Twitter user dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_12_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.8 – Twitter user dashboard
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we built different components for the frontend implementation.
    We saw how to make use of Danfo.js with Next.js and also got to know about loading
    components with `next/dynamic`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how to make use of Next.js to build a fast full stack
    app. We saw how to make use of Danfo.js nodes in the backend and we also used
    JavaScript packages such as twit.js and `nlp-node` to obtain Twitter data and
    perform sentiment analysis.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw how to easily infuse Danfo.js with Next.js and how to prevent errors
    by loading components with `next/dynamic`.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of the chapter was to enable you to see how you can easily use Danfo.js
    to build a full stack (backend and frontend) data-driven app, and I believe this
    was well achieved in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: I believe we've covered a lot in this book, starting from the introduction to
    Danfo.js to building a no-code environment with Danfo.js, to building a recommendation
    system and Twitter analytics dashboard. From the various use cases of Danfo.js
    with various JavaScript frameworks, we were able to build an analytics platform
    and machine learning-driven web apps.
  prefs: []
  type: TYPE_NORMAL
- en: We've come to the end of the book and I believe we are now well equipped with
    skills to include data analytics and machine learning in our next web app and
    also contribute to Danfo.js.
  prefs: []
  type: TYPE_NORMAL
