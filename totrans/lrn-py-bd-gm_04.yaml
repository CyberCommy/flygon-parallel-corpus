- en: Data Structures and Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to traverse through the concept of data structures
    and functions, two primary building blocks of Python. Normal variables are a good
    way to store singular units of data of any type, but for arrays of data, we should
    always use data structures. Python has a raft of data structures available that
    you can use to represent and manipulate your datasets, or even to combine them
    in order to make your own data structures. We have already seen built-in data
    types, such as integers, Booleans, floating numbers, strings, and characters.
    They are called built-in because they come as a dovetail with Python. Now, we
    are going to explore built-in data structures, such as lists, dictionaries, tuples,
    and sets. Combinations of these built-in data types result in data structures
    that are implemented independently. For example, if we put different integers
    in one place, they are arrays of numbers. Python call them lists, which are widely
    used data structures.
  prefs: []
  type: TYPE_NORMAL
- en: In order to become proficient programmers, first we have to learn about core
    programming paradigms, such as variables, numbers, modules, and built-in functions,
    before then diving into the data structures and algorithms. This book is not any
    different. We have already covered the basics of Python; now, it's time to delve
    into the data structures and the method that is used to access and manipulate
    data. In the previous chapter, we modified our game with conditionals and looping.Now,
    let's extend our knowledge of Python to include the broad concept of data structures
    and functions so that we can refine our game decide the most fa
  prefs: []
  type: TYPE_NORMAL
- en: further.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need data structures?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The four structural pillars of Python—lists, dictionaries, sets, and tuples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding AI to a tic-tac-toe game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game testing and possible modifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the requirements that you will need to understand this chapter
    properly:'
  prefs: []
  type: TYPE_NORMAL
- en: The Python IDLE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code assets for this chapter can be found at [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter04](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter04)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2oNoxOL](http://bit.ly/2oNoxOL)'
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need data structures?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a programmer or computer scientist, we always search for ways to optimize
    our code. Optimization is a way of refining code in order to improve code efficiency
    and quality. Data structures are a shrewd way of organizing data in a computer,
    therefore making it easier to retrieve and access data, which results in code
    optimization.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have learned how to use conditionals to make conditions, and how
    to make flow controls with normal variables. However, real-world data is not limited
    to one unit. We may collect profuse amounts of data, which would have the highest
    level of intricacies. It may contain thousands of integers, hundreds of Booleans,
    or a combination of these. Thus, storing them into a single, normal variable with
    an assignment statement is not possible. Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ceef5509-9abd-4f84-bd5e-7b5f8ae1118b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding code, we tried to assign two values to a single variable.
    It produced a syntax error. We even tried to put two string values into a single
    variable, `a`, but instead it performed a concatenation, and assigned it as a
    single value. Thus, storing multiple values in a normal variable is not possible.
    However, we can easily convert this normal variable into a data structure, as
    shown in the following snippet of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We have converted the normal `a` variable into a tuple, which is a built-in
    data structure of Python. We will cover this in detail in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: This variable was only able to store a single unit of data, but if we carry
    out multiple assignments, the preceding value would be overwritten. However, if
    you want to preserve all the data in one placeholder, data structures are a way
    of doing this.
  prefs: []
  type: TYPE_NORMAL
- en: As a programmer, our primary responsibility is to perform some sort of manipulation
    on input datasets. Input can be anything, such as emails or passwords, or maybe
    a request to enter into a system or location for Google Maps, where we can use
    the data to perform some sort of computation using algorithms. In addition, the
    haversine algorithm (refer to the following URL to learn more about this algorithm: [https://rosettacode.org/wiki/Haversine_formula](https://rosettacode.org/wiki/Haversine_formula))
    gives you the exact distance between your location and your destination. Thus,
    input data can have a wide range, but the main task is to manipulate it. Our systems
    and processors are not powerful enough to handle the manipulation of several terabytes
    of data all at once. Thus, choosing a proper data structure is a major optimization
    that can be carried out by the programmer. If we are able to store such inputs
    into faster data structures in any organized form, we can perform even complex
    tasks with ease. Data structures are just places or storage that provide structure
    to such complex data, but processes such as fetch and manipulation are performed
    using algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Still in doubt? Let's make things clear by taking an example of a library in
    order to understand data structures and algorithms. First of all, imagine a scenario
    where we don't have proper management in a library. Books are not properly placed
    in their relevant sections. Now, searching for a book in a particular section
    is useless, because it won't be there. The best-case scenario is that you may
    find your book within a few minutes, but the worst-case scenario is that you may
    have to search the entire library to find a book about history, for example. However,
    if the library is properly organized and managed, you will be able to go directly
    to the relevant section where history books are stored, and search for your book
    in that section only. Here, the library represents the data structure and the
    book is the data that you are searching for. Whenever you need data, you go to
    the data structure, and if it is properly managed, you will be easily be able
    to retrieve it. The steps that define how you are going to search for the books
    are called algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Enough of the theory—let's get our hands dirty by coding and learning about
    the four pillars of data structures of Python—**lists**, **dictionaries**, **sets**,
    and **tuples.**
  prefs: []
  type: TYPE_NORMAL
- en: The four structural pillars of Python – lists, dictionaries, sets, and tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 2](06cdc81b-3e57-405e-b721-235214498ac7.xhtml), *Learning the Fundamentals
    of Python*, we learned about strings, and we called them immutable data types
    because they do not allow assignment operation. This is shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'However, data structures must be flexible, which means that we should be able
    to store and extract elements of data from any position. Thus, most of the built-in
    data structures of Python are mutable, which means that they can be changed and
    manipulated with proper indexing. The proper categories for the four data structures
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**List and tuple**: Mutable data structures'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dictionary**: Mapped data structure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Set**: Mutable and unordered data structure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each category exists because of its uniqueness, and you will see how easy it
    is to distinguish them as superior or inferior to one another in the upcoming
    sections. However, remember that they are all superior at some point; it's up
    to us to choose a data structure that is appropriate to the situation. For example,
    we say that dictionaries are the king of data structures, but we may come across
    a situation where tuples may be the faster way to store data, which is usually
    the case when we make programs in Python using databases such as SQLite and MySQL.
    Now, let's take a look at each of these built-in data structures of Python, starting
    with a basic mutable data structure, which is known as a list.
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like a string is a sequence of characters, a list is a sequence of values.
    Values can be a combination of any type. The values in a list are called items
    of that list. Lists are mutable and ordered data structures, and elements of lists
    can be extracted using indexes. Like strings, we can extract multiple elements
    from a list using the slicing technique. Lists are notorious for storing homogeneous
    data types, but they also support heterogeneous data types. We are not confined
    to creating lists using only a single method; there are multiple ways of doing
    this. Let''s look at some of basic ways of creating lists in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The simplest way of creating lists is using square brackets—`[]`. You can add
    multiple elements inside these brackets, and there are multiple ways of doing
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we can add elements to the list at the moment of its declaration,
    as shown in the following example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also add elements to lists using the built-in methods within Python.
    For example, the `append` method can be used to insert elements into the list.
    Elements are added to the last position of the list, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also make a list containing multiple types of values, as shown in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we made a list containing numbers, strings, and Booleans. Thus, we stored
    heterogeneous data types in a single list. We can also add multiple lists within
    a single list, and these are known as nested lists. As the term suggests, one
    list is nested within another list, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we created a single list containing six elements. We
    have integers and two whole lists (`[4,5,6]` and `["hey","Python"]`) within that
    primary list. Thus, these types of list are called nested lists.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you assign those lists to variables, the variable type eventually becomes
    the list type. Now, the type of variable has been changed from a built-in data
    type such as `int`, `str`, or `bool`, to a built-in data structure, which is the
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way of creating lists is by using the built-in Python method—the `list()`
    method—but it is redundant in the preceding process because we have to pass the
    whole list as an argument of this list method. This is known as the type-casting
    method. If you want to convert any other data structure into a list, we use the
    `list()` method, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `list()` method, we have to pass an argument in the form of the list
    that contains the elements, which are enclosed using square brackets. You must
    have guessed by this point that every built-in data structure that is available
    in Python must have one built-in method in order to create its data structures.
    We use the `dict()` method to create dictionaries, the `set()` method to create
    sets, and `tuple()` to create tuples in the same way that the `list()` method
    creates lists.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have uncovered the different ways of creating a simple, yet powerful,
    data structure that goes by the name of `list` in this section, let's see how
    we can access and manipulate its stored data.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing list elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you recall the way that we access the elements of a string, you can also
    replicate this process in the case of lists. We use square brackets in lists in
    order to indicate the position inside it so that we can extract and interact with
    particular elements. We call this the index, and it is added inside this `[]`
    bracket symbol. It is same when creating new lists. Indexes of lists start from
    0 and increase in unit digits, while also traversing from left to right. Like
    strings, lists also support negative indexing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When we tried to assign elements to the string, it was not valid. Unlike strings,
    lists provide reassigned items to the list. Thus, we can say that lists are mutable,
    which means that they are changeable and modifiable. This feature makes the list
    the simplest and most flexible data structure of all. We can assign elements using
    the append method, which we saw in the preceding section, but this method only
    allows us to add elements to the end of the list. If you want to add elements
    to any particular position, you can explicitly tell the Python parser to do this
    through indexing and assignment statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you want to add `loves` in-between two elements of the list,
    you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Thus, we can see that the element at position one, `Monica`, has been replaced
    by `loves`, which shows that we can change the order of the elements and reassign
    any other element to the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'While dealing with data structures, it''s always good practice to observe them
    hypothetically. We can consider them as a mapping process, where every element
    on the list is mapped to certain indexes. Indexes are positions, and whenever
    we backtrack the list through the indexes, we are able to access elements of these
    indexes. Even if you have a nested list, that is, one or multiple lists inside
    the single list, they will be also mapped to an index, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We know that square brackets are used to access elements of a list, but if
    we want to access elements of a nested list, we have to add another square bracket
    in order to specify the level of indexes that are needed to access these elements,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check whether the element is in the list or not by using the `in` keyword.
    The syntax that''s used in the statement''s results give a Boolean value that
    is either `True` or `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Accessing the elements of the list is easier, but sometimes if you make mistakes
    when counting proper indexes, it may give an unintended result. Thus, you must
    count the elements of the list from the index, 0\. If you put indexes inside the
    square brackets that do not map to any value, you will run into an error, known
    as `IndexError`, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `IndexError` message pretty much explains why we ran into this error. The
    index of the list named odd stops at 4\. However, we passed 20, which is the position
    that has no mapping to the values, or simply, we don't have any elements in this
    position. Thus, while working with lists, we have to track every position of the
    inserted values so that we don't run into any exceptions. However, we have a solution
    to prevent such conditions—just recall the exception handling mate! That's what
    you need to call in order to handle these exceptions so that our code runs properly
    instead of crashing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have learned how to access these elements using the indexing technique,
    let''s dive into how to traverse the entire list, which is part of accessing the
    entire list. First and foremost, the thing that you must be aware of is looping.
    Since we are dealing with a list that has multiple pieces of data items stored
    in it—which means accessing multiple data, multiple times—we just need to recall
    the method that we would usually use if we want to do things repeatedly. There
    is nothing better than looping that suits this condition perfectly. Thus, the `for`
    loop is the most appropriate method if you want to read the entire elements of
    the list; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also update and refine our list within a `for` loop. The following example
    is among one of the most important examples that we have learned about so far;
    make sure you grasp every teeny-tiny piece of information from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As always, let's break up the preceding code into segments. First of all, we
    declared two empty lists, which will be our output lists of even and odd numbers.
    Then, we used looping to access the elements of the list. The statement range
    (0, 10) will yield a list that contains numbers from 0 to 9\. Here, 10 is the
    exclusion position. Thus, we have looped an entire list of elements one by one.
    If you have any difficulty in understanding the concept of recursion programming,
    recall the *Looping through dictionaries* section. After taking every element
    of the list at each iteration, we enter the body of the loop and check for the
    condition that will determine whether the elements are even or not. If it is even,
    we append it, which means that we insert that element into the `even_num` list,
    and we do a similar thing in the case of odd numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Wow, do you realize what you just did? You have used a simple yet powerful data
    structure and carried out a linear search. Although we have many more topics to
    cover, this is the best thing that we have done so far. Now, gear yourself up
    to learn more about list operations and methods.
  prefs: []
  type: TYPE_NORMAL
- en: List operations and methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Can you recall the type-casting method of Python from  the preceding chapter?
    It is surely the best way to convert one data type into another. We have looked
    at strings, its slicing techniques, and methods. However, we came to realize that
    it was immutable. This restriction is so robust that we can''t change any of the
    elements of that string. However, now we have come to the most flexible data structure,
    which goes by the name of `list`. So, why not convert the string into a list so
    that we can make it mutable too. Let''s use the following example to clarify this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can manipulate the preceding list however we like; maybe using built-in
    methods. However, most of the operation, apart from the assignment, is quite similar
    to that of strings. We learned so much in the string section, such as slicing,
    addition, and multiplication operations, and even some of the string methods.
    Strings and list manipulation are quite similar-they even start with same index,
    0\. That said, the built-in methods that are provided by Python for strings and
    lists are not quite as similar, and why would they be? They are different types
    of data or structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do arithmetic operations with a list, such as addition and multiplication.
    Remember, though, that addition can only be done between two lists, whereas multiplication
    must be done between a list and any integer number, as shown in the following
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the first example, we performed concatenation between the lists using the
    addition operator. In the second example, we multiplied the list by three, and
    the effect of the multiplication can be observed within the content of that list.
    In our case, `john` has been multiplied by three to create three `john` values.
  prefs: []
  type: TYPE_NORMAL
- en: The built-in methods that are provided by Python are used to manipulate the
    values of the list. They act upon the list by creating an object of it. Let's
    not confuse ourselves by talking about objects here; we have a dedicated chapter
    for that.
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of built-in methods available that can manipulate list structures,
    but we are going to cover the most important ones here. I find them useful because
    most developers use only a few of these when carrying out big projects. However,
    if you want to discover more, it's always good practice to take a tour of the
    documentation page.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already seen how we can use the `append` method to insert elements
    into the list. This method adds elements to the end of the list. But if you want
    to insert more than one element into the list, we can use the `extend` method,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `extend` method takes the list as an argument, and
    appends all the elements of the list that are being called upon. When we print
    `list_2`, we will see that the list will remain unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same way that there is a method to add elements to the list, we also
    have a method that can delete elements from the list. Actually, there are two
    methods that can be used to delete elements. One works by passing an argument
    as an index, while the other works by passing an argument directly as an element
    that needs to be deleted. When we use the `pop` method, we have to pass the index
    of the element that needs to be deleted from the list; but when we use the `remove`
    method, we have to pass the element to it in order to specify that this particular
    element needs to be deleted. Take a look at the following snippet of code for
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'There is another way of deleting elements in a list, which is by using the
    simple `del` keyword. Warning: if you write `>>> del fruits` , the entire list
    will be deleted. Make sure you explicitly specify the elements that need to be
    deleted. Specific elements can be fetched in a similar way to how we access elements
    using square brackets, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a bunch of built-in functions that are available in Python that can
    perform arithmetic and logical operations on a list. Using these functions inevitably
    makes code cleaner and readable, and we can perform numerous tasks within a single
    line. Some of the important built-in functions for a Python list are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `sum` function will give us a result of addition between the elements
    of the list. This method works only on the integers and floating values. Next,
    the min and max functions give the minimum and maximum values of the list, respectively.
    Another important function is `len()`, which will give us the length of the list.
    This `len` function works on any of the objects. In addition, we can use it with
    strings in order to find the number of characters in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you may only want to extract particular portions or slices of the
    list, for example, only the first four items stored in a list that contains 1,000
    items. In such cases, you have to use the slicing technique, which will be covered
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Slicing the list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before learning the technique of slicing a list, let''s recall how we sliced
    parts of a string. We used the square brackets operator to specify the start and
    endpoint for the slicing. It is quite similar in the case of lists, as shown in
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Slicing a list can be done by adding a start index and a stop index within
    square brackets. In the preceding example, the stop index element is excluded
    from the resulting slices. Let''s make a simple example that can slice parts of
    the element of our list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The second colon given in the `info[:3:]` statement is optional. The first
    semicolon separates two blocks as the start and end positions, but the second
    colon would be unnecessary if you don''t want to add `step`. To learn more about
    `[start:stop:step]`, check out the *String slicing technique* section in [Chapter
    2](06cdc81b-3e57-405e-b721-235214498ac7.xhtml), *Learning the Fundamentals of
    Python*. Take the following code as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `>>> info[:3:]`, we have added a colon (`:`) separator
    within square brackets to specify the indexes of the list. The space before the
    first colon is the starting index for slicing; here, we passed the empty index,
    which means it is the default, and it will start to slice from the beginning of
    that list. We passed index three to the next placeholder after the first colon
    in order to specify the end index for the slicing procedure. Here, the element
    at index three is `Java`, but it is in the exclusion position, which means it
    will slice from the beginning of list until the element at index two. The last
    placeholder after the second colon specifies the steps that need to be included
    in the slicing. Its value is empty, which means it's the default;, thus, we get
    a result without skipping any of the elements in-between those indexes. It works
    in the same way as the string slicing technique.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's learn about the needs of lists by examining the pitfalls of string
    objects. We will see how a list is considered superior and more prevalent than
    a string in the next section**.**
  prefs: []
  type: TYPE_NORMAL
- en: String and list objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have covered multiple topics about lists; we saw how to create one
    for ourselves, and we saw how to add, delete, and manipulate elements of lists
    using built-in methods. Now, let''s talk about another important concept of string
    and list-objects. Whenever we create any string, an object is created and stored
    in a particular memory reference. For any string that''s created in a program,
    the Python parser creates one object for them, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding examples, both `name_1` and `name_2` point to same object.
    Thus, we can say that they are equivalent and identical. Two variables were created
    with the same `Python` string. These two assignment operations do not create two
    objects; instead, a single object is created and mapped into a global namespace.
    We can see that both of these variables, which have the same content, create a
    single object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/9705e59f-a13d-438b-b959-b0e5818f6eb7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'But in the case of a list, even if the contents is the same, they create two
    distinct objects, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You can clearly see that we get a result of `False` in the preceding code, which
    means that these two list are two different objects. They are not similar, although
    their contents are similar. Thus, whenever we create list variables, we term them
    as a list object, and its content is the value of that object.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have covered our elemental and powerful `list` data structure in
    this section. Although we have not discovered the power of `list` yet, we have
    been using it from [Chapter 2](06cdc81b-3e57-405e-b721-235214498ac7.xhtml), *Learning
    the Fundamentals of Python*. Do you remember that we used `list` to represent
    the positions of the tic-tac-toe board game? Thus, we can conclude that, even
    when we have more robust and complex data structures such as dictionaries, trees,
    and queues, lists are considered the **Queen** of data structures because of their
    usefulness in holding complex data types within simple structures. Now, let's
    learn about **dictionaries**, which are considered the **King** of the data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any discovery of a new data structure occurs because of the deficits in the
    preceding ones. Let's recall the demerits of the list. We have stored elements
    in the list structure that follow some order, and we must use indexes to retrieve
    those values. However those indexes are imaginary. Whenever you want to work with
    the list, you will have the overhead of remembering the order of that sequence,
    otherwise you will run into an `IndexError` exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s learn about more of the sturdy data structure that is available
    in Python. Dictionary, as the term implies, involves working the data structure
    in a way that is quite similar to our Oxford Dictionary. In our real-world dictionary,
    we have key and value pairs. Key refers to the word that you want to search for
    in the dictionary, while value refers to the meaning of that word. Similar to
    the Oxford Dictionary, we have key and value pairs in our dictionary data structure,
    and we call them elements or items, collectively. In the case of lists, we also
    have key and value pairs. Key was imaginary, which was the index, and the value
    was the element of that list, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `python` string is the value and index zero is its key. In the case
    of lists, keys are only integers. In the case of dictionaries, keys can be of
    any type. We need to explicitly specify keys within the dictionary structure.
    Between each key and value pair, we need to put a single colon (`:`). Let''s create
    one dictionary to make things clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We used square brackets, `[]`, to create lists. But now, we will use curly
    braces, `{}`, to create dictionaries. We have to add items to the dictionary using
    the `key:value` pair. Let''s create a simple dictionary, which will contain the
    names of people as keys, and their ages as values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You can imagine a dictionary as a mapper between a set of indexes and a set
    of values. Here, indexes can be of any type, unlike integers for lists. In our
    `info` dictionary, we made keys as sets of strings and values as integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s observe the `info` dictionary that was printed in the preceding
    code. We can clearly see that the output sequence is not printed in the same order
    to that of the input. The element positions have been exchanged. In this case,
    where there are fewer elements, this might not be an issue. However, if we create
    a dictionary with 1,000 of items in it, you will clearly observe that the order
    of the output dictionary won''t be the same to that of the input. In our example,
    we add the `Ross` key at the end of the dictionary, but while printing the same
    dictionary, we got `Ross: 55` added in the second position. So, you might be wondering,
    will it make any difference while accessing the elements of that dictionary? Not
    at all! dictionaries are arranged without an order, unlike that of a list. To
    access the elements of the dictionary, we have to use keys as an identifier. Accessing
    elements of the dictionary is quite similar to that of a list, but instead of
    putting indexes inside the square brackets, we put keys into it. For example,
    if you want to fetch the age of `Monica`, we use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Instead of `IndexError`, we will get `KeyError`, which specifies that there
    is no such element inside the dictionary that has a key named `Chandler`. Thus,
    accessing the list can be an overhead because we have to track every possible
    index of that list. It won't be a problem for lists that are smaller in length,
    but imagine a list containing 10,000 or more elements. To overcome this expense,
    it's better to use dictionaries, since they are easier to access and the chances
    of running into exceptions is also meager. That being said, dictionaries are also
    not perfect data structures, and we will see the reason why most people prefer
    lists over dictionaries in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also another way of creating a dictionary, which is using the `dict()`
    method. Let''s see how it is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We have created an empty dictionary using the built-in `dict()` method. Now,
    let''s see how we can add elements to that dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Since we have seen how to create our own dictionary using two methods, let's
    see how we can fetch every element of that dictionary. Since our data structure
    may contain many values, we must use loops to iterate over it. We'll look at how,
    w can loop through dictionaries in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Looping through dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since dictionaries contain a finite number of keys and values, we can use a
    `for` loop to iterate over it. A `for` loop will traverse through the keys of
    the dictionary. The value of a particular key can be extracted by using square
    brackets, `[]`, and passing keys inside it. Let''s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, `info[key]` is going to extract the value of that key.
    The `for` loop will traverse through the keys of the dictionary, and iterating
    the `key` variable will store the key of the dictionary in each iteration. However,
    if we want to extract the key and value within the for loop, we will get `ValueError`.
    Let''s see what I mean by this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We get the preceding error because dictionaries are not iterables. However,
    we can convert it into another data structure, such as a tuple or lists so that
    we can fetch keys and values directly within the definition of the `for` loop.
    We will make this dictionary iterable by converting it into a tuple, which will
    be covered in the upcoming section about tuples.
  prefs: []
  type: TYPE_NORMAL
- en: Python provides a bunch of built-in methods in order to manipulate dictionaries
    according to your needs. For example, if you want to delete an item or insert
    an item to the dictionary, you don't have to make your custom logic to implement
    it; instead, Python has built-in functions for this. We will cover some of the
    most important dictionary methods in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionary methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Adding elements to the dictionary is easier, and we have already seen a couple
    of examples of this. Now, let''s see how we can remove an element from the dictionary
    using the `pop()` method. For the argument that''s given as a key to `pop()`,
    this method removes and returns an element from that dictionary. Let''s look at
    a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to retrieve a particular value of the key, we can use the `get`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can call the `values` method into the dictionary, which will return an object
    view that will represent all the values of the dictionary. Similar to `values()`,
    we can use the `keys()` method to print dictionary objects, which will represent
    all the keys of the dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the `len()` method, which will return the number of items that
    are stored in the dictionary, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to print a shallow copy of your dictionary, the `copy()` method
    can be used, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now,we have looked at some examples that have given us the knowledge to create
    our own dictionary and showed us how to access them using various dictionary methods.
    Now, let's explore tuples—another immutable data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tuples are quite similar to lists in terms of processing, but they are immutable,
    unlike lists, which are mutable or changeable. We can store sequence of values
    within the tuple in a fashion that is similar to a list. Like we used `[]` to
    create a list, and `{}` to create a dictionary, we use `use()` to create tuples.
    The values that are stored in the tuple can be of any type, and each of these
    values are mapped by indexes in the same way as a list. The index of the first
    element of a tuple is zero, and it starts to increment with one, while at the
    same time, traversing from left to right. One of the merits of tuples is that
    they are iterables. Thus, we can convert non-iterable data structures, such as
    dictionaries, into tuple, so that we can extract key and value pairs within the
    loop declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a simple tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the built-in method in Python to create tuples. We can create
    empty tuples using the `tuple()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to create a tuple with a single element in it, you have to add
    a comma after adding this element, otherwise Python treats it as a built-in data
    type, such as an integer or a string, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to create tuples is to add a comma between each item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the operations that we perform for lists also work in the case of tuples.
    In order to access the elements of a tuple, we use the square bracket operator
    and pass the index to it, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Slice operations can be also performed for tuples in the same way as for lists.
    This operation will result in a range of values that can be extracted from the
    tuple. Have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Tuples do not support item assignment, which makes it an immutable data structure,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have learned about dictionaries and tuples, let's see how we can
    convert them from one to another. Because all the available data structures are
    not perfect, they have some pitfalls; therefore, the following section will be
    one of the most important sections that we have covered so far. This is where
    we will perform conversions between dictionaries and tuples.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples and dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dictionaries are not perfect iterables, which means we cannot use a `for` loop
    to extract keys and values directly from them. We can only extract keys from a
    dictionary, but if you want to extract the `key:value` pair, we have to convert
    it into another iterable data structure. Let''s look at an example and observe
    the result, which shows the conversion from a dictionary into a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The direct conversion of a dictionary into a list does not preserve the values
    of the dictionary. It gives an object that contains only the keys of the dictionary.
    This information is useless due to a lack of values. Let''s try to convert it
    into the tuple and see the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of using the `tuple()` method to convert a dictionary into a tuple,
    there is another effective way. We can perform the same task using the `items()`
    method. This is used to return the dictionary object that contains the list of
    where the keys and values are stored in the nested tuples, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can iterate in this object using a `for` loop and fetch the keys and
    values in the same step of its declaration, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We have covered three powerful data structures up until now—lists, dictionaries,
    and tuples. Next is **s****ets**; an unordered structure that is considered iterable
    and mutable, but does not store duplicate elements.
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's make things simple by comparing this data structure with the well-known
    concept of mathematics, which is a set. In mathematics, sets are considered a
    collection of distinct entities, which are normally considered objects. The numbers
    1, 2, and 3 are objects independently, but when they are combined, they form a
    single set, which has a size of 3\. They are no different in Python. A set in
    Python is a collection of objects, which are neither ordered nor indexed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python sets can be created using two different methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one is similar to the way in which dictionaries are created; instead
    of key and value pairs, we will pass objects in their own right, as shown in the
    following example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way is by using a Python built-in method, that is, `set()`, where you
    have to pass your sequence of objects in the form of list, as shown in the following
    example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that the elements inside the curly braces
    are unordered. The order of objects, which we passed while creating the sets,
    is not preserved. They also do not support duplicate items in the sets. If there
    is repetition of the same elements multiple times within the set, only one element
    will be kept, and all the others will be removed from the structure, as shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Sets are also non-indexed, unlike lists and tuples. If you want to access the
    elements of sets, you cannot use the indexing technique, as it will throw a `TypeError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Since sets are iterables, we can only access them through loops. The appropriate
    loop will be the for loop because we do not have to worry about the terminating
    point while using it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have seen how to create and access sets of our own, let's delve
    into the basic methods of sets that are available so that we can manipulate their
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: Set methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sets are mutable, but once they have been created, you cannot change their
    items; rather, you can add or delete items from that set. It is quite similar
    to a list, but it is ordered. Now, let''s start this topic with the most commonly
    used methods of Python sets:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add single and multiple items to the list, and there are two ways of
    doing this. The `add()` method will insert only a single item into the set at
    any time. On the other hand, the `update()` method will add multiple items to
    the set at the same time. The addition of the elements will be unordered, and
    they may be inserted at any position:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'There are many ways of removing elements of sets. Methods such as `remove()`,
    `discard()`, and `pop()` can be used. If the item that you want to remove from
    the set does not exist, `remove()` will throw an exception, which goes by the
    name of `KeyError`, but in the case of the `discard()` method, our code won''t
    run into any errors, as shown in the following example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the `pop()` method to remove elements from a set. `pop()` will
    remove only the last element from the set. However, we don''t know which element
    will be the last in the set, since it is unordered and non-indexed. Thus, using
    `pop()` will be dangerous, as we won''t know about the removal of specific items.
    `pop()` will return an item that is removed from the set, as shown in the following
    example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to delete each and every element from the set, two methods can
    be used, but the results of these operations are slightly different. The `del`
    keyword can be used, along with the name of the set, in order to remove an entire
    element of a set along with the set, structure. On the other hand, the `clear()`
    method is used to empty the set, but its structure won''t be completely removed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also perform operations such as union, an intersection between sets,
    just like we do in mathematics. The union operation returns a set that contains
    all the elements from the original set, and all the items from the specified set.
    The set removes duplicate items. If any item is present in more than one set,
    it will be added only once in the resulting set. You can perform union between
    multiple sets by separating each of them with a comma:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We have the `intersection()` method, which will result in a set of items that
    is common between multiple sets, as shown in the following example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In the previous sections, we covered the fundamentals of Python. We have established
    a strong foundation of core programming up to this point, but we are not capable
    of building an advanced game yet.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming sections, we will delve into the most important concept, not
    only for Python, but for programming in general, that is, **functions**. After
    that section, you will possess procedural programming power, which will be helpful
    when we cover every advanced game that we will build from that point onward.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First of all, let''s recall all the topics that we have learned so far and
    observe procedural programming functions and why they are needed in the first
    place. We learned how to create multiple lines of statements using variables,
    numbers, modules, conditionals, and looping. However, we didn''t stop there; we
    covered all the fundamental data structures of Python, such as lists, dictionaries,
    tuples, and sets. This programming paradigm will result in an abundance in lines
    of code, and sometimes we may need to call the same code again and again. Have
    a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are adding two digits. Every time we perform an addition,
    we need to write two digits, followed by addition operators. Instead of doing
    the same task for many addition operations, why not make a single statement, which
    can perform addition, and put that statement into the scope where we can call
    it multiple times? This scope represents functions. We can invoke the execution
    of this statement multiple times by calling these functions. Let''s make a function
    that can add any two numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we defined the function with `add`. The `def` keyword,
    along with a name, is used to specify the Python parser in order to create functions.
    Inside the scope of the function, we can add multiple statements. Now, instead
    of manually adding two digits every time, we can call this `add` function to perform
    addition between any digits. So, this part of code is usable for operations that
    can add any two digits. The first task is to declare the function, which is what
    we just did; the next task is to call that function. You won''t execute any operation
    that is inside that function until you call that function. You have to use the
    same function name in order to invoke that function. Now, if you want to perform
    an `add` operation, you need to call it with same the signature, `add`, and pass
    two values as an argument to it. If you pass a number, it will be passed as an
    argument to that function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding result, each digit that is inside parentheses is passed to
    the function argument: a and b. At the first operation, `add(4,5)`, 4 is passed
    as a value to variable a, and 5 is passed as a value to variable b.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s compare these functions with the following coffee machine. We feed raw
    materials such as coffee beans, sugar, and water to the coffee machine, which
    will process those materials, and provide us with a coffee. In the same way as
    a coffee machine, functions also take raw arguments containing values as input.
    These arguments will be used for processing, which is done inside the function,
    and gives us meaningful results. Sometimes, functions do not return anything;
    we call these `void`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/e7096471-8dcd-4b00-bf32-b201532c734e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have look at couple of examples where we called the functions by name, but
    their declaration was carried out internally by Python. For instance, take the
    example of the `print()` method. We used this function to print any messages to
    the user on the Terminal, but we didn''t define it using the `def` keyword; we
    simply called it because it''s a built-in function. Thus, if you are using any
    functions such as `print()`, `input()`, or `type()`, you are calling that function
    by passing an argument inside its parentheses. You can see the implementation
    of `print()`, or any other built-in method of Python, by taking a tour of the
    official Python documentation. While calling `input()` or `print()`, we pass a
    string as an argument inside its parenthesis. Let''s look at an example of a function
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we made a call to the function with `type`. The arguments
    are passed inside the parenthesis of the function. We can pass as many arguments
    as we like as an expression inside the parenthesis, but we have to make sure that
    we pass only the required positional arguments. In the function declaration, if
    we made a function with two parameters, while calling, we should pass the same
    amount of arguments. Otherwise, it will throw us an error, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, we can conclude that functions take an argument, execute some statements
    based on that argument, and return a result. In our `add(a,b)` function, we printed
    the result inside the function, but instead of printing it inside the scope of
    the function, we used the `return` keyword in order to return a `result` from
    the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, we have two types of functions. One prints the results inside the scope
    of a function, rather than returning results from it which are normally void.
    Although Python has nothing nomenclature for void functions, other programming
    languages call these void functions, which means they return nothing. Another
    type will yield a return value of the function. Those return values should be
    captured when a function is called, just like in the code: `result = add(3,5)`.
    The value of `result` is the return value of the function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You may encounter a situation where a function has to return multiple value.
    We can use the tuple structure to return multiple values from the function. Let''s
    take a look at the following simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: We'll learn about the concept of *default arguments* in the next section. Learning
    about this will help us build more flexible functions and so this is an important
    topic.
  prefs: []
  type: TYPE_NORMAL
- en: Default arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'During the function call, we usually pass a value as a positional argument
    to the respective parameters. However, if we make a mistake by passing one less
    or one more than is required, our program will run into an exception. Thus, it
    is always good practice to specify some arguments as default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s look at the power of default arguments. Before using them, you
    should remember that default arguments must be placed at the end of the argument
    order. The syntax for creating a default argument is `argument_name = value`.
    In the preceding example, if you want to make `str1` the default argument, it
    should be placed after `str2`, otherwise you will get a syntax error from the
    Python interpreter, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'As the error message clarifies, we cannot specify a default argument to the
    left positional one. They should be followed by non-default arguments, as shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, have a look at the part where we called the function
    with only one argument in it. Now, that argument is a positional argument. As
    it is in position one, it will be passed to the first parameter of the function.
    Thus, the `Python` value will be passed to the `str1` parameter. After the `Python`
    value, we passed nothing. Instead of running into `TypeError`, we were able to
    get a proper result. This is the power of default arguments. However, if you pass
    another value to that default argument at the time of the function call, the default
    argument value will be overwritten with a new one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Up until now, we were able to call the function with a few positional arguments,
    such as a and b. But what if we have to make a function that can add 200 numbers?
    Calling a function such as `add(a,b,c,d,..)`, in which each variable represents
    one number, is not possible. We will have a shortage of variables, too, because
    for 200 numbers, we have to maintain 200 variables. So, the most efficient way
    would be to pack all of those arguments into one, and pass it as a single argument
    to the function. Then, the function will unpack that variable and perform the
    relevant operations. We can use the list data structure as a variable to store
    those multiple values. We'll look at how to pack and unpack normal and keyword
    arguments in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Packing and unpacking arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a simple example that will help us understand why we need this
    method of packing and unpacking in the first place. In this example, we are going
    to add numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Our code works fine for fewer numbers, maybe up to 10 values. Little modification
    should be done with a small increase in numbers, but that''s fine. However, what
    if we have 100 numbers? Tracking each of these numbers into variables is not possible
    and not effective. Our code would also look unprofessional. Now, here comes the
    crazy feature of Python that goes by the name of packing the arguments. Here,
    we are taking about arguments, that is, normal arguments such as list and tuple.
    We can make a list that contains multiple numbers. Let''s see how we can make
    a function that can add multiple numbers using the case of packing the arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Let's observe the code that we have written here. The `*arg` convention is used
    for packing the arguments. Here, `args` refers to arguments, which is the default
    naming convention for arguments in Python, but you can name it anything as long
    as you follow the rules and conventions of the variable naming pattern. A single
    asterisk (`*`) is essential, which shows that we are packing into a single argument.
    We are packing every item into `args`; therefore, `args` will be built as a list.
    We know that the lists are iterable, which allows us to loop within it using for
    loop. Now, while calling the function, we do not have to worry about any positional
    arguments or even parameters that contain values. Every piece of data that is
    passed during the function call will be packed into the list using this method.
    Now, we are not restricted to using parameters that assign values to specified
    positional arguments. We can perform these packing argument techniques for every
    data type, or even for structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unpacking arguments also works in a similar way to that of packing. We use
    a single asterisk abreast of the argument to specify that we are using the unpacking
    technique. Here, the argument must be a list, a string, or another structure that
    represents collections of items. Have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the argument is passed as a string (`Python`), we unpacked it so that
    every element is printed separately, with some spaces. You can also unpack elements
    of a list structure as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: So, we can pack and unpack normal arguments using a single asterisk, but in
    order to pack and unpack keyword arguments, we have to use a double asterisk.
    The syntax that is used for packing and unpacking a keyword argument is `**kwargs`.
    Just remember to use a single asterisk for normal arguments, and a double asterisk
    for keyword arguments. `args` represent arguments and `kwargs` is the naming convention
    for keyword arguments. We'll see some examples of packing and unpacking keyword
    arguments in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Packing and unpacking keyword arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Keyword arguments refer to dictionaries. Dictionaries cannot be packed and
    unpacked in a similar way to normal arguments such as lists or tuples. Dictionaries
    contain key and value pairs; thus, they cannot be packed and unpacked in the normal
    way. To distinguish them from normal arguments, we use a double asterisk. `**kwargs`
    is used to pack all the elements of a dictionary into a single argument. However,
    we know that dictionaries are not iterable, or in other words, we cannot loop
    inside dictionaries and fetch key and value pairs directly. In order to retrieve
    key and value pairs, we need to convert `kwargs` into a tuple using the `items()`
    method. We have seen its implementation in the preceding section. Let''s look
    at a simple example of how to implement packing keyword-arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we did two things: we made a dictionary that will
    be packed into a single argument using `**dictionary`, and passed each value to
    the positional arguments of function. In the dictionary definition, the keys of
    the dictionary must be the same as the parameters that are used while making the
    function, that is, `name`, `age`, and `like`. Even single typos will result in
    `TypeError`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to cover unpacking keyword arguments. The syntax will be similar,
    which contains a double asterisk and is followed by the dictionary name, or `kwargs`.
    Since we are unpacking, we have to add `**kwargs` as a parameter of function,
    because unpacking has to be done inside the function. Let''s look at the a simple
    example to clarify this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'While calling the `about` function, we passed a value to the argument, like
    we normally pass in the case of a normal function. For example, `Python` is the
    argument and it has a value of string. Now, this value is passed to the parameter
    of the `about` function. However, there is no parameter with the name of `Python`
    or `Java` within the function parenthesis. Instead, there is `**kwargs`, which
    is going to convert these `argument_name = value` formats into the dictionary.
    This is a form of packing the argument. Now, while inside the function, we have
    to unpack it. At this time, we know that `kwargs` is a dictionary, which is not
    iterable. We cannot fetch its `key:value` pair without converting it into a tuple
    or a list. One easy way to convert a dictionary into a tuple is by using the `items()`
    method. Now, after converting a dictionary into a tuple object using the `items()`
    method, `kwargs` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are looping around these items of the tuple object, and each object
    contains a key and a value separated by a comma. Thus, for each iteration, we
    get key and value pairs, and we print it by formatting it properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we possess the knowledge that will not only help us create our own functions,
    but also modify them according to our needs. If you want to make your program
    more reusable and sturdy, methods such as packing and unpacking arguments must
    be used. After this broad concept of functional programming, it''s time to explore
    three important functions in Python: the anonymous, recursive, and built-in functions.
    Let''s take a look at each of them one by one. We will begin with the *Anonymous
    function*.'
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the name suggests, these functions do not have any name or signature. In
    the same way that we used the name of the `add(a,b)` function to carry out an
    addition operation between two numbers, this `add` signature is invalid in the
    case of the anonymous function. If you recall the way we created a normal function
    using the `def` keyword, in the case of an anonymous function, we use the `lambda`
    keyword. Thus, anonymous functions are also called lambda functions. We need to
    remember two things while creating any function: arguments and expressions. Arguments
    are the independent and specific input to the function, whereas expressions are
    embedded inside the body of the function. In the case of the `lambda` function,
    we can pass any number of arguments, but only one expression. This implies that
    only one operation can be done with the `lambda` function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make a simple `lambda` function in order to grasp this information easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `square` is the container for the result. Since the `lambda`
    function does not contain a unique signature or name, we should pass an argument
    as a value using this container, that is, `square`. Here, the syntax to use for
    the `lambda` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the `arguments` and `expression` names; we cannot add multiple statements
    inside the `lambda` function. If we try to execute multiple statements inside
    the `lambda` function, we will run into the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: We passed `x,y`, that is, multiple arguments, which is completely valid, but
    two expressions, `x//y` and `x%y`, are not executed by `lambda`. We will use these
    `lambda` functions for creating games in the upcoming chapters. Since we have
    many things to cover in this chapter, and we are running out of space, I would
    like to end this topic right here; however, I highly urge you to practice these
    types of functions a little more. You can always use the Python documentation
    to help.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at another type of function: **recursion**—a computer programming
    technique involving the use of a procedure, subroutine, function, or algorithm
    that calls itself in a step, has a termination condition, and when the terminating
    condition is met, the program also terminates.'
  prefs: []
  type: TYPE_NORMAL
- en: Recursive functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to uncover another programming paradigm, known
    as recursive programming. Recursion is a way of programming where a function will
    call itself multiple times until a particular condition is met. Inside the body
    of the function, we will call the same function itself, which makes it a recursion.
    It is somewhat similar to nested conditionals, where we have another scope of
    `if..else` inside single `if` conditionals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recursion should have a base or a terminating condition in order to specify
    the stopping criterion for the program. Without a base condition, our recursive
    program is not going to operate viably. If the base condition is not met at the
    point of program execution, the recursive program will result in an infinite loop.
    Let''s jump to a simple programming example to observe the working principle of
    recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s explore the preceding example to uncover interesting facts about recursive
    programming. Printing a factorial of any number is a simple example that we can
    refer to while learning about recursive programming. In the preceding program,
    we have a base or terminating condition: when the number is one, we return one.
    This is not a random statement; rather, it is a mathematical pattern for finding
    a factorial number. Have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'For any number, the process of finding a factorial ends after we encounter
    one. Thus, it is a base condition, and whenever our program triggers it, we can
    terminate our program. Inside the scope of the `else` part of the program, we
    are calling the factorial function again, but with a different argument. You can
    observe the example where we found a factorial of five; each time we go to the
    next step, we are decreasing that number by one and multiplying it with the current
    number, which represents this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '`>>> number*factorial(number-1)`. This condition is called a recursive case,
    which leads to recursion.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, there are two ways of making logic with Python: with fundamental logic
    using loops and conditionals, or with recursion. Sometimes, it will be hard to
    get a solution using brand new logic, and in such situations we give recursion
    a try. Although recursion code looks simpler and cleaner, it is an expensive call
    in comparison to other code, because it takes a lot of time and space during computation.
    Now, let''s talk about a faster and cheaper way to execute an operation using
    built-in functions. We have covered so many built-in functions already, such as
    `max()`, `min()`, and `len()`. Thus, this section will be rather easier to follow.'
  prefs: []
  type: TYPE_NORMAL
- en: Built-in functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python comes with multiple built-in functions that are available for us to
    use directly in our programs. We shouldn''t have to import them, or make any extra
    effort to execute them. For example, we have `print()`. We have unknowingly used
    so many built-in functions before, but they are also a type of function. The only
    difference is that they are made by Python creators. They are fast, and more importantly,
    using them makes our code simpler and cleaner. Just think like this: adding two
    numbers using our own custom method may take a minimum of three lines of code,
    but using a built-in function, we can do it in a single line, using the `sum()`
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: You can check each and every built-in function by taking a tour of the Python
    official documentation. Secondly, we can also get information containing a list
    of built-in functions within our Python shell. You can type the following `>>>
    dir(__builtins__)` command in order to get a list containing 68 built-in functions.
    We have already seen a few of the most important among them., for example, the
    `type()` method and the type-casting techniques. They all are achieved using built-in
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: I won't be covering every built-in function in this section, as that is not
    the actual motive of this book; instead, we will be going directly to the next
    topic, which will be an interesting one since we are going to modify our tic-tac-toe
    game using the functions and data structures that we have learned about so far.
    However, I highly encourage you to take a prudent step forward by learning about
    a few built-in functions on your own. They may not be important just yet, but
    they will surely come in handy at some point during your career.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned about data structures and functions, we will use them
    to modify the previously built tic-tac-toe game by adding intelligence to it.
    We will cover this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding intelligence into our game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have made multiple modifications throughout this chapter, such as adding
    conditionals and looping to enhance code structure and processing. However, this
    not isn't perfect yet. In this section, we are going to modify our tic-tac-toe
    game using the functions and data structures that we have learned about in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Since the function is going to make our code smaller in length by eliminating
    the repetition of code, and also debugging it, it will be also easier to make
    changes in the code at a later stage; you can simply redirect to a specific function
    instead of traversing the entire program. So, these two features will be helpful
    for us while printing the game board into the terminal. If you recall the code
    that we wrote in the previous chapter, code for printing board layouts was used
    repeatedly. Now, we can create a function that will have all the code we need
    inside it so that we can print the layout of the board, and we can call it any
    time and anywhere within the code.
  prefs: []
  type: TYPE_NORMAL
- en: The next implementation on our code will be subsuming intelligence for our tic-tac-toe
    game. Until this moment, if you run your tic-tac-toe game, you will find that
    it can be played by two players. However, both players should be using the same
    computer, and they should play it by toggling their turn. Now, we are going to
    add computer intelligence that can play our game as one player. We are literally
    making a game where the player can play against the computer.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, we will start by brainstorming the essentials of the game, and we
    will gather critical information about the game layout and models.
  prefs: []
  type: TYPE_NORMAL
- en: Brainstorming and information gathering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term *artificial intelligence* is very notorious in the tech world, but
    if you inspect the depth of it, it is a bunch of modules and conditionals that
    determine the flow of agents. Here, agents can be anything that make decisions,
    such as machines, humans, and robots. All these agents perform actions that can
    produce the most desirable results. In our game of tic-tac-toe, the agent is a
    computer player, and it should take actions that can beat our player in the game.
    We have a dedicated chapter to learning about AI and its rational agents, which
    will be covered after we finish learning basic game programming. However, in this
    section, we are going to create a simple AI that can decide on the most favorable
    move in order to beat a human player, or even end the game in a tie most of the
    time.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to take on the approach of procedural programming in order to add
    intelligence to the system. Don't get overwhelmed with the term procedural programming—it
    is just a way of making and using functions to achieve a goal. One thing you must
    remember is that every function should perform only one task. For example, we
    can make the `print_board()` function, which will just print the layout of the
    game every time we call it. This `print_board()` function is not going to take
    input from a user, or make any player a winner. Thus, the existence of functions
    should be preserved by performing only one modular task. We can also make the
    `is_winner()` function, which will check whether any player is the winner.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows  how a simple algorithm can be made for our game.
    Here, we can see how we can check for the positions on the tic-tac-toe board so
    that the computer''s next move will produce the best result; something closer
    to winning the game, or in the worst case, making the game be a draw instead of
    the  computer losing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/cb90d27c-adf9-415e-a234-7607649af642.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following diagram show the procedures that we need to complete in order
    to implement the second part of the algorithm, where we will track every occupied
    position of the human player and check whether they could win with their next
    move. If they can win, we will block those positions. We will also occupy the
    center and side positions so that no human player can win the game easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/79f3c230-ef01-42dc-aac8-4fe51d2e45d6.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we have formed the basic algorithm so that we can start writing the code
    that can implement basic intelligence in our game. We will use this knowledge
    in the next section, *Implementation of models for intelligence,* in order to
    address the model for intelligence.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation of models for intelligence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First of all, let''s refine our code using functions; let''s create a function
    named `printBoard()`.This function will contain lines of code that will print
    the board layout of our tic-tac-toe game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code will print board''s layout; if you want to execute the statements
    that are inside the function you have to call it. Here, we have to call it using
    the `board` argument, which is the list containing all the positions of the board,
    that is, ten empty places, `[''  ''] *10`. Let''s call this function and observe
    the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time to make a function that can check whether any player is the
    winner or not. We are not making any brand new logic here; instead, we are putting
    all the statements that we made in the preceding chapters inside the scope of
    the function. Now, each time any user makes a move in the board, we can call this
    function to check whether that particular player is the winner or not. Thus, functions
    can remove repetition or duplication of code. Let''s use the `isWinner()` method
    to check whether any user satisfies the condition to become the winner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the parameter to the `isWinner` function is `board`,
    which contains the positions of the board layout and the player's letter; either
    `X` or `O`. We are reusing the same code that we wrote in the previous chapter,
    with small modifications. This method is going to return a Bool type of either
    `True` or `False`, and we will call it every time the player makes a new move
    in the game. We are checking entire rows, columns, and diagonal positions of the
    board layout using this method, and if any user occupies it, this will return
    `True` or `False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the game of tic-tac-toe, we get to move the player in the form of the position
    and we assign the player''s character''s either `X` or `O`, to it. We have seen
    its implementation in the previous chapter. Here, we are going to make a separate
    function that will assign a value to the position. In the following code, the
    board represents the layout of the game containing the positions; `current_player`
    is either `X` or `O` and `move` is the input from the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time to make the computer play our game. Let''s recall the algorithm
    that we made in the preceding section. We are going to perform multiple checks:
    whether the computer can win in the next move or not, and whether a human player
    could win in the next move. If so, we will block the winning position. We cannot
    perform these operations in the real board layout game, because we don''t want
    our board layout to be populated. Thus, we are going to make a copy of the board
    layout so that we can perform these checking operations in the new clone board
    layout. Let''s make a function to copy the original board layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'After we clone the original board, we have to check whether there are free
    spaces available for the computer to make a move. Let''s make a function to check
    the available free spaces inside the board layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '`isSpaceAvailable` returns a Bool type: either `True` or `False`. It will return
    `True` if the move is available on the passed board layout. If the position is
    already occupied by any player, it will return `False`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to get into the main part of our topic: making the computer
    play our game. Let''s create a function named `makeComputerMove()` and pass the
    board argument and a `computerPlayer` character to it. Here, the board represents
    our board layout containing all the positions, and `computerPlayer` is a character,
    either `X` or `O`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `#part1`, we checked if the computer can win in the next
    move or not. At first, we looped into the entire position of the board layout
    and made a clone of the board using the `boardCopy` function. After that, we passed
    every position from 1 to 10 to check for space availability. We checked if that
    move was going to make the computer player the winner or not by using the `isWinner`
    function, and returned that specific move as the position if that was the case.
    This part of the code makes our computer player intelligent enough to decide the
    next move, based on its favorable prediction.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the process of adding intelligence to our computer player, the next step
    is to keep track of the human player''s movements. On doing so, we can make a
    smart move on the board so that the player won''t win the game easily. In addition,
    if the human player has occupied two positions on the row of the board, we can
    make our move to block the third position. Let''s write `#part2` of our `makeComputerMove()`
    function. In order to check whether the human player is going to win, we have
    to play the game as a human, but virtually. We can do this without affecting the
    original board because we can play as a human within the copy of the board. Now,
    to check whether the human player is going to win, we have to get a player letter,
    that is, either `X` or `O`. We can make a condition to check whether the human
    player is `X` or `O`. After getting that letter, we can play as a human virtually
    on the copy of board game, but remember that we are coding for the computer player:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: The code that we have just written is going to add a smart move for the computer
    player. We are making the computer play the tic-tac-toe game as a human, but virtually.
    We are checking if the human will win on the next move or not. If it they are,
    we will return that move so that the computer will place its letter in that position
    to block the human from winning the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'During the brainstorming and information gathering processes, we made a flowchart
    to track the activities that will embed intelligence into our computer player.
    We executed two of them: checking the best move to win, and blocking the next
    best move of the human player. We can also make the computer player smarter by
    making an initial move, which the human player would normally do. For example,
    when we play tic-tac-toe, we start by taking the center position, because we think
    it is the best position to start with. So, why not make the computer to do that
    too? Let''s write some code where the computer will check the availability of
    the center position on the board and reserve that position accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'We can make this computer player even smarter by checking the availability
    of the corner positions, too. The corner positions on the board are `[1,3,7,9]`.
    Since there are four corners on our board, we maintained the list to track them.
    Now, let''s create a new `getRandomMove()` function, which will take the board
    and moves as arguments. The moves argument will be in the form of a list, such
    as the corner positions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: A lot of things are going on in the preceding code, so let's break things down
    to make it simpler. First of all, this method is going to take moves which will
    be in the form of a list, that is, `[1,2,3,4,5]`; among them, we have to choose
    only one element using this function. However, the elements of this list are not
    only numbers; they are moves or positions of the board layout. Thus, we have to
    check for the availability of spaces for each move of that list. If there are
    available spaces, we append that move to a new list called `availableMoves`. After
    the filtering is done, we perform conditionals to check whether there are any
    available moves or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `>>> availableMoves.__len__() != 0` expression is the same as `len(availableMoves)`,
    which is going to return the length of the list. We call these implementations
    (`__len__()`) data models, and we have an upcoming dedicated chapter that will
    cover them. If the length of `availableMoves` is zero, we are going to return
    `None`. But if it is not zero, we will execute an expression. Let''s break this
    expression down into fragments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import random`: If you recall the topics of [Chapter 2](06cdc81b-3e57-405e-b721-235214498ac7.xhtml), *Learning
    the Fundamentals of Python,* where we imported the math modules to perform mathematical
    computations such as square root and factorials, we imported math modules using
    the `import math` command. Now, we are importing a random module, which means
    that we can use methods that are defined inside it using this module. The syntax
    for calling a method from a random module is `random.method_name()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`random.choice()`: The choice method is going to pick up one random element
    from the list of elements that it has been called upon with. For example, the
    execution of the following command will give one random value from the range of
    values that''s been passed into it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: We passed `availableMoves` into it so that the `choice` method would pick any
    one of the moves randomly. This is essential for our gameplay because sometimes
    the computer must make decisions randomly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s call this `getRandomMove` function within the `makeComputerMove`
    function. If you take a look through the code of the `makeComputerMove` function,
    we have added a statement that will help the computer occupy the center position.
    What about corner positions? They are also an important position of the tic-tac-toe
    game. If we occupy the center and corner positions of the board, our computer
    will have a high chance of winning the game. Thus, we have to enhance our code,
    which will make the computer player capture the corner positions. Since the corner
    positions are `[1, 3, 7, 9]` we have to pass this as a list argument to the `getRandomMove`
    function, which we have just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we added code that will get random moves on any of the
    corner positions. We have covered the player moves for the center `position [5]`,
    and for corner positions `[1,3,7,9]`; now, we are left with the side positions,
    `[2,4,6,8]`. We made a call to the `getRandomMove` function, which will choose
    any one random move from the passed list.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned so many things in the preceding sections such as loops, conditionals,
    and many more. In the next section, we are going to write some code that will
    use them to control program flow. We will call it, the **main function**.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling program flow with main function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have written a bunch of functions such as `makeComputerMove`, `isWinner`,
    and many more, but they have not been called anywhere. We know that the function
    is not going to execute code inside it until we call it. Thus, we will make new
    function, that will take care of the flow of the program. We normally name it
    the main function, but you can literally name it anything you like. The code that
    we have wrote in the previous chapters, such as for the main game loop or toggling
    player turn, will be embedded inside this main function. The only function that
    needs to be called explicitly is this main function. Let''s create one now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'We have written the preceding code multiple times before, such as when printing
    the board, toggling the players, and creating a winner. The difference is, here,
    we are using functions. We have one task related to one function, such as `isWinner`,
    which checks if a player is the winner or not, and instead of writing an entire
    piece of code to check the winner, we write it once and use it in our main function.
    You can see that we have written some code take input from a user as a move value
    to the board game. We can make a function to take an input from a user. Let''s
    make it now, and make the main function cleaner and more readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add this newly created function to the main function. We will also
    complete the `else` part of the code, which will make the computer play our game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run our game and play against our custom-made AI agent. The following
    illustration show the output of our game, and shows the new tic-tac-toe board
    layout. This is made with the function call to `printBoard`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ad344339-a730-428a-a43a-c7779866475a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following illustration depicts the gameplay where the human player is playing
    against the computer AI. You can see that the human is defeated by the computer
    player:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/e6f59fb7-52ca-4a01-ab9b-bdc8a287e482.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we have made a layout that is appealing enough to entice any player to
    play the game. However, there are a few modifications that can be done, which
    will be covered in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Game testing and possible modifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The game that we have made in this chapter is playable enough against a computer.
    Using AI in the game is all about addressing all the probable situations that
    a game can face while interacting with the environment. In our tic-tac-toe game,
    we don't have many moves compared to Chess or Go, and so making an AI agent is
    easier. We were able to compete with the human by making an AI that was able to
    make two smart moves, such as checking for the next best move to win or blocking
    the human from winning through simulation. If you are wondering what simulation
    is, you will have to recall the algorithm that we have just implemented in order
    to check whether the human player is going to win in the next move. In addition,
    the computer player was acting as a human player on the clone board and played
    virtually, like a human. This is called simulation, where we made the computer
    imitate the real-world process or behavior of the system.
  prefs: []
  type: TYPE_NORMAL
- en: After predicting the best move to make through simulation, our program was returning
    the best possible next move for our computer player. Let's extrapolate this technique
    further. What we just did in our game was make an AI that can make a simulated
    environment to predict the next best move. The same technique is applied to a
    whole range of AI applications, for instance, a self-driving car; we make a simulated
    environment within the computer where the car is an agent, and will make decisions
    either to turn left or right based on obstacles. Tic-tac-toe is simple while interacting
    with the environment because of its lesser number of moves or situations, but
    programming a self-driving a car simulation requires us to acknowledge a whole
    range of situations that may arise while driving car on the road. Thus, we can
    conclude that AI is all about creating a program where the agent must consider
    all the situations it may face while interacting with the environment and respond
    to each of those situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our competitor is smart enough to make this game harder for the player to win,
    but humans also possess the ultimate power to make the computer player hamstrung.
    Human players won''t let a computer have an easy win. Thus, most of the time,
    our game will end in a tie. However, if you run the game, you''ll see we haven''t
    addressed those cases. Now, whenever our game is a tie, instead of stopping the
    game, our game will incessantly ask for input from the user. Instead, we have
    to give the user a message saying, try again, and facilitate the user to play
    our game again. In order to check for a tie condition, we have to check whether
    the board is full. When the board positions are fully occupied and nobody is the
    winner, we have a tie condition. We can make another function to check whether
    the board is full:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `isBoardOccupied()` function is going to return a Bool type,
    either `True` or `False`, based on the check, which will determine if the board
    is full or not. If the board is full, it will return `True` and if it is not,
    it will return `False`. We are using the `isSpaceAvailable()` function that we
    created in the preceding section, which will check whether there are any empty
    spaces on the board. Now, let''s refine our code with this new function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was concise and terse, containing an abundance of information,
    ranging from data structures to functions. These topics are the building blocks
    of any complex program, and so on, we will use them in every game that we will
    cover from the next chapter onward. We started this chapter by learning the necessity
    of data structures, and we delved into the fundamental data structures of Python
    such as lists, dictionaries, tuples, and sets. We covered the ways in which we
    can create those data structures and manipulate them.
  prefs: []
  type: TYPE_NORMAL
- en: We learned about ways to create user-defined functions, call them, and document
    them. We also saw that functions are like machines, where you can feed raw data
    in, and get output back as meaningful information. We saw the ways of inputting
    data to the functions using positional and default arguments. Then, we looked
    at saw the ways of modifying our functions by packing and unpacking of normal
    and keyword arguments in order to achieve the best performance from them.
  prefs: []
  type: TYPE_NORMAL
- en: We also modified our game further using functions and data structures, and we
    made simple algorithms that can address different possible situations of gameplay.
    We made our computer player smart enough to beat our human player. Then, we also
    made a simulation environment where an agent can test and train itself in order
    to predict the next best possible move. Although our game was simple to make,
    it has given us a broad range of ideas about the processes that need to be undertaken,
    such as brainstorming, designing, coding essentials, and analysis, before we actually
    start writing modular code.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we covered procedural programming, which refers to using functions
    to build programs. In the next chapter, we will cover procedural programming in
    terms of curses. We will create programs using terminal-independent, screen painter,
    and text-based terminals. We will make a snake game using a curses event and a
    screen painter and then use curses properties in order to make logic for playing
    the snake game.
  prefs: []
  type: TYPE_NORMAL
- en: Are you excited to hop into the next chapter? It will take you through an adventurous
    tour of game programming with the curses module, and we will learn how to handle
    user events and game consoles with it. Before that, I highly suggest that you
    refer to the official Python documentation and take a tour of the Python built-in
    data structures and modules; and practice with them without any additional help.
    The knowledge that we have gained so far will be used throughout the chapters
    of this book, so it's high time that revise the topics that we have learned about
    so far.
  prefs: []
  type: TYPE_NORMAL
