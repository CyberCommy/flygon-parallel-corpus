- en: Preface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Algorithms have always played an important role both in the science and practice
    of computing. This book focuses on utilizing these algorithms to solve real-world
    problems. To get the most out of these algorithms, a deeper understanding of their
    logic and mathematics is imperative. You'll start with an introduction to algorithms
    and explore various algorithm design techniques. Moving on, you'll learn about
    linear programming, page ranking, and graphs, and even work with machine learning
    algorithms, understanding the math and logic behind them. This book also contains
    case studies, such as weather prediction, tweet clustering, and movie recommendation
    engines, that will show you how to apply these algorithms optimally. As you complete
    this book, you will become confident in using algorithms for solving real-world
    computational problems.
  prefs: []
  type: TYPE_NORMAL
- en: Who this book is for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book is for the serious programmer! Whether you are an experienced programmer
    looking to gain a deeper understanding of the math behind the algorithms or have
    limited programming or data science knowledge and want to learn more about how
    you can take advantage of these battle-tested algorithms to improve the way you
    design and write code, youâ€™ll find this book useful. Experience with Python programming
    is a must, although knowledge of data science is helpful but not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: What this book covers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chapter 1, *Overview of Algorithms*, summarizes the fundamentals of algorithms.
    It starts with a section on the basic concepts needed to understand the working
    of different algorithms. It summarizes how people started using algorithms to
    mathematically formulate certain classes of problems. It also mentions the limitations
    of different algorithms. The next section explains the various ways to specify
    the logic of an algorithm. As Python is used in this book to write the algorithms,
    how to set up the environment in order to run the examples is explained next.
    Then, the various ways in which an algorithm's performance can be quantified and
    compared against other algorithms are discussed. Finally, this chapter discusses
    various ways in which a particular implementation of an algorithm can be validated.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 2](04672393-683c-406b-8dd1-4dab5b5d9c4f.xhtml), *Data Structures Used
    in Algorithms*, focuses on algorithms'' need for necessary in-memory data structures
    that can hold the temporary data. Algorithms can be data-intensive, compute-intensive,
    or both. But for all different types of algorithms, choosing the right data structures
    is essential for their optimal implementation. Many algorithms have recursive
    and iterative logic and require specialized data structures that are fundamentally
    iterative in nature. As we are using Python in this book, this chapter focuses
    on Python data structures that can be used to implement the algorithms discussed
    in this book.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 3](7f694829-0525-42b1-a485-fb37a07f31ec.xhtml), *Sorting and Searching
    Algorithms*, presents core algorithms that are used for sorting and searching.
    These algorithms can later become the basis for more complex algorithms. The chapter
    starts by presenting different types of sorting algorithms. It also compares the
    performance of various approaches. Then, various algorithms for searching are
    presented. They are compared and their performance and complexity are quantified.
    Finally, this chapter presents the actual applications of these algorithms.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 4](d8aca545-f465-4ab2-9f26-28e658b90a33.xhtml), *Designing Algorithms*,
    presents the core design concepts of various algorithms. It also explains different
    types of algorithms and discusses their strengths and weaknesses. Understanding
    these concepts is important when it comes to designing optimal complex algorithms.
    The chapter starts by discussing different types of algorithmic designs. Then,
    it presents the solution for the famous traveling salesman problem. It then discusses
    linear programming and its limitations. Finally, it presents a practical example
    that shows how linear programming can be used for capacity planning.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 5](051e9b32-f15f-4e88-a63a-ae3c14696492.xhtml), *Graph Algorithms*,
    focuses on the algorithms for graph problems that are common in computer science.
    There are many computational problems that can best be represented in terms of
    graphs. This chapter presents methods for representing a graph and for searching
    a graph. Searching a graph means systematically following the edges of the graph
    so as to visit the vertices of the graph. A graph-searching algorithm can discover
    a lot about the structure of a graph. Many algorithms begin by searching their
    input graph to obtain this structural information. Several other graph algorithms
    elaborate on basic graph searching. Techniques for searching a graph lie at the
    heart of the field of graph algorithms. The first section discusses the two most
    common computational representations of graphs: as adjacency lists and as adjacency
    matrices. Next, a simple graph-searching algorithm called *breadth-first search*
    is presented and shows how to create a breadth-first tree. The following section
    presents the depth-first search and provides some standard results about the order
    in which a depth-first search visits vertices.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 6](ce14ecc1-8ad5-406e-88d0-7f3acb3e4569.xhtml), *Unsupervised Machine
    Learning Algorithms*, introduces unsupervised machine learning algorithms. These
    algorithms are classified as unsupervised because the model or algorithm tries
    to learn inherent structures, patterns, and relationships from given data without
    any supervision. First, clustering methods are discussed. These are machine learning
    methods that try to find patterns of similarity and relationships among data samples
    in our dataset and then cluster these samples into various groups, such that each
    group or cluster of data samples has some similarity, based on the inherent attributes
    or features. The following section discusses dimensionality reduction algorithms,
    which are used when we end up having a number of features. Next, some algorithms
    that deal with anomaly detection are presented. Finally, this chapter presents
    association rule-mining, which is a data mining method used to examine and analyze
    large transactional datasets to identify patterns and rules of interest. These
    patterns represent interesting relationships and associations, among various items
    across transactions.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 7](e3df232d-9571-4514-a5f1-2789965492e1.xhtml), *Traditional Supervised
    Learning Algorithms*, describes traditional supervised machine learning algorithms
    in relation to a set of machine learning problems in which there is a labeled
    dataset with input attributes and corresponding output labels or classes. These
    inputs and corresponding outputs are then used to learn a generalized system,
    which can be used to predict results for previously unseen data points. First,
    the concept of classification is introduced in the context of machine learning.
    Then, the simplest of the machine learning algorithms, linear regression, is presented.
    This is followed by one of the most important algorithms, the decision tree. The
    limitations and strengths of decision tree algorithms are discussed, followed
    by two important algorithms, SVM and XGBoost.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 8](e1eec5e4-0365-4aeb-94d7-2e3ae02fc18c.xhtml), *Neural Network Algorithms*,
    first introduces the main concepts and components of a typical neural network,
    which is becoming the most important type of machine learning technique. Then,
    it presents the various types of neural networks and also explains the various
    kinds of activation functions that are used to realize these neural networks.
    The backpropagation algorithm is then discussed in detail. This is the most widely
    used algorithm to converge the neural network problem. Next, the transfer learning
    technique is explained, which can be used to greatly simplify and partially automate
    the training of models. Finally, how to use deep learning to detect objects in
    multimedia data is presented as a real-world example.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 9](52941f90-e073-4415-b2ba-accf7507b7a2.xhtml), *Algorithms for Natural
    Language Processing*, presents algorithms for **natural language processing**
    (**NLP**). This chapter proceeds from the theoretical to the practical in a progressive
    manner. First, it presents the fundamentals, followed by the underlying mathematics.
    Then, it discusses one of the most widely used neural networks to design and implement
    a couple of important use cases for textual data. The limitations of NLP are also
    discussed. Finally, a case study is presented where a model is trained to detect
    the author of a paper based on the writing style.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 10](8bad1434-aba4-4e14-8846-d1db0dcbb682.xhtml), *Recommendation Engines,*
    focuses on recommendation engines, which are a way of modeling information available
    in relation to user preferences and then using this information to provide informed
    recommendations on the basis of that information. The basis of the recommendation
    engine is always the recorded interaction between the users and products. This
    chapter begins by presenting the basic idea behind recommendation engines. Then,
    it discusses various types of recommendation engines. Finally, this chapter discusses
    how recommendation engines are used to suggest items and products to different
    users.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 11](f00b92cb-0750-4423-b98f-f9b1ce46fd39.xhtml), *Data Algorithms,*
    focuses on the issues related to data-centric algorithms. The chapter starts with
    a brief overview of the issues related to data. Then, the criteria for classifying
    data are presented. Next, a description of how to apply algorithms to streaming
    data applications is provided and then the topic of cryptography is presented.
    Finally, a practical example of extracting patterns from Twitter data is presented.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 12](d08b4e08-c668-46fe-aed8-7e2c8855b993.xhtml), *Cryptography,* introduces
    the algorithms related to cryptography. The chapter starts by presenting the background.
    Then, symmetrical encryption algorithms are discussed. MD5 and SHA hashing algorithms
    are explained and the limitations and weaknesses associated with implementing
    symmetric algorithms are presented. Next, asymmetric encryption algorithms are
    discussed and how they are used to create digital certificates. Finally, a practical
    example that summarizes all these techniques is discussed.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 13](271840d5-2d10-4fde-b403-d1a6657e10df.xhtml), *Large-Scale Algorithms,*
    explains how large-scale algorithms handle data that cannot fit into the memory
    of a single node and involve processing that requires multiple CPUs. This chapter
    starts by discussing what types of algorithms are best suited to be run in parallel.
    Then, it discusses the issues related to parallelizing the algorithms. It also
    presents the CUDA architecture and discusses how a single GPU or an array of GPUs
    can be used to accelerate the algorithms and what changes need to be made to the
    algorithm in order to effectively utilize the power of the GPU. Finally, this
    chapter discusses cluster computing and discusses how Apache Spark creates **resilient
    distributed datasets** (**RDDs**) to create an extremely fast parallel implementation
    of standard algorithms.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 14](28c50635-5b35-4f5f-a65b-2d4e984bdad5.xhtml), *Practical Considerations*,
    starts with the important topic of explainability, which is becoming more and
    more important now that the logic behind automated decision making has been explained.
    Then, this chapter presents the ethics of using an algorithm and the possibilities
    of creating biases when implementing them. Next, the techniques for handling NP-hard
    problems are discussed in detail. Finally, ways to implement algorithms, and the
    real-world challenges associated with this, are summarized.'
  prefs: []
  type: TYPE_NORMAL
- en: To get the most out of this book
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Chapter number** | **Software required (with version)** | **Free/Proprietary**
    | **Hardware specifications** | **OS required** |'
  prefs: []
  type: TYPE_TB
- en: '| 1-14 | Python version 3.7.2 or later | Free | Min 4GB of RAM, 8GB +Recommended.
    | Windows/Linux/Mac |'
  prefs: []
  type: TYPE_TB
- en: '**If you are using the digital version of this book, we advise you to type
    the code yourself or access the code via the GitHub repository (link available
    in the next section). Doing so will help you avoid any potential errors related
    to the copying and pasting of code.**'
  prefs: []
  type: TYPE_NORMAL
- en: Download the example code files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can download the example code files for this book from your account at [www.packt.com](http://www.packt.com).
    If you purchased this book elsewhere, you can visit [www.packtpub.com/support](https://www.packtpub.com/support)
    and register to have the files emailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the code files by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in or register at [www.packt.com](http://www.packt.com).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Support tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Code Downloads.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the name of the book in the Search box and follow the onscreen instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the file is downloaded, please make sure that you unzip or extract the
    folder using the latest version of:'
  prefs: []
  type: TYPE_NORMAL
- en: WinRAR/7-Zip for Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zipeg/iZip/UnRarX for Mac
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7-Zip/PeaZip for Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code bundle for the book is also hosted on GitHub at [https://github.com/PacktPublishing/40-Algorithms-Every-Programmer-Should-Know](https://github.com/PacktPublishing/40-Algorithms-Every-Programmer-Should-Know).
    In case there's an update to the code, it will be updated on the existing GitHub
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: We also have other code bundles from our rich catalog of books and videos available
    at  **[https://github.com/PacktPublishing/](https://github.com/PacktPublishing/)**.
    Check them out!
  prefs: []
  type: TYPE_NORMAL
- en: Download the color images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We also provide a PDF file that has color images of the screenshots/diagrams
    used in this book. You can download it here: [https://static.packt-cdn.com/downloads/9781789801217_ColorImages.pdf](https://static.packt-cdn.com/downloads/9781789801217_ColorImages.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: Conventions used
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of text conventions used throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: '`CodeInText`: Indicates code words in text, database table names, folder names,
    filenames, file extensions, pathnames, dummy URLs, user input, and Twitter handles.
    Here is an example: "Let''s see how to add a new element to a stack by using `push`
    or removing an element from a stack by using `pop`."'
  prefs: []
  type: TYPE_NORMAL
- en: 'A block of code is set as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When we wish to draw your attention to a particular part of a code block, the
    relevant lines or items are set in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Any command-line input or output is written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Bold**: Indicates a new term, an important word, or words that you see on
    screen. For example, words in menus or dialog boxes appear in the text like this.
    Here is an example: "One way to reduce the complexity of an algorithm is to compromise
    on its accuracy, producing a type of algorithm called an **approximate algorithm**."'
  prefs: []
  type: TYPE_NORMAL
- en: Warnings or important notes appear like this.Tips and tricks appear like this.
  prefs: []
  type: TYPE_NORMAL
