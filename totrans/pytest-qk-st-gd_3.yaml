- en: Fixtures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to use marks and parametrization effectively
    to skip tests, mark them as expected to fail, and parameterize them, to avoid
    repetition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tests in the real world often need to create resources or data to work on:
    a temporary directory to output some files to, a database connection to test the
    I/O layer of an application, a web server for integration testing. Those are all
    examples of resources that are required in more complex testing scenarios. More
    complex resources often need to be cleaned up at the end of the test session:
    removing a temporary directory, cleaning up and disconnecting from a database,
    shutting down a web server. Also, these resources should be easily shared across
    tests, because during testing we often need to reuse a resource for different
    test scenarios. Some resources are costly to create, but because they are immutable
    or can be restored to a pristine state, they should be created only once and shared
    with all the tests that require it, only being destroyed when the last test that
    needs them finishes.'
  prefs: []
  type: TYPE_NORMAL
- en: All of the previous requirements and more are covered by one of the most important
    of pytest's features: **fixtures**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what we will cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing fixtures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing fixtures with `conftest.py` files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scopes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autouse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parametrization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using marks from fixtures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of built-in fixtures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tips/discussion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing fixtures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most tests need some kind of data or resource to operate on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have a list of (`series name`, `year`, `rating`) tuples that we use
    to test the `highest_rated` function. Inlining data into the test code as we do
    here works well for isolated tests, but often you have a dataset that can be used
    by multiple tests. One solution would be to copy over the dataset to each test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: But this gets old quickly—plus, copying  and pasting things around will hurt
    maintainability in the long run, for example, if the data layout changes (adding
    a new item to the tuple or the cast size, for example).
  prefs: []
  type: TYPE_NORMAL
- en: Enter fixtures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pytest's solution to this problem is fixtures. Fixtures are used to provide
    resources that test the functions and methods we need to execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'They are created using normal Python functions and the `@pytest.fixture` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are creating a fixture named `comedy_series`, which returns the same
    list we were using in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tests can access fixtures by declaring the fixture name in their parameter
    list. The test function then receives the return value of the fixture function
    as a parameter. Here is the `comedy_series` fixture in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how things work:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pytest looks at the test function parameters before calling it. Here, we have
    one parameter: `comedy_series`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each parameter, pytest gets the fixture function of same name and executes
    it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The return value of each fixture function becomes a named parameter, and the
    test function is called.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that `test_highest_rated` and `test_oldest` each get their own copy of
    the comedy series list, so they don't risk interfering with each other if they
    change the list inside the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to create fixtures in classes using methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixtures defined in test classes are only accessible by test methods of the
    class or subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that test classes might have other non-test methods, like any other class.
  prefs: []
  type: TYPE_NORMAL
- en: Setup/teardown
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we've seen in the introduction, it is very common for resources that are
    used in testing to require some sort of clean up after a test is done with them.
  prefs: []
  type: TYPE_NORMAL
- en: In our previous example, we had a very small dataset, so inlining it in the
    fixture was fine. Suppose however that we have a much larger dataset (say, 1,000
    entries), so writing it in the code would hurt readability. Often, the dataset
    is in an external file, for example, in CSV format, so porting it into the Python
    code is a pain.
  prefs: []
  type: TYPE_NORMAL
- en: A solution to that would be to commit the CSV file containing the series dataset
    into the repository and read it inside the test, using the built-in `csv` module;
    for more details go to [https://docs.python.org/3/library/csv.html](https://docs.python.org/3/library/csv.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can change the `comedy_series` fixture to do just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This works, but we, being diligent developers, want to be able to close that
    file properly. How can we do that with fixtures?
  prefs: []
  type: TYPE_NORMAL
- en: 'Fixture clean up is often referred to as **teardown**, and it is easily supported
    using the `yield` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'By using  `yield` instead of `return`, this is what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: The fixture function is called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It executes until the yield statement, where it pauses and yields the fixture
    value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test executes, receiving the fixture value as parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regardless of whether the test passes or fails, the function is resumed so it
    can perform its teardown actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For those familiar with it, this is very similar to a **context manager** ([https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager](https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager)),
    except that you don't need to surround the yield statement with a try/except clause
    to ensure the block after yield is executed, even if an exception occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s return to our example; we can now use  `yield` instead of `return` and
    close the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This is good, but notice that because `yield` works well with the `with` statement
    of the file object, we can write this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The file will be closed automatically by the `with` statement after the test
    completes, which is shorter and considered more Pythonic.
  prefs: []
  type: TYPE_NORMAL
- en: Awesome.
  prefs: []
  type: TYPE_NORMAL
- en: Composability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose we receive a new series.csv file that now contains a much larger number
    of TV series, including the comedy series we had before and many other genres
    as well. We want to use this new data for some other tests, but we would like
    to keep existing tests working as they did previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fixtures in pytest can easily depend on other fixtures just by declaring them
    as parameters. Using this property, we are able to create a new series fixture
    that reads all the data from `series.csv` (which now contains more genres), and
    change our `comedy_series` fixture to filter out only comedy series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The tests which use `comedy_series` are unchanged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that, because of those characteristics, fixtures are a prime example of
    dependency injection, which is a technique where a function or an object declares
    its dependencies, but otherwise doesn't know or care how those dependencies will
    be created, or by who. This makes them extremely modular and reusable.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing fixtures with conftest.py files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose we need to use our `comedy_series` fixture from the previous section
    in other test modules. In pytest, sharing fixtures is easily done by just moving
    the fixture code to a `conftest.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `conftest.py` file is a normal Python module, except that it is loaded automatically
    by pytest, and any fixtures defined in it are available to test modules in the
    same directory and below automatically. Consider this test module hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `tests/conftest.py` file is at the root of the hierarchy, so any fixtures
    defined on it are automatically available to all other test modules in this project.
    Fixtures in `tests/io/conftest.py` will be available only to modules at and below
    `tests/io`, so only to `test_formats.py` for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'This might not look like a big deal, but it makes sharing fixtures a breeze:
    it is very liberating to be able to start small with just a few fixtures when
    writing a test module, knowing that if those fixtures are useful to other tests
    in the future, it will be just a small matter of moving the fixtures to a `conftest.py` to
    reuse them. This avoids the temptation to copy and paste test data around, or
    to spend too much time thinking about how to organize test-supporting code from
    the start, to avoid  having to do a lot of refactoring later.'
  prefs: []
  type: TYPE_NORMAL
- en: Scopes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fixtures are always created when a test function requests them, by declaring
    them on the parameter list, as we've seen already. By default, each fixture is
    destroyed when each test finishes.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned at the beginning of this chapter, some fixtures can be costly
    to create or set up, and it would be helpful to be able to create as few instances
    of it as possible, to save time. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Initializing database tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading cached data from a disk, for example, large CSV data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting up external services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To help solve this issue, fixtures in pytest can have different **scopes**.
    The scope of a fixture defines when the fixture should be cleaned up. While the
    fixture is not cleaned up, tests requesting the fixture will receive the same
    fixture value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The scope parameter of the @pytest.fixture decorator is used to set the fixture''s
    scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following scopes are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`scope="session"`: fixture is teardown when all tests finish.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scope="module"`: fixture is teardown when the last test function of a module
    finishes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scope="class"`: fixture is teardown when the last test method of a class finishes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scope="function"`: fixture is teardown when the test function requesting it
    finishes. This is the default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to emphasize that, regardless of scope, each fixture will be
    created only when a test function requires it. For example, session-scoped fixtures
    are not necessarily created at the start of the session, but only when the first
    test that requests it is about to be called. This makes sense when you consider
    that not all tests might need a session-scoped fixture, and there are various
    forms to run only a subset of tests, as we have seen in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Scopes in action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To show scopes in action, let's take a look at a common pattern that's used
    when your tests involve some form of database. In the upcoming example, don't
    focus on the database API (which is made up anyway), but on the concepts and design
    of the fixtures involved.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, the connection to a database and table creation are slow. If the database
    supports transactions, which is the ability to perform a set of changes that can
    be applied or discarded atomically, then the following pattern can be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'For starters, we can use a session-scoped fixture to connect and initialize
    the database with the tables we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that we prune the test database and disconnect from it at the end of the
    fixture, which will happen at the end of the session.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `db` fixture, we can share the same database across all our tests.
    This is great, because it saves time. But it also has the downside that now tests
    can change the database and affect other tests. To solve that problem, we create
    a transaction fixture that starts a new transaction before a test starts and rolls
    the transaction back when the test finishes, ensuring the database returns to
    its previous state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that our transaction fixture depends on `db`. Tests now can use the transaction
    fixture to read and write to the database at will, without worrying about cleaning
    it up for other tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'With just these two fixtures, we have a very solid foundation to write our
    database tests with: the first test that requires the transaction fixture will
    automatically initialize the database through the `db` fixture, and each test
    from now on that needs to perform transactions will do so from a pristine database.'
  prefs: []
  type: TYPE_NORMAL
- en: This composability between fixtures of different scopes is very powerful and
    enables all sorts of clever designs in real-world test suites.
  prefs: []
  type: TYPE_NORMAL
- en: Autouse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to apply a fixture to all of the tests in a hierarchy, even if
    the tests don't explicitly request a fixture, by passing `autouse=True` to the
    `@pytest.fixture` decorator. This is useful when we need to apply a side-effect
    before and/or after each test unconditionally.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'An autouse fixture is applied to all tests which the fixture is available for
    use with:'
  prefs: []
  type: TYPE_NORMAL
- en: Same module as the fixture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Same class as the fixture, in the case of a fixture defined by a method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tests in the same directory or below, if the fixture is defined in a `conftest.py`
    file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In other words, if a test can access an autouse fixture by declaring it in the
    parameter list, the autouse fixture will be automatically used by that test. Note
    that it is possible for a test function to add the autouse fixture to its parameter
    list if it is interested in the return value of the fixture, as normal.
  prefs: []
  type: TYPE_NORMAL
- en: '@pytest.mark.usefixtures'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `@pytest.mark.usefixtures` mark can be used to apply one or more fixtures
    to tests, as if they have the fixture name declared in their parameter list. This
    can be an alternative in situations where you want all tests in a group to always
    use a fixture that is not `autouse`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the code below will ensure all tests methods in the `TestVirtualEnv` class
    execute in a brand new virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As the name indicates, you can pass multiple fixtures names to the decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Parametrizing fixtures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fixtures can also be parametrized directly. When a fixture is parametrized,
    all tests that use the fixture will now run multiple times, once for each parameter.
    This is an excellent tool to use when we have variants of a fixture and each test
    that uses the fixture should also run with all variants.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapter, we saw an example of parametrization using multiple
    implementations of a serializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can update the example to parametrize on a fixture instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We pass a `params` parameter to the fixture definition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We access the parameter inside the fixture, using the `param` attribute of the
    special `request` object. This built-in fixture provides access to the requesting
    test function and the parameter when the fixture is parametrized. We will see
    more about the `request` fixture later in this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, we instantiate the serializer inside the fixture, instead of explicitly
    in each test.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As can be seen, parametrizing a fixture is very similar to parametrizing a
    test, but there is one key difference: by parametrizing a fixture we make all
    tests that use that fixture run against all the parametrized instances, making
    them an excellent solution for fixtures shared in `conftest.py` files.'
  prefs: []
  type: TYPE_NORMAL
- en: It is very rewarding to see a lot of new tests being automatically executed
    when you add a new parameter to an existing fixture.
  prefs: []
  type: TYPE_NORMAL
- en: Using marks from fixtures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use the `request` fixture to access marks that are applied to test functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have an `autouse` fixture that always initializes the current locale
    to English:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: But what if we want to use a different locale for just a few tests?
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to do that is to use a custom mark, and access the `mark` object from
    within our fixture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Marks can be used that way to pass information to fixtures. Because it is somewhat
    implicit though, I recommend using it sparingly, because it might lead to hard-to-understand
    code.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of built-in fixtures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a look at some built-in pytest fixtures.
  prefs: []
  type: TYPE_NORMAL
- en: tmpdir
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `tmpdir` fixture provides an empty directory that is removed automatically
    at the end of each test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Being a `function`-scoped fixture, each test gets its own directory so they
    don't have to worry about clean up or generating unique directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fixture provides a `py.local` object ([http://py.readthedocs.io/en/latest/path.html](http://py.readthedocs.io/en/latest/path.html)),
    from the `py` library ([http://py.readthedocs.io](http://py.readthedocs.io)),
    which provides convenient methods to deal with file paths, such as joining, reading,
    writing, getting the extension, and so on; it is similar in philosophy to the `pathlib.Path` object
    ([https://docs.python.org/3/library/pathlib.html](https://docs.python.org/3/library/pathlib.html))
    from the standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Why pytest use `py.local` instead of `pathlib.Path`?
  prefs: []
  type: TYPE_NORMAL
- en: Pytest had been around for years before `pathlib.Path` came along and was incorporated
    into the standard library, and the `py` library  was one the best solutions for
    path-like objects at the time. Core pytest developers are looking into how to
    adapt pytest to the now-standard `pathlib.Path` API.
  prefs: []
  type: TYPE_NORMAL
- en: tmpdir_factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `tmpdir` fixture is very handy, but it is only `function`*-*scoped: this
    has the downside that it can only be used by other `function`-scoped fixtures.'
  prefs: []
  type: TYPE_NORMAL
- en: The `tmpdir_factory` fixture is a *session-scoped* fixture that allows creating
    empty and unique directories at any scope. This can be useful when we need to
    store data on to a disk in fixtures of other scopes, for example a `session`-scoped
    cache or a database file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To show it in action, the `images_dir` fixture shown next uses `tmpdir_factory` to
    create a unique directory for the entire test session containing a series of sample
    image files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Because this will be executed only once per session, it will save us considerable
    time when running the tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tests can then use the `images_dir` fixture tests to easily access the sample
    image files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind however that a directory created by this fixture is shared and
    will only be deleted at the end of the test session. This means that tests should
    not modify the contents of the directory; otherwise, they risk affecting other
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: monkeypatch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In some situations, tests need features that are complex or hard to set up
    in a testing environment, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: Clients to an external resource (for example GitHub's API), where access during
    testing might be impractical or too expensive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forcing a piece of code to behave as if on another platform, such as error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complex conditions or environments that are hard to reproduce locally or in
    the CI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `monkeypatch` fixture allows you to cleanly overwrite functions, objects,
    and dictionary entries of the system being tested with other objects and functions,
    undoing all changes during test teardown. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In this code, `user_login` uses the `getpass.getpass()` function ([https://docs.python.org/3/library/getpass.html](https://docs.python.org/3/library/getpass.html))
    from the standard library to prompt for the user's password in the most secure
    manner available in the system. It is hard to simulate the actual entering of
    the password during testing because `getpass` tries to read directly from the
    terminal (as opposed to from `sys.stdin`) when possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `monkeypatch` fixture to bypass the call to `getpass` in the
    tests, transparently and without changing the application code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the tests, we use `monkeypatch.setattr` to replace the real `getpass()` function
    of the `getpass` module with a dummy `lambda`, which returns a hard-coded password.
    In `test_login_success`, we return a known, good password to ensure the user can
    authenticate successfully, while in `test_login_wrong_password`, we use a bad
    password to ensure the authentication error is handled correctly. As mentioned
    before, the original `getpass()` function is restored automatically at the end
    of the test, ensuring we don't leak that change to other tests in the system.
  prefs: []
  type: TYPE_NORMAL
- en: How and where to patch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `monkeypatch` fixture works by replacing an attribute of an object by another
    object (often called a *mock*), restoring the original object at the end of the
    test. A common problem when using this fixture is patching the wrong object, which
    causes the original function/object to be called instead of the mock one.
  prefs: []
  type: TYPE_NORMAL
- en: To understand the problem, we need to understand how `import` and `import from` work
    in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a module called `services.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we are importing the `subprocess` module and bringing the `subprocess`
    module object into the `services.py` namespace. That''s why we call `subprocess.run`:
    we are accessing the `run` function of the `subprocess` object in the `services.py` namespace.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider the previous code written slightly differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are importing the `subprocess` module but bringing the `run` function
    object into the `service.py` namespace. That's why `run` can be called directly
    in `start_service`, and the `subprocess` name is not even available (if you try
    to call `subprocess.run`, you will get a `NameError` exception).
  prefs: []
  type: TYPE_NORMAL
- en: We need to be aware of this difference, to properly `monkeypatch` the usage
    of `subprocess.run` in `services.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first case, we need to replace the `run` function of the `subprocess` module,
    because that''s how `start_service` uses it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this code, both `services.py` and `test_services.py` have the reference to
    the same `subprocess` module object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second case, however, `services.py` has a reference to the original `run` function
    in its own namespace. For this reason, the correct approach for the second case
    is to replace the `run` function in `services.py` ''s namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: How the code being tested imports code that needs to be monkeypatched is the
    reason why people are tripped by this so often, so make sure you take a look at
    the code first.
  prefs: []
  type: TYPE_NORMAL
- en: capsys/capfd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `capsys` fixture captures all text written to `sys.stdout` and `sys.stderr` and
    makes it available during testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have a small command-line script and want to check the usage instructions
    are correct when the script is invoked without arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'During testing, we can access the captured output, using the `capsys` fixture.
    This fixture has a `capsys.readouterr()` method that returns a `namedtuple` ([https://docs.python.org/3/library/collections.html#collections.namedtuple](https://docs.python.org/3/library/collections.html#collections.namedtuple)) with `out` and `err` attributes,
    containing the captured text from `sys.stdout` and `sys.stderr` respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: There's also the `capfd` fixture that works similarly to `capsys`, except that
    it also captures the output of file descriptors `1` and `2`. This makes it possible
    to capture the standard output and standard errors, even for extension modules.
  prefs: []
  type: TYPE_NORMAL
- en: Binary mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`capsysbinary` and `capfdbinary` are fixtures identical to `capsys` and `capfd`, except
    that they capture output in binary mode, and their `readouterr()` methods return
    raw bytes instead of text. It might be useful in specialized situations, for example,
    when running an external process that produces binary output, such as `tar`.'
  prefs: []
  type: TYPE_NORMAL
- en: request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `request` fixture is an internal pytest fixture that provides useful information
    about the requesting test. It can be declared in test functions and fixtures,
    and provides attributes such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`function`: the Python `test` function object, available for `function`-scoped
    fixtures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cls`/`instance`: the Python class/instance of a `test` method object, available
    for function- and `class`-scoped fixtures. It can be `None` if the fixture is
    being requested from a `test` function, as opposed to a test method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`module`: the Python module object of the requesting test method, available
    for `module`-, `function`-, and `class`-scoped fixtures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`session`: pytest''s internal `Session` object, which is a singleton for the
    test session and represents the root of the collection tree. It is available to
    fixtures of all scopes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`node`: the pytest collection node, which wraps one of the Python objects discussed
    that matches the fixture scope.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addfinalizer(func)`: adds a `new finalizer` function that will be called at
    the end of the test. The finalizer function is called without arguments. `addfinalizer` was
    the original way to execute teardown in fixtures, but has since then been superseded
    by the `yield` statement, remaining in use mostly for backward compatibility.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fixtures can use those attributes to customize their own behavior based on
    the test being executed. For example, we can create a fixture that provides a
    temporary directory using the current test name as the prefix of the temporary
    directory, somewhat similar to the built-in `tmpdir` fixture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This code created the following directory when executed on my system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `request` fixture can be used whenever you want to customize a fixture based
    on the attributes of the test being executed, or to access the marks applied to
    the test function, as we have seen in the previous sections.
  prefs: []
  type: TYPE_NORMAL
- en: Tips/discussion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following are some short topics and tips that did not fit into the previous
    sections, but that I think are worth mentioning.
  prefs: []
  type: TYPE_NORMAL
- en: When to use fixtures, as opposed to simple functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, all you need is to construct a simple object for your tests, and
    arguably this can be done in a plain function, not necessarily needing to be implemented
    as a fixture. Suppose we have a `WindowManager` class, that does not receive any
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'One way to use it in our tests would be to write a fixture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you could argue that a fixture for such simple usage is overkill,
    and use a plain function instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you could even create the manager explicitly on each test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This is perfectly fine, especially if this is used in a few tests in a single
    module.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind, however, that fixtures **abstract away details about the construction
    and teardown process of objects**. This is crucial to remember when deciding to
    forego fixtures in favor of normal functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that our `WindowManager` now needs to be closed explicitly, or that
    it needs a local directory for logging purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have been using a fixture such as the one given in the first example,
    we just update the fixture function and **no tests need to change at all**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'But if we opted to use a plain function, now we **have to update all places
    that call our function**: we need to pass a logging directory and guarantee that
    `.close()` is called at the end of the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Depending on how many times this function has been used in our tests, this can
    be quite a refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: 'The message is: it is fine to use plain functions when the underlying object
    is simple and unlikely to change, but keep in mind that fixtures abstract the
    details of the creation/destruction of objects, and they might need to change
    in the future. On the other hand, using fixtures creates another level of indirection,
    which slightly increases code complexity. In the end, it is a balance that should
    be weighted by you.'
  prefs: []
  type: TYPE_NORMAL
- en: Renaming fixtures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `@pytest.fixture` decorator accepts a `name` parameter that can be used
    to specify a name for the fixture, different from the fixture function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This is useful, because there are some annoyances that might affect users when
    using fixtures declared in the same module as the test functions that use them:'
  prefs: []
  type: TYPE_NORMAL
- en: If users forget to declare the fixture in the parameter list of a test function,
    they will get a `NameError` instead of the fixture function object (because they
    are in the same module).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some linters complain that the test function parameter is shadowing the fixture
    function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might adopt this as a good practice in your team if the previous annoyances
    are frequent. Keep in mind that these problems only happen with fixtures defined
    in test modules, not in `conftest.py` files.
  prefs: []
  type: TYPE_NORMAL
- en: Prefer local imports in conftest files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`conftest.py` files are imported during collection, so they directly affect
    your experience when running tests from the command line. For this reason, I suggest
    using local imports in `conftest.py` files as often as possible, to keep import
    times low.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, don''t use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Prefer local imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This practice has a noticeable impact on test startup in large test suites.
  prefs: []
  type: TYPE_NORMAL
- en: Fixtures as test-supporting code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should think of fixtures not only as a means of providing resources, but
    also of providing supporting code for your tests. By supporting code, I mean classes
    that provide high-level functionality for testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a bot framework might provide a fixture that can be used to test
    your bot as a black box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `bot` fixture allows the developer to talk to the bot, verify responses,
    and check the contents of the internal store that is handled by the framework,
    among other things. It provides a high-level interface that makes tests easier
    to write and understand, even for those who do not understand the internals of
    the framework.
  prefs: []
  type: TYPE_NORMAL
- en: This technique is useful for applications, because it will make it easy and
    enjoyable for developers to add new tests. It is also useful for libraries, because
    they will provide high-level testing support for users of your library.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we delved into one of pytest''s most famous features: fixtures.
    We have seen how they can be used to provide resources and test functionality,
    and how to concisely express setup/teardown code. We learned how to share fixtures,
    using `conftest.py` files; to use fixture scopes, to avoid creating expensive
    resources for every test; and to autouse fixtures that are executed for all tests
    in the same module or hierarchy. Then, we learned how to parametrize fixtures and
    use marks from them. We took an overview of various built-in fixtures, and closed
    the chapter with some short discussions about fixtures in general. I hope you
    enjoyed the ride!'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore a little of the vast pytest plugin ecosystem
    that is at your disposal.
  prefs: []
  type: TYPE_NORMAL
