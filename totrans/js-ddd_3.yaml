- en: Chapter 3. Setting Up a Project for Domain-driven Design
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far we have been focused on getting the prerequisites for the project ready.
    We focused on creating a mental model for ourselves and confirmed that our understanding
    of the domain matched the understanding of our domain expert. By doing this, we
    started to create a shared language between all the people involved so that all
    parties can communicate about the project while avoiding most misunderstandings.
    With all this in place, we were able to identify a starting point for the project,
    and now that we know where to start and how to name our objects according to the
    domain, we can set up the project to fit this. Robert C. Martin says in his talk
    *Architecture the lost years*: *Architecture is about intent* that architecture
    is not created for the sake of itself but actually to state what the project is
    about and make it clear for the next person what each level covers. As we set
    up our application, we want to express what the application is about at every
    level, and this includes the level of organization of files and folders as much
    as it is about creating classes and modules.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Our main goal, which coincides with the goal of software architecture, in general
    has been to not make decisions prematurely as well as to ensure the decisions
    we make are as self-explanatory as possible. We have not decided on any frameworks
    or actually any technology yet, but as we now push our application forward, it
    is time to resolve some of those deferred decisions, even though we want to keep
    as much as possible open to change.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is going to be about the challenges that arise when it comes to
    creating a flexible project setup that allows your project to adapt and actually
    embrace a change of structure. This is important to keep in mind throughout the
    whole design as we put it together. We don't want a module structure hindering
    our refactoring, or making our project more rigid because of an overwhelming class
    and file hierarchy.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'As we go about this, we are going to deal with structure on multiple levels:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: File and directory structure
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project structure
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object or class structure
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application structure as interaction with the outside of the domain
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object and class structure, as well as project structure, are closely related
    to how we decide to design our application. As part of this, testing is introduced
    as it has the most immediate impact on how we are going to design both our classes
    and objects. It also has an impact on the way our team works together on the project
    and how they are able to show the results to business experts by letting them
    explore the project as it currently stands.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As JavaScript leaves the realm of enhancing websites and moves towards being
    a language used for large applications, be it in the browser or on the server,
    the need for more involved architectures has grown and people have tried to carry
    over many of the concepts currently in use for Java or C++ backend applications.
    Often this actually causes more problems than it solves, as JavaScript is a very
    flexible language and has its own concepts of how organization can, and should,
    be done even though parts might still be missing; modules being one of those as
    a core concept. When building a JavaScript application, always keep in mind what
    language you are using and use its features and concepts to work with your project;
    don't fight it every step of the way.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the setup of the project and how to make it a joy to work
    on. You will learn about the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: The project file structure and what to consider when laying it out
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different forms of testing and why they are important
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the application
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to hexagonal architecture
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structuring a project as we see it
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a new developer dives into a project, the first thing they are always going
    to see is the layout of files and folders in the project. This is also the element
    of organization we deal with constantly while editing the project, so it is worth
    investing thought into the organization. Just looking at the files and folders
    should already tell you something about the project; it is the highest level of
    organization and therefore should represent some of the top level concepts of
    our domain.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'So to start out, we need to make sure we know what we are trying to solve with
    this structure. There are multiple points that we need to address at this level,
    and they will follow us through every part of the organization of the project;
    they are:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Approachability
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locality of edits
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fitness for handling change
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So let's see what these points are about and how we can optimize for each of
    those points.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Approachability
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a new developer joins a project, or even as one comes back to a project that
    they have not been recently working on, there is a learning curve in knowing where
    things are located, and maybe even more importantly in where things should be
    located moving forward. This is always a problem as it slows down development,
    or when talking about an open source project it might actually slow down adoption
    and contributions. So we obviously want to make codebase as approachable as possible,
    but what does this mean? There is a subjective learning curve in relation to unfamiliar
    tools and styles, which is hard to estimate ahead of time for each developer,
    but there is also a more objective one in relation to common practices, naming,
    and well established concepts. So how can we make a codebase approachable just
    from the file and folder level?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: When we start out, we will need to take a look at what is in there, so the ease
    of navigation is one of the first things we have to deal with. Having extensive
    levels of subfolders, with only view files, or sometimes even no files, is an
    example of making a project hard to navigate. Some might say that the editor you
    are working with should solve this, but it is also a problem we create for ourselves,
    so we should refrain from it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: There are more ways to make a project approachable so, for example, the filenames
    should reflect the contents, as should the directory names, and probably most
    importantly, the project should follow conventions that have been established
    in the community. This means that unless you have a very good reason, you should
    refrain from creating your own conventions. Especially little things such as naming
    files according to a community standard can help a lot. One example is tagging
    on names like model or controller to the end of files. In some programming communities
    this is really common, while in the Node.js community it is frowned upon. Following
    these little things can make it easier for developers as not following them might
    almost drive rage towards a project.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that files will most likely only ever be touched by developers,
    so they can be optimized to support developers in their task, and so a common
    developer practice is of higher weight than approachability for a domain expert.
    Of course, the extent of this varies between projects and tasks. It holds largely
    true for the organizational nature and for common idioms from frameworks, but
    does not extend to the naming of the inherent part of the language that is developed
    throughout the project. We want the project's structure to be approachable for
    developers already familiar with similar codebases, but we don't want to introduce
    a translation layer between the developers and the domain experts.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a closer look at this in an example of how we could lay out the
    basics for our dungeon-manager. To start out, this will, of course, only contain
    the transferring `prisoners feature`, but nonetheless it will hint towards the
    overall structure:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![Approachability](graphics/B03704_03_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: The important thing to note about this structure is that it uses the basics
    of node modules all the way while already hinting at a possible structure to include
    multiple features outside the prisoner transfer. The `index.js` files are conventional
    named to indicate the entry point to a certain module. A developer jumping into
    the project will know to look in those files first when trying to find out more
    about the module. We can leverage this fact later to include common documentation
    about the feature, as well as having this file load all the others necessary to
    accomplish the module task.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这种结构的重要事项是，它一直使用节点模块的基础，同时已经暗示了可能包括多个功能在囚犯转移之外的结构。`index.js`文件通常命名为指示特定模块的入口点。跳入项目的开发人员将知道在尝试了解有关模块的更多信息时首先查看这些文件。我们以后可以利用这一事实来包括有关功能的常见文档，以及使该文件加载完成模块任务所需的所有其他文件。
- en: Creating the tests in a test folder is also the established way to locate your
    tests. As the test have certain categories inherent in their design, it makes
    sense to structure the test directory accordingly. The structure of the test folder
    should allow us to, at a glance, figure out what tests there are and how they
    apply to our project as a whole. As the project grows, having a set of tests covering
    the features is not only incredibly valuable from a regression perspective, but
    also gives a quick insight into how a certain feature can be used, so locating
    your tests quickly can mean a certain module gets reused or adapted instead of
    wasting efforts on duplicating what was there already.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试文件夹中创建测试也是定位测试的已建立方式。由于测试在设计上具有某些固有的类别，因此按照测试目录的结构进行组织是有意义的。测试文件夹的结构应该让我们一眼就能看出有哪些测试，以及它们如何适用于我们的整个项目。随着项目的增长，拥有一组覆盖功能的测试不仅在回归方面非常有价值，而且还可以快速了解某个功能的使用方式，因此快速定位测试可以意味着某个模块被重复使用或调整，而不是浪费精力重复已有的工作。
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The structure presented here is not set in stone, some people prefer app to
    lib, spec to test, or other small changes like this. The goal of a structure should
    always be that developers feel at home in it. Tradeoffs in this area can be made
    with specific developers in mind.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提出的结构并非一成不变，有些人更喜欢将app改为lib，将spec改为test，或者进行其他类似的小改动。结构的目标应始终是让开发人员感到宾至如归。在这个领域可以根据特定的开发人员做出权衡。
- en: Lastly, adding a `package.json` file is the common way to handle project dependency
    and to define aspects about the structure and other parts, so we add this as well,
    ready to put to good use later.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加`package.json`文件是处理项目依赖关系并定义结构和其他部分的常见方式，因此我们也添加了这个文件，准备以后充分利用。
- en: Locality of edits
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编辑的局部性
- en: As developers are working on the project, they are most likely working on either
    a feature, or are fixing bugs and refactoring code. As these activities are, at
    least in the case we are aiming for, related to one feature, we want to make sure
    that the developer does not have to jump into many different places to edit. The
    files related to the problem should therefore be in one spot, reducing the overhead
    of opening everything related to a given task or feature, as well as the mental
    overhead of keeping the related parts in one's head to make sure the edits happen
    in the right place.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发人员在项目上工作时，他们很可能正在处理一个功能，或者正在修复错误和重构代码。由于这些活动至少在我们所追求的情况下与一个功能相关，我们希望确保开发人员不必跳转到许多不同的地方进行编辑。因此，与问题相关的文件应该在一个地方，减少打开与给定任务或功能相关的所有内容的开销，以及保持相关部分在头脑中以确保编辑发生在正确的地方的心理开销。
- en: This is one of the reasons we created features such as packages or modules in
    the `lib` folder before. As the developer works on the prisoner transfer, they
    can, just by looking at the directory structure, know what to edit. They can quickly
    open the files in their editor and view them as a unit of work as they are changing
    the code to accomplish a given task.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们之前在`lib`文件夹中创建包或模块的原因之一。当开发人员在处理囚犯转移时，他们可以仅通过查看目录结构就知道要编辑什么。他们可以快速在编辑器中打开文件，并将其视为一个工作单元，因为他们正在更改代码以完成给定的任务。
- en: Using a structure like this not only makes it easier to look at for the developer
    when editing, but also the version control system will be easier to work with.
    As the code is organized like this, we can look at it on a feature-by-feature
    basis and we are also less likely to touch the same files when working on different
    features. This not only reduces the likelihood of conflict, but also makes the
    history of a given module more useful.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这样的结构不仅使开发人员在编辑时更容易查看，而且版本控制系统也更容易使用。由于代码是这样组织的，我们可以逐个功能地查看它，而且在处理不同功能时也不太可能触及相同的文件。这不仅减少了冲突的可能性，还使给定模块的历史更有用。
- en: If you look at the preceding structure we have been using so far, you might
    have noticed that the locality of edits breaks down for tests. As we work on the
    prisoner transfer feature in `lib`, we have to edit the feature test in tests
    as well, which is about as far apart as you can get filesystem-wise. As with everything
    in software development, this is a tradeoff and we have chosen approachability
    over locality in this case. The reason being that a higher value is placed on
    the onboarding of people, and the assumed cost of non-locality seems low enough
    to support that. If we think otherwise, we might locate the tests for each feature
    inside the feature, and therefore more easily enable moving the whole feature
    to a different project in the future. This decision is not all or nothing of course,
    and we might create a structure resembling the main structure under the test directory
    to keep a locality for the tests as part of the tests directory for example.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Fitness
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '|   | *Fitness, according to Darwin, means the capacity to survive and reproduce.*
    |   |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
- en: '|   | --*Darwinian fitness - Lloyd Demetriusa, Martin Ziehec* |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
- en: As our software grows and evolves, it will need to adapt to varying scenarios
    of its usage, and the best software is the kind that grows beyond its intended
    use case. A common example is Unix and the associated philosophy. The idea is
    to create many small pieces that, when recombined, allow for a vast variety of
    uses. Unix has survived in various forms for decades now and there does not seem
    to be an end in sight, but being created in a certain way is only half the story.
    As changes came along and new use cases took form, it did not ossify, but its
    idea and concepts were malleable, but what does that mean for our software. How
    can we achieve similar versatility?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: We have seen already that even on the filesystem level, the software is composed
    of modules. There is an obvious distinction between the different elements as
    features are implemented. From a fitness perspective, this means that we are quickly
    able to locate a certain feature, as well as enhance, remove, or reuse it. A feature
    should also hint at its dependencies, which could be made clear through subfolders,
    or just by looking at the imported dependencies located in the index file located
    right at the root of a feature directory.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: To give an example, moving forward as the dungeon manager grows, the prisoner
    transfer might start to incorporate more messaging since other dungeons have adopted
    our system, and we can now fully automate transfers between them. At this point,
    the whole kingdom relies on the availability of the transfer service and this
    means that very rigorous testing needs to be present to ensure its reliability
    because downtime means that the kingdom cannot raid at maximum effectiveness.
    We are very happy with the success of this system, but it slows down development
    of the dungeon manager in general, as the prisoner transfer is a part of it and
    we need to comply with its harsh integration rules. But we are in a good position
    after all; if we look at the layout of our application, we can see that we can
    quite easily extract the prisoner transfer into an application by itself and have
    it maintained separately.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: After the extraction, we can start moving forward quickly again, and integrate
    the transfer as just another service the dungeon manager speaks with. Splitting
    out common functionality, as well as functionality that has to comply with different
    constraints, is key to having malleable and extendable software that can keep
    moving forward.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: In reality, this would obviously be the best case, but just structuring an application
    as a set of independent small parts all tested separately on the feature level
    makes us consider APIs in a way that will be very useful down the road as the
    software grows and, of course, the same goes the other way around. We are able
    to rip out unneeded features quickly and thus reduce the maintenance overhead
    and increase our velocity. This is in essence the concept of cooperation of all
    the small Unix programs mentioned at the beginning of this section.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: This is not the *be all and end all* of software design of course, as anybody
    who started out using Unix mainly from the shell will know that the initial learning
    curve is rather steep and getting anything done does not feel very fast or expressive
    at the beginning. As we have seen before, reaching all the way for one goal means
    sacrificing another, in this example—the approachability of the project. After
    all, there is no perfect solution, but at least at the beginning of a project
    it is often helpful to enhance approachability and think about other problems
    as they arise. For us, this means that keeping a high level structure of modules
    in mind is probably a good thing, but going overboard and making every piece ready
    for extraction, or even its own application, will probably not help the project
    along.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't overcomplicate things to get the perfect architecture, as it does not
    exist. It is more important to get the software into the hands of the users quickly
    to get feedback on whether it is even useful. A slowdown determining the perfect
    architecture will most likely be more costly down the road due to the delay in
    feedback, than a suboptimal architecture could be.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with shared functionality
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have structured our application right now, we are ready to split apart
    features that might become an independent piece of functionality, but what about
    the other way around? Domains often have a certain set of key concepts that to
    shows up time and time again. This is great as it allows us to not having to write
    it over and over if we can share it across the pieces that need. It also shows
    that we understand the domain well enough to extract core concepts and share them,
    so it is actually something to strive for.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: This is great on a level where our features match the shared functionality closely;
    we provide a public interface and each dependent interface can develop against
    that. But what happens if we actually extract a piece of functionality, and our
    prisoner transfer service is for example no longer local to the application but
    actually a service that is reachable via HTTP for example? In this case, we have
    to deal with shared functionality, which is not just another thing we can create
    an API for, but we actually have to implement the same code in every dependent
    to actually call over the API to do the work we were doing locally before. Think
    of the payment gateway abstraction every other shopping system creates—this kind
    of functionality could be developed once and used in multiple places, allowing
    shared testing and shared resources for development.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: This is, of course, not the only place where shared functionality actually means
    there is code being shared, where it seems like we have to duplicate certain snippets
    all over the place. Other examples might be database access, or configuration
    management. What all of this has in common is that it is actually lower level
    code that does not really have a close relationship with the application domain.
    We are dealing with an artifact of the way we like to communicate, and the patterns
    we applied don't support this communication well. We can think about it also in
    the way that the cohesion at a domain level is low, because we are leaking abstractions
    in a way that would for example make us care about the database accessing code
    when we want to deal with a prisoner.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One thing to keep in mind when introducing shared code is that sharing is coupling
    and coupling is not a good thing. There should always be a very good reason for
    sharing code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Multiple solutions are possible at this point, and depending on the project
    as well as the piece of code, different ones might be applicable, so let me introduce
    you to the most common ones.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: A shared toolbox
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When the first shared functionality appears that does not really belong anywhere,
    most projects start to create a *utility* library, a toolbox of things that are
    used in places all over the project. Even though many architecture purists frown
    upon it, it might be the best way to start out. It is better to have a shared
    toolbox separated out than dealing with code duplication later on after all. Many
    popular libraries start this way; think about underscore providing its implementation
    of the *each* construct on top of JavaScript, and dealing with all the different
    versions underneath that a browser implementation might have to care about to
    run all over the world. The following is an example from the `underscore.js` file,
    reformatted for easier reading:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: While a library such as underscore is a perfect example of the usefulness of
    this approach, there are problems as well. Especially when poorly named, this
    folder or file quickly becomes the dumping ground for all kind of things. It is
    quicker to not think about where something really belongs, and instead just dump
    more into the utilities folder. At least it is in one place now where it can be
    moved and refactored from, so stay positive; it could be worse. In the long run,
    the goal should be to move to an approach where we use object orientation and
    let our tests guide a domain-design from the start. When we look at an application
    and we see a library function like the above being part of the application code
    we know that there is an abstraction missing. Again, it is all tradeoffs all the
    time and the problem with abstractions is that you have to consider them at the
    time of writing.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Utilities or libraries are a dangerous place, so be sure to keep them on your
    regular review and refactor radar. Always leave the code a little bit tidier than
    you found it and monitor its churn closely.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Moving up the dependencies
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the project moves along and grows, the best way to deal with dependencies
    will probably be to leverage what is there already. Your libraries have grown,
    and many internal projects rely on them, so why not make use of the dependency
    management that is built into the environment already?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript used to be notoriously bad at dealing with dependencies, but the
    time of downloading a version of jQuery and putting it in the project is luckily
    over. JavaScript provides an amazing amount of dependency managers for every use
    case. In the browser, we can leverage **bower** ([http://bower.io/](http://bower.io/)),
    **browserify** ([http://browserify.org/](http://browserify.org/)) and **npm**
    ([https://www.npmjs.com/](https://www.npmjs.com/)) and possibly many more, and
    in Node.js, npm is the standard way to deal with any kind of packages we might
    want.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the kind of library that has been developed as part of the process,
    it might be either a good point to rely on versioning it outside of your project,
    or even maybe set up a private version of the package registry. This will be overkill
    in the beginning, but is something to keep in mind as the need arises. Also, don't
    forget that it might be your time to contribute back to the community and release
    it as open source.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *Beware of bugs in the above code; I have only proved it correct, not
    tried it.* |   |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
- en: '|   | --*Donald Ervin Knuth* |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
- en: Every system that is supposed to go into production needs to be evaluated against
    the real world situation. Reality can be a harsh thing, and it happens more often
    than not that something we expected to work perfectly fine does not work when
    we actually want to use it. So throughout the history of computer programming,
    developers have thought about how they could make sure that the software works,
    and at best, actually work as expected.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 每个即将投入生产的系统都需要根据实际情况进行评估。现实可能是一件严酷的事情，经常发生的情况是，我们期望完美运行的东西在实际使用时却不起作用。因此，在计算机编程的历史上，开发人员一直在思考如何确保软件能够正常工作，并且最好能够按预期工作。
- en: 'In 1994, Kent Beck wrote the **SUnit** test framework for Smalltalk and kicked
    off the modern age of unit testing. The idea was quite simple: automate the evaluation
    of code and make sure it fulfilled a certain set of specifications. Even though
    there are many new frameworks today to achieve this, the basic idea is still the
    same: write code and check whether it produces the expected result. In reality,
    with or without a testing framework or fixed process, developers are always doing
    this—nobody is just pushing code into production without actually having tried
    it before, at least. We can either do this by hand, or automate it.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 1994年，Kent Beck 为 Smalltalk 编写了 **SUnit** 测试框架，开启了现代单元测试的时代。这个想法非常简单：自动化代码评估，并确保它满足一定的规范。即使今天有许多新的框架来实现这一点，基本思想仍然是一样的：编写代码并检查它是否产生了预期的结果。实际上，无论有没有测试框架或固定流程，开发人员总是在做这个事情——没有人会在没有尝试过的情况下将代码推送到生产环境中。我们可以手动执行，也可以自动化执行。
- en: There are multiple points that need to be addressed to make testing useful because
    there are different goals for the tests we write. We need to facilitate easy unit
    testing, expressive feature testing, and performance testing. This of course does
    not mean that all scenarios need to be handled by one framework, but the less
    friction there is, the better the adoption of the core principles will be. It
    is also vital to make sure the tests are executed, and the best way to achieve
    this is through automation, making sure no code can wind up in the end product
    without satisfying its requirements and without breaking others.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有多个要点需要解决，以使测试变得有用，因为我们编写的测试有不同的目标。我们需要促进简单的单元测试、表达性的功能测试和性能测试。当然，这并不意味着所有场景都需要由一个框架处理，但摩擦越小，核心原则的采纳就会越好。确保测试被执行是至关重要的，而实现这一点的最佳方式是通过自动化，确保没有代码可以在最终产品中出现，而不满足其要求并且不破坏其他代码。
- en: Setting up a test environment
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建立测试环境
- en: As we now know, there are a lot of different goals a test environment must satisfy,
    but there also are an incredible number of test frameworks out there and JavaScript
    itself brings some challenges when it comes to testing. One framework that has
    worked for a lot of projects in the past is the Mocha-testing framework. It has
    also gained quite a wide adoption among web developers, so the following sections
    will explain Mocha. There is no secret to it, and Mocha is swappable for the framework
    of your choice that fits the style of your development team best. The only thing
    to make sure is that you actually use what you have, and be aware of what you
    want to get out of your tests. So first, we need to make sure we know what the
    goals are for our different tests before we can chose a technology to achieve
    them.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们现在所知，测试环境必须满足许多不同的目标，但也有大量的测试框架以及 JavaScript 本身在测试方面带来了一些挑战。过去许多项目中使用的一个框架是
    Mocha 测试框架。它在 Web 开发人员中也得到了广泛的采用，因此接下来的部分将解释 Mocha。没有秘密可言，Mocha 可以与您团队最擅长的框架相互替换。唯一需要确保的是您实际使用了您拥有的工具，并且了解您想从测试中获得什么。因此，首先，我们需要确保在选择技术实现目标之前，了解我们不同测试的目标是什么。
- en: Different types of tests and goals
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不同类型的测试和目标
- en: When we start testing code, there are multiple reasons why we should do it.
    For a project that is driven by its domain implementation, one major aspect is
    always testing the features as they are implemented, as we want to provide quick
    feedback to the client and show in an explanatory way that our implementation
    works. But as developers, we also need to dig a little deeper and work on the
    unit level, exploring the specifics of our code as we write it, or as we design
    the algorithm. Finally, a project should not only care about its functionality
    in actually doing what it is supposed to do, but also be usable from a user perspective,
    giving responsive answers and performing well enough overall to not be in the
    way. All of these aspects can be achieved by testing.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始测试代码时，有多个原因需要这样做。对于一个由其领域实现驱动的项目来说，一个主要方面始终是测试实现的功能，因为我们希望向客户提供快速反馈，并以一种解释性的方式展示我们的实现是有效的。但作为开发人员，我们还需要深入挖掘并在单元级别上工作，探索我们编写代码时的具体情况，或者在设计算法时。最后，一个项目不仅应关心其功能是否实际执行了它应该执行的任务，还应该从用户的角度来看，提供响应迅速的答复，并在整体上表现得足够好，以免成为障碍。所有这些方面都可以通过测试来实现。
- en: Feature specs
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 功能规范
- en: 'Making tests not only useful for the developer, but for the client too, has
    been the ultimate goal of test driving and implementation for many years. There
    are tools such as **Ruby''s** **Cucumber** that have a JavaScript implementation
    that makes sure the specification gets somewhat decoupled from the code, making
    it as accessible as possible for the domain expert to read and understand. The
    end result is a specification that mostly looks like plain English but has some
    restrictions applied to it. The code below is using the cucumber syntax to describe
    the prisoner transfer as a feature specification, including one acceptance scenario:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This kind of specification can now easily be turned into a running specification,
    using the `Given`, `When`, and `Then` blocks as the instructions for our tests.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Decoupling the specification from the real tests like this somewhat removes
    the programmer from it. So, depending on the technical expertise of the product
    owner, the idea is that even they could write the specification, with some developer
    support of course. In most projects, this is not the case, and the developers
    end up creating the specification code for Cucumber, as well as its implementation
    as test code. In this case, it is useful to stick with more basic tools, as it
    is a better fit for developers to write tests in a way they are accustomed to
    already. This does not mean Cucumber's idea isn't something to keep in mind. Tests
    should read at a really high level, and should be understandable to reflect what
    the product owner originally intended when describing it to developers, so we
    can detect mismatches together as a team. But, as code is most likely to be read
    with a developer at hand, the overhead of having almost two implementations of
    the tests is unnecessary.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'There is nothing wrong with being inspired by Cucumber and using Mocha to write
    our tests. The tests can look like this for example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Even though this style is now actual runnable code, using helper methods to
    abstract details and make the naming clear keeps it readable. The goal here is
    not to make it easy for a non-technical person to read this, but to enable a developer
    to sit down with a business expert and talk about the implied rules.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Test are an integral part of the code, so they need to have the same rigorous
    coding standards employed, and since there are no tests for the tests, readability
    is key.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After the discussion with the business expert to agree on the feature set, and
    creating a specification of its current state in the feature specs, there is a
    level where we as developers need to try out our code. This is where unit tests
    shine! The idea is to test our code as we develop it and allow it to be immediately
    executed in isolation, where we can reason about it. Unit tests are generally
    quickly changing as the development on a certain part progresses and serves as
    regression protection afterwards.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't fear throwing away unit tests; they are there to aid development not to
    hinder it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: As we already are using Mocha for our features, it is natural to use it to test
    our smaller units as well, but the tests are going to look different. At the level
    of the unit tests, we want to isolate ourselves as far as possible and if we can't
    do that, then we are really going to encounter some pain sooner or later in other
    development areas as well. This pain is really about high coupling; when we are
    coupling a module too close to other pieces of the system the test will show us.
    In this kind of setup, creating a unit test that is isolated is going to require
    an incredible amount of setup to really make sure we only hit the module by itself,
    and don't touch the dependencies.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: The end result of unit tests of a module should always test the public interface
    and this interface alone, because at this point they serve as regression protection.
    The more external pieces are tested with the unit tests, the more of its private
    interface is exposed, the more likely a breakage is going to occur, but even though
    this is our end goal, don't make the mistake of thinking this should be all the
    unit tests ever do. Often when writing a module of a bigger application, it can
    be immensely useful to explore its logic more deeply, especially when the public
    interface might still be in flux. So write all the tests that reach inside the
    harder parts of the module while developing it, but make sure you remove those
    "little helpers" before declaring a module ready for consumption.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Performance tests
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any time an application is moving forward and features are implemented, there
    is a point at which we need to think about the performance of this application.
    Even before we get into performance needs, it is important to know which parts
    of the system are most likely to cause trouble in the future.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: The important thing about performance tests are that they will ascertain the
    focus on metrics in the code at an early stage. Just thinking about how to measure
    the performance across parts of the system will ensure that we think about instrumentation,
    and this can be a vital feature when we actually move closer to heavy usage later
    on or actually when exploring breakages in production.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Testing the performance of an application is, of course, not a one-off thing.
    By itself, a measurement of performance is rather meaningless; it only becomes
    useful if it's monitored as it changes over time. One strategy to accomplish this
    is exercising the outside API on each push to the master branch and recording
    the changes. This will give you an idea of where the project stands in respect
    to monitoring as well as performance over the time the project is developed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Even though it might not be obvious outright, monitoring changes in performance
    is a major point towards implementing a domain. As developers employing domain-driven
    design practices, we must consider the usability of our app. Often, different
    stakeholders have different needs in performance, and having an application that
    does not satisfy its needs might render it useless to some. So many times apps
    stop being used due to bad performance characteristics even if they supply the
    whole feature set otherwise. Overall, just knowing the deficiencies is half the
    battle. When we at least have an understanding of where time is spent, it is a
    point where we can hook in as the need arises and optimize as needed. This need
    is very likely to arise sooner or later so the preparation for it is time very
    well spent.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: With these different goals in mind, we now have to tackle the problem of actually
    running all those different tests as often as possible without having to rely
    on just strict compliance throughout, especially when creating a view over time.
    As a project changes, relying on people running everything needed every time is
    not just a major burden on the team, but unnecessary as well.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the end, all the tests one could ever want are only useful if they are run,
    and this is where continuous integration comes into play. Of course, all of us
    are great developers who always test their code, but even we might not always
    test the whole chain of integration in our app. Our performance tests are only
    useful if they are run on a comparable platform.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration has been around for some time now, and its most prominent
    system is probably Jenkins, but others are around as well. The idea is to run
    the tests and other steps we need to move from development to production on a
    system automatically, and make sure we have a stable build at all times. We can
    even use this system to automate deployment, and of course provide a dashboard
    for developers to check how the app is doing right now.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: A system like this can be a vital part of a project, as it allows you to quickly
    move from development to system, where the business experts can check the impact
    of the work as well. There are many tutorials out there on how to set up a project's
    continuous integration, and in recent times highly refined systems such as **Travis-CI**
    make it very easy to set up, so I won't go into more details here; just keep in
    mind that such a system is worth its cost many times over throughout a project
    that grows to a certain size and complexity, and there is no real reason not to
    use one.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A continuous integration system is really about keeping the best practices enforced
    throughout the development, even when a developer has a bad day. It also provides
    a more approachable way to have an outsider discover and evaluate the state of
    the application as a whole.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Managing the build
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing software for an orc dungeon has a major advantage since the orcs don't
    know much about software so we can introduce any tools we like and they won't
    have an opinion on it. Why have I mentioned this when the title of this section
    is supposed to talk about building the software, you might wonder? There are a
    myriad of build tools out there and they all do things slightly differently, and
    everybody seems to prefer one to the other. Especially in JavaScript, the community
    has not yet standardized a tool so there is **Grunt**, **Jake**, and **Broccoli**,
    just to name a few, and of course your project might leverage one from a different
    language such as Ruby's Rake or the old familiar make.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Even though there are so many build tools, the only important thing about them
    is to actually use one. Yes they all have differences, but they can all do pretty
    much the same, adjusting for syntax and performance. But why is a build tool so
    important? And why should we use one?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Why every application needs a build system
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating software at the scale of actually creating a functional, complete system
    to manage a business process is always a difficult task. Such a system involves
    many parts, like in our example of managing prisoner transfers, notifying other
    dungeons, tracking statistics about the dungeon, and so on. When we set it up,
    we need to load multiple files, maybe compile some parts, manage the dependencies,
    and, in the case of frontend JavaScript code, we also want to compress and minimize
    it to optimize for faster page load. Doing all this manually involves multiple
    steps and will most likely fail sooner or later because we forgot one of those
    steps, and this is where the build system comes in. In a way, all software has
    a build system, it just depends on how automated the system is.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A build system optimizes for *boringness*; the more boring a build is, the better.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal is to not be able to make mistakes and create a reproducible environment
    every time. We want to run one command and get the expected result, so in our
    case the build system has a couple of responsibilities:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Running the tests
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packaging the application
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying the application
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All those steps are important to think about, so let's walk through them.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Running the tests
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are writing great tests right now and those tests ensure that our system
    behaves as expected according to the feature set we worked out with the domain
    experts, so those tests should run, and if they fail there is something wrong
    with our system that we need to fix. Since we already have a testing framework
    in place, running the tests is pretty straightforward:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will run all the tests specified inside the test directory, which according
    to our file layout we created earlier, will be all of them. Since we don''t want
    to remember this command, we can wire it into npm by adding it to the `package.json`
    file we already set up:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With this in place, running all our tests becomes:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will make our lives a lot easier, we can now rely on one command to actually
    run our tests, and the failures are certainly development failures and not the
    mistyping of a command, for example, forgetting about the `--recursive` and then
    skipping most of the tests. Depending on the preference of the developers involved,
    we can go even further, watching the files for changes and rerunning the tests
    triggered by those changes, the described system here should be considered as
    the minimum requirement.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Packaging the application
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Moving an application to production is most likely not a one-step process. Web
    applications might involve compiling assets together, downloading dependencies,
    and maybe even configuring certain parts for production instead of development.
    Running these steps by hand is prone to error, and every developer who has used
    such a process before has a story to tell about it failing more or less spectacularly.
    But if we want to keep our software malleable and able to react to changes to
    the domain, as well as get it in the hands of our domain experts quickly, we need
    to deploy early and often, and the first step towards this is packaging the application
    in one step.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal is for every developer to be able to set up the basic environment
    for the application, like in our case installing Node.js, and from then on setting-up
    the application with one command. Continuing with npm for now to manage our task,
    we add the following to our `package.json` file:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Since this is a custom command that has no special support in npm running,
    it means running:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is a little non-intuitive to an outsider, but listing a command like this
    in the readme file will cover that for now, and if we want to, we can also decide
    on a system to wrap all those calls to make them consistent.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a place to put any steps involved in packaging the application,
    we are ready to make sure we can deploy it with one command as well.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Deploying
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like we said before, we want our deployment to be a boring process; it should
    be one step and never cause a failure that is hard to recover from. This actually
    means we need to be able to roll back deploys as necessary, otherwise the fear
    of making a wrong deploy will be ossifying to any progress.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual deployment can be quite simple, and a couple of shell scripts easily
    accomplish it depending on your needs. One system that covers the basics, and
    is easy to use and adaptable to changing needs is `deploy.sh` is available at
    [https://github.com/visionmedia/deploy](https://github.com/visionmedia/deploy).
    When using deploy, all there is to do is create a `deploy.conf` configuration
    file:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The file can be extended for any application servers, and should be fairly easy
    to read. Any steps that need to be run can be implemented as pre- or post-deploy
    hooks, which makes this system incredibly flexible, especially when combined with
    a powerful build system managing the application parts.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the right system
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far we have been using what was available without really installing big tools;
    `deploy.sh` itself is just a shell script containing less than 400 lines of code
    and npm comes with Node.js by default. There are a lot of valid reasons to actually
    use a system outside the ones that come with the environment, for example, when
    you expect that the project will be composed of more than one language in the
    future, choosing a neutral wrapper can greatly increase the consistency across
    projects and ease the on ramp.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: We now know what we want to get out of the system, so choosing one means looking
    at the requirements and picking one the majority of the developers like. One thing
    to bear in mind is that this is something the project will stick with hopefully
    for a long time, so a system that has some usage under its belt is a good idea.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I like to wrap most of my projects in a simple **Makefile**, because it is the
    most available and understood system out there, but your mileage may vary.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the end of the setting up where we think about files and running
    commands, but one important part is missing, that is, how to actually make the
    domain part of the world, but keep it separate enough to allow reasoning on about
    it.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Isolating the domain
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *Create your application to work without either a UI or a database so
    you can run automated regression-tests against the application, work when the
    database becomes unavailable, and link applications together without any user
    involvement.* |   |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
- en: '|   | --*Alistair Cockburn* |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
- en: When we create an application following the principles of domain-driven design,
    we strive to keep the business logic separate from the parts of the software that
    interact with the "real world". The most-often referenced case is that we don't
    want to build our UI layer in a way that it houses some or all of the business
    logic as well. We want a clear domain-focused API that is consumed by other parts
    of the application to provide their interaction with the domain.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: The concept is similar to the UI being provided by some, to the UI specific
    language or API, be it HTML, or for example QT. Both sprang out of the concept
    of providing the developer with all the parts needed to build a UI but keep a
    natural separation. This doesn't make sense, the combination of HTML, CSS, and
    the DOM abstraction of JavaScript are a DSL, domain-specific language, to build
    browser interfaces. They provide an abstraction under which the browser implementers
    are free to change their implementation without impacting every website written.
    They therefore isolate the business domain of the browser vendors, displaying
    structured content, from the job of creating the content, most likely your job.
    Having such an API has many advantages over exposing the internal data structures
    directly, as history has shown.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: The architecture of modern applications
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea to isolate the business domain has followed the software industry for
    a long time, especially with the growth of having a core domain and many consumers.
    In recent years, the idea to make a service an API first has become more and more
    viable due to the increasing importance of mobiles and the web. Many applications
    today have multiple interfaces, for example, in hotel booking, the state of the
    hotel is accessed by the employees, moving customers between rooms, taking bookings
    over the phone, and more. At the same time, customers are online, checking the
    Internet for available options and booking via various web portals.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'On the days prior to their arrival, users might want to access the data on
    their phone in a mobile app to make sure they have it available wherever they
    are. These are just some of the many access options for a booking system, and
    even now there are a lot of options already:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Internal desktop applications
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internal web applications
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web applications
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web applications by other providers
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mobile applications
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mobile applications by other providers
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is already a long list and we can expect it to grow in the future with
    new devices appearing, accompanied by different usage patterns.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Hexagonal architecture
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So how can we make sure an application is ready to evolve? With the appearance
    and dominance of web applications, developers have realized that there is a split
    between what an application is built to process and the interface and technologies
    it uses. This split is not a bad thing, as it can be used to establish APIs at
    those points and encapsulate the business domain that the core concept domain-driven
    design is all about. One possible technique to accomplish this is known as **Hexagonal
    architecture**.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![Hexagonal architecture](graphics/B03704_03_02.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: The application as a whole is seen as a hexagon, with the business domain located
    inside. While the business domain only cares about its own language and concepts,
    it uses ports to talk to whatever it needs. Ports are the interfaces to the outside
    world and establish a clear API for what is needed and how it should be provided.
    On the other hand, there are adapters, that is, elements providing the API. This
    gives a lot of flexibility, and it not only allows you to swap adapters, for example
    during a test, but to also try out different technologies more quickly to find
    the one that fits best, not by guessing but actually trying it with the application.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Applying the pattern
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As an avid reader will have realized, our dungeon management application does
    not differ a lot from the booking application just described. Moving forward,
    we also want to integrate it with multiple UIs and other applications. Also, our
    business concepts are complex enough to make us reach for domain-driven design,
    so a Hexagonal architecture suits us well. But how do we get there?
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: This first thing to realize is that so far we have already been designing for
    it. Our core functionality is understood outside the context of a database or
    a web framework. The idea of hexagonal architecture and domain-driven design integrate
    very well after all. We now move forward to have a clear separation of what the
    business domain contains and what the outside provides. This is also referred
    to as **persistence ignorance**, as we want our domain to ignore the layers dealing
    with saving and loading data. As part of this pattern, we create separate objects
    or modules that encapsulate the actions of our domain, and use those to integrate
    into web frameworks as well as exposing as an API when we need to in the future.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Abstractions are not free; depending on the application, abstracting the data
    layers too much can introduce a performance overhead that might be too much to
    cope with. On the other hand, if your domain interacts with the data layer at
    such a frequency, there is possibly a problem in the domain itself and you might
    want to rethink your aggregates in the domain layer. The way we have to think
    about such patterns is more like a slider than a Boolean; we can increase and
    decrease the abstractions depending on the domain as well as the needs of our
    application's performance.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Plugging in a framework
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So how can we go about making this work for our application? The first version
    we are going to build is set out to have a web UI, so we need to have to plug
    in a web framework so we don't have to reinvent the wheel. Node.js provides many
    options there, the most popular being `express.js`, which we've already used,
    so what we want to do is let express do what it does best, serving requests, while
    our core domain processes the logic for those requests.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The code to manage the prisoner transfer is nicely encapsulated in its own module
    and only interacts with the domain objects. The other question is where the code
    should live. At this early stage, code like this might still validly reside in
    an `index.js` file, providing the interface, but as our project moves along we
    might move towards a more modular architecture containing the glue code that connects
    the domain to the express framework in its own module. At this stage, we might
    even create a middleware layer to inject dependencies automatically as we need
    them.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we got started with the project and are well on our way. We
    have everything in place to make the project progress and make it ready for changes
    that will no doubt follow. Again, the main idea has all been about isolation and
    making sure we think and tackle the domain, while not getting lost in the intricacies
    of language and frameworks and alike along the way.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: As most programmers will agree, integrating systems and modeling data are two
    tasks that really require attention just to themselves, and with this setup, we
    are taking an important step towards this integration. Meanwhile, the architecture
    sets us up to keep modeling the data as we started out previously.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we go into more detail on the domain objects themselves
    and what modeling them means in domain-driven design terms. We will be introducing
    the terminology to classify those models and drive them out using domain-driven
    design in conjunction with object orientation.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
