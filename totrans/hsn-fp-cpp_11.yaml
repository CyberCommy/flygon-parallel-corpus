- en: Test-Driven Development for Functional Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Test-driven development** (**TDD**) is a very useful method for designing
    software. The method is as follows—we first write one single test that fails,
    then we implement the minimum code to make the test pass, and finally we refactor.
    We do this in small cycles in quick succession.'
  prefs: []
  type: TYPE_NORMAL
- en: We will look at how pure functions simplify tests and provide an example of
    applying TDD with functions. Pure functions allow us to write simple tests because
    they always return the same values for the same input parameters; therefore, they
    are equivalent to big data tables. We can therefore write tests that emulate data
    tables for inputs and the expected outputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use data-driven tests to take advantage of pure functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the basics of the TDD cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to design a pure function using TDD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need a compiler that supports **C++ 17**. I used **GCC 7.3.0**.
  prefs: []
  type: TYPE_NORMAL
- en: The code can be found on GitHub at [https:/​/​github.​com/​PacktPublishing/​Hands-​On-​Functional-Programming-​with-​Cpp](https://github.%E2%80%8Bcom/PacktPublishing/Hands-On-Functional-Programming-with-Cpp)
    in the `Chapter09` folder. It includes and uses `doctest`, which is a single header
    open source unit testing library. You can find it on its GitHub repository at [https:/​/github.​com/​onqtam/​doctest](https://github.%E2%80%8Bcom/onqtam/doctest).
  prefs: []
  type: TYPE_NORMAL
- en: TDD for functional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programming in the 1950s was very different from what we know today. The job
    we now know as that of a programmer was split between three roles. The programmer
    would write the algorithm meant to be implemented. Then, a specialized typist
    would type it into punch cards using a special machine. The programmer then had
    to manually verify that the punch cards were correct—although there were hundreds
    of them. Once happy that the punch cards were correct, the programmer would take
    them to the mainframe operator. Since the only computers in existence were huge
    and very expensive, the time spent on the computer had to be protected. The mainframe
    operator took care of the computer, ensuring that the most important tasks took
    precedence, and thus a new program could wait for days until it was run. Once
    run, the program would print a full stack trace. If there was an error, the programmer
    had to look at a very long paper filled with weird symbols and figure out what
    might be wrong. The process was slow, error-prone, and unpredictable.
  prefs: []
  type: TYPE_NORMAL
- en: However, some of the engineers came up with an idea. What if, instead of getting
    the complex read-out from a failing program, they would get a clear indication
    of what was wrong? They decided to start writing additional code that would check
    the production code and produce an output of pass or fail. Instead of running
    the program, or in addition to running the program, they would run unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: The practice of unit testing was forgotten once programmers had shorter feedback
    loops, with the invention of terminals and, later, personal computers and powerful
    debuggers. However, it never quite disappeared, and it suddenly came back in a
    different form.
  prefs: []
  type: TYPE_NORMAL
- en: It was in the 1990s that unit tests made a surprise re-appearance. A group of
    programmers, including Kent Beck, Ward Cunningham, and Ron Jeffries, experimented
    with taking development practices to the extreme. The result of their effort was
    called **extreme programming** (**XP**). One of these practices was unit testing,
    and the results were very interesting.
  prefs: []
  type: TYPE_NORMAL
- en: The common practice of unit testing was to write some tests after the code was
    written, as part of the testing period. These tests were often written by testers—a
    different group from the programmers who implemented the features.
  prefs: []
  type: TYPE_NORMAL
- en: However, the initial XPers tried unit testing in a different way. What if we
    were to write the tests along with the code? And, more interestingly, what if
    we were to write the tests *before* the implementation? This led to two different
    techniques—**test-first programming** (**TFP**), which consists of writing a few
    tests first, and then some code to make the tests pass, and TDD, which we'll discuss
    in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: When I first heard about these techniques, I was both puzzled and fascinated.
    How could you write tests for something that doesn't exist? What would be the
    benefit? Fortunately, with the support of J.B. Rainsberger, I quickly realized
    the power of TFP/TDD. Our clients and our stakeholders want working features in
    software as soon as possible. Yet, all too often, they can't explain what features
    they want. Starting with the tests means that you fully understand what to implement
    and leads to useful and interesting conversations that clarify the requirements.
    Once the requirements are clear, we can focus on the implementation. Moreover,
    in TDD, we clean the code as soon as possible, so that we don't create a mess
    as time passes. It truly is an amazingly powerful technique!
  prefs: []
  type: TYPE_NORMAL
- en: But let's start from the beginning. How do we write a unit test? And, more importantly
    for our purpose, is it easier to write unit tests for pure functions?
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests for pure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first see what a unit test looks like. I have been using them already
    for a while in this book, and I''m sure you understand the code. But it''s time
    to look at one particular example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We first initialize the two variables with specific values (the *Arrange* part
    of the unit test). We then call the production code (the *Act* part of the unit
    test). Finally, we check that the result is the one we expected (the *Assert*
    part of the unit test). The library we're using, called `doctest`, provides implementation
    for the macros that allow us to write the unit tests. While more unit testing
    libraries exist for C++, notable examples including GTest and `Boost::unit_test`,
    the facilities they offer to programmers are quite similar.
  prefs: []
  type: TYPE_NORMAL
- en: When talking about unit tests, it's more important to figure out the characteristics
    that make them useful. The previous test is small, focused, fast, and can fail
    for only one reason. All these characteristics make the test useful since it's
    easy to write, easy to maintain, crystal clear, and provides useful and fast feedback
    if a bug is introduced.
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of technique, the previous test is example-based since it uses a very
    specific example to check a specific behavior of the code. We will look at a different
    method of unit testing called **property-based testing** in [Chapter 11](56c096aa-67a7-48ad-bf22-a78367941a26.xhtml),
    *Property-Based Testing*. Since this is an example-based test, an interesting
    question crops up: if we want to test the `greaterThan` function, what other examples
    would be interesting?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, we want to look at all the possible behaviors of the functions. So, what
    would be its possible outputs? Here''s a list:'
  prefs: []
  type: TYPE_NORMAL
- en: True, if the first value is greater than the second value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: False, if the first value is less than the second value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, that''s not enough. Let''s add the edge case:'
  prefs: []
  type: TYPE_NORMAL
- en: False, if the first value equals the second value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And, let's not forget possible errors. What is the domain for the values passed
    in? Is it OK to pass negative values? Floating point values? Complex numbers?
    This is an interesting conversation to have with the stakeholders of this function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume the simplest case for now—the function will accept only valid
    integers. This means that we need two more unit tests checking the situations
    when the first parameter is less than the second and when the two are equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In [Chapter 7](9d86d296-6caf-4b65-9020-4307c85f3acd.xhtml), *Removing Duplication
    with Functional Operations*, we discussed code similarity and how to remove it.
    Here, we have a case of similarity between tests. One way to remove it is to write
    so-called **data-driven tests** (**DDT**). In DDT, we write a list of inputs and
    expected outputs and repeat the test over every line of data. Different testing
    frameworks offer different ways to write these tests; for now, `doctest` has limited
    support for DDT, but we can still write them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If we ignore the plumbing code (the `struct Data` definition and the call to
    the `CAPTURE` macro), this shows a very convenient way of writing tests—especially
    for pure functions. Given that pure functions return, by definition, the same
    output when they receive the same inputs, it's only natural to test them with
    a list of inputs/outputs.
  prefs: []
  type: TYPE_NORMAL
- en: Another convenience of DDT is that we can easily add a new test by just adding
    a new line to the list. This, in particular, helps us when doing TDD with pure
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: The TDD cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TDD is a development cycle that is commonly presented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Red**: Write a test that fails.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Green**: Make the test pass by making the smallest change possible in the
    production code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Refactor**: Reorganize the code to include the newly introduced behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, TDD practitioners (such as myself) will be keen to mention that the
    TDD cycle starts with another step—think. More precisely, before writing the first
    test, let's understand what we are trying to implement and find a good place in
    the existing code to add the behavior.
  prefs: []
  type: TYPE_NORMAL
- en: This cycle is deceptively simple. However, beginners often struggle with what
    the first test should be and what the test after that should be, as well as with
    writing code that is too complex. **Refactoring** is an art in itself, requiring
    knowledge of code smells, design principles, and design patterns. Overall, the
    biggest mistake is to think too much about the code structure that you'd like
    to obtain, and write the tests that lead to that.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, TDD requires a mindset change. We start from the behaviors and, in
    small steps, polish the code structure that fits the behavior. A good practitioner
    will have steps smaller than 15 minutes. But that's not the only surprise of TDD.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest surprise of TDD is that it can teach you about software design by
    allowing you to explore various solutions to the same problem. The more solutions
    you're willing to explore, the better you'll become at designing code. TDD is
    a continuous learning experience when practiced with the right amount of curiosity.
  prefs: []
  type: TYPE_NORMAL
- en: I hope I made you curious about TDD. There's a lot more to study about the topic,
    but, for our goals, it's enough to try out an example. And since we're talking
    about functional programming, we'll use TDD to design a pure function.
  prefs: []
  type: TYPE_NORMAL
- en: Example – designing a pure function using TDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once again, we need a problem to showcase TDD in action. Since I like to practice
    development practices using games, I went through the list from Coding Dojo Katas
    ([http://codingdojo.org/kata/PokerHands/](http://codingdojo.org/kata/)) and I
    picked the poker hands problem for this exercise.
  prefs: []
  type: TYPE_NORMAL
- en: The poker hands problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A description of the problem is as follows—given two or more hands of poker,
    we need to compare them and return the one that has the higher rank and why it
    wins.
  prefs: []
  type: TYPE_NORMAL
- en: Each hand has five cards, and the cards are picked from a normal 52-card deck.
    The deck is formed of four suits—clubs, diamonds, hearts, and spades. Each suit
    starts with a `2` and ends with an ace, and is denoted as follows—`2`, `3`, `4`,
    `5`, `6`, `7`, `8`, `9`, `T`, `J`, `Q`, `K`, `A` (`T` means 10).
  prefs: []
  type: TYPE_NORMAL
- en: 'The cards in a poker hand will create formations. The value of a hand is determined
    by those formations, in the following descending order:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Straight flush**: Five cards of the same suit with consecutive values. For
    example, `2♠`, `3♠`, `4♠`, `5♠`, and `6♠`. The higher the starting value, the
    more valuable the straight flush is.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Four of a kind**: Four cards with the same value. The highest one is four
    aces—`A♣`, `A♠`, `A♦`, and `A♥`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Full house**: Three cards of the same value, and another two cards with the
    same value (but different). The highest one is as follows—`A♣`, `A♠`, `A♦`, `K♥`,
    and `K♠`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flush**: Five cards of the same suit. For example—`2♠`, `3♠`, `5♠`, `6♠`,
    and `9♠`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Straight**: Five cards of consecutive values. For example—`2♣`, `3♠`, `4♥`,
    `5♣`, and `6♦`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Three of a kind**: Three cards with the same value. For example—`2♣`, `2♠`,
    and `2♥`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Two pairs**: See pair. For example—`2♣`, `2♠`, `3♥`, and `3♣`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pair**: Two cards of the same value. For example—`2♣` and `2♠`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High card**: When no other formation is present, the highest cards from each
    hand are compared and the highest wins. If the highest cards have the same value,
    the next highest cards are compared, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our goal is to implement a program that compares two or more poker hands and
    returns both the winner and the reason. For example, let''s use the following
    input:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Player 1**: `*2♥ 4♦ 7♣ 9♠ K♦*`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Player 2**: `*2♠ 4♥ 8♣ 9♠ A♥*`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For this input, we should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Player 2 wins with their high card—an ace*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step 1 – Think
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at the problem in more detail. More precisely, we are trying to split
    the problem into smaller pieces without thinking too much about the implementation.
    I find it useful to look at possible examples of inputs and outputs, and to start
    with a simplified problem that allows me to implement something that works as
    fast as possible while preserving the nature of the problem.
  prefs: []
  type: TYPE_NORMAL
- en: It's obvious that we have a very large number of combinations to test for. So,
    what would be a useful simplification of the problem that limits our test cases?
  prefs: []
  type: TYPE_NORMAL
- en: One obvious way is to start from a shorter hand. Instead of having five cards,
    we could start with one card in hand. This limits our rules to high cards. The
    next step is to have two cards, which introduces the *pair > high card*, and *higher
    pair > lower pair*, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Another way is to start with five cards, but to limit the rules. Start with
    a high card, then implement one pair, then two pairs, and so on; or, the other
    way around, from the straight flush all the way down to the pair and high card.
  prefs: []
  type: TYPE_NORMAL
- en: The interesting thing about TDD is that any of these roads will lead to results
    that work in the same way, albeit often with different code structures. One of
    the powers of TDD is to help you visit multiple designs for the same problem by
    varying the order of your tests.
  prefs: []
  type: TYPE_NORMAL
- en: Needless to say, I've done this problem before, but I've always started from
    one card in hand. Let's have some fun and try a different way, shall we? I choose
    to go with five cards and start from the straight flush. To keep things simple,
    I'll just support two players for now, and since I like to name them, I'll use
    Alice and Bob.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What would be some interesting examples for this situation? Let''s think about
    possible outputs first:'
  prefs: []
  type: TYPE_NORMAL
- en: Alice wins with a straight flush.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bob wins with a straight flush.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alice and Bob have equally good straight flushes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Undecided (as in not implemented yet).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s write some examples of inputs for these outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With these examples, we're ready to start writing our first test!
  prefs: []
  type: TYPE_NORMAL
- en: First test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Based on our previous analysis, our first test is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write it! We expect this test to fail, so we can do whatever we want
    at this point. We need to initialize two hands with the preceding card. For now, we
    will use `vector<string>` to represent each hand. Then, we will call a function
    (that doesn''t exist yet) that we imagine will, at some point, implement the comparison
    between the two hands. Finally, we check the result against the expected output
    message that was previously defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: For now, this test doesn't compile because we haven't even created the `comparePokerHands` function. Time
    to move forward.
  prefs: []
  type: TYPE_NORMAL
- en: Making the first test pass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first write the function. The function needs to return something, so
    we''ll just return the empty string for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'What would be the simplest implementation that makes the test pass? This is
    the point where TDD gets weirder. The simplest implementation to make the test
    pass is to return the expected result as a hardcoded value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, my compiler complains because I turned all warnings on, and
    I report all warnings as errors. The compiler notices that we don''t use the two
    arguments and complains. This is a valid complaint, but I plan to start using
    the arguments soon. The C++ language gives us an easy fix—just remove or comment
    out the parameter names, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We run the tests, and our first test passes! Cool, something works!
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Is there anything to refactor? Well, we have two commented argument names, and
    I would normally remove them because commented code is just clutter. But, I've
    decided to keep them there for now, knowing that we will soon use them.
  prefs: []
  type: TYPE_NORMAL
- en: We also have a duplication—the same `Alice wins with straight flush` string appears
    in both the test and the implementation. Would it be worth extracting it as a
    constant or common variable? If this was the end of our implementation, then sure.
    But I know that the string is actually built from multiple things—the name of
    the winning player, and the rule based on which hand wins. I'd like to keep this
    as it is for a while.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, there is nothing to refactor. So, let's move on!
  prefs: []
  type: TYPE_NORMAL
- en: Think (again)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The current implementation feels underwhelming. Just returning a hardcoded value
    doesn't solve much. Or does it?
  prefs: []
  type: TYPE_NORMAL
- en: This is the mindset change needed when you're learning TDD. I know it because
    I went through it. I was so used to looking at the end result, comparing this
    solution with what I'm trying to accomplish feels underwhelming. However, there's
    a different way to look at it—we have something that works, and we have the simplest
    possible implementation. There's still a long time to go, but we can already demonstrate
    something to our stakeholders. Also, as we'll see, we'll always build on solid
    ground since the code we write is fully tested. These two things are incredibly
    liberating; I can only hope you will feel the same when trying out TDD.
  prefs: []
  type: TYPE_NORMAL
- en: But, what do we do next? We have a few options.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we could write another test in which Alice wins with a straight flush.
    However, that won't change anything in the implementation, and the test will immediately
    pass. While this seems to go against the TDD cycle, there's nothing wrong with
    adding more tests for our piece of mind. Definitely a valid option.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, we could move to the next test in which Bob wins with a straight flush.
    This will definitely change a few things.
  prefs: []
  type: TYPE_NORMAL
- en: Both options are good, and you can pick either of them. But since we want to
    see DDT in practice, let's write more tests first.
  prefs: []
  type: TYPE_NORMAL
- en: More tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s quite easy to turn our test into a DDT and add more cases. We will just
    vary the values of the Alice hand, while keeping Bob''s hand intact. The result
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Once again, all these tests pass. Time to move on to our next test.
  prefs: []
  type: TYPE_NORMAL
- en: Second test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second test we''ve described is when Bob wins with a straight flush:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write it! And this time, let''s use the data-driven format from the
    start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When we run this test, it fails, for a simple reason—we have a hardcoded implementation
    that says that Alice wins. What now?
  prefs: []
  type: TYPE_NORMAL
- en: Making the test pass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once again, we need to find the simplest way to make this test pass. Even if
    we won't like the implementation, the next step is about cleaning up the mess.
    So, what would the simplest implementation be?
  prefs: []
  type: TYPE_NORMAL
- en: We obviously need to introduce a conditional statement in our implementation.
    The question is, what should we check?
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, we have a few options. One option is to fake it once more, using
    something as simple as comparing Bob''s hand with the exact hand we expect to
    win:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: To make it compile, we also had to make the type of the `vector<string>` hands
    appear everywhere. Once these changes are made, the tests pass.
  prefs: []
  type: TYPE_NORMAL
- en: Our second option is to start implementing the actual check for a straight flush.
    However, that is a small problem in itself, and to do it properly requires more
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: I will go with the first option for now, refactor, and then start looking deeper
    into the implementation of the check for a straight flush.
  prefs: []
  type: TYPE_NORMAL
- en: Refactor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Is there anything to refactor? We still have a duplication in strings. Moreover,
    we've added a duplication to the vector containing Bob's hand. But we expect both
    to go away quite soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, another thing is bothering me—`vector<string>` appears everywhere.
    Let''s remove this duplication by naming the `vector<string>` type for what it
    is—`Hand`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Think
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Time to think again. We have two cases implemented with hardcoded values. That's
    not a big problem for Alice winning with a straight flush, but it is a problem
    if we add another test case for Bob with a different set of cards. We could go
    on for a few more tests, but inevitably, we'll need to actually check for the
    straight flush. I think now is as good a time as any.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what is a straight flush? It''s a set of five cards that have the same
    suit and consecutive values. We need a function that can take a set of five cards
    and return `true` if it''s a straight flush, or `false` if not. Let''s write down
    a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Input: `2♣ 3♣ 4♣ 5♣ 6♣` => Output: `true`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Input: `2♠ 3♠ 4♠ 5♠ 6♠` => Output: `true`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Input: `T♠ J♠ Q♠ K♠ A♠` => Output: `true`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Input: `2♣ 3♣ 4♣ 5♣ 7♣` => Output: `false`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Input: `2♣ 3♣ 4♣ 5♣ 6♠` => Output: `false`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Input: `2♣ 3♣ 4♣ 5♣` => Output: `false` (only four cards, need exactly five)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Input: `[empty vector]` => Output: `false` (no cards, need exactly five)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Input: `2♣ 3♣ 4♣ 5♣ 6♣ 7♣` => Output: `false` (six cards, need exactly five)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will notice that we also considered edge cases and weird situations. We
    have enough information to continue, so let's write the next test.
  prefs: []
  type: TYPE_NORMAL
- en: Next test – simple straight flush
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I prefer to start from the positive cases, since they tend to advance the implementation
    more. Let''s see the simplest one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Input: `2♣ 3♣ 4♣ 5♣ 6♣` => Output: `true`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The test appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Once again, the test doesn't compile because we have no `isStraightFlush` function
    implemented. But the test is right, and it's failing, so it's time to move on.
  prefs: []
  type: TYPE_NORMAL
- en: Making the test pass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once again, the first step is to write the body of the function and to return
    the expected hardcoded value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We ran the tests and they passed, so we're done for now!
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, you can see where this is going. We can either add some more inputs for
    a correct straight flush, but they won't change the implementation. The first
    test that will force us to advance the implementation is our first example of
    a set of cards that isn't a straight flush.
  prefs: []
  type: TYPE_NORMAL
- en: For the goals of this chapter, I will fast forward. However, I strongly advise
    you to go through all the small steps by yourself and compare your result with
    mine. The only way to learn TDD is to practice it by yourself and reflect on your
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing isStraightFlush
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at what we''re trying to accomplish again—a straight flush, which
    is defined by having exactly five cards with the same suit and consecutive values.
    We just need to express these three conditions in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation is helped by a number of different lambdas. First, to check
    the length of the formation, we use `has5Cards`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to check that it has the same suit, we use `allSuits` to extract the
    suits from the hand, `isSuitEqual` to compare two suits, and `isSameSuit` to check
    that all suits from a hand are the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to verify that the values are consecutive, we use `valueOf` to extract
    the values from a card, `allValuesInOrder` to get all the values from a hand and
    sort them, `toRange` to create a range of consecutive values starting from an
    initial value, and `areValuesConsecutive` to check that the values from a hand
    are consecutive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The final piece of the puzzle is a map from `char` to `int` that helps us to
    translate all the card values, including `T`, `J`, `Q`, `K`, and `A`, into numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also see our tests (which are obviously all passing). First, the ones
    for a valid straight flush; we''ll check straight flushes starting with `2`, `3`,
    `4`, and `10`, and how they vary along the data interval:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the tests for a set of cards that is not a valid straight flush. For
    input, we''ll use hands that are almost a straight flush, except for being from
    another suit, not having enough cards, or having too many cards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It's now time to get back to our main problem—comparing the poker hands.
  prefs: []
  type: TYPE_NORMAL
- en: Plugging the check for straight flush back into comparePokerHands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Despite everything we have implemented hitherto, our implementation of `comparePokerHands`
    is still hardcoded. Let''s remember its current status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'But, we now have a way of checking for a straight flush! So, let''s plug our
    implementation in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'All our tests pass, so we''re almost done. Time to add a few more tests to
    our `Bob wins with straight flush` case to be certain that we haven''t missed
    things. We''ll keep the same hand for Alice, an almost straight flush, and vary
    Bob''s hand from `2`, `3`, and `10`-based straight flushes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: All the previous tests pass. So, we're done with two cases—when either Alice
    or Bob have a straight flush and their competitor doesn't. Time to move to the
    next case.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing two straight flushes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we discussed in the beginning of this section, there''s another case when
    both Alice and Bob have straight flushes, but Alice wins with a higher one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write the test and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The test fails, because our `comparePokerHands` function returns that Bob won
    instead of Alice. Let''s fix this with the simplest implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Our implementation decides that Alice always wins if both Alice and Bob have
    a straight flush. That's obviously not what we want, but the tests pass. So, what
    test can we write to push the implementation forward?
  prefs: []
  type: TYPE_NORMAL
- en: Think
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It turns out that we missed one case from our previous analysis. We looked
    at what happens when both Alice and Bob have straight flushes and Alice wins;
    but what about when Bob has a higher straight flush? Let''s write down an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Time to write another failing test.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing two straight flushes (continued)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The test is fairly obvious to write by now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The test fails again, because our implementation assumes that Alice always wins
    when both Alice and Bob have straight flushes. It might be time to check which
    is the highest straight flush of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we will need once again to write down a few cases and go through
    our TDD cycles. Once again, I will fast forward to the implementation. We end
    up with the following helper function that compares two straight flushes. It returns
    `1` if the first hand has a higher straight flush, `0` if the two are equal, and
    `-1` if the second hand is a higher straight flush:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'And, by changing our implementation, we can make the tests pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This leaves us with the final case—a draw. The test is once again quite clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'And the change in implementation is fairly straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This is not the prettiest function, but it passes all our tests for straight
    flush comparison. We can definitely refactor it into smaller functions, but I'll
    stop here since we've reached our goal—we've designed not only one, but multiple,
    pure functions using TDD and DDT.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you've learned how to write unit tests, how to write data-driven
    tests, and how to use data-driven tests combined with TDD to design pure functions.
  prefs: []
  type: TYPE_NORMAL
- en: TDD is one of the core practices of effective software development. While it
    may seem weird and counterintuitive at times, it has a strong advantage—every
    few minutes, you have something working that you can demo. A passing test is not
    only a demo point, but also a save point. If anything wrong happens while trying
    to refactor or to implement the following test, you can always go back to the
    last save point. I find this practice even more valuable in C++, where so many
    things can go wrong. In fact, I wrote all the code since [Chapter 3](c4cdce72-828b-4cb8-b904-481315999c60.xhtml), *Deep
    Dive into Lambdas*, with a TDD approach. This has been immensely helpful, since
    I know that my code is working—something that is quite difficult to do when writing
    a technical book without this method. I strongly advise you to look more into
    TDD and practice it for yourself; it's the only way you'll become proficient.
  prefs: []
  type: TYPE_NORMAL
- en: TDD with functional programming is a perfect fit. When using it with imperative
    object-oriented code, we often need to take into account mutation and it makes
    things more difficult. With pure functions and data-driven tests, the practice
    of adding more tests becomes as simple as it can be, and allows us to focus on
    implementation. With the support of functional operations, making a test pass
    becomes easier in many situations. I personally find this combination incredibly
    rewarding; I hope you'll find it equally useful.
  prefs: []
  type: TYPE_NORMAL
- en: Now it's time to move forward and revisit another section of software design—design
    patterns. Do they change with functional programming? (Spoiler alert—they actually
    become much simpler.) This is what we will discuss in the next chapter.
  prefs: []
  type: TYPE_NORMAL
