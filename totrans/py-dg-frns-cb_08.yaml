- en: Working with Forensic Evidence Container Recipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Opening acquisitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gathering acquisition and media information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating through files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing files within the container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching for hashes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Sleuth Kit, and its Python bindings `pytsk3`, is perhaps the most well-known
    Python forensic library. This library offers rich support for accessing and manipulating
    filesystems. And with the help of supporting libraries, such as `pyewf`, they
    can be used to work with common forensic containers such as EnCase's popular `E01`
    format. Without these libraries (and many others), we would be inherently more
    limited by what can be accomplished with Python in forensics. Due to its lofty
    goal as an all-in-one filesystem analysis tool, `pytsk3` is perhaps the most complicated
    library we will work with in this book.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, we have dedicated a number of recipes exploring the fundamentals
    of this library. Up to this point, recipes have been mainly focused on loose file
    support. That convention ends here. We will routinely use this library going forward
    to interact with forensic evidence. Understanding how to interact with forensic
    containers will take your Python forensic capabilities to the next level.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn how to install `pytsk3` and `pyewf`, two libraries
    that will allow us to leverage the Sleuth Kit and `E01` image support, respectively.
    Additionally, we will learn how to perform basic tasks, such as accessing and
    printing a partition table, iterating through a filesystem, exporting files by
    extension, and searching for known bad hashes in an evidence container. You will
    learn about:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing and setting up `pytsk3` and `pyewf`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opening forensic acquisitions such as `raw` and `E01` files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting partition table data and `E01` metadata
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursing through active files and creating an active file listing spreadsheet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exporting files from the evidence container by file extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching for known bad hashes in an evidence container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visit [www.packtpub.com/books/content/support](http://www.packtpub.com/books/content/support)
    to download the code bundle for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Opening acquisitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recipe Difficulty: Medium'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python Version: 2.7'
  prefs: []
  type: TYPE_NORMAL
- en: 'Operating System: Linux'
  prefs: []
  type: TYPE_NORMAL
- en: 'With `pyewf` and `pytsk3` comes a whole new set of tools and operations we
    must first learn. In this recipe, we will start with the basics: opening an evidence
    container. This recipe supports `raw` and `E01` images. Note that unlike our previous
    scripts, these recipes will use Python 2.X due to some bugs found while working
    with the Python 3.X version of these libraries. That said, the main logic would
    not differ between the two versions and could easily be ported. Before we learn
    to open the container, we need to set up our environment. We will explore this
    in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Excluding a few scripts, we have been OS agnostic for the majority of this
    cookbook. Here, however, we will specifically provide instructions for building
    on Ubuntu 16.04.2\. With a fresh install of Ubuntu, execute the following commands
    to install necessary dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Beyond the two previously mentioned libraries (`pytsk3` and `pyewf`), we will
    also be using the third-party module `tabulate` to print tables to the console.
    As that is the easiest module to install, let''s complete that task first by executing
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To learn more about the tabulate library, visit [https://pypi.python.org/pypi/tabulate](https://pypi.python.org/pypi/tabulate).
  prefs: []
  type: TYPE_NORMAL
- en: 'Believe it or not, we can install `pytsk3` using `pip` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To learn more about the `pytsk3` library, visit [https://github.com/py4n6/pytsk.](https://github.com/py4n6/pytsk)
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, for `pyewf`, we must take a slightly more circuitous route and install
    it from its GitHub repository, [https://github.com/libyal/libewf/releases](https://github.com/libyal/libewf/releases).
    These recipes were written using the `libewf-experimental-20170605` release, and
    we recommend you install that version here. Once the package has been downloaded
    and extracted, open a Command Prompt in the extracted directory and execute the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To learn more about the `pyewf` library, visit : [https://github.com/libyal/libewf.](https://github.com/libyal/libewf)'
  prefs: []
  type: TYPE_NORMAL
- en: It goes without saying that for this script you will need a `raw` or `E01` evidence
    file to run these recipes against. For the first script, we recommend using a
    logical image, such as `fat-img-kw.dd` from [http://dftt.sourceforge.net/test2/index.html](http://dftt.sourceforge.net/test2/index.html).
    The reason is that this first script will lack some necessary logic to handle
    physical disk images and their partitions. We will introduce this functionality
    in the *Gathering acquisition and media information* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We employ the following methodology to open forensic evidence containers:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify if the evidence container is a `raw` image or an `E01` container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Access the image using `pytsk3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print a table of the root-level folders and files to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We import a number of libraries to assist with argument parsing, handling evidence
    containers and filesystems, and creating tabular console data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This recipe's command-line handler takes two positional arguments, `EVIDENCE_FILE`
    and `TYPE`, which represent the path to the evidence file and the type of evidence
    file (that is, `raw` or `ewf`). Note that for segmented `E01` files, you only
    need to supply the path to the first `E01` (with the assumption that the other
    splits are in the same directory). After performing some input validation on the
    evidence file, we supply the `main()` function with the two provided inputs and
    begin executing the script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the `main()` function, we first check what type of evidence file we are working
    with. If it is an `E01` container, we need to first use `pyewf` to create a handle
    before we can access its contents with `pytsk3`. With a `raw` image, we can directly
    access its contents with `pytsk3` without needing to perform this intermediate
    step first.
  prefs: []
  type: TYPE_NORMAL
- en: The `pyewf.glob()` method is used here to combine all segments of the `E01`
    container, if there are any, and store the segment names in a list. Once we have
    the list of filenames, we can create the `E01` handle object. We can then use
    this object to open the `filenames`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Next, we must pass the `ewf_handle` to the `EWFImgInfo` class, which will create
    the `pytsk3` object. The else statement here is for `raw` images that can use
    the `pytsk3.Img_Info` function to achieve the same task. Let's now look at the
    `EWFImgInfo` class to understand how EWF files are processed slightly differently.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The code for this component of the script is from the *Combining pyewf* *with
    pytsk3* section of the Python development page for `pyewf`.
  prefs: []
  type: TYPE_NORMAL
- en: Learn more about `pyewf` functions, visit [https://github.com/libyal/libewf/wiki/Development](https://github.com/libyal/libewf/wiki/Development).
  prefs: []
  type: TYPE_NORMAL
- en: This `EWFImgInfo` class inherits from the `pytsk3.Img_Info` base class and is
    of the type `TSK_IMG_TYPE_EXTERNAL`. It is important to note that the three functions
    defined next, `close()`, `read()`, and `get_size(),` are all required by `pytsk3`
    to interact with the evidence container appropriately. With this simple class
    created, we can now use `pytsk3` with any supplied `E01` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Back in the `main()` function, we have successfully created our `pytsk3` handler
    for either `raw` or `E01` images. We can now begin accessing the filesystem. As
    mentioned, this script is designed to work with logical images and not physical
    images. We will introduce support for physical images in the next recipe. Accessing
    the filesystem is really simple; we do so by calling the `FS_Info()` function
    on the `pytsk3` handle.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With access to the filesystem, we can iterate through the folders and files
    in the root directory. First, we access the root using the `open_dir()` method
    on the filesystem and specifying the root directory, `**/**`, as the input. Next,
    we create a nested list structure that will hold the table content, which we will
    later print to the console using `tabulate`. The first element of this list is
    the headers of that table.
  prefs: []
  type: TYPE_NORMAL
- en: Following that, we'll begin to iterate through the image as we would with any
    Python iterable object. There are a variety of attributes and functions for each
    object, and we begin to use them here. First, we extract the name of the object
    using the `f.info.name.name` attribute. We then check if we are dealing with a
    directory or a file using the `f.info.meta.type` attribute. If this is equal to
    the built-in `TSK_FS_META_TYPE_DIR` object, then we set the `f_type` variable
    to `DIR`; otherwise, to `FILE`.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we use a few more attributes to extract the directory or file size and
    create and modify timestamps. Be aware that object timestamps are stored in `Unix`
    time and must be converted if you would like to display them in a human-readable
    format. With these attributes extracted, we append the data to the `table` list
    and continue on to the next object. Once we have finished processing all objects
    in the root folder, we use `tabulate` to print the data to the console. This is
    accomplished in one line by supplying the `tabulate()` method with the list and
    setting the `headers` keyword argument to `firstrow` to indicate that the first
    element in the list should be used as the table header.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the script, we can learn about the files and folders at the root
    of the evidence container as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00090.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Gathering acquisition and media information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recipe Difficulty: Medium'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python Version: 2.7'
  prefs: []
  type: TYPE_NORMAL
- en: 'Operating System: Linux'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we learn how to view and print the partition table using `tabulate`.
    Additionally, for `E01` containers, we will print `E01` acquisition and container
    metadata stored in the evidence file. Oftentimes, we will be working with a physical
    disk image of a given machine. In pretty much any process going forward, we will
    need to iterate through the different partitions (or a user-selected partition)
    to get a handle on the filesystem and its files. Therefore, this recipe is of
    critical importance as we build upon our burgeoning understanding of the Sleuth
    Kit and its bevy of features.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to the *Getting started* section in the *Opening Acquisitions* recipe
    for information on the build environment and setup details for `pytsk3`, `pyewf`,
    and `tabulate`. All other libraries used in this script are present in Python's
    standard library.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The recipe follows these basic steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify if the evidence container is a `raw` image or an `E01` container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Access the image using `pytsk3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If applicable, print `E01` metadata to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print partition table data to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We import a number of libraries to assist with argument parsing, handling evidence
    containers and filesystems, and creating tabular console data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This recipe's command-line handler takes two positional arguments, `EVIDENCE_FILE`
    and `TYPE`, which represent the path to the evidence file and the type of evidence
    file. Additionally, if the user is experiencing difficulties with the evidence
    file, they can use the optional `p` switch to manually supply the partition. This
    switch should not be necessary for the most part but has been added as a precaution.
    After performing input validation checks, we pass the three arguments to the `main()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `main()` function is substantially similar, at least initially, to the previous
    recipe. We must first create the `pyewf` handle and then use the `EWFImgInfo`
    class to create, as shown previously in the `pytsk3` handle. If you would like
    to learn more about the `EWFImgInfo` class, refer to the *Opening Acquisitions*
    recipe. However, note that we have added an additional line calling the `e01_metadata()`
    function to print `E01` metadata to the console. Let's explore that function now.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `e01_metadata()` function primarily relies on the `get_header_values()`
    and `get_hash_values()` methods to acquire `E01`-specific metadata. The `get_header_values()`
    method returns a dictionary of `key-value` pairs for various types of acquisition
    and media metadata. We use a loop to iterate through this dictionary and print
    the `key-value` pairs to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we use a loop with the `hashes` dictionary to print stored acquisition
    hashes of the image to the console. Lastly, we call an attribute and a few functions
    to print acquisition size metadata.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'With that covered, we can now return to the `main()` function. Recall that
    in the first recipe of this chapter, we did not create support for physical acquisitions
    (which was totally on purpose). Now, however, we add that support in using the
    `Volume_Info()` function. While `pytsk3` can be daunting at first, appreciate
    the consistency in naming conventions used in the major functions we have introduced
    so far: `Img_Info`, `FS_Info`, and `Volume_Info`. These three functions are vital
    in order to access the contents of the evidence container. In this recipe, we
    will not be using the `FS_Info()` function as the purpose here is to only print
    out the partition table.'
  prefs: []
  type: TYPE_NORMAL
- en: We attempt to access the volume info in a `try-except` block. First, we check
    if the `p` switch was supplied by the user and, if so, assign the attribute for
    that partition type to a variable. Then we supply that, along with the `pytsk3`
    handle, in the `Volume_Info` method. Otherwise, if no partition was specified,
    we call the `Volume_Info` method and supply it with just the `pytsk3` handle object.
    If we receive an `IOError` attempting to do this, we catch the exception as `e`
    and print it to the console before exiting. If we are able to access the volume
    info, we pass this onto the `part_metadata()` function to print the partition
    data to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `part_metadata()` function is relatively light on logic. We create a nested
    list structure, as seen in the previous recipe, with the first element representing
    the eventual table header. Next, we iterate through the volume object and append
    the partition address, type, offset, and length to the `table` list. Once we have
    iterated through the partitions, we use `tabulate` to print a table of this data
    to the console using `firstrow` as the table header.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When running this code, we can review information about the acquisition and
    partition information in the console, if present:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00091.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Iterating through files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recipe Difficulty: Medium'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python Version: 2.7'
  prefs: []
  type: TYPE_NORMAL
- en: 'Operating System: Linux'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we learn how to recurse through the filesystem and create an
    active file listing. Oftentimes, one of the first questions we, as the forensic
    examiner, are often asked is "What data is on the device?". An active file listing
    comes in handy here. Creating a file listing of loose files is a very straightforward
    task in Python. However, this will be slightly more complicated because we are
    working with a forensic image rather than loose files. This recipe will be a cornerstone
    for future scripts as it will allow us to recursively access and process every
    file in the image. As you may have noticed, this chapter's recipes are building
    upon each other as each function we develop it becomes necessary to explore the
    image further. In a similar way, this recipe will become integral in future recipes
    to iterate through directories and process files.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to the *Getting started* section in the *Opening Acquisitions* recipe
    for information on the build environment and setup details for `pytsk3` and `pyewf`.
    All other libraries used in this script are present in Python's standard library.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We perform the following steps in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify if the evidence container is a `raw` image or an `E01` container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Access the forensic image using `pytsk3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recurse through all directories in each partition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store file metadata in a list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the `active` file list to CSV.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We import a number of libraries to assist with argument parsing, parsing dates,
    creating CSV spreadsheets, and handling evidence containers and filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This recipe's command-line handler takes three positional arguments, `EVIDENCE_FILE`,
    `TYPE`, and `OUTPUT_CSV`, which represent the path to the evidence file, the type
    of evidence file, and the output CSV file, respectively. Similar to the previous
    recipe, the optional `p` switch can be supplied to specify a partition type. We
    use the `os.path.dirname()` method to extract the desired output directory path
    for the CSV file and, with the `os.makedirs()` function, create the necessary
    output directories if they do not exist.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Once we have validated the input evidence file by checking that it exists and
    is a file, the four arguments are passed to the `main()` function. If there is
    an issue with initial validation of the input, an error is printed to the console
    before the script exits.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the `main()` function, we instantiate the volume variable with `None` to
    avoid errors referencing it later in the script. After printing a status message
    to the console, we check if the evidence type is an `E01` to properly process
    it and create a valid `pyewf` handle, as demonstrated in more detail in the *Opening
    Acquisitions* recipe. Refer to that recipe for more details as this part of the
    function is identical. The end result is the creation of the `pytsk3` handle,
    `img_info`, for the user-supplied evidence file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Next, we attempt to access the volume of the image using the `pytsk3.Volume_Info()`
    method by supplying it with the image handle. If the partition type argument was
    supplied, we add its attribute ID as the second argument. If we receive an `IOError`
    when attempting to access the volume, we catch the exception as `e` and print
    it to the console. Notice, however, that we do not exit the script as we often
    do when we receive an error. We'll explain why in the next function. Ultimately,
    we pass the `volume`, `img_info`, and `output` variables to the `open_fs()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `open_fs()` method tries to access the filesystem of the container in two
    ways. If the `volume` variable is not `None`, it iterates through each partition
    and, if that partition meets certain criteria, attempts to open it. If, however,
    the `volume` variable is `None`, it instead tries to directly call the `pytsk3.FS_Info()`
    method on the image handle, `img`. As we saw, this latter method will work and
    give us filesystem access for logical images, whereas the former works for physical
    images. Let's look at the differences between these two methods.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of the method, we create a `recursed_data` list to hold our active
    file metadata. In the first instance, where we have a physical image, we iterate
    through each partition and check whether it is greater than `2,048` sectors and
    does not contain the words `Unallocated`, `Extended`, or `Primary Table` in its
    description. For partitions meeting these criteria, we attempt to access their
    filesystem using the `FS_Info()` function by supplying the `pytsk3 img` object
    and the offset of the partition in bytes.
  prefs: []
  type: TYPE_NORMAL
- en: If we are able to access the filesystem, we use the `open_dir()` method to get
    the root directory and pass that, along with the partition address ID, the filesystem
    object, two empty lists, and an empty string, to the `recurse_files()` method.
    These empty lists and string will come into play in recursive calls to this function,
    as we will see shortly. Once the `recurse_files()` method returns, we append the
    active file metadata to the `recursed_data` list. We repeat this process for each
    partition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We employ a similar method for the second instance, where we have a logical
    image, where the volume is `None`. In this case, we attempt to directly access
    the filesystem and, if successful, we pass that to the `recurseFiles()` method
    and append the returned data to our `recursed_data` list. Once we have our active
    file list, we send it and the user-supplied output file path to the `csvWriter()`
    method. Let's dive into the `recurseFiles()` method, which is the meat of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `recurse_files()` function is based on an example of the *FLS* tool ([https://github.com/py4n6/pytsk/blob/master/examples/fls.py](https://github.com/py4n6/pytsk/blob/master/examples/fls.py))
    and David Cowen's tool DFIR Wizard ([https://github.com/dlcowen/dfirwizard/blob/master/dfirwizard-v9.py](https://github.com/dlcowen/dfirwizard/blob/master/dfirwizard-v9.py)).
    To start this function, we append the root directory `inode` to the `dirs` list.
    This list is used later to avoid unending loops. Next, we begin to loop through
    each object in the root directory and check whether it has certain attributes
    we would expect and that its name is not either `"**.**"` or `"**..**"`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If the object passes that test, we extract its name using the `info.name.name`
    attribute. Next, we use the `parent` variable, which was supplied as one of the
    function's inputs, to manually create the file path for this object. There is
    no built-in method or attribute to do this automatically for us.
  prefs: []
  type: TYPE_NORMAL
- en: We then check if the file is a directory or not and set the `f_type` variable
    to the appropriate type. If the object is a file, and it has an extension, we
    extract it and store it in the `file_ext` variable. If we encounter an `AttributeError`
    when attempting to extract this data, we continue onto the next object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the first recipe in this chapter, we create variables for the object
    size and timestamps. However, notice that we pass the dates to a `convert_time()`
    method. This function exists to convert the `Unix` timestamps into a human-readable
    format. With these attributes extracted, we append them to the data list using
    the partition address ID to ensure we keep track of which partition the object
    is from.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If the object is a directory, we need to recurse through it to access all of
    its subdirectories and files. To accomplish this, we append the directory name
    to the `parent` list. Then, we create a directory object using the `as_directory()`
    method. We use the `inode` here, which is for all intents and purposes a unique
    number, and check that the `inode` is not already in the `dirs` list. If that
    were the case, then we would not process this directory as it would have already
    been processed.
  prefs: []
  type: TYPE_NORMAL
- en: If the directory needs to be processed, we call the `recurse_files()` method
    on the new `sub_directory` and pass it current `dirs`, `data`, and `parent` variables.
    Once we have processed a given directory, we pop that directory from the `parent`
    list. Failing to do this will result in false file path details as all of the
    former directories will continue to be referenced in the path unless removed.
  prefs: []
  type: TYPE_NORMAL
- en: Most of this function was in a large `try-except` block. We pass on any `IOError`
    exception generated during this process. Once we have iterated through all of
    the subdirectories, we return the data list to the `open_fs()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s briefly look at the `convert_time()` function. We''ve seen this type
    of function before: if the `Unix` timestamp is not `0`, we use the `datetime.utcfromtimestamp()`
    method to convert the timestamp into a human-readable format.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: With the active file listing data in hand, we are now ready to write it to a
    CSV file using the `write_csv()` method. If we did find data (that is, the list
    is not empty), we open the output CSV file, write the headers, and loop through
    each list in the `data` variable. We use the `csvwriterows()` method to write
    each nested list structure to the CSV file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot demonstrates the type of data this recipe extracts
    from forensic images:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00092.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This script can be further improved. We have provided one or more recommendations
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `tqdm`, or another library, to create a progress bar to inform the user
    of the current execution progress
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about the additional metadata values that can be extracted from filesystem
    objects using `pytsk3` and add them to the output CSV file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing files within the container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recipe Difficulty: Medium'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python Version: 2.7'
  prefs: []
  type: TYPE_NORMAL
- en: 'Operating System: Linux'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can iterate through a filesystem, let's look at how we can create
    file objects as we have been accustomed to doing. In this recipe, we create a
    simple triage script that extracts files matching specified file extensions and
    copies them to an output directory while preserving their original file path.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to the *Getting started* section in the *Opening Acquisitions* recipe
    for information on the build environment and setup details for `pytsk3` and `pyewf`.
    All other libraries used in this script are present in Python's standard library.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will perform the following steps in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify if the evidence container is a `raw` image or an `E01` container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Access the image using `pytsk3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recurse through all directories in each partition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check if the file extension matches those supplied.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write responsive files with the preserved folder structure to the output directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We import a number of libraries to assist with argument parsing, creating CSV
    spreadsheets, and handling evidence containers and filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This recipe''s command-line handler takes four positional arguments: `EVIDENCE_FILE`,
    `TYPE`, `EXT`, and `OUTPUT_DIR`. These are the evidence file itself, the type
    of evidence file, a comma-delimited list of extensions to extract, and the desired
    output directory, respectively. We also have the optional `p` switch to manually
    specify the partition type.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Before calling the `main()` function, we create any necessary output directories
    and perform our standard input-validation steps. Once we have validated the input,
    we pass the supplied arguments onto the `main()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `main()` function, `EWFImgInfo` class, and the `open_fs()` function, have
    been covered in previous recipes. Recall that this chapter takes a more iterative
    approach to our recipes as we build upon the previous ones. Refer to those previous
    recipes for a more detailed description of each function and the `EWFImgInfo`
    class. Let's briefly show the two functions again so as to avoid jumping around
    logically.
  prefs: []
  type: TYPE_NORMAL
- en: In the `main()` function, we check whether the evidence file is a `raw` file
    or an `E01` file. Then, we perform the necessary steps to ultimately create a
    `pytsk3` handle on the evidence file. With this handle, we attempt to access the
    volume, using the manually supplied partition type if supplied. If we are able
    to open the volume, we pass `pytsk3` handle and volume to the `open_fs()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the `open_fs()` function, we use logic to support accessing the filesystem
    for both logical and physical acquisitions. For logical acquisitions, we can simply
    attempt to access the root of the filesystem on the `pytsk3` handle. On the other
    hand, for physical acquisitions, we must iterate through each partition and attempt
    to access the filesystem for those meeting certain criteria. Once we have access
    to the filesystem, we call the `recurse_files()` method to iterate through all
    of the files in the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Stop skimming here! The new logic for this recipe is contained in the `recurse_files()`
    method. This is sort of a blink-and-you'll-miss-it recipe. We've done the heavy
    lifting with the previous recipes, and we can now essentially treat these files
    like we would any other file with Python. Let's look at how this works.
  prefs: []
  type: TYPE_NORMAL
- en: Admittedly, the first part of this function is still the same as before, with
    one exception. On the first line of the function, we use list comprehension to
    split each comma-delimited extension supplied by the user and remove any white
    spaces and normalize the string to lowercase. As we iterate through each object,
    we check whether the object is a directory or a file. If it is a file, we separate
    and normalize the file's extension to lower case and store it in a `file_ext`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Next, we check if the extracted file's extension is in our user supplied list.
    If it is, we pass the file object itself and its name, extension, path, and the
    desired output directory to the `file_writer()` method to output. Notice that
    this operation, we have logic, discussed in the previous recipe, to recursively
    process any subdirectories to identify more potential files matching the extension
    criteria. So far, so good; let's now take a look at this last function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `file_writer()` method relies on the file object''s `read_random()` method
    to access the file content. Before we do that, however, we first set up the output
    path for the file by combining the user-supplied output with the extension and
    the path of the file. We then create these directories if they do not already
    exist. Next, we open the output file in `"w"` mode and are now ready to write
    the file''s content to the output file. As used here, the `read_random()` function
    takes two inputs: the byte offset within the file to start reading from and the
    number of bytes to read. In this case, since we want to read the entire file,
    we use the integer `0` as the first argument and the file''s size as the second
    argument.'
  prefs: []
  type: TYPE_NORMAL
- en: We supply this directly to the `write()` method, although note that going forward,
    if we were to perform any processing to this file, we could instead read it into
    a variable and work with the file from there. Also, note that for evidence containers
    with large files, this process of reading the entire file into memory may not
    be ideal. In that scenario, you would want to read and write to this file in chunks
    rather than all at once.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this script, we see responsive files based on the supplied extensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00093.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Additionally, we can review these files within the defined structure as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00094.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Searching for hashes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recipe Difficulty: Hard'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python Version: 2.7'
  prefs: []
  type: TYPE_NORMAL
- en: 'Operating System: Linux'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we create another triage script, this time focused on identifying
    files matching provided hash values. This script takes a text file containing
    `MD5`, `SHA-1`, or `SHA-256` hashes, separated by a newline, and searches for
    those hashes within the evidence container. With this recipe, we will be able
    to quickly process evidence files, locate files of interest, and alert the user
    by printing the file path to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to the *Getting started* section in the *Opening Acquisitions* recipe
    for information on the `build` environment and setup details for `pytsk3` and
    `pyewf`. All other libraries used in this script are present in Python's standard
    library.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We use the following methodology to accomplish our objective:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify if the evidence container is a `raw` image or an `E01` container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Access the image using `pytsk3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recurse through all directories in each partition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send each file to be hashed using the appropriate hashing algorithm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check if the hash matches one of those provided and if so, print to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We import a number of libraries to assist with argument parsing, creating CSV
    spreadsheets, hashing files, handling evidence containers and filesystems, and
    creating progress bars.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This recipe's command-line handler takes three positional arguments, `EVIDENCE_FILE`,
    `TYPE`, and `HASH_LIST`, which represent the evidence file, the type of evidence
    file, and the newline delimited list of hashes to search for, respectively. As
    always, the user can also manually supply the partition type using the `p` switch
    if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: After we parse the inputs, we perform our typical input-validation checks on
    both the evidence file and the hash list. If those pass, we call the `main()`
    function and supply it with the user-supplied inputs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As in the previous recipe, the `main()` function, `EWFImgInfo` class, and the
    `open_fs()` function are nearly identical to the previous recipes. For a more
    detailed explanation of these functions, refer to the previous recipes. One new
    addition to the `main()` function is the first line, where we call the `read_hashes()`
    method. This method reads the input hash list and returns a list of hashes and
    the type of hash (that is, `MD5`, `SHA-1`, or `SHA-256`).
  prefs: []
  type: TYPE_NORMAL
- en: Other than that, the `main()` function proceeds as we are accustomed to seeing
    it. First, it determines what type of evidence file it is working with in order
    to create a `pytsk3` handle on the image. Then, it uses that handle and attempts
    to access the image volume. Once this process has completed, the variables are
    sent to the `open_fs()` function for further processing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Let's quickly look at one of the new functions, the `read_hashes()` method.
    First, we instantiate the `hash_list` and `hash_type` variables as an empty list
    and `None` object, respectively. Next, we open and iterate through the input hash
    list and add each hash to our list. As we do this, if the `hash_type` variable
    is still `None`, we check the length of the line as a means of identifying the
    type of hash algorithm we should use.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this process, if for whatever reason the `hash_type` variable
    is still `None`, then the hash list must be made up of hashes we do not support,
    and so we exit the script after printing the error to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `open_fs()` method function is identical to that of previous recipes. It
    tries to use two different methods to access both physical and logical filesystems.
    Once successful, it passes these filesystems onto the `recurse_files()` method.
    As with the previous recipe, the magic happens within this function. We are also
    incorporating a progress bar with `tqdm` to provide feedback to the user, as it
    may take a while to hash all of the files within an image.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Within the `recurse_files()` method, we iterate through all subdirectories and
    hash each file. We skip the `.` and `..` directory entries and check that the
    `fs_object` has the correct properties. If so, we build the file path for use
    in our output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As we perform each iteration, we determine which objects are files versus directories.
    For each file discovered, we send it to the `hash_file()` method along with its
    path, the list of hashes, and the hash algorithm. The remainder of the `recurse_files()`
    function logic is specifically designed to handle directories and makes recursive
    calls to this function for any sub-directories to ensure the whole tree is walked
    and files are not missed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `hash_file()` method first checks which type of hash algorithm instance
    to create based on the `hash_type` variable. With that decided and an update of
    the file size to the progress bar, we read the file's data into the hash object
    using the `read_random()` method. Again, we read the entire file's contents by
    starting our read at the first byte and reading the entire file's size. We generate
    the hash of the file using the `hexdigest()` function on the hash object and then
    check whether that hash is in our list of supplied hashes. If it is, we alert
    the user by printing the file path, using `pbar.write()` to prevent progress bar
    display issues, and name to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'By running the script we are presented with a nice progress bar showing the
    hashing status and a list of files that match the list of provided hashes, as
    seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00095.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This script can be further improved. We have provided one or more recommendations
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Rather than printing matches, create a CSV of matching files with metadata for
    review
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add an optional switch to dump matching files to an output directory (with the
    folder path preserved)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
