- en: Chapter 4. Creating Accessible Experiences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing browser support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding skip navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding meta tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using semantic descriptions in tags for screen readers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing alternate site views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `hgroup` to create accessible header areas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying alternate content for non-supported browsers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using WAI-ARIA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Good accessibility design is good web design."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So far we have talked a lot about semantic web coding and the way HTML5 allows
    us to take this naming approach to a new level we have not previously been able
    to reach. Much of our discussion has centered on how semantic web coding makes
    our job as web developers easier, faster, and more meaningful.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will turn our attention to how semantic web coding can improve
    the online experiences our audiences have. Now, applying semantic tags — tags
    that are meaningful rather than just presentational — become even more important
    to screen readers and those who rely on them to navigate the websites and applications
    and interfaces we create.
  prefs: []
  type: TYPE_NORMAL
- en: If you have ever coded a website, application, or interface for the military,
    an academic institution, or just about anyone who gets money from the United States
    federal government, you have heard of Section 508.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike HTML or CSS validation, Section 508 validation works differently. In
    HTML or CSS, code is either valid or it is not. It is binary. Not so with Section
    508\. In this case, there are three different levels of validation, each ever
    more difficult to reach.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we will examine how to use HTML5 to test browser support, add
    skip navigation and meta tags, use semantic descriptions in tags for screen readers,
    provide alternate site views, use the new HTML5 `hgroup` element to create accessible
    header areas, display alternate content for non-supported browsers, and use WAI-ARIA.
  prefs: []
  type: TYPE_NORMAL
- en: Now. let's get cooking!
  prefs: []
  type: TYPE_NORMAL
- en: Testing browser support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by using the open source Modernizr project at: [http://modernizr.com](http://modernizr.com)
    created by developers Faruk Ates and Paul Irish. According to the website, Modernizr
    uses feature detection to test the current browser against upcoming features.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Modernizr concept aims at feature detection instead of browser detection.
    It is a subtle but important differentiation. Instead of making broad assumptions,
    the Modernizr approach detects features that browsers support.
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing browser support](img/1048_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Download the Modernizr JavaScript file and reference it in the `head` section
    of your markup. You will then add the class of "no-js" to your `body` element,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Including that script and simple body class in your markup enables Modernizr
    to detect which of the following items the web browser supports. It will then
    add classes and a JavaScript API to detect support for certain features. If the
    features aren't supported in the given browser, Modernizr simply won't add them.
  prefs: []
  type: TYPE_NORMAL
- en: '@font-face'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Canvas Text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML5 Audio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML5 Video
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: rgba()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: hsla()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'border-image:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'border-radius:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'box-shadow:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'text-shadow:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'opacity:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple backgrounds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flexible Box Model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSS Animations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSS Columns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSS Gradients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSS Reflections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSS 2d Transforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSS 3d Transforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSS Transitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Geolocation API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: localStorage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: sessionStorage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SVG
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SMIL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SVG Clipping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inline SVG
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drag-and-Drop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: hashchange
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: X-window Messaging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: History Management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: applicationCache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Touch events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web Sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web Workers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web SQL Database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebGL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IndexedDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input Types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input Attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'New in Modernizr 2 Beta is the ability to customize your JavaScript download.
    So now if you do not care about a particular feature (let''s say Drag and Drop),
    you can unclick it and not have Modernizr check for it. Read all about it at:
    [http://modernizr.github.com/Modernizr/2.0-beta](http://modernizr.github.com/Modernizr/2.0-beta).'
  prefs: []
  type: TYPE_NORMAL
- en: With an eye to the future
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From the website:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Modernizr is a small and simple JavaScript library that helps you take advantage
    of emerging web technologies (CSS3, HTML5) while still maintaining a fine level
    of control over older browsers that may not yet support these new technologies."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What Modernizr really does
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What Modernizr does not do is add or enable functionality that does not natively
    exist in browsers. If your browser doesn't support Input Attributes, for example,
    Modernizr does not somehow automatically add that ability to your browser. That
    is not possible. It simply lets you as the developer know with what you can work.
  prefs: []
  type: TYPE_NORMAL
- en: Do it for the right reasons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are some web developers using Modernizr because they read in an article
    somewhere that they were supposed to use it. That is fine, but you are smarter
    than they are. You see how detecting these abilities in the browser better informs
    you of how to serve accessible experiences if a browser does not natively support
    certain attributes. Clever and handsome you are!
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For further reading, author Gil Fink wrote the simple but concise ["Detecting](http://"Detecting)
    *HTML5 Features Using Modernizr"* article for Microsoft at [http://blogs.microsoft.co.il/blogs/gilf/archive/2011/01/09/detecting-html5-features-using-modernizr.aspx](http://blogs.microsoft.co.il/blogs/gilf/archive/2011/01/09/detecting-html5-features-using-modernizr.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: Adding skip navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to skip repeated elements like navigation is beneficial to those
    who use screen readers. Imagine when visiting a website, you read every single
    navigation element before you could proceed to the main content. That would be
    annoying, wouldn't it? Well, it can be for those using screen readers too. Let
    us take a look at an easy way to not annoy a part of our audience.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What we are going to do in this example is create a simple but special invisible
    anchor that will give our screen reader friends the option to skip over our navigation
    and get right to the good stuff: our site content.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have been around HTML for a while, you have no doubt created a skip
    navigation at some point. It probably looked something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Your CSS would include something like this to make the anchor invisible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The first `div` that contained your primary content then included another invisible
    anchor that looked something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: That was all well and good for years. It worked just fine. And it should work
    in HTML5 too, right? Well, guess what? It does not. Let us take a look at why.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In HTML5, the `name` attribute for anchor tags is no longer valid. Remember
    all that stuff I said in the first chapter about the approach to creating the
    HTML5 spec is to "pave the cowpaths?" Well, not this time. This time the cowpath
    has been removed. So here is what we are going to do about it for now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will keep the initial bit of markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And we will keep that bit of CSS that hides the anchor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'But here is what we are going to do differently with that second bit of markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When we removed the anchor, we renamed the `name` attribute it had from an `ID`
    and added it to the `h2` instead. Now it works and is valid in the HTML5 spec.
    Easy!
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ability to skip navigation is one of the most common — and easy to accomplish
    — things we developers can do to support our differently abled audiences. Consider
    revisiting old sites you have developed, updating (or adding) the skip navigation,
    switch the `DOCTYPE` to HTML5, and you are well on your way to using the latest
    technologies while still supporting accessibility.
  prefs: []
  type: TYPE_NORMAL
- en: Full browser support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Skip navigation is one change that is fortunately supported by all major web
    browsers. The author does not get to say that very often in a book like this,
    so this is quite a relief!
  prefs: []
  type: TYPE_NORMAL
- en: Less equals more
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the near future when screen readers are updated, instead of creating the
    ability to skip navigation via an explicit link, we will be able to use Web Accessibility
    Initiative-Accessible Rich Internet Applications roles and use the new `nav` element
    to achieve the same thing. Less markup equals more gooder!
  prefs: []
  type: TYPE_NORMAL
- en: The Web Standards Project site at [http://webstandards.org](http://webstandards.org)
    takes an interesting approach by only displaying the skip `nav` when the sighted
    user hovers over it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Less equals more](img/1048_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[http://html5accessibility.com](http://html5accessibility.com) is a terrific
    resource, providing information about which new HTML5 elements are accessibly
    supported in web browsers as well as for those who use assistive technologies.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding meta tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"A language tag identifies a natural language spoken, written, or otherwise
    conveyed by human beings for communication of information to other human beings.
    Computer languages are explicitly excluded. HTTP uses language tags within the
    Accept-Language and Content- Language fields." - World Wide Web Consortium''s
    Hypertext Transfer Protocol specification'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are thinking about accessibility for your or your client's website (and
    you should be!) you will want to ensure that those using a screen reader are able
    to have your information read to them in the language(s) you intended. We are
    going to take a look at how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, determine the language in which you want your website read. It could
    be English, French, Klingon, or any combination. See this list of the most popular
    content-languages: [http://devfiles.myopera.com/articles/554/httpheaders-contentlang-url.htm](http://devfiles.myopera.com/articles/554/httpheaders-contentlang-url.htm).'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We already have an English content-language meta tag in our common template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The simple `<html lang="en">` is all we need to ensure our site will be read
    in English. Changing that for other languages could not be simpler. Use `<html
    lang="fr">` for French and `<html lang="x-klingon">` if you are a huge Star Trek
    fan. Note, the `x- prefix` in the Klingon example indicates an experimental language.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You could also specify more than one language by using something like: `<html
    lang="en, fr">` for both English and French. Note the use of quotes around the
    values since we are referencing more than one.'
  prefs: []
  type: TYPE_NORMAL
- en: Whatchu talkin' 'bout?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note: "If no Content-Language is specified, the default is that the content
    is intended for all language audiences. This might mean that the sender does not
    consider it to be specific to any natural language, or that the sender does not
    know for which language it is intended." - World Wide Web Consortium''s Hypertext
    Transfer Protocol specification'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It all comes back to SEO
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Specifying a content-language is also beneficial to search engines and enables
    them to parse our content in the language we intend. And who among us couldn't
    use some more search-engine optimization?
  prefs: []
  type: TYPE_NORMAL
- en: Did I do that?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you do not specify a meta language, what is the worst that could happen?
    Nothing, right? Wrong. It turns out if we do not specify that meta language, old
    versions of our nemesis Internet Explorer will attempt to guess what language
    you intended. And as we have seen already, sometimes IE guesses wrong. According
    to this article, harmless user input can become active HTML and may execute, leading
    to security vulnerability: [http://code.google.com/p/doctype/wiki/ArticleUtf7](http://code.google.com/p/doctype/wiki/ArticleUtf7).'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[http://section508.gov](http://section508.gov) is the official website for
    the Section 508 specification of the U.S. Code. Though we web developers focus
    primarily on how Section 508 applies to the web, it is actually a much broader
    set of laws that define how those of us in the United States of America accommodate
    for those with different abilities both virtually and in the real world.'
  prefs: []
  type: TYPE_NORMAL
- en: Using semantic descriptions in tags for screen readers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The approach of semantic web development makes sense not just for those of us
    who develop websites and applications and interfaces, but also for those who use
    and interact with those experiences we create.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's review some of the new, more-semantic tags in the HTML5 specification.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'New HTML5 tags include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<article>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<aside>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<audio>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<canvas>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<datalist>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<details>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<embed>` - not a new tag, but it finally validates in HTML5'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<figcaption>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<figure>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<footer>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<header>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<hgroup>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<keygen>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<mark>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<meter>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<nav>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<output>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<progress>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<rp>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<rt>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<ruby>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<section>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<source>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<summary>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<time>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<video>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<wbr>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Of that list, the following new tags can support text:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<article>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<aside>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<datalist>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<details>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<figcaption>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<figure>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<footer>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<header>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<hgroup>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<keygen>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<mark>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<nav>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<output>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<section>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<source>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<summary>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<time>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<wbr>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That list represents the vast majority of new HTML5 tags available. The simple
    act of using these more semantic tags will add additional meaning and intelligence
    to screen readers.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following new tags also present us with the opportunity to create richer
    and more semantically meaningful experiences:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<audio>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<embed>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<progress>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<video>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always improve
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Survey the projects you have already launched that had accessibility requirements.
    If you are still able to update them, this is a golden opportunity to revisit
    them to add more semantically meaningful markup. Remember: Just because a site
    or application or interface is already launched does not mean you cannot revisit
    it later. If a project was a dud when it launched, this is the perfect time to
    update it and then relaunch it. Who knows? It might turn into that perfect portfolio
    piece that could land you another job! Score!'
  prefs: []
  type: TYPE_NORMAL
- en: Semantics for good SEO
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using increasingly more semantic and meaningful tags can have a benefit not
    just to those using screen readers, but also to search engine optimization because
    search engines will be able to more intelligently parse and understand your code.
  prefs: []
  type: TYPE_NORMAL
- en: Greg finally learned
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Semantic web development also has a benefit to other developers. If you code
    an area with a `<nav>` tag, another developer currently on your team or working
    on your project in the future will instantly understand what your intention is.
    The author once worked with a developer who used nonsensical naming like `<div
    id="banana">` for something that had nothing to do with bananas. That developer
    thought it was a kind of job security by being the only one to know what certain
    tags meant. Unfortunately that approach became painful for him years later when
    editing something he had previously created, and he could not remember the meaning
    of it. The lesson? Do not tick your future self off!
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[http://caniuse.com](http://caniuse.com) provides compatibility tables for
    HTML5, CSS3, SVG and more in both desktop and mobile browsers. The site is an
    invaluable aid for understanding which of the new tags can be supported. It is
    constantly updated and worth not only bookmarking but referring to over and over
    again.'
  prefs: []
  type: TYPE_NORMAL
- en: Providing alternate site views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cambridge, Massachusetts-based website developer Ethan Marcotte created an approach
    he refers to as "responsive web design" to support desktop computers with different
    sized displays as well as mobile devices — all with one code base. Though this
    approach is not required, it can be viewed as another step toward creating accessible
    experiences. Let's take a closer look at his approach.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Marcotte published the article in the May 25, 2010 issue of A List Apart at:
    [http://alistapart.com/articles/responsive-web-design](http://alistapart.com/articles/responsive-web-design).
    Reading the article will give you a head start toward understanding the rest of
    this section.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take a close look at Jon Hicks' portfolio at [http://hicksdesign.co.uk](http://hicksdesign.co.uk)
    for a spectacular example of Marcotte's approach at work.
  prefs: []
  type: TYPE_NORMAL
- en: Hicks' portfolio seen at full width on a 27" monitor.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/1048_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Resizing the window causes the site to collapse from four to three columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/1048_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Resizing the window further causes the site to collapse from three to two columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/1048_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Resizing the window even further causes the site to collapse from two to one
    column:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/1048_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By using a flexible grid as well as `min-width` and `max-width` values in his
    stylesheet, Hicks creates an experience that adjusts to different display sizes
    with ease. Let's take a look at how it is done.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This new way of flexible front-end web development allows us to create experiences
    that work despite the device resolution. Thanks to Marcotte, we are no longer
    forced to create separate experiences for every device. Current status: Code once,
    display everywhere.'
  prefs: []
  type: TYPE_NORMAL
- en: We start with a fluid grid with columns that can adapt to whatever screen space
    is available, flexible images, and letting media queries serve up unique stylesheets
    depending on the resolution and viewport.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a sample media query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can easily see we are saying that when the device has a maximum width of
    600 pixels, we are telling the `body` to display fonts at 80% of their height.
    We also specify the content-main `div` will be a single column with 100% width.
    If the device's maximum width is 601 pixels or more, these rules will be ignored.
    Note that since this media query specifies the screen, if the user prints the
    page, these rules will be ignored also.
  prefs: []
  type: TYPE_NORMAL
- en: Min-width
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you can imagine, if we are able to specify styles for narrow widths like
    this, you can also specify other styles for much wider widths, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Notice we are still targeting the screen in our media query, but now we are
    saying to apply some styles only if the viewport is *larger* than 1024 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: My math teacher was right
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Those who are used to working with a rigid, fixed grid layout system like Grid960
    may find using a flexible grid a mental challenge at first. As Marcotte explains:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Every aspect of the grid — and the elements laid upon it — can be expressed
    as a proportion relative to its container."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We can convert our pixel-based widths into percentages in order to keep our
    proportions intact no matter the size displayed. Let us start with an easy example:
    Let us say our `header` is 600 pixels wide and we want to display it on a device
    that is 1200 pixels wide. If the equation is target ÷ context = result, then 600
    ÷ 1200 = .5\. Our CSS would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'That was easy. But what if you want to display a different `header` at 510
    pixels wide in a 960 pixel width? Simple division leaves us with this: 510 ÷ 960
    = .53125\. We can adjust our CSS this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Repeat this process by defining each of your widths as a part of the overall
    whole and you will be well on your way toward a responsive display for many devices.
  prefs: []
  type: TYPE_NORMAL
- en: Is bigger always better?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Fluid images are even easier because there is no math to do. Instead, simply
    include:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: in your stylesheet and those images will never escape the width of your display
    or device.
  prefs: []
  type: TYPE_NORMAL
- en: Putting these three techniques together can create a virtually seamless site
    experience for users on multiple platforms, browsers, and even screen readers.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In 2011, Marcotte published the authoritative book on the subject of Responsive
    Web Design at [http://books.alistapart.com/products/responsive-web-design](http://books.alistapart.com/products/responsive-web-design).
  prefs: []
  type: TYPE_NORMAL
- en: Using hgroup to create accessible header areas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember `hgroups?` Sure you do. We looked at those in a previous chapter as
    a way to group related heading tags logically. Now, we will look at how that new
    HTML5 element can have added accessibility benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Previously, we looked at Roxane''s portfolio as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the past, we might have coded the body area of her site this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To a screen reader, the outdated second example is semantically meaningless.
    It does not know that those heading tags are related in any way other than being
    in the same `div`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, thanks to the WHATWG's HTML5 Draft Standard at [http://whatwg.org/html5](http://whatwg.org/html5)
    we — and screen readers — understand that the `hgroup` is a grouping of related
    headings. So what, you ask? If you could not rely on sight to know those headings
    were related, wouldn't you want some other mechanism — like a screen reader —
    to let you know they are?
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[http://diveintoaccessibility.org](http://diveintoaccessibility.org) is terrific
    30-day step-by-step resource to learning more about Section 508 and accessibility
    standards. Author Mark Pilgrim (also author of *Dive Into HTML5* at [http://diveintohtml5.org)](http://diveintohtml5.org))
    provides easy to understand tips by person, disability, design principle, web
    browser, and publishing tool. The site is a few years old, but because accessibility
    standards have not changed that much over the years, it is still an invaluable
    free resource.'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying alternate content for non-supported browsers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of the new HTML5 elements are so new that not all desktop browsers support
    them yet. So how can we assume all screen readers will support them?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Fortunately we can rest assured that screen readers will support common text
    tags such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<h1>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<h2>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<h3>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<h4>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<h5>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<h6>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<p>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<ul>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<ol>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<li>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<dl>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<dt>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<dd>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'and more as intended. But what about those new HTML5 elements such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<article>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<aside>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<audio>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<canvas>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<datalist>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<details>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<figcaption>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<figure>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<footer>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<header>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<hgroup>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<mark>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<meter>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<nav>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<output>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<progress>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<section>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<summary>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<time>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<video>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are those going to convey the meaning to the user as we intend? If so, terrific.
    But if not, what information does the user get? Is it meaningful at all? Certainly
    we would agree the last thing we would want is to provide less meaning through
    our new tags. Even the blind could see that would be an epic fail.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the time of this writing, many HTML5 elements provide at least the same
    amount of semantic information as a `div` to a screen reader. Let us look at each
    new element more specifically:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<article>` - same semantic information as a `div`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<aside>` - same semantic information as a `div`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<details>` - same semantic information as a `div`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<figcaption>` - same semantic information as a `div`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<figure>` - same semantic information as a `div`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<footer>` - same semantic information as a `div`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<header>` - same semantic information as a `div`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<hgroup>` - same semantic information as a `div`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<meter>` - same semantic information as a `div`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<nav>` - same semantic information as a `div`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<output>` - same semantic information as a `div`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<progress>` - same semantic information as a `div`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<section>` - same semantic information as a `div`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<summary>` - same semantic information as a `div`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For other new HTML5 elements however, their meaning is not so clear to a screen
    reader:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<audio>` - semantic information seems consistent but Firefox has a problem
    with built-in slider controls, Internet Explorer 9 has only partial play/pause
    support, and Opera has good keyboard support but no actual assistive technology
    support.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<canvas>` - provides virtually no usable semantic information to assistive
    technologies. Extreme caution must be used by anyone relying on the new HTML `<canvas>`
    element to convey information. Using it intentionally leaves members of the audience
    at the door, unable to get in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<datalist>` - keyboard accessible only in Opera.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<mark>` - provides no additional semantic information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<time>` - buggy keyboard accessibility only in Opera.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<video>` - semantic information seems consistent, but Firefox has a problem
    with built-in slider controls, Internet Explorer 9 has only partial play/pause
    support, and Opera has good keyboard support but no actual assistive technology
    support.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For now, until screen readers can catch up to all the new HTML5 elements, care
    must be taken when deciding which of these new tags we intend to use and what
    meaning we intend to convey with them to those using assistive technologies.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Emily Lewis is excited not just about HTML and CSS, but usability, semantics,
    and accessibility too. She is the kind of passionate advocate we need more of
    for the front-end web development world to thrive. See her excellent "Web Accessibility
    and WAI-ARIA Primer" for information on how to get started thinking about the
    future of accessibility at [http://msdn.microsoft.com/en-us/scriptjunkie/ff743762.aspx](http://msdn.microsoft.com/en-us/scriptjunkie/ff743762.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: Using WAI-ARIA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Through the use of technology, we have developed methods to update information
    in the browser window dynamically without manually refreshing the page from the
    server. For a person gifted with sight, this a boon, retrieving information quicker
    and in a more useful way. But what happens when a person cannot see? How will
    they know information on the page has been updated in any way without refreshing
    the page, redisplaying its contents, and having the assistive technology read
    it to them again in its entirety?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Accessible Rich Internet Applications (WAI-ARIA) is an emerging technical specification
    that, like many of HTML5's new semantic tags, forces us to really think about
    our content and how we want to present it to our audiences. We can use WAI-ARIA
    to define roles, properties, and states to help us define what our elements are
    supposed to do.
  prefs: []
  type: TYPE_NORMAL
- en: The WAI-ARIA Overview at [http://w3.org/WAI/intro/aria](http://w3.org/WAI/intro/aria),
    based on Marcotte's Responsive Web Design approach.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/1048_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Remember how we included the new HTML5 `nav` element on Roxane''s portfolio?
    Here is how we can use WAI-ARIA to add additional meaning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Because not every browser understands the `nav` tag, not every browser will
    understand its role either. WAI-ARIA provides us with the method to do so. That
    `role="navigation"` is named a "landmark role", and does for a non-sighted person
    what an actual landmark does for a sighted person in the real world: It lets them
    know where they are.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, even those without site can be made aware when something on the page changes
    via these landmark roles. WAI-ARIA informs the user of those dynamic page changes
    by "watching" for updates. Instead of re-reading the entire screen, only the new
    information is presented.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WAI-ARIA allows us to create the complex, data-driven objects like pulldown
    menus, tabs, sliders, file trees, and more that sighted users have become used
    to over the years and ensure through the use of these roles that even those who
    cannot see the content as it updates will be notified that it has done so.
  prefs: []
  type: TYPE_NORMAL
- en: Still awaiting browser support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is always a catch, right? The catch in this case is that, like many of
    the other HTML5 features described in this book, WAI-ARIA is not fully supported
    by all assistive-technology browsers. No matter how diligent and well-meaning
    we as developers are, if members of our target audience do not have the latest
    browsers with WAI-ARIA support, they will not receive the information we desire
    them to have.
  prefs: []
  type: TYPE_NORMAL
- en: That's how I role
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is another catch: Using WAI-ARIA incorrectly can actually make the situation
    worse. If a lesser developer than you assigned `role="navigation"` to some content
    that was frequently updated but gave the user the ability to skip the navigation,
    that user would never know information was being updated. Luckily that would probably
    never happen to you because you would have caught that mistake in a peer code
    review. With great power comes great responsibility.'
  prefs: []
  type: TYPE_NORMAL
- en: Accessibility first
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have a website under development and you have to support differently
    abled people, great care must be taken from the initial kickoff meeting to ensure
    their needs are being met. The most accessibly successful projects are ones that
    take people's needs into consideration from the outset. Trying to glom a set of
    features on at the end is just another way of setting yourself — and your project
    — up to fail. We either set people and projects up to succeed, or we set them
    up to fail. Which will you do?
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For further reading on how to use WAI-ARIA to build a more accessible web,
    see this excellent WebMonkey article by Scott Gilbertson: [http://webmonkey.com/2010/11/can-wai-aria-build-a-more-accessible-web](http://webmonkey.com/2010/11/can-wai-aria-build-a-more-accessible-web).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Gilbertson was on a roll by later penning a terrific resource for styling websites
    using the ARIA roles at: [http://webmonkey.com/2011/01/styling-webpages-with-arias-landmark-roles](http://webmonkey.com/2011/01/styling-webpages-with-arias-landmark-roles).'
  prefs: []
  type: TYPE_NORMAL
