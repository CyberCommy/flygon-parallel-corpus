- en: Performance Tuning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: The explain plan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benchmarking queries and the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding indexes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invisible index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Descending index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing slow queries using pt-query-digest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing datatypes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing duplicate and redundant indexes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking index usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling the query optimizer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using index hints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indexing for JSON using generated columns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using resource groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using performance_schema
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the sys schema
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will take you through query and schema tuning. The database is
    meant for the execution of queries; making it run faster is the end goal of tuning.
    The database's performance depends on many factors, mainly queries, schema, configuration
    settings, and hardware.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to take the employees database to explain all
    the examples. You might have transformed the employees database in many ways in
    the preceding chapters. It is recommended to load the sample employees data again
    before trying the examples mentioned in this chapter. You can refer to *Section
    Loading sample data in Chapter 2* to know how to load sample data.
  prefs: []
  type: TYPE_NORMAL
- en: The explain plan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How MySQL executes queries is one of the major factors of database performance.
    You can verify the MySQL execution plan using the `EXPLAIN` command. Starting
    from MySQL 5.7.2, you can use `EXPLAIN` to examine queries currently executing
    in other sessions. `EXPLAIN FORMAT=JSON` gives detailed information.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's get into the details.
  prefs: []
  type: TYPE_NORMAL
- en: Using EXPLAIN
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The explain plan gives information on how the optimizer is going to execute
    the query. You just need to prefix the `EXPLAIN` keyword to the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Using EXPLAIN JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the explain plan in JSON format gives complete information about the
    query execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Using EXPLAIN for connection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can run the explain plan for an already-running session. You need to specify
    the connection ID:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get connection ID, execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If the connection is not running any `SELECT`/`UPDATE`/`INSERT`/`DELETE`/`REPLACE`
    queries, it will throw an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Refer to [https://dev.mysql.com/doc/refman/8.0/en/explain-output.html](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html)
    to learn more about the explain plan format. The JSON format is very clearly explained
    at [https://www.percona.com/blog/category/explain-2/explain-formatjson-is-cool/](https://www.percona.com/blog/category/explain-2/explain-formatjson-is-cool/).
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarking queries and the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose you want to find out which of the queries is faster. The explain plan
    gives you an idea, but sometimes you cannot decide based on it. You can execute
    them on the server and find which one is faster if the query time is in the order
    of tens of seconds. However, if the query time is in the order of a few milliseconds,
    you cannot decide based on a single execution.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `mysqlslap` utility (it comes along with MySQL-client installation),
    which emulates client load for a MySQL server and reports the timing of each stage.
    It works as if multiple clients are accessing the server. In this section, you
    will learn about the usage of `mysqlslap`; in later sections, you will learn about
    the power of the `mysqlslap`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Suppose you want to measure the query time of a query; if you execute that
    in the MySQL client, you can know the approximate execution time with a granularity
    of 100 milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can emulate the client load using `mysqlslap` and run the preceding SQL
    concurrently over multiple iterations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding query was executed with 1,000 concurrencies and 100 iterations,
    and on average, it took 3.216 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can specify multiple SQLs in a file and specify the delimiter. `mysqlslap`
    runs all the queries in the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even autogenerate the table and SQL statements. In this way, you can
    compare the results with earlier server settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can also use `performance_schema` for all query-related metrics, which is
    explained in the *Using performance_schema* section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Without an index, MySQL must scan the entire table row by row to find the relevant
    rows. If the table has an index on the columns that you are filtering for, MySQL
    can quickly find the rows in the big data file without scanning the whole file.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL can use an index for filtering of rows in `WHERE`, `ORDER BY`, and `GROUP
    BY` clauses, and also for joining tables. If there are multiple indexes on a column,
    MySQL chooses the index that gives maximum filtering of rows.
  prefs: []
  type: TYPE_NORMAL
- en: You can execute the `ALTER TABLE` command to add or drop the index. Both index
    addition and dropping are online operations and do not hinder the DMLs on the
    table, but they take lot of time on larger tables.
  prefs: []
  type: TYPE_NORMAL
- en: Primary key (clustered index) and secondary indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you proceed further, it is important to understand what a primary key
    (or clustered index) is, and what a secondary index is.
  prefs: []
  type: TYPE_NORMAL
- en: '`InnoDB` stores rows in a primary key in order to speed up queries and sorts
    involving the primary key columns. This is also called an **index-organized table**,
    in Oracle terms. All other indexes are referred to as secondary keys, which store
    the value of primary keys (they do not refer to the row directly).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose the table is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The table rows are sorted and stored based on the value of `col1`. If you search
    for any value of `col1`, it can directly point to the physical row; this is why
    a clustered index is lightning-fast. The index on `col2` also contains the value
    of `col1`, and if you search for `col2`, the value of `col1` is returned, which
    in turn is searched in the clustered index to return the actual row.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tips on choosing the primary key:'
  prefs: []
  type: TYPE_NORMAL
- en: It should be `UNIQUE` and `NOT NULL`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose the smallest possible key because all the secondary indexes store the
    primary key. So if it is large, the overall index size uses more space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose a monotonically increasing value. The physical rows are ordered based
    on the primary key. So if you choose a random key, more rearrangement of rows
    is needed, which leads to degraded performance. `AUTO_INCREMENT` is a perfect
    fit for primary key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always choose a primary key; if you cannot find any, add an `AUTO_INCREMENT`
    column. If you do not choose any, `InnoDB` internally generates a hidden clustered
    index with a 6-byte row ID.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can see the indexes of a table by viewing its definition. You will notice
    that there is an index on `first_name` and `last_name`. If you filter the rows
    by specifying `first_name` or by both (`first_name` and `last_name`), MySQL can
    use the index to speed up the query. However, if you specify only `last_name`,
    the index cannot be used; this is because the optimizer can only use any of the
    leftmost prefixes of the index. Refer to [https://dev.mysql.com/doc/refman/8.0/en/multiple-column-indexes.html](https://dev.mysql.com/doc/refman/8.0/en/multiple-column-indexes.html)
    for more detailed examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Add index
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can add an index by executing the `ALTER TABLE ADD INDEX` command. For
    example, if you want to add an index on `last_name`, see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can specify the name of the index; if not, the leftmost prefix will be used
    as the name. If there are any duplicates, the name will be appended by `_2`, `_3`,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: UNIQUE index
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want the index to be unique, you can specify the keyword `UNIQUE`. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Prefix index
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For string columns, indexes that use only the leading part of column values,
    rather than the full column, can be created. You need to specify the length of
    the leading part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The maximum length of `last_name` is `16` characters, but the index is created
    only on the first 10 characters.
  prefs: []
  type: TYPE_NORMAL
- en: Drop index
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can drop an index using the `ALTER TABLE` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Index on generated columns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An index cannot be used on a column wrapped in a function. Suppose you add
    an index on `hire_date`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The index on `hire_date` can be used for queries having `hire_date` in the
    `WHERE` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, if you put `hire_date` inside a function, MySQL has to scan the full
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'So try to avoid putting an indexed column inside a function. If you cannot
    avoid using a function, create a virtual column and add an index on the virtual
    column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, instead of using the `YEAR()` function in the query, you can directly
    use `hire_date_year` in the `WHERE` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that even if you use `YEAR(hire_date)`, the optimizer recognizes that
    the expression `YEAR()` matches the definition of `hire_date_year` and that `hire_date_year`
    is indexed; so it considers that index during execution plan construction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Invisible index
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to drop an unused index, then instead of dropping immediately, you
    can mark it as invisible, monitor the application behavior, and later drop it.
    Later, if you need that index, you can mark it as visible, which is very fast
    compared to dropping and re-adding indexes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To explain the invisible index, you need to add normal index if not already
    there. Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you wish to drop the index on `last_name`, rather than directly dropping,
    you can mark it as invisible using the `ALTER TABLE` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice that the query filtering through `last_name` is using the `last_name`
    index; after marking it as invisible, it is not able to use. You can mark it as
    visible again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Descending index
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prior to MySQL 8, an index definition could contain the order (ascending or
    descending), but it was only parsed and not implemented. The index values were
    always stored in ascending order. MySQL 8.0 introduced support for descending
    indexes. Thus, the specified order in the index definition is not ignored. A descending
    index actually stores key values in descending order. Remember that scanning an
    ascending index in reverse is not efficient for a descending query.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a case where, in a multi-column index, you can specify certain columns
    to be descending. This can help for queries wherein we have both ascending and
    descending `ORDER BY` clauses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you want to sort the `employees` table with `first_name` ascending
    and `last_name` descending; MySQL cannot use the index on `first_name` and `last_name`.
    Without a descending index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the explain plan, you will notice that the index name (`first_name` and
    `last_name`) is not used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add a descending index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding the descending index, the query is able to use the index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The same index can be used for the other way of ordering, that is, ordering
    by `first_name` descending and `last_name` ascending through the backward index
    scan:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Analyzing slow queries using pt-query-digest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`pt-query-digest`, which is part of the Percona Toolkit, is used for analyzing
    queries. The queries can be collected through any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Slow query log
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: General query log
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary log
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TCP dump
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installation of the Percona Toolkit is covered in [Chapter 10](part0337.html#A1CDI0-faa69fe6f4c04957afca3568dcd9cd83), *Table
    Maintenance*, *Installing Percona Toolkit* section. In this section, you will
    learn how to use `pt-query-digest`. There are drawbacks for each method. The slow
    query log does not include all queries unless you specify `long_query_time` as `0`,
    which drastically slows down a system. The general query log does not include
    query time. You cannot get complete queries from the process list. Only writes
    can be analyzed using binary log and using TCP dump causes server degradation.
    Usually, this tool is used on the slow query log with a `long_query_time` of 1
    second or higher.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's get into the details of analyzing slow queries using `pt-query-digest`.
  prefs: []
  type: TYPE_NORMAL
- en: Slow query log
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enabling and configuring the slow query log is explained in [Chapter 12](part0417.html#CDLQI0-faa69fe6f4c04957afca3568dcd9cd83),
    *Managing Logs*, *Managing the general query log and slow query log*. Once the
    slow query log is enabled and queries are collected, you can run `pt-query-digest`
    by passing the slow query log.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose the slow query file is at `/var/lib/mysql/mysql-slow.log`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The digest report contains queries ranked by the number of query executions
    multiplied by the query time. Query details such as the query checksum (a unique
    value for each type of query), average time, percentage time, and number of executions
    are shown for all queries in the summary. You can drill down to the specific query
    by searching for the query checksum.
  prefs: []
  type: TYPE_NORMAL
- en: 'The digest report looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The query profile will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding output, you can infer that for query `#1` (`0x55F499860A034BCB`),
    the cumulative response time for all executions is `76560` seconds. This accounts
    for 42.7% of the cumulative response time of all queries. The number of executions
    is 47 and the average query time is `1628` seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can go to any query by searching for the checksum. The complete query,
    commands for the explain plan, and the table status are displayed. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: General query log
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use `pt-query-digest` to analyze the general query log by passing the
    argument `--type genlog`. Since general logs do not report query times, only the
    count aggregate is shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The query profile will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Process list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Instead of a log file, you can use `pt-query-digest` to read queries from the
    process list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`run-time` specifies how long each iteration should run. In the preceding example,
    the tool generates reports every minute for 10 minutes.'
  prefs: []
  type: TYPE_NORMAL
- en: Binary log
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To analyze the binary log using `pt-query-digest`, you should convert it to
    text format using the `mysqlbinlog` utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: TCP dump
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can capture TCP traffic using the `tcpdump` command and send it to `pt-query-digest`
    for analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: There are plenty of options available in `pt-query-digest`, such as filtering
    queries for a specific time window, filtering a specific query, and generating
    reports. Please refer to the Percona documentation at [https://www.percona.com/doc/percona-toolkit/LATEST/pt-query-digest.html](https://www.percona.com/doc/percona-toolkit/LATEST/pt-query-digest.html) for more
    details.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to [https://engineering.linkedin.com/blog/2017/09/query-analyzer--a-tool-for-analyzing-mysql-queries-without-overh](https://engineering.linkedin.com/blog/2017/09/query-analyzer--a-tool-for-analyzing-mysql-queries-without-overh)
    to know more about the new way of analyzing all queries without any overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing datatypes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should define tables such that they occupy minimum space on disk while accommodating
    all possible values.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the size is smaller:'
  prefs: []
  type: TYPE_NORMAL
- en: Less data is written to or read from the disk, which makes queries faster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The contents on the disk are loaded to the main memory while processing queries.
    So, smaller tables occupy less space in the main memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Less space is occupied by indexes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to store an employee number, for which the maximum possible value
    is 500,000, the optimum datatype is `MEDIUMINT UNSIGNED` (which occupies 3 bytes).
    If you are storing it as `INT`, which occupies 4 bytes, you are wasting a byte
    for each row.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you want to store the first name, for which the length is varying and the
    maximum possible value is 20, it is optimal to declare it as `varchar(20)`. If
    you are storing it as `char(20)`, and just a few names are 20 characters long
    while the remaining are less than 10 characters long, you are wasting space of
    10 characters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While declaring `varchar` columns, you should consider the length. Though `varchar`
    is optimized on-disk, while loading into memory, it occupies the full length.
    For example, if you store `first_name` in `varchar(255)` and the actual length
    is 10, on the disk it occupies 10 + 1 (an additional byte for storing length);
    but in the memory, it occupies the full length of 255 bytes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the length of the `varchar` column is more than 255 chars, it requires 2
    bytes to store the length.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare the columns as `NOT NULL` if you are not storing null values. This
    avoids the overhead for testing whether each value is null and also saves some
    storage space: 1 bit per column.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the length is fixed, use `char` instead of `varchar`, because `varchar` takes
    a byte or two to store the length of the string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the values are fixed, use `ENUM` rather than `varchar`. For example, if you
    want to store values that can be pending, approved, rejected, deployed, undeployed,
    failed, or deleted, you can use `ENUM`. It takes 1 or 2 bytes, rather than `char(10)`,
    which occupies 10 bytes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prefer integers over strings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to leverage the prefix index.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to leverage the `InnoDB` compression.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refer to [https://dev.mysql.com/doc/refman/8.0/en/storage-requirements.html](https://dev.mysql.com/doc/refman/8.0/en/storage-requirements.html)
    to know more about the storage requirements of each datatype and [https://dev.mysql.com/doc/refman/8.0/en/integer-types.html](https://dev.mysql.com/doc/refman/8.0/en/integer-types.html)
    to know about the range of each integer type.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to know the optimized datatype, you can use the function `PROCEDURE
    ANALYZE`. Though it is not accurate, it gives a fair idea of the fields. Unfortunately,
    it is deprecated in MySQL 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Removing duplicate and redundant indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can define several indexes on a column. By mistake, you might have defined
    the same index again (same column, same order of columns, or same order of keys),
    which is called a **duplicate index**. If only partial indexes (leftmost columns)
    are repetitive, they are called **redundant indexes**. A duplicate index has no
    advantages. Redundant indexes might be useful in some cases (a use case is mentioned
    in the note at the end of this section), but both slow down the inserts. So, it
    is important to identify and remove them.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three tools that can help with finding out duplicate indexes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pt-duplicate-key-checker`, which is part of the Percona Toolkit. Installing
    the Percona Toolkit is covered in [Chapter 10](part0337.html#A1CDI0-faa69fe6f4c04957afca3568dcd9cd83), *Table
    Maintenance*, *Installing Percona Toolkit* section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mysqlindexcheck`, which is part of MySQL utilities. Installing MySQL utilities
    is covered in [Chapter 1](part0025.html#NQU20-faa69fe6f4c04957afca3568dcd9cd83),
    *MySQL 8.0 – Installing and Upgrading*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `sys` schema, which will be covered in the next section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following `employees` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The index `full_name_1` is the duplicate of `full_name` because both indexes
    are on the same columns, the same order of columns, and the same order of keys
    (ascending or descending).
  prefs: []
  type: TYPE_NORMAL
- en: The index `first_name` is a redundant index because the column `first_name`
    is already covered in the leftmost suffix of the `first_name` index.
  prefs: []
  type: TYPE_NORMAL
- en: 'The index `first_name_emp_no` is a redundant index because it contains the
    primary key in the rightmost suffix. The `InnoDB` secondary indexes already contain
    the primary key, so it is redundant to declare the primary key as part of the
    secondary index. However, it can be useful in queries that filter by `first_name`
    and sort by `emp_no`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `full_name_desc` option is not a duplicate of `full_name` because the ordering
    of keys is different.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's get into the details of removing duplicate and redundant indexes.
  prefs: []
  type: TYPE_NORMAL
- en: pt-duplicate-key-checker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`pt-duplicate-key-checker` gives the exact `ALTER` statements to drop duplicate
    keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The tool suggests that you shorten the duplicate clustered index by removing
    the `PRIMARY KEY` from the rightmost suffix. Note that it may result in another
    duplicate index. If you wish to ignore the duplicate clustered indexes, you can
    pass the `--noclustered` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check the duplicate indexes of a particular database, you can pass the `--databases
    <database name>` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'To drop the keys, you can even pipe the output of `pt-duplicate-key-checker`
    to `mysql`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: mysqlindexcheck
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Note that `mysqlindexcheck` ignores descending indexes. For example, `full_name_desc`
    (`first_name` descending and `last_name`) is treated as a duplicate index of `full_name`
    (`first_name` and `last_name`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned earlier, redundant indexes can be useful in some cases. You have
    to consider whether these kinds of cases are needed by your application.
  prefs: []
  type: TYPE_NORMAL
- en: Create indexes to understand the following examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following `employees` and `salaries` tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'It seems like `from_date` is a redundant index of `from_date_2`, but check
    the explain plan of the following query! It is using an intersection of both the
    indexes. The `from_date` index is used for filtering and `from_date_2` is used
    for joining with the `employees` table. The optimizer is scanning only one row
    in each table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now drop the redundant index `from_date` and check the explain plan. You can
    see that the optimizer is scanning 90 rows in the `salaries` table and one row
    in the `employees` table. But look at the `ref` column; it shows that constants
    are compared to the index named in the `key` column (`from_date_2`) to select
    rows from the table. Rather than dropping the indexes, you can test this behavior
    by passing optimizer hints or index hints, which are covered in the next section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you need to determine which of the queries is faster:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Plan 1**: Using `intersect(from_date, from_date_2)`; scanning one row with
    ref as null'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Plan 2**: Using `from_date_2`; scanning 90 rows with ref as constant'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use the `mysqlslap` utility to find that (do not run this directly on
    the production host) and make sure that the concurrency is less than `max_connections`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The benchmark for plan 1 is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The benchmark for plan 2 is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: It turns out that the average query time for plan 1 and plan 2 are 0.466 seconds
    and 0.435 seconds, respectively. Since the results are very close, you can take
    a call and drop the redundant index. Use plan 2.
  prefs: []
  type: TYPE_NORMAL
- en: This is just an example that will enable you to learn and apply the concept
    in your application scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Checking index usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding section, you learned about removing redundant and duplicate
    indexes. While designing an application, you might have thought about filtering
    a query based on a column and added index. But over a period of time, because
    of changes in the application, you might not need that index. In this section,
    you will learn about identifying those unused indexes.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways you can find unused indexes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `pt-index-usage` (covered in this section)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `sys` schema (covered in the next section)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use the `pt-index-usage` tool from the Percona Toolkit to get the index
    analysis. It takes queries from the slow query log, runs the explain plan for
    each and every query, and identifies the unused indexes. If you have a list of
    queries, you can save them in slow query format and pass that to the tool. Note
    that this is only an approximation because the slow query log does not include
    all the queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Controlling the query optimizer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The task of the query optimizer is to find an optimal plan for executing a SQL
    query. There can be multiple plans to execute a query, especially when joining
    a table, where the number of plans to be examined increases exponentially. In
    this section, you will learn about adjusting the optimizer to your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Take the example of the `employees` table and add the necessary index;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose you want to check whether any of `first_name` or `last_name` is `Adam`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The explain plan is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice that there are many options available for the optimizer to
    fulfill the query. It can use any of the indexes listed in `possible_keys: (full_name,full_name_desc,first_name,full_name_1,first_name_emp_no,last_name_2)`.
    The optimizer verifies all the plans and determines which plan involves the least
    cost.'
  prefs: []
  type: TYPE_NORMAL
- en: Some examples of costs involved in the query are accessing data from the disk,
    accessing data from the memory, creating a temp table, sorting the results in
    the memory, and so on. MySQL assigns a relative value for each operation and sums
    the total cost for each plan. It executes the plan that involves the least cost.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can control the optimizer either by passing hints to the query or by adjusting
    the variable at a global or session level. You can even adjust the cost of the
    operations. It is recommended to leave these values as default unless you know
    what you are doing.
  prefs: []
  type: TYPE_NORMAL
- en: optimizer_search_depth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Jørgen''s point of view, taken from [http://jorgenloland.blogspot.in/2012/04/improvements-for-many-table-joins-in.html](http://jorgenloland.blogspot.in/2012/04/improvements-for-many-table-joins-in.html),
    states that:'
  prefs: []
  type: TYPE_NORMAL
- en: '"MySQL uses greedy search algorithm to to find the best order to join tables.
    When you join just a few tables, there''s no problem calculating the cost of all
    join order combinations and then pick the best plan. However, since there are
    (#tables)! possible combinations, the cost of calculating them all soon becomes
    too high: for five tables, e.g., there are 120 combinations which is no problem
    to compute. For 10 tables there are 3.6 million combinations and for 15 tables
    there are 1307 billion. For this reason, MySQL makes a trade off: use heuristics
    to only explore promising plans. This is supposed to significantly reduce the
    number of plans MySQL needs to calculate, but at the same time you risk not finding
    the best one."'
  prefs: []
  type: TYPE_NORMAL
- en: 'The MySQL documentation says:'
  prefs: []
  type: TYPE_NORMAL
- en: '"The optimizer_search_depth variable tells how far into the "future" of each
    incomplete plan the optimizer should look to evaluate whether it should be expanded
    further. Smaller values of optimizer_search_depth may result in orders of magnitude
    smaller query compilation times. For example, queries with 12, 13, or more tables
    may easily require hours and even days to compile if optimizer_search_depth is
    close to the number of tables in the query. At the same time, if compiled with
    optimizer_search_depth equal to 3 or 4, the optimizer may compile in less than
    a minute for the same query. If you are unsure of what a reasonable value is for
    optimizer_search_depth, this variable can be set to 0 to tell the optimizer to
    determine the value automatically."'
  prefs: []
  type: TYPE_NORMAL
- en: The default value of `optimizer_search_depth` is `62`, which is very greedy,
    but because of heuristics, MySQL picks up the plan very quickly. It is not clear
    from the documentation why the default value is set to `62` instead of `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are joining more than seven tables, you can set `optimizer_search_depth`
    to `0` or pass the optimizer hint (you will learn that in the next section). Automatic
    selection picks the value of min (number of tables, seven), limiting the search
    depth to a reasonable value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: How to know that the query is spending time in evaluating plans?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are joining 10 tables (mostly autogenerated by ORM), run an explain plan.
    If it takes more time, it means that the query is spending too much time in evaluating
    plans. Adjust the value of `optimizer_search_depth` (probably set to `0`) and
    check how much time the explain plan takes. Also note down the change in plans
    when you adjust the value of `optimizer_search_depth`.
  prefs: []
  type: TYPE_NORMAL
- en: optimizer_switch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `optimizer_switch` system variable is a set of flags. You can set each of
    those flags to `ON` or `OFF` to enable or disable the corresponding optimizer
    behavior. You can set it at the session level or global level dynamically. If
    you adjust the optimizer switch at the session level, all the queries in that
    session are affected, and if it is at the global level, all queries are affected.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you have noticed that the preceding query, `SELECT emp_no FROM
    employees WHERE first_name=''Adam'' OR last_name=''Adam''`, is using `sort_union(first_name,last_name_2)`.
    If you think that optimization is not correct for that query, you can adjust `optimizer_switch`
    to switch to another optimization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Initially, `index_merge_union` is on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The optimizer is able to use `sort_union`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'You can turn off `index_merge_sort_union` optimization at the session level
    so that only queries in this session are affected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice the plan change after `index_merge_sort_union` is turned off;
    it is no longer using `sort_union` optimization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: You can further find that, in this case, using `sort_union` is the best choice.
    Refer to [https://dev.mysql.com/doc/refman/8.0/en/switchable-optimizations.html](https://dev.mysql.com/doc/refman/8.0/en/switchable-optimizations.html)
    for more details on all types of optimizer switches.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizer hints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of adjusting the optimizer switch or `optimizer_search_depth` variables
    at session level, you can hint the optimizer to use, or not to use, certain optimizations.
    The scope of the optimizer hint is limited to the statement that gives you finer
    control over the queries, whereas the optimizer switch can be at session or global
    level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, take the example of the preceding query; if you feel that using `sort_union`
    is not optimal, you can turn it off by passing it as a hint in the query itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that in the redundant index section, we dropped the redundant index
    to find which plan was better. Instead, you can use the optimizer hint to ignore
    the intersect of `from_date` and `from_date_2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Another good example of using optimizer hints is setting the `JOIN` order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding query, the optimizer is first considering the `employees`
    table, and joining with the `salaries` table. You can change that by passing the
    hint, `/*+ JOIN_ORDER(s,e ) */`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: You will now notice that the `salaries` table is considered first, which avoids
    creating a temporary table, but it is going for a full table scan on the `salaries`
    table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another use case of optimizer hints is as follows: rather than setting the
    session variables for each statement or session, you can set them only for the
    statement. Suppose you are using an `ORDER BY` clause that sorts the query results,
    but you do not have index on the `ORDER BY` clause. Optimizer makes use of `sort_buffer_size`
    to speed up sorting. By default, the value of `sort_buffer_size` is `256K`. If
    `sort_buffer_size` is not sufficient, the number of merge passes that the sort
    algorithm has to do increases. You can measure this through the session variable `sort_merge_passes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice that MySQL did not have enough `sort_buffer_size`, and it has
    to do eight `sort_merge_passes`. You can set `sort_buffer_size` to some large
    value such as `16M` through an optimizer hint and check `sort_merge_passes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that `sort_merge_passes` is `0` when `sort_buffer_size` is set
    to `16M`.
  prefs: []
  type: TYPE_NORMAL
- en: It is highly recommended to optimize your queries by using indexes rather than
    relying on `sort_buffer_size`. You can consider increasing the `sort_buffer_size`
    value to speed up `ORDER BY` or `GROUP BY` operations that cannot be improved
    with query optimization or improved indexing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `SET_VAR`, you can set `optimizer_switch` at the statement level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also set the maximum execution time for a query, meaning the query
    is automatically terminated after the specified time using `/*+ MAX_EXECUTION_TIME(milli
    seconds) */`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: You can hint many other things to the optimizer, refer to [https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html](https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html)
    to get complete list and more examples.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting the optimizer cost model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To generate execution plans, the optimizer uses a cost model that is based
    on estimates of the cost of various operations that occur during query execution.
    The optimizer has a set of compiled-in default cost constants available to it,
    to make decisions regarding execution plans. You can adjust them by updating or
    inserting the `mysql.engine_cost` table and executing the `FLUSH OPTIMIZER_COSTS`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose you have a superfast disk; you can decrease the `cost_value` for `io_block_read_cost`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: To know more about the optimizer cost model, refer to [https://dev.mysql.com/doc/refman/8.0/en/cost-model.html](https://dev.mysql.com/doc/refman/8.0/en/cost-model.html).
  prefs: []
  type: TYPE_NORMAL
- en: Using index hints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using index hints, you can hint the optimizer to use or ignore indexes. This
    is different from optimizer hints. In optimizer hints, you hint the optimizer
    to use or ignore certain optimization methods. Index and optimizer hints can be
    used separately or together to achieve the desired plan. Index hints are specified
    following a table name.
  prefs: []
  type: TYPE_NORMAL
- en: When you are executing a complex query involving multiple table joins, and if
    the optimizer is taking too much time in evaluating the plans, you can determine
    the best plan and give it a hint to the query. But make sure that the plan you
    are suggesting is the best and should work in all cases.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take the same query where you evaluated the use of the redundant index as an
    example; it is using `intersect(from_date,from_date_2)`. By passing the optimizer
    hint `(/*+ NO_INDEX_MERGE(s from_date,from_date_2) */)`, you avoided the use of
    intersect. You can achieve the same behavior by hinting the optimizer to ignore
    the `from_date_2` index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Another use case is hinting the optimizer and saving the cost of evaluating
    multiple plans. Consider the following `employees` table and the query (the same
    as the one discussed at the beginning of the *Controlling query optimizer* section):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that the optimizer has to evaluate the indexes `full_name`, `full_name_desc`, `first_name`, `full_name_1`, `first_name_emp_no`, `last_name_2`
    to arrive at the best plan. You can hint the optimizer by passing `USE INDEX(first_name,last_name_2)`,
    which will eliminate scanning of other indexes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Since this is a simple query and the table is very small, the performance gain
    is negligible. The performance gain can be significant when the query is complex
    and is executed millions of times an hour.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing for JSON using generated columns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSON columns cannot be indexed directly. So if you want to use an index on a
    JSON column, you can extract the information using virtual columns and a created
    index on the virtual column.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider the `emp_details` table that you created in [Chapter 3](part0166.html#4U9TC0-faa69fe6f4c04957afca3568dcd9cd83),
    *Using MySQL (Advanced)*, *Using JSON* section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Insert a few dummy records:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose you want to retrieve the `emp_no` whose city is `Bangalore`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that the query is not able to use the index and scan all the
    rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can retrieve the city as a virtual column and add an index on it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'If you check the explain plan now, you can notice that the query is able to
    use the index on `city` and scan only one row:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: To know more about secondary indexes on generated columns, refer to [https://dev.mysql.com/doc/refman/8.0/en/create-table-secondary-indexes.html](https://dev.mysql.com/doc/refman/8.0/en/create-table-secondary-indexes.html).
  prefs: []
  type: TYPE_NORMAL
- en: Using resource groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can restrict the queries to use only a certain number of system resources
    using the resource groups. Currently, only CPU time is a manageable resource represented
    by **virtual CPU** (**VCPU**), which includes CPU cores, hyperthreads, hardware
    threads, and more. You can create a resource group and assign the VCPUs to it.
    Apart from the CPU, the attribute to the resource group is thread priority.
  prefs: []
  type: TYPE_NORMAL
- en: You can assign a resource group to a thread, set the default resource group
    at the session level, or pass the resource group as an optimizer hint. For example,
    you want to run some queries (say, reporting queries) with lowest priority; you
    can assign them to a resource group that has minimum resources.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Set the `CAP_SYS_NICE` capability to `mysqld`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a resource group using the `CREATE RESOURCE GROUP` statement. You have
    to mention the resource group name, number of VCPUS, thread priority, and type,
    which can be either `USER` or `SYSTEM`. If you do not specify the VCPU, all the
    CPUs will be used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The VCPU represents the CPU number as 0-5, including CPUs 0, 1, 2, 3, 4, and
    5; and 0-3, 8-9, and 11 include CPUs 0, 1, 2, 3, 8, 9, and 11.
  prefs: []
  type: TYPE_NORMAL
- en: The `THREAD_PRIORITY` is like a nice value for the CPU; it ranges from -20 to
    0 for system resource groups and 0 to 19 for user groups. -20 is the highest priority
    and 19 is the lowest priority.
  prefs: []
  type: TYPE_NORMAL
- en: You can also enable or disable a resource group. By default, the resource group
    is enabled at creation. A disabled group cannot have threads assigned to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating, you can verify the resource groups created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '`USR_default` and `SYS_default` are default resource groups which cannot be
    dropped or modified.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assign a group to a thread:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the sessions resource group; all the queries in that session will be executed
    under `report_group`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `RESOURCE_GROUP` optimizer hint to execute a single statement using `report_group`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Alter and drop resource group
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can dynamically adjust the number of CPUs or `thread_priority` of a resource
    group. If the system is heavily loaded, you can decrease the thread priority:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, you can increase the priority when the system is lightly loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'You can disable a resource group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also drop a resource group using the `DROP RESOURCE GROUP` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: If `FORCE` is given, the threads running are moved to the default resource group
    (system threads to `SYS_default` and user threads to `USR_default`).
  prefs: []
  type: TYPE_NORMAL
- en: If `FORCE` is not given, existing threads in the group continue to run until
    they terminate, but new threads cannot be assigned to the group.
  prefs: []
  type: TYPE_NORMAL
- en: The resource group is restricted to the local server, and none of the resource-group-related
    statements are replicated. To know more about resource groups, refer to [https://dev.mysql.com/doc/refman/8.0/en/resource-groups.html](https://dev.mysql.com/doc/refman/8.0/en/resource-groups.html).
  prefs: []
  type: TYPE_NORMAL
- en: Using performance_schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can inspect the internal execution of the server at runtime using `performance_schema`.
    This should not be confused with information schema, which is used to inspect
    metadata.
  prefs: []
  type: TYPE_NORMAL
- en: There are many event consumers in `performance_schema` that influence the timings
    of a server, such as a function call, a wait for the operating system, a stage
    of an SQL statement execution (say, parsing or sorting), a single statement, or
    a group of statements. All the collected information is stored in `performance_schema`
    and is not replicated.
  prefs: []
  type: TYPE_NORMAL
- en: '`performance_schema` is enabled by default; if you want to disable it, you
    can set `performance_schema=OFF` in the `my.cnf` file. By default, not all the
    consumers and instruments are enabled; you can turn them off/on by updating the
    `performance_schema.setup_instruments` and `performance_schema.setup_consumers` 
    tables.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will see how to use the `performance_schema`.
  prefs: []
  type: TYPE_NORMAL
- en: Enable/disable performance_schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To disable it, set `performance_schema` to `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Enable/disable consumers and instruments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You see a list of consumers available in the `setup_consumers` table, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose you want to enable `events_waits_current`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, you can disable or enable instruments from the `setup_instruments`
    table. There are around 1182 instruments (depending on the version):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: performance_schema tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are five main types of table in `performance_schema`. They are current
    events tables, event history tables, event summary tables, object instances tables,
    and setup (configuration) tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose you want to find out which file is accessed the most:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you want to find out which file has taken the most time in writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `events_statements_summary_by_digest` table to get the query
    report, just like you did for `pt-query-digest`. Top query by amount of time taken:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Top query by number of executions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose you want to find the statistics of a particular query; rather than
    depending on `mysqlslap` benchmark, you can check all the statistics using `performance_schema`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Using the sys schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `sys` schema helps you interpret the data collected from the `performance_schema`
    in an easy and more understandable form. `performance_schema` should be enabled
    for `sys` schema to work. To use the `sys` schema to its fullest extent, you need
    to enable all the consumers and timers on `performance_schema`, but this impacts
    the performance of the server. So, enable consumers for only those that you are
    looking for.
  prefs: []
  type: TYPE_NORMAL
- en: A view with the `x$` prefix displays data in picoseconds, which is used by other
    tools for further processing; other tables are human readable.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Enable a instrument from the `sys` schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to reset to default, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: There are numerous tables in the `sys` schema; some of the most used ones are
    shown in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Statement by type (INSERT and SELECT) from each host
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Statement by type from each user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Redundant indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Unused indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Statements executed from each host
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Table statistics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Table statistics with buffer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Statement analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This output is similar to the output of  `performance_schema.events_statements_summary_by_digest`
    and `pt-query-digest`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The top query by execution count is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'The statement that consumed maximum `tmp_disk_tables`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: To know more about the `sys` schema objects, refer to [https://dev.mysql.com/doc/refman/8.0/en/sys-schema-object-index.html](https://dev.mysql.com/doc/refman/8.0/en/sys-schema-object-index.html).
  prefs: []
  type: TYPE_NORMAL
