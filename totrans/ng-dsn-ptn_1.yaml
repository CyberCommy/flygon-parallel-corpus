- en: TypeScript Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I''ve always hated JavaScript. I use it, sure, but only when necessary. I distinctly
    remember my first internship interview, back when I was a freshman at eXia.Cesi, a
    French computer engineering school. I only knew C and some Java, and I was asked
    to help on an intranet that mostly worked with homemade Ajax libraries. It was
    pure madness and kind of steered me away from the web aspect of computer engineering
    for a while. I find nothing likeable in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A native Ajax call. How ugly is that?
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, with jQuery modules and some separation of concerns, it can be usable,
    but still not as comfortable as I would like. You can see in the following screenshot
    that the concerns are separated, but it''s not so easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/16cbc831-2677-40cc-bfaa-2d73c10587fa.png)A deprecated toolwatch.io
    version using PHP5 and Codeigniter'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, I learned some RoR (a Ruby-based, object-oriented framework for web applications: [http://rubyonrails.org/](http://rubyonrails.org/))
    and Hack (a typed PHP by Facebook: [http://hacklang.org/](http://hacklang.org/)).
    It was wonderful; I had everything I always wanted: type safety, tooling, and
    performance. The first one, type safety, is pretty self-explanatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, with types, you can have great toolings, such as powerful auto completion
    and suggestions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/47a5355f-21db-45a0-9216-f98a21caba1e.png)Sublime Text autocompletion
    on toolwatch.io mobile app (Ionic2 *[5]* + Angular 2 )'
  prefs: []
  type: TYPE_IMG
- en: 'Angular can be used with CoffeeScript, TypeScript, and JavaScript. In this
    book, we''ll focus on TypeScript, which is the language recommended by Google.
    TypeScript is a typed superset of JavaScript; this means that, with TypeScript,
    you can do everything you used to do in JavaScript, and more! To name but a few
    advantages: user-defined types, inheritance, interfaces, and visibility. And the
    best part is that TypeScript is transpiled into JavaScript so that any modern
    browser can run it.'
  prefs: []
  type: TYPE_NORMAL
- en: In fact, with the use of polyfill, even our good old IE6 can almost execute
    the final output. We'll get back to that in the next chapter. The transpilation
    is different from compilation (for example, from C to executable or `.java` to
    `.class`) as it only translates TypeScript into JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn the best practices for TypeScript. The syntax
    of the TypeScript language is quite easy to grasp for anyone who knows JavaScript
    and an object-oriented language. If you don''t know anything about object-oriented
    programming, I''d suggest you put this book aside for a few moments and take a
    look at this quick Udacity course: [https://www.udacity.com/wiki/classes](https://www.udacity.com/wiki/classes).'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a summary of the topics covered:'
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript shortcomings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environment setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the environment setup, I will cover all three major platforms: Debian-flavored
    Linux, macOS, and Windows. All the tools we are going to use are cross-platform.
    Consequently, feel free to choose the one you like the most; there is not a thing
    you will not be able to do later on.'
  prefs: []
  type: TYPE_NORMAL
- en: In what follows, we will install `Node.js`, `npm`, and TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js and npm for Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This command downloads a script, directly into your `bash`, that will fetch
    every resource you need and install it. For most cases, it will work just fine
    and install `Node.js` + `npm`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, this script has one flaw; it will fail if you have Debian repositories
    that are no longer available. You can either take this opportunity to clean your
    Debian repositories or edit the script a bit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Then, go to [https://Node.js.org/en/download/](https://Node.js.org/en/download/),
    and download and install the last `.pkg` or `.msi` (for Linux or Windows, respectively).
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, you should have access to `node` and `npm` in your Terminal. You can test
    them out with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the output of these commands (for example, v6.2.1 and 3.9.3) can
    be different, and your environment as the latest version of node and npm can,
    and most certainly, will be different by the time you read these lines. However,
    if you at least have these versions, you will be fine for the rest of this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `-g` argument stands for global. In the Linux system, depending on your
    distribution, you might need `sudo` rights to install global packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Very much like node and npm, we can test whether the installation went well
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'What we have, for now, is the TypeScript transpiler. You can use it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will transpile the content of `myTypeScriptFile.ts` and create
    `myTranspiledFile.js`. Then, you can execute the resultant `js` file, in the console,
    using node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To speed up our development process, we will install `ts-node`. This node package
    will transpile TypeScript files into JavaScript and resolve the dependencies between
    said files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file named `hello.ts` and add the following to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use our new package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Quick overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, I'll present a quick overview of TypeScript. This presentation
    is by no means exhaustive, as I will explain particular concepts when we come
    across them. However, here are some basics.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript is, as I''ve mentioned, a typed superset of JavaScript. While TypeScript
    is typed, it only proposes four base types for you to use out of the box. The
    four types are `String`, `number`, `Boolean`, and `any`. These types can, using
    the `:` operator, type var name: string variables or function arguments and return
    the add(`a:number`, `b:number`):number type function. Also, `void` can be used
    for functions to specify that they don''t return anything. On the object-oriented
    side, string, number, and boolean specialize any. `Any` can be used for anything.
    It''s the TypeScript equivalent of the Java object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need more than these types, well, you''ll have to create them yourself!
    Thankfully, this is pretty straightforward. Here''s the declaration of a user
    class that contains one property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create a new `Person` instance with the simple command shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, I create a `p` variable that statically (for example, the left-hand side)
    and dynamically (for example, the right-hand side) stands for a Person. Then,
    I add `Mathieu`to the `name` property. Properties are, by default, public, but
    you can use the `public`, `private`, and `protected` keywords to refine their
    visibility. They'll behave as you'd expect in any object-oriented programming
    language.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript supports interfaces, inheritance, and polymorphism in a very simple
    fashion. Here is a simple hierarchy composed of two classes and one interface.
    The interface, `People`, defines the string that will be inherited by any `People`
    implementation. Then, `Employee` implements `People` and adds two properties:
    `manager` and `title`. Finally, the `Manager` class defines an `Employee` array,
    as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions can be overridden by functions that have the same signature, and
    the `super` keyword can be used to refer to the parent implementation, as shown
    in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The last thing you need to know about TypeScript before we move on to the best
    practices is the difference between `let` and `var`. In TypeScript, you can use
    both to declare a variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the particularity of variables in TypeScript is that it lets you decide
    between a function and a block scope for variables using the var and let keywords.
    Var will give your variable a function scope, while let will produce a block-scoped
    variable. A function scope means that the variables are visible and accessible
    to and from the whole function. Most programming languages have block scope for
    variables (such as C#, Java, and C++). Some languages also offer the same possibility
    as TypeScript, such as Swift 2\. More concretely, the output of the following
    snippet will be `456`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In opposition, if you use let, the output will be `123` because the second
    `foo` variable only exists in the `if` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we present the best practices for TypeScript in terms of coding
    conventions, tricks to use, and features and pitfalls to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: Naming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The naming conventions preconized by the Angular and definitely typed teams
    are very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Class: `CamelCase`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Interface: `CamelCase`. Also, you should try to refrain from preceding your
    interface name with a capital I.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Variables: `lowerCamelCase`. Private variables can be preceded by a `_`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Functions: `lowerCamelCase`. Also, if a method does not return anything, you
    should specify that said method returns `void` for better readability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface redefinitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeScript allows programmers to redefine interfaces, using the same name multiple
    times. Then, any implementation of said interface inherits all the definitions
    of all the interfaces. The official reason for this is to allow users to enhance
    the JavaScript interface without having to change the types of their object throughout
    their code. While I understand the intent of such a feature, I foresee way too
    much hassle in its use. Let''s have a look at an example feature on the Microsoft
    website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Leaving aside the fact that the naming conventions are not respected, we got
    two different definitions of the `ICustomerMerge` interface. The first one defines
    a string and the second one a number. Automatically, `CustomerMerge` has these
    members. Now, imagine you have ten-twelves file dependencies, you implement an
    interface, and you don't understand why you have to implement such and such functions.
    Well, someone, somewhere, decided it was pertinent to redefine an interface and
    broke all your code, at once.
  prefs: []
  type: TYPE_NORMAL
- en: Getters and setters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In TypeScript, you can specify optional arguments with the `?`operator. While
    this feature is good and I will use it without moderation in the coming chapters,
    it opens the door to the following ugliness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, we test whether the optional name argument was passed with `!== undefined`.
    If the `getSetName` function received something, it'll act as a setter, otherwise,
    as a getter. The fact that the function doesn't return anything when used as a
    setter is authorized by any return type.
  prefs: []
  type: TYPE_NORMAL
- en: 'For clarity and readability, stick to the ActionScript-inspired getter and
    setter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can use them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Constructor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeScript constructors offer a pretty unusual, but time-saving, feature. Indeed,
    they allow us to declare a class member directly. So, instead of this lengthy
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You could have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code achieves the same thing and will be transpiled to the same
    JavaScript. The only difference is that it saves you time in a way that doesn't
    degrade the clarity or readability of your code.
  prefs: []
  type: TYPE_NORMAL
- en: Type guards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Type guards, in TypeScript, define a list of types for a given value. If one
    of your variables can be assigned to one and only value or a specific set of values,
    then consider using the type guard over the enumerator. It''ll achieve the same
    functionality while being much more concise. Here''s a made-up example with a
    `People` person who has a gender attribute that can only be `MALE` or `FEMALE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Enumerator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In opposition to type guards, if your class has a variable that can take multiple
    values at the same time from a finite list of values, then consider using the
    bit-based enumerator. Here''s an excellent example from [https://basarat.gitbooks.io/](https://basarat.gitbooks.io/):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We defined the different values using the `<<` shift operator in `AnimalFlags`,
    then used `|=` to combine flags, `&=` and `~` to remove flags, and `|` to combine
    flags.
  prefs: []
  type: TYPE_NORMAL
- en: Pitfalls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will go over two TypeScript pitfalls that became a problem
    for me when I was coding Angular 2 applications.
  prefs: []
  type: TYPE_NORMAL
- en: Type-casting and JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you plan to build more than a playground with Angular 2, and you obviously
    do since you are interested in patterns for performances, stability, and operations,
    you will most likely consume an API to feed your application. Chances are, this
    API will communicate with you using JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that we have a `User` class with two private variables: `lastName:string`
    and `firstName:string`. In addition, this simple class proposes the `hello` method,
    which prints `Hi I am`, `this.firstName`, `this.lastName`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, consider that we receive users through a JSON API. Most likely, it''ll
    look something like  *`[{"lastName":"Nayrolles","firstName":"Mathieu"}...]`*.
    With the following snippet, we can create a `User`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, the TypeScript compiler doesn''t complain, and it executes smoothly.
    It works because the `parse` method returns `any` (that is, the TypeScript equivalent
    of the Java object). Sure enough, we can convert `any` into `User`. However, the
    following `userFromJSONAPI.hello();` will yield:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Why? Well, the left-hand side of the assignation is defined as `User`, sure,
    but it''ll be *erased* when we transpile it to JavaScript. The type-safe TypeScript
    way to do it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Interestingly enough, the `typeof` function won't help you either. In both cases,
    it'll display `Object`instead of `User`, as the very concept of `User` doesn't
    exist in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'This type of fetch/map/new can rapidly become tedious as the parameter list
    grows. You can use the factory pattern which we''ll see in [Chapter 3](fac4936a-292a-4b12-ac60-394bacad0f16.xhtml),
    *Classical Patterns*, or create an instance loader, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`InstanceLoader` will only work when used inside an HTML page, as it depends
    on the `window` variable. If you try to execute it using `ts-node`, you''ll get
    the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Inheritance and polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s assume that we have a simple inheritance hierarchy as follows. We have
    an interface `Animal` that defines the `eat():void` and `sleep(): void` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have a `Mammal` class that implements the `Animal` interface. This
    class also adds a constructor and leverages the private `name: type` notation
    we saw earlier. For the `eat():void` and `sleep(): void` methods, this class prints
    `"Like a mammal"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have a `Dog` class that extends `Mammal` and overrides `eat(): void`
    so it prints `"Like a Dog"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have a function that expects an `Animal` as a parameter and invokes
    the `eat()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our last creation, `let abomination: Dog = new Mammal("abomination");`should
    not be possible as per object-oriented principles. Indeed, the left-hand side
    of the affectation is more specific than the right-hand side, which should not
    be allowed by the TypeScript compiler. If we look at the generated JavaScript,
    we can see what happens. The types disappear and are replaced by functions. Then,
    the types of the variables are inferred at creation time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: When in doubt, it's always a good idea to look at the transpiled JavaScript.
    You will see what's going on at execution time and maybe discover other pitfalls!
    As a side note, the TypeScript transpiler is fooled here because, from a JavaScript
    point of view, `Mammal` and `Dog` are not different; they have the same properties
    and functions. If we add a property in the `Dog` class (such as `private race:string`),
    it won't transpile anymore. This means that overriding methods are not sufficient
    to be recognized as types; they must be semantically different.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example is a bit far-fetched, and I agree that this TypeScript specificity
    won''t haunt you every day. However, if we are using some bounded genericity with
    a strict hierarchy, then you have to know about it. Indeed, the following example,
    unfortunately, works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we completed a TypeScript setup and reviewed most of the best
    practices in terms of code convention, features we should and shouldn't use, and
    common pitfalls to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on Angular and how to get started with the
    all-new Angular CLI.
  prefs: []
  type: TYPE_NORMAL
