- en: TypeScript Best Practices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I''ve always hated JavaScript. I use it, sure, but only when necessary. I distinctly
    remember my first internship interview, back when I was a freshman at eXia.Cesi, a
    French computer engineering school. I only knew C and some Java, and I was asked
    to help on an intranet that mostly worked with homemade Ajax libraries. It was
    pure madness and kind of steered me away from the web aspect of computer engineering
    for a while. I find nothing likeable in the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A native Ajax call. How ugly is that?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, with jQuery modules and some separation of concerns, it can be usable,
    but still not as comfortable as I would like. You can see in the following screenshot
    that the concerns are separated, but it''s not so easy:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/16cbc831-2677-40cc-bfaa-2d73c10587fa.png)A deprecated toolwatch.io
    version using PHP5 and Codeigniter'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, I learned some RoR (a Ruby-based, object-oriented framework for web applications: [http://rubyonrails.org/](http://rubyonrails.org/))
    and Hack (a typed PHP by Facebook: [http://hacklang.org/](http://hacklang.org/)).
    It was wonderful; I had everything I always wanted: type safety, tooling, and
    performance. The first one, type safety, is pretty self-explanatory:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Also, with types, you can have great toolings, such as powerful auto completion
    and suggestions:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/47a5355f-21db-45a0-9216-f98a21caba1e.png)Sublime Text autocompletion
    on toolwatch.io mobile app (Ionic2 *[5]* + Angular 2 )'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
- en: 'Angular can be used with CoffeeScript, TypeScript, and JavaScript. In this
    book, we''ll focus on TypeScript, which is the language recommended by Google.
    TypeScript is a typed superset of JavaScript; this means that, with TypeScript,
    you can do everything you used to do in JavaScript, and more! To name but a few
    advantages: user-defined types, inheritance, interfaces, and visibility. And the
    best part is that TypeScript is transpiled into JavaScript so that any modern
    browser can run it.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: In fact, with the use of polyfill, even our good old IE6 can almost execute
    the final output. We'll get back to that in the next chapter. The transpilation
    is different from compilation (for example, from C to executable or `.java` to
    `.class`) as it only translates TypeScript into JavaScript.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn the best practices for TypeScript. The syntax
    of the TypeScript language is quite easy to grasp for anyone who knows JavaScript
    and an object-oriented language. If you don''t know anything about object-oriented
    programming, I''d suggest you put this book aside for a few moments and take a
    look at this quick Udacity course: [https://www.udacity.com/wiki/classes](https://www.udacity.com/wiki/classes).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'As a summary of the topics covered:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript syntax
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript best practices
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript shortcomings
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environment setup
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the environment setup, I will cover all three major platforms: Debian-flavored
    Linux, macOS, and Windows. All the tools we are going to use are cross-platform.
    Consequently, feel free to choose the one you like the most; there is not a thing
    you will not be able to do later on.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: In what follows, we will install `Node.js`, `npm`, and TypeScript.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Node.js and npm for Linux
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This command downloads a script, directly into your `bash`, that will fetch
    every resource you need and install it. For most cases, it will work just fine
    and install `Node.js` + `npm`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Now, this script has one flaw; it will fail if you have Debian repositories
    that are no longer available. You can either take this opportunity to clean your
    Debian repositories or edit the script a bit.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Then, go to [https://Node.js.org/en/download/](https://Node.js.org/en/download/),
    and download and install the last `.pkg` or `.msi` (for Linux or Windows, respectively).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, you should have access to `node` and `npm` in your Terminal. You can test
    them out with the following commands:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Note that the output of these commands (for example, v6.2.1 and 3.9.3) can
    be different, and your environment as the latest version of node and npm can,
    and most certainly, will be different by the time you read these lines. However,
    if you at least have these versions, you will be fine for the rest of this book:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `-g` argument stands for global. In the Linux system, depending on your
    distribution, you might need `sudo` rights to install global packages.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'Very much like node and npm, we can test whether the installation went well
    with the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'What we have, for now, is the TypeScript transpiler. You can use it like so:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This command will transpile the content of `myTypeScriptFile.ts` and create
    `myTranspiledFile.js`. Then, you can execute the resultant `js` file, in the console,
    using node:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To speed up our development process, we will install `ts-node`. This node package
    will transpile TypeScript files into JavaScript and resolve the dependencies between
    said files:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a file named `hello.ts` and add the following to it:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we can use our new package:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Quick overview
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, I'll present a quick overview of TypeScript. This presentation
    is by no means exhaustive, as I will explain particular concepts when we come
    across them. However, here are some basics.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript is, as I''ve mentioned, a typed superset of JavaScript. While TypeScript
    is typed, it only proposes four base types for you to use out of the box. The
    four types are `String`, `number`, `Boolean`, and `any`. These types can, using
    the `:` operator, type var name: string variables or function arguments and return
    the add(`a:number`, `b:number`):number type function. Also, `void` can be used
    for functions to specify that they don''t return anything. On the object-oriented
    side, string, number, and boolean specialize any. `Any` can be used for anything.
    It''s the TypeScript equivalent of the Java object.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need more than these types, well, you''ll have to create them yourself!
    Thankfully, this is pretty straightforward. Here''s the declaration of a user
    class that contains one property:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can create a new `Person` instance with the simple command shown here:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, I create a `p` variable that statically (for example, the left-hand side)
    and dynamically (for example, the right-hand side) stands for a Person. Then,
    I add `Mathieu`to the `name` property. Properties are, by default, public, but
    you can use the `public`, `private`, and `protected` keywords to refine their
    visibility. They'll behave as you'd expect in any object-oriented programming
    language.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript supports interfaces, inheritance, and polymorphism in a very simple
    fashion. Here is a simple hierarchy composed of two classes and one interface.
    The interface, `People`, defines the string that will be inherited by any `People`
    implementation. Then, `Employee` implements `People` and adds two properties:
    `manager` and `title`. Finally, the `Manager` class defines an `Employee` array,
    as shown in the following code block:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Functions can be overridden by functions that have the same signature, and
    the `super` keyword can be used to refer to the parent implementation, as shown
    in the following snippet:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The last thing you need to know about TypeScript before we move on to the best
    practices is the difference between `let` and `var`. In TypeScript, you can use
    both to declare a variable.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续讨论最佳实践之前，您需要了解有关TypeScript的最后一件事是`let`和`var`之间的区别。在TypeScript中，您可以使用这两个关键字来声明变量。
- en: 'Now, the particularity of variables in TypeScript is that it lets you decide
    between a function and a block scope for variables using the var and let keywords.
    Var will give your variable a function scope, while let will produce a block-scoped
    variable. A function scope means that the variables are visible and accessible
    to and from the whole function. Most programming languages have block scope for
    variables (such as C#, Java, and C++). Some languages also offer the same possibility
    as TypeScript, such as Swift 2\. More concretely, the output of the following
    snippet will be `456`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，TypeScript中变量的特殊之处在于它允许您使用var和let关键字为变量选择函数作用域和块作用域。Var将为您的变量提供函数作用域，而let将产生一个块作用域的变量。函数作用域意味着变量对整个函数可见和可访问。大多数编程语言都有变量的块作用域（如C＃，Java和C
    ++）。一些语言也提供了与TypeScript相同的可能性，例如Swift 2。更具体地说，以下代码段的输出将是`456`：
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In opposition, if you use let, the output will be `123` because the second
    `foo` variable only exists in the `if` block:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果您使用let，输出将是`123`，因为第二个`foo`变量只存在于`if`块中：
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Best practices
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践
- en: In this section, we present the best practices for TypeScript in terms of coding
    conventions, tricks to use, and features and pitfalls to avoid.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍TypeScript的最佳实践，包括编码约定、使用技巧、以及要避免的功能和陷阱。
- en: Naming
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名
- en: 'The naming conventions preconized by the Angular and definitely typed teams
    are very simple:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Angular和definitely typed团队提倡的命名约定非常简单：
- en: 'Class: `CamelCase`.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类：`CamelCase`。
- en: 'Interface: `CamelCase`. Also, you should try to refrain from preceding your
    interface name with a capital I.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口：`CamelCase`。此外，您应该尽量避免在接口名称前加大写I。
- en: 'Variables: `lowerCamelCase`. Private variables can be preceded by a `_`.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量：`lowerCamelCase`。私有变量可以在前面加上`_`。
- en: 'Functions: `lowerCamelCase`. Also, if a method does not return anything, you
    should specify that said method returns `void` for better readability.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数：`lowerCamelCase`。此外，如果一个方法不返回任何内容，您应该指定该方法返回`void`以提高可读性。
- en: Interface redefinitions
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口重新定义
- en: 'TypeScript allows programmers to redefine interfaces, using the same name multiple
    times. Then, any implementation of said interface inherits all the definitions
    of all the interfaces. The official reason for this is to allow users to enhance
    the JavaScript interface without having to change the types of their object throughout
    their code. While I understand the intent of such a feature, I foresee way too
    much hassle in its use. Let''s have a look at an example feature on the Microsoft
    website:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript允许程序员多次使用相同的名称重新定义接口。然后，所述接口的任何实现都继承了所有接口的定义。官方原因是允许用户增强JavaScript接口，而无需在整个代码中更改对象的类型。虽然我理解这种功能的意图，但我预见到在使用过程中会遇到太多麻烦。让我们来看一个微软网站上的示例功能：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Leaving aside the fact that the naming conventions are not respected, we got
    two different definitions of the `ICustomerMerge` interface. The first one defines
    a string and the second one a number. Automatically, `CustomerMerge` has these
    members. Now, imagine you have ten-twelves file dependencies, you implement an
    interface, and you don't understand why you have to implement such and such functions.
    Well, someone, somewhere, decided it was pertinent to redefine an interface and
    broke all your code, at once.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Getters and setters
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In TypeScript, you can specify optional arguments with the `?`operator. While
    this feature is good and I will use it without moderation in the coming chapters,
    it opens the door to the following ugliness:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we test whether the optional name argument was passed with `!== undefined`.
    If the `getSetName` function received something, it'll act as a setter, otherwise,
    as a getter. The fact that the function doesn't return anything when used as a
    setter is authorized by any return type.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'For clarity and readability, stick to the ActionScript-inspired getter and
    setter:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, you can use them as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Constructor
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeScript constructors offer a pretty unusual, but time-saving, feature. Indeed,
    they allow us to declare a class member directly. So, instead of this lengthy
    code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You could have:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding code achieves the same thing and will be transpiled to the same
    JavaScript. The only difference is that it saves you time in a way that doesn't
    degrade the clarity or readability of your code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Type guards
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Type guards, in TypeScript, define a list of types for a given value. If one
    of your variables can be assigned to one and only value or a specific set of values,
    then consider using the type guard over the enumerator. It''ll achieve the same
    functionality while being much more concise. Here''s a made-up example with a
    `People` person who has a gender attribute that can only be `MALE` or `FEMALE`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, consider the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Enumerator
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In opposition to type guards, if your class has a variable that can take multiple
    values at the same time from a finite list of values, then consider using the
    bit-based enumerator. Here''s an excellent example from [https://basarat.gitbooks.io/](https://basarat.gitbooks.io/):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We defined the different values using the `<<` shift operator in `AnimalFlags`,
    then used `|=` to combine flags, `&=` and `~` to remove flags, and `|` to combine
    flags.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Pitfalls
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will go over two TypeScript pitfalls that became a problem
    for me when I was coding Angular 2 applications.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Type-casting and JSON
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you plan to build more than a playground with Angular 2, and you obviously
    do since you are interested in patterns for performances, stability, and operations,
    you will most likely consume an API to feed your application. Chances are, this
    API will communicate with you using JSON.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that we have a `User` class with two private variables: `lastName:string`
    and `firstName:string`. In addition, this simple class proposes the `hello` method,
    which prints `Hi I am`, `this.firstName`, `this.lastName`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, consider that we receive users through a JSON API. Most likely, it''ll
    look something like  *`[{"lastName":"Nayrolles","firstName":"Mathieu"}...]`*.
    With the following snippet, we can create a `User`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'So far, the TypeScript compiler doesn''t complain, and it executes smoothly.
    It works because the `parse` method returns `any` (that is, the TypeScript equivalent
    of the Java object). Sure enough, we can convert `any` into `User`. However, the
    following `userFromJSONAPI.hello();` will yield:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Why? Well, the left-hand side of the assignation is defined as `User`, sure,
    but it''ll be *erased* when we transpile it to JavaScript. The type-safe TypeScript
    way to do it is:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Interestingly enough, the `typeof` function won't help you either. In both cases,
    it'll display `Object`instead of `User`, as the very concept of `User` doesn't
    exist in JavaScript.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'This type of fetch/map/new can rapidly become tedious as the parameter list
    grows. You can use the factory pattern which we''ll see in [Chapter 3](fac4936a-292a-4b12-ac60-394bacad0f16.xhtml),
    *Classical Patterns*, or create an instance loader, such as:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`InstanceLoader` will only work when used inside an HTML page, as it depends
    on the `window` variable. If you try to execute it using `ts-node`, you''ll get
    the following error:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Inheritance and polymorphism
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s assume that we have a simple inheritance hierarchy as follows. We have
    an interface `Animal` that defines the `eat():void` and `sleep(): void` methods:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, we have a `Mammal` class that implements the `Animal` interface. This
    class also adds a constructor and leverages the private `name: type` notation
    we saw earlier. For the `eat():void` and `sleep(): void` methods, this class prints
    `"Like a mammal"`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We also have a `Dog` class that extends `Mammal` and overrides `eat(): void`
    so it prints `"Like a Dog"`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, we have a function that expects an `Animal` as a parameter and invokes
    the `eat()` method:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output is as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, our last creation, `let abomination: Dog = new Mammal("abomination");`should
    not be possible as per object-oriented principles. Indeed, the left-hand side
    of the affectation is more specific than the right-hand side, which should not
    be allowed by the TypeScript compiler. If we look at the generated JavaScript,
    we can see what happens. The types disappear and are replaced by functions. Then,
    the types of the variables are inferred at creation time:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When in doubt, it's always a good idea to look at the transpiled JavaScript.
    You will see what's going on at execution time and maybe discover other pitfalls!
    As a side note, the TypeScript transpiler is fooled here because, from a JavaScript
    point of view, `Mammal` and `Dog` are not different; they have the same properties
    and functions. If we add a property in the `Dog` class (such as `private race:string`),
    it won't transpile anymore. This means that overriding methods are not sufficient
    to be recognized as types; they must be semantically different.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'This example is a bit far-fetched, and I agree that this TypeScript specificity
    won''t haunt you every day. However, if we are using some bounded genericity with
    a strict hierarchy, then you have to know about it. Indeed, the following example,
    unfortunately, works:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Summary
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we completed a TypeScript setup and reviewed most of the best
    practices in terms of code convention, features we should and shouldn't use, and
    common pitfalls to avoid.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on Angular and how to get started with the
    all-new Angular CLI.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
