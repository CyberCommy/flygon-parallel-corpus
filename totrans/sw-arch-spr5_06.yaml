- en: Event-Driven Architectures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Event-driven architectures** (**EDA**) are based on commands and events that
    are created each time an application changes state. According to Martin Fowler,
    there are four patterns that are used to build software systems using this approach.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn about these four patterns and look at
    how messaging can be tied together to take full advantage of a programming model
    based on messages. Even when it's not a requirement, messaging can be used to
    add more capabilities into applications that are built using an event-driven architectural
    style.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Underlying concepts and key aspects associated with event-driven architectures:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Common patterns used within event-driven architectures:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event notification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event-carried state transfer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event sourcing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CQRS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Underlying concepts and key aspects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before looking into the details of event-driven architectures, we are going
    to start by learning about some key aspects surrounding them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The applications created using this approach are developed with two different
    but related concepts in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at a brief definition of each of these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A command is an operation performed within an application that emits one or
    more events as the result of a successful or failed execution. We can think about
    these as operations that are intended to modify the state of a system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Commands are called actions. This makes a lot of sense if we take their intended
    use into consideration. The following list shows some examples of such commands:'
  prefs: []
  type: TYPE_NORMAL
- en: Transfer money
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update user information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's highly recommended that you use present tense verbs for naming commands,
    as demonstrated with these examples.
  prefs: []
  type: TYPE_NORMAL
- en: Event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An event is the result of a command execution within an application. These are
    used as a notification mechanism for subscribers who are interested in receiving
    them. Events are immutable and should not be modified, as they are designed to
    keep a log that keeps information on how the application state has mutated over
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to naming events, the rule of thumb is to use past tense, such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Money transferred
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User information updated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Account created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events are not concerned with what actions will be performed after their creation.
    This makes it possible to decouple a system but still notify the subscribers. In
    this way, we can decouple applications because the subscribers are responsible
    for executing one or more operations, depending on what is needed when they have
    been notified of an event's creation.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we can conclude that we can decouple applications because the
    subscribers are responsible for executing one or more operations, depending on
    what is needed when they have been notified of an event's creation. We can also
    infer that events are an excellent way to reverse dependencies by delegating responsibilities
    to other systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how a command emits events and how the subscribers
    to these events are notified:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ddc799d-645a-4f18-b6ba-1a55ee131efb.png)'
  prefs: []
  type: TYPE_IMG
- en: Events creation and propagation
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a better understanding of events, let's review the four patterns
    that we mentioned at the beginning of this chapter in order to create applications
    using an event-driven architectural style.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns of event-driven architectures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When people talk about event-driven architectures, they often refer to one
    of the following patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: Event notification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event-carried state transfer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event sourcing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CQRS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At times, more than one of these are used together within the same system, depending
    on what the business requirements are. Let's review each of these patterns in
    order to identify the scenarios in which they can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Event notification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The event notification pattern works by emitting events to subscribers once
    a command is executed. This can be compared to the observer pattern in which you
    observe a subject that has a list of many listeners or subscribers that are automatically notified
    when the state of the observed object changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This behavior is widely used by event bus libraries that allow publish-subscribe
    communication among the components that are part of an application. The most common
    use cases for these libraries are targeted towards the UI, but they are also applicable
    to other parts of the system in the backend. The following diagram demonstrates
    how an event is sent to the bus and then propagated to all subscribers, which
    were previously registered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a065abde-ec41-4828-ab21-9c8f33600082.png)'
  prefs: []
  type: TYPE_IMG
- en: Event bus
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main benefits to using this event-notification mechanism:'
  prefs: []
  type: TYPE_NORMAL
- en: Decoupled systems and functionalities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inverted dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To better understand these benefits, let''s imagine that we need to work on
    the following requirement of our banking application:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The bank wants to offer customers who are using the mobile app the chance
    to transfer money. This will include either transferring **between accounts owned **by **our
    bank or transferring to external banks. Once this transaction is executed, we
    need to notify the customers about the transaction status using their preferred
    notification channels.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*The bank also has an application that is used by the call center staff that
    notifies our agents of our clients'' balance. When a client''s account balance
    is higher than a predetermined amount of money, the call center system will alert
    the agents, who will then call the clients to make them aware of the possibility
    of investing their money in the bank. Finally, if a transaction involves an external
    bank, we need to notify them about the transaction status too.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a classic approach to write an application, we can correctly build a
    system where all the following postconditions listed in the requirements are executed
    within the transfer application boundaries after the money transfer occurs, as
    demonstrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c789f88c-e8ac-4e36-8e46-10290e86a8c9.png)'
  prefs: []
  type: TYPE_IMG
- en: Coupled transfer money application
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from the preceding diagram, the transfer money application needs
    to know about all the postconditions that have to be met once the transaction
    has occurred; using this approach, we will end up writing all the necessary code
    to interact with other systems, which leads us to couple the application with
    other systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, using the event-notification pattern, we can decouple the
    transfer money application, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc5708c0-6293-4467-bfa9-dc7c7be9cf3d.png)'
  prefs: []
  type: TYPE_IMG
- en: Decoupled transfer money application
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, we can see that once the `<Transfer money>` command is
    executed, a `<Money transferred>` event is emitted, and all the subscribed systems
    are notified. By doing this, we can get rid of the coupling among the systems.
  prefs: []
  type: TYPE_NORMAL
- en: The important thing to note here is that the money transfer application doesn't
    even need to know about the existence of other software systems, and all the postconditions
    are met out of the boundaries of this application. In other words, decoupled systems
    lead us to invert dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Decoupled systems and inverted dependencies sound fantastic, but the implicit
    disadvantage of these is that you lose visibility. This is because the application
    emitting events doesn't know anything about the processes that are executed once
    the event is published, and there is no code for reading other systems.
  prefs: []
  type: TYPE_NORMAL
- en: It is often impossible to identify dependencies downstream, and some techniques
    for correlating events across different logs are commonly used to relieve this
    nightmare.
  prefs: []
  type: TYPE_NORMAL
- en: Coupled systems give all the information regarding downstream dependencies,
    and are hard to evolve. Conversely, decoupled systems know nothing about downstream
    dependencies, but they offer the chance to evolve systems independently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have learned of the underlying concepts that are supporting the
    event-notification pattern, we can say that the most visible technology for implementing
    this kind of application is the use of messaging systems such as RabbitMQ, AWS
    SQS/SNS, MSMQ, and so on. These are supported by Spring under the Spring Cloud
    Stream project umbrella. In our case, we are going to use RabbitMQ, which can
    be supported by adding the following dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In order to make the setup process of RabbitMQ accessible, the code provided
    for this book in this chapter includes a Docker Compose file that should be executed
    using the `docker-compose up `command*. *We will look at what Docker Compose is
    and how it works in [Chapter 10](8762b4ca-6a2e-4b00-acf3-3f8f5e2f00b9.xhtml),
    *Containerizing your Applications*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Cloud Stream is built on the top of Spring Integration and offers the
    chance to produce and consume messages easily, as well as the chance to use all
    the built-in functionalities of Spring Integration. We are going to use this project
    to implement the example of the banking application mentioned earlier, so we will
    need to add the following dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The transfer money application will expose an endpoint to allow the transferring
    of money. Once this transaction is done, an event notification needs to be sent
    to the other apps. Spring Cloud Stream makes it possible to define messaging channels
    with the use of the `@Output` annotation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This interface can be annotated and used wherever you want. Let''s look at
    how to use this in the controller, which exposes the functionality to transfer
    money:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: One thing to keep in mind when we are using the event-notification pattern is
    that the application that is emitting events simply provides very basic information
    regarding the executed command. In this case, the `<Money Transferred>` event
    contains the client ID that should be used later to query more information and
    determine whether or not additional operations need to be executed. This process
    always involves one or more additional interactions with other systems, databases,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The subscribers can take advantage of Spring Cloud Stream as well. In this
    case, the `@Input` annotation should be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Using Spring Integration, a complete integration flow can be executed to process
    the incoming message in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Once the message is retrieved, it should be used to query additional information
    regarding the transaction and determine whether a notification should be sent
    to external banks. This approach is useful for reducing the size of the payload.
    It also helps to avoid sending information that is often unnecessary and useless
    for other systems, but which increases the traffic retrieved by the source application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In worst-case scenarios, every single event produced will retrieve at least
    one additional request asking for the transaction details, as shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b81c2556-b001-40b5-9827-887c498492a8.png)'
  prefs: []
  type: TYPE_IMG
- en: Downstream dependencies requesting transaction details
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we will have at least three other requests from the dependent
    systems for each event produced.
  prefs: []
  type: TYPE_NORMAL
- en: Event-carried state transfer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The event-carried state transfer pattern has a minor variation in comparison
    to the event-notification pattern discussed earlier. Here, the event contains
    very basic information related to the executed command. In this case, the event
    contains all of the information regarding the executed command that is used to
    avoid contacting the source application to perform further processing by the dependent
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern brings the following benefits to the table:'
  prefs: []
  type: TYPE_NORMAL
- en: Improves application performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduces the load on the source application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increases the availability of the system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's talk about each of these points in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Improving application performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous example, once the event was produced and retrieved by the downstream
    systems, an additional operation needed to be executed in order to obtain the
    details associated with the transaction. This determined what action needed have
    to been performed as part of the process. This additional operation involved establishing
    a communication with the source application. This step could take only a few milliseconds
    in some cases, but the response time could take longer depending on the network
    traffic and latency. This would then influence the performance of the dependent
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, the size of the payload provided by the source application increases,
    but less traffic is required.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing the load on the source application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since all the information associated with the executed command is included as
    part of the produced event, there is no need to ask for more information about
    the source application. Consequently, there are fewer requests, reducing the load
    retrieved by the source application.
  prefs: []
  type: TYPE_NORMAL
- en: The relationship between the produced events and the requests retrieved once
    the event is emitted is 1:1 in the best-case scenarios. In other words, one request
    will produce one event, but this could be even worse depending on how many dependent
    systems need to ask for additional information when the event is retrieved.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid this extra load, all downstream systems often have their own data
    storage in which the events information is persisted, as shown by the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94465532-3b0f-4da2-816a-c233a82f9d2c.png)'
  prefs: []
  type: TYPE_IMG
- en: Downstream dependencies persisting events data
  prefs: []
  type: TYPE_NORMAL
- en: When using this approach, each one of the downstream systems only stores the
    data that is relevant to itself, and the rest of the information provided is ignored
    because it is useless for the system, and won't be used at all.
  prefs: []
  type: TYPE_NORMAL
- en: Increasing the availability of the system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After removing the need to ask for additional data once the event has been retrieved,
    it's natural to assume that the availability of the system has increased as, no
    matter whether the other systems are available or not, the event will be processed.
    An indirect consequence of introducing this benefit is the eventual consistency
    that is now part of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Eventual consistency is a model that is used to achieve high availability in
    the systems where, if no new updates are made to the given data, once a piece
    of information has been retrieved, all instances of accessing that data will eventually
    return the last updated value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how a system changes its data without propagating
    these changes to the downstream dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee803ce8-493c-4991-9b50-5f7e8bdb2b73.png)'
  prefs: []
  type: TYPE_IMG
- en: Data updates are not propagated
  prefs: []
  type: TYPE_NORMAL
- en: 'To change the preceding example so that it follows this approach, we only need
    to include additional information as part of the payload. Previously, we just sent
    a `String` with the `clientId`; now we are going to cover the complete `TransactionMoneyDetails`
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `Message` class can support any kind of object that should be specified
    within `<>`, since this class is implemented using the generic types feature from
    Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'The downstream-dependent systems should also be modified to make them able
    to retrieve an object instead of a simple string. Since the `Handler` to process
    incoming messages also supports generics, we can implement this feature with a
    small change in the code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Event sourcing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Event sourcing is another way to implement applications using an event-driven
    approach, where the core of the functionality is based on the use of commands
    that produce events that change the system state once they have been processed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can think of a command as the result of a transaction executed within the
    system. This transaction would be different depending on factors such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: User actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Messages received from other applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduled tasks performed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications created using an event-sourcing approach store the events associated
    with the executed commands. It's also worth storing the commands that produced events.
    This makes it possible to correlate all of them in order to get an idea of the
    boundaries that were created.
  prefs: []
  type: TYPE_NORMAL
- en: The main reason to store events is to use them whenever you want to rebuild
    the system state at any point in time. A way to make this task easier is by periodically generating
    backups for the database that stores the system state, which is helpful for avoiding
    the need to reprocess all the events that were created since the application started
    to work. Instead, we will just need to process the set of events that were executed
    after the database snapshot was generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review the following set of diagrams to understand how this works. The
    first diagram shows that once `Command A` is executed, three `Events` are created,
    and a new `State` is generated after each one of them is processed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f6c21ae3-3c05-481c-9dd0-bdad5e083381.png)'
  prefs: []
  type: TYPE_IMG
- en: Events and application states generated once Command A is executed
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram represents quite a similar process. In this case, two
    `Events` were created as a result of the `Command B` execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec22155e-8a04-4229-8737-b9c760246dfa.png)'
  prefs: []
  type: TYPE_IMG
- en: Events and application states generated as the result of the Command B execution
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, our application has five states:'
  prefs: []
  type: TYPE_NORMAL
- en: State A
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State B
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State D
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State E
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s say we are interested in debugging `Event b-1` because, when it was
    executed, the application crashed. To achieve this goal, we have two options:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Process the events one by one and study the application behavior during the
    `Event b-1` execution, as shown in the following diagram:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/f60ed164-0460-4e56-b547-166613859f2a.png)'
  prefs: []
  type: TYPE_IMG
- en: Rebuilding the application state processing all the events
  prefs: []
  type: TYPE_NORMAL
- en: 'Process the rest of the events after restoring a database snapshot and study
    the application behavior during the `Event b-1` execution, as shown in the following
    diagram:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/f946d555-0508-4806-9395-bfc09324b89a.png)'
  prefs: []
  type: TYPE_IMG
- en: Rebuilding the application state from a database snapshot
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, the second approach is much more efficient. Scheduled tasks are often
    in charge of creating database snapshots after a certain period of time, and a
    policy should be established to manage the existing snapshots. For example, you
    can establish a policy to create a new snapshot every single day at midnight and
    get rid of old snapshots after the most convenient period of time for your business.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may have realized, the source of truth for our system is the events
    storage, which allows us to rebuild the application state at any time. Since the
    events are being used to generate the system state, we can 100% rely on the events
    storage. However, we should also consider the fact that an event execution within
    a system would also require interaction with another application. In this case,
    if you replay that event, you should think about how the other system(s) will
    be affected. Here, we would end up with one of the two following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: The operations executed in the other application(s) are idempotent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other application(s) will be affected because a new transaction will be
    generated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first case, since the operations are idempotent, we don't have to be
    worried at all. This is because another execution will not affect the other system(s).
    In the second case, we should consider a way to create compensation operations
    or a way to ignore these interactions to avoid affecting the other systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The inherent benefits that we are going to have after following this approach
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A data store that can be used for auditing purposes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An excellent logging level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will be easier to debug an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A historic state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to go back in time to a previous version of the state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The quintessential example for event-sourcing applications is version control
    systems (VCS) such as Git, Apache subversion, CVS, or any other version control
    system where all the changes that are applied in the source code files are stored.
    Furthermore, the commits represent the events that allow us to undo/redo changes
    when required.
  prefs: []
  type: TYPE_NORMAL
- en: In order to make it as simple as possible to understand, you can think of an
    event-sourcing application as something that manages data changes in the same
    way that a version control system manages file changes. You can also think about
    a `git push` operation as a command in an event-sourcing system.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have explained the underlying concepts behind event sourcing, it's
    time to dive into details that will allow us to understand how to implement a
    system following this approach. Although there are different ways to create event-sourcing
    applications, I'll explain a generic way to do it here. It is important that you
    keep in mind that this approach should be changed depending on the particular
    needs or assumptions that you need for your business.
  prefs: []
  type: TYPE_NORMAL
- en: 'We mentioned that an event-sourcing system should have *at least* two places
    in which to store the data. One of these will be used to save event and command
    information and the other one will be used to save the application state—we say *at
    least two* because more than one storage option is sometimes needed to persist
    the system state of an application. Since the input retrieved by the system to
    perform their business processes are very different from each other, we should
    consider using a database that supports the ability to store data using a JSON
    format. Following this approach, the most basic data that should be stored as
    part of a command that is executed within an event-sourcing system is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Unique identifier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timestamp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input data retrieved in JSON format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any additional data to correlate commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the other hand, the recommended data that should be stored for an event
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Unique identifier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timestamp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relevant data for the event in JSON format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifier of the command that generated the event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we mentioned earlier, depending on your business needs, you would need to
    add more fields, but the ones mentioned earlier are necessary in any case. The
    key here is to make sure that your data will be able to be processed later to
    recreate the application state when that's needed. Almost any NoSQL database has
    support to store data as JSON, but some SQL databases, such as PostgreSQL, can also deal
    with data in this format very well.
  prefs: []
  type: TYPE_NORMAL
- en: On the subject of the system state, the decision of choosing an SQL or NoSQL
    technology should completely depend on your business; you don't have to change
    your mind just because the application will be built using an event-sourcing approach.
    Furthermore, the structure of your data model should also depend on the business
    itself rather than on the events and commands that generate the data that will
    be stored there. It is also worth mentioning that one event will generate data
    that will be stored in one or more tables of the system state data model, and
    there are no restrictions at all in these terms.
  prefs: []
  type: TYPE_NORMAL
- en: When we think about commands, events, and states, a question that is usually raised is
    with regards to the order in which the information is persisted. This point would
    be an interesting discussion, but you don't have to worry too much about the order
    in which the data was persisted. You can choose to persist the data synchronously
    or asynchronously in any of the data storage instances.
  prefs: []
  type: TYPE_NORMAL
- en: An asynchronous approach sometimes leads us to think that we will end up having inconsistent
    information, but the truth is that both approaches could lead us to that point.
    Instead of thinking about synchronous or asynchronous processing, we should consider
    mechanisms to recover our app from these crashes, such as proper logging, for
    example. Good logging would be helpful for recovering the data of our systems
    in exactly the same way as we do for applications that are built using any approach
    other than event sourcing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time to review some code to put the concepts that we discussed previously into
    practice. Let''s build an application that allows us to open a new bank account.
    The input data required will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Customer name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customer last name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An initial amount of money to open the account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Account type (savings/current)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After creating the account, our application state should reflect one new customer
    and a new bank account that has been created.
  prefs: []
  type: TYPE_NORMAL
- en: 'As part of our application, we will have one command: `CreateCustomerCommand`.
    This will generate two events, named `CustomerCreated` and `AccountCreated`, as
    shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5fed95d8-d882-458b-95b7-a620e8cca665.png)'
  prefs: []
  type: TYPE_IMG
- en: Command execution
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this command is executed, a few things need to happen:'
  prefs: []
  type: TYPE_NORMAL
- en: The command should be saved
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The aforementioned events should be created with the relevant information for
    them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The events should be saved
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The events should be processed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The relevant code for this process is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the events are handled, the system state should be generated. In this
    case, it means a new customer and a new account should be created, as shown in
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/81d1803c-8298-447b-8c39-f0c895be5c6b.png)'
  prefs: []
  type: TYPE_IMG
- en: System state generated after processing the events
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this goal, we have a pretty basic implementation that, depending
    on `event name`, executes code instructions, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to see how the application works, you can execute the following
    `CURL` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following messages in the console :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can check the system state by executing SQL statements in the H2 web console
    available in the URL: `http://localhost:8080/h2-console`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the result of querying the Account table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d25011b-0d29-4562-ae98-4001cb3b9e9a.png)'
  prefs: []
  type: TYPE_IMG
- en: Query result from the Account table
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the result of querying the Customer table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b0f50a8-6983-46bb-aaf7-caef238a3c68.png)'
  prefs: []
  type: TYPE_IMG
- en: Query result from the Customer table
  prefs: []
  type: TYPE_NORMAL
- en: 'The most crucial test for an event-sourcing application is the ability to recreate
    the `state` once the data is deleted. You can run this test by deleting the data
    from the table using the following SQL statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After executing these operations in the H2 console, you can recreate the state
    by running the following `CURL` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note that you will need to replace the `<EVENT_ID>` listed in the preceding
    URL with the values listed in the console when the command was executed.
  prefs: []
  type: TYPE_NORMAL
- en: CQRS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Command-Query Responsibility Segregation** (**CQRS**) is a pattern in which
    the main idea is to create separate data structures and operations to read and
    write data by creating segregated interfaces to interact with the system''s data
    storage.'
  prefs: []
  type: TYPE_NORMAL
- en: 'CQRS is not really based on events, but since it''s often used in conjunction
    with event-sourcing implementations, it is worth mentioning the scenarios in which
    it would be applied. There are three main use cases where the segregation of interfaces
    to process and query information would be useful:'
  prefs: []
  type: TYPE_NORMAL
- en: Complex domain model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distinct paths to query and persist information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Independent scaling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complex domain models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This scenario refers to systems where the inputs retrieved are simple to manage
    and persist in the database. However, before delivering information to users,
    many transformations are needed to make the data useful and comprehensive for
    the business.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a system where the code is comprised of a large set of entity objects
    mapping database tables to persist information using an ORM framework. This kind
    of system involves many writes and read operations that are executed using the
    ORM and some operations that run as part of the system to transform the retrieved
    data—in the form of entity objects—into data transfer objects (DTOs) to provide
    information in a meaningful way for the business.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the dataflow from the database to the business
    services that is designed to follow this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c07aa513-2d26-423b-a48a-81d0d1bb2d37.png)'
  prefs: []
  type: TYPE_IMG
- en: Dataflow using entity objects and DTOs
  prefs: []
  type: TYPE_NORMAL
- en: Transforming data is not a big deal. In systems using an ORM, the biggest problem arises
    when entity objects bring columns containing useless information that is ignored
    during the transformation process, introducing an unnecessary overhead on the
    database and the network. On the other hand, in the preceding diagram, we can
    see that a big process is needed to map the database tables as objects before actually
    getting the requested data. A good approach to getting rid of this problem is
    to replace the read operations executed by the ORM frameworks with stored procedures
    or plain query statements to retrieve only the required data from the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how entity objects can be replaced with DOTs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/08280105-b441-4ee5-b9e8-7e9b1a1d03eb.png)'
  prefs: []
  type: TYPE_IMG
- en: Data flow using DTOs
  prefs: []
  type: TYPE_NORMAL
- en: It's evident that this approach is much more simple and easy to accomplish.
    Even the amount of code required is drastically reduced. I'm not concluding that
    ORM frameworks are bad—actually, many of them are awesome, and projects such as
    Spring Data provide tons of built-in features. However, depending on the business
    requirements, plain JDBC operations are sometimes much more beneficial for the
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Distinct paths to query and persist information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we are building applications, it's quite common to find ourselves writing
    tons of validations on the retrieved input before using the provided information
    in the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Common validations applied to the retrieved data include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Verification for non-null values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specific text formats, such as emails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checks to validate string lengths
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The maximum quantity of decimals allowed in numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many mechanisms available for implementing this kind of validation
    within our code. The most popular of these are based on third-party libraries
    that rely on annotations that can be extended using regular expressions for specific
    scenarios. There is even a specification that is part of the platform that can
    be used to validate class fields called Bean Validation. This is currently part
    of the **Java Specification Request** (**JSR**) **380** ([http://beanvalidation.org/](http://beanvalidation.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: While it is essential to have all these validations when users or external systems
    provide the data, there is no need to keep performing these checks when the information
    is read from the database and returned to the user. Furthermore, in some cases,
    such as event sourcing, once the data is retrieved, some commands are executed,
    events are created, and at the end, the information is persisted.
  prefs: []
  type: TYPE_NORMAL
- en: In these scenarios, it is apparent that the processes to persist and read information
    are different, and they need separate paths in order to accomplish their goals.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how an application uses different paths to persist
    and retrieve data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7abf67f1-4d20-4321-a20c-9d332f8adaf3.png)'
  prefs: []
  type: TYPE_IMG
- en: Data persisted and queried using different paths
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding diagram, we can quickly note how much processing is avoided
    because it is absolutely unnecessary. Furthermore, the domain models used to query
    and process the information are often different because they are tailored to accomplish
    different goals.
  prefs: []
  type: TYPE_NORMAL
- en: Independent scaling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today, it's common to hear developers, software architects, and technical people
    in general talking about creating separate services to solve different needs.
    Creating separate services supports the independent scaling approach because it
    makes it possible to scale the created services separately.
  prefs: []
  type: TYPE_NORMAL
- en: The main idea, in this case, is creating separate systems that can be built
    and deployed independently. The source of data for these different applications
    can either be the same or different, depending on what the requirements are. The
    most common scenario here is where the same data storage is used for both systems
    because the applied changes should be immediately reflected. Otherwise, delayed
    data could cause confusion or errors during the normal operation of an application.
  prefs: []
  type: TYPE_NORMAL
- en: Let's think about an online store. Imagine that you added many items to your
    shopping cart, and after checking out your order, you realize you paid a lower
    amount of money than required because not all items were considered during the
    check-out process. This is undesired behavior within an application.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, in some cases, it is okay to use different data storage because
    retrieving data that is delayed by hours or days is enough to solve the business
    needs associated with an application. Imagine that you are tasked with creating
    a report showing the months when people tend to request vacations. Of course,
    a database that does not have the latest changes, and is a bit behind the current
    state of the application, will work perfectly. When we have this kind of requirement, we
    can use reporting databases (see [https://martinfowler.com/bliki/ReportingDatabase.html](https://martinfowler.com/bliki/ReportingDatabase.html)
    for more details) to retrieve the information. This approach is often taken when
    an application is intended to provide executive reporting information for taking
    strategic decisions rather than getting a list of all the existing records in
    the database tables.
  prefs: []
  type: TYPE_NORMAL
- en: Having separate systems to query and process information gives us the benefit
    of independent scaling capabilities on both systems. This is useful when one of
    the systems requires many more resources for processing. Let's take the example of
    the online store mentioned previously—people are always looking for items to buy,
    making comparisons, checking sizes, prices, brands, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, the number of requests to check out orders is less
    than the number of requests to check for item information. So, in this case, having
    separate systems allows us to avoid unnecessarily wasting resources and allows
    us to only add more resources or instances of the service that has the highest
    volume of traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered event-driven architectures and the four common patterns
    that are used to implement applications using this architectural style. We explained
    each of these patterns in detail, and wrote some code to understand how they can
    be implemented using Spring Framework. At the same time, we looked at some use
    cases where they can be utilized, and learned how they help us to reduce the complexity
    that is introduced as part of the system requirements that we would eventually
    have.
  prefs: []
  type: TYPE_NORMAL
- en: As part of these patterns, we talked about event sourcing, which is getting
    more and more popular within the microservices world, and which we will learn
    about later in [Chapter 8](7c38500a-5a66-422b-a41b-21f4fd18de51.xhtml), *Microservices*.
  prefs: []
  type: TYPE_NORMAL
