- en: Threading and Concurrency
  prefs: []
  type: TYPE_NORMAL
- en: A process is essentially a program that is executing on an operating system.
    This process is made up of more than one thread of execution. A thread of execution
    is a set of commands issued by a process. The ability to execute more than one
    thread at a time is known as **multi-threading**. In this chapter, we are going
    to look at multi-threading and concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple threads are allotted a set amount of time to execute, and each thread
    is executed on a rotational basis by a thread scheduler. The thread scheduler
    schedules the threads using a technique called **time slicing** and then passes
    each thread to the CPU to be executed at the scheduled time.
  prefs: []
  type: TYPE_NORMAL
- en: '**Concurrency** is the ability to run more than one thread at exactly the same
    time. This can be accomplished on computers with more than one processor core.
    The more processor cores a computer has, the more threads of execution can be
    executed concurrently.'
  prefs: []
  type: TYPE_NORMAL
- en: As we look at concurrency and threading in this chapter, we will encounter the
    problems of blocking, deadlocks, and race conditions. You will see how we can
    overcome these problems using clean coding techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the course of this chapter, we will cover each of the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the thread life cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding thread parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a thread pool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a mutual exclusion object with synchronous threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with parallel threads using semaphores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limiting the number of processors and threads in the thread pool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing deadlocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing race conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding static constructors and methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutability, immutability, and thread safety
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronized method dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `Interlocked` class for simple state changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: General recommendations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After working through this chapter and developing your threading and concurrency
    skills, you will have acquired the following skills:'
  prefs: []
  type: TYPE_NORMAL
- en: The ability to understand and discuss the thread life cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An understanding of and ability to use foreground and background threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to throttle threads and set the number of processors to use concurrently
    using a thread pool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to understand the effects of static constructors and methods in
    relation to multi-threading and concurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to take into account mutability and immutability and their impact
    on thread safety
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to understand what causes race conditions and how to avoid them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to understand what causes deadlocks and how to avoid them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to perform simple state changes using the `Interlocked` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To run through the code in this chapter, you will need a .NET Framework console
    application. Unless otherwise stated, all code will be placed in the `Program`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the thread life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Threads in C# have an associated life cycle. The life cycle for threads is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f574fc2-1ade-4f26-9ecf-52f3cecde092.png)'
  prefs: []
  type: TYPE_IMG
- en: When a thread starts, it enters the **running** state. When running, the thread
    can enter a **wait**, **sleep**, **join**, **stop**, or **suspended **state. Threads
    can also be aborted. Aborted threads enter the stop state. You can suspend and
    resume a thread by calling the `Suspend()` and `Resume()` methods, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: A thread will enter the wait state when the `Monitor.Wait(object obj)` method
    is called. The thread will then continue when the `Monitor.Pulse(object obj)`
    method is called. Threads enter sleep mode by calling the `Thread.Sleep(int millisecondsTimeout)`
    method. Once the elapsed time has passed, the thread returns to the running state.
  prefs: []
  type: TYPE_NORMAL
- en: The `Thread.Join()` method causes a thread to enter the wait state. A joined
    thread will remain in the wait state until all dependent threads have finished
    running, upon which it will enter the running state. However, if any dependent
    threads are aborted, then this thread is also aborted and enters the stop state.
  prefs: []
  type: TYPE_NORMAL
- en: Threads that have completed or have been aborted cannot be restarted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Threads can run in the foreground or the background. Let''s look at both foreground
    and background threads, starting with foreground threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Foreground threads**: By default, threads run in the foreground. A process
    will continue to run while at least one foreground thread is currently running.
    Even if `Main()` completes but a foreground thread is running, the application
    process will remain active until the foreground thread terminates. Creating a
    foreground thread is really simple, as the following code shows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Background threads**: You create a background thread in the same way that
    you create foreground threads, except that you also have to explicitly set a thread
    to run in the background, as shown:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Background threads are used to carry out background tasks and keep the user
    interface responsive to the user. When the main process terminates, any background
    threads that are executing are also terminated. However, even if the main process
    terminates, any foreground threads that are running will run to completion.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at thread parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Adding thread parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Methods that run in threads often have parameters. So, when executing a method
    within a thread, it is useful to know how to pass the method parameters into the
    thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that we have the following method, which adds two integers together
    and returns a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the method is simple. There are two parameters called `a` and
    `b`. These two parameters will need to be passed into the thread for the `Add()`
    method to run properly. We will add an example method that will do just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this method, we declare an integer with an initial value of `0`. We then
    create a new thread that calls the `Add()` method with the `1` and `2` parameter
    values, and then assign the result to the integer variable. The thread then starts
    and we wait for it to finish executing by calling the `Join()` method. Finally,
    we print the result to the console window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add our `Message()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Message()` method simply takes a string and outputs it to the console
    window. All we have to do now is update the `Main()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `Main()` method, we call our example method and then wait for the user
    to press any key before exiting. You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d13b988-cbf1-4b6f-a5f1-8e5ecabdb34b.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, `1` and `2` were the method parameters passed into the addition
    method, and `3` was the value returned by the thread. The next topic we will look
    at is using a thread pool.
  prefs: []
  type: TYPE_NORMAL
- en: Using a thread pool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A thread pool improves performance by creating a collection of threads during
    application initialization. When a thread is required, it is assigned a single
    task. That task will be executed. Once executed, the thread is returned to the
    thread pool to be reused.
  prefs: []
  type: TYPE_NORMAL
- en: Since thread creation is expensive in .NET, we can improve performance by using
    a thread pool. Each process has a fixed number of threads based on the system
    resources available, such as memory and the CPU. However, we can increase or decrease
    the number of threads used by the thread pool. It is normally best to let the
    thread pool take care of how many threads to use, rather than manually setting
    these values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The different ways to create a thread pool are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the **Task Parallel Library** (**TPL**) (on .NET Framework 4.0 and higher)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `ThreadPool.QueueUserWorkItem()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using asynchronous delegates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `BackgroundWorker`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a rule of thumb, you should only use a thread pool for server-side applications.
    For client-side applications, use foreground and background threads, as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will just look at the **TPL** and the `QueueUserWorkItem()`
    method. You can check out how to use the other two methods at [http://www.albahari.com/threading/](http://www.albahari.com/threading/).
    We'll look at the TPL next.
  prefs: []
  type: TYPE_NORMAL
- en: Task Parallel Library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An asynchronous operation in C# is represented by a task. A task in C# is represented
    by the `Task` class in the TPL. As you will gather from the name, task parallelism
    enables multiple tasks to be executed concurrently, which we will learn about
    in the following subsections. The first `Parallel` class method we will look at
    is the `Invoke()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel.Invoke()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In our first example, we will invoke three separate methods using `Parallel.Invoke()`.
    Add the following three methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, these three methods are almost identical, apart from their
    names and the message printed to the console window via the `Message()` method
    we wrote earlier. Now, we''ll add the `UsingTaskParallelLibrary()` method to execute
    these three methods in parallel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this method, we write a message to the console window indicating the start
    of the method. We then invoke the `MethodOne`, `MethodTwo`, and `MethodThree` methods in
    parallel. Then, we write a message to the console window indicating that the method
    has reached its end, and then we wait for a key to be pressed before exiting the
    method. Run the code and you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/320d0805-ddc4-4c24-a70d-3faea45cafd6.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, you can see that thread one is reused. Let's now
    move on to the `Parallel.For()` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel.For()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In our next TPL example, we will look at a simple `Parallel.For()` loop. Add
    the following method to the `Program` class of a new .NET Framework console application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'All this method does is output a string to the console window. We''ll now create
    the method that executes the `Parallel.For()` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this method, we loop through `0` to `1000`, calling `Method()`. You will
    see how the threads are reused with the different method calls, as in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b4ae2005-16d0-422a-81aa-00d07a93a8db.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we will look at using the `ThreadPool.QueueUserWorkItem()` method.
  prefs: []
  type: TYPE_NORMAL
- en: ThreadPool.QueueUserWorkItem()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ThreadPool.QueueUserWorkItem()` method accepts a `WaitCallback` method
    and queues it ready for execution. `WaitCallback` is a delegate that represents
    a callback method to be executed by a thread pool thread. When a thread becomes
    available, the method is executed. Let''s add a simple example. We''ll start by
    adding `WaitCallbackMethod`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This method accepts a type of object. However, since the parameter will be
    unused, we use the discard variable (`_`). A message is printed to the console
    window. Now, all we need is the code to call the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we use the `ThreadPool` class to queue `WaitCallbackMethod()` in
    the thread pool via the call to the `QueueUserWorkItem()` method. We then do some
    work on the main thread. The main thread then goes to sleep. A thread becomes
    available from the thread pool and `WaitCallBackMethod()` is executed. The thread
    is then returned back to the thread pool to be reused. Execution returns to the
    main thread, which then completes and terminates.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss thread-locking objects, known as **Mutual
    Exclusion Objects **(**m****utexes**).
  prefs: []
  type: TYPE_NORMAL
- en: Using a mutex with synchronous threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C#, a mutex is a thread-locking object that works across multiple processes.
    Only a process that can request or release a resource can modify the mutex. When
    a mutex is locked, the process will have to wait in a queue. When the mutex is
    unlocked, then it can be accessed. Multiple threads can use the same mutex, but
    only in a synchronous manner.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of using a mutex are that a mutex is a simple lock obtained before
    entering a critical piece of code. That lock is released when the critical piece
    of code is exited. Because only a single thread is in the critical piece of code
    at any one time, the data will remain in a consistent state as there will be no
    race conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several disadvantages to using a mutex:'
  prefs: []
  type: TYPE_NORMAL
- en: Thread starvation occurs when a thread is unable to move forward as an existing
    thread has obtained a lock and has either gone to sleep or is pre-empted (prevented
    from completing its task).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a mutex is locked, only the thread that obtained the lock can unlock it.
    No other thread can lock or unlock it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only one thread at a time is allowed to enter the critical piece of code. CPU
    time can be wasted as the normal implementation of a mutex may lead to a *busy
    waiting* state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will now write a program that demonstrates the use of a mutex. Start a new
    .NET Framework console application. Add the following line to the top of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have declared a primitive called `_mutex`, which we will use for inter-process
    synchronization. Now, add a method to demonstrate thread synchronization using
    a mutex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In this method, the current thread is blocked until the current wait handle
    receives a signal. Then, when the signal is given, it is safe for the next thread
    to enter. Upon completion, other threads are unblocked from trying to gain ownership
    of the mutex. Next, add the `MutexExample()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In this method, we create 10 threads and start them. Each thread executes the
    `ThreadSynchronisationUsingMutex()` method. Now, finally, update the `Main()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Main()` method runs our mutex example. The output should be similar to
    the one in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb8cc4bd-8486-4e2d-b085-c4d9f0915b5b.png)'
  prefs: []
  type: TYPE_IMG
- en: Run the example again and you may end up with different thread numbers. If they
    are the same numbers, then they may be in different orders.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have looked at mutexes, let's look at semaphores.
  prefs: []
  type: TYPE_NORMAL
- en: Working with parallel threads using semaphores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In multi-threaded applications, a non-negative number, known as a **semaphore**,
    is shared between threads that have a number of `1` or `2`. In terms of synchronization, `1`
    specifies *wait* and `2` specifies *signal*.We can associate a semaphore with
    a number of buffers, which can each be worked on simultaneously by different processes.
  prefs: []
  type: TYPE_NORMAL
- en: So, essentially, semaphores are signaling mechanisms of the integer and binary
    primitive types that can be modified by wait and signal operations. If there are
    no free resources, then processes that require a resource should execute the wait
    operation until the semaphore value is *greater than 0*. Semaphores can have multiple
    program threads and they can be changed by any object, obtaining a resource or
    releasing it.
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of using semaphores are down to the fact that more than one thread
    can access the critical piece of code. A semaphore is executed in the kernel and
    is machine-independent. The critical piece of code is protected from multiple
    processes if you use semaphores. Unlike a mutex, a semaphore never wastes processing
    time and resources.
  prefs: []
  type: TYPE_NORMAL
- en: Just like a mutex, semaphores also have their own set of disadvantages. Priority
    inversion is one of the biggest disadvantages and occurs when a high-priority
    thread is forced to wait for a semaphore to be released by its low-priority owning
    thread.
  prefs: []
  type: TYPE_NORMAL
- en: This can be further compounded if the low-priority thread is prevented from
    completing by mid-priority threads prior to their release. This is known as **unbounded
    priority inversion** because we can no longer predict the delay to the high-priority
    thread. With semaphores, the operating system must keep track of all wait and
    signal calls.
  prefs: []
  type: TYPE_NORMAL
- en: Semaphores are used by convention, but they are not forced. You need to execute
    wait and signal operations in the correct order; otherwise, you risk deadlocks
    in your code. Because of the complexity of using semaphores, there may be times
    when a mutual exclusion cannot be obtained. Loss of modularity in large systems
    is also another drawback and semaphores are prone to programming errors that result
    in deadlocks and mutual exclusion violation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to write a program now that demonstrates the use of semaphores:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We have added a new semaphore variable. The first parameter states the initial
    number of requests for the semaphore that can be granted concurrently. The second
    parameter states the maximum number of requests for the semaphore that can be
    granted concurrently. Add the `StartSemaphore()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The current thread is blocked until the current wait handle receives a signal.
    The thread can then do its work. Finally, the semaphore is released and the count
    returns to the previous count. Now, add the `SemaphoreExample()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This example generates 10 threads, which execute the `StartSemaphore()` method.
    Let''s update the `Main()` method to run the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Main()` method calls `SemaphoreExample()` and then waits for a user keypress
    to exit. You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/33cf6f91-f372-464f-b382-81a7646148a4.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's move on to look at how we limit the number of processors and threads in
    the thread pool.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting the number of processors and threads in the thread pool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There may be times when you need to limit the number of processors and threads
    used by your computer program.
  prefs: []
  type: TYPE_NORMAL
- en: 'To reduce the number of processors that your program uses, you obtain the current
    process and set its processor affinity value. For example, say that we have a
    four-core computer and we want to limit our usage to the first two cores. The
    binary value for the first two cores is `11`, which is `3` in integer form. Now,
    let''s add a method to a new .NET Framework console application and call it `AssignCores()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We pass in an integer to the method. This integer value will be converted into
    a binary value by .NET Framework. That binary value will use the processors identified
    by the value of `1`. For binary values of `0`, the processors will not be used.
    So, since machine code is represented by binary numbers, `0110` (`6`) will use
    cores `2` and `3`, `1100` (`3`) will use cores `1` and `2`, and `0011` (`12`)
    will use cores `3` and `4`.
  prefs: []
  type: TYPE_NORMAL
- en: If you want a refresher on binary, refer to [https://www.computerhope.com/jargon/b/binary.htm](https://www.computerhope.com/jargon/b/binary.htm).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to set the maximum number of threads, we call the `SetMaxThreads()` method
    on the `ThreadPool` class. This method takes two parameters, which are both integers.
    The first parameter is the maximum number of worker threads in the thread pool
    and the second parameter is the maximum number of asynchronous I/O threads in
    the thread pool. We''ll now add our method to set the maximum number of threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it is pretty straightforward to set thread maximums and processors
    in your programs. Most of the time, you will not have to do this in your programs.
    The main reason for manually setting the number of threads and/or processors to
    use in your program is for if your programs run into performance issues. If your
    program does not experience performance issues, then it is best not to set the
    number of threads or the number of processors.
  prefs: []
  type: TYPE_NORMAL
- en: The next topic we will look at is deadlocks.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing deadlocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **deadlock** occurs when two or more threads are executed and are waiting
    for each other to finish. This problem manifests in computer programs when they
    hang. For the end user, this can be very bad and can result in the loss or corruption
    of data. An example of this is executing two batches of data input that crash
    halfway through a transaction and cannot be rolled back. This is not good; let
    me explain why with an example.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a major banking transaction that will take £1 million out of a customer's
    business bank account to pay their **Her Majesty's Revenue and Customs** (**HMRC**)
    tax bill. The money is taken from the business account, but before the money is
    deposited in the HMRC bank account, a deadlock occurs. There is no recovery option
    and so the application has to be terminated and restarted. As a result, the business
    bank account is reduced by £1 million but the HMRC tax bill has not been paid.
    The customer is still liable to pay the tax bill. But what happens to the money
    that has been taken out of the account? So, you can see the importance of removing
    the possibility of deadlocks occurring due to the problems they can cause.
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep things simple, we will deal with two threads, shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6547929-7a72-40da-817a-87481d5face9.png)'
  prefs: []
  type: TYPE_IMG
- en: We will call our threads Thread 1 and Thread 2 and our resources Resource 1 and Resource
    2\. Thread 1 obtains a lock on **Resource 1**. **Thread 2** obtains a lock on **Resource
    2**. **Thread 1** requires access to **Resource 2** but has to wait because **Thread
    2** has locked **Resource 2**. **Thread 2** requires access to **Resource 1** but
    has to wait because **Thread 1** has locked **Resource 1**. This results in both **Thread
    1** and **Thread 2** being in a wait state. Since neither thread can continue
    until the other thread releases its resource, both threads are in a **deadlock
    situation**. When a computer program is in a deadlock situation, it *hangs*, forcing
    you to terminate the program.
  prefs: []
  type: TYPE_NORMAL
- en: A code example of a deadlock will be a nice way to illustrate this, and so in
    the next section, we will code a deadlock example.
  prefs: []
  type: TYPE_NORMAL
- en: Coding a deadlock example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The best way to understand this is with a working example. We are going to write
    some code consisting of two methods that have two different locks each. They will
    both lock objects that the other method needs. Because each thread locks the resources
    that the other thread needs, they will both enter a deadlock state. Once we have
    our example working, we will then modify it so that our code recovers from the
    deadlock situation and is able to continue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new .NET Framework console application and call it `CH08_Deadlocks`.
    We will need two objects as member variables, so let''s add them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'These objects will be used as our lock objects. We will have two threads, and
    each thread will execute its own method. Now, add `Thread1Method()` to your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`Thread1Method()` obtains a lock on `_object1`. It then sleeps for 1 second.
    When it awakes, a lock is obtained on `_object2`. The method then exits both locks
    and terminates.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Thread2Method()` obtains a lock on `_object2`. It then sleeps for 1 second.
    When it awakes, a lock is obtained on `_object1`. The method then exits both locks
    and terminates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, we now have our two methods in place to demonstrate a deadlock. We just
    need the code to call them in a way that will cause a deadlock. Let''s add the `DeadlockNoRecovery()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `DeadlockNoRecovery()` method, we create two threads. Each thread is
    assigned a different method. Then, each thread is started. The program is then
    paused until the user presses a key. Now, update the `Main()` method and run your
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run your program, you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3cc47b74-1c00-4540-b392-39a9b241a776.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, because `thread1` has locked `_object1`, `thread2` is blocked
    from obtaining a lock on `_object1`. Also, because `thread2` has locked `_object2`,
    `thread1` is blocked from obtaining a lock on `_object2`. So, both threads are
    in deadlock and the program hangs.
  prefs: []
  type: TYPE_NORMAL
- en: We will now write some code that demonstrates how to avoid this deadlock situation
    from occurring. We will be using the `Monitor.TryLock()` method to try and obtain
    a lock within a certain number of milliseconds. We will then exit a successful
    lock with `Monitor.Exit()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the `DeadlockWithRecovery()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DeadlockWithRecovery()` method creates two foreground threads. It then
    starts the threads, prints a message to the console, and waits for the user to
    press a key before exiting. We will now add the code for `Thread4Method()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`Thread4Method()` sleeps for 1 second. It then tries to get a lock on `_object1`.
    If it fails to get a lock on `_object1`, it returns from the method. If a lock
    on `_object1` is obtained, then it tries to get a lock on `_object2`. If a lock
    on `_object2` can''t be obtained, then it returns from the method. If a lock is
    obtained on `_object2`, then it performs the necessary work on `_object2`. The
    lock on `_object2` is then released, and then the lock on `_object1` is released.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Thread5Method()` method does exactly the same thing, except the objects—`_object1`
    and `_object2`—are locked in reverse order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add the `DeadlockWithRecovery()` method call to your `Main()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run your code a few times. The majority of the time, you will see what
    is in the following screenshot, where all the locks have been successfully obtained:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa0d5689-7404-4341-9bb8-880b35507571.png)'
  prefs: []
  type: TYPE_IMG
- en: Then, press any key and the program will exit. If you keep running the program,
    you will eventually find a lock that fails. The program failed to get a lock on `_object2` in `Thread5Method()`.
    However, if you press any key, the program will exit. As you can see, by using
    `Monitor.TryEnter()`, you can try and lock an object. But if the lock is not obtained,
    then you are able to take another action without your program hanging.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we look at preventing race conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing race conditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When multiple threads using the same resource produce different outcomes due
    to the timings of each thread, this is known as a **race condition**. We will
    demonstrate this in action now.
  prefs: []
  type: TYPE_NORMAL
- en: In our demonstration, we will have two threads. Each thread will call a method
    to print the alphabet. One method will print the alphabet using *uppercase letters*.
    The second method will print the alphabet using *lowercase letters*. From the
    demonstration, we'll see how the output is wrong, and every time the program is
    run, the output will be wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the `ThreadingRaceCondition()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`ThreadingRaceCondition()` produces two threads and starts them. It also references
    two methods. `Method1()` prints out the alphabet in uppercase and `Method2()` prints
    out the alphabet in lowercase. Let''s add `Method1()` and `Method2()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Both `Method1()` and `Method2()` reference the `_alphabetCharacter` variable.
    So, add the member to the top of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, update `MainMethod()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have our code in place to demonstrate the race condition. If you run
    the program multiple times, you will see that the results are not what we expect.
    You should even see characters that are not part of the alphabet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c017737-c3f3-4839-b064-e30731c5db83.png)'
  prefs: []
  type: TYPE_IMG
- en: Not exactly what we were expecting, is it?
  prefs: []
  type: TYPE_NORMAL
- en: We are going to solve this problem by using the TPL. The aim of the TPL is to
    simplify **parallelism** and **concurrency**. As most computers today have two
    or more processors, the TPL will scale the degree of concurrency dynamically to
    make the most efficient use of all the available processors.
  prefs: []
  type: TYPE_NORMAL
- en: The partitioning of work, the scheduling of threads in the thread pool, cancellation
    support, state management, and so on are also carried out by the TPL. A link to
    the official Microsoft TPL documentation can be found in the *Further reading* section
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see just how simple the solution to the aforementioned problem can
    be. We have a task that runs `Method1()`. The task then continues with `Method2()`.
    We then call `Wait()` to wait for the task to complete execution. Now, add the
    `ThreadingRaceConditionFixed()` method to your source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify your `Main()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code now. If you run it multiple times, you will see that the output
    is always the same, as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0cf0ae1c-9d51-4196-9316-36317f555b56.png)'
  prefs: []
  type: TYPE_IMG
- en: So far, we have seen what a thread is and how to use them in the foreground
    and background. We have also looked at deadlocks and how to solve them with `Monitor.TryEnter()`.
    Finally, we looked at what race conditions are and how to solve them using the
    TPL.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will move on to looking at static constructors and methods.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding static constructors and methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If multiple classes require access to a property instance simultaneously, then
    one of the threads will be requested to run the **static constructor** (also known
    as the **type initializer**). While waiting for the type initializer to run, all
    the other threads will be locked. Once the type initializer has run, the locked
    threads are unlocked and are able to access the `Instance` property.
  prefs: []
  type: TYPE_NORMAL
- en: Static constructors are thread-safe as they are guaranteed to run only once
    per application domain. They are executed before accessing any static members
    and before any class instantiation is performed.
  prefs: []
  type: TYPE_NORMAL
- en: Should an exception be raised in and escape from a static constructor, then
    `TypeInitializationException` is generated, which causes the CLR to exit your
    program.
  prefs: []
  type: TYPE_NORMAL
- en: Before any threads can access a class, static initializers and static constructors
    must finish executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Static methods** only keep a single copy of the method and its data at the
    type level. This means that the same method and its data will be shared between
    different instances. Each thread in an application has its own stack. Value types
    passed into static methods are created on the calling thread''s stack, and so
    they are thread-safe. This means that if two threads call the same code and pass
    the same value in, there will be two copies of that value—one on each thread''s
    stack. So, multiple threads will not affect each other.'
  prefs: []
  type: TYPE_NORMAL
- en: However, if you have a static method that accesses a member variable, then it
    is not thread-safe. Two different threads call the same method and so both will have
    access to the member variable. A process or context-switching occurs between threads;
    each thread will access and modify the member variable. This leads to race conditions,
    as you saw earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You also run into problems if you pass reference types into a static method,
    as different threads will have access to the same reference type. This also causes
    a race condition.
  prefs: []
  type: TYPE_NORMAL
- en: When working with static methods that will be used across threads, avoid member
    variable access and do not pass reference types in. Static methods are thread-safe
    as long as you pass in primitive types and don't modify the state.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've discussed static constructors and methods, we will run through
    some example code.
  prefs: []
  type: TYPE_NORMAL
- en: Adding static constructors to our sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start a new .NET Framework console application. Add a class called `StaticConstructorTestClass`
    to the project. Then, add a read-only static string variable called `_message`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `_message` variable is returned to the caller by the `Message()` method.
    Let''s write the `Message()` method now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This method returns the message stored in the `_message` variable. Now, we
    need to write our constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In our constructor, we write a message to the screen. We then set the member
    variable and let the thread sleep for a second. Then, we set the message again
    and write another message to the console. Now, in the `Program` class, update
    the `Main()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `Main()` method instantiates the `Program` class. The `StaticConstructorExample()`
    method is then called. When the program halts and we can see the result, we join
    threads. You can see the output in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d79fb288-6c27-4ef6-8c6d-8cfa2aa74ac3.png)'
  prefs: []
  type: TYPE_IMG
- en: We'll now take a look at examples of static methods.
  prefs: []
  type: TYPE_NORMAL
- en: Adding static methods to our sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are now going to look at thread-safe static methods and non-thread-safe
    methods in action. Add a new class called `StaticExampleClass` to a new .NET Framework
    console application. Then, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'At the top of our class, we add three integers—`_x`, `_y`, and `_z`—with values
    of `1`, `2`, and `3`, respectively. These variables can be modified between threads.
    Now, we will add a static constructor to print out the values of these variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the static constructor simply prints out the values of the
    variables to the console window. Our first method will be a thread-safe method
    called `ThreadSafeMethod()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This method is thread-safe because it only operates on by value parameters.
    It does not interact with the member variables and does not include any by reference
    values. So, no matter what values are passed in, you will always get the expected
    result.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that regardless of whether only a single thread or even millions
    of threads are accessing the method, the output for each thread will be what you
    expect when you pass in the input values, even despite context switching. The
    following screenshot shows the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/014d5718-ac04-4629-92ea-2e7e0405cc34.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have looked at thread-safe methods, it is only right that we look
    at non-thread-safe methods. By now, you know that a static method that operates
    on by reference values or static member variables is not thread-safe.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our next example, we will use a method with the same three parameters as
    `ThreadSafeMethod()`, but this time, we will set the member variables, output
    a message, go to sleep for a while, and then awake to print the values out again.
    Add the following `NotThreadSafeMethod()` method to `StaticExampleClass`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In this method, we set the member variables to the values passed into the method.
    We then output those values to the console windows and go to sleep for 300 milliseconds.
    Then, upon waking from our sleep, we print the values out again. In the `Program`
    class, update the `Main()` method, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Main()` method, we instantiate the program class, call `ThreadUnsafeMethodCall()`,
    and then wait for the user to press a key before exiting. So, let''s add `ThreadUnsafeMethodCall()`
    to the `Program` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This method produces 10 threads that call `NotThreadSafeMethod()` of `StaticExampleClass`.
    If you run the code, you will see an output similar to that in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/37710a9d-f8db-4e4d-9cb1-6bb2e7a4b3ec.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the output is not what we would expect. This is because of the
    pollution from different threads. This leads us nicely to the next section on
    mutability, immutability, and thread safety.
  prefs: []
  type: TYPE_NORMAL
- en: Mutability, immutability, and thread safety
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Mutability** is a source of bugs in multi-threaded applications. A mutable
    bug is normally a data bug caused by values being updated and shared between threads.
    To remove the risk of mutability bugs, it is best to use **immutable types**.
    The guaranteed safe execution of a body of code by multiple threads at the same
    time is called **thread safety**. When working with multi-threaded programs, it
    is important that your code is thread-safe. Your code is thread-safe if it removes
    race conditions and deadlocks, along with problems caused by mutability.'
  prefs: []
  type: TYPE_NORMAL
- en: An object that cannot be modified after it has been created is an **immutable
    object**. Once created, if passed between threads using correct thread synchronization,
    all threads will see the same valid state of an object. Immutable objects allow
    you to share data safely between threads.
  prefs: []
  type: TYPE_NORMAL
- en: An object that can be modified after it has been created is a mutable object.
    Mutable objects can have their data values changed between threads. This can lead
    to some serious data corruption. So, even if the program does not crash, it can
    leave the data in an invalid state. Therefore, when working with multiple threads
    of execution, it is important that your objects are immutable. In [Chapter 3](3d63c927-7dd3-4985-b50d-64d98c108a46.xhtml), *Classes,
    Objects, and Data Structures,* we went through creating and using immutable data
    structures for your immutable objects.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure thread safety, do not use mutable objects, pass parameters by reference,
    or modify member variables—only pass parameters by value and only operate on parameter
    variables. Do not access member variables. Immutable structures are a good and
    thread-safe way to pass data between objects.
  prefs: []
  type: TYPE_NORMAL
- en: We will take a brief look at mutability, immutability, and thread safety with
    the following examples. We'll start with mutability in terms of thread safety.
  prefs: []
  type: TYPE_NORMAL
- en: Writing code that is mutable and not thread-safe
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To demonstrate mutability within a multi-threaded application, we will write
    a new .NET Framework console application. Add a new class to the application called
    `MutableClass` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In our `MutableClass` class, we have a constructor that takes an integer array
    as an argument. A member integer array is then assigned the array passed into
    the constructor. The `GetIntArray()` method returns the integer array member variable.
    If you look at this class, you would not think it is mutable because once the
    array is passed into the constructor, the class provides no way to modify it.
    Yet, the integer array passed into the constructor is mutable. The `GetIntArray()`
    method returns a reference to the mutable array.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `Program` class, we will add the `MutableExample()` method to show that
    the integer array is mutable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `MutableExample()` method, we have declared and initiated an integer
    array of items from `0` to `9`. We then declare a new instance of `MutableClass`
    and pass in the integer array. Next, we print out the contents of the initial
    array before it is modified. Then, we loop nine times. For each iteration, we
    increase the array at the index specified by the current loop count value of `x` so
    that it equals `x + 1`. After that, we start the thread. Now, update the `Main()`
    method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `Main()` method simply calls `MutableExample()` and then waits for a keypress.
    Run the code and you should see something as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/56fe7d8d-f687-47a3-86f6-909b4dfad3f1.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, even though we only created one instance of `MutableClass` before
    creating and running our threads, changing the local array modifies the array
    in the instance of `MutableClass`. This proves that the arrays are mutable, and
    so they are not thread-safe.
  prefs: []
  type: TYPE_NORMAL
- en: We will now look at immutability in terms of thread safety.
  prefs: []
  type: TYPE_NORMAL
- en: Writing code that is immutable and thread-safe
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our immutability example, we will again create a .NET Framework console
    application and we''ll use the same array. Add a class called `ImmutableStruct`
    and modify the code, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Instead of using a normal integer array, we employ `ImmutableArray`. An immutable
    array is passed into the constructor and assigned to the `_immutableArray` member
    variable. Our `GetIntArray()` method returns the immutable array as a normal integer
    array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `ImmutableExample()` array to the `Program` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In our `ImmutableExample()` method, we create an array of integers that we pass
    into the constructor of `ImmutableStruct` as an immutable array. We then print
    the content of the local array before modification. Then, we loop nine times.
    In each iteration, we access the location of the count of the current iteration in
    the array and add the count of the current iteration plus one to the variable
    at that position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then assign a copy of the `immutableStruct` array to a local variable via
    a call to `GetIntArray()`. Then, we proceed to print out the values of the returned
    array. Finally, we start the thread. Call the `ImmutableExample()` method from
    your `Main()` method and then run the code. You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d54dd02-cdb2-4612-aba5-e67a652dbd9b.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the array's content is not modified by updating the local array.
    This version of our program shows that our program is thread-safe.
  prefs: []
  type: TYPE_NORMAL
- en: Let's briefly run through what we've learned about thread safety so far in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding thread safety
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you saw in the previous two sections, it is very important to be careful
    when writing multi-threaded code. Writing thread-safe code can be very difficult,
    especially in larger projects. You have to be particularly careful with collections,
    passing parameters by reference, and when accessing member variables within static
    classes. The best practices for multi-threaded applications are to only pass immutable
    types, not to access static member variables, and if any code that is not thread-safe
    must be executed, then to lock the code using a lock, mutex, or semaphore. Although
    you have already seen code like this in action in this chapter, we will quickly
    refresh our memory on this with some code snippets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how to write an immutable type using `readonly
    struct`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In our `ImmutablePerson` structure, we have a public constructor that takes
    an integer for the ID and strings for the first and last name. We assign the `id`,
    `firstName`, and `lastName` parameters to member read-only variables. The only
    access to the data is via read-only properties. This means that there is no way
    to modify the data. Since the data cannot be modified once it has been created,
    it is classed as thread-safe. Because it is thread-safe, it cannot be modified
    by different threads. The only way to modify the data would be to create a new
    struct with the new data.
  prefs: []
  type: TYPE_NORMAL
- en: Structs can be mutable, just like classes. However, to pass data around that
    you don't want to be modified, then read-only structs are a good, lightweight
    choice. They are faster to create and destroy than classes as they are added to
    the stack—that is, unless they are part of a class that is added to the heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier on, we saw how collections are mutable. However, there is also a namespace
    of immutable collections called `System.Collections.Namespace`. The following
    table lists various items from this namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef71435c-f95c-44b7-b5ee-f046b7e1be1e.png)'
  prefs: []
  type: TYPE_IMG
- en: The `System.Collections.Immutable` namespace contains a number of immutable
    collections that you can use safely between threads. Refer to [https://docs.microsoft.com/en-us/dotnet/api/system.collections.immutable?view=netcore-3.1](https://docs.microsoft.com/en-us/dotnet/api/system.collections.immutable?view=netcore-3.1) for
    more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a lock object in C# is really straightforward, as the following code
    snippet shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We create and instantiate the `_lock` member variable. Then, when it comes to
    executing code that is not thread-safe, we wrap the code in the lock and pass
    in the `_lock` variable to use as the lock object. When a thread enters the lock,
    all other threads are barred from executing the code until the thread leaves the
    lock. One problem with using this code is that threads can enter a deadlock situation.
    One way around this is to use a mutex.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use a synchronization primitive for interprocess synchronization. Start
    by adding the following code to the top of the class that has code that needs
    protection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to use the mutex, you will need to wrap the code that needs protection
    with the following `try/catch` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `WaitOne()` method blocks the current thread until
    the wait handle receives a signal. As soon as the mutex is signaled, the `WaitOne()`
    method returns `true`. The calling thread then assumes ownership of the mutex.
    Protected resources can then be accessed by the calling thread. When the work
    is finished on the protected resource, the mutex is released by calling `ReleaseMutex()`. `ReleaseMutex()`
    is called in the `finally` block because you don't want a thread to keep a resource
    locked if it raises an exception for whatever reason. So, always release a mutex
    in a `finally` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another mechanism for protecting access to resources is using a semaphore.
    Semaphores are coded much like a mutex and they perform the same role of protecting
    resources. The main difference between a semaphore and a mutex is that a mutex
    is a locking mechanism and a semaphore is a signaling mechanism. To use semaphores
    instead of locks and mutexes, add the following line to the top of a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now added a new semaphore variable. The first parameter states the
    initial number of requests for the semaphore that can be granted concurrently.
    The second parameter states the maximum number of requests for the semaphore that
    can be granted concurrently. You will then protect access to a resource in your
    methods, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The current thread is blocked until the current wait handle receives a signal.
    The thread can then do its work. Finally, the semaphore is released.
  prefs: []
  type: TYPE_NORMAL
- en: You have seen, in this chapter, how to use locks, mutexes, and semaphores to
    lock code that is not thread-safe. Also remember that background threads terminate
    when the process completes and terminates, whereas foreground threads will continue
    executing until completion. If you have any code that must run to completion without
    the thread being terminated halfway through what it is doing, then you are better
    off using foreground threads over background threads.
  prefs: []
  type: TYPE_NORMAL
- en: The next section covers synchronized method dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronized method dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To synchronize your code, use a lock statement as we did previously. You can
    also reference the `System.Runtime.CompilerServices` namespace in your projects.
    Then, you can add the `[MethodImpl(MethodImplOptions.Synchronized)]` annotation
    to methods and properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of the `[MethodImpl(MethodImplOptions.Synchronized)]` annotation
    applied to a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of using `[MethodImpl(MethodImplOptions.Synchronized)]` with
    a property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it is easy to encounter a deadlock or a race condition, but
    it is just as easy to overcome deadlocks by using `Monitor.TryEnter()` and race
    conditions with `Task.ContinueWith()`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we look at the `Interlocked` class.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Interlocked class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In multi-threaded applications, errors can creep in during the thread scheduler
    context-switching process. One of the main problems that arises is the update
    of the same variables by different threads. The methods of the `System.Threading.Interlocked`
    class in the `mscorlib` assembly help to protect against these kinds of errors.
    The methods of the `Interlocked` class do not throw exceptions, and so they are
    very helpful in applying simple state changes in a more performant way than using
    the `lock` statement that we've seen previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'The methods available in the `Interlocked` class are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CompareExchange`: Compares two variables and stores the results in a different
    variable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`Add`**: Adds two `Int32` or `Int64` integer variables together and stores
    the result in the first integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Decrement`: Decrements the `Int32` and `Int64` integer variable values and
    stores their results'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Increment`:Increments the `Int32` and `Int64` integer variable values and
    stores their results'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Read`: Reads integer variables of the `Int64` type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Exchange`:Exchanges values between variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are now going to write a simple console application that demonstrates these
    methods. Start by creating a new .NET Framework console application. Add the following
    lines to the top of the `Program` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The `_value` variable will be used to demonstrate the update of variables using
    the interlocking methods. The `_resourceInUse` variable is used to indicate whether
    a resource is in use. Add the `CompareExchangeVariables()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `CompareExchangeVariables()` method, we call the `CompareExchange()`
    method to compare `_value` with `long.MaxValue`. If the two values are equal,
    then `_value` is replaced with the value of `123`. We''ll now add our `AddVariables()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AddVariables()` method calls the `Add()` method to access the `_value`
    member variable and update it with the value of `_value` plus `321`. Next, we''ll
    add our `DecrementVariable()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This method calls the `Decrement()` method, which decrements the `_value` member
    variable by 1\. Our next method is `IncrementValue()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `IncrementVariable()` method, we increment the `_value` member variable
    by calling the `Increment()` method. The next method we will write is the `ReadVariable()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Since 64-bit read operations are atomic, calling the `Interlocked.Read()` method
    is unnecessary. However, on 32-bit systems, for 64-bit reads to be atomic, you
    need to call the `Interlocked.Read()` method. Add the `PerformUnsafeCodeSafely()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PerformUnsafeCodeSafely()` method loops five times. Each iteration of
    the loop calls the `UseResource()` method, and then the thread goes to sleep for
    1 second. Now, we''ll add the `UseResource()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The `UseResource()` method prevents a lock from being obtained if the resource
    is in use, as identified by the `_resourceInUse` variable. We start by setting
    the `_resourceInUse` member variable value to `1` by calling the `Exchange()`
    method. The `Exchange()` method returns an integer, which we compare against `0`.
    If the value returned by `Exchange()` is `0`, then the method is not in use.
  prefs: []
  type: TYPE_NORMAL
- en: If the method is in use, then we output a message informing the user that the
    current thread was denied the lock.
  prefs: []
  type: TYPE_NORMAL
- en: If the method is not in use, then we output a message informing the user that
    the current thread has obtained a lock. We then call the `NonThreadSafeResourceAccess()`
    method and then send the thread to sleep for half a second to simulate work.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the thread awakes, we output a message informing the user that the current
    thread has exited the lock. Then, we release the lock by calling the `Exchange()`
    method and setting the value of `_resourceInUse` to `0`. Add the `NonThreadSafeResourceAccess()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '`NonThreadSafeResourceAccess()` is where non-thread-safe code is executed in
    the safety of the lock. In our method, we simply inform the user with a message.
    The last job to do before we run our code is to update our `Main()` method, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `Main()` method calls the methods that test the `Interlocked` methods.
    Run the code and you should see something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a355f2b5-6574-4bd0-8168-9f276553d81d.png)'
  prefs: []
  type: TYPE_IMG
- en: We'll now go over some general recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: General recommendations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this final section, we will look at some general recommendations from Microsoft
    for working on multi-threaded applications. They include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoid using `Thread.Abort` to terminate other threads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a mutex, `ManualResetEvent`, `AutoResetEvent`, and `Monitor` to synchronize
    activities between multiple threads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where possible, use a thread pool for your worker threads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have any worker threads that gets blocked, then use `Monitor.PulseAll`
    to notify all the threads of a change in the worker thread's state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid using this, type instances, and string instances including string literals
    as `lock` objects. Avoid using types of the `lock` objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instance locks can result in deadlocks, so exercise caution when using them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `try/finally` block with threads that enter a monitor so that in the
    `finally` block, you ensure that the thread leaves the monitor by calling `Monitor.Exit()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use different threads for different resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid assigning multiple threads to the same resource.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I/O tasks should have their own thread as they block when performing I/O operations.
    This way, you allow other threads to run.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User input should have its own dedicated thread.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve performance for simple state changes by using the methods of the `System.Threading.Interlocked`
    class instead of the lock statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For heavily used code, avoid synchronization as it can lead to deadlocks and
    race conditions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make static data thread-safe by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instance data must not be thread-safe by default; otherwise, you decrease performance,
    increase lock contention, and introduce the possibility of race conditions and
    deadlocks occurring.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid using static methods that alter state as they lead to threading bugs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That concludes our look at threading and concurrency. Let's run through a summary
    of what we have learned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered what threading is and how to use it. We looked at
    the problems of deadlocks and race conditions in action, and we saw how to prevent
    these exceptional circumstances using a lock statement and the TPL library. We
    also discussed the thread safety of static constructors, static methods, immutable
    objects, and mutable objects. We saw why using immutable objects is a thread-safe
    way of transferring data between threads, and we reviewed some general recommendations
    for working with threads.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw how making your code thread-safe can have a lot of benefits. In
    the next chapter, we will look at designing effective APIs. But for now, you can
    test your knowledge by answering the following questions and you can further your
    reading by referring to the links provided.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a thread?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many threads are there in a single-threaded application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What types of threads are there?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What thread terminates as soon as the program is exited?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What thread continues through to completion, even if the program is exited?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What code makes a thread sleep for half a millisecond?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you instantiate a thread that calls a method named `Method1`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you make a thread a background thread?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a deadlock?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you exit a lock obtained using `Monitor.TryEnter(objectName)`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you recover from a deadlock?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a race condition?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is one way to prevent race conditions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What makes static methods unsafe?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are static constructors thread-safe?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is responsible for managing groups of threads?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an immutable object?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are immutable objects preferred to mutable objects in threaded applications?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://www.c-sharpcorner.com/blogs/mutex-and-semaphore-in-thread](https://www.c-sharpcorner.com/blogs/mutex-and-semaphore-in-thread) provides
    examples of using a mutex and a semaphore.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.guru99.com/mutex-vs-semaphore.html](https://www.guru99.com/mutex-vs-semaphore.html) explains
    the differences between a mutex and a semaphore.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/static-constructors](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/static-constructors) is
    the official Microsoft documentation on static constructors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices](https://docs.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices) is
    the official Microsoft guidance on Microsoft''s managed threading best practices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/task-parallel-library-tpl](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/task-parallel-library-tpl) is
    the official Microsoft API documentation for the TPL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.c-sharpcorner.com/UploadFile/1d42da/interlocked-class-in-C-Sharp-threading/](https://www.c-sharpcorner.com/UploadFile/1d42da/interlocked-class-in-C-Sharp-threading/) covers
    the Interlocked class in C# threading.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://geekswithblogs.net/BlackRabbitCoder/archive/2012/08/23/c.net-little-wonders-interlocked-read-and-exchange.aspx](http://geekswithblogs.net/BlackRabbitCoder/archive/2012/08/23/c.net-little-wonders-interlocked-read-and-exchange.aspx) provides
    a discussion on `System.Threading.Interlocked` with examples.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.albahari.com/threading/](http://www.albahari.com/threading/) is
    a link to a free eBook by Joseph Albahari about threading in C#.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/dotnet/api/system.collections.immutable?view=netcore-3.1](https://docs.microsoft.com/en-us/dotnet/api/system.collections.immutable?view=netcore-3.1) is
    the official Microsoft documentation on the immutable collections available in
    the `System.Collections.Immutable` namespace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
