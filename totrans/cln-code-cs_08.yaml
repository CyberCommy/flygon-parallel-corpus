- en: Threading and Concurrency
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 线程和并发
- en: A process is essentially a program that is executing on an operating system.
    This process is made up of more than one thread of execution. A thread of execution
    is a set of commands issued by a process. The ability to execute more than one
    thread at a time is known as **multi-threading**. In this chapter, we are going
    to look at multi-threading and concurrency.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 进程本质上是在操作系统上执行的程序。这个进程由多个执行线程组成。执行线程是由进程发出的一组命令。能够同时执行多个线程的能力称为**多线程**。在本章中，我们将研究多线程和并发。
- en: Multiple threads are allotted a set amount of time to execute, and each thread
    is executed on a rotational basis by a thread scheduler. The thread scheduler
    schedules the threads using a technique called **time slicing** and then passes
    each thread to the CPU to be executed at the scheduled time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 多个线程被分配一定的执行时间，并且每个线程都由线程调度程序按轮换方式执行。线程调度程序使用一种称为**时间片分配**的技术来调度线程，然后在预定的时间将每个线程传递给CPU执行。
- en: '**Concurrency** is the ability to run more than one thread at exactly the same
    time. This can be accomplished on computers with more than one processor core.
    The more processor cores a computer has, the more threads of execution can be
    executed concurrently.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**并发**是能够同时运行多个线程的能力。这可以在具有多个处理器核心的计算机上实现。计算机的处理器核心越多，就可以同时执行更多的执行线程。'
- en: As we look at concurrency and threading in this chapter, we will encounter the
    problems of blocking, deadlocks, and race conditions. You will see how we can
    overcome these problems using clean coding techniques.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本章中研究并发和线程时，我们将遇到阻塞、死锁和竞争条件的问题。您将看到我们如何使用清晰的编码技术来克服这些问题。
- en: 'In the course of this chapter, we will cover each of the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下每个主题：
- en: Understanding the thread life cycle
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解线程生命周期
- en: Adding thread parameters
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加线程参数
- en: Using a thread pool
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用线程池
- en: Using a mutual exclusion object with synchronous threads
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用互斥对象与同步线程
- en: Working with parallel threads using semaphores
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用信号量处理并行线程
- en: Limiting the number of processors and threads in the thread pool
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制线程池中的处理器和线程数量
- en: Preventing deadlocks
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止死锁
- en: Preventing race conditions
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止竞争条件
- en: Understanding static constructors and methods
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解静态构造函数和方法
- en: Mutability, immutability, and thread safety
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变性、不可变性和线程安全
- en: Synchronized method dependencies
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步方法依赖
- en: Using the `Interlocked` class for simple state changes
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Interlocked`类进行简单状态更改
- en: General recommendations
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一般建议
- en: 'After working through this chapter and developing your threading and concurrency
    skills, you will have acquired the following skills:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过学习本章并发编程技能，您将获得以下技能：
- en: The ability to understand and discuss the thread life cycle
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和讨论线程生命周期的能力
- en: An understanding of and ability to use foreground and background threads
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和使用前台和后台线程的能力
- en: The ability to throttle threads and set the number of processors to use concurrently
    using a thread pool
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过线程池限制线程数量和设置并发使用的处理器数量的能力
- en: The ability to understand the effects of static constructors and methods in
    relation to multi-threading and concurrency
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解静态构造函数和方法对多线程和并发的影响
- en: The ability to take into account mutability and immutability and their impact
    on thread safety
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑可变性和不可变性及其对线程安全的影响的能力
- en: The ability to understand what causes race conditions and how to avoid them
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解竞争条件的原因以及如何避免它们的能力
- en: The ability to understand what causes deadlocks and how to avoid them
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解死锁的原因以及如何避免它们的能力
- en: The ability to perform simple state changes using the `Interlocked` class
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Interlocked`类执行简单的状态更改的能力
- en: To run through the code in this chapter, you will need a .NET Framework console
    application. Unless otherwise stated, all code will be placed in the `Program`
    class.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章中的代码，您需要一个.NET Framework控制台应用程序。除非另有说明，所有代码将放在`Program`类中。
- en: Understanding the thread life cycle
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解线程生命周期
- en: 'Threads in C# have an associated life cycle. The life cycle for threads is
    as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的线程有一个相关的生命周期。线程的生命周期如下：
- en: '![](img/9f574fc2-1ade-4f26-9ecf-52f3cecde092.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f574fc2-1ade-4f26-9ecf-52f3cecde092.png)'
- en: When a thread starts, it enters the **running** state. When running, the thread
    can enter a **wait**, **sleep**, **join**, **stop**, or **suspended **state. Threads
    can also be aborted. Aborted threads enter the stop state. You can suspend and
    resume a thread by calling the `Suspend()` and `Resume()` methods, respectively.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当线程启动时，它进入**运行**状态。在运行时，线程可以进入**等待**、**睡眠**、**加入**、**停止**或**挂起**状态。线程也可以被中止。中止的线程进入停止状态。您可以通过分别调用`Suspend()`和`Resume()`方法来挂起和恢复线程。
- en: A thread will enter the wait state when the `Monitor.Wait(object obj)` method
    is called. The thread will then continue when the `Monitor.Pulse(object obj)`
    method is called. Threads enter sleep mode by calling the `Thread.Sleep(int millisecondsTimeout)`
    method. Once the elapsed time has passed, the thread returns to the running state.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`Monitor.Wait(object obj)`方法时，线程将进入等待状态。然后当调用`Monitor.Pulse(object obj)`方法时，线程将继续。通过调用`Thread.Sleep(int
    millisecondsTimeout)`方法，线程进入睡眠模式。一旦经过了经过的时间，线程就会返回到运行状态。
- en: The `Thread.Join()` method causes a thread to enter the wait state. A joined
    thread will remain in the wait state until all dependent threads have finished
    running, upon which it will enter the running state. However, if any dependent
    threads are aborted, then this thread is also aborted and enters the stop state.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread.Join()`方法使线程进入等待状态。加入的线程将保持在等待状态，直到所有依赖线程都完成运行，然后它将进入运行状态。但是，如果任何依赖线程被中止，那么这个线程也会被中止并进入停止状态。'
- en: Threads that have completed or have been aborted cannot be restarted.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 已完成或已中止的线程无法重新启动。
- en: 'Threads can run in the foreground or the background. Let''s look at both foreground
    and background threads, starting with foreground threads:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 线程可以在前台或后台运行。让我们先看看前台和后台线程，从前台线程开始：
- en: '**Foreground threads**: By default, threads run in the foreground. A process
    will continue to run while at least one foreground thread is currently running.
    Even if `Main()` completes but a foreground thread is running, the application
    process will remain active until the foreground thread terminates. Creating a
    foreground thread is really simple, as the following code shows:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前台线程**：默认情况下，线程在前台运行。只要至少有一个前台线程正在运行，进程就会继续运行。即使`Main()`完成了，但前台线程正在运行，应用程序进程仍将保持活动状态，直到前台线程终止。创建前台线程非常简单，如下面的代码所示：'
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Background threads**: You create a background thread in the same way that
    you create foreground threads, except that you also have to explicitly set a thread
    to run in the background, as shown:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后台线程**：创建后台线程的方式与创建前台线程的方式相同，只是您还必须显式地将线程设置为后台运行，如下所示：'
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Background threads are used to carry out background tasks and keep the user
    interface responsive to the user. When the main process terminates, any background
    threads that are executing are also terminated. However, even if the main process
    terminates, any foreground threads that are running will run to completion.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 后台线程用于执行后台任务并保持用户界面对用户的响应。当主进程终止时，任何正在执行的后台线程也将被终止。但是，即使主进程终止，任何正在运行的前台线程也将运行到完成。
- en: In the next section, we will look at thread parameters.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看一下线程参数。
- en: Adding thread parameters
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加线程参数
- en: Methods that run in threads often have parameters. So, when executing a method
    within a thread, it is useful to know how to pass the method parameters into the
    thread.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在线程中运行的方法通常具有参数。因此，在线程中执行方法时，了解如何将方法参数传递到线程中是有用的。
- en: 'Let''s say that we have the following method, which adds two integers together
    and returns a result:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有以下方法，它将两个整数相加并返回结果：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see, the method is simple. There are two parameters called `a` and
    `b`. These two parameters will need to be passed into the thread for the `Add()`
    method to run properly. We will add an example method that will do just that:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，该方法很简单。有两个名为`a`和`b`的参数。这两个参数将需要传递到线程中，以便`Add()`方法能够正确运行。我们将添加一个示例方法来实现这一点：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this method, we declare an integer with an initial value of `0`. We then
    create a new thread that calls the `Add()` method with the `1` and `2` parameter
    values, and then assign the result to the integer variable. The thread then starts
    and we wait for it to finish executing by calling the `Join()` method. Finally,
    we print the result to the console window.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们声明一个初始值为`0`的整数。然后我们创建一个调用带有`1`和`2`参数值的`Add()`方法的新线程，然后将结果赋给整数变量。然后线程开始，我们等待它通过调用`Join()`方法执行完毕。最后，我们将结果打印到控制台窗口。
- en: 'Let''s add our `Message()` method:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加我们的`Message()`方法：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `Message()` method simply takes a string and outputs it to the console
    window. All we have to do now is update the `Main()` method, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Message()`方法只是接受一个字符串并将其输出到控制台窗口。现在我们只需要更新`Main()`方法，如下所示：'
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In our `Main()` method, we call our example method and then wait for the user
    to press any key before exiting. You should see the following output:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Main()`方法中，我们调用我们的示例方法，然后等待用户按任意键退出。您应该看到以下输出：
- en: '![](img/4d13b988-cbf1-4b6f-a5f1-8e5ecabdb34b.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d13b988-cbf1-4b6f-a5f1-8e5ecabdb34b.png)'
- en: As you can see, `1` and `2` were the method parameters passed into the addition
    method, and `3` was the value returned by the thread. The next topic we will look
    at is using a thread pool.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`1`和`2`是传递给加法方法的方法参数，`3`是线程返回的值。我们将要看的下一个主题是使用线程池。
- en: Using a thread pool
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用线程池
- en: A thread pool improves performance by creating a collection of threads during
    application initialization. When a thread is required, it is assigned a single
    task. That task will be executed. Once executed, the thread is returned to the
    thread pool to be reused.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 线程池通过在应用程序初始化期间创建一组线程来提高性能。当需要线程时，它被分配一个单独的任务。该任务将被执行。执行完毕后，线程将返回到线程池以便重用。
- en: Since thread creation is expensive in .NET, we can improve performance by using
    a thread pool. Each process has a fixed number of threads based on the system
    resources available, such as memory and the CPU. However, we can increase or decrease
    the number of threads used by the thread pool. It is normally best to let the
    thread pool take care of how many threads to use, rather than manually setting
    these values.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在.NET中创建线程是昂贵的，我们可以通过使用线程池来提高性能。每个进程都有一定数量的线程，这取决于可用的系统资源，如内存和CPU。但是，我们可以增加或减少线程池使用的线程数量。通常最好让线程池负责使用多少线程，而不是手动设置这些值。
- en: 'The different ways to create a thread pool are as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 创建线程池的不同方法如下：
- en: Using the **Task Parallel Library** (**TPL**) (on .NET Framework 4.0 and higher)
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**任务并行库**（**TPL**）（在.NET Framework 4.0及更高版本）
- en: Using `ThreadPool.QueueUserWorkItem()`
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ThreadPool.QueueUserWorkItem()`
- en: Using asynchronous delegates
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用异步委托
- en: Using `BackgroundWorker`
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`BackgroundWorker`
- en: As a rule of thumb, you should only use a thread pool for server-side applications.
    For client-side applications, use foreground and background threads, as necessary.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 作为经验法则，您应该只在服务器端应用程序中使用线程池。对于客户端应用程序，根据需要使用前台和后台线程。
- en: In this book, we will just look at the **TPL** and the `QueueUserWorkItem()`
    method. You can check out how to use the other two methods at [http://www.albahari.com/threading/](http://www.albahari.com/threading/).
    We'll look at the TPL next.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们只会看一下**TPL**和`QueueUserWorkItem()`方法。您可以在[http://www.albahari.com/threading/](http://www.albahari.com/threading/)上查看如何使用其他两种方法。我们接下来将看一下TPL。
- en: Task Parallel Library
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务并行库
- en: An asynchronous operation in C# is represented by a task. A task in C# is represented
    by the `Task` class in the TPL. As you will gather from the name, task parallelism
    enables multiple tasks to be executed concurrently, which we will learn about
    in the following subsections. The first `Parallel` class method we will look at
    is the `Invoke()` method.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的异步操作由任务表示。C#中的任务由TPL中的`Task`类表示。正如你从名称中可以得知的那样，任务并行使多个任务能够同时执行，我们将在接下来的小节中学习。我们将首先看一下`Parallel`类的`Invoke()`方法。
- en: Parallel.Invoke()
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Parallel.Invoke()
- en: 'In our first example, we will invoke three separate methods using `Parallel.Invoke()`.
    Add the following three methods:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个示例中，我们将使用`Parallel.Invoke()`来调用三个单独的方法。添加以下三个方法：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, these three methods are almost identical, apart from their
    names and the message printed to the console window via the `Message()` method
    we wrote earlier. Now, we''ll add the `UsingTaskParallelLibrary()` method to execute
    these three methods in parallel:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这三个方法几乎是相同的，除了它们的名称和通过我们之前编写的`Message()`方法打印到控制台窗口的消息。现在，我们将添加`UsingTaskParallelLibrary()`方法来并行执行这三个方法：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this method, we write a message to the console window indicating the start
    of the method. We then invoke the `MethodOne`, `MethodTwo`, and `MethodThree` methods in
    parallel. Then, we write a message to the console window indicating that the method
    has reached its end, and then we wait for a key to be pressed before exiting the
    method. Run the code and you should see the following output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们向控制台窗口写入一条消息，指示方法的开始。然后，我们并行调用`MethodOne`、`MethodTwo`和`MethodThree`方法。然后，我们向控制台窗口写入一条消息，指示方法已经到达结束，然后我们等待按键退出方法。运行代码，你应该看到以下输出：
- en: '![](img/320d0805-ddc4-4c24-a70d-3faea45cafd6.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/320d0805-ddc4-4c24-a70d-3faea45cafd6.png)'
- en: In the preceding screenshot, you can see that thread one is reused. Let's now
    move on to the `Parallel.For()` loop.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中，你可以看到线程一被重用。现在让我们转到`Parallel.For()`循环。
- en: Parallel.For()
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Parallel.For()
- en: 'In our next TPL example, we will look at a simple `Parallel.For()` loop. Add
    the following method to the `Program` class of a new .NET Framework console application:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们下一个TPL示例中，我们将看一个简单的`Parallel.For()`循环。将以下方法添加到新的.NET Framework控制台应用程序的`Program`类中：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'All this method does is output a string to the console window. We''ll now create
    the method that executes the `Parallel.For()` loop:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法只是在控制台窗口输出一个字符串。现在，我们将创建执行`Parallel.For()`循环的方法：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this method, we loop through `0` to `1000`, calling `Method()`. You will
    see how the threads are reused with the different method calls, as in the following
    screenshot:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们循环从`0`到`1000`，调用`Method()`。你将看到线程如何在不同的方法调用中被重用，如下面的截图所示：
- en: '![](img/b4ae2005-16d0-422a-81aa-00d07a93a8db.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b4ae2005-16d0-422a-81aa-00d07a93a8db.png)'
- en: Now, we will look at using the `ThreadPool.QueueUserWorkItem()` method.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看看如何使用`ThreadPool.QueueUserWorkItem()`方法。
- en: ThreadPool.QueueUserWorkItem()
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ThreadPool.QueueUserWorkItem()
- en: 'The `ThreadPool.QueueUserWorkItem()` method accepts a `WaitCallback` method
    and queues it ready for execution. `WaitCallback` is a delegate that represents
    a callback method to be executed by a thread pool thread. When a thread becomes
    available, the method is executed. Let''s add a simple example. We''ll start by
    adding `WaitCallbackMethod`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadPool.QueueUserWorkItem()`方法接受`WaitCallback`方法并将其排队准备执行。`WaitCallback`是一个代表回调方法的委托，将由线程池线程执行。当线程可用时，该方法将被执行。让我们添加一个简单的例子。我们将首先添加`WaitCallbackMethod`：'
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This method accepts a type of object. However, since the parameter will be
    unused, we use the discard variable (`_`). A message is printed to the console
    window. Now, all we need is the code to call the method:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法接受一个对象类型。然而，由于参数将不被使用，我们使用丢弃变量（`_`）。一条消息被打印到控制台窗口。现在，我们只需要调用这个方法的代码：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, we use the `ThreadPool` class to queue `WaitCallbackMethod()` in
    the thread pool via the call to the `QueueUserWorkItem()` method. We then do some
    work on the main thread. The main thread then goes to sleep. A thread becomes
    available from the thread pool and `WaitCallBackMethod()` is executed. The thread
    is then returned back to the thread pool to be reused. Execution returns to the
    main thread, which then completes and terminates.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用`ThreadPool`类通过调用`QueueUserWorkItem()`方法将`WaitCallbackMethod()`排队到线程池中。然后我们在主线程上做一些工作。主线程然后进入睡眠状态。一个线程从线程池中可用，`WaitCallBackMethod()`被执行。然后线程被返回到线程池中以便重用。执行返回到主线程，然后完成并终止。
- en: In the next section, we will discuss thread-locking objects, known as **Mutual
    Exclusion Objects **(**m****utexes**).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论线程锁定对象，即**互斥对象**（**mutexes**）。
- en: Using a mutex with synchronous threads
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用互斥体与同步线程
- en: In C#, a mutex is a thread-locking object that works across multiple processes.
    Only a process that can request or release a resource can modify the mutex. When
    a mutex is locked, the process will have to wait in a queue. When the mutex is
    unlocked, then it can be accessed. Multiple threads can use the same mutex, but
    only in a synchronous manner.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，互斥体是一个跨多个进程工作的线程锁定对象。只有能够请求或释放资源的进程才能修改互斥体。当互斥体被锁定时，进程将不得不在队列中等待。当互斥体被解锁时，它就可以被访问。多个线程可以以同步的方式使用相同的互斥体。
- en: The benefits of using a mutex are that a mutex is a simple lock obtained before
    entering a critical piece of code. That lock is released when the critical piece
    of code is exited. Because only a single thread is in the critical piece of code
    at any one time, the data will remain in a consistent state as there will be no
    race conditions.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用互斥体的好处是，互斥体是在进入关键代码之前获取的简单锁。当关键代码退出时，该锁将被释放。因为在任何时候只有一个线程在关键代码中，数据将保持一致状态，因为不会出现竞争条件。
- en: 'There are several disadvantages to using a mutex:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用互斥体有一些缺点：
- en: Thread starvation occurs when a thread is unable to move forward as an existing
    thread has obtained a lock and has either gone to sleep or is pre-empted (prevented
    from completing its task).
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a mutex is locked, only the thread that obtained the lock can unlock it.
    No other thread can lock or unlock it.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only one thread at a time is allowed to enter the critical piece of code. CPU
    time can be wasted as the normal implementation of a mutex may lead to a *busy
    waiting* state.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will now write a program that demonstrates the use of a mutex. Start a new
    .NET Framework console application. Add the following line to the top of the class:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, we have declared a primitive called `_mutex`, which we will use for inter-process
    synchronization. Now, add a method to demonstrate thread synchronization using
    a mutex:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this method, the current thread is blocked until the current wait handle
    receives a signal. Then, when the signal is given, it is safe for the next thread
    to enter. Upon completion, other threads are unblocked from trying to gain ownership
    of the mutex. Next, add the `MutexExample()` method:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this method, we create 10 threads and start them. Each thread executes the
    `ThreadSynchronisationUsingMutex()` method. Now, finally, update the `Main()`
    method:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `Main()` method runs our mutex example. The output should be similar to
    the one in the following screenshot:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb8cc4bd-8486-4e2d-b085-c4d9f0915b5b.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
- en: Run the example again and you may end up with different thread numbers. If they
    are the same numbers, then they may be in different orders.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have looked at mutexes, let's look at semaphores.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Working with parallel threads using semaphores
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In multi-threaded applications, a non-negative number, known as a **semaphore**,
    is shared between threads that have a number of `1` or `2`. In terms of synchronization, `1`
    specifies *wait* and `2` specifies *signal*.We can associate a semaphore with
    a number of buffers, which can each be worked on simultaneously by different processes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: So, essentially, semaphores are signaling mechanisms of the integer and binary
    primitive types that can be modified by wait and signal operations. If there are
    no free resources, then processes that require a resource should execute the wait
    operation until the semaphore value is *greater than 0*. Semaphores can have multiple
    program threads and they can be changed by any object, obtaining a resource or
    releasing it.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of using semaphores are down to the fact that more than one thread
    can access the critical piece of code. A semaphore is executed in the kernel and
    is machine-independent. The critical piece of code is protected from multiple
    processes if you use semaphores. Unlike a mutex, a semaphore never wastes processing
    time and resources.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Just like a mutex, semaphores also have their own set of disadvantages. Priority
    inversion is one of the biggest disadvantages and occurs when a high-priority
    thread is forced to wait for a semaphore to be released by its low-priority owning
    thread.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: This can be further compounded if the low-priority thread is prevented from
    completing by mid-priority threads prior to their release. This is known as **unbounded
    priority inversion** because we can no longer predict the delay to the high-priority
    thread. With semaphores, the operating system must keep track of all wait and
    signal calls.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Semaphores are used by convention, but they are not forced. You need to execute
    wait and signal operations in the correct order; otherwise, you risk deadlocks
    in your code. Because of the complexity of using semaphores, there may be times
    when a mutual exclusion cannot be obtained. Loss of modularity in large systems
    is also another drawback and semaphores are prone to programming errors that result
    in deadlocks and mutual exclusion violation.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to write a program now that demonstrates the use of semaphores:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We have added a new semaphore variable. The first parameter states the initial
    number of requests for the semaphore that can be granted concurrently. The second
    parameter states the maximum number of requests for the semaphore that can be
    granted concurrently. Add the `StartSemaphore()` method:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个新的信号量变量。第一个参数表示可以同时授予的信号量的初始请求数。第二个参数表示可以同时授予的信号量的最大请求数。添加`StartSemaphore()`方法：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The current thread is blocked until the current wait handle receives a signal.
    The thread can then do its work. Finally, the semaphore is released and the count
    returns to the previous count. Now, add the `SemaphoreExample()` method:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当前线程被阻塞，直到当前等待句柄接收到一个信号。然后线程可以执行它的工作。最后，信号量被释放，计数返回到之前的计数。现在，添加`SemaphoreExample()`方法：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This example generates 10 threads, which execute the `StartSemaphore()` method.
    Let''s update the `Main()` method to run the code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子生成10个线程，这些线程执行`StartSemaphore()`方法。让我们更新`Main()`方法来运行这段代码：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `Main()` method calls `SemaphoreExample()` and then waits for a user keypress
    to exit. You should see the following output:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main()`方法调用`SemaphoreExample()`，然后等待用户按键退出。你应该看到以下输出：'
- en: '![](img/33cf6f91-f372-464f-b382-81a7646148a4.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33cf6f91-f372-464f-b382-81a7646148a4.png)'
- en: Let's move on to look at how we limit the number of processors and threads in
    the thread pool.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看如何限制线程池中处理器和线程的数量。
- en: Limiting the number of processors and threads in the thread pool
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制线程池中处理器和线程的数量
- en: There may be times when you need to limit the number of processors and threads
    used by your computer program.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你可能需要限制计算机程序使用的处理器和线程的数量。
- en: 'To reduce the number of processors that your program uses, you obtain the current
    process and set its processor affinity value. For example, say that we have a
    four-core computer and we want to limit our usage to the first two cores. The
    binary value for the first two cores is `11`, which is `3` in integer form. Now,
    let''s add a method to a new .NET Framework console application and call it `AssignCores()`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少程序使用的处理器数量，你获取当前进程并设置它的处理器亲和性值。例如，假设我们有一台四核计算机，我们想将使用限制在前两个核心上。前两个核心的二进制值是`11`，在整数形式中是`3`。现在，让我们添加一个方法到一个新的.NET
    Framework控制台应用程序，并称其为`AssignCores()`：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We pass in an integer to the method. This integer value will be converted into
    a binary value by .NET Framework. That binary value will use the processors identified
    by the value of `1`. For binary values of `0`, the processors will not be used.
    So, since machine code is represented by binary numbers, `0110` (`6`) will use
    cores `2` and `3`, `1100` (`3`) will use cores `1` and `2`, and `0011` (`12`)
    will use cores `3` and `4`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向方法传递一个整数。这个整数值将被.NET Framework转换为一个二进制值。这个二进制值将使用由`1`值确定的处理器。对于二进制值为`0`，处理器将不会被使用。因此，由二进制数表示的机器码，`0110`（`6`）将使用核心`2`和`3`，`1100`（`3`）将使用核心`1`和`2`，`0011`（`12`）将使用核心`3`和`4`。
- en: If you want a refresher on binary, refer to [https://www.computerhope.com/jargon/b/binary.htm](https://www.computerhope.com/jargon/b/binary.htm).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要关于二进制的复习，请参考[https://www.computerhope.com/jargon/b/binary.htm](https://www.computerhope.com/jargon/b/binary.htm)。
- en: 'Now, to set the maximum number of threads, we call the `SetMaxThreads()` method
    on the `ThreadPool` class. This method takes two parameters, which are both integers.
    The first parameter is the maximum number of worker threads in the thread pool
    and the second parameter is the maximum number of asynchronous I/O threads in
    the thread pool. We''ll now add our method to set the maximum number of threads:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了设置最大线程数，我们在`ThreadPool`类上调用`SetMaxThreads()`方法。这个方法接受两个参数，都是整数。第一个参数是线程池中工作线程的最大数量，第二个参数是线程池中异步I/O线程的最大数量。现在，我们将添加我们的方法来设置最大线程数：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, it is pretty straightforward to set thread maximums and processors
    in your programs. Most of the time, you will not have to do this in your programs.
    The main reason for manually setting the number of threads and/or processors to
    use in your program is for if your programs run into performance issues. If your
    program does not experience performance issues, then it is best not to set the
    number of threads or the number of processors.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，设置程序中线程的最大数量和处理器是非常简单的。大多数情况下，你不需要在程序中这样做。手动设置线程和/或处理器数量的主要原因是如果你的程序遇到性能问题。如果你的程序没有遇到性能问题，最好不要设置线程或处理器的数量。
- en: The next topic we will look at is deadlocks.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个我们将要看的主题是死锁。
- en: Preventing deadlocks
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止死锁
- en: A **deadlock** occurs when two or more threads are executed and are waiting
    for each other to finish. This problem manifests in computer programs when they
    hang. For the end user, this can be very bad and can result in the loss or corruption
    of data. An example of this is executing two batches of data input that crash
    halfway through a transaction and cannot be rolled back. This is not good; let
    me explain why with an example.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**死锁**发生在两个或更多线程执行并且互相等待对方完成时。当计算机程序出现这个问题时，会出现挂起的情况。对于最终用户来说，这可能非常糟糕，并且可能导致数据的丢失或损坏。一个例子是执行两批数据输入，其中一半事务崩溃并且无法回滚。这是不好的；让我用一个例子来解释为什么。'
- en: Consider a major banking transaction that will take £1 million out of a customer's
    business bank account to pay their **Her Majesty's Revenue and Customs** (**HMRC**)
    tax bill. The money is taken from the business account, but before the money is
    deposited in the HMRC bank account, a deadlock occurs. There is no recovery option
    and so the application has to be terminated and restarted. As a result, the business
    bank account is reduced by £1 million but the HMRC tax bill has not been paid.
    The customer is still liable to pay the tax bill. But what happens to the money
    that has been taken out of the account? So, you can see the importance of removing
    the possibility of deadlocks occurring due to the problems they can cause.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep things simple, we will deal with two threads, shown in the following
    diagram:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6547929-7a72-40da-817a-87481d5face9.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
- en: We will call our threads Thread 1 and Thread 2 and our resources Resource 1 and Resource
    2\. Thread 1 obtains a lock on **Resource 1**. **Thread 2** obtains a lock on **Resource
    2**. **Thread 1** requires access to **Resource 2** but has to wait because **Thread
    2** has locked **Resource 2**. **Thread 2** requires access to **Resource 1** but
    has to wait because **Thread 1** has locked **Resource 1**. This results in both **Thread
    1** and **Thread 2** being in a wait state. Since neither thread can continue
    until the other thread releases its resource, both threads are in a **deadlock
    situation**. When a computer program is in a deadlock situation, it *hangs*, forcing
    you to terminate the program.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: A code example of a deadlock will be a nice way to illustrate this, and so in
    the next section, we will code a deadlock example.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Coding a deadlock example
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The best way to understand this is with a working example. We are going to write
    some code consisting of two methods that have two different locks each. They will
    both lock objects that the other method needs. Because each thread locks the resources
    that the other thread needs, they will both enter a deadlock state. Once we have
    our example working, we will then modify it so that our code recovers from the
    deadlock situation and is able to continue.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new .NET Framework console application and call it `CH08_Deadlocks`.
    We will need two objects as member variables, so let''s add them:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'These objects will be used as our lock objects. We will have two threads, and
    each thread will execute its own method. Now, add `Thread1Method()` to your code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`Thread1Method()` obtains a lock on `_object1`. It then sleeps for 1 second.
    When it awakes, a lock is obtained on `_object2`. The method then exits both locks
    and terminates.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '`Thread2Method()` obtains a lock on `_object2`. It then sleeps for 1 second.
    When it awakes, a lock is obtained on `_object1`. The method then exits both locks
    and terminates:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Well, we now have our two methods in place to demonstrate a deadlock. We just
    need the code to call them in a way that will cause a deadlock. Let''s add the `DeadlockNoRecovery()` method:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the `DeadlockNoRecovery()` method, we create two threads. Each thread is
    assigned a different method. Then, each thread is started. The program is then
    paused until the user presses a key. Now, update the `Main()` method and run your
    code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When you run your program, you should see the following output:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3cc47b74-1c00-4540-b392-39a9b241a776.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: As you can see, because `thread1` has locked `_object1`, `thread2` is blocked
    from obtaining a lock on `_object1`. Also, because `thread2` has locked `_object2`,
    `thread1` is blocked from obtaining a lock on `_object2`. So, both threads are
    in deadlock and the program hangs.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: We will now write some code that demonstrates how to avoid this deadlock situation
    from occurring. We will be using the `Monitor.TryLock()` method to try and obtain
    a lock within a certain number of milliseconds. We will then exit a successful
    lock with `Monitor.Exit()`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the `DeadlockWithRecovery()` method:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `DeadlockWithRecovery()` method creates two foreground threads. It then
    starts the threads, prints a message to the console, and waits for the user to
    press a key before exiting. We will now add the code for `Thread4Method()`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeadlockWithRecovery()`方法创建两个前台线程。然后启动线程，在控制台打印一条消息，并等待用户按键退出。现在我们将为`Thread4Method()`添加代码：'
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`Thread4Method()` sleeps for 1 second. It then tries to get a lock on `_object1`.
    If it fails to get a lock on `_object1`, it returns from the method. If a lock
    on `_object1` is obtained, then it tries to get a lock on `_object2`. If a lock
    on `_object2` can''t be obtained, then it returns from the method. If a lock is
    obtained on `_object2`, then it performs the necessary work on `_object2`. The
    lock on `_object2` is then released, and then the lock on `_object1` is released.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread4Method()`休眠1秒。然后尝试锁定`_object1`。如果无法锁定`_object1`，则从方法返回。如果成功锁定`_object1`，则尝试锁定`_object2`。如果无法锁定`_object2`，则从方法返回。如果成功锁定`_object2`，则对`_object2`执行必要的工作。然后释放`_object2`的锁，然后释放`_object1`的锁。'
- en: 'Our `Thread5Method()` method does exactly the same thing, except the objects—`_object1`
    and `_object2`—are locked in reverse order:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Thread5Method()`方法做的事情完全相同，只是对象`_object1`和`_object2`以相反的顺序被锁定：
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, add the `DeadlockWithRecovery()` method call to your `Main()` method:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将`DeadlockWithRecovery()`方法调用添加到你的`Main()`方法中：
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, run your code a few times. The majority of the time, you will see what
    is in the following screenshot, where all the locks have been successfully obtained:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行你的代码几次。大多数情况下，你会看到以下截图中的情况，所有锁都已成功获取：
- en: '![](img/fa0d5689-7404-4341-9bb8-880b35507571.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa0d5689-7404-4341-9bb8-880b35507571.png)'
- en: Then, press any key and the program will exit. If you keep running the program,
    you will eventually find a lock that fails. The program failed to get a lock on `_object2` in `Thread5Method()`.
    However, if you press any key, the program will exit. As you can see, by using
    `Monitor.TryEnter()`, you can try and lock an object. But if the lock is not obtained,
    then you are able to take another action without your program hanging.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按任意键，程序将退出。如果继续运行程序，最终会发现一个锁定失败。程序在`Thread5Method()`中无法获取`_object2`的锁。但是，如果按任意键，程序将退出。如你所见，通过使用`Monitor.TryEnter()`，你可以尝试锁定一个对象。但如果未获得锁定，则可以在程序挂起的情况下采取其他操作。
- en: In the next section, we look at preventing race conditions.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看看如何防止竞争条件。
- en: Preventing race conditions
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止竞争条件
- en: When multiple threads using the same resource produce different outcomes due
    to the timings of each thread, this is known as a **race condition**. We will
    demonstrate this in action now.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个线程使用相同的资源产生不同的结果，这是由于每个线程的时间安排不同，这被称为**竞争条件**。我们现在将演示这一点。
- en: In our demonstration, we will have two threads. Each thread will call a method
    to print the alphabet. One method will print the alphabet using *uppercase letters*.
    The second method will print the alphabet using *lowercase letters*. From the
    demonstration, we'll see how the output is wrong, and every time the program is
    run, the output will be wrong.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的演示中，将有两个线程。每个线程将调用一个打印字母的方法。一个方法将使用*大写字母*打印字母表。第二个方法将使用*小写字母*打印字母表。从演示中，我们将看到输出是错误的，每次运行程序时，输出都将是错误的。
- en: 'First, add the `ThreadingRaceCondition()` method:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，添加`ThreadingRaceCondition()`方法：
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`ThreadingRaceCondition()` produces two threads and starts them. It also references
    two methods. `Method1()` prints out the alphabet in uppercase and `Method2()` prints
    out the alphabet in lowercase. Let''s add `Method1()` and `Method2()`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadingRaceCondition()`产生两个线程并启动它们。它还引用两个方法。`Method1()`以大写字母打印字母表，`Method2()`以小写字母打印字母表。让我们添加`Method1()`和`Method2()`：'
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Both `Method1()` and `Method2()` reference the `_alphabetCharacter` variable.
    So, add the member to the top of the class:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`Method1()`和`Method2()`都引用`_alphabetCharacter`变量。因此，在类的顶部添加该成员：'
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, update `MainMethod()`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，更新`MainMethod()`：
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We now have our code in place to demonstrate the race condition. If you run
    the program multiple times, you will see that the results are not what we expect.
    You should even see characters that are not part of the alphabet:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经准备好演示竞争条件的代码。如果多次运行程序，你会发现结果不是我们期望的。甚至会看到不属于字母表的字符：
- en: '![](img/0c017737-c3f3-4839-b064-e30731c5db83.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c017737-c3f3-4839-b064-e30731c5db83.png)'
- en: Not exactly what we were expecting, is it?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 不完全是我们期望的，是吗？
- en: We are going to solve this problem by using the TPL. The aim of the TPL is to
    simplify **parallelism** and **concurrency**. As most computers today have two
    or more processors, the TPL will scale the degree of concurrency dynamically to
    make the most efficient use of all the available processors.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用TPL来解决这个问题。TPL的目标是简化**并行性**和**并发性**。由于今天大多数计算机都有两个或更多处理器，TPL将动态地扩展并发度，以充分利用所有可用的处理器。
- en: The partitioning of work, the scheduling of threads in the thread pool, cancellation
    support, state management, and so on are also carried out by the TPL. A link to
    the official Microsoft TPL documentation can be found in the *Further reading* section
    of this chapter.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: TPL还执行工作分区、线程池中的线程调度、取消支持、状态管理等。本章的*进一步阅读*部分中可以找到官方Microsoft TPL文档的链接。
- en: 'You will see just how simple the solution to the aforementioned problem can
    be. We have a task that runs `Method1()`. The task then continues with `Method2()`.
    We then call `Wait()` to wait for the task to complete execution. Now, add the
    `ThreadingRaceConditionFixed()` method to your source code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到上述问题的解决方案是多么简单。我们有一个运行`Method1()`的任务。任务然后继续执行`Method2()`。然后我们调用`Wait()`等待任务完成执行。现在，在你的源代码中添加`ThreadingRaceConditionFixed()`方法：
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Modify your `Main()` method, as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 修改你的`Main()`方法如下：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Run the code now. If you run it multiple times, you will see that the output
    is always the same, as in the following screenshot:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行代码。如果多次运行，你会发现输出总是相同的，如下截图所示：
- en: '![](img/0cf0ae1c-9d51-4196-9316-36317f555b56.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0cf0ae1c-9d51-4196-9316-36317f555b56.png)'
- en: So far, we have seen what a thread is and how to use them in the foreground
    and background. We have also looked at deadlocks and how to solve them with `Monitor.TryEnter()`.
    Finally, we looked at what race conditions are and how to solve them using the
    TPL.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了线程是什么以及如何在前台和后台使用它们。我们还看了死锁以及如何使用`Monitor.TryEnter()`解决它们。最后，我们看了什么是竞争条件以及如何使用TPL解决它们。
- en: Now, we will move on to looking at static constructors and methods.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将继续查看静态构造函数和方法。
- en: Understanding static constructors and methods
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解静态构造函数和方法
- en: If multiple classes require access to a property instance simultaneously, then
    one of the threads will be requested to run the **static constructor** (also known
    as the **type initializer**). While waiting for the type initializer to run, all
    the other threads will be locked. Once the type initializer has run, the locked
    threads are unlocked and are able to access the `Instance` property.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多个类需要同时访问一个属性实例，则其中一个线程将被要求运行**静态构造函数**（也称为**类型初始化程序**）。在等待类型初始化程序运行时，所有其他线程将被锁定。一旦类型初始化程序运行，被锁定的线程将被解锁，并能够访问`Instance`属性。
- en: Static constructors are thread-safe as they are guaranteed to run only once
    per application domain. They are executed before accessing any static members
    and before any class instantiation is performed.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 静态构造函数是线程安全的，因为它们保证每个应用程序域只运行一次。它们在访问任何静态成员和执行任何类实例化之前执行。
- en: Should an exception be raised in and escape from a static constructor, then
    `TypeInitializationException` is generated, which causes the CLR to exit your
    program.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果静态构造函数中引发异常并且逃逸，那么将生成`TypeInitializationException`，这会导致CLR退出您的程序。
- en: Before any threads can access a class, static initializers and static constructors
    must finish executing.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何线程可以访问一个类之前，静态初始化程序和静态构造函数必须执行完成。
- en: '**Static methods** only keep a single copy of the method and its data at the
    type level. This means that the same method and its data will be shared between
    different instances. Each thread in an application has its own stack. Value types
    passed into static methods are created on the calling thread''s stack, and so
    they are thread-safe. This means that if two threads call the same code and pass
    the same value in, there will be two copies of that value—one on each thread''s
    stack. So, multiple threads will not affect each other.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**静态方法**只在类型级别保留方法及其数据的单个副本。这意味着相同的方法及其数据将在不同实例之间共享。应用程序中的每个线程都有自己的堆栈。传递给静态方法的值类型是在调用线程的堆栈上创建的，因此它们是线程安全的。这意味着如果两个线程调用相同的代码并传递相同的值，那么该值将有两个副本，分别在每个线程的堆栈上。因此，多个线程不会相互影响。'
- en: However, if you have a static method that accesses a member variable, then it
    is not thread-safe. Two different threads call the same method and so both will have
    access to the member variable. A process or context-switching occurs between threads;
    each thread will access and modify the member variable. This leads to race conditions,
    as you saw earlier in this chapter.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您有一个访问成员变量的静态方法，那么它就不是线程安全的。两个不同的线程调用相同的方法，因此两者都将访问成员变量。在线程之间发生进程或上下文切换；每个线程将访问并修改成员变量。这会导致竞争条件，正如您在本章前面看到的那样。
- en: You also run into problems if you pass reference types into a static method,
    as different threads will have access to the same reference type. This also causes
    a race condition.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将引用类型传递给静态方法，也会遇到问题，因为不同的线程将可以访问相同的引用类型。这也会导致竞争条件。
- en: When working with static methods that will be used across threads, avoid member
    variable access and do not pass reference types in. Static methods are thread-safe
    as long as you pass in primitive types and don't modify the state.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用将在多个线程之间使用的静态方法时，避免访问成员变量并且不要传递引用类型。只要传递原始类型并且不修改状态，静态方法就是线程安全的。
- en: Now that we've discussed static constructors and methods, we will run through
    some example code.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了静态构造函数和方法，我们将运行一些示例代码。
- en: Adding static constructors to our sample code
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向我们的示例代码添加静态构造函数
- en: 'Start a new .NET Framework console application. Add a class called `StaticConstructorTestClass`
    to the project. Then, add a read-only static string variable called `_message`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个新的.NET Framework控制台应用程序。向项目添加一个名为`StaticConstructorTestClass`的类。然后，添加一个名为`_message`的只读静态字符串变量：
- en: '[PRE37]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `_message` variable is returned to the caller by the `Message()` method.
    Let''s write the `Message()` method now:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`Message()`方法通过`_message`变量将消息返回给调用者。现在让我们编写`Message()`方法：'
- en: '[PRE38]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This method returns the message stored in the `_message` variable. Now, we
    need to write our constructor:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法返回存储在`_message`变量中的消息。现在，我们需要编写我们的构造函数：
- en: '[PRE39]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In our constructor, we write a message to the screen. We then set the member
    variable and let the thread sleep for a second. Then, we set the message again
    and write another message to the console. Now, in the `Program` class, update
    the `Main()` method, as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的构造函数中，我们向屏幕写入一条消息。然后，我们设置成员变量并让线程休眠一秒钟。然后，我们再次设置消息并向控制台写入另一条消息。现在，在`Program`类中，更新`Main()`方法如下：
- en: '[PRE40]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Our `Main()` method instantiates the `Program` class. The `StaticConstructorExample()`
    method is then called. When the program halts and we can see the result, we join
    threads. You can see the output in the following screenshot:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Main()`方法实例化`Program`类。然后调用`StaticConstructorExample()`方法。当程序停止并且我们可以看到结果时，我们加入线程。您可以在以下截图中看到输出：
- en: '![](img/d79fb288-6c27-4ef6-8c6d-8cfa2aa74ac3.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d79fb288-6c27-4ef6-8c6d-8cfa2aa74ac3.png)'
- en: We'll now take a look at examples of static methods.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看一些静态方法的示例。
- en: Adding static methods to our sample code
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向我们的示例代码添加静态方法
- en: 'We are now going to look at thread-safe static methods and non-thread-safe
    methods in action. Add a new class called `StaticExampleClass` to a new .NET Framework
    console application. Then, add the following code:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将看看线程安全的静态方法和非线程安全的方法是如何运作的。向新的.NET Framework控制台应用程序添加一个名为`StaticExampleClass`的新类。然后，添加以下代码：
- en: '[PRE41]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'At the top of our class, we add three integers—`_x`, `_y`, and `_z`—with values
    of `1`, `2`, and `3`, respectively. These variables can be modified between threads.
    Now, we will add a static constructor to print out the values of these variables:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'As you can see, the static constructor simply prints out the values of the
    variables to the console window. Our first method will be a thread-safe method
    called `ThreadSafeMethod()`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This method is thread-safe because it only operates on by value parameters.
    It does not interact with the member variables and does not include any by reference
    values. So, no matter what values are passed in, you will always get the expected
    result.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that regardless of whether only a single thread or even millions
    of threads are accessing the method, the output for each thread will be what you
    expect when you pass in the input values, even despite context switching. The
    following screenshot shows the output:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/014d5718-ac04-4629-92ea-2e7e0405cc34.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
- en: Now that we have looked at thread-safe methods, it is only right that we look
    at non-thread-safe methods. By now, you know that a static method that operates
    on by reference values or static member variables is not thread-safe.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'In our next example, we will use a method with the same three parameters as
    `ThreadSafeMethod()`, but this time, we will set the member variables, output
    a message, go to sleep for a while, and then awake to print the values out again.
    Add the following `NotThreadSafeMethod()` method to `StaticExampleClass`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In this method, we set the member variables to the values passed into the method.
    We then output those values to the console windows and go to sleep for 300 milliseconds.
    Then, upon waking from our sleep, we print the values out again. In the `Program`
    class, update the `Main()` method, as shown:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the `Main()` method, we instantiate the program class, call `ThreadUnsafeMethodCall()`,
    and then wait for the user to press a key before exiting. So, let''s add `ThreadUnsafeMethodCall()`
    to the `Program` class:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This method produces 10 threads that call `NotThreadSafeMethod()` of `StaticExampleClass`.
    If you run the code, you will see an output similar to that in the following screenshot:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/37710a9d-f8db-4e4d-9cb1-6bb2e7a4b3ec.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
- en: As you can see, the output is not what we would expect. This is because of the
    pollution from different threads. This leads us nicely to the next section on
    mutability, immutability, and thread safety.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Mutability, immutability, and thread safety
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Mutability** is a source of bugs in multi-threaded applications. A mutable
    bug is normally a data bug caused by values being updated and shared between threads.
    To remove the risk of mutability bugs, it is best to use **immutable types**.
    The guaranteed safe execution of a body of code by multiple threads at the same
    time is called **thread safety**. When working with multi-threaded programs, it
    is important that your code is thread-safe. Your code is thread-safe if it removes
    race conditions and deadlocks, along with problems caused by mutability.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: An object that cannot be modified after it has been created is an **immutable
    object**. Once created, if passed between threads using correct thread synchronization,
    all threads will see the same valid state of an object. Immutable objects allow
    you to share data safely between threads.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: An object that can be modified after it has been created is a mutable object.
    Mutable objects can have their data values changed between threads. This can lead
    to some serious data corruption. So, even if the program does not crash, it can
    leave the data in an invalid state. Therefore, when working with multiple threads
    of execution, it is important that your objects are immutable. In [Chapter 3](3d63c927-7dd3-4985-b50d-64d98c108a46.xhtml), *Classes,
    Objects, and Data Structures,* we went through creating and using immutable data
    structures for your immutable objects.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: To ensure thread safety, do not use mutable objects, pass parameters by reference,
    or modify member variables—only pass parameters by value and only operate on parameter
    variables. Do not access member variables. Immutable structures are a good and
    thread-safe way to pass data between objects.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: We will take a brief look at mutability, immutability, and thread safety with
    the following examples. We'll start with mutability in terms of thread safety.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Writing code that is mutable and not thread-safe
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To demonstrate mutability within a multi-threaded application, we will write
    a new .NET Framework console application. Add a new class to the application called
    `MutableClass` with the following code:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In our `MutableClass` class, we have a constructor that takes an integer array
    as an argument. A member integer array is then assigned the array passed into
    the constructor. The `GetIntArray()` method returns the integer array member variable.
    If you look at this class, you would not think it is mutable because once the
    array is passed into the constructor, the class provides no way to modify it.
    Yet, the integer array passed into the constructor is mutable. The `GetIntArray()`
    method returns a reference to the mutable array.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `Program` class, we will add the `MutableExample()` method to show that
    the integer array is mutable:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In our `MutableExample()` method, we have declared and initiated an integer
    array of items from `0` to `9`. We then declare a new instance of `MutableClass`
    and pass in the integer array. Next, we print out the contents of the initial
    array before it is modified. Then, we loop nine times. For each iteration, we
    increase the array at the index specified by the current loop count value of `x` so
    that it equals `x + 1`. After that, we start the thread. Now, update the `Main()`
    method, as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Our `Main()` method simply calls `MutableExample()` and then waits for a keypress.
    Run the code and you should see something as in the following screenshot:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/56fe7d8d-f687-47a3-86f6-909b4dfad3f1.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
- en: As you can see, even though we only created one instance of `MutableClass` before
    creating and running our threads, changing the local array modifies the array
    in the instance of `MutableClass`. This proves that the arrays are mutable, and
    so they are not thread-safe.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: We will now look at immutability in terms of thread safety.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Writing code that is immutable and thread-safe
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our immutability example, we will again create a .NET Framework console
    application and we''ll use the same array. Add a class called `ImmutableStruct`
    and modify the code, as shown:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Instead of using a normal integer array, we employ `ImmutableArray`. An immutable
    array is passed into the constructor and assigned to the `_immutableArray` member
    variable. Our `GetIntArray()` method returns the immutable array as a normal integer
    array.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `ImmutableExample()` array to the `Program` class:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In our `ImmutableExample()` method, we create an array of integers that we pass
    into the constructor of `ImmutableStruct` as an immutable array. We then print
    the content of the local array before modification. Then, we loop nine times.
    In each iteration, we access the location of the count of the current iteration in
    the array and add the count of the current iteration plus one to the variable
    at that position in the array.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'We then assign a copy of the `immutableStruct` array to a local variable via
    a call to `GetIntArray()`. Then, we proceed to print out the values of the returned
    array. Finally, we start the thread. Call the `ImmutableExample()` method from
    your `Main()` method and then run the code. You should see the following output:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d54dd02-cdb2-4612-aba5-e67a652dbd9b.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
- en: As you can see, the array's content is not modified by updating the local array.
    This version of our program shows that our program is thread-safe.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Let's briefly run through what we've learned about thread safety so far in the
    next section.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Understanding thread safety
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you saw in the previous two sections, it is very important to be careful
    when writing multi-threaded code. Writing thread-safe code can be very difficult,
    especially in larger projects. You have to be particularly careful with collections,
    passing parameters by reference, and when accessing member variables within static
    classes. The best practices for multi-threaded applications are to only pass immutable
    types, not to access static member variables, and if any code that is not thread-safe
    must be executed, then to lock the code using a lock, mutex, or semaphore. Although
    you have already seen code like this in action in this chapter, we will quickly
    refresh our memory on this with some code snippets.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how to write an immutable type using `readonly
    struct`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In our `ImmutablePerson` structure, we have a public constructor that takes
    an integer for the ID and strings for the first and last name. We assign the `id`,
    `firstName`, and `lastName` parameters to member read-only variables. The only
    access to the data is via read-only properties. This means that there is no way
    to modify the data. Since the data cannot be modified once it has been created,
    it is classed as thread-safe. Because it is thread-safe, it cannot be modified
    by different threads. The only way to modify the data would be to create a new
    struct with the new data.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Structs can be mutable, just like classes. However, to pass data around that
    you don't want to be modified, then read-only structs are a good, lightweight
    choice. They are faster to create and destroy than classes as they are added to
    the stack—that is, unless they are part of a class that is added to the heap.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier on, we saw how collections are mutable. However, there is also a namespace
    of immutable collections called `System.Collections.Namespace`. The following
    table lists various items from this namespace:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef71435c-f95c-44b7-b5ee-f046b7e1be1e.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
- en: The `System.Collections.Immutable` namespace contains a number of immutable
    collections that you can use safely between threads. Refer to [https://docs.microsoft.com/en-us/dotnet/api/system.collections.immutable?view=netcore-3.1](https://docs.microsoft.com/en-us/dotnet/api/system.collections.immutable?view=netcore-3.1) for
    more details.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a lock object in C# is really straightforward, as the following code
    snippet shows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We create and instantiate the `_lock` member variable. Then, when it comes to
    executing code that is not thread-safe, we wrap the code in the lock and pass
    in the `_lock` variable to use as the lock object. When a thread enters the lock,
    all other threads are barred from executing the code until the thread leaves the
    lock. One problem with using this code is that threads can enter a deadlock situation.
    One way around this is to use a mutex.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use a synchronization primitive for interprocess synchronization. Start
    by adding the following code to the top of the class that has code that needs
    protection:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Then, to use the mutex, you will need to wrap the code that needs protection
    with the following `try/catch` block:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the preceding code, the `WaitOne()` method blocks the current thread until
    the wait handle receives a signal. As soon as the mutex is signaled, the `WaitOne()`
    method returns `true`. The calling thread then assumes ownership of the mutex.
    Protected resources can then be accessed by the calling thread. When the work
    is finished on the protected resource, the mutex is released by calling `ReleaseMutex()`. `ReleaseMutex()`
    is called in the `finally` block because you don't want a thread to keep a resource
    locked if it raises an exception for whatever reason. So, always release a mutex
    in a `finally` block.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'Another mechanism for protecting access to resources is using a semaphore.
    Semaphores are coded much like a mutex and they perform the same role of protecting
    resources. The main difference between a semaphore and a mutex is that a mutex
    is a locking mechanism and a semaphore is a signaling mechanism. To use semaphores
    instead of locks and mutexes, add the following line to the top of a class:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 保护资源访问的另一种机制是使用信号量。信号量的编码方式与互斥体非常相似，它们执行保护资源的相同角色。信号量和互斥体之间的主要区别在于互斥体是一种锁定机制，而信号量是一种信号机制。要使用信号量而不是锁和互斥体，请在类的顶部添加以下行：
- en: '[PRE56]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We have now added a new semaphore variable. The first parameter states the
    initial number of requests for the semaphore that can be granted concurrently.
    The second parameter states the maximum number of requests for the semaphore that
    can be granted concurrently. You will then protect access to a resource in your
    methods, as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在添加了一个新的信号量变量。第一个参数表示可以同时授予的信号量的初始请求数。第二个参数表示可以同时授予的信号量的最大请求数。然后您将保护对资源的访问，如下所示：
- en: '[PRE57]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The current thread is blocked until the current wait handle receives a signal.
    The thread can then do its work. Finally, the semaphore is released.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当前线程被阻塞，直到当前等待句柄接收到信号。然后线程可以执行其工作。最后，信号量被释放。
- en: You have seen, in this chapter, how to use locks, mutexes, and semaphores to
    lock code that is not thread-safe. Also remember that background threads terminate
    when the process completes and terminates, whereas foreground threads will continue
    executing until completion. If you have any code that must run to completion without
    the thread being terminated halfway through what it is doing, then you are better
    off using foreground threads over background threads.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经看到如何使用锁定、互斥体和信号量来锁定不是线程安全的代码。还要记住，后台线程在进程完成和终止时终止，而前台线程将继续执行直到完成。如果您有任何必须在不被终止的线程中途运行完成的代码，那么最好使用前台线程而不是后台线程。
- en: The next section covers synchronized method dependencies.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节涵盖了同步方法依赖关系。
- en: Synchronized method dependencies
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步方法依赖关系
- en: To synchronize your code, use a lock statement as we did previously. You can
    also reference the `System.Runtime.CompilerServices` namespace in your projects.
    Then, you can add the `[MethodImpl(MethodImplOptions.Synchronized)]` annotation
    to methods and properties.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 要同步您的代码，使用锁定语句，就像我们之前所做的那样。您还可以在项目中引用`System.Runtime.CompilerServices`命名空间。然后，您可以在方法和属性中添加`[MethodImpl(MethodImplOptions.Synchronized)]`注释。
- en: 'Here is an example of the `[MethodImpl(MethodImplOptions.Synchronized)]` annotation
    applied to a method:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是应用于方法的`[MethodImpl(MethodImplOptions.Synchronized)]`注释的示例：
- en: '[PRE58]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Here is an example of using `[MethodImpl(MethodImplOptions.Synchronized)]` with
    a property:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`[MethodImpl(MethodImplOptions.Synchronized)]`与属性的示例：
- en: '[PRE59]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As you can see, it is easy to encounter a deadlock or a race condition, but
    it is just as easy to overcome deadlocks by using `Monitor.TryEnter()` and race
    conditions with `Task.ContinueWith()`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，很容易遇到死锁或竞争条件，但使用`Monitor.TryEnter()`和`Task.ContinueWith()`同样容易克服死锁和竞争条件。
- en: In the next section, we look at the `Interlocked` class.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看看Interlocked类。
- en: Using the Interlocked class
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Interlocked类
- en: In multi-threaded applications, errors can creep in during the thread scheduler
    context-switching process. One of the main problems that arises is the update
    of the same variables by different threads. The methods of the `System.Threading.Interlocked`
    class in the `mscorlib` assembly help to protect against these kinds of errors.
    The methods of the `Interlocked` class do not throw exceptions, and so they are
    very helpful in applying simple state changes in a more performant way than using
    the `lock` statement that we've seen previously.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程应用程序中，在线程调度程序上下文切换过程中可能会出现错误。一个主要的问题是不同线程更新相同变量。`mscorlib`程序集中`System.Threading.Interlocked`类的方法有助于防止这类错误。`Interlocked`类的方法不会抛出异常，因此在应用简单状态更改时比使用之前看到的`lock`语句更有效。
- en: 'The methods available in the `Interlocked` class are as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: Interlocked类中可用的方法如下：
- en: '`CompareExchange`: Compares two variables and stores the results in a different
    variable'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompareExchange`：比较两个变量并将结果存储在不同的变量中'
- en: '**`Add`**: Adds two `Int32` or `Int64` integer variables together and stores
    the result in the first integer'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`Add`**：将两个`Int32`或`Int64`整数变量相加，并将结果存储在第一个整数中'
- en: '`Decrement`: Decrements the `Int32` and `Int64` integer variable values and
    stores their results'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Decrement`：减少`Int32`和`Int64`整数变量的值并存储它们的结果'
- en: '`Increment`:Increments the `Int32` and `Int64` integer variable values and
    stores their results'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Increment`：增加`Int32`和`Int64`整数变量的值并存储它们的结果'
- en: '`Read`: Reads integer variables of the `Int64` type'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Read`：读取`Int64`类型的整数变量'
- en: '`Exchange`:Exchanges values between variables'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exchange`：在变量之间交换值'
- en: 'We are now going to write a simple console application that demonstrates these
    methods. Start by creating a new .NET Framework console application. Add the following
    lines to the top of the `Program` class:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将编写一个简单的控制台应用程序来演示这些方法。首先创建一个新的.NET Framework控制台应用程序。将以下行添加到`Program`类的顶部：
- en: '[PRE60]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `_value` variable will be used to demonstrate the update of variables using
    the interlocking methods. The `_resourceInUse` variable is used to indicate whether
    a resource is in use. Add the `CompareExchangeVariables()` method:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`_value`变量将用于演示使用互锁方法更新变量。`_resourceInUse`变量用于指示资源是否正在使用。添加`CompareExchangeVariables()`方法：'
- en: '[PRE61]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In our `CompareExchangeVariables()` method, we call the `CompareExchange()`
    method to compare `_value` with `long.MaxValue`. If the two values are equal,
    then `_value` is replaced with the value of `123`. We''ll now add our `AddVariables()`
    method:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`CompareExchangeVariables()`方法中，我们调用`CompareExchange()`方法来比较`_value`和`long.MaxValue`。如果两个值相等，则用`123`的值替换`_value`。现在我们将添加我们的`AddVariables()`方法：
- en: '[PRE62]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The `AddVariables()` method calls the `Add()` method to access the `_value`
    member variable and update it with the value of `_value` plus `321`. Next, we''ll
    add our `DecrementVariable()` method:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This method calls the `Decrement()` method, which decrements the `_value` member
    variable by 1\. Our next method is `IncrementValue()`:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In our `IncrementVariable()` method, we increment the `_value` member variable
    by calling the `Increment()` method. The next method we will write is the `ReadVariable()`
    method:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Since 64-bit read operations are atomic, calling the `Interlocked.Read()` method
    is unnecessary. However, on 32-bit systems, for 64-bit reads to be atomic, you
    need to call the `Interlocked.Read()` method. Add the `PerformUnsafeCodeSafely()`
    method:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `PerformUnsafeCodeSafely()` method loops five times. Each iteration of
    the loop calls the `UseResource()` method, and then the thread goes to sleep for
    1 second. Now, we''ll add the `UseResource()` method:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The `UseResource()` method prevents a lock from being obtained if the resource
    is in use, as identified by the `_resourceInUse` variable. We start by setting
    the `_resourceInUse` member variable value to `1` by calling the `Exchange()`
    method. The `Exchange()` method returns an integer, which we compare against `0`.
    If the value returned by `Exchange()` is `0`, then the method is not in use.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: If the method is in use, then we output a message informing the user that the
    current thread was denied the lock.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: If the method is not in use, then we output a message informing the user that
    the current thread has obtained a lock. We then call the `NonThreadSafeResourceAccess()`
    method and then send the thread to sleep for half a second to simulate work.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'When the thread awakes, we output a message informing the user that the current
    thread has exited the lock. Then, we release the lock by calling the `Exchange()`
    method and setting the value of `_resourceInUse` to `0`. Add the `NonThreadSafeResourceAccess()`
    method:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '`NonThreadSafeResourceAccess()` is where non-thread-safe code is executed in
    the safety of the lock. In our method, we simply inform the user with a message.
    The last job to do before we run our code is to update our `Main()` method, as
    follows:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Our `Main()` method calls the methods that test the `Interlocked` methods.
    Run the code and you should see something similar to the following:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a355f2b5-6574-4bd0-8168-9f276553d81d.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
- en: We'll now go over some general recommendations.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: General recommendations
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this final section, we will look at some general recommendations from Microsoft
    for working on multi-threaded applications. They include the following:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Avoid using `Thread.Abort` to terminate other threads.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a mutex, `ManualResetEvent`, `AutoResetEvent`, and `Monitor` to synchronize
    activities between multiple threads.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where possible, use a thread pool for your worker threads.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have any worker threads that gets blocked, then use `Monitor.PulseAll`
    to notify all the threads of a change in the worker thread's state.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid using this, type instances, and string instances including string literals
    as `lock` objects. Avoid using types of the `lock` objects.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instance locks can result in deadlocks, so exercise caution when using them.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `try/finally` block with threads that enter a monitor so that in the
    `finally` block, you ensure that the thread leaves the monitor by calling `Monitor.Exit()`.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use different threads for different resources.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid assigning multiple threads to the same resource.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I/O tasks should have their own thread as they block when performing I/O operations.
    This way, you allow other threads to run.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User input should have its own dedicated thread.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve performance for simple state changes by using the methods of the `System.Threading.Interlocked`
    class instead of the lock statement.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For heavily used code, avoid synchronization as it can lead to deadlocks and
    race conditions.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make static data thread-safe by default.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instance data must not be thread-safe by default; otherwise, you decrease performance,
    increase lock contention, and introduce the possibility of race conditions and
    deadlocks occurring.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid using static methods that alter state as they lead to threading bugs.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That concludes our look at threading and concurrency. Let's run through a summary
    of what we have learned.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered what threading is and how to use it. We looked at
    the problems of deadlocks and race conditions in action, and we saw how to prevent
    these exceptional circumstances using a lock statement and the TPL library. We
    also discussed the thread safety of static constructors, static methods, immutable
    objects, and mutable objects. We saw why using immutable objects is a thread-safe
    way of transferring data between threads, and we reviewed some general recommendations
    for working with threads.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: We also saw how making your code thread-safe can have a lot of benefits. In
    the next chapter, we will look at designing effective APIs. But for now, you can
    test your knowledge by answering the following questions and you can further your
    reading by referring to the links provided.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a thread?
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many threads are there in a single-threaded application?
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What types of threads are there?
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What thread terminates as soon as the program is exited?
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What thread continues through to completion, even if the program is exited?
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What code makes a thread sleep for half a millisecond?
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you instantiate a thread that calls a method named `Method1`?
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you make a thread a background thread?
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a deadlock?
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you exit a lock obtained using `Monitor.TryEnter(objectName)`?
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you recover from a deadlock?
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a race condition?
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is one way to prevent race conditions?
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What makes static methods unsafe?
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are static constructors thread-safe?
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is responsible for managing groups of threads?
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an immutable object?
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are immutable objects preferred to mutable objects in threaded applications?
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://www.c-sharpcorner.com/blogs/mutex-and-semaphore-in-thread](https://www.c-sharpcorner.com/blogs/mutex-and-semaphore-in-thread) provides
    examples of using a mutex and a semaphore.'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.guru99.com/mutex-vs-semaphore.html](https://www.guru99.com/mutex-vs-semaphore.html) explains
    the differences between a mutex and a semaphore.'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/static-constructors](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/static-constructors) is
    the official Microsoft documentation on static constructors.'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices](https://docs.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices) is
    the official Microsoft guidance on Microsoft''s managed threading best practices.'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/task-parallel-library-tpl](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/task-parallel-library-tpl) is
    the official Microsoft API documentation for the TPL.'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.c-sharpcorner.com/UploadFile/1d42da/interlocked-class-in-C-Sharp-threading/](https://www.c-sharpcorner.com/UploadFile/1d42da/interlocked-class-in-C-Sharp-threading/) covers
    the Interlocked class in C# threading.'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://geekswithblogs.net/BlackRabbitCoder/archive/2012/08/23/c.net-little-wonders-interlocked-read-and-exchange.aspx](http://geekswithblogs.net/BlackRabbitCoder/archive/2012/08/23/c.net-little-wonders-interlocked-read-and-exchange.aspx) provides
    a discussion on `System.Threading.Interlocked` with examples.'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.albahari.com/threading/](http://www.albahari.com/threading/) is
    a link to a free eBook by Joseph Albahari about threading in C#.'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/dotnet/api/system.collections.immutable?view=netcore-3.1](https://docs.microsoft.com/en-us/dotnet/api/system.collections.immutable?view=netcore-3.1) is
    the official Microsoft documentation on the immutable collections available in
    the `System.Collections.Immutable` namespace.'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/api/system.collections.immutable?view=netcore-3.1](https://docs.microsoft.com/en-us/dotnet/api/system.collections.immutable?view=netcore-3.1)
    是微软官方文档，介绍了`System.Collections.Immutable`命名空间中可用的不可变集合。'
