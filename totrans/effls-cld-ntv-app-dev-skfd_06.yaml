- en: '[*Chapter 4*](B17385_04_Final_PD_ePub.xhtml#_idTextAnchor044): Understanding
    Skaffold''s Features and Architecture'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we gained a basic understanding of Skaffold through
    some coding examples. This chapter will cover the features that are provided by
    Skaffold. Additionally, we will explore Skaffold's internals by looking at its
    architecture, workflow, and the `skaffold.yaml` configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Skaffold's features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Demystifying Skaffold's architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Skaffold workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deciphering Skaffold's configuration with `skaffold.yaml`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a solid understanding of the features
    that Skaffold provides, and how it performs all the magic, by looking at its workflow
    and architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with the examples in this chapter, you will need to have the
    following software installed:'
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse ([https://www.eclipse.org/downloads/](https://www.eclipse.org/downloads/))
    or IntelliJ IDE ([https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git ([https://git-scm.com/downloads](https://git-scm.com/downloads))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skaffold ([https://skaffold.dev/docs/install/](https://skaffold.dev/docs/install/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Desktop for macOS and Windows ([https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can download the code examples for this chapter from the GitHub repository
    at [https://github.com/PacktPublishing/Effortless-Cloud-Native-App-Development-Using-Skaffold](https://github.com/PacktPublishing/Effortless-Cloud-Native-App-Development-Using-Skaffold).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Skaffold's features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B17385_03_Final_PD_ePub.xhtml#_idTextAnchor034), *Skaffold
    – Easy-Peasy Cloud-Native Kubernetes Application Development*, we were introduced
    to Skaffold. We uncovered some of its features by building and deploying a Spring
    Boot application to the local Kubernetes cluster. However, Skaffold is capable
    of far more than that, so let's take a look at some of its features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Skaffold has the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Easy to share**: Sharing your project among the same or different teams,
    provided they already have Skaffold installed, is effortless. They have to run
    the following commands to proceed with their development activities:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Integrated with IDE**: Many IDEs, such as IntelliJ and VS Code, support the
    **Cloud Code** plugin developed by Google, which internally uses Skaffold and
    its API to provide a better developer experience while developing a Kubernetes
    application. Using the IntelliJ or VS code **Google Cloud Code Extension** plugin
    makes it easier for you to create, edit, and update the `skaffold.yaml` file with
    its code completion feature. For example, to give you a little more context regarding
    this, the plugin can detect that the project is using Skaffold to build and deploy
    by looking at the `skaffold.yaml` configuration file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 4.1 – The IntelliJ Cloud code plugin detects the Skaffold configuration'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_4.1_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – The IntelliJ Cloud code plugin detects the Skaffold configuration
  prefs: []
  type: TYPE_NORMAL
- en: You can also look up supported builders and deployers with Skaffold using the
    code completion feature. We will cover the Cloud Code plugin specifically in [*Chapter
    7*](B17385_07_Final_PD_ePub.xhtml#_idTextAnchor092),  *Building and Deploying
    a Spring Boot Application with the Cloud Code Plugin*.
  prefs: []
  type: TYPE_NORMAL
- en: '**File sync**: Skaffold has an excellent file sync feature. It can copy the
    changed files directly to an already running container to avoid rebuilding, redeploying,
    and restarting the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will learn more about this in [*Chapter 5*](B17385_05_Final_PD_ePub.xhtml#_idTextAnchor052),
    *Installing Skaffold and Demystifying Its Pipeline Stages*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Super-fast local development**: In the previous chapter, you learned that
    building and deploying an application with Skaffold is pretty quick as it can
    figure out whether your Kubernetes context is set to a local Kubernetes cluster
    and will avoid pushing the image to a remote container registry. Therefore, you
    can bypass that expensive network hop and also preserve the battery life of your
    laptop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not only that, but Skaffold detects your code changes in real time and automates
    the build, push, and deploy workflows. So, you can continue working within your
    inner development loop with the focus on coding, and there is no need to leave
    that loop until you are completely sure about the change you are making. This
    not only accelerates your inner development loop but also makes you more productive.
  prefs: []
  type: TYPE_NORMAL
- en: '**Effortless remote development**: So far, while reading this book, you might
    have the impression that Skaffold can only accelerate the inner development loop.
    Oh, boy! You are in for a surprise as Skaffold can handle outer development loop
    workflows as well. For example, you can use Skaffold to create full-fledged production-ready
    CI/CD pipelines. We will cover this specifically in [*Chapter 9*](B17385_09_Final_PD_ePub.xhtml#_idTextAnchor116),
    *Creating a Production-Ready CI/CD Pipeline with Skaffold*. Not only that, but
    you can also switch your Kubernetes context in your local development environment
    using commands such as `kubectl config use-context context-name` and perform a
    deployment to a remote cluster of your choice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we are talking about remote development, I just wanted to highlight another
    point—you don't need to run Docker daemon if you are using the `jib-maven` plugin
    for a remote build (that is, if you are pushing to a remote container registry).
    You can also use something like **Google Cloud Build** to do remote builds. Cloud
    Build is a service provided by **Google Cloud Platform** that you can use to execute
    your builds and create serverless CI/CD pipelines in the cloud for your cloud-native
    applications. It might be slow if you run it from your local system, but it's
    worth exploring.
  prefs: []
  type: TYPE_NORMAL
- en: '**Built-in image tag management**: In the previous chapter, while declaring
    Kubernetes deployment manifests, we only mentioned the image name and not the
    image tag while building and deploying the Spring Boot application. For example,
    in the following snippet from the previous chapter, in the `image:` field, we
    only mentioned the image name:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Typically, we have to tag an image before pushing and then use the same image
    tag while pulling. For example, you would also have to specify the image tag in
    the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The reason for this is that Skaffold automatically generates the image tag for
    you, out of the box, every time you rebuild the image. This is so that you don't
    have to edit the Kubernetes manifests manually. The default tagging strategy with
    Skaffold is `gitCommit`.
  prefs: []
  type: TYPE_NORMAL
- en: We will cover this in greater detail in [*Chapter 5*](B17385_05_Final_PD_ePub.xhtml#_idTextAnchor052),
    *Installing Skaffold and Demystifying Its Pipeline Stages*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lightweight**: Skaffold is entirely a CLI tool. There are no server-side
    components to look for while working with Skaffold. This makes it extremely lightweight,
    easy to use, and there is no maintenance burden. The size of the Skaffold binary
    is around 63 MB.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pluggable architecture**: Skaffold has a pluggable architecture. This will
    eventually mean that you can pick and choose a build and deploy tool of your choice.
    Bring your own tools, and Skaffold will adjust itself accordingly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Purpose-built for CI/CD pipelines**: Skaffold can help you to create effective
    CI/CD pipelines. For example, you can use the `skaffold run` command to execute
    an end-to-end pipeline or use individual commands such as `skaffold build` or
    `skaffold deploy`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Furthermore, with commands such as `skaffold render` and `skaffold apply`, you
    can create a **GitOps**-style continuous delivery workflow for your application.
    GitOps allows you to store your application's desired state inside a Git repository
    in the form of Kubernetes manifests. It also allows others to view your infrastructure
    as code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Effortless environment management**: Skaffold allows you to define, build,
    test, and deploy configurations for different environments. You can keep one set
    of configurations for development or staging and another for production. Also,
    you can keep completely different configurations on a per-environment basis. You
    can achieve this by using Skaffold profiles. This is relatively similar to the
    `profiles` feature provided for Spring Boot applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Please refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Skaffold profiles'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_4.2_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 – Skaffold profiles
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical Skaffold profile consists of the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`build`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`activation`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deploy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`patches`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of these parts are quite obvious, as they explain the unique name of the
    profile, the build steps, the deployment steps, and how the images are tested.
    Let's move on to discuss patches and activation.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's understand patches.
  prefs: []
  type: TYPE_NORMAL
- en: Skaffold profile patches
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As the name suggests, patches are a more verbose way of overriding individual
    values in a `skaffold.yaml` file. For example, in the following snippet, instead
    of overriding the whole build section, the `dev` profile defines a different `Dockerfile`
    for the first artifact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `op` string underneath the `patches` section specifies the operation
    to be performed by this patch. The `path` string specifies the position in the
    `.yaml` file where the operation that you defined in the `op` string takes place,
    and the `value` object specifies the value it should be replaced with.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following operations are supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '`add`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`replace`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`move`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`copy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To summarize, here, we instruct Skaffold to replace the `Dockerfile` that was
    used to build the first `docker.io/hiashish/skaffold-example` image with a different
    `Dockerfile` named `Dockerfile_dev`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's discuss activation objects in profiles.
  prefs: []
  type: TYPE_NORMAL
- en: Skaffold profile activation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can activate a profile in Skaffold in one of the following two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With `skaffold.yaml` activations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, let''s discuss how you can activate a profile using CLI. For example,
    in the following `skaffold.yaml` file, underneath the `profiles` section, we have
    declared a profile name, called `gcb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This profile will be activated when running the `skaffold run` or `skaffold
    dev` command by passing either the `--profile` or `–p` CLI flag. If you run the
    following command, then Skaffold will use **Google Cloud Build** to build the
    artifacts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we have not specified the `deploy` section underneath the `gcb`
    profile. This means that Skaffold will continue to use `kubectl` for deployment.
    If your use case requires multiple profiles, you can use the `-p` flag numerous
    times or pass comma-separated profiles, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try to understand this using another example. In this example, we will
    use the Spring Boot application that we built in [*Chapter 3*](B17385_03_Final_PD_ePub.xhtml#_idTextAnchor034),
    *Skaffold – Easy-Peasy Cloud-Native Kubernetes Application Development*. In that
    scenario, we used Jib to containerize the application; however, in this example,
    we will use a multistage Docker build to create a slim Docker image of our application.
    The following is the `Dockerfile` of our Spring Boot application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can explain the multistage `Dockerfile` build as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first stage of the build, we have used the `maven:3-adoptopenjdk-16`
    image to build and create `jar` for our application using the `mvn clean package`
    Maven command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the second stage, we have copied `jar` we made in the previous build stage
    and created a new final image based on a significantly smaller *Java 16 JRE base
    image*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final Docker image does not include the JDK or Maven image, just the JRE
    image. The only downside to this approach is that the build time is higher because
    all of the required dependencies need to be downloaded during the first stage
    of the build.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: You can use Docker multistage builds to create slimmer Docker images of your
    application. The size of a typical JDK image is around 650 MB, and with the Docker
    multistage build, we can reduce its size by half by using JRE as the base image
    in the last stage of the multistage build.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, you can further reduce the size of the image using Java tools
    such as `jdeps` and `jlink` (introduced in Java 9). While `jdeps` helps you to
    identify the required JVM modules, `jlink` allows you to create a customized JRE.
    With the combination of these tools, you can create a customized JRE, which results
    in an even slimmer Docker image of your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate the use of profiles, we will make the following changes to the
    `skaffold.yaml` file. The following is the `skaffold.yaml` file in which we added
    a new profile called `docker`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the `skaffold run --profile docker` command to build and deploy
    our Spring Boot application. The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding logs, you can see that, first, Skaffold began building our
    image using Docker. Also, we have used a multistage build, and then, in steps
    1 to 6, we are into the first stage of the build, wherein we created the `jar`
    of our application inside the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: in *steps 6 to 10*, we are in the second stage of the build where we have used
    `adoptopenjdk:16-jre` as the base image since we only need JRE to run our application.
    Typically, JRE images are of a smaller size than JDK.
  prefs: []
  type: TYPE_NORMAL
- en: 'This final output is our containerized application, which should appear as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Finally, Skaffold deploys our containerized application to the local Kubernetes
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to activate a profile is to use the activation object array in
    `skaffold.yaml` to automatically activate a profile based upon the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kubeContext`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An environment variable: `env`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Skaffold command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Please refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Skaffold profile activation using the skaffold.yaml file'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_4.3_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3 – Skaffold profile activation using the skaffold.yaml file
  prefs: []
  type: TYPE_NORMAL
- en: Let's attempt to understand this activation option using an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code example, we have two profiles—`profile-staging` and `profile-production`.
    As their names suggest, `profile-staging` will be used for the staging environment,
    while `profile-production` will be used for the production environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `profile-staging` will be automatically activated if the `ENV` environment
    variable key matches the value staging. We have not specified the build, test,
    and deploy steps for this specific profile, so it will continue to use the options
    we have provided in the main section of the `skaffold.yaml` file. In addition
    to this, `profile-production` will be automatically activated if the following
    criteria are satisfied. Note that it only runs the profile production stage if
    all of these criteria are activated:'
  prefs: []
  type: TYPE_NORMAL
- en: The `ENV` environment variable key matches the value production.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Kubernetes context is set to **GKE** (which is short for **Google Kubernetes
    Engine**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Skaffold command that is used is `scaffold run`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that `profile-production` will use Google's Cloud Build for the build and
    will default to `kubectl` for the deployment (as it's not explicitly specified).
  prefs: []
  type: TYPE_NORMAL
- en: This segregation also allows you to use various tools to build and deploy within
    different environments. For example, you might use Docker to create images in
    a local development and `Jib` for production. In the case of a deployment, you
    might use `kubectl` in development and Helm in production.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapter, I explained that Skaffold, by default, looks for the
    current Kubernetes context from the `kube config` file that is located in `${HOME}/.kube/config
    path`. If you wish to change it, you can do that while running the `skaffold dev`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also mention `kubeContext` in the `skaffold.yaml` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The flag passed via the CLI takes precedence over the `skaffold.yaml` file.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's discuss how Skaffold configures or adjusts itself to different local
    Kubernetes clusters.
  prefs: []
  type: TYPE_NORMAL
- en: A local Kubernetes cluster
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By now, you should have realized that Skaffold provides sensible, smart defaults
    to make the development process easier without you having to tell it to do things.
    If your Kubernetes context is set to a local Kubernetes cluster, then there is
    no need to push an image to a remote Kubernetes cluster. Instead, Skaffold will
    move the image to the local Docker daemon to speed up the development cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have only discussed the Kubernetes cluster that comes with Docker
    Desktop, but this is not the only option you have. There are various ways in which
    to set up and run a local Kubernetes cluster. For example, you have the following
    choices when creating a local Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker Desktop ([https://docs.docker.com/desktop/kubernetes/#enable-kubernetes](https://docs.docker.com/desktop/kubernetes/#enable-kubernetes))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minikube ([https://minikube.sigs.k8s.io/docs/](https://minikube.sigs.k8s.io/docs/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kind ([https://kind.sigs.k8s.io/](https://kind.sigs.k8s.io/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: k3d ([https://k3d.io/](https://k3d.io/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If any of these supported Kubernetes installations are available for local development,
    Skaffold expects that Kubernetes' context is as shown in the following table.
    Otherwise, it will assume that we are deploying to a remote Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Skaffold detects a local cluster based on the Kubernetes context name, as described
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 4.1 – The Kubernetes context supported by Skaffold'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Table_4.1_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.1 – The Kubernetes context supported by Skaffold
  prefs: []
  type: TYPE_NORMAL
- en: 'However, for other nonstandard local cluster setups, such as when running `minikube`
    with a custom profile (for instance, `minikube` `start -p my-profile`), you can
    use the following commands to tell Skaffold that you are using a local Kubernetes
    cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, set up the Docker environment for Skaffold using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, instruct Skaffold to consider `my-profile` as a local cluster using the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we took a deep dive into the features that Skaffold provides.
    Now, let's discuss Skaffold's architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Demystifying Skaffold's architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned in the previous section, Skaffold has been designed with pluggability
    in mind. The following is a visualization of the Skaffold architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – The Skaffold architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_4.4_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 – The Skaffold architecture
  prefs: []
  type: TYPE_NORMAL
- en: From this architecture diagram, you can conclude that Skaffold has a modular
    design. However, what is a modular design?
  prefs: []
  type: TYPE_NORMAL
- en: Well, a modular design, or modularity in design, is a design principle that
    subdivides a system into smaller parts called modules, which can be independently
    created, modified, replaced, or exchanged with other modules or between different
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this definition, we can define the following modules for Skaffold:'
  prefs: []
  type: TYPE_NORMAL
- en: Container image builders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container testing tools/strategy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container image taggers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container deployment tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s discuss each of these tools/modules in more detail. Currently,
    Skaffold supports the following container image builders:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dockerfile**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jib (Maven and Gradle)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bazel**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cloud-Native Buildpacks**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Custom Script**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For deployment to Kubernetes, Skaffold supports the following tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Helm**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kubectl**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kustomize**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss these options in greater detail in [*Chapter 6*](B17385_06_PreFinal_PD_ePub.xhtml#_idTextAnchor074),
    *Working with Skaffold Container Image Builders and Deployers*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Skaffold supports the following types of tests between the build and deployment
    phases of the pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: Custom tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container structure tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will explore these options further in [*Chapter 5*](B17385_05_Final_PD_ePub.xhtml#_idTextAnchor052),  *Installing
    Skaffold and Demystifying Its Pipeline Stages*.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, underneath the Skaffold **Features** section, Skaffold
    offers built-in image tag management. Currently, Skaffold supports multiple taggers
    and tag policies to tag images:'
  prefs: []
  type: TYPE_NORMAL
- en: The `gitCommit` tagger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `inputDigest` tagger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `envTemplate` tagger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `datetime` tagger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `customTemplate` tagger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `sha256` tagger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Knowing which image tag policy is supported is very easy with the IntelliJ
    Cloud Code plugin code completion feature. Let''s suppose you don''t specify the
    image tag policy in the `skaffold.yaml` file; in that case, the default policy
    is the `gitCommit` tagger:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Skaffold''s supported image tag policies'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_4.5_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.5 – Skaffold's supported image tag policies
  prefs: []
  type: TYPE_NORMAL
- en: Now, considering the pluggable architecture of Skaffold, you might use **Local
    Docker Daemon** for building images, `kubectl` for deployment to `minikube`, or
    any other supported local Kubernetes cluster. In this scenario, Skaffold will
    not push the image to a remote registry, and you can even skip the container structure
    tests by using the `-skipTests` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the tools used for local development in this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Skaffold in development'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_4.6_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.6 – Skaffold in development
  prefs: []
  type: TYPE_NORMAL
- en: While, in the case of the production scenario, you might use a Jib Maven or
    Gradle plugin to build the image, test the artifacts, push it to the remote registry,
    and, finally, deploy it to the remote Kubernetes cluster using Helm.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the tools used for the production scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Skaffold in production'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_4.7_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.7 – Skaffold in production
  prefs: []
  type: TYPE_NORMAL
- en: This completes our deep-dive analysis of the Skaffold architecture. Now, let's
    discuss the Skaffold workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Skaffold workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Typically, Skaffold works in two modes, namely, *continuous development* or
    an *end-to-end pipeline* through commands such as `skaffold dev` and `skaffold
    run`. For example, when you run the `skaffold dev` command, the following steps
    are carried out by Skaffold:'
  prefs: []
  type: TYPE_NORMAL
- en: Receive and watch your source code for changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the changed files straight to `build` if the user marks them as eligible
    for copying.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build your artifacts from the source code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test your built artifacts using `container-structure-tests` or custom scripts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tag your artifacts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push your artifacts (only if the Kubernetes context is set to a remote cluster).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the Kubernetes manifests with the correct tags.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy your artifacts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Monitor the deployed artifacts with built-in health checks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stream logs from the running pods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clean up any deployed artifacts on exit by pressing *Ctrl + C*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the case of the `skaffold run` command, the workflow is relatively similar.
    The only difference is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Skaffold will not continuously watch for code changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, Skaffold will not stream logs from the running pods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skaffold will exit after *step 9* in the end-to-end pipeline mode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram illustrates both the continuous development and end-to-end
    pipeline that we explained in the preceding steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – The Skaffold workflow'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_4.8_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.8 – The Skaffold workflow
  prefs: []
  type: TYPE_NORMAL
- en: You should now have an understanding of how Skaffold works in continuous development
    and end-to-end pipeline mode. Let's take a look at the components that are available
    in its configuration with the `skaffold.yaml` file.
  prefs: []
  type: TYPE_NORMAL
- en: Deciphering Skaffold's configuration with skaffold.yaml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any action that Skaffold needs to perform should be clearly defined in the `skaffold.yaml`
    configuration file. In this configuration file, you must specify which tool Skaffold
    has to use to build an image and then deploy it to the Kubernetes cluster. Skaffold
    typically expects to find the configuration file as `skaffold.yaml` in the current
    directory; however, we can override the location using the `--filename` flag.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: We recommend that you keep the Skaffold configuration file in the root directory
    of the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration file consists of the following main components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 4.2 –  The skaffold.yaml file components'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Table_4.2_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.2 –  The skaffold.yaml file components
  prefs: []
  type: TYPE_NORMAL
- en: 'Skaffold also supports a global configuration file, which is located in the
    `~/.skaffold/config` path. The following are the options it supports, which can
    be defined at the global level:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 4.3 – Skaffold global configuration options'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Table_4.3_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.3 – Skaffold global configuration options
  prefs: []
  type: TYPE_NORMAL
- en: 'You can list, set, and unset these options in the command line easily by using
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, you can set the local cluster option to false. This will allow
    you to push an image to a remote registry after building the image. Please refer
    to the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, you can unset the configuration using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we covered the components of the `skaffold.yaml` configuration
    file. We also looked at some of the global configuration settings that you can
    set via the Skaffold CLI commands.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced you to some of Skaffold's peculiarities, such as super-fast
    local development, effortless remote development, built-in tag management, lightweight
    capability, and file sync capability to name a few. These are compelling features
    that will help you to improve the developer experience. Additionally, we looked
    at the Skaffold architecture and discovered that Skaffold has a pluggable architecture.
    This means that you can always bring your own tools to build and deploy your applications.
    Following this, we covered the steps that typically occur within the Skaffold
    development workflow. Finally, at the end of the chapter, we studied the Skaffold
    main components and some global configurations supported via the Skaffold configuration.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, the main goal was to give you an insight into Skaffold's features
    and internals by looking at its architecture and typical development workflow.
    You have developed a deep understanding of Skaffold, and now it will be easier
    for you to connect the dots between the previous and upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will go through the different ways of installing Skaffold.
    Additionally, we will explore the Skaffold CLI commands.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The official Skaffold documentation ([https://skaffold.dev/docs/](https://skaffold.dev/docs/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
