- en: Aggregation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Chapter 5, *Multi-D**o**cument ACID Transactions*, we worked through two
    use cases of the new transactions capability using code for Ruby and Python. In
    this chapter, we will dive deeper into the aggregation framework, learning how
    it can be useful. We will also look at the operators that are supported by MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: To learn this information, we will use aggregations to process transaction data
    from the Ethereum blockchain. The complete source code is available at [https://github.com/PacktPublishing/Mastering-MongoDB-4.x-Second-Edition](https://github.com/PacktPublishing/Mastering-MongoDB-4.x-Second-Edition).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why aggregation?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different aggregation operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limitations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why aggregation?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The aggregation framework was introduced by MongoDB in version 2.2 (which is
    version 2.1 in the development branch). It serves as an alternative to both the
    MapReduce framework and querying the database directly.
  prefs: []
  type: TYPE_NORMAL
- en: Using the aggregation framework, we can perform `GROUP BY` operations in the
    server. Thus, we can project only the fields that are needed in the result set.
    Using the `$match` and `$project` operators, we can reduce the amount of data
    passed through the pipeline, resulting in faster data processing.
  prefs: []
  type: TYPE_NORMAL
- en: Self-joins—that is, joining data within the same collection—can also be performed
    using the aggregation framework, as we will see in our use case.
  prefs: []
  type: TYPE_NORMAL
- en: When comparing the aggregation framework to simply using the queries available
    via the shell or various other drivers, it is important to remember that there
    is a use case for both.
  prefs: []
  type: TYPE_NORMAL
- en: 'For selection and projection queries, it''s almost always better to use simple
    queries, as the complexity of developing, testing, and deploying an aggregation
    framework operation cannot easily outweigh the simplicity of using built-in commands.
    Finding documents with `( db.books.find({price: 50} {price: 1, name: 1}) )`, or
    without `( db.books.find({price: 50}) )` projecting only some of the fields, is
    simple and fast enough to not warrant the usage of the aggregation framework.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if we want to perform `GROUP BY` and self-join operations
    using MongoDB, there might be a case for using the aggregation framework. The
    most important limitation of the `group()` command in the MongoDB shell is that
    the resulting set has to fit in a document, meaning that it can't be more than
    16 MB in size. In addition, the result of any `group()` command can't have more
    than 20,000 results. Finally, `group()` doesn't work with sharded input collections,
    which means that when our data size grows we have to rewrite our queries anyway.
  prefs: []
  type: TYPE_NORMAL
- en: In comparison to MapReduce, the aggregation framework is more limited in functionality
    and flexibility. In the aggregation framework, we are limited by the available
    operators. On the plus side, the API for the aggregation framework is simpler
    to understand and use than MapReduce. In terms of performance, the aggregation
    framework was way faster than MapReduce in earlier versions of MongoDB, but seems
    to be on a par with the most recent versions after the improvement in performance
    by MapReduce.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, there is always the option of using the database as data storage and
    performing complex operations using the application. Sometimes this can be quick
    to develop, but should be avoided as it will most likely incur memory, networking,
    and ultimately performance costs down the road.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will describe the available operators before using them
    in a real use case.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to use aggregation operators. Aggregation
    operators are divided into two categories. Within each stage, we use **expression
    operators** to compare and process values. Between different stages, we use **aggregation
    stage operators** to define the data that will get passed on from one stage to
    the next, as it is considered to be in the same format.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation stage operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An aggregation pipeline is composed of different stages. These stages are declared
    in an array and executed sequentially, with the output of every stage being the
    input of the next one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `$out` stage has to be the final stage in an aggregation pipeline, outputting
    data to an output collection by replacing or adding to the existing documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$group`: This is most commonly used to group by identifier expression and
    to apply the accumulator expression. It outputs one document per distinct group.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$project`: This is used for document transformation, and outputs one document
    per input document.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$match`: This is used for filtering documents from input based on criteria.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$lookup`: This is used for filtering documents from input. Input can be documents
    from another collection in the same database selected by an outer left join.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$out`: This outputs the documents in this pipeline stage to an output collection
    by replacing or adding to the documents that already exist in the collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$limit`: This limits the number of documents passed on to the next aggregation
    phase based on predefined criteria.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$count`: This returns a count of the number of documents at this stage of
    the pipeline.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$skip`: This skips a certain number of documents, preventing them from passing
    on to the next stage of the pipeline.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$sort`: This sorts the documents based on criteria.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$redact`: As a combination of `$project` and `$match`, this will redact the
    selected fields from each document and pass them on to the next stage of the pipeline.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$unwind`: This transforms an array of *n* elements to *n* documents, mapping
    each document to one element of the array. The documents are then passed on to
    the next stage of the pipeline.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$collStats`: This returns statistics regarding the view or collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$indexStats`: This returns statistics regarding the indexes of the collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$sample`: This randomly selects a specified number of documents from the input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$facet`: This combines multiple aggregation pipelines within a single stage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$bucket`: This splits documents into buckets based on predefined selection
    criteria and bucket boundaries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$bucketAuto`: This splits documents into buckets based on predefined selection
    criteria and attempts to evenly distribute documents among the buckets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$sortByCount`: This groups incoming documents based on the value of an expression
    and computes the count of documents in each bucket.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$addFields`: This adds new fields to documents and outputs the same number
    of documents as input with the added fields.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$replaceRoot`: This replaces all existing fields of the input document (including
    the `standard _id` field) with the specified fields.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$geoNear`: This returns an ordered list of documents based on the proximity
    to a specified field. The output documents include a computed `distance` field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$graphLookup`: This recursively searches a collection and adds an array field
    with the results of the search in each output document.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expression operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within every stage, we can define one or more expression operators to apply
    our intermediate calculations to. This section will focus on these expression
    operators.
  prefs: []
  type: TYPE_NORMAL
- en: Expression Boolean operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Boolean operators are used to pass a `true` or `false` value to the next stage
    of our aggregation pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: We can choose to pass the originating `integer`, `string`, or any other type
    value along as well.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `$and`, `$or`, and `$not` operators in the same way that we would
    use them in any programming language.
  prefs: []
  type: TYPE_NORMAL
- en: Expression comparison operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Comparison operators can be used in conjunction with Boolean operators to construct
    the expressions that we need to evaluate as `true`/`false` for the output of our
    pipeline's stage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most commonly used operators are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$eq ( equal )`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$ne ( not equal)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$gt (greater than)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$gte (greater than or equal)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$lt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$lte`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the aforementioned mentioned operators return a Boolean value of `true`
    or `false`.
  prefs: []
  type: TYPE_NORMAL
- en: The only operator that doesn't return a Boolean value is `$cmp`, which returns
    `0` if the two arguments are equivalent, `1` if the first value is greater than
    the second and `-1` if the second value is greater than the first.
  prefs: []
  type: TYPE_NORMAL
- en: Set expression and array operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with most programming languages, set operations ignore duplicate entries
    and the order of elements, treating them as sets. The order of results is unspecified
    and duplicates will be deduplicated in the result set. Set expressions do not
    apply recursively to elements of the set, but only to the top level. This means
    that if a set contains, for example, a nested array, then this array may or may
    not contain duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The available set operators are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$setEquals`: This is `true` if the two sets have the same distinct elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$setIntersection`: This returns the intersection of all input sets (that is,
    the documents that appear in all of the input sets)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$setUnion`: This returns the union of all input sets (that is, the documents
    that appear in at least one of all of the input sets)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$setDifference`: This returns the documents that appear in the first input
    set but not the second'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$setIsSubset`: This is `true` if all documents in the first set appear in
    the second one, even if the two sets are identical'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$anyElementTrue`: This is `true` if any of the elements in the set evaluate
    to `true`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$allElementsTrue`: This is `true` if all of the elements in the set evaluate
    to `true`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The available array operators are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$arrayElemAt`: This returns the element at the array index position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$concatArrays`: This returns a concatenated array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$filter`: This returns a subset of the array based on specified criteria.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$indexOfArray`: This returns the index of the array that fulfills the search
    criteria. If it does not, then `-1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$isArray`: This returns `true` if the input is an array; otherwise, it returns `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$range`: This outputs an array containing a sequence of integers according
    to user-defined inputs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$reverseArray`: This returns an array with the elements in reverse order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$reduce`: This reduces the elements of an array to a single value according
    to the specified input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$size`: This returns the number of items in the array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$slice`: This returns a subset of the array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$zip`: This returns a merged array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$in`: This returns `true` if the specified value is in the array; otherwise,
    it returns `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expression date operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Date operators are used to extract date information from date fields when we want
    to calculate statistics based on the day of the week/month/year using the pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$dayOfYear` is used to get the day of the year within a range of 1 to 366
    (for a leap year)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$dayOfMonth` is used to get the day of the month within a range of 1 to 31'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$dayOfWeek` is used to get the day of the week within a range of 1 to 7, with
    1 being Sunday and 7 being Saturday (using English days of the week)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$isoDayOfWeek` returns the weekday number in the ISO 8601 date format within
    a range of 1 to 7, with 1 being Monday and 7 being Sunday'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$week` is the week number within a range of 0 to 53, with 0 being the partial
    week at the beginning of each year to 53 for a year with a leap week'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$isoWeek` returns the week number in the ISO 8601 date format within a range
    of 1 to 53, 1 being the first week of the year that contains a Thursday and 53
    being a leap week, if one exists in the year in question'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$year`, `$month`, `$hour`, `$minute`, `$milliSecond` return the relevant portion
    of the date in zero-based numbering, except for `$month`, which returns a value
    ranging from 1 through 12'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$isoWeekYear` returns the year in ISO 8601 date format according to the date
    that the last week in ISO 8601 date format ends (for example, 2016/1/1 will still
    return 2015)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$second` returns 0 to 60 inclusive for leap seconds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$dateToString` converts a date input to a string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expression string operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like date operators, string operators are used when we want to transform our
    data from one stage of the pipeline to the next one. Potential use cases include
    preprocessing text fields to extract relevant information to be used in later
    stages of a pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$concat`: This is used to concatenate strings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$split`: This is used to split strings based on delimiter. If the delimiter
    is not found, then the original string is returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$strcasecmp`: This is used in case-insensitive string comparisons. It will
    return `0` if the strings are equal and `1` if the first string is great; otherwise,
    it will return `-1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$toLower`/`$toUpper`: These are used to convert a string to all lowercase
    or all uppercase, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$indexOfBytes`: This is used to return the byte occurrence of the first occurrence
    of a substring in a string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$strLenBytes`: This is the number of bytes in the input string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$substrBytes`: This returns the specified bytes of the substring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The equivalent methods for code points (a value in Unicode, regardless of the
    underlying bytes in its representation) are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$indexOfCP`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$strLenCP`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$substrCP`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expression arithmetic operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'During each stage of the pipeline, we can apply one or more arithmetic operators
    to perform intermediate calculations. These operators are shown in the following
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$abs`: This is the absolute value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$add`: This can add numbers or a number to a date to get a new date.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$ceil`/`$floor`: These are the ceiling and floor functions, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$divide`: This is used to divide by two inputs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$exp`: This raises the natural number *e* to the specified exponential power.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$pow`: This raises a number to the specified exponential power.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$ln`/`$log`/`$log10`: These are used to calculate the natural log, the log
    on a custom base, or a log base ten, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$mod`: This is the modular value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$multiply`: This is used to multiply by inputs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$sqrt`: This is the square root of the input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$subtract`: This is the result of subtracting the second value from the first.
    If both arguments are dates, it returns the difference between them. If one argument
    is a date (this argument has to be the first argument) and the other is a number,
    it returns the resulting date.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$trunc`: This is used to truncate the result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregation accumulators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Accumulators are probably the most widely used operators, as they allow us
    to sum, average, get standard deviation statistics, and perform other operations
    in each member of our group. The following is a list of the aggregation accumulators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$sum`: This is the sum of the numerical values. It ignores non-numerical values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$avg`: This is the average of the numerical values. It ignores non-numerical
    values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$first`/`$last`: This is the first and last value that passes through the
    pipeline stage. It is available in the group stage only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$max`/`$min`: These get the maximum and minimum value that passes through
    the pipeline stage, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$push`: This will add a new element at the end of an input array. It is available
    in the group stage only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$addToSet`: This will add an element (only if it does not exist) to an array,
    effectively treating it as a set. It is available in the group stage only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$stdDevPop`/`$stdDevSamp`: These are used to get the population/sample standard
    deviation in the `$project` or `$match` stages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These accumulators are available in the group or project pipeline phases except
    where otherwise noted.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Expressions can be used to output different data to the next stage in our pipeline
    based on Boolean truth tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `$cond` phrase will evaluate an expression of the format `if...then...else`,
    and depending on the result of the `if` statement, it will return the value of
    the `then` statement or `else` branches. The input can be either three named parameters
    or three expressions in an ordered list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `$ifNull` phrase will evaluate an expression and return the first expression
    if it is not null or the second expression if the first expression is null. Null
    can be either a missing field or a field with an undefined value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Similar to a programming language's `switch` statement, `$switch` will execute
    a specified expression when it evaluates to `true`, and breaks out of the control
    flow.
  prefs: []
  type: TYPE_NORMAL
- en: Type conversion operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Introduced in MongoDB 4.0, type conversion operators allow us to convert a
    value to a specified type. The generic syntax of the command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this syntax, `input` and `to` (the only mandatory arguments) can be any
    valid expression. In its simplest form, we could, for example, have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This converts a string with the value `true` to the Boolean value `true`.
  prefs: []
  type: TYPE_NORMAL
- en: The `onError` phrase can again be any valid expression, and specifies the value
    that MongoDB will return if it encounters an error during conversion, including
    unsupported type conversions. Its default behavior is to throw an error and stop
    processing.
  prefs: []
  type: TYPE_NORMAL
- en: The `onNull` phrase can also be any valid expression, and specifies the value
    that MongoDB will return if the input is null or missing. The default behavior
    is to return null.
  prefs: []
  type: TYPE_NORMAL
- en: 'MongoDB also provides some helper functions for the most common `$convert`
    operations. These functions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$toBool`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$toDate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$toDecimal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$toDouble`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$toInt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$toLong`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$toObjectId`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$toString`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are even simpler to use. We could rewrite the previous example as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Other operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some operators that are not as commonly used, but which can be useful
    in use-case-specific cases. The most important of them are listed in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Text search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `$meta` operator is used to access text search metadata.
  prefs: []
  type: TYPE_NORMAL
- en: Variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `$map` operator applies a sub-expression to each of the elements of an array
    and returns the array of the resulting values. It accepts named parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The `$let` operator defines variables for use within the scope of a subexpression
    and returns the result of the subexpression. It accepts named parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Literal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `$literal` operator will return a value without parsing. It is used for
    values that the aggregation pipeline may interpret as an expression. For example,
    you can apply a `$literal` expression to a string that starts with `$` to avoid
    parsing as a field path.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing data type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `$type `operator returns the `BSON` data type of the field.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The aggregation pipeline can output results in the following three distinct
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Inline as a document containing the result set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning a cursor to the result set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inline results are subject to `BSON` maximum document size of 16 MB, meaning
    that we should use this only if our final result is of a fixed size. An example
    of this would be outputting `ObjectId` of the top five most ordered items from
    an e-commerce site.
  prefs: []
  type: TYPE_NORMAL
- en: A contrary example to this would be outputting the top 1,000 most ordered items,
    along with the product information, including the description and other fields
    of variable size.
  prefs: []
  type: TYPE_NORMAL
- en: Outputting results into a collection is the preferred solution if we want to
    perform further processing of the data. We can either output into a new collection
    or replace the contents of an existing collection. The aggregation output results
    will only be visible once the aggregation command succeeds; otherwise, it will
    not be visible at all.
  prefs: []
  type: TYPE_NORMAL
- en: The output collection cannot be a sharded or capped collection (as of v3.4).
    If the aggregation output violates indexes (including the built-in index on the
    unique `ObjectId` per document) or document validation rules, the aggregation
    will fail.
  prefs: []
  type: TYPE_NORMAL
- en: Each pipeline stage can have documents exceeding the 16 MB limit as these are
    handled by MongoDB internally. Each pipeline stage, however, can only use up to
    100 MB of memory. If we expect more data in our stages, we should set `allowDiskUse:`
    to `true` to allow excess data to overflow to disk at the expense of performance.
  prefs: []
  type: TYPE_NORMAL
- en: The `$graphLookup` operator does not support datasets over 100 MB and will ignore
    any setting on `allowDiskUse`.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation use case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this rather lengthy section, we will use the aggregation framework to process
    data from the Ethereum blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using our Python code, we have extracted data from Ethereum and loaded it into
    our MongoDB database. The relation of the blockchain to our database is shown
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ad5e8b5-bd05-430e-9e4f-06548aa820a9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Our data resides in two collections: **blocks** and **transactions**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample block document has the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: Number of transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number of contracted internal transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Block hash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parent block hash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mining difficulty
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gas used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Block height
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows the output data from a block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'A sample transaction document has the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: Transaction hash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The block height it belongs to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From hash address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To hash address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transaction value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transaction fee
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows the output data from a transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Sample data for our database is available on GitHub at: [https://github.com/PacktPublishing/Mastering-MongoDB-4.x-Second-Edition](https://github.com/PacktPublishing/Mastering-MongoDB-4.x-Second-Edition).'
  prefs: []
  type: TYPE_NORMAL
- en: 'As curious developers who are using this novel blockchain technology, we want
    to analyze Ethereum transactions. We are especially keen to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the top ten addresses that transactions originate from
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find the top ten addresses that transactions end in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find the average value per transaction, with statistics concerning the deviation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find the average fee required per transaction, with statistics concerning the
    deviation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find the time of day that the network is more active according to the number
    or value of transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find the day of week that the network is more active according to the number
    or value of transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We find the top ten addresses that transactions originate from. To calculate
    this metric, we first count the number of occurrences with a `1` count for each
    one, group them by the value of the `from` field, and output them into a new field
    called `count`.
  prefs: []
  type: TYPE_NORMAL
- en: After this, we sort by the value of the `count` field in descending (`-1`) order,
    and finally, we `limit` the output to the first ten documents that pass through
    the pipeline. These documents are the top ten addresses that we are looking for.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is some sample Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we find the top ten addresses that transactions end in. As we did with
    `from`, the calculation for the `to` addresses is exactly the same, only grouping
    using the `to` field instead of `from`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s find the average value per transaction, with statistics concerning the
    standard deviation. In this example, we are using the `$avg` and `$stdDevPop`
    operators of the values of the `value` field to calculate the statistics for this
    field. Using a simple `$group` operation, we output a single document with the
    ID of our choice (here, `value`) and the `averageValues`, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s find the average fee required per transaction, returning statistics
    concerning the deviation. Average fees are similar to average values, replacing
    `$value` with `$txfee`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We find the time of day that the network is more active according to the number
    or value of transactions at specific times.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find out the most active hour for transactions, we use the `$hour` operator
    to extract the `hour` field from the `ISODate()` field in which we stored our
    `datetime` values and called `timestamp`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code will calculate the sum of transaction values for the most
    active hour of the day:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s find the day of the week that the network is more active according to
    the number of transactions or value of transactions. As we did with the hour of
    the day, we use the `$dayOfWeek` operator to extract the day of the week from
    `ISODate()` objects, as shown in the following code. Days are numbered ranging
    from one for Sunday to seven for Saturday, following the US convention:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code will calculate the sum of transaction values for the most
    active day of the week:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The aggregations that we calculated can be described in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8fe830a-aef7-4dc6-b15a-60247711d69e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In terms of blocks, we would like to know the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Average number of transactions per block, for both the total overall transactions
    and the total contracted internal transactions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Average gas used per block.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Average gas used per transaction to a block. Is there a window of opportunity
    to submit my smart contract in a block?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Average difficulty per block and how it deviates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Average number of transactions per block, both in total and also in contracted
    internal transactions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Averaging over the `number_transactions` field, we can get the number of transactions
    per block, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Whereas with the following code, we can get the average number of internal
    transactions per block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The average gas used per block can be acquired as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The average difficulty per block and how it deviates can be acquired as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Our aggregations are described in the following schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b5a0878-4238-4012-bca0-c395a951a7f9.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have the basic statistics calculated, we want to up our game and
    find out more information about our transactions. Through our sophisticated machine
    learning algorithms, we have identified some of the transactions as either scams
    or **initial coin offering** (**ICO**), or maybe both.
  prefs: []
  type: TYPE_NORMAL
- en: 'In these documents, we have marked these attributes in an array called `tags`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now we want to get the transactions from June, 2017, remove the `_id` field,
    and produce different documents according to the tags that we have identified.
    So in our example, we would output two documents in our new collection, `scam_ico_documents`,
    for separate processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way to do this via the aggregation framework is shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have the following four distinct steps in our aggregation framework
    pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `$match`, we only extract documents that have a `timestamp`  field value
    of June 01, 2017.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using `$project`, we add a new  `report_period` field with a value of `June
    2017` and remove the `_id` field by setting its value to `0`. We keep the rest
    of the fields intact by using the value `1`, as shown in the preceding code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using `$unwind`, we output one new document per tag in our `$tags` array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, using `$out`, we output all of our documents to a new `scam_ico_documents`
    collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since we used the `$out` operator, we will get no results in the command line.
    If we comment out `{"$out": "scam_ico_documents"}`, we get documents that look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The final result in our database will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have documents that are clearly separated in the `scam_ico_documents`
    collection, we can perform further analysis pretty easily. An example of this
    analysis would be to append more information on some of these scammers. Luckily,
    our data scientists have come up with some additional information that we have
    extracted into a new collection `scam_details`, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now create a new aggregation pipeline job to join our `scam_ico_documents`
    with the `scam_details` collection and output these extended results in a new
    collection, called `scam_ico_documents_extended`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are using the following three-step aggregation pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `$lookup` command to join data from the `scam_details` collection and
    the `scam_address` field with data from our local collection (`scam_ico_documents`)
    based on the value from the local collection attribute `from` being equal to the
    value in the `scam_details` collection's `scam_address` field. If these are equal,
    then the pipeline adds a new field to the document called `scam_details`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we only match the documents that have a `scam_details` field—the ones
    that matched with the lookup aggregation framework step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we output these documents in a new collection called `scam_ico_documents_extended`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These documents will now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Using the aggregation framework, we have identified our data and can process
    it rapidly and efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous steps can be summed up in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ce20f81-e8bb-4501-94a4-2a855c17c203.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we dived deep into the aggregation framework. We discussed
    why and when we should use aggregation as opposed to simply using MapReduce or
    querying the database. We went through the vast array of options and functionalities
    for aggregation.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed the aggregation stages and the various operators, such as Boolean
    operators, comparison operators, set operators, array operators, date operators,
    string operators, expression arithmetic operators, aggregation accumulators, conditional
    expressions, and variables, and the literal parsing data type operators.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Ethereum use case, we went through aggregation with working code and
    learned how to approach an engineering problem to solve it.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned about the limitation that the aggregation framework currently
    has and when to avoid it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will move on to the topic of indexing and learn how
    to design and implement performant indexes for our read and write workloads.
  prefs: []
  type: TYPE_NORMAL
