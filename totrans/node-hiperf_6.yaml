- en: Chapter 6. Test, Benchmark, and Analyze
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing your application is as important as its development. Testing is the
    process of analyzing your application modules and the application as a whole to
    see whether it behaves as you expect it. It allows your business to define use
    cases and check whether they're all accomplished.
  prefs: []
  type: TYPE_NORMAL
- en: There are many testing techniques. One of the most famous is **Test-driven Development**
    (**TDD**). This technique consists of using the smallest development cycles possible.
    Between every cycle, tests are performed and new tests and uses cases are added
    before they're developed. This way, your application versions can be continuously
    tested and any faulty version can be quickly spotted. If you use a version control
    system, such as Git, it becomes very easy to find the culprit of the failing test
    and fix it.
  prefs: []
  type: TYPE_NORMAL
- en: An important aspect of performing tests from the ground up is that you can keep
    adding use cases and test cases as you spot them. For example, if someone reports
    a bug and you create a specific use case for it, you can ensure that that bug
    doesn't appear again or that it will not be visible in the tests. In community-driven
    projects, it's very common to see this use case (a member spotting a bug and adding
    a test case for it). If you can replicate it, you can create a test case.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on your test platform, you can benchmark your application. Usually,
    test platforms have a default timeout per test as long as 1 or 2 seconds. You
    can reduce this value for features that you want to ensure perform well. You can
    also do the opposite by giving more time for longer use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Platforms with this timeout feature allow you to have consistent tests. Remember
    to test in a common platform, such as a general working environment. Don't define
    test benchmarks for a superfast server and then expect them to pass in a computer
    that is 20 years old.
  prefs: []
  type: TYPE_NORMAL
- en: Test fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tests can be defined in a variety of ways. The most common approach is unit
    testing. This is a method by which parts of your application are individually
    checked to confirm that they comply with the specifications. This approach encourages
    your application parts to act as independent and replaceable black boxes.
  prefs: []
  type: TYPE_NORMAL
- en: You need real data to properly test your application. You also need unrealistic
    data. Both are crucial to confirm that it behaves as expected with both correct
    data and scrambled data. This ensures that a misguided or malicious user won't
    break your application.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering what I mean by unrealistic data. Does your application
    handle text in date fields or numbers in checkboxes? What about missing data?
    You might think it does, but if you have more developers working on it, you may
    want to ensure that, somewhere in the future, it doesn't stop behaving correctly.
    The most common type of bug occurs in one place after making a change in a completely
    different place.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of unit testing should be to completely isolate each of your application's
    modules and to be able to test them independently. If a module needs other parts
    of the application to work properly, you can fake that data or mock that dependency,
    using Sinon ([http://sinonjs.org/](http://sinonjs.org/)) for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the benefits of testing are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Bugs are found early in the development cycle. Since you can test your code
    every time you change it, bugs should be spotted earlier. The cost of fixing bugs
    earlier, sometimes even before going into production, greatly reduces overall
    costs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It forces developers to think about I/O data and errors, since application architects
    must think and properly describe every use case. Features and use cases are developed
    with one or more test cases in mind.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It enables changing or refactoring modules while still ensuring that the expected
    behavior is kept intact because of the test cases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It facilitates module integration tests, since each of the modules are tested
    and have an expected behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these benefits are achieved only if the tests are properly defined and
    your test covers the entire application (all functions and objects). With proper
    test coverage, you can also add specific use cases for new features or edge cases.
  prefs: []
  type: TYPE_NORMAL
- en: Separating tests for each module is quite difficult. For example, if one of
    your modules needs a database to work, your test case will require giving it database
    access. This is not good, since your unit test will actually be an integration
    test, and if it fails you won't be able to say whether the problem is with the
    module or with the database.
  prefs: []
  type: TYPE_NORMAL
- en: The test environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is also important to have a consistent test environment. More importantly,
    the environment should be the same or almost the same, as the production environment.
    This means the same application (of course), but also the same operating system
    version, the same database server version, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: For example, for Node.js tests, ensure that your test environment has the same
    Node.js version. You can test with different versions, but the most important
    is the version used in production. The same applies to the operative system version,
    the database service version, dependencies' versions, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having the same environment might not be easy, but there's a solution for that—Linux
    containers. If you haven't tried Docker yet, you're missing the train. This solution
    is free and is a tool involving containers that makes them usable.
  prefs: []
  type: TYPE_NORMAL
- en: Its main difference compared to tools such as Vagrant is that it doesn't need
    a virtual machine to create an environment. Docker is similar to OpenVZ ([https://openvz.org/Main_Page](https://openvz.org/Main_Page)),
    but with a twist; you can create an environment (a container) and share it for
    others to use. If you like NPM, you will find this similar. You have versioning
    and dependencies, and the most used environments are already online for you to
    download and use.
  prefs: []
  type: TYPE_NORMAL
- en: You can create a test environment in a container and then distribute the container
    to other developers. This also applies to production. Your developers can get
    a snapshot of a production database and a complete production environment in their
    laptop. In this way, changes can be made and tested as if they were applied to
    production. This is better than trying in production and having to roll back.
    In this way, you'll roll back less often. This is the principle of continuous
    integration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a very simple environment for our Node.js application. Have Docker
    installed, open a terminal, and run this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that we want a specific version, and that''s why we''re forcing `0.12.4`
    in this case. I''m considering the operative system as unimportant, since our
    application won''t have external dependencies or node modules. This command will
    just download the image template, and it''s not creating any environment yet;
    we''ll do that in a moment. You''ll notice that it takes a few hundred megabytes.
    Don''t worry; that is possibly the only space you need, as your environments will
    almost always depend on this image. If you want to check out the downloaded image,
    run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Well, there's a lot of space there, isn't there? If you look closely, you'll
    notice that there's only one image (the `IMAGE ID` is the same). What has happened
    is that `0.12.4` is actually the latest version by the time of writing this book,
    and the latest tag has also been assigned to our image. Furthermore, that version
    is the last version of `0.12`, and it's the last version of 0.
  prefs: []
  type: TYPE_NORMAL
- en: This means that we can use any of these tags to refer to our image, but we don't
    want that, as new versions might come up and our images would start being built
    with those new versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see which containers are running, or were created before, and are not
    running anymore. We can see simply what is running, but I find it much more useful
    to see dead containers, as they potentially use unnecessary space. There are no
    containers now. We can simply test the image to see whether it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We just ran a basic environment using our image, running `bash` in a `tty`
    (`-t`), in interactive mode (`-i`) as opposed to running in the background (`-d`).
    You can see that we have node and `npm` in the environment. If we look at which
    containers exist, we will see something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Our container has unique identifier, `1a56bbeb3d36`, is using the `0` node
    image, and is running the `bash` command. Well, it is actually no longer running.
    You can remove it by running this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Noticed the `Exited (0) ..` lines in the `ps` command? Yes, exit code from the
    command is accessible. If you exited `bash` with `exit` `123`, you will see it
    outside the container. This is great for launching a test command instead of `bash`
    and then just checking whether all the tests have passed based on the exit code.
    You can also record the output and, in the event of a failure, save it for analysis.
  prefs: []
  type: TYPE_NORMAL
- en: The test tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have a form of replicating the environment to test, we need a proper
    test tool—something you can use to define your use cases and test cases. There
    are many great tools and Node.js has specific tools for testing. Some of them
    are really great.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have nothing in mind, I would recommend trying mocha ([http://mochajs.org/](http://mochajs.org/)).
    It''s available for installation on NPM, and you should install it globally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this way, you can use mocha in all your applications on your computer without
    having to install it over and over again, because it's actually a development/test
    dependency, not a real application dependency. Installing it globally will also
    install the `mocha` command in your path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a very simple module called `module`.js with a function that
    simply adds two numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a test case. For this, we''ll create another file called
    `test.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this file loads our module (`m`) and asserts that `m.add` should
    add two numbers. To check it, we add a test case by checking whether the module
    returns `5` when we pass `2` and `3` to it. Now, open a terminal in the folder
    where you have these two files and just run `mocha` without any arguments, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The test tool](img/4183_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Nice, isn't it? There are other forms of output called **reporters**, such as
    the progress, list, or dot matrix. If you just want a simple output, try list
    or progress. If you want the details of every test, use the spec reporter. It's
    shown in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add another test to our function. Change the test file to look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run `mocha` again, your test case will cause the `test` suite to fail,
    as shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The test tool](img/4183_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s change our module to behave correctly, as we stated in our new test.
    You can change it however you want; I''ll just show an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon running again, our test should pass, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The test tool](img/4183_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can now test this in our environment instead of testing it directly. This
    ensures that our application works in a clean environment and is not passing because
    of something your local environment has. To do this, we can use our previous node
    image. Let''s create a simple test environment. To do this, we need to create
    a file called `Dockerfile` in our test folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This describes our environment. What the file is describing is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Use node image version `0.12.4`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install the `mocha` dependency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a linkable volume on `/opt/app`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s build our environment and call it `env/test`. We''re actually creating
    a new image based on another image. Our linkable volume is a folder that we can
    specify when running our environment. In this way, you can use this very image
    for all your applications. To build our environment, we run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We now have an image that we can use. Let's try the image by running our tests
    with `mocha`.
  prefs: []
  type: TYPE_NORMAL
- en: '![The test tool](img/4183_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Check out the online documentation of Docker for details on the command line.
    We're running our image where the `/opt/app` (`-v`) volume is our current folder
    (with our Node.js files). Our test environment is run in interactive mode (`-it`),
    and the result image is discarded at the end (`--rm`).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have a central code repository, it is good practice to test before committing
    to avoid common mistakes. It also avoids breaking changes. It''s common to make
    a change to fix or improve something and break something else. With an always-clean
    test environment, developers can ensure that the tests run correctly. This environment
    can be similar to the one in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The test tool](img/4183_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Continuous integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Continuous integration** (**CI**) is a practice wherein all the developers
    of an application continuously integrate their changes into a central repository.
    This is a practice used in **extreme programming** (**XP**). It introduces new
    features faster and helps avoid code conflicts by reducing code merge time.'
  prefs: []
  type: TYPE_NORMAL
- en: If the application has a good test suite, developers can test changes locally
    in a replicated production and test environments and just commit if they pass.
    These tests should not replace the tests done on the server. If the test suite
    executes fast, it could even be a guarantee for the commit to be merged, but this
    is usually not recommended, as some commits actually cannot pass. Usually, all
    the commits are accepted and only then are they tested. The test results should
    be public at least inside the developer's circle as a way of forcing them to take
    care of their commits, how they structure their code, and how they describe commits.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four best practices for CI:'
  prefs: []
  type: TYPE_NORMAL
- en: Have a code repository and use a revision control system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every commit should be checked to guarantee that it passes all the tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separate the test environment from production environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automate deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One way of achieving this workflow is by using **git**. Since it allows you
    to define hooks for commits and merges, you can add a hook to the central repository
    to test every new commit. If the commit passes, it could be eligible to pass to
    production.
  prefs: []
  type: TYPE_NORMAL
- en: 'One strategy can be to merge the latest commit that passed all the tests with
    production. This could be every time a commit passes or at specific times. For
    simple applications, this approach is acceptable. But if you have a big user base,
    it can really be risky. Ensure that your test base is really good, and at least
    look and read the commit change log. There are risks that you should know of,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Your test base might not cover all of your code. This means that there are parts
    of your code that are not tested, which raises uncertainty about its behavior.
    In this case, you should try to cover as much of your code as possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your test base might not cover all of your use cases. If all of your use cases
    are not described in the tests, they will not be tested in your code. They could
    get handled correctly, but it's still uncertain. So, you should describe all of
    your use cases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are test cases which aren't easy to describe or even reproduce. You should
    make an effort to avoid these kinds of tests and ensure that you can completely
    rely on tests. Otherwise, you'll need someone to test the application changes
    before they go to production.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, it is important to be able to test the application against your production
    database, perhaps the latest backup or a database with replication that you can
    use without compromising the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: Data size always influences your application's performance. If you're just testing
    your modules to check simple use cases, you're not testing the load, but you should.
    Sometimes, your production data can have relationships that you didn't except
    at first. You may think your code doesn't allow those relationships to appear,
    but you may be wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Consider, for example, a hierarchical structure in which you define a parent
    for a certain element. Assume that this descendant can also be a parent of another
    element. What if a third-degree descendant is a parent of an ascendant? This creates
    a loop that you probably don't want but you have to handle. Even if your application
    doesn't allow this loop to appear at first, consider getting the code required
    to protect yourself against it.
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having all of your code covered by tests is important to ensure that you're
    really testing everything, or at least everything that is coded. This is not an
    easy task. Conditions and loops in your code create a log of different cases and
    running paths, and some of your code might be triggered only in very specific
    situations. That situation needs to be tested somehow.
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage is a metric used to indicate how much of your code is covered
    by your test suite. A higher metric indicates that your application is more "test
    covered" and can usually be an indication of low bug probability. This metric
    is usually given in percentage values, and 50 percent coverage means that half
    of your code covered by the test suite.
  prefs: []
  type: TYPE_NORMAL
- en: There are tools that can help you find this value, otherwise it would be impossible
    to calculate it. In a Node.js environment, what the tools usually do is creating
    a replica of your code, in which they change every significant line to get a way
    of counting the number of times the execution passed through that line. Significant
    lines are lines with real code, not comments or empty lines.
  prefs: []
  type: TYPE_NORMAL
- en: There are also online services for doing this. Depending on your application
    license or budget, you might prefer to prepare your test environment locally.
    This is usually not as simple as it might look. You have to create a way of instrumenting
    your code (this is best done on a copy) and running your tests while gathering
    the coverage metrics, and then generate a report.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several tools for Node.js that you can try. There''s no magic tool,
    and you should see what fits you and your application best. One possible tool
    is `istanbul`. Let''s try it out on our small test example. You''ll see that it''s
    a little tricky, and for a real application, you must automate this process. Let''s
    start by installing the dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mocha-istanbul` dependency can be installed locally. The `istanbul` Node.js
    module should be global because it has a command for us to use. Now we can instrument
    our code. Let''s create an instrumented copy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have to change our test suite to use our instrumented version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we just need to run our test suite using the `istanbul` reporter.
    To do this, run `mocha` with the `reporter` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of showing a description of the tests, you''ll see a report showing
    how many lines and functions are instrumented in your code and covered by the
    test suite. Here''s an example of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code coverage](img/4183_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After this, you should have a folder called `html-report` with an `index.html`
    page inside. Open it in your browser to analyze your test coverage. You should
    see a page similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code coverage](img/4183_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You'll see the `test` folder, and inside, you'll find our original module. Click
    on it and you'll see a coverage report. For each significant line (notice that
    the lines with closing brackets are ignored), you'll have a number associated.
    It corresponds to the number of times the execution passed that line while we
    we're testing. In our case, it's the **1** and **2** columns with a green background.
    It's easy to understand why, seeing that we have only two tests.
  prefs: []
  type: TYPE_NORMAL
- en: '![Code coverage](img/4183_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Benchmark tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Benchmarking is the process of running a set of tools or tests to measure specific
    performance metrics in order to compare them, either with other tools or with
    past tests. The most common benchmark tests for applications are related to two
    similar metrics: time (of an operation) and operations (over a period of time).'
  prefs: []
  type: TYPE_NORMAL
- en: To maintain your application's performance, you need to continuously benchmark
    it. One obvious approach is to use the test suite, where you add specific tests
    just for benchmarking purposes. After checking out the common use cases, you can
    have specific tests where you can ensure that certain operations continue to run
    for a specific target time.
  prefs: []
  type: TYPE_NORMAL
- en: Take benchmarking seriously, but don't lose sleep over it! Most of the time,
    when you start your application development, you just don't have the statistics
    to compare with and you don't know what benchmark tests to define.
  prefs: []
  type: TYPE_NORMAL
- en: Start by benchmarking simple listings, such as history lists, and ensure that
    they don't perform over the 100-millisecond mark. When creating a more complex
    interface, ensure that its rendering also performs well. People tend to stress
    out if they have to wait for more than half a second for a simple task, and more
    than one or two seconds for a more complex one.
  prefs: []
  type: TYPE_NORMAL
- en: These benchmarks are usually done using a copy of the production data, or a
    subset of it if it's too large, in order to ensure that you're benchmarking against
    a good amount of data and not a small set of data on a test environment like your
    personal laptop. You can also perform the test against the production data, but
    I won't recommend it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, using our previous test framework, `mocha` ensures that each test
    runs for less than two seconds. You can change this default timeout for specific
    tests. Let''s try it out with a new test file called `timeout.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re creating an asynchronous test. This is because we referenced `done`
    in our test function to be called when the test ends. In this case, we''re not
    calling it specifically to force it to fail. Let''s try it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Benchmark tests](img/4183_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It is good practice to use timeouts in specific tests where performance is important.
    The normal timeout may be fine for most common tests, but make sure that you analyze
    some specific tests and ensure that they perform within a certain period of time.
  prefs: []
  type: TYPE_NORMAL
- en: That timeout can be a performance limit or just a mark to inform you when your
    application is becoming too complex or when your test data is becoming too big
    to be able to keep up that performance. That's when, based on the previous chapter,
    you need to take a look at your environment and analyze your next steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Test suites such as mocha can also give you other interesting information that
    complements your tests and helps you get a better picture of the behavior of your
    application, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Report test durations, even for the tests that are not benchmark tests, this
    will allow you to first make your tests and look at the metrics, and then define
    a good timeout mark.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Present test reports. They can be used for quality assurance reports and can
    be saved for later analysis or comparison.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Specifically for Node.js applications, `mocha` can provide you with:'
  prefs: []
  type: TYPE_NORMAL
- en: Memory leak detection, by looking at global variables before and after the tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uncaught exception detection, indicating the test that caused it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seamless asynchronous support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js debugger support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Browser support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having a test suite is very important. The most important benefit is having
    your application fully tested, or at least as much tested as possible. Creating
    the initial test environment may be a challenge, but it pays off as you keep developing
    your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Performing proper tests ensures that you:'
  prefs: []
  type: TYPE_NORMAL
- en: Don't reintroduce old bugs with new features. This can happen even without touching
    the source code and just by making a database change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can define use cases by defining test cases first (look at [https://en.wikipedia.org/wiki/Test-driven_development](https://en.wikipedia.org/wiki/Test-driven_development)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can make changes and easily check whether the application keeps behaving as
    expected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can check your test coverage and see how it has changed over time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can create specific tests for newly found bugs and ensure that they don't reappear.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that benchmark tests run under a specific metric.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting a proper test suite is similar to having a quality assurance person
    test your application every time you make a change. Moreover, your quality assurance
    person won't be as precise or as fast as your test suite.
  prefs: []
  type: TYPE_NORMAL
- en: If your application has more developers than just you, make sure that you enforce
    tests passing successfull and a test coverage of a high mark like 90 percent.
    If you automate your coverage tests, you can use the coverage metric as a condition
    to merge new features with production.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that your tests are public in the development group circle, allowing
    everyone to see the work of others. This motivates people to work better, as their
    reputation is public, at least inside the group.
  prefs: []
  type: TYPE_NORMAL
- en: When there are more people looking at tests, developers can share experiences
    and ask for help upon bumping into failing tests. This reduces the time taken
    to fix a problem and motivates developers to keep the test suite always going.
    It should be a constant goal—to keep the test history clean of failures.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A good, performant application is all about how well it performs. A complete
    test suite ensures that you also perform well in developing and can introduce
    changes fast—changes that can improve performance. The test suite should have
    specific tests for benchmark analysis, with demanding time restrictions. The developers
    should know about them and work hard to keep the tests passing without having
    to lift those restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: Use the test suite as a metric for production. Ensure that you merge new changes
    if your test suite covers your application source in at least 90 percent coverage
    and passes all the benchmark tests. Use a separate server for those tests, and
    don't mix tests with production. Keep your production server lean and fast, and
    change it only if you're sure it will keep that way.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at bottlenecks—limits that degrade performance—and
    the situations in which you can't do anything about them. You must try hard to
    be ready for them and, if possible, try to attenuate their consequences. The network,
    the server, and the client are some of the factors that introduce bottlenecks.
    Some you can control and minimize, but others… you just have to be ready for them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prepared for Bentham Chang, Safari ID bentham@gmail.com User number: 2843974
    © 2015 Safari Books Online, LLC. This download file is made available for personal
    use only and is subject to the Terms of Service. Any other use requires prior
    written consent from the copyright owner. Unauthorized use, reproduction and/or
    distribution are strictly prohibited and violate applicable laws. All rights reserved.'
  prefs: []
  type: TYPE_NORMAL
