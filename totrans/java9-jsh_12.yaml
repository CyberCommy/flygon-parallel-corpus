- en: Chapter 12. Object-Oriented, Functional Programming, and Lambda Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss functional programming and how Java 9 implements
    many functional programming concepts. We will work with many examples on how to
    mix functional programming with object-oriented programming. We will:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand functions and methods as first-class citizens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work with functional interfaces and lambda expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a functional version of array filtering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a data repository with generics and interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filter collections with complex conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a map operation to transform values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combine a map operation with reduce
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chain many operations with map and reduce
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work with different collectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding functions and methods as first-class citizens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since its first release, Java has been an object-oriented programming language.
    Starting with Java 8, Java added support for the **functional programming** paradigm
    and continues to do so in Java 9\. Functional programming favors immutable data,
    and therefore, functional programming avoids state changes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code written with a functional programming style is as declarative as possible,
    and it is focused on what it does instead of how it must do it.
  prefs: []
  type: TYPE_NORMAL
- en: In most programming languages that provide support to the functional programming
    paradigm, functions are first-class citizens, that is, we can use functions as
    arguments for other functions or methods. Java 8 introduced many changes to reduce
    boilerplate code and make it easy for methods to become first-class citizens in
    Java and make it easy to write code that uses a functional programming approach.
    We can easily understand this concept with a simple example such as filtering
    a list. However, take into account that we will start by writing **imperative
    code** with methods as first-class citizens, and then, we will create a new version
    for this code that uses a complete functional approach in Java 9 through a filter
    operation. We will create many versions of this example because it will allow
    us to understand how functional programming is possible in Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will write some code considering that we still don't know about the
    features included in Java 9 to transform methods into first-class citizens. Then,
    we will use these features in many examples.
  prefs: []
  type: TYPE_NORMAL
- en: The following lines declare the `Testable` interface that specifies a method
    requirement that receives a `number` argument of the `int` type and returns a
    `boolean` result. The code file for the sample is included in the `java_9_oop_chapter_12_01`
    folder, in the `example12_01.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The following lines declare the `TestDivisibleBy5` concrete class that implements
    the previously declared `Testable` interface. The class implements the `test`
    method with code that returns a `boolean` value indicating whether the received
    number is divisible by `5` or not. If the result of the modulus, modulo, or remainder
    operator (`%`) between the number and `5` is equal to `0`, it means that the number
    is divisible by `5`. The code file for the sample is included in the `java_9_oop_chapter_12_01`
    folder, in the `example12_01.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The following lines declare the `TestGreaterThan10` concrete class that implements
    the previously declared `Testable` interface. The class implements the `test`
    method with code that returns a `boolean` value indicating whether the received
    number is greater than `10` or not. The code file for the sample is included in
    the `java_9_oop_chapter_12_01` folder, in the `example12_01.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The following lines declare the `filterNumbersWithTestable` method that receives
    a `List<Integer>` in the `numbers` argument and a `Testable` instance in the `tester`
    argument. The method uses an external `for` loop, that is, imperative code to
    call the `tester.test` method for each `Integer` element in the numbers `List<Integer>`.
    If the `test` method returns `true`, the code adds the `Integer` element to the
    `filteredNumbersList<Integer>`, specifically, an `ArrayList<Integer>`. Finally,
    the method returns the `filteredNumbersList<Integer>` as a result with all the
    `Integer` objects that satisfied the test. The code file for the sample is included
    in the `java_9_oop_chapter_12_01` folder, in the `example12_01.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `filterNumbersWithTestable` method works with two `List<Integer>` objects,
    that is, two `List` of `Integer` objects. We are talking about `Integer` and not
    the `int` primitive type. `Integer` is a wrapper class for the `int` primitive
    type. However, the `test` method we declared in the `Testable` interface and then
    implemented in the two classes that implement this interface receive an argument
    of the `int` type, and not `Integer`.
  prefs: []
  type: TYPE_NORMAL
- en: Java automatically converts a primitive value into an object of the corresponding
    wrapper class. Whenever we pass an object as a parameter to a method that expects
    the value of a primitive type, the Java compiler converts this object to the corresponding
    primitive type, in an operation known as **unboxing**. In the next line, the Java
    compiler converts or unboxes the `Integer` object to a value of the `int` type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler will execute code that is equivalent to the following line that
    calls the `intValue()` method that unboxes the `Integer` to an `int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We won't write a `for` loop to populate a `List` of `Integer` objects. Instead,
    we will use the `IntStream` class that specializes `Stream<T>` to describe a stream
    of `int` primitives. These classes are defined in the `java.util.stream` package,
    and therefore, we must add an `import` statement to be able to use it in our code
    in JShell. The following line calls the `IntStream.rangeClosed` method with `1`
    and `20` as the arguments to generate an `IntStream` with `int` values from `1`
    to `20` (inclusive). The chained call to the `boxed` method converts the generated
    `IntStream` into a `Stream<Integer>`, that is, a stream of `Integer` objects boxed
    from the primitive `int` values. The chained call to the `collect` method with
    `Collectors.toList()` as an argument collects the stream of `Integer` objects
    into a `List<Integer>`, specifically, an `ArrayList<Integer>`. The `Collectors`
    class is also defined in the `java.util.stream` package. The code file for the
    sample is included in the `java_9_oop_chapter_12_01` folder, in the `example12_01.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Boxing and unboxing add overheads and have both performance and memory impacts.
    In some cases, we might need to rewrite our code to avoid unnecessary boxing and
    unboxing when we want to achieve the best performance.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to understand that the `collect` operation will start processing
    the pipeline to return the desired result, that is, the list generated from the
    intermediate streams. The intermediate operations aren't executed until we call
    the `collect` method. The following screenshot shows the results of executing
    the previous lines in JShell. We can see that `range1to20` is a list of `Integer`
    that includes the numbers from 1 to 20 (inclusive) boxed into `Integer` objects.
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding functions and methods as first-class citizens](img/00096.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following lines create an instance of the `TestDivisibleBy5` class named
    `testDivisibleBy5`. Then, the code calls the `filterNumbersWithTestable` method
    with the `List<Integer> range1to20` as the `numbers` argument and the `TestDivisibleBy5`
    instance named `testDivisibleBy5` as the `tester` argument. The `List<Integer>
    divisibleBy5Numbers` will have the following values after the code runs: `[5,
    10, 15, 20]`. The code file for the sample is included in the `java_9_oop_chapter_12_01`
    folder, in the `example12_01.java` file.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines create an instance of the `TestGreaterThan10` class named
    `testGreaterThan10`. Then, the code calls the `filterNumbersWithTestable` method
    with `range1to20` and `testGreaterThan10` as the arguments. The `List<Integer>
    greaterThan10Numbers` will have the following values after the code runs: `[11,
    12, 13, 14, 15, 16, 17, 18, 19, 20]`. The code file for the sample is included
    in the `java_9_oop_chapter_12_01` folder, in the `example12_01.java` file.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the results of executing the previous lines
    in JShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding functions and methods as first-class citizens](img/00097.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Working with functional interfaces and lambda expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We had to declare an interface and two classes to make it possible for a method
    to receive an instance of `Testable` and execute the `test` method implemented
    by each class. Luckily, Java 8 introduced **functional interfaces** and Java 9
    makes it easy for us to supply a compatible **lambda expression** whenever the
    code requires a functional interface. In a nutshell, we can write less code to
    achieve the same goal.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A functional interface is an interface that meets the following condition:
    it has a single abstract method or a single method requirement. We can create
    instances of functional interfaces with lambda expressions, method references,
    or constructor references. We will work with different examples that will allow
    us to understand lambda expressions, method references, and constructor references
    and we will see them in action.'
  prefs: []
  type: TYPE_NORMAL
- en: The `IntPredicate` functional interface represents a function with one argument
    of the `int` type that returns a `boolean` result. Boolean-valued functions are
    known as predicates. This functional interface is defined in `java.util.function`,
    and therefore, we must include an `import` statement before we use it.
  prefs: []
  type: TYPE_NORMAL
- en: The following lines declare the `filterNumbersWithPredicate` method that receives
    a `List<Integer>` in the `numbers` argument and an `IntPredicate` instance in
    the `predicate` argument. The code for this method is the same as the code declared
    for the `filterNumbersWithTestable` method, with the only difference being that
    instead of receiving an argument of the `Testable` type named `tester`, the new
    method receives an argument of the `IntPredicate` type named `predicate`. The
    code also calls the `test` method with each number retrieved from the list as
    an argument to evaluate. The `IntPredicate` functional interface defines an abstract
    method named `test` that receives an `int` and returns a `boolean` result. The
    code file for the sample is included in the `java_9_oop_chapter_12_01` folder,
    in the `example12_02.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The following line declares a variable named `divisibleBy5` with the `IntPredicate`
    type and assigns a lambda expression to it. Specifically, the code assigns a lambda
    expression that receives an `int` argument named `n` and returns a `boolean` value
    indicating whether the modulus, modulo, or remainder operator (`%`) between `n`
    and `5` is equal to `0`. The code file for the sample is included in the `java_9_oop_chapter_12_01`
    folder, in the `example12_02.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The lambda expression is composed of the following three components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`n`: The argument list. In this case, there is just one argument, and therefore,
    we don''t need to enclose the argument list within parentheses. If we have more
    than one argument, it is necessary to enclose the list within parentheses. We
    don''t have to specify the types for the arguments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`->`: The arrow token.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`n % 5 == 0`: The body. In this case, the body is a single expression, and
    therefore, there is no need to enclose it in curly braces (`{}`). In addition,
    there is no need to write the `return` statement before the expression because
    it is a single expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The previous code is equivalent to the following code. The previous code is
    the shortest version and the next line is the longest version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Imagine that with any of the two versions of the previous code, we are performing
    the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an anonymous class that implements the `IntPredicate` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare a test method in the anonymous class that receives an `int` argument
    and returns a `boolean` with the body specified after the arrow token (`->`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an instance of this anonymous class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All these things happen under the hood whenever we enter a lambda expression
    when an `IntPredicate` is required. When we use lambda expressions for other functional
    interfaces, similar things will happen with the difference being that the method
    name, the arguments, and the return type for the method might be different.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Java compiler infers the types for the arguments and the return type from
    the functional interface. Things remain strongly typed and if we make a mistake
    with types, the compiler will generate the appropriate errors and the code won't
    compile.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines call the `filterNumbersWithPredicate` method with the `List<Integer>
    range1to20` as the `numbers` argument and the `IntPredicate` instance named `divisibleBy5`
    as the `predicate` argument. The `List<Integer> divisibleBy5Numbers2` will have
    the following values after the code runs: `[5, 10, 15, 20]`. The code file for
    the sample is included in the `java_9_oop_chapter_12_01` folder, in the `example12_02.java`
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines call the `filterNumbersWithPredicate` method with the `List<Integer>
    range1to20` as the `numbers` argument and a lambda expression as the `predicate`
    argument. The lambda expression receives an `int` argument named `n` and returns
    a `boolean` value indicating whether `n` is greater than `10`. The `List<Integer>
    greaterThan10Numbers2` will have the following values after the code runs: `[11,
    12, 13, 14, 15, 16, 17, 18, 19, 20]`. The code file for the sample is included
    in the `java_9_oop_chapter_12_01` folder, in the `example12_02.java` file.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The following screenshot shows the results of executing the previous lines in
    JShell.
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with functional interfaces and lambda expressions](img/00098.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The `Function<T, R>` functional interface represents a function where `T` is
    the type of the input to the function and `R` is the type of the result of the
    function. We cannot specify a primate type such as `int` for `T` because it is
    not a class, but we can use the boxed type, that is, `Integer`. We cannot use
    `boolean` for `R`, but we can use the boxed type, that is, `Boolean`. If we want
    a similar behavior than the `IntPredicate` functional interface, we can use `Function<Integer,
    Boolean>`, that is, a function with one argument of the `Integer` type that returns
    a `Boolean` result. This functional interface is defined in `java.util.function`,
    and therefore, we must include an `import` statement before we use it.
  prefs: []
  type: TYPE_NORMAL
- en: The following lines declare the `filterNumbersWithFunction` method that receives
    a `List<Integer>` in the `numbers` argument and a `Function<Integer, Boolean>`
    instance in the `predicate` argument. The code for this method is the same as
    the code declared for the `filterNumbersWithCondition` method, with the difference
    being that instead of receiving an argument of the `IntPredicate` type named `predicate`,
    the new method receives an argument of the `Function<Integer, Boolean>` type named
    `function`. The code calls the `apply` method with each number retrieved from
    the list as an argument to evaluate, instead of calling the `test` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `Function<T, R>` functional interface defines an abstract method named apply
    that receives a `T` and returns a result of type `R`. In this case, the apply
    method receives an `Integer` and returns a `Boolean` that the Java compiler will
    automatically unbox to `boolean`. The code file for the sample is included in
    the `java_9_oop_chapter_12_01` folder, in the `example12_03.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines call the `filterNumbersWithFunction` method with the `List<Integer>
    range1to20` as the `numbers` argument and a lambda expression as the `function`
    argument. The lambda expression receives an `Integer` argument named `n` and returns
    a `Boolean` value indicating whether the modulus, modulo, or remainder operator
    (`%`) between `n` and `3` is equal to `0`. Java automatically boxes the `boolean`
    value generated by the expression into a `Boolean` object. The `List<Integer>
    divisibleBy3Numbers` will have the following values after the code runs: `[3,
    6, 9, 12, 15, 18]`. The code file for the sample is included in the `java_9_oop_chapter_12_01`
    folder, in the `example12_03.java` file.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Java will run code that is equivalent to the following line. The `intValue()`
    function returns an `int` value for the received `Integer` instance in `n` and
    the lambda expression returns the `boolean` value generated by the expression
    evaluation in a new `Boolean` instance. However, remember that boxing and unboxing
    happens under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: There are more than 40 functional interfaces defined in `java.util.function`.
    We just worked with two of them that were capable of working with the same lambda
    expression. We could dedicate an entire book to analyze all the functional interfaces
    in detail. We will keep our focus on mixing object-oriented with functional programming.
    However, it is very important to know that we must check all the functional interfaces
    defined in `java.util.function` before declaring a customized one.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a functional version of array filtering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preceding code that declared the `filterNumbersWithFunction` method represents
    an imperative version of array filtering with an external `for` loop. We can use
    the `filter` method available for a `Stream<T>` object, in this case, a `Stream<Integer>`
    object, and achieve the same goal with a functional approach.
  prefs: []
  type: TYPE_NORMAL
- en: The next lines use a functional approach to generate a `List<Integer>` with
    the numbers included in the `List<Integer> range1to20` that are divisible by `3`.
    The code file for the sample is included in the `java_9_oop_chapter_12_01` folder,
    in the `example12_04.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If we want the previous code to run in JShell, we must enter all the code in
    a single line, which wouldn't be necessary for the Java compiler to successfully
    compile the code. It is a specific problem with JShell, streams, and lambda expression.
    This makes the code a bit difficult to understand. Hence, the next lines show
    another version of the code that uses multiple lines, won't work in JShell, but
    will make it easier to understand the code. Just take into account that you must
    enter the code in a single line in the next examples. The code files use single
    lines. The code file for the sample is included in the `java_9_oop_chapter_12_01`
    folder, in the `example12_04.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `stream` method generates a `Stream<Integer>` from the `List<Integer>`.
    A **stream** is a sequence of elements of a specific type that allow us to perform
    computations or aggregate operations with sequential or parallel executions. In
    fact, we can chain many stream operations and compose a stream pipeline. These
    computations have a lazy execution, that is, they won't be computed until there
    is a terminal operation such as a request to collect the final data into a `List`
    of a specific type.
  prefs: []
  type: TYPE_NORMAL
- en: The `filter` method receives a `Predicate<Integer>` as an argument and we apply
    it to the `Stream<Integer>`. The `filter` method returns the stream of the elements
    of the input stream that matches the specified predicate. The method returns a
    stream with all the elements for whom the `Predicate<Integer>` evaluates to `true`.
    We passed that previously explained lambda expression as an argument for the `filter`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `collect` method receives a `Stream<Integer>` returned by the `filter`
    method. We passed `Collectors.toList()` as an argument to the `collect` method
    to perform a mutable reduction operation on the elements of the `Stream<Integer>`
    and generate a `List<Integer>`, that is, a mutable result container. The `List<Integer>
    divisibleBy3Numbers2` will have the following values after the code runs: `[3,
    6, 9, 12, 15, 18]`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we want to follow a functional approach to print each number in the resulting
    `List<Integer>`. `List<T>` implements the `Iterable<T>` interface that allows
    us to call the `forEach` method to perform the action specified as an argument
    for each element of the `Iterable` until all the elements have been processed
    or the action throws an exception. The action argument for the `forEach` method
    must be a `Consumer<T>`, and therefore, in our case, it must be a `Consumer<Integer>`
    because we will call the `forEach` method for the resulting `List<Integer>`.
  prefs: []
  type: TYPE_NORMAL
- en: A `Consumer<T>` is a functional interface that represents an operation that
    accesses a single input argument of type `T` and returns no result (`void`). The
    `Consumer<T>` functional interface defines an abstract method named `accept` that
    receives an argument of type `T` and returns no result. The following lines pass
    a lambda expression as an argument to the `forEach` method. The lambda expression
    generates a `Consumer<Integer>` that prints the number received in `n`. The code
    file for the sample is included in the `java_9_oop_chapter_12_01` folder, in the
    `example12_04.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result of the previous line, we will see the following numbers printed
    in JShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The lambda expression that generates the `Consumer<Integer>` calls the `System.out.println`
    method with an `Integer` as an argument. We can use a method reference instead
    of a lambda expression to invoke an existing method. In this case, we can replace
    the previously shown lambda expression with `System.out::println`, that is, a
    method reference that invokes the `println` method for `System.out`. The Java
    runtime infers the method type arguments whenever we use a method reference; in
    this case, the method type argument is a single `Integer`. The code file for the
    sample is included in the `java_9_oop_chapter_12_01` folder, in the `example12_04.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The code will produce the same results as the previous call to `forEach` with
    the lambda expression. The following screenshot shows the results of executing
    the previous lines in JShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a functional version of array filtering](img/00099.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can capture variables that aren't defined within the lambda expression. When
    a lambda captures variables from the outside world, we can also call them closures.
    For example, the following lines declare an `int` variable named `byNumber` and
    assigns `4` to this variable. Then, the next lines use a new version of the combination
    of stream, filter, and collect to generate a `List<Integer>` with the numbers
    that are divisible by the number specified in the `byNumber` variable. The lambda
    expression includes `byNumber` and Java captures this variable from the outside
    world under the hood. The code file for the sample is included in the `java_9_oop_chapter_12_01`
    folder, in the `example12_04.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result of the previous line, we will see the following numbers printed
    in JShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If we use a lambda expression that doesn't match a functional interface, the
    code won't compile and the Java compiler will generate the appropriate errors.
    For example, the following line tries to assign a lambda expression that returns
    an `int` instead of either a `Boolean` or a `boolean` to an `IntPredicate` variable.
    The code file for the sample is included in the `java_9_oop_chapter_12_01` folder,
    in the `example12_05.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'JShell will display the following errors, indicating to us that `int` cannot
    be converted to `boolean`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Creating a data repository with generics and interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we want to create a repository that provides us with entities so that we
    can apply the functional programming features included in Java 9 to retrieve and
    process data from these entities. First, we will create an `Identifiable` interface
    that defines the requirements for an identifiable entity. We want any class that
    implements this interface to provide a `getId` method that returns an `int` with
    the value of a unique identifier for the entity. The code file for the sample
    is included in the `java_9_oop_chapter_12_01` folder, in the `example12_06.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The next lines create a `Repository<E>` generic interface that specifies that
    `E` must implement the recently created `Identifiable` interface in the generic
    type constraint. The class declares a `getAll` method that returns a `List<E>`.
    Each class that implements the interface must provide its own implementation for
    this method. The code file for the sample is included in the `java_9_oop_chapter_12_01`
    folder, in the `example12_06.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The next lines create the `Entity` abstract class, which is the base class for
    all the entities. The class implements the `Identifiable` interface and defines
    an immutable `id` protected field of the `int` type. The constructor receives
    the desired value for the `id` immutable field and initializes the fields with
    the received value. The abstract class implements the `getId` method that returns
    the value for the `id` immutable field. The code file for the sample is included
    in the `java_9_oop_chapter_12_01` folder, in the `example12_06.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The next lines create the `MobileGame` class, specifically, a subclass of the
    previously created `Entity` abstract class. The code file for the sample is included
    in the `java_9_oop_chapter_12_01` folder, in the `example12_06.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The class declares many public fields whose values are initialized with the
    constructor: `name`, `highestScore`, `lowestScore`, and `playersCount`. The field
    is immutable but the other three are mutable. We don''t use getters or setters
    in order to keep things simpler. However, it is important to take into account
    that some frameworks that allow us to work with entities require us to use getters
    for all the fields and setters when the fields aren''t read-only.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the class overrides the `toString` method inherited from the `java.lang.Object`
    class and that must return a `String` representation for the entity. The code
    declared in this method uses an instance of the `java.lang.StringBuilder` class
    (`sb`) to append many strings in an efficient way and finally return the results
    of calling the `sb.toString` method to return the generated `String`. This method
    uses the protected separator immutable string that determines the separator we
    use between fields. Whenever we call `System.out.println` with an instance of
    `MobileGame` as an argument, the `println` method will call the overridden `toString`
    method to print the `String` representation for the instance.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We might also use `String` concatenation (`+`) or `String.format` to write the
    code for the `toString` method because we will work with just 15 instances of
    the `MobileGame` class. However, it is a good practice to work with `StringBuilder`
    whenever we have to concatenate many strings to produce a result and we want to
    make sure that we will have the best performance when executing the code. In our
    simple example, any implementation won't have any performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: The following lines create the `MemoryMobileGameRepository` concrete class that
    implements the `Repository<MobileGame>` interface. Notice that we don't say `Repository<E>`
    but instead we indicate `Repository<MobileGame>`, because we already know the
    value for the `E` type parameter that we will implement in our class. We aren't
    creating a `MemoryMobileGameRepository<E extends Identifiable>`. Instead, we are
    creating a non-generic concrete class that implements a generic interface and
    sets the value for the parameter type `E` to `MobileGame`. The code file for the
    sample is included in the `java_9_oop_chapter_12_01` folder, in the `example12_06.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The class implements the `getAll` method required by the `Repository<E>` interface.
    In this case, the method returns a `List` of `MobileGame` (`List<MobileGame>`),
    specifically an `ArrayList<MobileGame>`. The method creates 15 `MobileGame` instances
    and appends them to an `ArrayList` of `MobileGame` that the method returns as
    a result.
  prefs: []
  type: TYPE_NORMAL
- en: The following lines create an instance of the `MemoryMobileGameRepository` class
    and call the `forEach` method for the `List<MobileGame>` returned by the `getAll`
    method. The `forEach` method calls a body on each element in the list, as is done
    in a `for` loop. The closure specified as an argument for the `forEach` method
    calls the `System.out.println` method with the `MobileGame` instance as an argument.
    This way, Java uses the `toString` method overridden in the `MobileGame` class
    to generate a `String` representation for each `MobileGame` instance. The code
    file for the sample is included in the `java_9_oop_chapter_12_01` folder, in the
    `example12_06.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the output generated after executing the previous
    code that prints the `String` returned by the `toString()` method for each `MobileGame`
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Filtering collections with complex conditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use our new repository to restrict the results retrieved from complex
    data. We can combine a call to the `getAll` method with stream, filter, and collect
    to generate a `Stream<MobileGame>`, apply a filter with a lambda expression as
    an argument, and call the `collect` method with `Collectors.toList()` as an argument
    to generate a filtered `List<MobileGame>` from the filtered `Stream<MobileGame>`.
    The `filter` method receives a `Predicate<MobileGame>` as an argument that we
    generate with a lambda expression and we apply the filter to the `Stream<MobileGame>`.
    The `filter` method returns the stream of the elements of the input stream that
    matches the specified predicate. The method returns a stream with all the elements
    for whom the `Predicate<MobileGame>` evaluates to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next lines show code snippets that use multiple lines, won't work in JShell,
    but will make it easier to read and understand the code. If we want the code to
    run in JShell, we must enter all the code in a single line, which wouldn't be
    necessary for the Java compiler to successfully compile the code. It is a specific
    problem with JShell, streams, and lambda expression. The code files use single
    lines to be compatible with JShell.
  prefs: []
  type: TYPE_NORMAL
- en: The following lines declare the new `getWithLowestScoreGreaterThan` method for
    the `MemoryMobileGameRepository` class. Notice that we don't include all the code
    for the new class in order to avoid repetition. The code file for the sample is
    included in the `java_9_oop_chapter_12_01` folder, in the `example12_07.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines use the `MemoryMobileGameRepository` instance named `repository`
    to call the previously added method and then chain a call to `forEach` to print
    all the games whose `lowestScore` value is greater than `1000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the output generated after executing the previous
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The following lines declare the new `getStartingWith` method for the `MemoryMobileGameRepository`
    class. The lambda expression passed as an argument to the `filter` method returns
    the results of calling the `startsWith` method for the game's name with the prefix
    received as an argument. In this case, the lambda expression is a closure that
    captures the `prefix` argument and uses it within the lambda expression body.
    The code file for the sample is included in the `java_9_oop_chapter_12_01` folder,
    in the `example12_08.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The following lines use the `MemoryMobileGameRepository` instance named `repository`
    to call the previously added method and then chain a call to `forEach` to print
    all the games whose names starts with `"Su"`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the output generated after executing the previous
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The following lines declare the new `getByPlayersCountAndHighestScore` method
    for the `MemoryMobileGameRepository` class. The method returns an `Optional<MobileGame>`,
    that is, a container object which may contain a `MobileGame` instance or it may
    be empty. If there is a value, the `isPresent` method will return `true` and we
    will be able to retrieve the `MobileGame` instance by calling the `get` method.
    In this case, the code calls the `findFirst` method chained to the call to the
    `filter` method. The `findFirst` method returns an `Optional<T>`, in this case,
    an `Optional<MobileGame>` with the first element in the `Stream<MobileGame>` generated
    by the `filter` method. Notice that we aren't sorting the results at any time.
    The code file for the sample is included in the `java_9_oop_chapter_12_01` folder,
    in the `example12_09.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The following lines use the `MemoryMobileGameRepository` instance named `repository`
    to call the previously added method. The code calls the `isPresent` method after
    each call to the `getByPlayersCountAndHighestScore` method to determine whether
    the `Optional<MobileGame>` has an instance. If the method returns `true`, the
    code calls the `get` method to retrieve the `MobileGame` instance from the `Optional<MobileGame>`.
    The code file for the sample is included in the `java_9_oop_chapter_12_01` folder,
    in the `example12_09.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the output generated with the previous code. In the
    first call, there was a mobile game that matched the search criteria. In the second
    call, there is no `MobileGame` instance that matches the search criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the results of executing the previous lines
    in JShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Filtering collections with complex conditions](img/00100.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using a map operation to transform values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following lines declare a new `getGameNamesTransformedToUpperCase` method
    for our previously coded `MemoryMobileGameRepository` class. The new method performs
    one of the simplest map operations. The call to the `map` method transforms a
    `Stream<MobileGame>` into a `Stream<String>`.The lambda expression passed as an
    argument to the `map` method generates a `Function<MobileGame, String>`, that
    is, it receives a `MobileGame` argument and returns a `String`. The call to the
    `collect` method generates a `List<String>` from the `Stream<String>` returned
    by the `map` method.
  prefs: []
  type: TYPE_NORMAL
- en: The code file for the sample is included in the `java_9_oop_chapter_12_01` folder,
    in the `example12_10.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `getGameNamesTransformedToUpperCase` method returns a `List<String>`. The
    `map` method transforms each `MobileGame` instance in the `Stream<MobileGame>`into
    a `String` with the `name` field converted to uppercase. This way, the `map` method
    transforms a `Stream<MobileGame>` into a `List<String>`.
  prefs: []
  type: TYPE_NORMAL
- en: The following lines use the `MemoryMobileGameRepository` instance named `repository`
    to call the previously added method and generate a list of the game names converted
    to uppercase strings. The code file for the sample is included in the `java_9_oop_chapter_12_01`
    folder, in the `example12_10.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the output generated after executing the previous
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The following code creates a new `NamesForMobileGame` class with two constructors.
    The code file for the sample is included in the `java_9_oop_chapter_12_01` folder,
    in the `example12_11.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `NamesForMobileGame` class declares two immutable fields of the `String`
    type: `upperCaseName` and `lowerCaseName`. One of the constructors receives a
    `nameString` and saves it converted to uppercase in the `upperCaseName` field
    and saves it converted to lowercase in the `lowerCaseName` field. The other constructor
    receives a `MobileGame` instance and calls the previously explained constructor
    with the `name` field for the received `MobileGame` instance as an argument.'
  prefs: []
  type: TYPE_NORMAL
- en: The following code adds a new `getNamesForMobileGames` method to the `MemoryMobileGameRepository`
    class. The new method performs a map operation. The call to the `map` method transforms
    a `Stream<MobileGame>` into a `Stream<NamesForMobileGame>`. The lambda expression
    passed as an argument to the `map` method generates a `Function<MobileGame, NamesForMobileGame>`,
    that is, it receives a `MobileGame` argument and returns an instance of `NamesForMobileGame`
    by calling the constructor that receives a `name` as an argument. The call to
    the `collect` method generates a `List<NamesForMobileGame>` from the `Stream<NamesForMobileGame>`
    returned by the `map` method. The code file for the sample is included in the
    `java_9_oop_chapter_12_01` folder, in the `example12_11.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The following lines use the `MemoryMobileGameRepository` instance named `repository`
    to call the previously added method. The lambda expression passed as an argument
    to the `forEach` method declares a body enclosed in curly braces because it requires
    many lines. This body uses an instance of the `java.lang.StringBuilder` class
    (`sb`) to append many strings with the uppercase name, a separator, and a lower
    case name. The code file for the sample is included in the `java_9_oop_chapter_12_01`
    folder, in the `example12_11.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the output generated after executing the previous
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The next code shows another version of the `getNamesForMobileGames` method
    named `getNamesForMobileGamesV2` that is equivalent and produces the same results.
    In this case, we replaced the lambda expression that generates a `Function<MobileGame,
    NamesForMobileGame>` with the constructor reference method: `NamesForMobileGame::new`.
    The constructor reference method is specified with the class name followed by
    `::new` and will create a new instance of the `NamesForMobileGame` by using the
    constructor that receives a `MobileGame` instance as an argument. The code file
    for the sample is included in the `java_9_oop_chapter_12_01` folder, in the `example12_12.java`
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The following code uses the new version of the method and produces the same
    results shown for the first version. The code file for the sample is included
    in the `java_9_oop_chapter_12_01` folder, in the `example12_12.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Combining a map operation with reduce
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following lines show an imperative code version of a `for` loop that calculates
    the sum of all the `lowestScore` values for the mobile games. The code file for
    the sample is included in the `java_9_oop_chapter_12_01` folder, in the `example12_13.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The code is very easy to understand. The `lowestScoreSum` variable has a starting
    value of `0`, and each iteration of the `for` loop retrieves a `MobileGame` instance
    from the `List<MobileGame>` returned by the `repository.getAll()` method and increases
    the value of the `lowestScoreSum` variable with the value of the `mobileGame.lowestScore`
    field.
  prefs: []
  type: TYPE_NORMAL
- en: We can combine the map and reduce operations to create a functional version
    of the previous imperative code to calculate the sum of all the `lowestScore`
    values for the mobile games. The next lines chain a call to `map` to a call to
    `reduce` to achieve this goal. Take a look at the following code. The code file
    for the sample is included in the `java_9_oop_chapter_12_01` folder, in the `example12_14.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'First, the code uses the call to `map` to transform a `Stream<MobileGame>`
    into a `Stream<Integer>` with the values specified in the `lowestScore` stored
    property boxed into `Integer` objects. Then, the code calls the `reduce` method
    that receives two arguments: the initial value for an accumulated value, `0`,
    and a combine closure that will be repeatedly called with the accumulated value.
    The method returns the results of the repeated calls to the combine closure.'
  prefs: []
  type: TYPE_NORMAL
- en: The closure specified in the second argument for the `reduce` method receives
    `sum` and `lowestScore` and returns the sum of both values. Hence, the closure
    returns the sum of the total accumulated so far plus the `lowestScore` value that
    is processed. We can add a `System.out.println` statement to display the values
    for both `sum` and `lowestScore` within the closure specified in the second argument
    for the `reduce` method. The following lines show a new version of the previous
    code that adds the line with the `System.out.println` statement that will allow
    us to dive deep into how the `reduce` operation works. The code file for the sample
    is included in the `java_9_oop_chapter_12_01` folder, in the `example12_15.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The following lines show the results for the previous lines, where we can see
    how the value for the `sum` argument starts with the initial value specified in
    the first argument for the `reduce` method (`0`) and accumulates the sum completed
    so far. Finally, the `lowestScoreSum2` variable holds the sum of all the `lowestScore`
    values. We can see that the last value printed for `sum` and `lowestScore` are
    `10910` and `5`. The last piece of code executed for the reduce operation computes
    `10910` plus `5` and returns `10915`, which is the result saved in the `lowestScoreSum2`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we combined map and reduce to perform a sum. We can
    take advantage of the reduction methods provided by Java 9 to achieve the same
    goal with simplified code. In the following code, we take advantage of `mapToInt`
    to generate an `IntStream`; the sum works with `int` values and doesn't have to
    unbox `Integer` to `int`. The code file for the sample is included in the `java_9_oop_chapter_12_01`
    folder, in the `example12_16.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The next lines also produce the same results with a different pipeline that
    is not as efficient as the previously shown one. The `map` method has to box the
    returned `int` into an `Integer` and returns a `Stream<Integer>`. Then, the call
    to the `collect` method specifies a call to `Collectors.summingInt` as an argument.
    `Collectors.summingInt` requires `int` values to compute the sum, and therefore,
    we pass a method reference to call the `intValue` method for each `Integer` in
    the `Stream<Integer>`. The following lines use the `Collectors.summingInt` collector
    to perform the sum of the `int` values. The code file for the sample is included
    in the `java_9_oop_chapter_12_01` folder, in the `example12_17.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we know that the `Integer.MAX_VALUE` will allow us to hold the
    accurate result for the sum. However, in some cases, we have to use the`long`
    type. The following code uses the `mapToLong` method to use a `long` to accumulate
    the values. The code file for the sample is included in the `java_9_oop_chapter_12_01`
    folder, in the `example12_18.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Java 9 provides many reduction methods, also known as aggregate operations.
    Make sure you consider them before writing your own code to perform operations
    such as count, average, and sum. We can use them to perform arithmetic operations
    on streams and get the number results.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining many operations with map and reduce
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can chain `filter`, `map`, and `reduce` operations. The following code adds
    a new `getHighestScoreSumForMinPlayersCount` method to the `MemoryMobileGameRepository`
    class. The code file for the sample is included in the `java_9_oop_chapter_12_01`
    folder, in the `example12_19.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The new method performs a `filter` chained with a `mapToLong` and finally a
    `reduce` operation. The call to `filter` generates a `Stream<MobileGame>` with
    the instance of `MobileGame` whose `playersCount` value is equal or greater than
    the `minPlayersCount` value received as an argument. The `mapToLong` method returns
    a `LongStream`, that is, a specialized `Stream<T>` that describes a stream of
    `long` primitives. The call to `mapToLong` receives the `highestScore` value of
    the `int` type for each filtered `MobileGame` instance and returns this value
    converted to `long`.
  prefs: []
  type: TYPE_NORMAL
- en: The `reduce` method receives a `LongStream` from the processing pipeline. The
    initial value for the accumulated value of the `reduce` operation is specified
    as the first argument, `0`, and the second argument is a lambda expression with
    the combine operation that will be repeatedly called with the accumulated value.
    The method returns the results of the repeated calls to the combine operation.
  prefs: []
  type: TYPE_NORMAL
- en: The lambda expression specified in the second argument for the `reduce` method
    receives `sum` and `highestScore` and returns the sum of both values. Hence, the
    lambda expression returns the sum of the total accumulated so far, received in
    the `sum` argument, plus the `highestScore` value that is processed.
  prefs: []
  type: TYPE_NORMAL
- en: The next lines use the previously created method. The code file for the sample
    is included in the `java_9_oop_chapter_12_01` folder, in the `example12_19.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'JShell will display the following value as a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: As we learned from the previous examples, we can use the `sum` method instead
    of writing the code for the `reduce` method. The next code shows another version
    of the `getHighestScoreSumForMinPlayersCount` method named `getHighestScoreSumForMinPlayersCountV2`
    that is equivalent and produces the same results. The code file for the sample
    is included in the `java_9_oop_chapter_12_01` folder, in the `example12_20.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The following code uses the new version of the method and produces the same
    results shown for the first version. The code file for the sample is included
    in the `java_9_oop_chapter_12_01` folder, in the `example12_20.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Working with different collectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can follow a functional approach and solve different kinds of algorithms
    with stream processing pipelines and the help of the diverse collectors provided
    by Java 9, that is, the diverse static methods provided by the `java.util.stream.Collectors`
    class. In the next examples, we will use different arguments for the `collect`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: The following lines join all the names for the `MobileGame` instances to generate
    a single `String` with the names separated with a separator (`"; "`). The code
    file for the sample is included in the `java_9_oop_chapter_12_01` folder, in the
    `example12_21.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The code passes `Collectors.joining(";" )` as an argument to the `collect` method.
    The `joining` static method returns a `Collector` that concatenates the input
    elements into a `String` separated by the delimiter received as an argument. The
    following shows the results of executing the previous lines in JShell.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The code passes `Comparator.comparing(game -> game.name)` as an argument to
    the `sorted` method. The `comparing` static method receives a function that extracts
    the desired sort key from the `MobileGame` and returns a `Comparator<MobileGame>`
    that compares this sort key using the specified comparator. The code passes a
    lambda expression as an argument to the `comparing` static method to specify the
    name as the desired sort key for the `MobileGame` instances. The sorted method
    receives a `Stream<MobileGame>` and returns a `Stream<MobileGame>` with the `MobileGame`
    instances sorted according to the provided `Comparator<MobileGame>`. The following
    shows the results of executing the previous lines in JShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Now we want to check the games that have a players' count equal or higher than
    a specified threshold. We want to check the games that passed and failed. The
    following lines generate a `Map<Boolean, List<MobileGame>>` whose key specifies
    whether the mobile games passed or not and the value includes the `List<MobileGame>`
    that passed or failed. Then, the code calls the `forEach` method to display the
    results. The code file for the sample is included in the `java_9_oop_chapter_12_01`
    folder, in the `example12_23.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The code passes `Collectors.partitioningBy(g -> g.playersCount >= 100000)` as
    an argument to the `collect` method. The `partitioningBy` static method receives
    a `Predicate<MobileGame>`. The code passes a lambda expression as an argument
    to the `partitioningBy` static method to specify that the input elements must
    be partitioned based on whether the `playersCount` field is greater than or equal
    to `100000` or not. The returned `Collector<MobileGame>` partitions the `Stream<MobileGame>`
    and organizes it into a `Map<Boolean, List<MobileGame>>`, performing a downstream
    reduction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the code calls the `forEach` method with a lambda expression as an argument
    that receives the key and value from the `Map<Boolean, List<MobileGame>>` in the
    `passed` and `mobileGames` arguments. The following shows the results of executing
    the previous lines in JShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The following shows the results of executing the previous lines in JShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A functional interface is an interface that meets the following condition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It uses a lambda expression in one of its default methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It has a single abstract method or a single method requirement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It implements the `Lambda<T, U>` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can create an instance of a functional interface with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lambda expressions, method references, or constructor references.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Only lambda expressions. Method references and constructor references only work
    with `Predicate<T>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Method references and constructor references. Lambda expressions only work with
    `Predicate<T>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `IntPredicate` functional interface represents a function with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One argument of the `int` type that returns no result (`void`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One argument of the `int` type that returns an `Integer` result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One argument of the `int` type that returns a `boolean` result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When we apply a `filter` method to a `Stream<T>`, the method returns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `Stream<T>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `List<T>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `Map<T, List<T>>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following code snippets is equivalent to `numbers.forEach(n ->
    System.out.println(n));`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`numbers.forEach(n::System.out.println);`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`numbers.forEach(System.out::println);`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`numbers.forEach(n ->System.out.println);`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we worked with many functional programming features included
    in Java 9 and combined them with everything we discussed so far about object-oriented
    programming. We analyzed the differences between imperative code and functional
    programming approaches for many algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: We worked with functional interfaces and lambda expressions. We understood method
    references and constructor references. We created a data repository with generics
    and interfaces and we used it to work with filters, map operations, reductions,
    aggregate functions, sorting and partitioning. We worked with different stream
    processing pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned about functional programming, we are ready to take
    advantage of modularity in Java 9, which is the topic we are going to discuss
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
