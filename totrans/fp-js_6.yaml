- en: Chapter 6. Advanced Topics and Pitfalls in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript has been called the "assembly language of the web". The analogy (it
    isn't perfect, but which analogy is?) draws from the fact that JavaScipt is often
    a target for compilation, namely from **Clojure** and **CoffeeScript**, but also
    from many other sources such as **pyjamas** (python to JS) and Google Web Kit
    (Java to JS).
  prefs: []
  type: TYPE_NORMAL
- en: But the analogy also references the foolish idea that JavaScript is as expressive
    and low-level as x86 assembly. Perhaps this notion stems from the fact that JavaScript
    has been bashed for its design flaws and oversights ever since it was first shipped
    with Netscape back in 1995\. It was developed and released in a hurry, before
    it could be fully developed. And because of that, some questionable design choices
    made its way into JavaScript, the language that soon became the de-facto scripting
    language of the web. Semicolons were a big mistake. So were its ambiguous methods
    for defining functions. Is it `var foo = function();` or `function foo();`?
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming is an excellent way to side-step some of these mistakes.
    By focusing on the fact that JavaScript is truly a functional language, it becomes
    clear that, in the preceding example about the different ways to declare a function,
    it's best to declare functions as variables. And that semicolons are mostly just
    syntactic sugar to make JavaScript appear more C-like.
  prefs: []
  type: TYPE_NORMAL
- en: 'But always remember the language you are working with. JavaScript, like any
    other language, has its pitfalls. And, when programming in a style that often
    skirts the bleeding edge of what''s possible, those minor stumbles can become
    non-recoverable gotchas. Some of these gotchas include:'
  prefs: []
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable scope and closures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function declarations vs. function expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, these issues can be overcome with a little attention.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recursion is very important to functional programming in any language. Many
    functional languages go so far as to require recursion for iteration by not providing
    `for` and `while` loop statements; this is only possible when tail-call elimination
    is guaranteed by the language, which is not the case for JavaScript. A quick primer
    on recursion was given in [Chapter 2](part0019_split_000.html#page "Chapter 2. Fundamentals
    of Functional Programming"), *Fundamentals of Functional Programming*. But in
    this section, we'll dig deeper into exactly how recursion works in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Tail recursion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript's routine for handling recursion is known as *tail recursion*, a
    stack-based implementation of recursion. This means that, for every recursive
    call, there is a new frame in the stack.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate the problems that can arise from this method, let's use the classic
    recursive algorithm for factorials.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The algorithm will call itself `n` times to get the answer. It's literally computing
    `(1 x 1 x 2 x 3 x … x N)`. That means the time complexity is `O(n)`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`O(n)`, pronounced "big oh to the n," means that the complexity of the algorithm
    will grow at a rate of `n` as the size of the input grows, which is leaner growth.
    `O(n2)` is exponential growth, `O(log(n))` is logarithmic growth, and so on. This
    notation can be used for time complexity as well as space complexity.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But, because a new frame in the memory stack is allocated for each iteration,
    the space complexity is also `O(n)`. This is a problem. This means that memory
    will be consumed at such a rate the memory limit will be exceeded far too easily.
    On my laptop, `factorial(23456)` returns `Uncaught Error: RangeError: Maximum
    call stack size exceeded`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While calculating the factorial of 23,456 is a frivolous endeavor, you can
    be assured that many problems that are solved with recursion will grow to that
    size without too much trouble. Consider the case of data trees. The tree could
    be anything: search applications, file systems, routing tables, and so on. Below
    is a very simple implementation of the tree traversal function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: With just two children per node, both time complexity and space complexity,
    (in the worst case, where the entire tree must be traversed to find the answer),
    would be `O(n2)` because there would be two recursive calls each. With many children
    per node, the complexity would be `O(nm)` where `m` is the number of children.
    And recursion is the preferred algorithm for tree traversal; a `while` loop would
    be much more complex and would require the maintenance of a stack.
  prefs: []
  type: TYPE_NORMAL
- en: Exponential growth like this would mean that it would not take a very large
    tree to throw a `RangeError` exception. There must be a better way.
  prefs: []
  type: TYPE_NORMAL
- en: The Tail-call elimination
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We need a way to eliminate the allocation of new stack frames for every recursive
    call. This is known as *tail-call elimination*.
  prefs: []
  type: TYPE_NORMAL
- en: With tail-call elimination, when a function returns the result of calling itself,
    the language doesn't actually perform another function call. It turns the whole
    thing into a loop for you.
  prefs: []
  type: TYPE_NORMAL
- en: OK, so how do we do this? With lazy evaluation. If we could rewrite it to fold
    over a lazy sequence, such that the function returns a value or it returns the
    result of calling another function without doing anything with that result, then
    new stack frames don't need to be allocated.
  prefs: []
  type: TYPE_NORMAL
- en: 'To put it in "tail recursion form", the factorial function would have to be
    rewritten such that the inner procedure `fact` calls itself last in the control
    flow, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Instead of having the result produced by the first function in the recursion
    tail (like in `n * factorial(n-1)`), the result is computed going down the recursion
    tail (with the call to `_fact(r*n, n-1)`) and is produced by the last function
    in this tail (with `return r;`). The computation goes only one way down, not on
    its way up. It's relatively easy to process it as an iteration for the interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, *tail-call elimination does not work in JavaScript*. Put the above
    code into your favorite JavaScript engine and `factorial(24567)` still returns
    `Uncaught Error: RangeError: Maximum call stack size exceeded` exception. Tail-call
    elimination is listed as a new feature to be included in the next release of ECMAScript,
    but it will be some time before all browsers implement it.'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript cannot optimize functions that are put into tail recursion form.
    It's a feature of the language specification and runtime interpreter, plain and
    simple. It has to do with how the interpreter acquires resources for stack frames.
    Some languages will reuse the same stack frame when it doesn't need to remember
    anything new, like in the preceding function. This is how tail-call elimination
    reduces both time and space complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, JavaScript does not do this. But if it did, it would reorganize
    the stack frames from this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Trampolining
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The solution? A process known as **trampolining**. It's a way to "hack" the
    concept of tail-call elimination into a program by using **thunks**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Thunks are, for this purpose, expressions with arguments that wrap anonymous
    functions with no arguments of their own. For example: `function(str){return function(){console.log(str)}}`.
    This prevents the expression from being evaluated until a receiving function calls
    the anonymous function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A trampoline is a function that takes a function as input and repeatedly executes
    its returned value until something other than a function is returned. A simple
    implementation is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: To actually implement tail-call elimination, we need to use thunks. For this,
    we can use the `bind()` function that allows us to apply a method to one object
    with the `this` keyword assigned to another. Internally, it's the same as the
    `call` keyword, but it's chained to the method and returns a new bound function.
    The `bind()` function actually does partial application, though in a very limited
    way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'But writing the `fact.bind(null, ...)` method is cumbersome and would confuse
    anybody reading the code. Instead, let''s write our own function for creating
    thunks. There are a few things the `thunk()` function must do:'
  prefs: []
  type: TYPE_NORMAL
- en: '`thunk()` function must emulate the `_fact.bind(null, n*x, n-1)` method that
    returns a non-evaluated function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `thunk()` function should enclose two more functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For processing the give function, and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For processing the function arguments that will be used when the given function
    is invoked
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With that, we're ready to write the function. We only need a few lines of code
    to write it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use the `thunk()` function in our factorial algorithm like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: But again, we can simplify it just a bit further by defining the `_fact()` function
    as a `thunk()` function. By defining the inner function as a `thunk()` function,
    we're relieved of having to use the `thunk()` function both inside the inner function
    definition and in the return statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The result is beautiful. What seems like the function `_fact()` being recursively
    called for a tail-free recursion is almost transparently processed as an iteration!
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s see how the `trampoline()` and `thunk()` functions work with
    our more meaningful example of tree traversal. The following is a crude example
    of how a data tree could be traversed using trampolining and thunks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We've solved the issue of tail recursion. But is there an even better way? What
    if we could simply convert the recursive function to a non-recursive function?
    Up next, we'll look at how to do just that.
  prefs: []
  type: TYPE_NORMAL
- en: The Y-combinator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Y-combinator is one of those things in computer science that amaze even
    the deftest of programming masterminds. Its ability to automatically convert recursive
    functions to non-recursive functions is why Douglas Crockford calls it "one of
    the most strange and wonderful artifacts of computer science", and Sussman and
    Steele once said, "That this manages to work is truly remarkable".
  prefs: []
  type: TYPE_NORMAL
- en: 'So a truly-remarkable, wonderfully strange artifact of computer science that
    brings recursive functions to their knees must be massive and complex, right?
    No, not exactly. Its implementation in JavaScript is only nine, very odd, lines
    of code. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how it works: it finds the "fixed point" of the function passed in
    as an argument. Fixed points offer another way to think about functions rather
    than recursion and iteration in the theory of computer programming. And it does
    this with only the use of anonymous function expressions, function applications,
    and variable references. Note that `Y` does not reference itself. In fact, all
    those functions are anonymous.'
  prefs: []
  type: TYPE_NORMAL
- en: As you might have guessed, the Y-combinator came out of lambda calculus. It's
    actually derived with the help of another combinator called the U-combinator.
    Combinators are special higher-order functions that only use function application
    and earlier defined combinators to define a result from its input.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate the Y-combinator, we'll again turn to the factorial problem,
    but we need to define the factorial function a little differently. Instead of
    writing a recursive function, we write a function that returns a function that
    is the mathematical definition of factorials. Then we can pass this into the Y-combinator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: However, when we give it a significantly large number, the stack overflows just
    as if tail recursion without trampolining was used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'But we can use trampolining with the Y-combinator as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We can also rearrange the Y-combinator to perform something called memoization.
  prefs: []
  type: TYPE_NORMAL
- en: Memoization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Memoization is the technique of storing the result of expensive function calls.
    When the function is later called with the same arguments, the stored result is
    returned rather than computing the result again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the Y-combinator is much faster than recursion, it is still relatively
    slow. To speed it up, we can create a memoizing fixed-point combinator: a Y-like
    combinator that caches the results of intermediate function calls.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: So how much faster is it? By using [http://jsperf.com/](http://jsperf.com/),
    we can compare the performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following results are with random numbers between 1 and 100\. We can see
    that the memoizing Y-combinator is much, much faster. And adding trampolining
    to it does not slow it down by much. You can view the results and run the tests
    yourself at this URL: [http://jsperf.com/memoizing-y-combinator-vs-tail-call-optimization/7](http://jsperf.com/memoizing-y-combinator-vs-tail-call-optimization/7).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Memoization](../images/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The bottom line is: the most efficient and safest method of performing recursion
    in JavaScript is to use the memoizing Y-combinator with tail-call elimination
    via trampolining and thunks.'
  prefs: []
  type: TYPE_NORMAL
- en: Variable scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The scope of variables in JavaScript is not natural. In fact, sometimes it's
    downright counter-intuitive. They say that JavaScript programmers can be judged
    by how well they understand scope.
  prefs: []
  type: TYPE_NORMAL
- en: Scope resolutions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, let's go over the different scope resolutions in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript uses scope chains to establish the scope of variables. When resolving
    a variable, it starts at the innermost scope and searches outwards.
  prefs: []
  type: TYPE_NORMAL
- en: Global scope
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Variables, functions, and objects defined at this level are available to any
    code in the entire program. This is the outermost scope.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Local scope
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each function described has its own local scope. Any function defined within
    another function has a nested local scope that is linked to the outer function.
    Almost always, it's the position in the source that defines the scope.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Local scope is only for functions and not for any expression statements (`if`,
    `for`, `while`, and so on), which is different from how most languages treat scope.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In functional programming, this isn''t as much of a concern because functions
    are used more often and expression statements less often. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Object properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Object properties have their own scope chains as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The object's prototype is further down the scope chain.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This isn't even close to being comprehensive, but these three types of scope
    are enough to get started.
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One problem with this scope structure is that it leaves no room for private
    variables. Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: These variables and functions are global, which means it would be too easy for
    code later down the program to accidentally overwrite them. One solution would
    be to encapsulate them into a function and call that function immediately after
    defining it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Nothing is happening outside the function, so we ought to discard the function
    name by making it anonymous.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the functions `getValue()` and `updateMillage()` available outside
    the anonymous function, we''ll need to return them in an object literal as shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This gives us pseudo-private variables, but the problems don't stop there. The
    following section explores more issues with variable scope in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Gotchas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many variable scope nuances can be found throughout JavaScript. The following
    is by no means a comprehensive list, but it covers the most common cases:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following will output 4, not ''undefined'' as one would expect:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This is due to the fact that, in JavaScript, variable definition happens at
    the beginning of the corresponding scope, not just when it is declared.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you define a variable in the outer scope, and then have an `if` statement
    define a variable inside the function with the same name, even if that `if` branch
    isn''t reached, it is redefined. An example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Again, this is caused by moving the variable definition at the beginning of
    the scope with the `undefined` value.
  prefs: []
  type: TYPE_NORMAL
- en: In the browser, global variables are really stored in the `window` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`a` in the global scope means `a` as an attribute of the current context, so
    `a===this.a` and `window` object in a browser act as an equivalent of the `this`
    keyword in the global scope.'
  prefs: []
  type: TYPE_NORMAL
- en: The first two examples are a result of a feature of JavaScript known as hoisting,
    which will be a critical concept in the next section about writing functions.
  prefs: []
  type: TYPE_NORMAL
- en: Function declarations versus function expressions versus the function constructor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between these three statements?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: At first glance, they're merely different ways to write the same function. But
    there's a little more going on here. And if we're to take full advantage of functions
    in JavaScript in order to manipulate them into a functional programming style,
    then we'd better be able to get this right. If there is a better way to do something
    in computer programming, then that one way should be the only way.
  prefs: []
  type: TYPE_NORMAL
- en: Function declarations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Function declarations, sometimes called function statements, define a function
    by using the `function` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions that are declared with this syntax are *hoisted* to the top of the
    current scope. What this actually means is that, even if the function is defined
    several lines down, JavaScript knows about it and can use it earlier in the scope.
    For example, the following will correctly print 6 to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Function expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Named functions can also be defined as an expression by defining an anonymous
    function and assigning it to a variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'They are not hoisted like function declarations are. This is because, while
    function declarations are hoisted, variable declarations are not. For example,
    this will not work and will throw an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In functional programming, we're going to want to use function expressions so
    we can treat the functions like variables, making them available to be used as
    callbacks and arguments to higher-order functions such as `map()` functions. Defining
    functions as expressions makes it more obvious that they're variables assigned
    to a function. Also, if we're going to write functions in one style, we should
    write all functions in that style for the sake of consistency and clarity.
  prefs: []
  type: TYPE_NORMAL
- en: The function constructor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript actually has a third way to create functions: with the `Function()`
    constructor. Just like function expressions, functions defined with the `Function()`
    constructor are not hoisted.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'But the `Function()` constructor is not only confusing, it is also highly dangerous.
    No syntax correction can happen, no optimization is possible. It''s far easier,
    safer, and less confusing to write the same function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Unpredictable behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So the difference is that function declarations are hoisted while function
    expressions are not. This can cause unexpected things to happen. Consider the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: What's actually printed to the console is `hello`. This is due to the fact that
    the second definition of the `foo()` function is hoisted to the top, making it
    the definition that is actually used by the JavaScript interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: 'While at first this may not seem like a critical difference, in functional
    programming this can cause mayhem. Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: When the `foo()` function is called, `two` is printed to the console, not `one`!
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, there is a way to combine both function expressions and declarations.
    It works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'It makes very little sense to use this method because the name used in the
    declaration (the `bar()` function in the preceding example) is not available outside
    the function and causes confusion. It would only be appropriate for recursion,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript has been called the "assembly language of the web," because it's
    as ubiquitous and unavoidable as x86 assembly. It's the only language that runs
    on all browsers. It's also flawed, yet referring to it as a low-level language
    is missing the mark.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, think of JavaScript as the raw coffee beans of the web. Sure, some
    of the beans are damaged and a few are rotten. But if the good ones are selected,
    roasted, and brewed by a skilled barista, the beans can be transformed into a
    brilliant jamocha that cannot be had just once and forgotten. It's consumption
    becomes a daily custom, life without it would be static, harder to perform, and
    much less exciting. Some even prefer to enhance the brew with plug-ins and add-ons
    such as cream, sugar, and cocoa, which complement it very well.
  prefs: []
  type: TYPE_NORMAL
- en: One of JavaScript's biggest critics, Douglas Crawford, was quoted as saying
    "There are certainly a lot of people who refuse to consider the possibility that
    JavaScript got anything right. I used to be one of those guys. But now I continue
    to be amazed by the brilliance that is in there".
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript turned out to be pretty awesome.
  prefs: []
  type: TYPE_NORMAL
