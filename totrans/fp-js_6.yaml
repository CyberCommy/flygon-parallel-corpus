- en: Chapter 6. Advanced Topics and Pitfalls in JavaScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript has been called the "assembly language of the web". The analogy (it
    isn't perfect, but which analogy is?) draws from the fact that JavaScipt is often
    a target for compilation, namely from **Clojure** and **CoffeeScript**, but also
    from many other sources such as **pyjamas** (python to JS) and Google Web Kit
    (Java to JS).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: But the analogy also references the foolish idea that JavaScript is as expressive
    and low-level as x86 assembly. Perhaps this notion stems from the fact that JavaScript
    has been bashed for its design flaws and oversights ever since it was first shipped
    with Netscape back in 1995\. It was developed and released in a hurry, before
    it could be fully developed. And because of that, some questionable design choices
    made its way into JavaScript, the language that soon became the de-facto scripting
    language of the web. Semicolons were a big mistake. So were its ambiguous methods
    for defining functions. Is it `var foo = function();` or `function foo();`?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming is an excellent way to side-step some of these mistakes.
    By focusing on the fact that JavaScript is truly a functional language, it becomes
    clear that, in the preceding example about the different ways to declare a function,
    it's best to declare functions as variables. And that semicolons are mostly just
    syntactic sugar to make JavaScript appear more C-like.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'But always remember the language you are working with. JavaScript, like any
    other language, has its pitfalls. And, when programming in a style that often
    skirts the bleeding edge of what''s possible, those minor stumbles can become
    non-recoverable gotchas. Some of these gotchas include:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Recursion
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable scope and closures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function declarations vs. function expressions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, these issues can be overcome with a little attention.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Recursion
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recursion is very important to functional programming in any language. Many
    functional languages go so far as to require recursion for iteration by not providing
    `for` and `while` loop statements; this is only possible when tail-call elimination
    is guaranteed by the language, which is not the case for JavaScript. A quick primer
    on recursion was given in [Chapter 2](part0019_split_000.html#page "Chapter 2. Fundamentals
    of Functional Programming"), *Fundamentals of Functional Programming*. But in
    this section, we'll dig deeper into exactly how recursion works in JavaScript.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Tail recursion
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript's routine for handling recursion is known as *tail recursion*, a
    stack-based implementation of recursion. This means that, for every recursive
    call, there is a new frame in the stack.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate the problems that can arise from this method, let's use the classic
    recursive algorithm for factorials.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The algorithm will call itself `n` times to get the answer. It's literally computing
    `(1 x 1 x 2 x 3 x … x N)`. That means the time complexity is `O(n)`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`O(n)`, pronounced "big oh to the n," means that the complexity of the algorithm
    will grow at a rate of `n` as the size of the input grows, which is leaner growth.
    `O(n2)` is exponential growth, `O(log(n))` is logarithmic growth, and so on. This
    notation can be used for time complexity as well as space complexity.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'But, because a new frame in the memory stack is allocated for each iteration,
    the space complexity is also `O(n)`. This is a problem. This means that memory
    will be consumed at such a rate the memory limit will be exceeded far too easily.
    On my laptop, `factorial(23456)` returns `Uncaught Error: RangeError: Maximum
    call stack size exceeded`.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'While calculating the factorial of 23,456 is a frivolous endeavor, you can
    be assured that many problems that are solved with recursion will grow to that
    size without too much trouble. Consider the case of data trees. The tree could
    be anything: search applications, file systems, routing tables, and so on. Below
    is a very simple implementation of the tree traversal function:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With just two children per node, both time complexity and space complexity,
    (in the worst case, where the entire tree must be traversed to find the answer),
    would be `O(n2)` because there would be two recursive calls each. With many children
    per node, the complexity would be `O(nm)` where `m` is the number of children.
    And recursion is the preferred algorithm for tree traversal; a `while` loop would
    be much more complex and would require the maintenance of a stack.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Exponential growth like this would mean that it would not take a very large
    tree to throw a `RangeError` exception. There must be a better way.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: The Tail-call elimination
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We need a way to eliminate the allocation of new stack frames for every recursive
    call. This is known as *tail-call elimination*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: With tail-call elimination, when a function returns the result of calling itself,
    the language doesn't actually perform another function call. It turns the whole
    thing into a loop for you.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: OK, so how do we do this? With lazy evaluation. If we could rewrite it to fold
    over a lazy sequence, such that the function returns a value or it returns the
    result of calling another function without doing anything with that result, then
    new stack frames don't need to be allocated.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'To put it in "tail recursion form", the factorial function would have to be
    rewritten such that the inner procedure `fact` calls itself last in the control
    flow, as shown in the following code snippet:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Instead of having the result produced by the first function in the recursion
    tail (like in `n * factorial(n-1)`), the result is computed going down the recursion
    tail (with the call to `_fact(r*n, n-1)`) and is produced by the last function
    in this tail (with `return r;`). The computation goes only one way down, not on
    its way up. It's relatively easy to process it as an iteration for the interpreter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'However, *tail-call elimination does not work in JavaScript*. Put the above
    code into your favorite JavaScript engine and `factorial(24567)` still returns
    `Uncaught Error: RangeError: Maximum call stack size exceeded` exception. Tail-call
    elimination is listed as a new feature to be included in the next release of ECMAScript,
    but it will be some time before all browsers implement it.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript cannot optimize functions that are put into tail recursion form.
    It's a feature of the language specification and runtime interpreter, plain and
    simple. It has to do with how the interpreter acquires resources for stack frames.
    Some languages will reuse the same stack frame when it doesn't need to remember
    anything new, like in the preceding function. This is how tail-call elimination
    reduces both time and space complexity.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, JavaScript does not do this. But if it did, it would reorganize
    the stack frames from this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'into the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Trampolining
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The solution? A process known as **trampolining**. It's a way to "hack" the
    concept of tail-call elimination into a program by using **thunks**.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Thunks are, for this purpose, expressions with arguments that wrap anonymous
    functions with no arguments of their own. For example: `function(str){return function(){console.log(str)}}`.
    This prevents the expression from being evaluated until a receiving function calls
    the anonymous function.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'A trampoline is a function that takes a function as input and repeatedly executes
    its returned value until something other than a function is returned. A simple
    implementation is shown in the following code snippet:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To actually implement tail-call elimination, we need to use thunks. For this,
    we can use the `bind()` function that allows us to apply a method to one object
    with the `this` keyword assigned to another. Internally, it's the same as the
    `call` keyword, but it's chained to the method and returns a new bound function.
    The `bind()` function actually does partial application, though in a very limited
    way.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'But writing the `fact.bind(null, ...)` method is cumbersome and would confuse
    anybody reading the code. Instead, let''s write our own function for creating
    thunks. There are a few things the `thunk()` function must do:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '`thunk()` function must emulate the `_fact.bind(null, n*x, n-1)` method that
    returns a non-evaluated function'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `thunk()` function should enclose two more functions:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For processing the give function, and
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For processing the function arguments that will be used when the given function
    is invoked
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With that, we're ready to write the function. We only need a few lines of code
    to write it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we can use the `thunk()` function in our factorial algorithm like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: But again, we can simplify it just a bit further by defining the `_fact()` function
    as a `thunk()` function. By defining the inner function as a `thunk()` function,
    we're relieved of having to use the `thunk()` function both inside the inner function
    definition and in the return statement.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The result is beautiful. What seems like the function `_fact()` being recursively
    called for a tail-free recursion is almost transparently processed as an iteration!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s see how the `trampoline()` and `thunk()` functions work with
    our more meaningful example of tree traversal. The following is a crude example
    of how a data tree could be traversed using trampolining and thunks:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We've solved the issue of tail recursion. But is there an even better way? What
    if we could simply convert the recursive function to a non-recursive function?
    Up next, we'll look at how to do just that.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: The Y-combinator
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Y-combinator is one of those things in computer science that amaze even
    the deftest of programming masterminds. Its ability to automatically convert recursive
    functions to non-recursive functions is why Douglas Crockford calls it "one of
    the most strange and wonderful artifacts of computer science", and Sussman and
    Steele once said, "That this manages to work is truly remarkable".
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'So a truly-remarkable, wonderfully strange artifact of computer science that
    brings recursive functions to their knees must be massive and complex, right?
    No, not exactly. Its implementation in JavaScript is only nine, very odd, lines
    of code. They are as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here''s how it works: it finds the "fixed point" of the function passed in
    as an argument. Fixed points offer another way to think about functions rather
    than recursion and iteration in the theory of computer programming. And it does
    this with only the use of anonymous function expressions, function applications,
    and variable references. Note that `Y` does not reference itself. In fact, all
    those functions are anonymous.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: As you might have guessed, the Y-combinator came out of lambda calculus. It's
    actually derived with the help of another combinator called the U-combinator.
    Combinators are special higher-order functions that only use function application
    and earlier defined combinators to define a result from its input.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate the Y-combinator, we'll again turn to the factorial problem,
    but we need to define the factorial function a little differently. Instead of
    writing a recursive function, we write a function that returns a function that
    is the mathematical definition of factorials. Then we can pass this into the Y-combinator.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: However, when we give it a significantly large number, the stack overflows just
    as if tail recursion without trampolining was used.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'But we can use trampolining with the Y-combinator as in the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can also rearrange the Y-combinator to perform something called memoization.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Memoization
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Memoization is the technique of storing the result of expensive function calls.
    When the function is later called with the same arguments, the stored result is
    returned rather than computing the result again.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the Y-combinator is much faster than recursion, it is still relatively
    slow. To speed it up, we can create a memoizing fixed-point combinator: a Y-like
    combinator that caches the results of intermediate function calls.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: So how much faster is it? By using [http://jsperf.com/](http://jsperf.com/),
    we can compare the performance.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'The following results are with random numbers between 1 and 100\. We can see
    that the memoizing Y-combinator is much, much faster. And adding trampolining
    to it does not slow it down by much. You can view the results and run the tests
    yourself at this URL: [http://jsperf.com/memoizing-y-combinator-vs-tail-call-optimization/7](http://jsperf.com/memoizing-y-combinator-vs-tail-call-optimization/7).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '![Memoization](../images/00010.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: 'The bottom line is: the most efficient and safest method of performing recursion
    in JavaScript is to use the memoizing Y-combinator with tail-call elimination
    via trampolining and thunks.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Variable scope
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The scope of variables in JavaScript is not natural. In fact, sometimes it's
    downright counter-intuitive. They say that JavaScript programmers can be judged
    by how well they understand scope.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Scope resolutions
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, let's go over the different scope resolutions in JavaScript.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript uses scope chains to establish the scope of variables. When resolving
    a variable, it starts at the innermost scope and searches outwards.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Global scope
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Variables, functions, and objects defined at this level are available to any
    code in the entire program. This is the outermost scope.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Local scope
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each function described has its own local scope. Any function defined within
    another function has a nested local scope that is linked to the outer function.
    Almost always, it's the position in the source that defines the scope.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Local scope is only for functions and not for any expression statements (`if`,
    `for`, `while`, and so on), which is different from how most languages treat scope.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In functional programming, this isn''t as much of a concern because functions
    are used more often and expression statements less often. For example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Object properties
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Object properties have their own scope chains as well.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The object's prototype is further down the scope chain.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This isn't even close to being comprehensive, but these three types of scope
    are enough to get started.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One problem with this scope structure is that it leaves no room for private
    variables. Consider the following code snippet:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: These variables and functions are global, which means it would be too easy for
    code later down the program to accidentally overwrite them. One solution would
    be to encapsulate them into a function and call that function immediately after
    defining it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Nothing is happening outside the function, so we ought to discard the function
    name by making it anonymous.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To make the functions `getValue()` and `updateMillage()` available outside
    the anonymous function, we''ll need to return them in an object literal as shown
    in the following code snippet:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This gives us pseudo-private variables, but the problems don't stop there. The
    following section explores more issues with variable scope in JavaScript.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Gotchas
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many variable scope nuances can be found throughout JavaScript. The following
    is by no means a comprehensive list, but it covers the most common cases:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'The following will output 4, not ''undefined'' as one would expect:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This is due to the fact that, in JavaScript, variable definition happens at
    the beginning of the corresponding scope, not just when it is declared.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'If you define a variable in the outer scope, and then have an `if` statement
    define a variable inside the function with the same name, even if that `if` branch
    isn''t reached, it is redefined. An example:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Again, this is caused by moving the variable definition at the beginning of
    the scope with the `undefined` value.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: In the browser, global variables are really stored in the `window` object.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`a` in the global scope means `a` as an attribute of the current context, so
    `a===this.a` and `window` object in a browser act as an equivalent of the `this`
    keyword in the global scope.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: The first two examples are a result of a feature of JavaScript known as hoisting,
    which will be a critical concept in the next section about writing functions.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Function declarations versus function expressions versus the function constructor
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between these three statements?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: At first glance, they're merely different ways to write the same function. But
    there's a little more going on here. And if we're to take full advantage of functions
    in JavaScript in order to manipulate them into a functional programming style,
    then we'd better be able to get this right. If there is a better way to do something
    in computer programming, then that one way should be the only way.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Function declarations
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Function declarations, sometimes called function statements, define a function
    by using the `function` keyword.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Functions that are declared with this syntax are *hoisted* to the top of the
    current scope. What this actually means is that, even if the function is defined
    several lines down, JavaScript knows about it and can use it earlier in the scope.
    For example, the following will correctly print 6 to the console:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Function expressions
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Named functions can also be defined as an expression by defining an anonymous
    function and assigning it to a variable.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'They are not hoisted like function declarations are. This is because, while
    function declarations are hoisted, variable declarations are not. For example,
    this will not work and will throw an error:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In functional programming, we're going to want to use function expressions so
    we can treat the functions like variables, making them available to be used as
    callbacks and arguments to higher-order functions such as `map()` functions. Defining
    functions as expressions makes it more obvious that they're variables assigned
    to a function. Also, if we're going to write functions in one style, we should
    write all functions in that style for the sake of consistency and clarity.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: The function constructor
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript actually has a third way to create functions: with the `Function()`
    constructor. Just like function expressions, functions defined with the `Function()`
    constructor are not hoisted.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'But the `Function()` constructor is not only confusing, it is also highly dangerous.
    No syntax correction can happen, no optimization is possible. It''s far easier,
    safer, and less confusing to write the same function as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Unpredictable behavior
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So the difference is that function declarations are hoisted while function
    expressions are not. This can cause unexpected things to happen. Consider the
    following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: What's actually printed to the console is `hello`. This is due to the fact that
    the second definition of the `foo()` function is hoisted to the top, making it
    the definition that is actually used by the JavaScript interpreter.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'While at first this may not seem like a critical difference, in functional
    programming this can cause mayhem. Consider the following code snippet:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: When the `foo()` function is called, `two` is printed to the console, not `one`!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, there is a way to combine both function expressions and declarations.
    It works as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'It makes very little sense to use this method because the name used in the
    declaration (the `bar()` function in the preceding example) is not available outside
    the function and causes confusion. It would only be appropriate for recursion,
    for example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript has been called the "assembly language of the web," because it's
    as ubiquitous and unavoidable as x86 assembly. It's the only language that runs
    on all browsers. It's also flawed, yet referring to it as a low-level language
    is missing the mark.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Instead, think of JavaScript as the raw coffee beans of the web. Sure, some
    of the beans are damaged and a few are rotten. But if the good ones are selected,
    roasted, and brewed by a skilled barista, the beans can be transformed into a
    brilliant jamocha that cannot be had just once and forgotten. It's consumption
    becomes a daily custom, life without it would be static, harder to perform, and
    much less exciting. Some even prefer to enhance the brew with plug-ins and add-ons
    such as cream, sugar, and cocoa, which complement it very well.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，把JavaScript看作是网络的生咖啡豆。当然，有些豆子是受损的，有些是腐烂的。但是如果选择好豆子，由熟练的咖啡师烘焙和冲泡，这些豆子就可以变成一杯绝妙的摩卡咖啡，一次就无法忘怀。它的消费变成了日常习惯，没有它的生活会变得单调，更难以进行，也不那么令人兴奋。一些人甚至喜欢用插件和附加组件来增强这种咖啡，比如奶油、糖和可可，这些都很好地补充了它。
- en: One of JavaScript's biggest critics, Douglas Crawford, was quoted as saying
    "There are certainly a lot of people who refuse to consider the possibility that
    JavaScript got anything right. I used to be one of those guys. But now I continue
    to be amazed by the brilliance that is in there".
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript最大的批评者之一道格拉斯·克劳福德曾说过：“肯定有很多人拒绝考虑JavaScript可能做对了什么。我曾经也是那些人之一。但现在我对其中的才华仍然感到惊讶。”
- en: JavaScript turned out to be pretty awesome.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript最终变得非常棒。
