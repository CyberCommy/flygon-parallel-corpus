- en: Creating Custom Operators in RxCpp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the last three chapters, we learned about the RxCpp library and its programming
    model. We also applied what we learned, in the context of GUI programming. From
    a mental model perspective, any developer who wants to write programs in a reactive
    manner has to understand Observable, Observer, and the operators that work between
    them. Of course, Schedulers and Subjects are important as well. The bulk of the
    logic of reactive programs resides in operators. The RxCpp library provides a
    lot of built-in (stock) operators as part of its implementation. We have already
    used some of them in our programs. In this chapter, we will learn how we can implement
    custom operators. To write custom operators, we need to delve deep into some advanced
    topics related to the RxCpp library. The topics covered in this chapter are the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Philosophy of Rx operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chaining stock operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing basic RxCpp operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing different genres of custom operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom operators using the `lift<T>` meta operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding operators to the RxCpp library source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Philosophy of Rx operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you take any reactive program, we see a chain of operators stacked between
    the Observable and the Observer. The developers use a fluent interface to chain
    operators. In RxCpp, one can use a dot (`.`) or pipe (`|`) to perform the operator
    chaining. From a software interface point of view, every operator takes an Observable
    and returns an Observable of the same kind or a different kind.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general usage of an RxCpp Observable/Observer interaction (given as pseudo-code)
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Even though we are using fluent interfaces when it comes to operator chaining,
    we are effectively composing functions together. To compose functions together,
    the return value of a function should be type compatible with the parameter of
    the function that comes in the composition chain.
  prefs: []
  type: TYPE_NORMAL
- en: An operator takes an Observable as a parameter and returns another Observable.
    There are some cases where it returns a value other than the Observable. Only
    those operators that return an Observable can be part of a process called operator
    chaining.
  prefs: []
  type: TYPE_NORMAL
- en: To write a new operator that can be part of the operator chaining method, the
    best way is to add them as a method of the `observable<T>` type. However, writing
    a production-quality operator that can run in different contexts is best left
    to experts in RxCpp internals. Another option is to use the `lift<t>` (`...`)
    operator available in the RxCpp library. We will cover both these strategies in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Another very important property that every operator implementation should have
    is that they should be side effect-free. At least, they should not mutate contents
    of the input Observable. In other words, the function or functor that acts as
    an operator should be a pure function.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining stock operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already learned that RxCpp operators operate on Observables (received
    as input) and return Observables. This allows these operators to be invoked one
    after the other using operator chaining. Each individual operator in the chain
    transforms elements in the stream received from the previous operator. The source
    stream is not mutated in the process. We use the fluent interface syntax when
    chaining operators.
  prefs: []
  type: TYPE_NORMAL
- en: Developers usually use the fluent interface in the context of the consumption
    of classes that implement the GOF Builder pattern. Builder pattern implementations
    are implemented in an order-independent manner. Even though the syntax of operator
    chaining is similar, the order in which operators are invoked does matter in the
    reactive world.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a simple program that will help us understand the significance
    of the order of execution in Observable operator chaining. In this particular
    example, we have an Observable stream where we apply the map operator twice: once
    to find out the square, and then to find two instances of a value. We apply the
    square function first, followed by the twice function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding program will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s reverse the order of application (scaling by `2`, twice, followed
    by the square of the argument), and then peruse the output to see that we will
    get a different output (in the first case, square was applied first, then scaling
    by `2`). The following program will explain the order of execution, if we compare
    the output generated by the program with the previous program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output produced by the program is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In C++, we can compose functions together very well because of Lambda functions
    and the lazy evaluation of Lambda functions. The RxCpp library exploits this fact
    while implementing operators. If there are three functions (`F`, `G`, `H` ) that
    take `observable<T>` as the input parameter and return `observable<T>`, we can
    compose them symbolically as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we are using operator chaining, this can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We have now learned that operator chaining is effectively doing operator composition.
    Both produce similar results, but operator chaining is more readable and intuitive.
    One purpose of this section is to establish the fact that operator composition
    and operator chaining provide similar functionality. The operators that we implement
    initially can be composed together (cannot be chained) and we will learn how to
    create operators that are amenable to operator chaining.
  prefs: []
  type: TYPE_NORMAL
- en: Writing basic RxCpp custom operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we covered the topic of operator chaining. Operator
    chaining was possible because, the stock operators are implemented as part of
    the `observable<T>` type. The operators that we are going to implement initially
    cannot be part of the operator chaining strategy. In this section, we will implement
    some RxCpp operators that can transform an Observable and return another Observable.
  prefs: []
  type: TYPE_NORMAL
- en: Writing an RxCpp operator as a function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To kickstart the discussion, let''s write a simple operator that works on observable<string>.
    The operator just prepends the literal text `Hello` before each item in the stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The custom operator that we have implemented is written to demonstrate how
    you can write an operator that can work on an Observable. The operator written
    has to be invoked using the function semantics, and the implementation is not
    fit for operator chaining. Now that we have implemented an operator, let''s write
    a main function to test how the operator works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The program will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Writing an RxCpp operator as a Lambda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have written our first custom operator as a `unary` function. All operators
    are `unary` functions that take Observables as a parameter. The function took
    `observable<string>` as a parameter and returned another `observable<string>`.
    We can achieve the same effect by writing an operator (inline) as a Lambda. Let''s
    see how it can be done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the program is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The output shows that the program behavior is identical whether one uses an
    ordinary function or the Lambda function. The advantage of the Lambda function
    is the call site creation and consumption of functions.
  prefs: []
  type: TYPE_NORMAL
- en: Composing custom RxCpp operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already learned about function-composition in this book ([Chapter 2](e1c95513-a3a7-40f2-ac25-9f95cbd9a2e6.xhtml)*, A
    Tour of Modern C++ and Its Key Idioms*). Function composition is possible when
    the return value of a function is type compatible with the input parameter of
    another function. In the case of operators, since most of them return Observables
    and take Observables as a parameter, they are compatible for function composition.
    In this section, our operators are compatible for composition, but they cannot
    be chained yet. Let''s see how we can compose operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the program is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Different genres of custom operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The RxCpp library contains different genres of operators as part of the stock
    offering. The default collection of RxCpp operators is enough for most applications.
    The different genres of available operators are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Creation operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transformation operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error-handling operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utility operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mathematical operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The classification of operators gives developers a nice framework for choosing
    the appropriate operator for the context. In this section, we will implement the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Custom creational operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom transformation operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom operations that involve Schedulers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a custom creational operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The majority of RxCpp operator functions accept Observables and return an Observable
    to achieve composition of operators. We need to do some extra work to make the
    composition in a chainable fashion (in the next section, we will cover `lift<t>`
    and the topic of adding operators to the `[observable<T>]` Observable in the `RxCpp`
    library). The operators we implement in this section will help us create an Observable
    from the input data. We can create an Observable stream of any type,from individual
    value of the type, from a range of values, from an iterator to a STL container,
    from another Observable, and so on. Let''s discuss an example program that accepts
    an STL container and creates an Observable, followed by some transformations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `helloNames()` function accepts any standard library container and creates
    an Observable of the type string (`observable<string>`). The Observable is then
    filtered to get items longer than five characters to prepend the `Hello` string to
    each item. The exceptions that occur will be translated by the use of the standard
    RxCpp operator, `on_error_resume_next()`: Now, let''s write the main program to
    see how this operator can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The list of names is passed as an argument into the newly defined operator
    and we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Writing a custom transformation operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s write a simple program to implement a custom operator by combining other
    operators, where we filter stream of numbers for odd numbers, transform numbers
    into its square, and take only first three elements from the stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the custom operator is implemented with a different approach.
    Instead of returning a simple Observable of the desired type, the operator function
    returns a function object that takes and returns an Observable of the *int* type.
    This allows the user to perform the execution of higher-order functions using
    the pipe (`|`) operator. The ability to implement custom operators using user-defined
    transformations and combining them with existing operators comes in very handy
    when writing nontrivial programs. It is usually better to compose new operators
    by combining existing ones rather than implementing a new operator from the scratch
    (do not re-invent the wheel!).
  prefs: []
  type: TYPE_NORMAL
- en: Writing a custom operator that involves Schedulers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The RxCpp library is single-threaded by default, and RxCpp will schedule execution
    in the thread where we called the subscriber method. There are some operators
    that take a Scheduler as a parameter, where execution can happen in the thread
    managed by the Scheduler. Let''s write a program to implement a custom operator
    to work with a Scheduler parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Writing custom operators that can be chained
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the key benefits of built-in operators provided by the RxCpp library
    is the possibility to chain operators using fluent interfaces. This significantly
    improves code readability. The custom operators that we''ve created so far can
    be composed together, but cannot be chained together in the way the standard operator
    can be chained. In this section, we will implement operators that can be chained
    by using the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `lift<T>` meta operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a new operator by adding code to the RxCpp library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the lift<t> operator to write a custom operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The RxCpp library has an operator as part of the `observable<T>` implementation,
    called `lift` (`lift<t>`). In fact, it can be called a meta-operator as it has
    the capability to convert a `unary` function or functor that takes an ordinary
    variable (`int`, `float`, `double`, `struct`, and so on) to be compatible for
    processing `observable<T>` Streams. The RxCpp implementation of `observable<T>::lift`
    expects a Lambda that takes `rxcpp::subscriber<T>` as a parameter, and within
    the body of the Lambda, we can apply an action (a Lambda or a function). In this
    section, one can get an overview of the purpose of the `lift<t>` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lift operator takes any function or Lambda that will take a Subscriber
    for an Observable and produce a new Subscriber. This is intended to allow externally-defined
    operators that use `make_subscriber` to be connected into the composition chain.
    The function prototype of the lift is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The signature and body of the Lambda expected by `lift<t>` is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: To understand the workings of the `lift<T>` operator, let's write a program
    that uses it. The advantage of `lift<T>` is that the operator created can be part
    of the operator chaining infrastructure of the RxCpp library.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We have now learned how we can use the `lift<t>` operator. The `observable<T>`
    instance and its lift method take a Lambda with a specific parameter type and
    produce an `observable<T>`. The advantage of `lift<T>` is that we can use operator
    chaining.
  prefs: []
  type: TYPE_NORMAL
- en: Converting an arbitrary Lambda to a custom Rx operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we learned that it is possible to use the `lift<t>`
    operator to implement custom operators that can be part of the operator chaining
    infrastructure of the RxCpp library. The workings of `lift<T>` are a bit complicated
    and we will write an `Adapter` class to convert an arbitrary Lambda that takes
    a parameter (of the basic types) to a form where the `lift<T>` operator can be
    applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'The adapter code will help us to make calls such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write an `Adapter` class implementation and a generic function wrapper
    on top of it to be consumed in a program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In RxCpp operator implementations, we will have an internal Observer that intercepts
    the traffic and applies some logic on items, before passing on the control to
    the next operator in the chain. The `action_observer` class is structured along
    those lines. Since we are using Lambdas (lazy evaluation), the execution will
    happen only when the Scheduler triggers the execution, whenever data is received
    in the pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have learned how to implement an `Adapter` class to convert a Lambda
    into a form that `lift<T>` can accept, let''s write a program that demonstrates
    how we can leverage the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the program is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Creating a custom RxCpp operator in the library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every operator in the `RxCpp` library is defined under `rxcpp::operators` namespaces.
    Within the `rxcpp::operators` namespace, library designers have created a nested
    namespace called details, where implementations of the operator logic are typically
    specified. To demonstrate the implementation of an operator from scratch, we have
    cloned the implementation of the map operator to create another operator, by the
    name of `eval`. The semantics of `eval` are the same as those of the `map` operator.
    The source code listing is available in a folder related to this particular chapter
    in the GitHub repository associated with this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'We decided to move the book''s code to the GitHub repository because the listing
    is a bit long and doesn''t contribute much to the conceptual understanding of
    the implementation of an operator in the `RxCpp` library. The `liftaction` implementation
    outlined earlier shows us how to write an internal Observer. There is a standard
    pattern that every operator implementation follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It subscribes to the source Observable by creating a private Observer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It transforms elements of the Observable according to the purpose of the operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It pushes the transformed value to its own subscribers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The skeleton source listing of the `eval` operator implementation is given
    here. The implementation of the source file contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Source file ** | **Key changes** |'
  prefs: []
  type: TYPE_TB
- en: '| `rx-eval.hpp` | Implementation of the `eval` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `rx-includes.h` | Modified header files with the inclusion of `Rx-eval.hpp`.`rx-includes.h`
    will add an additional entry into the file, which goes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `rx-operators.h` | Modified header file with the `eval_tag` definition. `rx-operators.h`
    contains the following tag entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `rx-observables.h` | Modified header file with the definition of the `eval`
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a program to use the `eval` operator. The prototype for the `eval`
    operator (like `map`) is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check the source code of the implementation to better understand the
    `eval` operator. Now, let''s write a program that leverages the `eval` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the program is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: To write custom operators that are implemented in a generic manner requires
    deep expertise in RxCpp internals. You need to understand the implementation of
    some stock operators before attempting a custom operator. The operator we wrote
    can be a starting point for you to implement such operators. Once again, writing
    custom operators from scratch should be a last resort!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to write custom operators. We started by writing
    simple operators that can perform basic tasks. Even though the operators we wrote
    (initially) were composable, we were not able to chain them together like standard
    RxCpp operators. After writing different genres of operators, we implemented chainable
    custom operators using the `lift<T>` meta operator. Finally, we saw how we can
    add an operator to `observable<T>` as well. In the next chapter, we'll delve into
    the world of design patterns and idioms for Rx programming. We'll start with GOF
    design patterns and implement different reactive programming patterns.
  prefs: []
  type: TYPE_NORMAL
