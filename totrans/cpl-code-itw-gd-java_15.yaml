- en: '*Chapter 12*:'
  prefs: []
  type: TYPE_NORMAL
- en: Stacks and Queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers the most popular interview coding challenges involving stacks
    and queues. Mainly, you will learn how to provide a stack/queue implementation
    from scratch and how to tackle coding challenges via Java's built-in implementations,
    such as the `Stack` class, and the `Queue` interface implementations, especially
    `ArrayDeque`. Commonly, a coding challenge from this category will ask you to
    build a stack/queue or will ask you to solve a certain problem using Java's built-in
    implementations. Depending on the problem, it may explicitly disallow you to call
    certain built-in methods that will lead you to finding an easy solution.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you'll have a deep insight into stacks and queues,
    you'll be able to exploit their capabilities, and also recognize and write solutions
    that depend on stacks and queues.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you''ll learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Stacks in a nutshell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queues in a nutshell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding challenges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by briefly covering the data structures of stacks.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code files presented in this chapter are available on GitHub at [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter12](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter12).
  prefs: []
  type: TYPE_NORMAL
- en: Stacks in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A stack is a linear data structure that uses the **Last-In-First-Out** (**LIFO**)
    principle. Think of a stack of plates that needs to be washed. You take the first
    plate from the top (which was the last one to be added) and you wash it. Afterward,
    you take the next plate from the top and so on. This is exactly what a real-life
    stack is (for example, a stack of plates, a stack of books, a stack of CDs, and
    so on).
  prefs: []
  type: TYPE_NORMAL
- en: So, technically speaking, in a stack, the elements are only added (known as
    the **push** operation) and removed (known as the **pop** operation) to/from one
    end of it (known as the **top**).
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common operations that are performed in a stack are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`push(E e)`: Adds an element to the top of the stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`E pop()`: Removes the top element from the stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`E peek()`: Returns (but doesn''t remove) the top element from the stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean isEmpty()`: Returns `true` if the stack is empty'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int size()`: Returns the size of the stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean isFull()`: Returns `true` if the stack is full'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unlike an array, a stack does not provide access to the *n*th element in constant
    time. However, it does provide constant time for adding and removing elements.
    A stack can be implemented on top of an array or even on top of a linked list.
    The implementation that''s being used here is based on an array and is named `MyStack`.
    The stub of this implementation is listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Pushing an element into a stack means adding that element to the end of the
    underlying array. Before pushing an element, we have to ensure that the stack
    is not full. If it is full, then we can signal this via a message/exception, or
    we can increase its capacity, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, every time we reach the stack''s capacity, we double its size.
    Popping an element from the stack means that we return the element that was last
    added to the underlying array. This element is removed from the underlying array
    by nullifying the last index, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Peeking an element from a stack means returning the element that was added
    last to the underlying array but without removing it from this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Since this implementation can represent the coding challenge you may face in
    an interview, it is advised that you take your time and dissect its code. The
    complete application is called *MyStack*.
  prefs: []
  type: TYPE_NORMAL
- en: Queues in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A queue is a linear data structure that uses the **First-In-First-Out** (**FIFO**)
    principle. Think of people standing in a queue to buy stuff. You can also imagine
    ants that are walking in a queue formation.
  prefs: []
  type: TYPE_NORMAL
- en: So, technically speaking, the elements are removed from the queue in the same
    order that they are added. In a queue, the elements added at one end referred
    to as the rear (this operation is known as the enqueue operation) and removed
    from the other end referred to as the front (this operation is known as the dequeue
    or poll operation).
  prefs: []
  type: TYPE_NORMAL
- en: 'The common operations in a queue are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`enqueue(E e)`: Adds an element to the rear of the queue'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`E dequeue()`: Removes and returns the element from the front of the queue'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`E peek()`: Returns (but doesn''t remove) the element from the front of the
    queue'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean isEmpty()`: Returns `true` if the queue is empty'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int size()`: Returns the size of the queue'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean isFull()` : Returns `true` if the queue is full'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unlike an array, a queue does not provide access to the *n*th element in constant
    time. However, it does provide constant time for adding and removing elements.
    A queue can be implemented on top of an array or even on top of a linked list
    or a stack (which is built on top of an array or a linked list). The implementation
    used here is based on an array and is named `MyQueue`. The stub of this implementation
    is listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Enqueuing an element into a queue means adding this element to the end of the
    underlying array. Before enqueuing an element, we have to ensure that the queue
    is not full. If it is full, then we can signal this via a message/exception, or
    we can increase its capacity, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Dequeuing an element from a queue means returning the next element from the
    beginning of the underlying array. This element is removed from the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Peeking an element from a queue means returning the next element from the beginning
    of the underlying array without removing it from the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Since this implementation can represent the coding challenge you may face in
    an interview, it is advised that you take your time and dissect its code. The
    complete application is called *MyQueue*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the next 11 coding challenges, we will cover the most popular problems involving
    stacks and queues that have appeared in interviews in the past few years in a
    wide range of companies that hire Java developers. One of the most common problems,
    *Implementing three stacks with one array*, was covered in [*Chapter 10*](B15403_10_Final_JM_ePub.xhtml#_idTextAnchor217)*,
    Arrays and Strings*.
  prefs: []
  type: TYPE_NORMAL
- en: The solutions to the following coding challenges rely on the Java built-in `Stack`
    and `ArrayDeque` APIs. So, let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 1 – Reverse string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given a string. Use a stack to reverse it.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Reversing a string using a stack can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Loop the string from left to right and push each character into the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Loop the stack and pop the characters one by one. Each popped character is put
    back into the string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code based on these two steps is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *StackReverseString*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 2 – Stack of curly braces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '`String` containing curly braces. Write a snippet of code that returns `true`
    if there are matching pairs of curly braces. If we can find a closing curly brace
    for an opening one in the proper order, then we can say that we have a matching
    pair. For example, a string containing matching pairs looks like this: {{{}}}{}{{}}.'
  prefs: []
  type: TYPE_NORMAL
- en: '`false`. Second, if their number is equal, then they must be in the proper
    order; otherwise, we return `false`. By the proper order, we understand that the
    last opened curly brace is the first one to be closed, the one prior to the last
    is the second to be closed, and so on. If we rely on a stack, then we can elaborate
    on the following algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For each character of the given string, take one of the following decisions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. If the character is an opening curly brace, {, then put it on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'b. If the character is a closing curly brace, }, then do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: i. Check the top of stack, and if it is {, pop and move it to the next character.
  prefs: []
  type: TYPE_NORMAL
- en: ii. If it is not {, then return `false`.
  prefs: []
  type: TYPE_NORMAL
- en: If the stack is empty, return `true` (we found all pairs); otherwise, return
    `false` (the stack contains curly braces that do not match).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Putting these steps into code results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *StackBraces*. Challenge yourself by implementing
    a similar problem but for multiple types of parentheses (for example, allow ()
    {} [] in the same given string).
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 3 – Stack of plates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '`push()` and `pop()` methods will work like there is a single stack. Additionally,
    write a `popAt(int stackIndex)` method that pops a value from the stack, as indicated
    via `stackIndex`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: We know how to deal with a single stack, but how do we link multiple
    stacks together? Well, since we have to *link*, how about a linked list? If the
    linked list contains a stack in each node, then the next pointer of a node will
    point to the next stack. The following diagram visualizes this solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Linked list of stacks'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.1_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.1 – Linked list of stacks
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever the current stack capacity is exceeded, we create a new node and append
    it to the linked list. Java''s built-in linked list (`LinkedList`) gives us access
    to the last node via the `getLast()` method. In other words, via `LinkedList#getLast()`,
    we can easily operate on the current stack (for example, we can push or pop an
    element). Adding a new stack is quite simple via the `LinkedList#add()` method.
    Based on these statements, we can implement the `push()` method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to pop an element, then we have to do so from the last stack, so
    `LinkedList#getLast()` is very handy here. The corner-case here is represented
    by the moment we pop the last element from the last stack. When this happens,
    we must remove the last stack, in which case the one before the last (if any)
    will become the last. The following code speaks for itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s focus on implementing the `popAt(int stackIndex)` method. We
    can pop from the `stackIndex` stack by simply calling `stacks.get(stackIndex).pop()`.
    Once we''ve popped an element, we must shift the remaining elements. The bottom
    element of the next stack will become the top element of the stack being pointed
    to by `stackIndex` and so on. If the last stack contains a single element, then
    shifting the other elements will eliminate the last stack, and the one before
    it will become the last. Let''s see this in terms of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *StackOfPlates*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 4 – Stock span
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given an array of prices of a single stock
    for multiple consecutive days. A stock span is represented by the number of consecutive
    days prior to the current day (today) when the price of a stock was less than
    or equal to the price of the current day. For example, consider the prices of
    a stock covering 10 days; that is, {55, 34, 22, 23, 27, 88, 70, 42, 51, 100}.
    The resulting stock span is {1, 1, 1, 2, 3, 6, 1, 1, 2, 10}. Notice that, for
    the first day, the stock span is always 1\. Write a snippet of code that computes
    the stock span for the given list of prices.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: We can start from the given example and try to visualize it,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – Stock span for 10 days'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.2_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.2 – Stock span for 10 days
  prefs: []
  type: TYPE_NORMAL
- en: 'From the preceding figure, we can observe the following:'
  prefs: []
  type: TYPE_NORMAL
- en: For the first day, the span is always 1\.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For day 2, the price is 34\. Since 34 is less than the price of the prior day
    (55), the stock span of day 2 is also 1\.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For day 3, the price is 22\. Since 22 is less than the price of the prior day
    (34), the stock span of day 3 is also 1\. Days 7 and 8 fall under the same scenario.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For day 4, the price is 23\. Since 23 is greater than the price of the prior
    day (22), but is less than the price of day 2, the stock span is 2\. Day 9 is
    similar to day 4\.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For day 5, the price is 27\. Since this price is greater than the prices of
    days 3 and 4 but less than the price of day 2, the stock span is 3.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For day 6, the price is 88\. This is the biggest price so far, so the stock
    span is 6.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For day 10, the price is 100\. This is the biggest price so far, so the stock
    span is 10.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Notice that we compute the stock span of the current day as the difference
    between the index of the current day and the index of the day corresponding to
    the last biggest stock price. After tracking this scenario, the first idea that
    we have may sound like this: for each day, scan all days prior to it and increment
    the stock span until the price of the stock is bigger than the current day. In
    other words, we are using the brute-force approach. As I mentioned earlier in
    this book, the brute-force approach should be used as a last resort in an interview
    since it has a poor performance and the interviewers won''t be impressed. In this
    case, the brute-force approach works in O(n2) complexity time.'
  prefs: []
  type: TYPE_NORMAL
- en: However, let's try another perspective of thought. For each day, we want to
    find a prior day that has a bigger price than the current day. In other words,
    we are looking for the last price that is bigger than the price of the current
    day.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we should choose a LIFO data structure that allows us to push the prices
    in descending order and pop the last pushed price. Once we have this in place,
    we can go through each day and compare the price at the top of the stack with
    the current day's price. Until the price on top of the stack is less than the
    current day's price, we can pop from the stack. But if the price at the top of
    the stack is bigger than the price of the current day, then we compute the stock
    span of the current day as the difference in days between the current day and
    the day for the price on top of the stack. This will work if we push the prices
    into the stack in descending order – the biggest price is at the top of the stack.
    However, since we can compute the stock span as the difference between the index
    of the current day and the index of the day corresponding to the last biggest
    stock price (let's denote it with `i`), we can simply store the `i` index in the
    stack; `stackPrices[i]` (let's denote the prices array as `stackPrices`) will
    return the price of the stock on the *i*th day.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be accomplished by the following algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: The first day has a stock span of 1 and an index of 0 – we push this index into
    the stack (let's denote it as `dayStack`; therefore, `dayStack.push(0)`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We loop the remaining days (day 2 has index 1, day 3 has index 2, and so on)
    and do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. While `stockPrices[i] > stockPrices[dayStack.peek()]` and `!dayStack.empty()`,
    we pop from the stack (`dayStack.pop()`).
  prefs: []
  type: TYPE_NORMAL
- en: If `dayStack.empty()`, then the stock span in `i+1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `stockPrices[i] <= stockPrices[dayStack.peek()]`, then the stock span is
    `i - dayStack.peek()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push the index of the current day, `i`, into the stack (`dayStack`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s see how this algorithm works for our test case:'
  prefs: []
  type: TYPE_NORMAL
- en: The first day has a stock span of 1 and an index of 0 – we push this index into
    the stack, `dayStack.push(0)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the second day, `stockPrices[1]=34` and `stockPrices[0]=55`. Since 34 <
    55, the stock span of day 2 is `i - dayStack.peek()` = 1 - 0 = 1\. We push in
    stack 1, `dayStack.push(1)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the third day, `stockPrices[2]`=22 and `stockPrices[1]`=34\. Since 22 <
    34, the stock span of day 3 is 2 - 1 = 1\. We push in stack 1, `dayStack.push(2`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the fourth day, `stockPrices[3]`=23 and `stockPrices[2]`=22\. Since 23 >
    22 and the stack is not empty, we pop the top, so we pop the value 2\. Since 23
    < 34 (`stockPrices[1]`), the stock span of day 4 is 3 - 1 = 2\. We push in stack
    3, `dayStack.push(3)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the fifth day, `stockPrices[4]`=27 and `stockPrices[3]`=23\. Since 27 >
    23 and the stack is not empty, we pop the top, so we pop the value 3\. Next, 27
    < 34 (remember that we popped the value 2 in the previous step, so the next top
    has the value 1), and the stock span of day 5 is 4 - 1 = 3\. We push in stack
    4, `dayStack.push(4)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the sixth day, `stockPrices[5]`=88 and `stockPrices[4]`=27\. Since 88 >
    27 and the stack is not empty, we pop the top, so we pop the value 4\. Next, 88
    > 34 and the stack is not empty, so we pop the value 1\. Next, 88 > 55 and the
    stack is not empty, so we pop the value 0\. Next, the stack is empty and the stock
    span of day 6 is 5 + 1 = 6\.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Well, I think you got the idea, so now, challenge yourself and continue until
    day 10\. For now, we have enough information to put this algorithm into code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *StockSpan*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 5 – Stack min
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '`push()`, `pop()`, and `min()` methods should operate in O(1) time.'
  prefs: []
  type: TYPE_NORMAL
- en: '`push()` and `pop()` to run in O(1) time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution that respects the problem''s constraints requires an additional
    stack for tracking the minimum. Mainly, when the pushed value is smaller than
    the current minimum, we add this value to the auxiliary stack (let''s denote it
    as `stackOfMin`) and the original stack. If the value that''s popped from the
    original stack is the top of `stackOfMin`, then we pop it from `stackOfMin` as
    well. In terms of code, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Done! Our solution performed in O(1) complexity time. The complete application
    is called *MinStackConstantTime*. A problem related to this one requires you to
    implement the same functionality in constant time and space. The solution to this
    problem imposes several restrictions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `pop()` method returns `void` to avoid returning incorrect values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The given value multiplied by 2 should not exceed the `int` data type domain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In short, these restrictions are caused by the solution itself. We cannot use
    extra space; therefore, we will use the initial stack of values to store the minimum
    as well. Moreover, we need to multiply the given value by 2, so we should ensure
    that the `int` domain is not exceeded. Why do we need to multiply the given value
    by 2?
  prefs: []
  type: TYPE_NORMAL
- en: Let's bring some light to this subject! Let's assume that we need to push a
    value into a stack that has a certain minimum value. If this value is bigger than
    or equal to the current minimum value, then we can simply push it into the stack.
    But if it is smaller than the minimum, then we push 2**value-minimum*, which should
    be smaller than the value itself. Then, we update the current minimum as value.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we pop a value, we have to consider two aspects. If the popped value is
    bigger or equal to the minimum, then this is the real value that was pushed earlier.
    Otherwise, the popped value is not the pushed value. The real pushed value is
    stored in the minimum. After we pop the top of the stack (the minimum value),
    we have to restore the previous minimum. The previous minimum is obtained as 2**minimum
    - top.* In other words, since the current top is 2**value - previous_minimum*
    and the value is the current minimum, the previous minimum is 2**current_minimum
    - top*. The following code illustrates this algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *MinStackConstantTimeAndSpace*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 6 – Queue via stacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Google**, **Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Design a queue via two stacks.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: In order to find the proper solution to this problem, we must
    start from the main difference between a queue and a stack. We know that a queue
    works on FIFO, while a stack works on LIFO. Next, we have to think of the main
    operations (push, pop, and peek) and identify the differences.'
  prefs: []
  type: TYPE_NORMAL
- en: Both of them push new elements in the same way. When we push an element into
    a queue, we push it at one end (the rear of the queue). When we push an element
    into a stack, we push it from the new top of the stack, which can be considered
    the same as the rear of the queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we pop or peek a value from a stack, we do so from the top. However, when
    we perform the same operations on a queue, we do so from the front. This means
    that, while popping or peeking an element, a reversed stack will act as a queue.
    The following diagram exemplifies this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Queue via two stacks'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.3_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.3 – Queue via two stacks
  prefs: []
  type: TYPE_NORMAL
- en: So, each new element is pushed into the *enqueue stack* as the new top. When
    we need to pop or peek a value, we use the *dequeue* stack, which is the reversed
    version of the *enqueue stack*. Notice that we don't have to reverse the *enqueue
    stack* at each pop/peek operation. We can let the elements sit in the *dequeue
    stack* until we absolutely must reverse the elements. In other words, for each
    pop/peek operation, we can check if the *dequeue stack* is empty. As long as the
    *dequeue stack* is not empty, we don't need to reverse the *enqueue stack* because
    we have at least one element to pop/peek.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see this in terms of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *QueueViaStack*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 7 – Stack via queues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Google**, **Adobe**, **Microsoft**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Design a stack via two queues.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: In order to find the proper solution to this problem, we must
    start from the main difference between a stack and a queue. We know that a stack
    is a LIFO, while a queue is a FIFO. Next, we have to think of the main operations
    (push, pop, and peek) and identify the differences.'
  prefs: []
  type: TYPE_NORMAL
- en: Both of them push new elements in the same way. When we push an element into
    a stack, we push it from the new top of the stack. When we push an element into
    a queue, we push it from one end (the rear of the queue). The rear of the queue
    is like the top of the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we pop or peek a value from a queue, we do so from the front. However,
    when we perform the same operations on a stack, we do so from the top. This means
    that, while popping or peeking an element from a queue that acts as a stack, we
    need to poll all the elements except the last one. The last element is the one
    that we pop/peek. The following diagram exemplifies this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4 – Stack via two queues'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.4_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.4 – Stack via two queues
  prefs: []
  type: TYPE_NORMAL
- en: As the left-hand side of the preceding diagram reveals, pushing an element into
    a stack and a queue is a simple operation. The right-hand side of the preceding
    diagram shows that problems occur when we want to pop/peek an element from the
    queue that acts as a stack. Mainly, before popping/peeking an element, we have
    to move the elements from the queue (denoted in the preceding diagram as *queue1*)
    between (*rear*-1) and *front* into another queue (denoted in the preceding diagram
    as *queue2*). In the preceding diagram, on the right-hand side, we poll the elements
    2, 5, 3, and 1 from *queue1* and add them to *queue2*. Next, we pop/peek the last
    element from *queue1*. If we pop element 6, then *queue1* remains empty. If we
    peek element 6, then *queue1* remains with this element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the remaining elements are in *queue2*, so in order to perform another
    operation (push, peek, or pop), we have two options:'
  prefs: []
  type: TYPE_NORMAL
- en: Restore *queue1* by moving the remaining elements from *queue2* back.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use *queue2* as if it was *queue1*, which means using *queue1* and *queue2*
    alternatively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of the second option, we avoid the overhead of moving the elements
    from *queue2* back to *queue1*, with the purpose of performing the next operation
    on *queue1*. While you can challenge yourself to implement the first option, let's
    focus more on the second one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Trying to use *queue1* and *queue2* alternatively can be done if we consider
    that the queue that we should use for the next operation is the one that is not
    empty. Since we move the elements between these two queues, one of them is always
    empty. Hence, a problem arises when we peek an element because the peek operation
    doesn''t remove the element, so one of the queues remains with that element. Since
    none of the queues are empty, we don''t know which queue should be used for the
    next operation. The solution is quite simple: we poll the last element, even for
    the peek operation, and we store it as an instance variable. Subsequent peek operations
    will return this instance variable. A push operation will push this instance variable
    back into the queue before pushing the given value and will set this instance
    variable to `null`. The pop operation will check if this instance variable is
    `null` or not. If it is not `null`, then this is the element to pop.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *StackViaQueue*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 8 – Max histogram area
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given the histogram shown in the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5 – Histogram with the class interval equal to 1](img/Figure_12.5_B15403.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.5 – Histogram with the class interval equal to 1
  prefs: []
  type: TYPE_NORMAL
- en: We define a histogram as a diagram of rectangular bars where the area is proportional
    to the frequency of a certain variable. The width of a bar is known as the histogram
    class interval. For example, the histogram in the preceding image has a class
    interval equal to 1\. There are six bars whose widths are equal to 1 and whose
    heights are 4, 2, 8, 6, 5, and 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider you''ve been given these heights as an array of integers (this is
    the input of the problem). Write a snippet of code that uses a stack for computing
    the largest rectangular area in the histogram. For a better understanding of this,
    the following image highlights several rectangles (not all) that can be formed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6 – Rectangles of a histogram'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.6_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.6 – Rectangles of a histogram
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding image, the largest rectangular area (that is, the largest rectangle)
    is the one in the middle, 3 x 5 = 15.
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: This problem is harder than it may seem at first sight. First
    of all, we need to analyze the given image and formulate several statements. For
    example, it is very important to notice that a bar can only be part of a rectangular
    area if its height is less than or equal to the height of that area. Moreover,
    for each bar, we can say that all the bars from the left-hand side that are higher
    than the current bar can form a rectangular area with the current bar. Similarly,
    all the bars on the right-hand side that are higher than the current bar can form
    a rectangular area with the current bar.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that every rectangular area is delimited by a *left* and a *right*
    boundary, and (*right - left*) ** current_bar* give us the value of this area.
    We should compute all the possible areas and peek the highest area as the output
    of our implementation. The following image highlights the left and right boundaries
    of the 3 x 5 rectangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7 – Left and right boundaries'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.7_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.7 – Left and right boundaries
  prefs: []
  type: TYPE_NORMAL
- en: Remember that we must use a stack to solve this problem. Now that we have some
    statements that can lead us to the solution, it is time to bring the stack into
    the discussion. Mainly, we can use the stack to compute the left and right boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start from the first bar and we push the index of it (index 0) into the
    stack. We continue with the remaining bars and do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Repeat *steps 1a*, *1b*, and *1c* as long as the current bar is smaller than
    the top of the stack and the stack is not empty:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. We pop the top of the stack.
  prefs: []
  type: TYPE_NORMAL
- en: b. We compute the left boundary.
  prefs: []
  type: TYPE_NORMAL
- en: c. We compute the width of the rectangular area that can be formed between the
    computed left boundary bar and the current bar.
  prefs: []
  type: TYPE_NORMAL
- en: d. We compute the area as the computed width multiplied by the height of the
    bar that we popped in *step 1a.*
  prefs: []
  type: TYPE_NORMAL
- en: e. If this area is bigger than the previous one, then we store this one.
  prefs: []
  type: TYPE_NORMAL
- en: Push the index of the current bar into the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat from *step 1* until every bar is processed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s see this in terms of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The time complexity of this code is O(n). Moreover, the additional space complexity
    is O(n). The complete application is called *StackHistogramArea*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 9 – Smallest number
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given a string representing a number of
    *n* digits. Write a snippet of code that prints the smallest possible number after
    removing the given *k* digits.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let''s consider that the given number is *n*=4514327 and *k*=4\.
    In this case, the smallest number after removing four digits is 127\. If *n*=2222222,
    then the smallest number is 222\.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution can be easily implemented via a `Stack` and the following algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate the given number from left to right, digit by digit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'a. While the given *k* is greater than 0, the stack is not empty and the top
    element in the stack is greater than the currently traversed digit:'
  prefs: []
  type: TYPE_NORMAL
- en: i. Pop out the top element from the stack.
  prefs: []
  type: TYPE_NORMAL
- en: ii. Decrement *k* by 1.
  prefs: []
  type: TYPE_NORMAL
- en: b. Push the current digit to the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the given *k* is greater than 0, do the following (to handle special
    cases such as 222222):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Pop out elements from the stack.
  prefs: []
  type: TYPE_NORMAL
- en: b. Decrement *k* by 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of code, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *SmallestNumber*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 10 – Islands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Adobe**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given a matrix, *m*x*n*, containing only
    0s and 1s. By convention, 1 means land and 0 means water. Write a snippet of code
    that counts the number of islands. An island is defined as a group of 1s surrounded
    by 0s.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let''s visualize a test case. The following is a 10x10 matrix
    that contains 6 islands, highlighted as 1, 2, 3, 4, 5, and 6:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8 – Islands via a 10x10 matrix'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.8_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.8 – Islands via a 10x10 matrix
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to find the islands, we have to traverse the matrix. In other words,
    we have to traverse each cell of the matrix. Since a cell is characterized by
    a row (let''s denote it as *r*) and a column (let''s denote it as *c*), we observe
    that, from a cell (*r, c*), we can move in eight directions: (*r-*1*, c-*1), (*r-*1*,
    c*), (*r-*1*, c+*1), (*r, c-*1), (*r, c+*1), (*r+*1*, c-*1), (*r+*1*, c*), and
    (*r+*1*, c+*1). This means that from the current cell (*r, c*), we can move to
    (*r+ROW*[*k*]*, c+COL*[*k*]) as long as `ROW` and `COL` are the below arrays and
    0 ≤ *k* ≤ 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Moving to a cell is valid as long as we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Don't fall from the grid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step on a cell representing land (a cell of 1).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Haven't been in that cell before.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to ensure that we don't visit the same cell multiple times, we use
    a boolean matrix denoted as `flagged[][]`. Initially, this matrix contains only
    values of `false`, and each time we visit a cell (`r`, `c`), we flip the corresponding
    `flagged[r][c]` to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the preceding three bullet points in code form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we know how to decide if a move from the current cell to another cell
    (from the eight possible movements) is valid or not. Furthermore, we have to define
    an algorithm to determine a movement pattern. We know that from a cell (*r, c*),
    we can move in eight directions in neighboring cells. So, the most convenient
    algorithm consists of trying to move from the current cell into all the valid
    neighbors, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with an empty queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move to a valid cell (*r, c*), enqueue it, and mark it as flagged – the starting
    point should be cell (0, 0).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dequeue the current cell and resolve all its eight neighboring cells – resolving
    a cell means to enqueue it if it is valid and mark it as flagged.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat *step 3* until the queue is empty. When the queue is empty, this means
    we've found an island.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat from *step 2* until there are no more valid cells.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In terms of code, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *QueueIslands*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 11 – Shortest path
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given a matrix, *m* x *n*, containing only
    0s and 1s. By convention, 1 means safe land, while 0 represents unsafe land. More
    precisely, a 0 represents a sensor that should not be activated. Moreover, all
    eight adjacent cells can activate the sensor. Write a snippet of code that computes
    the shortest route from any cells of the first column to any cell of the last
    column. You can only move one step at a time; either left, right, up, or down.
    The resulting route (if its exists) should contain only values of 1.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let''s visualize a test case. The following is a 10 x 10 matrix.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the left-hand side of the following image, you can see the given matrix.
    Notice the values of 0 representing sensors that should not be activated. On the
    right, you can see the matrix being used by the application and a possible solution.
    This matrix is obtained from the given matrix by expanding the sensor''s coverage
    area. Remember that the eight adjacent cells of a sensor can activate the sensor
    as well. The solution starts from the first column (cell(4, 0)) and ends in the
    last column (cell (9, 9)) and contains 15 steps (from 0 to 14). You can see these
    steps in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.9 – The given matrix (left-hand side) and the resolved matrix (right-hand
    side)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.9_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.9 – The given matrix (left-hand side) and the resolved matrix (right-hand
    side)
  prefs: []
  type: TYPE_NORMAL
- en: 'From a safe cell of coordinates (*r, c*), we can move in four safe directions:
    (*r*-1*, c*), (*r, c*-1), (*r*+1*, c*), and (*r, c*+1). If we think of the possible
    movements as directions (edges) and the cells as vertices, then we can visualize
    this problem in the context of a graph. The edges are the possible moves, while
    the vertices are the possible cells where we can go. Each move holds the distance
    from the current cell to the start cell (a start cell is a cell from the first
    column). For each move, the distance is increased by 1\. So, in the context of
    a graph, the problem reduces to finding the shortest path in a graph. Hence, we
    can use the **Breadth-first Search (BFS)** approach to solve this problem. In
    [*Chapter 13*](B15403_13_Final_JM_ePub.xhtml#_idTextAnchor295)*, Trees and Graphs*,
    you were provided with a description of the BFS algorithm, and another problem
    was solved in the same manner as the one being solved here – the *Chess Knight*
    problem.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, based on the experience provided by the previous problem, we can elaborate
    on this algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with an empty queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enqueue all the safe cells of the first column and set their distances to 0
    (here, 0 represents the distance from each cell to itself). Moreover, these cells
    are marked as visited or flagged.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As long as the queue is not empty, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Pop the cell representing the top of the queue.
  prefs: []
  type: TYPE_NORMAL
- en: b. If the popped cell is the destination cell (that is, it is on the last column),
    then simply return its distance (the distance from the destination cell to the
    source cell on the first column).
  prefs: []
  type: TYPE_NORMAL
- en: c. If the popped cell is not the destination then, for each of the four adjacent
    cells of this cell, enqueue each valid cell (safe and unvisited) into the queue
    with distance (+1) and mark it as visited.
  prefs: []
  type: TYPE_NORMAL
- en: d. If we processed all the cells in the queue without reaching the destination,
    then there is no solution. Return -1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we rely on the BFS algorithm, we know that all the cells whose shortest
    paths are 1 are visited first. Next, the visited cells are the adjacent cells
    who have the shortest paths as 1+1=2 and so on. So, the cell that has the shortest
    path is equal to the *shortest path of its parent +* 1\. This means that, when
    we traverse the target cell for the first time, it gives us the final result.
    This is the shortest path. Let''s see the most relevant part of the code for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *ShortestSafeRoute*.
  prefs: []
  type: TYPE_NORMAL
- en: Infix, postfix, and prefix expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Prefix, postfix, and infix expressions are not a very common interview topic
    these days, but it can be considered a topic that should be covered at least once
    by any developer. The following is a quick overview:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Prefix expressions**: This is a notation (algebraic expression) that''s used
    for writing arithmetic expressions in which the operands are listed after their
    operators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Postfix expressions**: This is a notation (algebraic expression) that''s
    used for writing arithmetic expressions in which the operands are listed before
    their operators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Infix expressions**: This is a notation (algebraic expression) that''s typically
    used in arithmetic formulas or statements where the operators are written in between
    their operands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we have three operators, a, b, and c, we can write the expressions shown
    in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.10 – Infix, postfix, and prefix'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.10_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.10 – Infix, postfix, and prefix
  prefs: []
  type: TYPE_NORMAL
- en: The most common problems refer to evaluating prefix and postfix expressions
    and converting between prefix, infix, and postfix expressions. All these problems
    have solutions that rely on stacks (or binary trees) and are covered in any serious
    book dedicated to fundamental algorithms. Take your time and harvest some resources
    about this topic to get familiar with it. Since this topic is widely covered in
    dedicated books and is not a common topic in interviews, we will not cover it
    here.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered the must-know stack and queue problems for any candidate
    that is preparing for a Java developer technical interview. Stacks and queues
    occur in many real applications, so mastering them is one of the top skills that
    an interviewer will test you on.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, *Trees, Tries, and Graphs*, you'll see that stacks and
    queues are frequently used for solving problems that involve trees and graphs
    as well, which means they also deserve your attention.
  prefs: []
  type: TYPE_NORMAL
