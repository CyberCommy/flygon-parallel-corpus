- en: Chapter 5. Handling Data in Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data in business defines the business. What it means is that the way we define,
    store, interpret, and use data, forms the data platform of our business. It seldom
    happens that a single piece of data has meaning on its own; it only forms business
    functionality when combined with other data. So it becomes important that the
    data is connected, grouped, and filtered in such a way that the same dataset can
    be used for various aspects of the business.
  prefs: []
  type: TYPE_NORMAL
- en: In order to have a platform which can sustain future requirements, it is pertinent
    that we define and classify the data in a way which gives us indications on the
    kind of expectation we have from that data. Data has many facets and it's important
    to understand those facets to extract full business value from it. For example,
    stock price of a company is important for the real-time systems to decide whether
    to buy or sell, and it loses its importance after a few seconds or milliseconds.
    However, it becomes important for the analytics system to predict its trends.
    So in a way, the same piece of data at different times has different usage. So
    it's good practice to take into account the various expectations from the data
    while strategizing the data architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Classifying data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A general tendency has been to think only in terms of a data model which fits
    the relational model. This might be a good model for certain classes of data but
    might prove to be ineffective for another class of data. Since this book is on
    Redis, we will attempt to classify the data based on certain behaviors and make
    an attempt to see where Redis fits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Message and event data**: The data classified as message data in business
    show the following properties:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data complexity**: Message data has low data complexity as they are usually
    flat in structure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data quantity**: Message data usually has high volumes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Persistence**: Message data can be stored in disk and memory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CAP property**: Message data needs to be at least available and partition
    tolerant'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Usability**: Message data can have usability in real-time, soft real-time,
    and offline and show the property of heavy writes and low reads'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the requirement for message data is for real-time and soft real-time activity,
    and the data quantity is not very high then Redis and its messaging capability
    can be used.
  prefs: []
  type: TYPE_NORMAL
- en: '**Cache data**: The data classified as cache data in business shows the following
    properties:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data complexity**: Cache data has low data complexity and is mostly stored
    as name value pair'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data quantity**: Cache data usually has low to medium volumes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Persistence**: Data can be stored in cache memory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CAP property**: Cache data needs to be at least available and consistent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Usability**: Cache data can have usability in real-time, and show low writes
    and heavy reads'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redis is the perfect fit for cache data since it provides data structures which
    can be used directly by the program for storing the data. Also, the keys in Redis
    have time to live option which can be used to clean the data in Redis at regular
    intervals.
  prefs: []
  type: TYPE_NORMAL
- en: '**Meta data**: The data classified as meta data in business shows the following
    properties:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data complexity**: Meta data has low data complexity and is mostly stored
    as name value pair'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data quantity**: Meta data usually has low volumes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Persistence**: Meta data can be stored in memory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CAP property**: Meta data needs to be at least available and consistent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Usability**: Meta data can have usability in real-time and usually show low
    writes and low to heavy reads'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Redis is the perfect fit for meta data since it provides data structures which
    can be used directly by the program for storing the data. Since Redis is fast
    and has messaging capability, it can be used for runtime manipulation of the meta
    data and also act as a central meta data repository. The following figure is a
    representation of how Redis can be used as meta data store:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Classifying data](img/0123OS_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Redis as a meta data store
  prefs: []
  type: TYPE_NORMAL
- en: '**Transactional data**: The data classified as transactional data in business
    shows the following properties:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data complexity**: Transactional data has medium to high data complexity
    and is mostly relational'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data quantity**: Transactional data usually has medium to high volumes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Persistence**: Transactional data can be stored in memory and disk'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CAP property**: Transactional data needs to be at least consistent and partition
    tolerant'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Usability**: Transactional data need to show `CRUD` behavior, capabilities
    that Redis does not have'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redis is not the right datastore for this kind of data. Another point which
    we can figure out here is that wherever we need partition tolerance as a CAP feature,
    Redis should not be used.
  prefs: []
  type: TYPE_NORMAL
- en: '**Analytical data**: The data classified as analytical data in business shows
    the following properties:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data complexity**: Data complexity can be further segregated on the basis
    of online analytics and offline analytics. Online analytical data has low to medium
    data complexity as they can contain graph like relation. Offline analytics have
    very high data complexity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data quantity**: Data here usually has low to high volumes depending upon
    the kind of analytics we want. Online analytics can have a lower amount of data
    as compared to offline analytics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Persistence**: Data can be stored in disk and memory. If online analytics
    is the requirement, the data is persisted in memory but if the analytics is offline
    then data needs to persist in the disk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CAP property**: In case of offline analytics, the data needs to be at least
    available and partition tolerant, and in case of online analytics, the data needs
    to be available and consistent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Usability**: Message data can have usability in real-time, soft real-time,
    and offline.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the requirement is for online analytics, Redis can be used provided the complexity
    of the data is low.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding classification of data, we saw some areas where Redis is a
    good fit and areas where Redis can be avoided. But for Redis to be taken seriously
    in the business solution environment, it has to show capability for fault tolerance
    and fault management, replication, and so on. In the next section, we will do
    in-depth study of how redundancy and fault management can be taken care of.
  prefs: []
  type: TYPE_NORMAL
- en: Master-slave data replication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In any business application, it is paramount that data is kept in a replicated
    manner since hardware can break at any time without giving any warning. In order
    to have continuance of the business, it becomes necessary that when the master
    database goes down, the replicated database can be used instead, which in a way
    guarantees quality of service. Another advantage of having replicated data is
    realized when the traffic on one database goes up and it negatively impacts the
    performance of the solution. In order to provide the performance, it is important
    to load balance the traffic and reduce the load on each node.
  prefs: []
  type: TYPE_NORMAL
- en: Datastores such as Cassandra provide master-master configuration where all the
    nodes in the topology are like masters and the replication of data takes place
    based on token hash generated on the basis of key, and for that to happen nodes
    in the topology are partitioned based on token ranges.
  prefs: []
  type: TYPE_NORMAL
- en: Redis, unlike master-master breed of datastores, has a simpler master-slave
    arrangement. What it means is that master is the node which will write all the
    data and then replicate the data into all the slave nodes. The replication takes
    place asynchronously which means that the moment a data is written into the master,
    the slaves are not written synchronously but a separate process writes them asynchronously,
    so the update is not immediate; in other words **eventual consistency**. But there
    is advantage in this kind of arrangement in terms of performance. If the replication
    is synchronous then when an update is made to the master, the master has to update
    all the slaves and then only the update will be marked as a success. So if there
    are more slaves then the updates become more time consuming.
  prefs: []
  type: TYPE_NORMAL
- en: The following figure represents the process of master-slave replication in Redis.
    To have a better understanding of the process, let's say that at time **T0**,
    the value of a Set represented by **Msg** is **"Hello"** in the master node as
    well as in all the slave nodes (**S1**, **S2**, **S3**). When an insert command
    **SADD** is made to insert value (**"Hello again"**) to the Set at time **T1**,
    the value **Msg** becomes **Hello Hello again** at time **T2** but the value of
    **Msg** at slave nodes is still **"Hello"**. The new value is successfully inserted
    into the master node and the reply code for a successful insertion is sent back
    to the client. Meanwhile, the master will start inserting all the slaves with
    the new value and this happens in time **T3**. So at time **T3**, all the nodes
    (master and slaves) are updated with the new value. The time lag between the master
    getting updated and the slaves getting updated is very small (in milliseconds).
  prefs: []
  type: TYPE_NORMAL
- en: To have a better understanding of how master-slave would work in Redis, let's
    revisit the previous chapter where we discussed real-time messaging in Redis.
    To apply the same functionality in this case, we can think that all the slave
    nodes have been subscribed to the master node and when the master node gets updated,
    it publishes the new data to all the slave nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Master-slave data replication](img/0123OS_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Data replication in master-slave
  prefs: []
  type: TYPE_NORMAL
- en: So what happens when a slave is down and an update happens in the master? Well,
    in that case, the particular slave misses the update and still carries the older
    value. However, when the slave again connects back to the master, the first thing
    it does is fire a `SYNC` command to the master. This command sends the data to
    the slave nodes wherein it can update itself.
  prefs: []
  type: TYPE_NORMAL
- en: Setting master and slave nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Setting up master slave nodes is pretty simple in Redis. What we will do here
    is set up a master and a slave node for Redis in our local machine. The first
    thing we do here is to copy the Redis folder (in our case `redis 2.6`) to a suitable
    location. So now we have Redis distribution in two separate locations.
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting master and slave nodes](img/0123OS_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Master node folder and slave node folder
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of better understanding, we will refer to **Redis-2.6** as the
    master node and **Redis-2.6.slave** as the slave node. Now open the master node
    and go to the `bin/release`" folder and start the Redis-server. This will start
    the Redis server in the localhost and with port address 6379\. Now open the slave
    node and open the `Redis.conf` file in a suitable text editor. There are at least
    two properties that need to be changed in order to start our slave node. The first
    property which needs to be edited is `port`. In our case, let's change the value
    from 6379 to 6380\. Since the master node is going to listen for requests at 6379,
    the slave has to listen at a different port (we are going to launch both the master
    and the slave from the same machine). The second property change that needs to
    be done is `slaveof`, the value of which is going to be `127.0.0.1 6379`. This
    is basically telling the slave where and what port the master is running. This
    is helpful since the slave is going to use this address to send `SYNC` and other
    commands to the master. With these minimal changes we are good to go. Now go to
    the `bin/release` folder of the slave node and start the Redis-server.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you start the Redis-server, provide the path of `Redis.conf` of the slave
    node, that is Redis-server `F:\path\to\config-file\Redis.conf`.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we would see when we fire the slave node is that it will try
    to connect to the master. From its `Redis.conf`, the slave node will figure out
    the host and port of the master node. One thing again which is different in Redis
    as compared to other datastores is that it uses one port for catering to business
    requests as well as catering to `SYNC` and other ports for similar request from
    slave nodes. This is primarily because Redis is a single threaded server and the
    thread only listens to the messages coming to the socket.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure represents how your command prompt might look when the
    slave node starts (please make sure your master node is up and running):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting master and slave nodes](img/0123OS_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Slave node starting at port 6380
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of things that need to be noted here. The first thing is
    that the moment the slave node starts, it fires a `SYNC` command to the master.
    The command is a nonblocking command which means that the single thread will not
    hold other requests in order to cater to this request. What basically the master
    does is put it in a request stack for that connection and time slices it with
    the other connections, and when the activity is complete for that command of that
    connection (in our case `SYNC` for slave) it sends it to slave. In this case,
    what it sends back is the command and the data that the slave needs to have to
    become at par with the master. This command is executed with the data and it is
    then subsequently loaded in the slave's database. All the commands that the master
    sends are the commands which alter the data and not the data `getter` commands.
    The protocol used by the master to connect to the slaves is the **Redis protocol**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look into some scenarios and see how Redis behaves in the master slave
    mode:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Master is up and a telnet session connects to the master:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure Redis master node is up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure Redis client for the master is running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open your command prompt and connect to the master using the command `telnet
    127.0.0.1 6379`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type the command `SYNC` in the telnet client. The following text should appear
    in the command prompt:![Setting master and slave nodes](img/0123OS_05_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Master pinging telnet client
  prefs: []
  type: TYPE_NORMAL
- en: Go to your master client prompt and type the command `SET MSG "Learning Redis
    master slave replication"` and execute it. Immediately shift to the telnet command
    prompt and you will see the following output:![Setting master and slave nodes](img/0123OS_05_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Master sending the data to telnet client
  prefs: []
  type: TYPE_NORMAL
- en: Now execute the `GET MSG` command at the client prompt of the master node
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Master is up and the slave connects for the first time:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The slave console is similar to the previous figure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fire a command from master Redis-cli as `SET MSG "Learning Redis"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fire a command from slave Redis-cli as `GET MSG`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure you give the host and port addresses; in our case since we have configured
    it in localhost and port is configured at 6380, the command would look like `Redis-cli.exe
    -h localhost -p 6380`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The result should be `"Learning Redis"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Master is up and slave comes up again after being disconnected for a while:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kill the slave node and the client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the master's client command prompt and write the command `SET MSG "Slave
    node is down"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now start the slave node and its client (provide host and port information).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the command `GET MSG` from slave's client command prompt and the result
    should be `"Slave node is down"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Master is up and is executing a pipeline command and we are reading the value
    from slave:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure master and slave are up and running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the `SCARD MSG` command in slave client's command prompt but do not execute
    it. We are going to get the number of members in the set `MSG`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open you Java client and write the following program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Execute this command and immediately switch to your slave client command prompt
    and execute the command you had written. The result will be similar to the figure
    shown next. What it tells us is that the moment a command is executed in the master
    node which changes the dataset, the master starts buffering these commands and
    sends them to the slave. In our case, when we did a `SCARD` on the set, we saw
    results in an incremental way.![Setting master and slave nodes](img/0123OS_05_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Result of SCARD command on slave node
  prefs: []
  type: TYPE_NORMAL
- en: Master is up and is executing a transaction command and we are reading the value
    from slave.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Promoting slave as master when the master goes down and restarting master as
    slave:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start master and slave Redis servers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Execute the following Java program from your IDE:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When the program goes to sleep for the first time, quickly go to the command
    prompt of the master and restart it (don't touch the slave node). Allow the program
    to finish and the output is going to be similar to the following image:![Setting
    master and slave nodes](img/0123OS_05_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Master becomes slave and slave becomes master
  prefs: []
  type: TYPE_NORMAL
- en: The second sleep in the program is meant for the master to sync up with the
    new master.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the old master attempts to write against the key, it fails since slaves
    cannot write.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Server messages when the old slave became new master.![Setting master and slave
    nodes](img/0123OS_05_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Slave becomes master
  prefs: []
  type: TYPE_NORMAL
- en: Server messages when the old master is started as a new slave. We can also see
    that the moment the old master restarts, the first thing it does as a slave is
    to sync with the new master and update its datasets.![Setting master and slave
    nodes](img/0123OS_05_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Master becomes slave
  prefs: []
  type: TYPE_NORMAL
- en: If we don't give the second sleep in the program, the old master will not get
    time to sync with the new master and if there is a client request for a key then
    it will end up showing the old value for the key
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Until now we have learnt the master-slave capabilities of Redis and how it behaves
    in cases where master goes down or slave goes down. We also discussed that master
    sends data to slave and replicates the dataset. But still the question is what
    does Redis master send when it has to send data to the slaves? To find out, let's
    run a small experiment which will clarify the behind the scene activities.
  prefs: []
  type: TYPE_NORMAL
- en: Performance pattern – high reads
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a production environment, it becomes important to have some kind of a strategy
    when the concurrency is high. Having a replication pattern surely helps to distribute
    the load across the environment. The replication pattern followed in this pattern
    is to write to the master and read from the slaves.
  prefs: []
  type: TYPE_NORMAL
- en: '![Performance pattern – high reads](img/0123OS_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Replication strategy in master and slaves
  prefs: []
  type: TYPE_NORMAL
- en: The sample we will run will not be a proper replication of the previous mentioned
    solution since the master and the slave will run from the same machine (my laptop).
    By running the master and the slave nodes in the same machine, we are utilizing
    common memory and processing power. On top of it, the client program also uses
    the same resources. But still the difference will be observed because of server
    I/O happenings at two different ports, which means that at least a separate socket
    memory bound to two separate server threads (Redis is a single thread server)
    are processing the read requests.
  prefs: []
  type: TYPE_NORMAL
- en: In a production environment, it is better if every node works out of its own
    core since Redis cannot make use of multi-core.
  prefs: []
  type: TYPE_NORMAL
- en: In this sample, we will use one master and two slave nodes. In the first use
    case, we will use the master to write data into and the slaves to read data from.
    We will take the total time taken for the reads only and compare it with a scenario
    where the reads will be done entirely on the master node.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prepare for the sample we need to prepare for the environment and the following
    diagram depicts in brief what the setup shall be for this sample. Here note that
    all the resources are from a single machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Performance pattern – high reads](img/0123OS_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setup for the sample
  prefs: []
  type: TYPE_NORMAL
- en: 'The following written program can accommodate both the scenarios discussed
    earlier. To work in the **USECASE-1** mode (write to master and read from master
    node), call the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Call `test.setup()` in the first run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `test.readFromMasterNode()` in the second run
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please comment the following function call this will not allow **USECASE-2**
    to run `// test.readFromSlaveNodes();`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To work in the **USECASE-2** mode (write to master and read from two slaves),
    call the following functions, but before that, execute `FLUSHDB` command to clean
    up the data or don''t execute the `test.setup();` function:'
  prefs: []
  type: TYPE_NORMAL
- en: Call `test.setup();` in the first run (optional).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `test.readFromSlaveNodes();` in the second run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please comment the following function call this will not allow **USECASE-1**
    to run `// test.readFromMasterNode();`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code has three simple classes and a brief description of the classes is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MasterSlaveLoadTest`: This class has the following characteristics:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the main class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This class coordinates the flow for **USECASE-1** and **USECASE-2**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This class is responsible for creating threads for **USECASE-1** and **USECASE-2**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Following is the code for `MasterSlaveLoadTest`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`PumpData`: This class has the following characteristics:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the class responsible for pushing the data into the main node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data pushing is single threaded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code for `PumpData` is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`FetchData`: This class has the following characteristics:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the class responsible for fetching the data from the Redis nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This class is called in a multi-threaded mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This class is passed at start time so the last result returned will indicate
    the total time the execution has taken place
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code for `FetchData` is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the preceding program for a few iterations and take out the best and worst
    record, and then take out the average result. For the iterations that I ran, I
    got the following results:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For USECASE-1, the average time was 95609 milliseconds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For USECASE-2, the average time was 72622 milliseconds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Though the results in your machines will be different in terms of number, but
    the results will be similar. This clearly shows that reading from slave nodes
    and writing to master node clearly is better performing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance pattern – high writes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a production environment, it becomes important to have some kind of a strategy
    when the demand for concurrency is high for writes. Having a replication pattern
    surely helps to distribute the load across the environment but replication pattern
    alone is not helpful when the need for concurrency in writes is high. Also, in
    Redis the slave nodes cannot have write capability. In order to make the data
    write highly concurrent in the database, it is important to shard the dataset
    across many database nodes in the environment. Many databases come with the in-built
    capability to shard the data accordingly across nodes. The advantage of having
    the dataset sharded, apart from high concurrency in writes, is to provide mechanism
    of partial failure tolerance. In other words, even if one of the nodes goes down,
    it will make the dataset contained in it unavailable but the other nodes can still
    cater to the requests for the data they hold.
  prefs: []
  type: TYPE_NORMAL
- en: Redis as a database lacks the capability to shard the data across many nodes.
    But it is possible to have some sort of intelligence built on top of Redis which
    can do the work of sharding, thus enabling high concurrent writes for Redis. The
    whole idea here is to take the responsibility out of the Redis nodes and keep
    it in a separate location.
  prefs: []
  type: TYPE_NORMAL
- en: '![Performance pattern – high writes](img/0123OS_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Distributing the data across nodes based on sharding logic
  prefs: []
  type: TYPE_NORMAL
- en: There are various logics that can be built on top of Redis which can be used
    to distribute the write load. Logic can be based on a round robin where the data
    can be distributed on sequentially arranged nodes; for example, data will go to
    **M1**, then **M2**, then **M3**, and so on and so forth. But the problem in this
    mechanism is that if one of the nodes were to go down, the round robin logic cannot
    factor in the lost node and it will continue to send data to the defective node
    which will end up in data loss. Even if we build logic to skip the defective node
    and put the data in the subsequent node, this strategy will result in that node
    having its own share of data, and the data of the defective node thus fills up
    its memory resources very fast.
  prefs: []
  type: TYPE_NORMAL
- en: Consistent Hashing is one of the algorithms which can come in handy when equally
    distributing data amongst the nodes. What basically we do here is that based on
    algorithms we generate, a Hash which distributes the key equally amongst the entire
    set of available Redis server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Redis client for Java already has the algorithm for consistent Hashing
    built into it to distribute the writes. This is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Persistence handling in Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Redis provides a wide range of options for persisting data. These mechanisms
    help in deciding what kind of persistence model we need for our data, and that
    solely depends on the kind of data we want to store in Redis. The four options
    that we have in Redis are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Persisting via the RDB option
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persisting via the AOF option
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persisting via combination of AOF and RDB option
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not persisting at all
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s run a simple program and see the importance of persistence mechanism,
    because then only we can appreciate the importance of persistence. Follow the
    steps and see for yourself how lack of persistence can cause data loss:'
  prefs: []
  type: TYPE_NORMAL
- en: Start your Redis server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a Redis client command prompt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the command `SET msg 'temporary value'`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Quickly kill the Redis server manually, either by **Kill-9** option in Linux
    or through **close** option in Command Prompt in windows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restart your Redis server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the command `get msg`.![Persistence handling in Redis](img/0123OS_05_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get msg without persistence handling
  prefs: []
  type: TYPE_NORMAL
- en: Persisting via the RDB option
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Redis database file** (**RDB**) is an option where the Redis server persists
    the dataset at regular interval or in other words, snapshots the data in memory
    at regular intervals. The format is a single, very compact file which is useful
    for keeping data as backups. This file can act as a saving grace in case of a
    disaster and thus is very important. The Redis server can be configured to take
    snapshots at various intervals. From a performance perspective, this way of persisting
    data will result in higher performance since the Redis server will fork a child
    process to do this in a nonblocking manner. Another advantage is that since it
    is the dataset only that is stored in the RDB files, the server start-ups are
    very fast in case of RDB files. But storing dataset in RDB comes with its own
    disadvantage since chances of data loss is possible if Redis were to fail in between
    two snapshots. Another problem might crop up if the dataset is very high in volume
    because in that case the Redis server''s forked child process will take time to
    load up the data and this time taken can block client requests for that duration.
    This problem will not come in production scenarios as there is always a time lag
    between the servers to restart and for the server to process the client request.
    From a hardware perspective, a machine with a faster processor will always do
    the trick.'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Redis for RDB persistence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here we will learn how to persist data on a RDB file. Well in Redis, the RDB
    persistence mechanism can be configured by editing the `Redis.conf` file or through
    the client prompt. When we open our `Redis.conf` file and go to the `snapshotting`
    section, we see the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Save 900 1`: Save in 15 minutes if one key has changed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Save 300 10`: Save in 5 minutes if 10 keys have changed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Save 60 10000`: Save in 1 minute if 10,000 keys have changed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from these preconfigured options, we can add our own options by tweaking
    the value in the `Redis.conf` file. Clients can also be used to add configurations
    at runtime for dataset snapshotting. For example, `CONFIG SET SAVE "900 2 300
    10"` will set snapshotting as `Save in 15 minutes if 2 keys have changed` and
    `Save in 10 minutes if one key has changed`, and this will override the previous
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run a simple program like the previous program wherein we see data loss
    due to lack of persistence and we will configure the Redis to have persistence
    mechanism:'
  prefs: []
  type: TYPE_NORMAL
- en: Start your Redis server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a Redis client command prompt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the command `Set msg 'temp value'`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Quickly kill the Redis server manually, either by **Kill-9** option in Linux
    or through **close** option in command prompt in windows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restart your Redis server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the command `get msg`.![Configuring Redis for RDB persistence](img/0123OS_05_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get msg without persistence handling
  prefs: []
  type: TYPE_NORMAL
- en: Now execute the command `CONFIG SET SAVE "60 1"`, which tells the Redis server
    to save the data in one minute if one key has changed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the command `Set msg 'temp value'`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for a minute or go and grab a cup of your favorite beverage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Kill the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restart your Redis server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a new client connection and execute the command `get msg`, which would
    result in the following display:![Configuring Redis for RDB persistence](img/0123OS_05_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get msg RDB persistence handling
  prefs: []
  type: TYPE_NORMAL
- en: Instead of waiting for one minute, you can also use the `save` command which
    will immediately push the data in memory into the RDB file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The parameters that you need to give attention to for persisting your data
    into a RDB file are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`dbfilename`: Give the name of you RDB file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dir`: Give the path of the RDB file only'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rdbchecksum yes`: This is default value which adds CRC64 checksum placed at
    the end of the file to make it resistant to corruption but has a minor performance
    penalty on server restarts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use case for using RDB persistence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Redis can be configured to have RDB persistence mechanism in cases where data
    is stateless. What I want to convey here is that if the data is a piece of information
    that has no relation to the data stored before or the next piece of data it is
    going to store, then it becomes a perfect candidate for RDB persistence. Moreover,
    the relation can be in terms of sequence, time, rank, and so on, or the data itself
    can contain information of state. Take for example where the data stored is `START`,
    `PAUSE`, `RESUME`, and `STOP`. In this case, if we were to lose data such as `PAUSE`
    or `RESUME` during snapshotting, then it might bring the entire system to an unstable
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a use case where the website records the URLs the user visits in
    a browsing session. This data is analyzed for profiling the user behavior in order
    to give the user a better service. In this case, the data, that is the URL of
    the page visited, is not related to the data stored previously or the data to
    be stored in future, so it does not have a state. So even in a case of failure
    between two snapshots, if some amount of data is lost it is not going to impact
    the overall analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Another use case where RDB persistence can be used is when we want to use Redis
    as a caching engine where there will be fewer data writes and data reads are going
    to be very frequent.
  prefs: []
  type: TYPE_NORMAL
- en: Persisting via the AOF option
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Append only file** (**AOF**) is a durable mechanism of storing data in the
    Redis datastore. When AOF is enabled, Redis will append all the commands (that
    write into the dataset) and the associated data, so that when the Redis server
    is restarted it will rebuild the dataset to the correct state. This mode of persistence
    is useful when we are storing data that have states. This is because when we are
    doing state management or have a state associated with a dataset in the eventuality
    of a server shutdown the information (the state information stored in the memory)
    will be lost. This in turn would result in some sort of state mismatch. Let''s
    say that we have a piece of information at state A and subsequent activities on
    that information change its state from A to B and from B to C, and so on and so
    forth. Now from a user''s perspective, the last state change brought the information
    in the D state, which in principle would be in memory, and in the case of a server
    shutdown (crash), the information will be lost, so the state change information
    D will be lost. So when the server restarts, and if the user changes the state
    of that information to E, the state change history will look like A to B, B to
    C, and C to E. This in certain scenarios would result in corrupt data. The AOF
    way of persisting takes care of the problems that may arise due to this.'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Redis for AOF persistence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: AOF can be enabled by making a change in the `Redis.conf` file. The property
    `appendonly` needs to be set to `yes`. By setting it to true, we signal Redis
    to record the write commands and the data into a file which will reply itself
    when the server restarts, bringing it to the same state in which it was before
    shutdown.
  prefs: []
  type: TYPE_NORMAL
- en: Redis provides three flavors or strategies to mitigate problems arising due
    to inconsistent states. The first strategy is to record every write event in the
    AOF file. This mechanism is the safest but not very good in performance. The way
    this can be achieved is via `appendfsync always`.
  prefs: []
  type: TYPE_NORMAL
- en: The second mechanism is time-based wherein we instruct the Redis server to buffer
    every write command and schedule an AOF append every second. This technique is
    more efficient since this is happening in every second and not on every write.
    The way it can be achieved is by telling Redis to `appendfsync everysec`. Here
    in this mechanism, there is a miniscule chance of state loss.
  prefs: []
  type: TYPE_NORMAL
- en: The third mechanism is more like a delegation where the control to append is
    given to the underlying operating server to flush the write commands from the
    buffer to the AOF file. The frequency of append is once every few seconds (in
    a Linux-based machine, the frequency is close to once every 30 seconds). The performance
    is the fastest in this technique since this is happening every 30 seconds. However,
    the chances and amount of data loss is also high in this mechanism. This way of
    appending can be achieved by telling Redis to `appendfsync no`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run a simple program like the previous program wherein we see data loss
    due to a lack of persistence and we will configure the Redis to have AOF persistence
    mechanism:'
  prefs: []
  type: TYPE_NORMAL
- en: Start your Redis server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a Redis client command prompt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the command `Set msg 'temp value'`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Quickly kill the Redis server manually, either by **Kill-9** option in Linux
    or through **close** option in command prompt in windows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restart your Redis server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the command `get msg`.![Configuring Redis for AOF persistence](img/0123OS_05_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get msg without persistence handling
  prefs: []
  type: TYPE_NORMAL
- en: Open your `Redis.conf` file and go to the section `APPEND ONLY MODE` and change
    the `appendonly no` to `appendonly yes`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncomment the `appendfilename appendonly.aof` property. Here, you can choose
    to provide your own name but the default name is `appendonly.aof`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the append mechanism to `appendfsync always`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start your Redis server with the following argument `--appendonly yes --appendfilename
    C:\appendonly.aof` (use this technique if you do not want to make the change in
    the `Redis.conf` file).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the command `Set msg 'temp value'`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Quickly kill the Redis server manually, either by **Kill-9** option in Linux
    or through **close** option in Command Prompt in windows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restart your Redis server with the following argument `--appendonly yes --appendfilename
    C:\appendonly.aof` (use this technique if you do not want to make the change in
    the `Redis.conf` file).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the command `get msg`.![Configuring Redis for AOF persistence](img/0123OS_05_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get msg with AOF persistence handling
  prefs: []
  type: TYPE_NORMAL
- en: Open file from `C:\appendonly.aof` and see the following:![Configuring Redis
    for AOF persistence](img/0123OS_05_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Opening the appendonly.aof
  prefs: []
  type: TYPE_NORMAL
- en: One thing that can be observed here is that there is no `get` command which
    gets recorded since they do not change the dataset. A problem that should be kept
    in mind is that if the writes are very frequent then AOF file will get bigger
    and bigger and the server restarts are going to take longer.
  prefs: []
  type: TYPE_NORMAL
- en: Use case for using AOF persistence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Redis can be configured to have AOF persistence mechanism in cases where data
    is state full. What I want to convey here is that if the data is a piece of information
    that has relation to the data stored before, or the next piece of data it is going
    to store, then it becomes a perfect candidate for AOF persistence. Suppose we
    are building a workflow engine where every state is responsible for the next state;
    in this kind of situation, using a AOF persistence is the best option.
  prefs: []
  type: TYPE_NORMAL
- en: Dataset handling commands in Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen commands used by the client program to either set data or get
    data in Redis but there are some useful commands that are needed to handle Redis
    as a datastore. These commands help in maintaining Redis in the production environment
    and are usually the domain of the Redis administration. Since these commands have
    an impact on the data stored in Redis, one should be careful in executing them.
    Following are some of the commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FLUSHDB`: This command deletes all the keys (and their held data) in the chosen
    database. As we have seen, in Redis we can create a database which is more like
    a SILO wherein we can store data in a segregated manner (more like separation
    of concern). This command never fails.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FLUSHALL`: This command deletes all of the keys in all the databases in Redis
    node. This command never fails.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MONITOR`: This command is a debugging command that relays all the commands
    that the Redis server is processing. You can either use the Redis-cli or the telnet
    to monitor what the server is doing.![Dataset handling commands in Redis](img/0123OS_05_20.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using telnet to monitor commands
  prefs: []
  type: TYPE_NORMAL
- en: Here we have used telnet to monitor the Redis server and whatever command is
    issued in the client is replicated here. Monitoring commands gives an inside look
    into the working of Redis but has a performance penalty. You can use this command
    to even monitor the slave nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '`SAVE`: This is a synchronous blocking call save to snapshot all the data in
    the memory to a RDB file. This command in a production environment should be used
    carefully because this will block every client command and perform this task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BGSAVE`: This command is more like a background save. The previous command
    `SAVE` is a blocking call but this command does not block the client calls. By
    issuing this command, Redis forks another process which starts to persist the
    data to a RDB file in the background. Issuing this command immediately returns
    the `OK` code but the client can check the result by issuing the `LASTSAVE` command.
    Let''s try a small example and see if it''s working:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start the Redis server and a client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute `LASTSAVE` command from the client; in my case the value it showed was
    an integer **1391918354** but in your case it might show a different time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open your telnet prompt and execute `MONITOR` command (this is done on purpose
    to retard the performance of your Redis server).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open your Java editor and type in the following program which will insert lots
    of values into the Redis server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the client prompt I issued the following commands and the result is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Dataset handling commands in Redis](img/0123OS_05_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Checking nonblocking nature of BGSAVE
  prefs: []
  type: TYPE_NORMAL
- en: I issued the `TIME` command after the `BGSAVE` command but when I issued `LASTSAVE`,
    the time I got was later to `BGSAVE` command. So we can conclude that `BGSAVE`
    is a nonblocking way of saving data. Since the command `FLUSHALL` manipulates
    the entire dataset, it automatically calls the `SAVE` command after execution.
    See the `LASTSAVE` command which shows time as **1391920265** and the previous
    `LASTSAVE` before `FLUSHALL`, which shows time as **1391920077** prove that `FLUSHALL`
    does as save.
  prefs: []
  type: TYPE_NORMAL
- en: '`LASTSAVE`: This command is similar to `BGSAVE` command, and it shows when
    the last time the data was persisted to the RDB file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SHUTDOWN SAVE`/`NOSAVE`: This command basically quits the server but before
    doing that it closes the connection of the entire set of clients and performs
    a blocking save, and then flushes the AOF if it is enabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DBSIZE`: This returns the number of keys in the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BGREWRITEAOF`: This instructs the Redis server to start a back ground write
    to an AOF. If this instruction fails, the old AOF file is retained.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CLIENT SETNAME`: This sets the name of a client and we can see the name set
    when we do a `CLIENT LIST`. Execute the following command in the client prompt
    `CLIENT SETNAME "myclient"`, and you should see something thing similar to the
    following image:![Dataset handling commands in Redis](img/0123OS_05_22.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Naming a client
  prefs: []
  type: TYPE_NORMAL
- en: '`CLIENT LIST`: This gets the list of clients connected to the IP address and
    the `PORT` address. Let''s do a simple experiment:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open a telnet client to a Redis server with `telnet localhost 6379` and execute
    the `MONITOR` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open a Redis server master node client prompt and execute the command `CLIENT
    LIST`. The command prompt should look similar to the following image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Dataset handling commands in Redis](img/0123OS_05_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting client list
  prefs: []
  type: TYPE_NORMAL
- en: '`CLIENTKILL`: This kills the client. Now, to the previous experiment, issue
    the following command in the client that we have opened up:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute the command `CLIENT KILL 127.0.0.1:1478`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the command `CLIENT LIST` we will see the number of lines displayed
    to go down by one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`DEBUG sEGFAULT`: This crashes the Redis server. The utility can be used to
    simulate bugs during development. This command can be used to simulate the scenario
    where we want to check the fault tolerance of the system by purposefully bringing
    the Redis server down. It would be interesting to see how the slave node behaves,
    how fault tolerance is handled by the clients, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SLOWLOG`: This command shows which commands took time during execution. Execute
    the program that you wrote in the *Performance pattern – high reads* section,
    and after the execution open a client for the master and execute this command.
    The result seen in the following image is a snapshot and is not the full result
    of what you might get in your command prompt:![Dataset handling commands in Redis](img/0123OS_05_24.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slowlog command
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw and learnt how to handle the entire dataset in Redis.
    Apart from that, we learnt patterns for performance in a production environment.
    We also learnt commands to manage the Redis server ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will apply the knowledge we have learnt until now to
    develop common components in web programming and see how Redis fits as a great
    tool to take care of some of the problems in this space.
  prefs: []
  type: TYPE_NORMAL
