- en: Production, Integration, and Federated Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover production, integration, and federated modules. We
    will provide an overview of the correct deployment procedures, shortcuts, and
    alternatives. Even though some of this chapter will discuss subjects that have
    already been covered in more detail, it's good to go over them again so that you
    have a clearer understanding of what you've learned so far.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have discussed and carried out development builds and alluded to
    going into production, but the procedure for appropriate publication-level production
    is a little different and involves cross-checking and following best practices.
  prefs: []
  type: TYPE_NORMAL
- en: This section of the book will explore the various options we can use to deploy
    Webpack 5 with various web utilities. This will provide you with an overview of
    such web utilities and explain which are more appropriate for specific situations
    and platforms, including deploying with Babel.
  prefs: []
  type: TYPE_NORMAL
- en: All of these subjects are relevant to our opening section on production bundling,
    which also covers the topic of deployment for production and publication purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Production setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shimming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Progressive web applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating task runners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting boilerplate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module Federation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Production setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we understand the basics, we can move on and learn about how to practically
    deploy production bundles. The objectives of building a project in development
    mode and production mode differ greatly. In production mode, goals shift to minifying
    builds using lightweight source mapping and optimizing assets to improve load
    time. In development mode, strong source mapping is crucial, as well as having
    a **localhost** server with live reloading or hot module replacement. Due to their
    different purposes, it is typically recommended to write separate Webpack configurations
    for each mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common configuration should be maintained between modes, despite their differences.
    To merge these configurations, a utility called `webpack-merge` can be used. This
    common configuration process means code does not need to be duplicated with each
    mode. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by opening your command-line utility, installing `webpack-merge`, and
    saving it in development mode, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s examine the **project directory**. Its contents should be structured
    similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that the preceding output shows that there are extra files present in this
    particular example. For instance, we are including the `webpack.common.js` file
    here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a closer look at the `webpack.common.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `webpack.common.js` file deals with **CommonJS** requests. It does things
    similarly to ECMAScript but is formatted differently. Let's ensure that the `webpack.config.js`
    file, which works in the **ECMA** environment, does the same thing as the **CommonJS**
    configuration file. Take note of the entry points and bundle name, as well as
    the **`title`** option. This latter option is the mode's counterpart, so you must
    ensure there is parity between both files in your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we''re looking inside the `webpack.dev.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the preceding code provides instructions on how `webpack.common.js`
    should be used in development mode. This is simply a case of cross-checking for
    final production to ensure the content of your work is formatted correctly and
    will map with an error during compilation.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re working in production mode, the following file, `webpack.prod.js`, will
    be called into action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Using `webpack.common.js`, set up entry and output configurations and include
    any plugins that are required for both environment modes. When using `webpack.dev.js`,
    the mode should be set to development mode. Also, add the recommended **devtool**
    to that environment, as well as the simple `devServer` configuration. In `webpack.prod.js`,
    the mode is, of course, set to production, which loads `TerserPlugin`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `merge()` can be used in an environment-specific configuration so
    that you can easily include a common configuration in development and production
    modes. It is also worth noting that there are a variety of advanced features available
    when using the `**webpack-merge**` tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make those development configurations inside of **`webpack.common.js`**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example simply shows the completed configuration for CommonJS.
    Note the list of plugin dependencies and their versions, which are loaded through
    the `devDependancies` option.
  prefs: []
  type: TYPE_NORMAL
- en: Now, run those scripts and see how the output changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code shows how you can continue adding to the production configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that Webpack 5 will minify the project's code by default when in production
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: '`TerserPlugin` is a good place to start minification and should be used as
    the default option. There are, however, a couple of choices, such as `BabelMinifyPlugin`
    and `closureWebpackPlugin`.'
  prefs: []
  type: TYPE_NORMAL
- en: When trying a different minification plugin, ensure that the choice will also
    drop any dead code, similar to tree shaking, which we described earlier in this
    book. Something related to tree-shaking is shimming, which we'll discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: Shimming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shimming, or more specifically, `shim-loaders`. Now is a good time to explore
    this concept in detail since you'll need a firm grasp of it before you can move
    on.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler that Webpack uses can understand modules written in **ECMAScript**
    **2015**, **CommonJS**, or **AMD**. It should be noted that some third-party libraries
    may need global dependencies, for example, when using jQuery. These libraries
    may, in this case, need globals to be exported. This almost broken nature of the
    module is where shimming comes into effect.
  prefs: []
  type: TYPE_NORMAL
- en: Shimming can allow us to convert one language specification into another. In
    Webpack, this is usually done through dedicated loaders specific to your environment.
  prefs: []
  type: TYPE_NORMAL
- en: The principal concept behind Webpack is the use of modular development – isolated
    modules that are securely contained that don't rely on hidden or global dependencies –
    so it is important to note that the use of such dependencies should be sparse.
  prefs: []
  type: TYPE_NORMAL
- en: Shimming can be useful when you wish to polyfill browsers so that you can support
    multiple users. In this case, the polyfill only needs to be patched where needed
    and loaded on demand.
  prefs: []
  type: TYPE_NORMAL
- en: Shimming is related to patching but tends to take place in the browser, which
    makes it highly relevant to progressive web applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at progressive web applications in more detail
    – they are key to Webpack 5.
  prefs: []
  type: TYPE_NORMAL
- en: Progressive web applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes called PWAs, progressive web applications deliver a native application
    experience online. They have many contributing factors, the most notable of which
    is the ability for the application to function when offline, as well as online.
    To do this, service workers are utilized.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing your web app to work offline will mean you can provide functionality
    such as push notifications. These rich experiences will also be available to the
    web-based application through devices such as the service worker. This script
    will work in the background of a browser, regardless of whether the user is on
    the right page or not, and permit these same notifications or even background
    synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: PWAs offer the reach of the web but are fast and reliable, similar to desktop
    applications. They can also feel engaging, like mobile apps, and can offer the
    same immersive experience. This demonstrates a new level of quality for applications.
    They can also play a part in cross-platform compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Responsive design was the web's first push in this direction, but the push to
    make the internet more universal has led us to PWA. To leverage your application's
    potential, you should use a progressive approach. For more information, see this
    Google resource on the subject: [https://developers.google.com/web/progressive-web-apps/](https://developers.google.com/web/progressive-web-apps/).
  prefs: []
  type: TYPE_NORMAL
- en: When using Webpack, the service workers need to be registered so that you can
    start integrating desktop functionality into your web-based PWA. PWAs are not
    designed to be installed locally by the user; they work natively through web browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Service workers can be registered by adding the following to your code – in
    this example, this is an `index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'With this complete, run `npm build` – you should see the following output in
    the command-line window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, the application can be served with `npm start` in the command-line interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'A PWA should have a manifest, a service worker, and possibly a workbox to wrap
    and protect the service worker. For more information on the manifest, see [Chapter
    3](593298f3-f214-4726-9a04-28b4f89f2a31.xhtml), *Using Configurations and Options*.
    Workbox is a plugin that can be installed in the command line using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'An example configuration of the **Workbox** plugin can be seen here in a hypothetical
    `webpack.config.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The options inside the `{` braces will encourage the service workers to get
    to that point quickly and will not allow them to strangle previous service workers.
  prefs: []
  type: TYPE_NORMAL
- en: As your project becomes more complicated, you may consider using related task
    runners. Let's take a look at this in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating task runners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Task runners handle automation tasks such as code linting. Webpack is not designed
    for this purpose – no bundler is. However, using Webpack, we can benefit from
    the high level of focus that task runners offer while still having high-performance
    bundling.
  prefs: []
  type: TYPE_NORMAL
- en: While there is some overlap between task runners and bundlers, they can integrate
    well if approached correctly. In this section, we will explore integration techniques
    we can use for some of the most popular task runners out there.
  prefs: []
  type: TYPE_NORMAL
- en: Bundlers work by preparing JavaScript and other frontend code for deployment,
    transforming their format so that they're suitable for browser delivery. For example,
    it allows us to split JavaScript into chunks for lazy loading, which improves
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: Bundling may be challenging, but its results will remove a lot of the painstaking
    work of the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will show you how to integrate the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Gulp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocha
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Karma
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Gulp is probably the most well-known task runner, so let''s start with that
    first. It is utilized through the use of a dedicated file, much like the other
    two task runners. Here, the `gulpfile.js` file will handle how Webpack interplays
    with Gulp. Let''s take a look at how to integrate all of these task runners:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s take a look at the `gulpfile.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is all we have to do to use Gulp. Note the use of the `gulp.task` function,
    the `return` entry point, and the `.pipe(**gulp**.dest('dist/'));` output location.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the command-line code you can use to install Mocha:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: For more information, please visit the Webpack community repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the configuration file amendments you''ll need to make to
    the `karma.config.js` file to use Karma with Webpack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `webpack` and `webpackMiddleware` options have been left blank so that you
    can fill this content with your project's specific configuration. These options
    can be completely removed if you are not using them. For the sake of this example,
    we won't be.
  prefs: []
  type: TYPE_NORMAL
- en: These installation procedures will be some use to you if you wish to use them
    in your development environment, but GitHub is an increasingly more essential
    tool. We'll take a look at how it can play a key role in terms of development
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitHub, as you may already know, is a command-line code hosting platform that
    works well with Webpack. Much of the code and projects you will work with when
    using Webpack will be hosted through GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub is based on the Git version control system. The use of GitHub with Webpack
    5 allows some command-line operations to be used online.
  prefs: []
  type: TYPE_NORMAL
- en: A Git command-line instruction is typically made with the use of the `git` command
    before each new entry and before each command. Much of Webpack's content files
    are available through GitHub, and the GitHub Webpack page can be found here: [https://github.com/webpack/webpack](https://github.com/webpack/webpack).
    The development of Webpack 5 can be viewed here in terms of stages of progress,
    which can be interesting and allows you to anticipate its arrival better, should
    you need to upgrade your projects. The URL for this is [https://github.com/webpack/webpack/projects/5.](https://github.com/webpack/webpack/projects/5)
  prefs: []
  type: TYPE_NORMAL
- en: As a developer, you may have used GitHub often, but if you're a dedicated JavaScript
    developer, you may have limited experience. When working on Webpack projects,
    the GitHub platform offers a great deal of live and collaborative opportunities.
    Since version control and command-line functionality is provided, there is less
    of a need to perform software development locally. This is the primary reason
    why GitHub is so popular among the developer community and why it is becoming
    so fundamental as proof of a developer's work.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub allows developers to work together on projects. When working with bundled
    projects, this is even more useful as some command-line operations can be run
    online. GitHub also allows Agile workflows or project management interfaces. Agile
    methodologies allow teams to collaborate while individuals self-organize through
    a dedicated digital platform.
  prefs: []
  type: TYPE_NORMAL
- en: When using GitHub, you may be working with other people's code. This may include
    frameworks of code that have been developed by teams. This can become very difficult,
    even for the most seasoned developers, if they're unfamiliar with the logic being
    used. This brings us to the subject of boilerplate, which is usually standard
    or well-documented code, but nonetheless, you may want to extract this from the
    sections of a project you wish to utilize. This is where this extraction process
    starts to become very useful.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting boilerplate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Boilerplate code is sections of code that need to be included in various places,
    but with little or no alterations made to them. When using languages that are
    considered verbose, it is often necessary to write exhaustive amounts of code.
    This large section of code is called boilerplate. It has essentially the same
    purpose as a framework or library, and the terms are often conflated or mutually
    acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: The Webpack community offers boilerplate installations, such as the combined
    installation of multiple common dependencies such as prerequisites and loaders.
    There are multiple versions of these boilerplates, and the use of these can expedite
    a build. Please search the Webpack Community pages ([https://webpack.js.org/contribute/](https://webpack.js.org/contribute/))
    or Webpack's GitHub page ([https://github.com/webpack-contrib](https://github.com/webpack-contrib))
    for examples.
  prefs: []
  type: TYPE_NORMAL
- en: This being said, there will be times when only part of the boilerplate is required.
    For this, extracting the boilerplate functionality of Webpack may be required.
  prefs: []
  type: TYPE_NORMAL
- en: Webpack, while using its minification method, allows boilerplate to be extracted;
    that is, only the elements of the boilerplate you need are included in the bundle.
    This is an automated process that's done during the compilation process.
  prefs: []
  type: TYPE_NORMAL
- en: Minification is the key way in which Webpack 5 offers this extraction process
    and it's one of the more salient ways in which a bundler of this type can be used.
    There is another key process that is highly useful and native to Webpack 5\. It
    takes us in a different direction regarding how bundles are built but is something
    that will no doubt follow on from a complex or custom build, such as a project
    that began by boilerplate being extracted. This process is known as Module Federation.
  prefs: []
  type: TYPE_NORMAL
- en: Module Federation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Module Federation has been described as a game-changer in the JavaScript architecture.
    It essentially allows applications to run code from remotely stored modules between
    servers while part of a bundled application.
  prefs: []
  type: TYPE_NORMAL
- en: Some developers may be aware of a technology called **GraphQL**. It is essentially
    a solution for sharing code between applications, developed by a company called
    Apollo. Federated Modules are a feature of Webpack 5 that allows this to happen
    between bundled applications.
  prefs: []
  type: TYPE_NORMAL
- en: For a long time, the best compromise was the use of externals of the `DllPlugin`,
    which relied on a centralized external dependency file, However, this isn't great
    for organic development, convenience, or large-scale projects.
  prefs: []
  type: TYPE_NORMAL
- en: With Module Federation, JavaScript applications can dynamically load code between
    applications and share dependencies. If an application is using a federated module
    as part of its build but requires a dependency to serve the federated code, Webpack
    can also download that dependency from the origin of the federated build. So,
    the federation will effectively provide a map of where Webpack 5 can find the
    required dependency code.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is some terminology to consider when it comes to federation: remote and
    host. The term remote refers to the application or modules that are loaded into
    the user''s application, while the host refers to the application that the user
    is visiting through their browser at runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: The federation method is designed for standalone builds and can be deployed
    independently or in your own repository. In this sense, they can be hosted bi-directionally,
    effectively serving as the host of remote content. This means that a single project
    could potentially switch between hosting orientations throughout the user's journey.
  prefs: []
  type: TYPE_NORMAL
- en: Building our first federated application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start by looking at three standalone applications, identified as the first,
    second, and third applications, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The first application in our system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin by configuring the first application:'
  prefs: []
  type: TYPE_NORMAL
- en: We are going to be using the `<app>` container in the HTML. This first app is
    a remote application in the federation system and is, therefore, to be consumed
    by other applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To expose the application, we will use the `AppContainer` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This first application will also consume a component from two other federated
    applications in the system.
  prefs: []
  type: TYPE_NORMAL
- en: To allow this application to consume components, the remote scope will need
    to be specified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All these steps should be followed as specified in the preceding code block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the HTML segment of the build:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows the `<head>` element of the HTML. `app_one_remote.js`
    connects the runtime and provisional orchestration layer at runtime. It is specifically
    designed for entry points. These are example URLs and you can use your own locations.
    It's important to note that this example is a very low-memory example and that
    your build may be much larger, but it is good enough to understand this principle.
  prefs: []
  type: TYPE_NORMAL
- en: 'To consume code from a remote application, the first application has a web
    page that consumes a dialog component from the second application, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start by exporting the default HTML page we are using and set up the
    router, which is done as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code block shows how the code works; it will export the default
    routes from each page in the system we are developing.
  prefs: []
  type: TYPE_NORMAL
- en: This system is part of three applications, the second of which we will look
    at now.
  prefs: []
  type: TYPE_NORMAL
- en: The second application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The system that we''re building is comprised of three applications. This application
    will expose the dialogue that enables the first application in this sequence to
    consume it. The second application, however, will consume the first application''s `<app>` element
    identifier. Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by configuring the second application. This means we need to
    specify `app-one` as a remote application and simultaneously demonstrate bi-directional
    hosting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'For the sake of consumption, the following is what the root application looks
    like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to set up the code so that we can export the default application.
    The following is an example of what the default page should look like, when using
    the dialogue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now, we need to export the default `MainPage`. This is done using the third
    application in our system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The third application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at our third and final application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The third application in our system will be exporting a default `MainPage`.
    This is done through the following script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the third application looks similar to the previous ones, except
    it doesn't consume `<app>` from the first application. This application is standalone
    and has no navigation and as such, does not specify any remote federated components.
  prefs: []
  type: TYPE_NORMAL
- en: When viewing the system in a browser, you should pay close attention to the
    network tab. The code can be federated across three different servers (potentially)
    and three different bundles (naturally).
  prefs: []
  type: TYPE_NORMAL
- en: This component permits a great deal of dynamism in your builds, but you may
    want to avoid federating the whole application container unless you hope to utilize
    **server-side rendering (SSR)** or progressive loading as, otherwise, loading
    times could be severely harmed.
  prefs: []
  type: TYPE_NORMAL
- en: Loading issues are a natural concern, but one issue that would ordinarily cause
    larger project sizes is the potential duplication of repetitious code, which is
    the result of using multiple parallel bundles. Let's take a look at how Webpack
    5 handles that issue.
  prefs: []
  type: TYPE_NORMAL
- en: Duplication issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One key feature of Webpack is removing duplicated code. In the federation environment,
    host applications serve the remote application with dependencies. In the absence
    of a sharable dependency, the remote application can download its own automatically.
    This is a kind of built-in redundancy fail-safe mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Manually adding vendor code can be tedious at scale but the federation feature
    allows us to create automation scripts. This is the developer's choice, but it
    may be an excellent opportunity for you to be able to test your knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already alluded to SSR. You should be aware that server builds require
    a `commonjs` library target so that they can be used with Webpack federation.
    This can be done with S3 streaming, ESI, or by automating npm publish so that
    you can consume server variants. The following code shows an example of including `commonjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You may wish to use the `target: "node"` method to avoid URLs in favor of file
    paths. This will allow SSR with the same code base but different configurations
    when building for Node.js. This will also mean that separate builds will become
    separate deployments.'
  prefs: []
  type: TYPE_NORMAL
- en: Webpack, as a company, is open to demonstrating SSR examples that you, as part
    of a community of developers, may have made. They will gladly accept pull requests
    through their GitHub pages since they have the bandwidth to and benefit from the
    exposure while the process is so new.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you looked at the process you might use to deploy a project
    online. We went over the installation and setup process, as well as tree shaking.
  prefs: []
  type: TYPE_NORMAL
- en: First, we looked at the production and development modes, the nature of each
    environment, and how they utilize Webpack. Then, we looked at shimming, the best
    way to use it, how it works so that we can patch code, its relationship with task
    runners, and their integration with bundlers such as Webpack.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you should be able to extract boilerplate, integrate various task runners, and
    know how to use GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss hot module replacement, and live coding,
    and get to grips with some serious tutorials.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is meant by boilerplate?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does tree shaking do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is meant by the term shimming?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of progressive web applications?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What do task runners do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What three task runners were mentioned in this chapter?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Webpack's compiler can understand modules written in which three specifications?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Webpack content files and the GitHub Webpack page can be found here: [https://github.com/webpack/webpack](https://github.com/webpack/webpack).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Webpack 5 can be viewed here in terms of its stages of progress: [https://github.com/webpack/webpack/projects/5.](https://github.com/webpack/webpack/projects/5)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Webpack community pages: [https://webpack.js.org/contribute/](https://webpack.js.org/contribute/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Webpack's GitHub pages: [https://github.com/webpack-contrib](https://github.com/webpack-contrib)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
