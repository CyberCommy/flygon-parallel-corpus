- en: 5\. Line Traces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will be the start of a new game project called Dodgeball, where
    we will be creating a game from scratch that features mechanics based on collision
    concepts. In this chapter, you will modify the Third Person Template project to
    give it a top-down perspective. Then, you will be introduced to line traces, a
    key concept in game development, and learn about their potential and use cases.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to use UE4's built-in Line Trace
    feature (also known as Raycasts or Raytraces in other game development tools)
    by executing different types of line traces; creating your own trace channels;
    and modifying an object's response to each trace channel.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we learned how we can reproduce the Third Person Template
    project offered to us by the Unreal Engine team in order to understand some of
    the basic concepts of UE4's workflow and framework.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will start creating another game from scratch. In this
    game, the player will control a character from a top-down point of view (*similar
    to games such as Metal Gear Solid 1, 2, and 3*). A top-down perspective implies
    that the player controls a character that is seen as if it was being looked down
    upon, usually with the camera rotation being fixed (the camera doesn't rotate).
    In our game, the player character must go from point A to point B without being
    hit by dodgeballs that are being thrown at the player by the enemies that are
    spread throughout the level. The levels in this game will be maze-like in nature,
    and the player will have multiple paths to choose from, all of which will have
    enemies trying to throw dodgeballs at the player.
  prefs: []
  type: TYPE_NORMAL
- en: The specific topics we'll be approaching in this chapter will be Line Traces
    (Single and Multi), Sweep Traces, Trace Channels, and Trace Responses. In the
    first section, we begin by getting to know what *collision* is in the world of
    video games.
  prefs: []
  type: TYPE_NORMAL
- en: Collision
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A collision is basically a point at which two objects come into contact with
    each other (for example, two objects colliding, an object hitting a character,
    a character walking into a wall, and so on). Most game development tools have
    their own set of features that allow for collision and physics to exist inside
    the game. This set of features is called a **Physics Engine**, which is responsible
    for everything related to collisions. It is responsible for executing Line Traces,
    checking whether two objects are overlapping each other, blocking each other's
    movement, bouncing off of a wall, and much more. When we ask the game to execute
    or notify us of these collision events, the game is essentially asking the Physics
    Engine to execute it and then show us the results of these collision events.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Dodgeball` game you will be building, examples of where collision needs
    to be taken into account include checking whether enemies are able to see the
    player (which will be achieved using a Line Trace, covered in this chapter), simulating
    physics on an object that will behave just like a dodgeball, checking whether
    anything is blocking the player character's movement, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: Collision is one of the most important aspects of most games, so understanding
    it is crucial in order to get started with game development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start building our collision-based features, we will first need to
    set up our new `Dodgeball` project in order to support the game mechanics we will
    be implementing. This process starts with the steps described in the next section:
    *Project Setup*.'
  prefs: []
  type: TYPE_NORMAL
- en: Project Setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin this chapter by creating our Unreal Engine project:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Launch` UE4\. Select the `Games` project category, then press `Next`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `Third Person template`, then press `Next`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the first option is set to `C++` and not `Blueprint`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the location of the project according to your preference and name your
    project `Dodgeball`, then press `Create Project`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When the project is done being generated, you should see the following on your screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1: Dodgeball project loaded up'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_05_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.1: Dodgeball project loaded up'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the code has been generated and the project opens up, close the UE4 editor
    and open the files of the generated third-person Character class, `DodgeballCharacter`,
    in Visual Studio, as shown in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.2: Files generated in Visual studio'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_05_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.2: Files generated in Visual studio'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned before, your project is going to have a top-down perspective. Given
    that we're starting this project from the Third Person Template, we'll have to
    change a few things before we turn this into a top-down game. This will mainly
    involve changing some lines of code in the existing Character class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.01: Converting DodgeballCharacter to a Top-Down Perspective'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you'll be performing the necessary changes to your generated
    `DodgeballCharacter` class. Remember, it currently features a third-person perspective,
    where the rotation of the character is dictated by the player's input (*namely
    the mouse or right analog stick*).
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you will change this to a top-down perspective, which remains
    the same regardless of the player's input, where the camera always follows the
    character from above.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Head to the `DodgeballCharacter` class's constructor and update the `CameraBoom`
    properties, as mentioned in the following steps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change `TargetArmLength`, which is a property of `CameraBoom`, to `900.0f`,
    in order to add some distance between the camera and the player:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add a line that sets the relative pitch to `-70`º, using the `SetRelativeRotation`
    function, so that the camera looks down at the player. The `FRotator` constructor''s
    parameters are the *pitch*, *yaw*, and *roll*, respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Change `bUsePawnControlRotation` to `false`, so that the camera''s rotation
    isn''t changed by the player''s movement input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a line that sets `bInheritPitch`, `bInheritYaw`, and `bInheritRoll` to
    `false`, so that the camera''s rotation isn''t changed by the character''s orientation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: After we've made these modifications, we're going to remove the character's
    ability to jump (we don't want the player to escape from the dodgeballs that easily)
    and to rotate the camera from the player's rotation input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the `SetupPlayerInputComponent` function in the `DodgeballCharacter''s`
    source file and remove the following lines of code in order to remove the ability
    to jump:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the following lines in order to remove the player''s rotation input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This step is optional, but in order to keep your code clean, you should remove
    the declarations and implementations of the `TurnAtRate` and `LookUpAtRate` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after you've made these changes, run your project from Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When the editor has loaded, play the level. The camera''s perspective should
    look like this and should not rotate based on the player''s input or the character''s rotation:![Figure
    5.3: Locked camera rotation to a top-down perspective'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_05_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.3: Locked camera rotation to a top-down perspective'
  prefs: []
  type: TYPE_NORMAL
- en: And that concludes the first exercise of this chapter, and the first step to
    your new project, `Dodgeball`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you will be creating the `EnemyCharacter` class. This character will
    be the enemy that throws dodgeballs at the player while the player is in view.
    But the question that arises here is this: how will the enemy know whether it
    can see the player character or not?'
  prefs: []
  type: TYPE_NORMAL
- en: That will be achieved with the power of **Line Traces** (also known as **Raycasts**
    or **Raytraces**), which you will be looking at in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Line Traces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important features of any game development tool is its ability
    to execute Line Traces. These are available through the Physics Engine that the
    tool is using.
  prefs: []
  type: TYPE_NORMAL
- en: Line Traces are a way of asking the game to tell you whether anything stands
    between two points in the game world. The game will *shoot a ray* between those
    two points, specified by you, and return the objects that were hit (if any), where
    they were hit, at what angle, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following figure, you can see a representation of a Line Trace where
    we assume object `1` is ignored and object `2` is detected, due to their Trace
    Channel properties (further explained in the following paragraphs):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4: A Line Trace being executed from point A to point B'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_05_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.4: A Line Trace being executed from point A to point B'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 5.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: The dashed line represents the Line Trace before it hits an object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The arrows represent the direction of the Line Trace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dotted line represents the Line Trace after it hits an object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The striped circle represents the Line Trace's impact point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The big squares represent two objects that are in the path of the Line Trace
    (objects `1` and `2`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We notice that only object `2` was hit by the Line Trace and not object `1`,
    although it is also in the path of the Line Trace. This is due to assumptions
    made about object `1`'s Trace Channel properties, which are talked about later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Line Traces are used for many game features, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether a weapon hits an object when it fires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Highlighting an item that the player can interact with when the character looks
    at it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotating the camera around the player character automatically as it goes around corners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A common and important feature of Line Traces is **Trace Channels**. When you
    execute a Line Trace, you may want to check only specific types of objects, which
    is what Trace Channels are for. They allow you to specify filters to be used when
    executing a Line Trace so that it doesn''t get blocked by unwanted objects. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: You may want to execute a Line Trace only to check for objects that are visible.
    These objects would block the `Visibility` Trace Channel. For instance, invisible
    walls, which are invisible pieces of geometry used in games to block the player's
    movement, would not be visible and therefore would not block the `Visibility`
    Trace Channel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may want to execute a Line Trace only to check for objects that can be interacted
    with. These objects would block the `Interaction` Trace Channel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may want to execute a Line Trace only to check for pawns that can move around
    the game world. These objects would block the `Pawn` Trace Channel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can specify how different objects react to different Trace Channels so that
    only some objects block specific Trace Channels and others ignore them. In our
    case, we want to know whether anything stands between the enemy and the player
    character, so that we know whether the enemy can see the player. We will be using
    Line Traces for this purpose, by checking for anything that blocks the enemy's
    line of sight to the player character, using a `Tick` event.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will be creating the `EnemyCharacter` class using C++.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the EnemyCharacter C++ class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our `Dodgeball` game, the `EnemyCharacter` class will constantly be looking
    at the player character, if they're within view. This is the same class that will
    later throw dodgeballs at the player; however, we'll leave that to the next chapter.
    In this chapter, we will be focusing on the logic that allows our enemy character
    to look at the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the `Content Browser` inside the editor and select `New C++ Class`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the `Character` class as the parent class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new class `EnemyCharacter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After you''ve created the class and opened its files in Visual Studio, let''s
    add the `LookAtActor` function declaration in its `header` file. This function
    should be `public`, not return anything and only receive the `AActor* TargetActor`
    parameter, which will be the actor it should be facing. Have a look at the following
    code snippet, which shows this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Even though we only want the enemy to look at the player's character, in order
    to execute good software development practices, we're going to abstract this function
    a bit more and allow `EnemyCharacter` to look at any Actor, because the logic
    that allows an Actor to look at another Actor or at the player character will
    be exactly the same.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, you should not create unnecessary restrictions when writing code.
    If you can write similar code while at the same time allowing more possibilities,
    you should do so, if that doesn't overcomplicate the logic of your program.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on ahead, if `EnemyCharacter` can't see the `Target` `Actor`, it shouldn't
    be looking at it. In order to check whether the enemy can see the Actor, it should
    be looking at the `LookAtActor` function which will call another function, the
    `CanSeeActor` function. This is what you'll be doing in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.02: Creating the CanSeeActor Function, Which Executes Line Traces'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will create the `CanSeeActor` function, which will return
    whether the enemy character can see the given Actor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the declaration for the `CanSeeActor` function in the header file of
    the `EnemyCharacter` class, which will return a `bool` and receive a `const Actor*
    TargetActor` parameter, which is the Actor we want to look at. This function will
    be a `const` function, because it doesn''t change any of the class''s attributes,
    and the parameter will also be `const` because we won''t need to modify any of
    its properties; we''ll only need to access them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's get to the fun part, which is executing the Line Trace.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to call functions related to line tracing, we''ll have to fetch the
    enemy''s current world with the `GetWorld` function. However, we haven''t included
    the `World` class in this file, so let''s do so in the following step:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `GetWorld` function is accessible to any Actor and will return the `World`
    object that the Actor belongs to. Remember, the world is necessary in order to
    execute the Line Trace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `EnemyCharacter` source file and find the following code line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following line right after the preceding line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create the implementation of the `CanSeeActor` function in the `EnemyCharacter`
    source file, where you''ll start by checking whether our `TargetActor` is a `nullptr`.
    If it is, we return `false`, given that we have no valid Actor to check our sight
    to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Next, before we add our Line Trace function call, we need to set up some necessary
    parameters; we will be implementing these in the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the previous `if` statement, create a variable to store all the necessary
    data relative to the results of the Line Trace. Unreal already has a built-in
    type for this called the `FHitResult` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is the variable we will send to our Line Trace function, which will populate
    it with the relevant info of the executed Line Trace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create two `FVector` variables, for the `Start` and `End` locations of our
    Line Trace, and set them to our enemy''s current location and our target''s current
    location, respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, set the Trace Channel we wish to compare against. In our case, we want
    to have a `Visibility` Trace Channel specifically designated to indicate whether
    an object blocks another object''s view. Luckily for us, such a Trace Channel
    already exists in UE4, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `ECollisionChannel` `enum` represents all the possible Trace Channels available
    to compare against. We will be using the `ECC_Visibility` value, which represents
    the `Visibility` Trace Channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve set up all our necessary parameters, we can finally call the
    `LineTrace` function, `LineTraceSingleByChannel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This function will consider the parameters we send it, execute the Line Trace,
    and return its results by modifying our `Hit` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Before we continue, there are still a couple more things we need to consider.
  prefs: []
  type: TYPE_NORMAL
- en: If the Line Trace starts from within our enemy character, which is what will
    happen in our case, that means it's very likely that the Line Trace will simply
    hit our enemy character immediately and just stop there, because our character
    might block the `Visibility` Trace Channel. In order to fix that, we need to tell
    the Line Trace to ignore it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the built-in `FCollisionQueryParams` type, which allows us to give even
    more options to our Line Trace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, update the `Line Trace` to ignore our enemy, by adding itself to the list
    of Actors to ignore:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We should also add our target to our list of Actors to ignore because we don't
    want to know whether it blocks the `EnemySight` channel; we just simply want to
    know whether something between the enemy and the player character blocks that
    channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the Target Actor to the list of Actors to be ignored as shown in the following
    code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, send our `FCollisionQueryParams` to the Line Trace by adding it as the
    last parameter of the `LineTraceSingleByChannel` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Finalize our `CanSeeActor` function, by returning whether the Line Trace hits
    anything or not. We can do that by accessing our `Hit` variable and checking whether
    there was a blocking hit, using the `bBlockingHit` property. If there was, that
    means we can''t see our `TargetActor`. This can be achieved with the following
    code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we won''t need any more information from the `Hit` result, other than
    whether there was a blocking hit, the `Hit` variable can give us much more information
    on the Line Trace, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Information on the Actor that was hit by the Line Trace (`nullptr` if no Actor
    was hit), by accessing the `Hit.GetActor()` function
  prefs: []
  type: TYPE_NORMAL
- en: Information on the Actor component that was hit by the Line Trace (`nullptr`
    if no Actor component was hit), by accessing the `Hit.GetComponent()` function
  prefs: []
  type: TYPE_NORMAL
- en: Information on the location of the hit by accessing the `Hit.Location` variable
  prefs: []
  type: TYPE_NORMAL
- en: The distance of the hit can be found by accessing the `Hit.Distance` variable
  prefs: []
  type: TYPE_NORMAL
- en: The angle at which the Line Trace hit the object, which can be found by accessing
    the `Hit.ImpactNormal` variable
  prefs: []
  type: TYPE_NORMAL
- en: Finally, our `CanSeeActor` function is complete. We now know how to execute
    a Line Trace and we can use it for our enemy's logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'By completing this exercise, we have finished the `CanSeeActor` function; we
    can now get back to the `LookAtActor` function. However, there is something we
    should look at first: visualizing our Line Trace.'
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing the Line Trace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When creating new logic that makes use of Line Traces, it is very useful to
    actually visualize the Line Trace while it's being executed, which is something
    that the Line Trace function doesn't allow you to do. In order to do that, we
    must use a set of helper debug functions that can draw objects dynamically at
    runtime, such as lines, cubes, spheres, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s then add a visualization of our Line Trace. The first thing we must
    do in order to use the debug functions is to add the following `include` below
    our last `include` line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We will want to call the `DrawDebugLine` function in order to visualize the
    Line Trace, which needs the following inputs, very similar to the ones received
    by the Line Trace function:'
  prefs: []
  type: TYPE_NORMAL
- en: The current `World`, which we will supply with the `GetWorld` function
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Start` and `End` points of the line, which will be the same as the `LineTraceSingleByChannel`
    function
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The desired color of the line in the game, which can be set to `Red`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we can add the `DrawDebugLine` function call below our Line Trace function
    call as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This will allow you to visualize the Line Trace as it is being executed, which
    is very useful.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you feel the need for it, you can also specify more of the visual Line Trace's
    properties, such as its lifetime and thickness.
  prefs: []
  type: TYPE_NORMAL
- en: There are many `DrawDebug` functions available that will draw cubes, spheres,
    cones, donuts, and even custom meshes.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can both execute and visualize our Line Trace, let's use the `CanSeeActor`
    function, which we created in the last exercise, inside the `LookAtActor` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.03: Creating the LookAtActor Function'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will be creating the definition of our `LookAtActor` function,
    which will change the enemy's rotation so that it faces the given Actor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the `LookAtActor` function definition in the `EnemyCharacter` source file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start by checking whether our `TargetActor` is a `nullptr` and returns nothing
    immediately if it is (because it''s not valid), as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we want to check whether we can see our Target Actor, using our `CanSeeActor`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If this `if` statement is true, that means we can see the Actor, and we will
    set our rotation in such a way that we are facing that Actor. Luckily for us,
    there''s already a function within UE4 that allows us to do that: the `FindLookAtRotation`
    function. This function will receive as input two points in the level, point A
    (the `Start` point) and point B (the `End` point), and return the rotation that
    the object at the start point must have in order to face the object at the end
    point.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use this function, include `KismetMathLibrary` as shown in the
    following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FindLookAtRotation` function must receive a `Start` and `End` point, which
    will be our enemy''s location and our Target Actor''s location, respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, set your enemy character''s rotation to the same value as our `LookAtRotation`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: And that's it for the `LookAtActor` function.
  prefs: []
  type: TYPE_NORMAL
- en: Now the last step is to call the `LookAtActor` function inside the Tick event
    and to send the player character as the `TargetActor`, the Actor that we want
    to look at.
  prefs: []
  type: TYPE_NORMAL
- en: 'For us to fetch the character that is currently being controlled by the player,
    we can do so using the `GameplayStatics` object. As with other UE4 objects, we
    must first include them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, head to your Tick function''s body and call the `GetPlayerCharacter`
    function from `GameplayStatics`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This function receives as input:'
  prefs: []
  type: TYPE_NORMAL
- en: A World context object, which is, essentially, an object that belongs to our
    current World, used to let the function know which World object to access. This
    World context object can simply be the `this` pointer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A player index, which, given that our game is supposed to be a single-player
    game, we can safely assume to be `0` (the first player).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, call the `LookAtActor` function, sending the player character that we
    just fetched:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The last step of this exercise is to compile your changes in Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that you've completed this exercise, your `EnemyCharacter` class has all
    the necessary logic to face the player character, if it's within view, and we
    can start creating the `EnemyCharacter` Blueprint class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the EnemyCharacter Blueprint Class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have finished the logic for our `EnemyCharacter` C++ class, we
    must create our blueprint class that derives from it:'
  prefs: []
  type: TYPE_NORMAL
- en: Open our project in the Editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the `Blueprints` folder inside the `ThirdPersonCPP` folder, in the `Content
    Browser`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Right-click* and select the option to create a new blueprint class.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the `All Classes` tab near the bottom of the `Pick Parent Class` window,
    search for our `EnemyCharacter` C++ class, and select it as the parent class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the Blueprint class `BP_EnemyCharacter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Blueprint class, select the `SkeletalMeshComponent` (called `Mesh`)
    from the `Components` tab, and set its `Skeletal Mesh` property to `SK_Mannequin`
    and its `Anim Class` property to `ThirdPerson_AnimBP`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the *Yaw* of `SkeletalMeshComponent` to `-90º` (on the *z-axis*) and
    its position on the *z-axis* to `-83` units.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After you've set up the Blueprint class, its mesh setup should look very similar
    to that of our `DodgeballCharacter` Blueprint class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag an instance of the `BP_EnemyCharacter` class to your level, in a location
    near an object that can block its line of sight, such as this location (the selected
    character is `EnemyCharacter`):![Figure 5.5: Dragging the BP_EnemyCharacter class
    into the level'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_05_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.5: Dragging the BP_EnemyCharacter class into the level'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can finally play the game and verify that our enemy does look at our
    player character whenever it''s within view:![Figure 5.6: Enemy character with
    a clear view of the player using a Line Trace'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_05_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.6: Enemy character with a clear view of the player using a Line Trace'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also see that the enemy stops seeing the player whenever it''s not within
    view, as shown in *Figure 5.7*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.7: Enemy losing sight of the player'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_05_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.7: Enemy losing sight of the player'
  prefs: []
  type: TYPE_NORMAL
- en: And that concludes our `EnemyCharacter`'s logic. In the next section, we will
    be looking at Sweep Traces.
  prefs: []
  type: TYPE_NORMAL
- en: Sweep Traces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we continue with our project, it is important to know about a variant
    of the Line Trace, which is the **Sweep Trace**. Although we won't be using these
    in our project, it is important to know about them and how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: While the Line Trace basically *shoots a ray* between two points, the Sweep
    Trace will simulate *throwing an object* between two points in a straight line.
    The object that is being *thrown* is simulated (doesn't actually exist in the
    game) and can have various shapes. In the Sweep Trace, the `Hit` location will
    be the first point at which the virtual object (which we will call **Shape**)
    hits another object, if it were thrown from the start point to the end point.
    The shapes of the Sweep Trace can be either a box, a sphere, or a capsule.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a representation of a Sweep Trace from point `A` to point `B`, where
    we assume that object `1` is ignored due to its Trace Channel properties, using
    a box shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8: Representation of a Sweep Trace'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_05_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.8: Representation of a Sweep Trace'
  prefs: []
  type: TYPE_NORMAL
- en: 'From *Figure 5.8*, we notice the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A Sweep Trace, using a box shape, being executed from point A to point B.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dashed boxes represent the Sweep Trace before it hits an object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dotted boxes represent the Sweep Trace after it hits an object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The striped circle represents the Sweep Trace's impact point with object `2`,
    which is the point at which the Sweep Trace Box shape's surface and object `2`'s
    surface collide with each other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The big squares represent two objects that are in the path of the Line Sweep
    Trace (objects `1` and `2`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object `1` is ignored in the Sweep Trace due to assumptions based on its Trace
    Channel properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sweep Traces are more useful than regular Line Traces in a few situations.
    Let''s take the example of our enemy character, which can throw dodgeballs. If
    we wanted to add a way for the player to constantly visualize where the next dodgeball
    that the enemy throws will land, that could be better achieved with a Sweep Trace:
    we would do a Sweep Trace with the shape of our dodgeball (a sphere) toward our
    player, check the impact point, and show a sphere on that impact point, which
    would be visible to the player. If the Sweep Trace hits a wall or a corner somewhere,
    the player would know that, if the enemy were to throw a dodgeball at that moment,
    that''s where it would hit first. You could use a simple Line Trace for the same
    purpose, but the setup would have to be rather complex in order to achieve the
    same quality of results, which is why Sweep Traces are a better solution in this
    case.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's now take a quick look at how we can do a Sweep Trace in code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.04: Executing a Sweep Trace'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will implement a Sweep Trace in code. Although we won't
    be using it for our project, by performing this exercise, you will become familiar
    with such an operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the end of the `CanSeeActor` function created in the previous sections
    and follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The function responsible for the Sweep Trace is `SweepSingleByChannel`, which
    is available within UE4 and requires the following parameters as inputs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An `FHitResult` type, to store the results of the sweep (we already have one
    of these, so there''s no need to create another variable of this type):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`Start` and `End` points of the sweep (we already have both of these, so there''s
    no need to create another variable of this type):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the intended rotation of the shape, which is in the form of an `FQuat`
    type (representing a quaternion). In this case, it''s set to a rotation of `0`
    on all axes, by accessing the `FQuat`''s `Identity` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, use the intended Trace Channel to compare it against (we already have
    one of these, so there''s no need to create another variable of this type):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, use the shape of a box for the Sweep Trace by calling the `FcollisionShape`
    `MakeBox` function and supplying it with the radius (on all three axes) of the
    box shape we want. This is shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, call the `SweepSingleByChannel` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: With these steps completed, we finish our exercise on Sweep Traces. Given that
    we won't be using Sweep Traces in our project, you should comment out the `SweepSingleByChannel`
    function, so that our `Hit` variable doesn't get modified and lose the results
    from our Line Trace.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've concluded the segment on Sweep Traces, let's get back to our
    `Dodgeball` project and learn how to change an object's response to a Trace Channel.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the Visibility Trace Response
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our current setup, every object that is visible blocks the `Visibility`
    Trace Channel; however, what if we wanted to change whether an object blocks that
    channel completely? In order to do this, we must change a component''s response
    to that channel. Have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We select the cube that we''ve been using to block the enemy''s sight in our
    level as shown in *Figure 5.9*:![Figure 5.9: Default spawn of the character'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_05_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.9: Default spawn of the character'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you go to the `Collision` section of this object''s `Details Panel` (its
    default place in the `Editor`''s interface):![Figure 5.10: Collision tab in the
    Details Panel in Unreal'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_05_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.10: Collision tab in the Details Panel in Unreal'
  prefs: []
  type: TYPE_NORMAL
- en: Here, you'll find several collision-related options. The one we want to pay
    attention to right now is the `CollisionPresets` option. Its current value is
    `Default`; however, we want to change it according to our own preferences, so
    we will click on the drop-down box and change its value to `Custom`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you do this, you''ll notice a whole group of new options pops up:![Figure
    5.11: Collision Preset set to Custom'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_05_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.11: Collision Preset set to Custom'
  prefs: []
  type: TYPE_NORMAL
- en: This group of options allows you to specify how this object responds to Line
    Traces and object collision, and the type of collision object it is.
  prefs: []
  type: TYPE_NORMAL
- en: The option you should be paying attention to is `Visibility`. You'll notice
    it's set to `Block`, but that you can also set it to `Overlap` and `Ignore`.
  prefs: []
  type: TYPE_NORMAL
- en: Right now, the cube is blocking the `Visibility` trace channel, which is why
    our enemy can't see the character when it's behind this cube. However, if we change
    the object's response to the `Visibility` Trace Channel to either `Overlap` or
    `Ignore`, the object will no longer block Line Traces that check for visibility
    (which is the case for the Line Trace you've just written in C++).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change the cube''s response to the `Visibility` channel to `Ignore`,
    and then play the game. You''ll notice that the enemy is still looking toward
    the player character, even when it''s behind the cube:![Figure 5.12: Enemy character
    looking through an object at the player'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_05_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.12: Enemy character looking through an object at the player'
  prefs: []
  type: TYPE_NORMAL
- en: This is because the cube no longer blocks the `Visibility` Trace Channel, and
    so the Line Trace the enemy is executing no longer hits anything when trying to
    reach the player character.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've seen how we can change an object's response to a specific Trace
    Channel, let's change the cube's response to the `Visibility` channel back to `Block`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there''s one thing that''s worth mentioning: if we were to set the
    cube''s response to the `Visibility` channel to `Overlap`, instead of `Ignore`,
    the result would be the same. But why is that, and what is the purpose of having
    these two responses? In order to explain that, we''ll look at Multi Line Traces.'
  prefs: []
  type: TYPE_NORMAL
- en: Multi Line Traces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While using the `CanSeeActor` function in *Exercise 5.02*, *Creating the CanSeeActor
    Function, Which Executes Line Traces*, you might have wondered to yourself about
    the name of the Line Trace function we used, `LineTraceSingleByChannel`, specifically
    about why it used the word *Single*. The reason for that is because you can also
    execute `LineTraceMultiByChannel`.
  prefs: []
  type: TYPE_NORMAL
- en: But how do these two Line Traces differ?
  prefs: []
  type: TYPE_NORMAL
- en: While the Single Line Trace will stop checking for objects that block it after
    it hits an object, and tell us that was the object that it hit, the Multi Line
    Trace can check for any objects that are hit by the same Line Trace.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Single Line Trace will:'
  prefs: []
  type: TYPE_NORMAL
- en: Ignore the objects that have their response set to either `Ignore` or `Overlap`
    on the Trace Channel being used by the Line Trace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stop when it finds an object that has its response set to `Block`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, instead of ignoring objects that have their response set to `Overlap`,
    the Multi Line Trace will add them as objects that were found during the Line
    Trace, and only stop when it finds an object that blocks the desired Trace Channel
    (*or when it reaches the end point*). In the next figure, you''ll find an illustration
    of a Multi Line Trace being executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13: A Multi Line Trace being executed from point A to point B'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_05_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.13: A Multi Line Trace being executed from point A to point B'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 5.13*, we notice the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The dashed line represents the Line Trace before it hits an object that blocks
    it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dotted line represents the Line Trace after it hits an object that blocks
    it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The striped circles represent the Line Trace's impact points, only the last
    one of which is a blocking hit in this case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only difference between the `LineTraceSingleByChannel` and the `LineTraceMultiByChannel`
    functions, when it comes to their inputs, is that the latter must receive a `TArray<FHitResult>`
    input, instead of a single `FHitResult`. All other inputs are the same.
  prefs: []
  type: TYPE_NORMAL
- en: Multi Line Traces are very useful when simulating the behavior of bullets with
    strong penetration that can go through several objects before stopping completely.
    Keep in mind that you can also do Multi Sweep Traces by calling the `SweepMultiByChannel`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Another thing about the `LineTraceSingleByChannel` function that you might be
    wondering about is the `ByChannel` portion. This distinction has to do with using
    a Trace Channel, as opposed to the alternative, which is an Object Type. You can
    do a Line Trace that uses Object Types instead of Trace Channels by calling the
    `LineTraceSingleByObjectType` function, also available from the World object.
    Object Types are related to topics we will be covering in the next chapter, so
    we won't be going into detail on this function just yet.
  prefs: []
  type: TYPE_NORMAL
- en: The Camera Trace Channel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When changing our cube''s response to the `Visibility` Trace Channel, you may
    have noticed the other out-of-the-box Trace Channel: `Camera`.'
  prefs: []
  type: TYPE_NORMAL
- en: This channel is used to specify whether an object blocks the line of sight between
    the camera's spring arm and the character it's associated with. In order to see
    this in action, we can drag an object to our level and place it in such a way
    that it will stay between the camera and our player character.
  prefs: []
  type: TYPE_NORMAL
- en: Have a look at the following example; we begin by duplicating the `floor` object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can easily duplicate an object in the level by holding the *Alt* key and
    dragging one of the *Move Tool*'s arrows in any direction.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14: Floor object being selected'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_05_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.14: Floor object being selected'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we change its `Transform` values as shown in the following figure:![Figure
    5.15: Updating the Transform values'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_05_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.15: Updating the Transform values'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now when you play your game, you''ll notice that when the character goes under
    our duplicated floor object, you won''t lose sight of the player''s character,
    but rather the spring arm will cause the camera to move down until you can see
    the character:![Figure 5.16: Changes in the camera angle'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_05_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.16: Changes in the camera angle'
  prefs: []
  type: TYPE_NORMAL
- en: In order to see how the spring arm's behavior differs when an object isn't blocking
    the `Camera` Trace Channel, change our duplicated floor's response to the `Camera`
    channel to `Ignore` and play the level again. What will happen is that, when our
    character goes under the duplicated floor, we will lose sight of the character.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After you've done these steps, you can see that the `Camera` channel is used
    to specify whether an object will cause the spring arm to move the camera closer
    to the player when it intersects that object.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to use the existing Trace Channels, what if we wanted to
    create our own Trace Channels?
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.05: Creating a Custom EnemySight Trace Channel'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we''ve discussed before, UE4 comes with two out-of-the-box Trace Channels:
    `Visibility` and `Camera`. The first one is a general-use channel that we can
    use to specify which objects block the line of sight of an object, while the second
    one allows us to specify whether an object blocks the line of sight between the
    camera''s spring arm and the character it''s associated with.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But how can we create our own Trace Channels? That''s what we''ll be looking
    into in this exercise. We will create a new `EnemySight` Trace Channel and use
    it to check whether the enemy can see the player character, instead of the built-in
    `Visibility` channel:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `Project Settings` by pressing the `Edit` button at the top-left corner
    of the editor, and go to the `Collision` section. There you'll find the `Trace
    Channels` section. It's currently empty because we haven't yet created any of
    our own Trace Channels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `New Trace Channel` option. A window should pop up, giving you the
    option to name your new channel and set its default response by the objects in
    your project. Name our new Trace Channel `EnemySight` and set its default response
    to `Block`, because we want most objects to do exactly that.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After you''ve created the new Trace Channel, we must go back to our `EnemyCharacter`
    C++ class and change the trace we''re comparing against in our Line Trace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Given that we are no longer using the `Visibility` channel, we must reference
    our new channel, but how do we do that?
  prefs: []
  type: TYPE_NORMAL
- en: In your project's directory, you'll find the `Config` folder. This folder contains
    several `ini` files related to your project, such as `DefaultGame.ini`, `DefaultEditor.ini`,
    `DefaultEngine.ini`, and so on. Each of these contains several properties that
    will be initialized when the project is loaded. The properties are set by name-value
    pairs (`property=value`), and you can change their values as desired.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we created our `EnemySight` channel, the project''s `DefaultEngine.ini`
    file was updated with our new Trace Channel. Somewhere in that file, you''ll find
    this line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Verify that our enemy's behavior remains the same after all the changes we've
    made. This means that the enemy must still face the player's character, as long
    as it's within view of said enemy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By completing this exercise, we now know how to make our own Trace Channels
    for any desired purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Going back to our enemy character, there are still ways that we can improve
    its logic. Right now, when we fetch our enemy's location as the start point of
    the Line Trace, that point is somewhere around the enemy's hip, because that's
    where the origin of the Actor is. However, that's not usually where people's eyes
    are, and it wouldn't make much sense to have a humanoid character looking from
    its hip instead of its head.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's change that, and have our enemy character check whether it sees the
    player character starting from its eyes, instead of its hip.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 5.01: Creating the SightSource Property'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, we will be improving our enemy's logic to determine whether
    it should look at the player. Currently, the Line Trace that's being done to determine
    that is being *shot* from around our character's hips, (`0,0,0`) in our `BP_EnemyCharacter`
    blueprint, and we want this to make a bit more sense, so we'll make it so that
    the Line Trace starts somewhere close to our enemy's eyes. Let's get started then.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Declare a new `SceneComponent` in our `EnemyCharacter` C++ class called `SightSource`.
    Make sure to declare this as a `UPROPERTY` with the `VisibleAnywhere`, `BlueprintReadOnly`,
    `Category = LookAt` and `meta = (AllowPrivateAccess = "true")` tags.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create this component in the `EnemyCharacter` constructor by using the `CreateDefaultSubobject`
    function, and attach it to the `RootComponent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the start location of the Line Trace in the `CanSeeActor` function to
    the `SightSource` component's location, instead of the Actor's location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `BP_EnemyCharacter` Blueprint class and change the `SightSource` component's
    location to the location of the enemy's head, `(10, 0, 80)`, as was done in the
    *Creating the EnemyCharacter Blueprint Class* section to the `SkeletalMeshComponent`
    property of `BP_EnemyCharacter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Transform` tab in the `Editor Panel` as shown in *Figure 5.17*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17: Updating the SightSource component’s values'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_05_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.17: Updating the SightSource component''s values'
  prefs: []
  type: TYPE_NORMAL
- en: 'Expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.18: Expected output showing the updated Line Trace from the hip
    to the eye'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_05_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.18: Expected output showing the updated Line Trace from the hip to
    the eye'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  prefs: []
  type: TYPE_NORMAL
- en: By completing this activity, we have updated our `SightSource` property for
    our `EnemyCharacter`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By completing this chapter, you have added a new tool to your belt: Line Traces.
    You now know how to execute Line Traces and Sweep Traces, both Single and Multi;
    how to change an object''s response to a specific Trace Channel; and how to create
    your own Trace Channels.'
  prefs: []
  type: TYPE_NORMAL
- en: You will quickly realize in the chapters ahead that these are essential skills
    when it comes to game development, and you will make good use of them on your
    future projects.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to use Line Traces, we're ready for the next step, which
    is Object Collision. In the next chapter, you will learn how to set up collisions
    between objects and how to use collision events to create your own game logic.
    You will create the Dodgeball Actor, which will be affected by real-time physics
    simulation; the Wall Actors, which will block both the characters' movements and
    the dodgeball; and the Actor responsible for ending the game when the player comes
    into contact with it.
  prefs: []
  type: TYPE_NORMAL
