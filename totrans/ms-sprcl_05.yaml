- en: Distributed Configuration with Spring Cloud Config
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is the right time to introduce a new element in our architecture, a distributed
    configuration server. Similar to service discovery, this is one of the key concepts
    around microservices. In the previous chapter, we discussed in detail how to prepare
    discovery, both on the server and client sides. But so far, we have always provided
    a configuration for the application using properties placed inside a fat JAR file.
    That approach has one big disadvantage, it requires a recompilation and a redeployment
    of the microservice's instance. Another approach supported by Spring Boot assumes
    the use of an explicit configuration stored in a filesystem outside of the fat
    JAR. It can be easily configured for an application during startup with the `spring.config.location`
    property. That approach does not require a redeployment, but it is also not free
    from drawbacks. With a lot of microservices, a configuration management based
    on explicit files placed in a filesystem may be really troublesome. In addition,
    let’s imagine that there are many instances of every microservice and each of
    them has a specific configuration. Well, with that approach it is better not to
    imagine it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, a distributed configuration is a very popular standard in a cloud-native
    environment. Spring Cloud Config provides server-side and client-side support
    for externalized configuration in a distributed system. With that solution, we
    have one central place where we can manage external properties for applications
    across all environments. The concept is really simple and easy to implement. A
    server does nothing more than expose HTTP and resource-based API interfaces, which
    returns `property` files in JSON, YAML, or properties formats. Additionally, it
    performs decryption and encryption operations for returned property values. A
    client needs to fetch configuration settings from a server, and also decrypt them
    if such a feature has been enabled on the server side.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Configuration data may be stored in different repositories. The default implementation
    of `EnvironmentRepository` uses a Git backend. It is also possible to set up other
    VCS systems such as SVN. If you don't want to take advantage of features provided
    by VCS as a backend, you may use the filesystem or Vault. Vault is a tool for
    managing secrets, which stores and controls access to such resources as tokens,
    passwords, certificates, and API keys.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we will cover in this chapter are:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: HTTP API exposed by Spring Cloud Config Server
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different types of repository backend on the server side
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating with service discovery
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reloading the configuration automatically with Spring Cloud Bus and message
    broker
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to HTTP API resources
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Config Server provides the HTTP API, which may be invoked in various ways.
    The following endpoints are available:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '`/{application}/{profile}[/{label}]`: This returns data in a JSON format; the
    label parameter is optional'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/{application}-{profile}.yml`: This returns the YAML format'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/{label}/{application}-{profile}.yml`: A variant of the previous endpoint,
    where we can pass an optional label parameter'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/{application}-{profile}.properties`: This returns the simple key/value format
    used by properties files'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/{label}/{application}-{profile}.properties`: A variant of the previous endpoint,
    where we can pass an optional label parameter'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From a client point of view, the application parameter is the name of the application,
    which is taken from the `spring.application.name` or `spring.config.name` property,
    and profile is an active profile or comma-separated list of active profiles. The
    last available parameter `label` is an optional property, important only while
    working with Git as a backend store. It sets the name of the Git branch for configuration
    and defaults to `master`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Native profile support
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s begin with the simplest example, based on a filesystem backend. By default,
    Spring Cloud Config Server tries to fetch configuration data from a Git repository.
    To enable the native profile, we should launch the server with the `spring.profiles.active` option set
    to `native`. It searches for files stored in the following locations, `classpath:/`,
    `classpath:/config`, `file:./`, `file:./config`. It means that properties or YAML
    files may be also placed inside a JAR file. For test purposes, I created a config
    folder inside `src/main/resources`. Our configuration files will be stored in
    that location. Now, we need to go back for a moment to the example from the previous
    chapter. As you probably remember, I introduced the configuration for a clustered
    discovery environment, where each client service instance was launched in a different
    zone. There were three available zones and three client instances, each of them
    has its own profile in the `application.yml` file. The source code for that example
    is available in the `config` branch. Here''s the link:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/piomin/sample-spring-cloud-netflix/tree/config](https://github.com/piomin/sample-spring-cloud-netflix/tree/config)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Our current task is to migrate that configuration to the Spring Cloud Config
    Server. Let''s remind ourselves the properties set for that example. Here are
    the profile settings used for the first instance of the client application. According
    to the selected profile, there are a changing instance running port, a default
    discovery server URL and a zone name:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the described example I placed all of the profiles settings in a single
    `application.yml` file for simplicity. That file might as well be divided into
    three different files with the names including the profiles, `application-zone1.yml`,
    `application-zone2.yml`, and `application-zone3.yml`. Of course, such names are
    unique to a single application, so if we decided to move the files into a remote
    configuration server, we should take care of their names. The client application
    name is injected from `spring.application.name` and in this case, it is `client-service`.
    So, to conclude, I created three configuration files with the name `client-service-zone[n].yml`
    in the `src/main/resources/config` catalog, where [`n`] is an instance''s number.
    Now, when you call the `http://localhost:8888/client-service/zone1` endpoint, you
    will receive the following response in JSON format:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can also call `http://localhost:8888/client-service-zone2.properties` for
    the second instance, which returns the following response as a list of properties:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The last available version of the HTTP API endpoint, `http://localhost:8889/client-service-zone3.yml`,
    returns data identical to the input file. Here''s the result for the third instance:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Building a server-side application
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have started by discussing HTTP, a resource-based API provided by the Spring
    Cloud Config Server, and the way of creating and storing properties there. But
    now let''s move back to the basics. The same as a discovery server, a Config Server
    may be run as a Spring Boot application. To enable it on the server side, we should
    include `spring-cloud-config-server` in our dependencies in the `pom.xml` file:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In addition to this, we should enable the Config Server on the main application
    class. It would be a good idea to change the server port to `8888`, because it
    is the default value of the `spring.cloud.config.uri` property on the client side.
    For example, it is auto configured on the client side. To switch the server to
    a different port, you should set the `server.port` property on `8888` or launch
    it with the `spring.config.name=configserver` property. There is a `configserver.yml`
    embedded in the `spring-cloud-config-server` library:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Building a client-side application
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you set port `8888` as the default for the server, the configuration on
    the client side is really simple. All you need to do is to provide the `bootstrap.yml`
    file with the application name and include the following dependency in your `pom.xml`.
    Of course, that rule is applicable only on localhost, because the auto-configured
    Config Server address for a client is `http://localhost:8888`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将`port` `8888`设置为服务器的默认端口，则客户端端的配置非常简单。 您只需要提供`bootstrap.yml`文件和在`pom.xml`中包含以下依赖项。
    当然，该规则仅适用于本地主机，因为客户端的自动配置的配置服务器地址为`http://localhost:8888`：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you set a port different than `8888` for the server, or it is running on
    a different machine than the client application, you should also set its current
    address in `bootstrap.yml`. Here are the bootstrap context settings, which allow
    you to fetch properties for `client-service` from the server available on port 
    `8889`. When running the application with the `--spring.profiles.active=zone1` argument, it
    automatically fetches the properties set for the `zone1` profile in the configuration
    server:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您为服务器设置的端口与`8888`不同，或者它在与客户端应用程序不同的计算机上运行，则还应在`bootstrap.yml`中设置其当前地址。 以下是引导上下文设置，允许您从在`port`
    `8889`上可用的服务器中获取`client-service`的属性。 使用`--spring.profiles.active=zone1`参数运行应用程序时，它会自动获取为配置服务器中的`zone1`配置文件设置的属性：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Adding a Eureka Server
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Eureka服务器
- en: As you have probably noticed, there is the discovery service network location
    address in the client's properties. So, before launching the client service we
    should have a Eureka Server running. Of course, Eureka also has its own configuration,
    which has been stored in the `application.yml` file for the example from the previous
    chapter. That configuration, similar to `client-service`, has been divided into
    three profiles, where each of them differ from the others in such properties as
    the number of the server's HTTP port and the list of discovery peers to communicate
    with.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，客户端属性中有发现服务网络位置地址。 因此，在启动客户端服务之前，我们应该运行Eureka服务器。 当然，Eureka也有自己的配置，该配置已存储在上一章节示例的`application.yml`文件中。
    该配置与`client-service`类似，已分为三个配置文件，其中每个配置文件在服务器的HTTP端口号和要与之通信的发现对等体列表等属性方面与其他配置文件不同。
- en: 'Now, we place those `property` files on the configuration server. Eureka fetches
    all of the settings assigned to the selected profile on startup. File naming is
    consistent with the already described standard, which means `discovery-service-zone[n].yml`.
    Before running the Eureka Server, we should include `spring-cloud-starter-config`
    in the dependencies to enable Spring Cloud Config Client, and replace `application.yml`
    with `bootstrap.yml`, which is shown here:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将这些`property`文件放在配置服务器上。 Eureka在启动时获取分配给所选配置文件的所有设置。 文件命名与已描述的标准一致，这意味着`discovery-service-zone[n].yml`。
    在运行Eureka服务器之前，我们应该在依赖项中包含`spring-cloud-starter-config`以启用Spring Cloud Config
    Client，并将`application.yml`替换为`bootstrap.yml`，如下所示：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we may run three instances of the Eureka Server in peer-to-peer communication
    mode by setting a different profile name in the `--spring.profiles.active` property.
    After launching three instances of `client-service`, our architecture looks like
    the following diagram. In comparison to the example from the previous chapter,
    both client and discovery services fetch the configuration from the Spring Cloud
    Config Server, instead of keeping it as a YML file inside a fat JAR:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过在`--spring.profiles.active`属性中设置不同的配置文件名来以对等通信模式运行三个Eureka服务器实例。 在启动三个`client-service`实例后，我们的架构如下图所示。
    与上一章的示例相比，客户端和发现服务都从Spring Cloud Config服务器获取配置，而不是将其作为YML文件保存在fat JAR中：
- en: '![](img/9423cf78-f43e-4e95-89a7-fe1beeae4cff.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9423cf78-f43e-4e95-89a7-fe1beeae4cff.png)'
- en: Client-side bootstrap approaches
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端引导方法
- en: In the example solution described previously, all of the applications must hold
    the network location of the configuration server. The network location of service
    discovery is stored there as a property. At this point, we are confronted with
    an interesting problem to discuss. We could ask whether our microservices should
    be aware of the Config Server's network address. In previous discussions, we have
    agreed that the main place all the service’s network locations should be kept
    is the service discovery server. The configuration server is also a Spring Boot
    application like other microservices, so logically it should register itself with
    Eureka to enable the automated discovery mechanism for other services that have
    to fetch data from the Spring Cloud Config Server. This in turn requires placing
    the service discovery connection settings in `bootstrap.yml` instead of the `spring.cloud.config.uri`
    property.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前描述的示例解决方案中，所有应用程序都必须保存配置服务器的网络位置。 服务发现的网络位置存储在那里作为属性。 在这一点上，我们面临一个有趣的问题需要讨论。
    我们可以问我们的微服务是否应该知道配置服务器的网络地址。 在先前的讨论中，我们已经同意所有服务的网络位置应该保存在服务发现服务器中。 配置服务器也是像其他微服务一样的Spring
    Boot应用程序，因此从逻辑上讲，它应该向Eureka注册，以启用其他服务的自动发现机制，这些服务必须从Spring Cloud Config服务器获取数据。
    这反过来要求将服务发现连接设置放在`bootstrap.yml`中，而不是`spring.cloud.config.uri`属性。
- en: Choosing between these two different approaches is one of the decisions you
    need to make while designing your system architecture. It's not that one solution
    is better than the other. The default behavior for any application that uses the `spring-cloud-config-client`
    artifact is called **Config First Bootstrap** in Spring Cloud nomenclature. When
    a config client starts up, it binds to the server and initializes the context
    with remote property sources. That approach has been presented in the first example
    in this chapter. In the second solution, the Config Server registers with the
    service discovery and all of the applications may use `DiscoveryClient` to locate
    it. That approach is called **Discovery First Bootstrap**. Let's implement an
    example that illustrates that concept.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计系统架构时，选择这两种不同方法之一是您需要做出的决定之一。并不是一个解决方案比另一个更好。任何使用`spring-cloud-config-client`工件的应用程序的默认行为在Spring
    Cloud命名法中称为**Config First Bootstrap**。当配置客户端启动时，它会绑定到服务器并使用远程属性源初始化上下文。这种方法已经在本章的第一个示例中介绍过。在第二种解决方案中，配置服务器向服务发现注册，并且所有应用程序都可以使用`DiscoveryClient`来定位它。这种方法称为**Discovery
    First Bootstrap**。让我们实施一个说明该概念的示例。
- en: Config Server discovery
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置服务器发现
- en: 'To access that example on GitHub, you need to switch to the `config_with_discovery` branch.
    Here''s the link:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要在GitHub上访问该示例，您需要切换到`config_with_discovery`分支。这是链接：
- en: '[https://github.com/piomin/sample-spring-cloud-netflix/tree/config_with_discovery](https://github.com/piomin/sample-spring-cloud-netflix/tree/config_with_discovery).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/piomin/sample-spring-cloud-netflix/tree/config_with_discovery](https://github.com/piomin/sample-spring-cloud-netflix/tree/config_with_discovery).'
- en: 'The first change is related to the `sample-service-discovery` module. We don’t
    need the `spring-cloud-starter-config` dependency there. The simple configuration
    is not fetched from remote property sources, but set in `bootstrap.yml`. In contrast
    to the previous example, we launch a single standalone Eureka instance in order
    to simplify the exercise:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个变化与`sample-service-discovery`模块有关。我们不需要在那里使用`spring-cloud-starter-config`依赖项。简单的配置不是从远程属性源中获取的，而是在`bootstrap.yml`中设置的。与上一个示例相反，我们启动了一个独立的Eureka实例，以简化练习：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'By contrast, we should include the `spring-cloud-starter-eureka` dependency
    for the Config Server. Now, the full list of dependencies is shown in the following
    code. Moreover, a discovery client has to be enabled by declaring the `@EnableDiscoveryClient`
    annotation on the main class, and the Eureka Server address should be provided
    by setting the `eureka.client.serviceUrl.defaultZone` property to `http://localhost:8761/eureka/`
    in the `application.yml` file:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，我们应该为配置服务器包含`spring-cloud-starter-eureka`依赖项。现在，完整的依赖项列表显示在以下代码中。此外，必须通过在主类上声明`@EnableDiscoveryClient`注解来启用发现客户端，并且应该通过在`application.yml`文件中将Eureka服务器地址设置为`http://localhost:8761/eureka/`来提供Eureka服务器地址：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'On the client application side, it is no longer needed to hold the address
    of the configuration server. The only thing that has to be set is the service
    ID, in case it is different than the Config Server. In accordance with the naming
    convention used for the services in the presented examples, that ID is `config-server`.
    It should be overridden with the `spring.cloud.config.discovery.serviceId` property.
    In order to allow discovery mechanism enable the discovery mechanism to fetch
    remote property sources from the configuration server, we should set `spring.cloud.config.discovery.enabled=true`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端应用程序方面，不再需要保存配置服务器的地址。唯一需要设置的是服务ID，如果与配置服务器不同的话。根据所呈现示例中服务的命名约定，该ID为`config-server`。它应该被`spring.cloud.config.discovery.serviceId`属性覆盖。为了允许发现机制从配置服务器获取远程属性源，我们应该设置`spring.cloud.config.discovery.enabled=true`：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here''s the screen with the Eureka dashboard, with one instance of the Config
    Server and three instances of `client-service` registered. Every instance of the
    client''s Spring Boot application is the same as for the previous example and
    was launched with the `--spring.profiles.active=zone[n]` parameter, where `n`
    is the number of the zone. The only difference is that all of the client''s service
    configuration files served by the Spring Cloud Config Server have the same connection
    address as the Eureka Server:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是带有尤里卡仪表板的屏幕，其中一个配置服务器的实例和三个“client-service”注册。客户端的每个Spring Boot应用程序实例与上一个示例相同，并且是使用`--spring.profiles.active=zone[n]`参数启动的，其中`n`是区域的编号。唯一的区别是，由Spring
    Cloud配置服务器提供的所有客户端服务配置文件都具有与Eureka服务器相同的连接地址：
- en: '![](img/11dbf317-7acc-465c-8714-af1143dd5297.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11dbf317-7acc-465c-8714-af1143dd5297.png)'
- en: Repository backend types
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仓库后端类型
- en: All of the previous examples in this chapter have used the filesystem backend,
    which means that the config files were loaded from the local filesystem or classpath.
    This type of backend is very good for tutorial purposes or for testing. If you
    would like to use Spring Cloud Config in production, it is worth considering the
    other options. The first of them is a repository backend based on Git, which is
    also enabled by default. It is not the only one **version control system** (**VCS**)
    that can be used as a repository for configuration sources. The other option is
    SVN, or we can even decide to create a composite environment, which may consist of
    both Git and SVN repositories. The next supported backend type is based on a tool
    provided by HashiCorp, Vault. It is especially useful when managing security properties
    such as passwords or certificates. Let's take a closer look at each of the solutions
    listed here.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Filesystem backend
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I won't write a lot about this topic, because it has already been discussed
    in the previous examples. All of them have shown how to store property sources
    in the classpath. There is also the ability to load them from disk. By default,
    the Spring Cloud Config Server tries to locate files inside an application's working
    directory or the config subdirectory at this location. We can override the default
    location with the `spring.cloud.config.server.native.searchLocations` property.
    The search location path may contain placeholders for `application`, `profile`,
    and `label`. If you don't use any placeholders in the location path, the repository
    automatically appends the label parameter as a suffix.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: As a consequence, the configuration files are loaded from each search location
    and a subdirectory with the same name as the label. For example, `file:/home/example/config`
    is the same as `file:/home/example/config,file:/home/example/config/{label}`.
    This behavior may be disabled by setting `spring.cloud.config.server.native.addLabelLocations`
    to `false`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: As I have already mentioned, a filesystem backend is not a good choice for a
    production deployment. If you place property sources in a classpath inside a JAR
    file, every change requires a recompilation of the application. On the other hand,
    using a filesystem outside of a JAR does not need recompilation, but this approach
    may be troublesome if you have more than one instance of a config service working
    in a high availability mode. In that case, share the filesystem across all of
    the instances or hold a copy of all of the property sources per running instance.
    The Git backend is free from such disadvantages, and that's why it is recommended
    for production use.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Git backend
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Git version control system has some features that make it very useful as
    a repository for property sources. It allows you to easily manage and audit changes.
    By using well-known VCS mechanisms such as commit, revert, and branching, we can
    perform important operations a lot easier than in a filesystem approach. This
    type of backend also has another two key advantages. It forces a separation between
    the Config Server source code and the `property` files repository. If you take
    a look one more time at the previous examples, you will see that the `property`
    files were stored together with the application source code. Probably some of
    you would say that even if we used a filesystem backend, we can store the whole
    configuration as a separate project on Git and upload it to a remote server on
    demand. Of course, you would be right. But when using a Git backend with the Spring
    Cloud Config, you have those mechanisms available out of the box. In addition,
    it resolves the problems related to running multiple instances of the server.
    If you use a remote Git server, the changes may be easily shared across all of
    the running instances.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Different protocols
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To set the location of the Git repository for the application, we should use
    the `spring.cloud.config.server.git.uri` property in `application.yml`. If you
    are familiar with Git, you well know that cloning may be realized using file,
    http/https, and ssh protocols. The local repository access allows you to get started
    quickly without a remote server. It is configured with file, prefix, for example,
    `spring.cloud.config.server.git.uri=file:/home/git/config-repo`. For more advanced
    usage when running Config Server in the high availability mode, you should use
    the remote protocols SSH or HTTPS. In this case, Spring Cloud Config clones a
    remote repository and then bases it on the local working copy as a cache.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Using placeholders in URIs
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the recently listed placeholders, `application`, `profile`, and `label`,
    are also supported here. We can create a single repository per application using
    a placeholder as in `https://github.com/piomin/{application}`, or even per profile, `https://github.com/piomin/{profile}`.
    This type of backend implementation maps the label parameter of the HTTP resource
    to a Git label, which may refer to commit ID, branch, or tag name. The most appropriate
    way to discover interesting features for us is obviously through an example. Let's
    begin by creating a Git repository dedicated to storing the application's property
    sources.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Building a server application
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I created an example configuration repository, which is available on GitHub
    here:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/piomin/sample-spring-cloud-config-repo.git](https://github.com/piomin/sample-spring-cloud-config-repo.git).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'I placed all of the property sources used in the first example in this chapter,
    which illustrated native profile support for client applications running in different
    discovery zones. Now, our repository holds the files visible in this list:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2b06957-1a0d-4f84-ade1-8637cdc7d591.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
- en: 'The Spring Cloud Config Server by default tries to clone a repository after
    the first HTTP resource call. If you would like to force cloning it after startup,
    you should set the `cloneOnStart` property to `true`. Beyond this, it is required
    to set the repository connection settings and the account authentication credentials:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After running the server, we can call the endpoints known from the previous
    exercises, for example, `http://localhost:8889/client-service/zone1` or `http://localhost:8889/client-service-zone2.yml`.
    The result would be the same as for the earlier tests; the only difference is
    in the data source. Now, let's perform another exercise. As you probably remember,
    we had to change the client's properties a little when we created the example
    with discovery first bootstrap with the `native` profile enabled. Because right
    now we are using a Git backend, we can develop a smarter solution for that case.
    In the current approach, we would create `discovery` branch ([https://github.com/piomin/sample-spring-cloud-config-repo/tree/discovery](https://github.com/piomin/sample-spring-cloud-config-repo/tree/discovery))
    at our configuration repository on GitHub, and we would place the files dedicated
    to the application illustrating the discovery first bootstrap mechanism. If you
    call the Config Server endpoints with the `label` parameter set to `discovery`,
    you will fetch data from our new branch. Try to call `http://localhost:8889/client-service/zone1/discovery`
    and/or `http://localhost:8889/discovery/client-service-zone2.yml` and check the
    result*. *
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider another situation. I changed the server port for the third
    instance of `client-service`, but for some reason I would like to move back to
    the previous value. Do I have to change and commit `client-service-zone3.yml`
    with the previous port value? No, all I have to do is to pass the commit ID as
    a `label` parameter while calling the HTTP API resource. The change performed is
    illustrated in the following screenshot:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b6069696-66ed-4ace-bfda-741529faf834.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: 'If I invoke the API endpoint with the parent commit ID instead of branch name,
    the older port number would be returned as a response. Here''s the result of calling `http://localhost:8889/e546dd6/client-service-zone3.yml`,
    where `e546dd6` is the previous commit ID:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Client-side configuration
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While building the server side with a Git backend, I have only shown you examples
    of HTTP resource calls.  Here''s the example configuration for the client''s application.
    Instead of setting the `profile` property inside `bootstrap.yml`, we may also
    pass it in the `spring.profiles.active` running parameter. This configuration
    makes the client fetch properties from the `discovery` branch. We may also decide
    to switch to a certain commit ID by setting it in the `label` property, as I have
    already mentioned:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Multiple repositories
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, you may need to configure multiple repositories for a single Config
    Server. I can imagine the situation that you would have to separate the business
    configuration from a typical technical configuration. This is absolutely possible:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Vault backend
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I have already mentioned Vault as a tool for securely accessing secrets through
    a unified interface. In order to enable the Config Server to use that type of
    backend, you must run it with the Vault profile `--spring.profiles.active=vault`.
    Of course, before running the Config Server you need to install and launch the
    Vault instance. I suggest you use Docker for this. I know that this is our first
    contact with Docker in this book, and not everyone has knowledge of that tool.
    I have provided a short introduction to Docker, its basic commands, and use cases
    in [Chapter 14](0756243e-39c9-4696-8d79-4175e7cf4c48.xhtml)*, Docker Support*.
    So, if this is your first contact with that technology, please first take a look
    at that introduction. For those of you who are familiar with Docker, here''s the
    command for running a Vault container in development mode. We may override the
    default listen address with the `VAULT_DEV_LISTEN_ADDRESS` parameter or the ID
    of the initial generated root token with the `VAULT_DEV_ROOT_TOKEN_ID` parameter:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Getting started with Vault
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Vault provides a command line interface, which may be used for adding new values
    to the server and reading them from the server. Examples of calling those commands
    are shown here. However, we have run Vault as a Docker container, so the most
    convenient way to manage the secrets is through the HTTP API:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The HTTP API is available for our instance of Vault under the `http://192.168.99.100:8200/v1/secret` address.
    When calling every method of that API, you need to pass a token as the request
    header `X-Vault-Token`. Because we set that value in the `VAULT_DEV_ROOT_TOKEN_ID`
    environment parameter while launching a Docker container, it is equal to `client`.
    Otherwise, it would be automatically generated during startup and may be read
    from logs by invoking the command `docker logs vault`. To start working with Vault,
    we in fact need to be aware of two HTTP methods—`POST` and `GET`. When calling
    the `POST` method, we may define the list of secrets that should be added to the
    server. The parameters passed in the `curl` command shown here are created using
    the kv backend, which acts like a key/value store:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The newly added values may be read from the server by using the `GET` method:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Integration with Spring Cloud Config
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As I have mentioned before, we have to run the Spring Cloud Config Server with
    the `--spring.profiles.active=vault` parameter to enable Vault as a backend store.
    To override the default auto configured settings, we should define the properties
    under the `spring.cloud.config.server.vault.*` key. The current configuration
    for our example application is shown here. An example application is available
    on GitHub; you need to switch to the `config_vault` branch ([https://github.com/piomin/sample-spring-cloud-netflix/tree/config_vault](https://github.com/piomin/sample-spring-cloud-netflix/tree/config_vault))
    to access it:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, you may call the endpoint exposed by the Config Server. You have to pass
    the token in the request header, but this time its name is `X-Config-Token`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The response should be the same as what is shown next. These properties are
    the default for all of the profiles of the client application. You may also add
    specific settings for the selected profile by calling the Vault HTTP `API` method
    with the profile name after a comma character, like this, `http://192.168.99.100:8200/v1/secret/client-service,zone1`. If
    such a profile name is included in the calling path, the properties for both the
    `default` and `zone1` profiles are returned in the response:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Client-side configuration
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When using Vault as a backend to your Config Server, the client will need to
    pass a token for the server to be able to retrieve values from Vault. This token
    should be provided in the client configuration settings with the `spring.cloud.config.token`
    property in the `bootstrap.yml` file:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Additional features
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a look at some other useful features of the Spring Cloud Config.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Fail on start and retry
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes it doesn't make any sense to launch the application if the Config
    Server is unavailable. In this case, we would like to halt a client with an exception.
    To achieve this, we have to set the bootstrap configuration property `spring.cloud.config.failFast`
    to `true`. Such a radical solution is not always the desired behavior. If a Config
    Server is unreachable only occasionally, the better approach would be to keep
    trying to reconnect until it succeeds. The `spring.cloud.config.failFast` property still
    has to be equal to `true`, but we would also need to add the `spring-retry` library
    and `spring-boot-starter-aop` to the application classpath. The default behavior
    assumes to retry six times with an initial backoff interval of 1000 milliseconds. You
    may override these settings by using the `spring.cloud.config.retry.*` configuration
    properties.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Secure client
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The same as for the service discovery, we may secure the Config Server with
    basic authentication. It can be easily enabled on the server side with Spring
    Security. In that case, all the client needs to set is the username and password
    in the `bootstrap.yml` file:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Reload configuration automatically
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already discussed the most important features of Spring Cloud Config.
    At that point, we implemented examples illustrating how to use different backend
    storage as a repository. But no matter whether we decided to choose filesystem,
    Git, or Vault, our client-side application needed to restart to be able to fetch
    the newest configuration from the server. However, sometimes this is not an optimal
    solution, especially if we have many microservices running and some of them use
    the same generic configuration.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Solution architecture
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even if we created a dedicated `property` file per single application, an opportunity
    to dynamically reload it without restart could be very helpful. As you may have
    deduced, such a solution is available for Spring Boot and therefore for Spring
    Cloud. In [Chapter 4](b016b615-1eed-457a-9b9c-66ba07c9ce9e.xhtml), *Service Discovery*
    while describing deregistration from the service discovery server, I introduced
    an endpoint, `/shutdown`, which may be used for gracefully shutting down. There
    is also an endpoint available for Spring context restart, which works in a similar
    way to that for shutdown.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'An endpoint on the client side is just one component of the much larger system
    that needs to be included to enable push notifications for the Spring Cloud Config. The
    most popular source code repository providers, such as GitHub, GitLab, and Bitbucket,
    are able to send notifications about changes in a repository by providing a WebHook
    mechanism. We may configure the WebHook using the provider''s web dashboard as
    a URL and a list of selected event types. Such a provider will call the `POST`
    method defined in the WebHook with a body containing a list of commits. It is
    required to include a Spring Cloud Bus dependency in the project to enable the
    monitor endpoint on the Config Server side. When this endpoint is invoked as a
    result of the WebHook activation, a Config Server prepares and sends an event
    with a list of property sources that has been modified by the last commit. That
    event is sent to a message broker. The Spring Cloud Bus provides implementations
    for RabbitMQ and Apache Kafka. The first may be enabled for the project by including
    the `spring-cloud-starter-bus-amqp` dependency, and the second by including the `spring-cloud-starter-bus-kafka`
    dependency. Those dependencies should also be declared for a client application
    to enable receiving messages from a message broker. We should also enable the
    dynamic refresh mechanism on the client side by annotating the selected configuration
    class with `@RefreshScope`. An architecture of this solution is shown here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f0318c08-6af4-40fc-a44a-e1b8885e6a01.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
- en: Reload configuration with @RefreshScope
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This time we will start unusually from the client side. The example application
    is available on GitHub ([https://github.com/piomin/sample-spring-cloud-config-bus.git](https://github.com/piomin/sample-spring-cloud-config-bus.git)).
    The same as the previous examples, it uses a Git repository as backend storage,
    which is also created on GitHub ([https://github.com/piomin/sample-spring-cloud-config-repo](https://github.com/piomin/sample-spring-cloud-config-repo)).
    I added some new properties to the client''s configuration file and committed
    changes to the repository. Here''s the current version of the client''s configuration:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'I disabled security for Spring Boot Actuator endpoints by setting `management.security.enabled`
    to `false`. It is required to be able to call those endpoints without passing
    security credentials. I also added two test parameters, `sample.string.property`
    and `sample.int.property`, to demonstrate bean refresh mechanisms based on their
    values in the example. Spring Cloud provides some additional HTTP management endpoints
    for the Spring Boot Actuator. One of them is `/refresh`, which is responsible
    for reloading the bootstrap context and refreshing beans annotated with `@RefreshScope`.
    This is an HTTP `POST` method, which may be called on our client''s instance at `http://localhost:8081/refresh`.
    Before testing that functionality, we need to have the discovery and Config Servers
    running. The client application should be launched with the `--spring.profiles.active=zone1 `parameter.
    Here''s the class where the test properties `sample.string.property` and `sample.int.property`
    are injected into the fields:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'That bean is injected into the `ClientController` class and invoked inside
    the `ping` method, which is exposed at `http://localhost:8081/ping`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, let''s change the values for test properties in `client-service-zone1.yml`
    and commit them. If you call the Config Server HTTP endpoint `/client-service/zone1`,
    you''ll see the newest values returned as a response. But when you call the `/ping`
    method exposed on the client application, you will still see older values visible
    on the left side of the following screen. Why? Although the Config Server automatically
    detects repository changes, the client application is not able to automatically
    refresh without any trigger. It requires a restart to read the newest settings,
    or we may force a configuration reload by invoking the previously described `/refresh`
    method:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49a8d206-7a6b-4477-8b85-40b5427c13f9.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
- en: 'After calling the `/refresh` endpoint on the client application, you will see
    in the log files that the configuration has been reloaded. Now, if you invoke
    `/ping` one more time, the newest property values are returned in the response.
    That example illustrates how a hot reload works for a Spring Cloud application,
    but it is obviously not our target solution. The next step is to enable communication
    with the message broker:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7c79dd98-0c3d-45ae-a736-678d2cec1cb1.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: Consuming events from a message broker
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I have already mentioned that we may choose between two message brokers that
    are integrated with the Spring Cloud Bus. In this example, I'm going to show you
    how to run and use RabbitMQ. Let me just say a few words about that solution,
    because we are dealing with it for the first time in the book. RabbitMQ has grown
    into the most popular message broker software. It is written in Erlang and implements
    **Advanced Message Queueing Protocol** (**AMQP**). It is easy to use and configure,
    even if we are talking about such mechanisms as clustering or high availability.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'The most convenient way to run RabbitMQ on your machine is through a Docker
    container. Two ports have been exposed outside the container. The first of them
    is used for client connections (`5672`) and the second is dedicated to the management
    dashboard (`15672`). I also ran the image with the management tag to enable the
    UI dashboard, which is not available in the default version:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To enable support for the RabbitMQ broker for our example client application,
    we should include the following dependency in `pom.xml`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'That library contains auto-configuration settings. Because I run Docker on
    Windows, I need to override some default properties. The full service configuration
    is stored inside a Git repository, so the changes affect only remote files. We
    should add the following parameters to the previously used version of the client''s
    property source:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you run the client application, an exchange and a queue would be automatically
    created in RabbitMQ. You can easily check this out by logging in to the management
    dashboard available at `http://192.168.99.100:15672`. The default username and
    password are `guest/guest`. Here''s the screen from my RabbitMQ instance. There
    is one exchange with the name `SpringCloudBus` created, with two bindings to the
    client queue and Config Server queue (I have already run it with the changes described
    in the next section). At this stage, I wouldn''t like to go into the detail about
    RabbitMQ and its architecture. A good place for such a discussion would be in
    the [Chapter 11](554c4049-1dc9-430d-8fe7-19f3b9ac99a3.xhtml), *Message-Driven
    Microservices* on the Spring Cloud Stream project:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c29e1292-6fa9-412f-812f-c60bb2ab2033.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
- en: Monitoring repository changes on a Config Server
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Cloud Config Server has to perform two tasks in the previously described
    process. First of all, it has to detect changes in a `property` file stored in
    a Git repository. This may be achieved by exposing a special endpoint, which would
    be called through a WebHook by the repository provider. The second step is to
    prepare and send a `RefreshRemoteApplicationEvent` targeted at the applications
    that might have been changed.  This in turn requires us to establish connection
    with a message broker. The `spring-cloud-config-monitor` library is responsible
    for enabling the `/monitor` endpoint. To enable support for the RabbitMQ broker,
    we should include the same starter artifact as for the client application:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'That''s not all. The configuration monitor should also be activated in `application.yml`.
    Because each repository provider has a dedicated implementation in Spring Cloud,
    it is necessary to select which of them should be enabled:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The change detection mechanism may be customized. By default, it detects changes
    in files that match the application name. To override that behavior, you need
    to provide a custom implementation of `PropertyPathNotificationExtractor`. It
    accepts the request headers and body parameters, and returns a list of file paths
    that have been changed. To support notifications from GitHub, we may use `GithubPropertyPathNotificationExtractor`
    provided by `spring-cloud-config-monitor`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Simulating change events manually
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A monitor endpoint can be invoked by a WebHook configured on a Git repository
    provider such as GitHub, Bitbucket, or GitLab. Testing such a feature with the
    application running on localhost is troublesome. It turns out that we may easily
    simulate such a WebHook activation by calling `POST /monitor` manually. For example,
    the `Github` command should have the header `X-Github-Event` included in the request.
    The JSON body with changes in the `property` files should look as shown in this
    cURL request:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, let's change and commit a value of one property in the `client-service-zone1.yml`
    file, for example, `sample.int.property`. Then, we may call the `POST /monitor`
    method with the parameters shown in the previous example command. If you configured
    everything according to my descriptions, you should  see the following log line
    on your client application side, `Received remote refresh request. Keys refreshed
    [sample.int.property]`. If you call the `/ping` endpoint exposed by the client
    microservice, it should return the newest value of the changed property.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Testing locally with a GitLab instance
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For those who do not prefer simulating events, I''m proposing a more practical
    exercise. However, I would point out that it requires not only development skills
    from you, but also a basic knowledge of Continuous Integration tools. We will
    start by running a GitLab instance locally using its Docker image. GitLab is an
    open sourced web-based Git repository manager with wiki and issue tracking features.
    It is very similar to such tools as GitHub or Bitbucket, but may be easily deployed
    on your local machine:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'A web dashboard is available at `http://192.168.99.100:10080`. The first step
    is to create an admin user and then log in using the credentials provided. I won''t
    go into the details of GitLab. It has a user-friendly and intuitive GUI interface,
    so I''m pretty sure you will able to handle it without too much effort. Anyway,
    going forward, I created a project in GitLab with the name `sample-spring-cloud-config-repo`.
    It may be cloned from `http://192.168.99.100:10080/root/sample-spring-cloud-config-repo.git`.
    I committed there the same set of configuration files, which is available in our
    example repository on GitHub.  The next step is to define a WebHook that invokes
    the Config Server''s `/monitor` endpoint with a push notification. To add a new
    WebHook for the project, you need to go to the Settings | Integration section
    and then fill in the URL field with the server address (use your hostname instead
    of localhost). Leave the Push events checkbox selected:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7c24aea-9d7a-45ed-b69f-b6aa818239d7.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
- en: 'In comparison with the Config Server implementation with GitHub as a backend
    repository provider, we need to change the enabled monitor type in `application.yml`
    and of course provide a different address:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We should also register another bean implementing `PropertyPathNotificationExtractor`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Finally, you may make and push some changes in the configuration files. The
    WebHook should be activated and the client application's configuration should
    be refreshed. That is the last example in this chapter; we may proceed to the
    conclusion.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, I have described the most important features of a Spring Cloud
    Config project. The same as for service discovery, we started from the basics,
    a simple use case on the client and server sides. We discussed the different backend
    repository types for a Config Server. I implemented the examples illustrating
    how to use filesystem, Git, and even third-party tools such as Vault as a repository
    for your `property` files. I put particular focus on interoperability with other
    components, such as service discovery or multiple instances of microservices within
    a larger system. Finally, I showed you how to reload an application's configuration
    without restart, based on WebHooks and a message broker. To conclude, after reading
    this chapter you should be able to use Spring Cloud Config as one element of your
    microservice-based architecture and take an advantage of its main features.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: After we have discussed an implemetation of service discovery and configuration
    server with Spring Cloud, we may proceed to an inter-service communication. In
    the next two chapters we will analyze basic and some more advanced samples that
    illustrate synchronous communication between a few microservices.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
