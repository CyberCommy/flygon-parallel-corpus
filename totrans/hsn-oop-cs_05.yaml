- en: Exception Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin this chapter by looking at two words: exception and handling.
    In English, the word **exception** refers to something unusual that doesn''t usually
    happen. In programming, the word exception has a similar meaning, but is related
    to software code. By their nature, computer programs should do only those things
    that we instruct them to do, and it is considered abnormal when a computer won''t
    or can''t follow our instructions. If the computer program fails to follow our
    instructions, it is classified as an exception in the software world.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Error **is another word that is heavily used in programming. It is important
    for us to understand that an error and an exception are not the same thing. An
    error refers to an incident where the software couldn''t even run. More specifically,
    an error means that the code that is written contains something wrong, and that
    is why the compiler couldn''t compile/build the code. On the other hand, an exception is
    something that happens at runtime. The easiest way to distinguish between these
    two concepts is—if the code doesn''t compile/build, then there is an error in
    your code. If the code compiles/builds, but when you run it you get some unusual
    behavior, then it''s an exception.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exception handling** means handling/controlling/supervising exceptions that
    occur while we are running the program. The topics that we are going to explore
    in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Why we need exception handling in programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception handling in C# programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basics of exception handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`try` and `catch`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens if you don't handle exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple `catch` blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the `throw` keyword is used for
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the `finally` block does
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some common exception classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception-handling best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why we need exception handling in programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that you have written some code. The code should do what you have instructed
    it to, right? But for some reason, the software is unable to execute the commands
    you have given. Maybe the software is facing some issues that make it impossible
    to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s say that you have instructed the software to read a file,
    collect data, and store it in a database. However, the software is unable to find
    the file at the location where the file is supposed to be. There could be many
    reasons why the file isn''t found there: the file may have been deleted by someone
    or may have been moved to another location. Now, what will your software do? It''s
    not smart enough to handle this situation automatically. If the software is not
    clear about its work, it will throw an exception. It is our duty as a software
    developer to tell the software what to do in these kind of situations.'
  prefs: []
  type: TYPE_NORMAL
- en: The software will let us know that it is stuck and can't resolve the situation by
    passing a message. But what should it say to us? *"Help! Help!"* won't be an appropriate
    message, and this kind of message won't make the developer's life any easier.
    We need more information about the situation so that we can guide the computer
    to work accordingly. For that reason, the .NET framework has created some very
    common exceptions that occur very often in programming. If the problem that the
    software is facing has a predefined exception, it will throw that. For example,
    say that there is a program that is trying to divide a number by zero. Mathematically,
    this is not possible, but the computer has to do it because you have instructed
    it to do so. Now the computer is in big trouble; it's confused and helpless. It
    tries to divide the number by zero as you instructed, but then the compiler will
    stop it and say *"Ask for help, Mr. Program!"*, which means, *"T**hrow a* `DivideByZeroException`
    *to your master for help".* The program will then throw a `DivideByZeroException`
    and expect some code that the programmer has written to handle it. This is how
    we will actually know what exceptions we need to handle in the program. This is
    why we need exceptions in programming.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling in C# programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The .NET framework and C# programming language have developed some powerful
    ways to handle exceptions. `System.Exceptions` is a class in .NET under the system
    namespace and has some functionality that will help you to manage exceptions that
    occur during runtime and prevent your program from crashing. If you don't handle
    exceptions properly in your code, your software will crash. This is why exception
    handling is very important in software development.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you might be wondering how you can handle exceptions in your code. An exception
    is something unexpected. How can you know which exception will occur in your code
    and cause the program to crash? This is a very good question, and I am sure this
    question was also asked when language developers were designing the language.
    That is why they came up with a solution for .NET that has created a very beautiful
    mechanism to handle exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Basics of exception handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Exception handling in C# is mainly achieved by four keywords: `try`, `catch`,
    `throw`, and `finally`. Later, we will talk about these keywords in detail. However,
    just to give you a basic idea of what is meant by those keywords, let''s briefly
    discuss them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`try`: When you are not sure of the expected behavior of a piece of code or
    if there is a possibility of an exception, you should put that code in a `try`
    block. The `try` block will throw an exception if any exception happens inside
    the code for that block. If no exception occurs, the `try` block will act like
    a normal code block. The `try` block is actually designed to throw exceptions,
    which is its main task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catch`: The `catch` block is executed when an exception is caught. Exceptions
    thrown by the `try` block will be handled by the following `catch` block. There
    could be multiple `catch` blocks for a `try` block. Each `catch` block can be
    dedicated to a particular exception. Consequently, we should write different `catch`
    blocks for different types of exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`throw`: This is used when you manually want to throw an exception. There could
    be situations in which you want to do this to control a specific kind of situation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`finally`: This is a block of code that will be compulsorily executed. It doesn''t
    matter whether the `try` block threw an exception or not—the `finally` block will
    be executed. This is mainly used to code some tasks that are essential to handle
    in any case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try and catch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `try` and `catch` keywords are the two most important keywords for exception
    handling in C#. If you write a `try` block without a `catch` block, then it won''t
    make any sense because, if a `try` block throws an exception and there is no `catch`
    block to handle it, then what is the benefit? The exception will still be unhandled.
    The `catch` block actually depends on a `try` block. A `catch` block can''t exist
    if there is no `try` block associated with it. Let''s look at how we can write
    a `try`-`catch` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also have more `catch` blocks for a `try` block. Let''s look at an example of
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: What happens if you don't handle exceptions?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Are exceptions really important? Are they worth the time spent handling them
    when you have tons of complexities in the logic? Yes, they are super important.
    Let's explore what will happen if you don't take care of exceptions. When an exception
    is triggered, if no code handles it, the exception goes to the system runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, when the system runtime faces an exception, it just terminates
    the program. So, now you understand why you should handle exceptions. If you fail
    to do this, your application might break down in the middle of running. I am sure
    you personally don''t like programs that crash while you are using them, so we
    have to be careful about writing exception-free software. Let''s look at an example
    of what happens during system runtime if the exception is not handled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If we run this code, then the first four times that it is run, it will perform
    perfectly and print some numbers from one to four. But after that, it will throw
    an exception of `IndexOutOfRangeException` and the system runtime will terminate
    the program.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple catch blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s normal to get different types of exceptions in one `try` block. But how
    can you handle them? You should not use a general exception to do this. If you
    throw a general exception instead of throwing a specific exception, you might
    miss some important information about the exception. For this reason, the C# language
    introduced multiple `catch` blocks for a `try` block. You can specify one `catch`
    block that will be called for one type of exception, and you can create other
    `catch` blocks just after one-by-one with different exception types. When a specific
    exception is thrown, only that particular `catch` block will be executed if it
    has a dedicated `catch` block for that kind of exception. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the preceding code, you will see that only the second `catch` block
    is executed. If you open up the console window, you will see that the following
    line has been printed out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: So, we can see that if you have multiple `catch` blocks, only the particular
    `catch` block that matches the type of exception that was thrown will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you might be thinking, *"You said we shouldn''t use a general exception
    handler. But why is that? Yes, we might miss some information but my system isn''t
    crashing! Isn''t it better this way?"* Actually, the answer to this question is
    not straightforward. It may vary from system to system, but let me tell you why
    you want the system to crash sometimes. Suppose you have a system where you deal
    with very complex and sensitive data. When an exception happens in such a system, it
    might be very risky to allow the customer to use the software. The customer could
    do some serious damage to the data, as the exception was not handled properly.
    But yes, if you think your system will be fine if you allow the user to continue,
    even if they got an unknown exception, you can use a general `catch` block. Now
    let me show you how you can do this. If you want a `catch` block to catch any
    kind of exception, regardless of the exception type, then your `catch` block should
    accept the `Exception` class as a parameter, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can also pass a `no` parameter to the `catch` block. This
    will also catch every kind of exception and execute the code in the body. An example
    of this is given in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: However, keep in mind that this has to be the last `catch` block, otherwise,
    there will be a runtime error.
  prefs: []
  type: TYPE_NORMAL
- en: Using the throw keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, in your own program, you have to create exceptions by yourself.
    No, not to take revenge on the user, but for the sake of your application. Sometimes,
    there are situations where you need to throw an exception to bypass a difficulty,
    to log something, or just redirect the flow of the software. Don''t worry: by
    doing this you are not becoming the bad guy; you are actually the hero who is
    saving the program from trouble. But how can you create an exception? To do that,
    C# has a keyword called `throw`. This keyword will help you to create an instance
    of a type of exception and throw it. Let me show you an example of the `throw`
    keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/19a3ed57-7485-4785-872d-de991b0338f1.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see that, if you run the preceding code, you will get the `DivideByZeroException` `catch`
    block executed.
  prefs: []
  type: TYPE_NORMAL
- en: So, if you want to throw an exception (because you want the upper-layer `catch`
    block to handle it, for example), you simply throw a new instance of an exception.
    This could be any kind of exception, including a system exception or a self-created
    exception. Just keep in mind that there is a `catch` block that will handle it.
  prefs: []
  type: TYPE_NORMAL
- en: What does the finally block do?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we say "finally", we mean something that we were waiting for or something
    that is going to conclude the process. This is almost the same in exception handling.
    A `finally` block is a block of code that will be executed no matter what happens
    in the `try` or `catch` block. It doesn't matter what types of exception were
    thrown or whether or not they were handled, the `finally` block will be executed.
    Now you may ask, *"**Why do we need this* `finally` *block? If there is any exception
    in our program, we will handle it with the* `catch` *block! Can't we write the
    code inside the* `catch` *block instead of the* `finally` *block?"*
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes, you can, but what happens if an exception was thrown but the `catch` block
    wasn''t triggered? This would mean that the code inside the `catch` block will
    not get executed. For this reason, the `finally` block is important. It doesn''t
    matter whether or not there was any exception; the `finally` block will run. Let
    me show you an example of the `finally` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/32173a85-0984-4cbd-acbb-cb9eb559c8e1.png)'
  prefs: []
  type: TYPE_IMG
- en: An important use case of the `finally` block could be when you open a database
    connection in the `try` block! You have to close this, otherwise, that connection
    will be open for the rest of the program and it will use a lot of resources. In
    addition, there are a limited number of connections a database can make, so if
    you open one and don't close it, that connection string is wasted. The best practice
    is to close the connection as soon as your work with it is complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `finally` block plays the best role here. It doesn''t matter what will
    happen in the `try` block, the `finally` block will close the connection, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are performing two main tasks in the `try` block. First, we open a
    database connection, and secondly, we perform some activity in the database. Now,
    if any exception happens while we do any of this, an exception will be thrown
    that will be handled by a `catch` block. At the very end, the `finally` block
    will close the database connection.
  prefs: []
  type: TYPE_NORMAL
- en: The `finally` block is not something that you must have to have to handle exceptions,
    but you should use it if you need it.
  prefs: []
  type: TYPE_NORMAL
- en: Exception class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An `exception` is simply a class in C#. This has a few properties and methods.
    The four most commonly used properties are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Message` | This contains what the exception is about.  |'
  prefs: []
  type: TYPE_TB
- en: '| `StackTrace` | This contains the method call-stack information. |'
  prefs: []
  type: TYPE_TB
- en: '| `TargetSite` | This gives an object that contains the method where the exception
    happened. |'
  prefs: []
  type: TYPE_TB
- en: '| `InnerException` | This gives the instance of the exception that caused the
    exception. |'
  prefs: []
  type: TYPE_TB
- en: Exception class properties and methods
  prefs: []
  type: TYPE_NORMAL
- en: One of the most popular methods in this class is `ToString()`. This method returns
    a string that contains information about the exception. The exception is easier
    to read and understand when it is represented in string format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of using these properties and methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9295d985-106f-47ac-9530-b2818991d2b0.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we can see that the `message` property of the exception holds the information
    `Attempted to divide by zero`. In addition, the `ToString()` method gives a lot
    of information about the exception. These properties and methods will help you
    a lot when handling exceptions in your program.
  prefs: []
  type: TYPE_NORMAL
- en: Some common exception classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many exception classes available in .NET Framework. The .NET Framework
    team created these to make the developer''s life easier. The .NET Framework provides
    specific information about the exceptions. The following are some of the most
    common exception classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Exception Class** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `DivideByZeroException` | This exception is thrown when any number is divided
    by zero. |'
  prefs: []
  type: TYPE_TB
- en: '| `IndexOutOfRangeException` | This exception is thrown when the application
    tries to use an index of an array that doesn''t exist. |'
  prefs: []
  type: TYPE_TB
- en: '| `InvalidCastException` | This exception is thrown when trying to perform
    invalid casting. |'
  prefs: []
  type: TYPE_TB
- en: '| `NullReferenceException` | This exception is thrown when trying to use or
    access a null reference type. |'
  prefs: []
  type: TYPE_TB
- en: Different exception classes of .NET framework
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example in which one of these exception classes is used.
    In this example, we are using the `IndexOutOfRange` exception class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2ae2fd64-2e62-4365-aa7c-23b2e7104ae7.png)'
  prefs: []
  type: TYPE_IMG
- en: User-defined exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, you''ll encounter a situation where you might think that the predefined
    exceptions do not satisfy your condition. In this instance, you might wish there
    was a way to create your own exception classes and use them. Thankfully, in C#,
    there is actually a mechanism where you can create your own custom exceptions,
    and can write whatever message is appropriate for that kind of exception. Let''s
    look at an example of how to create and use custom exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b38a2822-1170-4403-8bfe-b6e93aea6a89.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So, we can see from the preceding example that you just have to create a class
    that will extend the `Exception` class. This class should have three constructors:
    one shouldn''t take any parameter, one should take a string and pass it to the
    base, and one should take a string and an exception and pass it to the base.'
  prefs: []
  type: TYPE_NORMAL
- en: Using a custom exception is like using any other built-in exception provided
    by .NET Framework.
  prefs: []
  type: TYPE_NORMAL
- en: The exception filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The exception filter feature isn''t very old at the time of writing—it was
    introduced in C# 6\. The main benefit of this is that you can catch more specific
    exceptions in a block. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0742e721-1391-4da1-89eb-707e2c898206.png)'
  prefs: []
  type: TYPE_IMG
- en: To filter out exceptions, you have to use the `when` keyword just next to the
    `catch` declaration line. So first, when any exception is thrown, it will check
    what type of exception it is and then check the condition provided after the `when`
    keyword. In our example, the exception type is `IndexOutOfRangeException` and
    the condition is `ex.Message == "Index was outside the bounds of the array."`.
    We can see that, when the code ran, only that particular `catch` block was executed,
    which fulfilled all the conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you can see, there are different ways in which you can handle exceptions:
    sometimes you can throw exceptions, sometimes you can use the `finally` block,
    and sometimes you can use multiple `catch` blocks. Consequently, there is a chance
    that you can get confused at the beginning if you don''t have enough experience
    with exception handling. But thanks to the C# community, there are some best practices
    for exception handling. Let''s have a look at some of them:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a `finally` block to close/clean up dependent resources that could cause
    a problem in the future.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Catch the specific exception and handle it properly. Use multiple `catch` blocks
    if needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create your own exceptions if needed and use them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle exceptions as soon as possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't use a general exception handler if you can handle an exception using a
    specific handler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The exception messages should be very clear.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We all dream of a perfect world where there are no errors or unexpected situations,
    but in reality, this is impossible. Software development is also not free from
    errors and exceptions. Software developers don't want their software to break
    down, but unexpected exceptions happen every now and then. Consequently, handling
    these exceptions is necessary for developing awesome software. In this chapter,
    we familiarized ourselves with what an exception is in software development. We
    have also learned how to handle exceptions, why we need to handle exceptions,
    how to create custom exceptions, and many other important topics. When implementing
    exception handling in your application, try to follow best practices so that you
    get an application that runs smoothly.
  prefs: []
  type: TYPE_NORMAL
