- en: Template Programming in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Template programming in Go allows the end user to write Go templates that produce,
    manipulate, and run Go programs. Go has clear, static dependencies, which assist
    with metaprogramming. Template programming in Go, including generated binaries,
    CLI tooling, and templating libraries, are all core tenets of the language that
    help us write maintainable, scalable, performant Go code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Go generate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protobuf code generation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linking toolchains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration metaprogramming using Cobra and Viper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text and HTML templating
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sprig for Go templating
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these topics will help you write Go code faster and more effectively.
    In the next section, we'll talk about Go generate and how it is useful in the
    Go programming language.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Go generate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As of Go version 1.4, the language contains a tool that helps with code generation,
    called Go generate. Go generate scans source code for general commands to run.
    This operates independently of `go build`, and thus must be run before code is
    built. Go generate is run by the code author, not by users of the compiled binary.
    This tool runs similarly to how Makefiles and shell scripts are typically used,
    but it is packaged with the Go tool and we don't need to include any other dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Go generate will search the code base for lines with the following pattern: `//go:generate
    command argument`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A generated source file should have a line such as the following, in order
    to convey that the code was generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Go generate utilizes a group of variables when the generator is run:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$GOARCH`: The architecture of the executing platform'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$GOOS`: The operating system of the executing platform'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$GOFILE`: The filename'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$GOLINE`: The source file''s line number that contains the directive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$GOPACKAGE`: The package name in which the file containing the directive lives'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$DOLLAR`: A literal `$`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use this Go generate command for all sorts of different use cases in
    Go.  They can be thought of as built-in build mechanisms for Go. The operations
    that are performed with Go generate can be done with other build toolings, such
    as Makefiles, but having Go generate available means that you don't need any other
    dependencies in your build environment. This means that all of your build artifacts
    live within Go files to maintain consistency across your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Generated code for protobufs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One practical use case for generating code in Go is generating protocol buffers
    using gRPC. Protocol buffers are a new method that is used to serialize structured
    data. It's commonly used to pass data between services in distributed systems,
    as it tends to be much more efficient than its JSON or XML counterparts. Protocol
    buffers are also extensible across multiple languages on multiple platforms. They
    come with a structured data definition; once you have your data structured, source
    code is generated that can be read from, and written to, data sources.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to grab the latest version of the protocol buffers: [https://github.com/protocolbuffers/protobuf/releases](https://github.com/protocolbuffers/protobuf/releases).
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, the stable version of this software is 3.8.0\. After
    installing this package, we need to make sure that we pull the required Go dependencies
    using the `go get github.com/golang/protobuf/protoc-gen-go` command. Next, we
    can generate a very generic protocol definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, we can generate our protofile by using Go generate. Create a file
    in the same directory as your `.proto` file that contains the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to generate a protobuf definition just by using Go generate.
    After we execute Go generate in this directory, we get a file, `userinfo.pb.go`,
    that contains all of our protobuf definitions in the Go format. We can use this
    information when we are generating our client and server architecture with gRPC.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can create a server to use the gRPC definitions that we added earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'After we initialize our server struct and have a function for returning user
    information, we can set up our gRPC server to listen on our standard port and
    register our server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have our server definition set up, we can focus on the client. Our
    client has all of our normal imports, as well as a couple of default constant
    declarations, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have our imports and constants set up, we can use these in our main
    function to send these values to our server. We set up a context with a default
    timeout of 1 second, we make a `PrintUserInfo` protobuf request, and we get a
    response and log it. The following is our protobuf example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We can see our protobuf example in action here. Protobufs are a powerful way
    to send messages across a distributed system.  Google has often mentioned how
    important protobufs are to their stability at scale. We'll talk about the results
    from our protobuf code in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Protobuf code results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we have our protocol definition, our server, and our client, we can execute
    them together to see our work in action. First, we start the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1ef5a6cc-4cae-409b-a20b-820eb05353ba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we execute the client code. We can see the default user name and email
    address that we created in our client code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d87c1be2-f1c0-4066-8a40-775e4eb0699b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On the server-side, we can see the log for the request that we made:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d803f44f-6fc8-4629-b664-8c9f5712af69.png)'
  prefs: []
  type: TYPE_IMG
- en: 'gRPC is a very efficient protocol: it uses HTTP/2 and protocol buffers in order
    to rapidly serialize data. Multiple calls can make use of a single connection
    from the client to the server, which in turn reduces latency and increases throughput.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will talk about the link toolchain.
  prefs: []
  type: TYPE_NORMAL
- en: The link toolchain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go has a bunch of handy tools in its link tool that allow us to pass pertinent
    data to an executable function. With this tool, the programmer has the ability
    to set a value for a string with a particular name and value pair. Using the `cmd`/`link`
    package in Go allows you to pass in information to the Go program at hand at link
    time. The way to pass this information from the toolchain to the executable is
    to utilize the build parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if we were trying to take in a serial number for our program from
    the command line, we could do something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding output, if we attempt to execute this program while
    not passing in a serial number, the program will tell us that our serial number
    is invalid:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca2db256-1808-4fce-9f2f-746e956332af.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we pass in an incorrect serial number, we will get the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/774acde4-4e0e-457c-8513-a7e2db3695cf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we pass in the correct serial number, our program will tell us that we have
    a valid serial number:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d1f8fef-3f44-475b-88a6-3c2397304178.png)'
  prefs: []
  type: TYPE_IMG
- en: Having the ability to pass data into your program at link time can be useful
    when troubleshooting a large code base. It can also be useful when, though you
    have a compiled binary that you need to deploy, later a common value may need
    to be updated in a non-deterministic fashion.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss two tools—Cobra and Viper—that are commonly
    used for configuration programming.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Cobra and Viper for configuration programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Two commonly used Go libraries, `spf13/cobra` and `spf13/viper`, are used for
    configuration programming. Together, these two libraries can be used to create
    CLI binaries that have many configurable options. Cobra allows you to generate
    applications and command files, while Viper helps to read and maintain complete configuration
    solutions for 12-factor Go applications. Cobra and Viper are used in some of the
    most commonly used Go projects, including Kubernetes and Docker.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use these two libraries together to make a `cmd` library, we need to make
    sure we nest our project directory, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2542a06f-7527-477c-9588-b0e63555caa5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we have created our nested directory structure, we can start setting up
    our main program. In our `main.go` file, we have defined our date command—the
    `main.go` function for Cobra and Viper us deliberately simple so that we can invoke
    functions written in the `cmd` directory (this is a common Go idiom). Our `main`
    package is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have our `main` function defined, we can start setting up the rest
    of our command tooling. We start by importing our requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can set up our root `date` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have this set up, we can also set up a subcommand to display our licensing
    information, as shown in the following code sample.  A subcommand is a second
    argument for the CLI tool in order to give `cli` more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we can set up our `init()` function.  The `init()` function in Go is
    used for a couple of things:'
  prefs: []
  type: TYPE_NORMAL
- en: Initial information displayed to the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initial variable declaration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing connections to outside parties (a DB connection pool or message
    broker initialization)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can leverage our new `init()` function knowledge in the last bit of this
    code to initialize the `viper` and `cobra` commands we defined previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet shows us some default, persistent, and binding flags
    that are commonly used in Viper.
  prefs: []
  type: TYPE_NORMAL
- en: Cobra/Viper resulting sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have instantiated all of our functionality, we can see our new code
    in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we invoke our new `main.go` without any optional parameters, we will just
    see the date return that we defined in our initial `DateCommand` run block, as
    shown in the following code output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/573c481a-3822-41c0-9118-936ee34d458e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we add additional flags to our input, we can gather verbose information
    and change the Author of the package using command-line flags, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c2450161-1c4c-4765-8a3b-fb9db3f742f5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also view the subcommand that we created for licensing by adding it
    as a parameter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b0b25dca-8d9d-4d97-8e87-e546ceae13db.png)'
  prefs: []
  type: TYPE_IMG
- en: We have seen a small fraction of the functionality of the `spf13` Cobra and
    Viper packages, but it is important to understand their root principle – they
    are used in order to facilitate extensible CLI tooling within Go. In the next
    section, we'll talk about text templating.
  prefs: []
  type: TYPE_NORMAL
- en: Text templating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go has a built-in templating language, `text/template`, that implements templates
    with data and generates a text-based output. We use structs in order to define
    the data that we want to use within our templates. As with all things, Go input
    text is defined as UTF-8 and can be passed in as any format. We use double braces
    `{{}}` to denote actions that we want to perform on our data. A cursor, represented
    by `.`, allows us to add data to our template. These things combined create a
    powerful templating language that will allow us to reuse templates for many bits
    of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are going to initialize our package, import our necessary dependencies,
    and define our struct for the data that we would like to pass into our template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can set up our template and our input structure using the text/template
    definitions we mentioned previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we can execute our template and print it. Our example prints to `Stdout`,
    but we could print to a file, write to a buffer, or send an email automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Utilizing the Go text templating system allows us to reuse these templates to
    produce consistent quality content. Since we have new inputs, we can adjust our
    templates and derive a result accordingly.  In the next section, we will discuss
    HTML templating.
  prefs: []
  type: TYPE_NORMAL
- en: HTML templating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also use HTML templating, akin to how we performed text tempting, in
    order to generate dynamic results for HTML pages in Go. In order to do this, we
    need to initialize our package, import the proper dependencies, and set up a data
    structure to hold the values that we are planning to use in our HTML templates,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create the `userResponse` HTML template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create an HTTP request handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we initialize the HTTP server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we invoke our web server using `go run htmlTemplate.go`. When we request
    a page on this domain, we will see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f036617f-b337-43c3-886c-4366cde1c43f.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding output comes from the templated code from our HTML template. This
    example could be extended to include parsing for an incoming IP address request
    via an X-Forwarded-For header, the end user's browser information based on the
    user agent string, or any other particular request parameter that could be used
    in order to give a rich response back to the client. In the next section, we'll
    discuss Sprig, a library for Go templating functions.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Sprig
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sprig is a library that is used to define Go templating functions. The library
    includes many functions that extend the functionality of Go''s templating language.
    The Sprig library has a few principles that help determine which functions are
    available to drive enhanced templates:'
  prefs: []
  type: TYPE_NORMAL
- en: Only allows simple math
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only deals with data that is passed to templates; never retrieves data from
    an external source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizes functions from the template library to build the resulting layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Never overrides the Go core template functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following subsections, we'll take a closer look at Sprig's functionality.
  prefs: []
  type: TYPE_NORMAL
- en: String functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sprig has a grouping of string functions that are capable of manipulating strings
    within a template.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we are going to take the `"   -  bob smith"` string (note the
    spaces and dashes). From there, we are going to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Trim white space using the `trim()` utility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replace the instance of the word `smith` with the word `strecansky`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trim the `-` prefix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the string to title case, that is, from `bob strecansky` to `Bob Strecansky`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeat the string 10 times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a word wrap of 14 characters (the width of my name) and separate each
    with a new line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Sprig library can do this in one line, akin to how bash shells can pipe
    functions to one another.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by initializing our package and importing the necessary dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we set our string map to `interface`, perform our transformations, and
    render our template to standard output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'After we execute our program, we will see string manipulations occurring the
    way we expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef77ea5a-0575-420b-af28-f0771b04994f.png)'
  prefs: []
  type: TYPE_IMG
- en: Being able to manipulate strings in templates like in our example helps us to
    quickly rectify any issues we may have with incoming templates and manipulate
    them on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: String slice functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to manipulate slices of strings is helpful, as we have seen in previous
    chapters. The Sprig library helps us perform some string slice manipulation actions.
    In our example, we'll split a string based on the `.` character.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import the necessary libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we split our templated string using the `.` delimiter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have the ability to sort a templated list into alphabetical order using
    the `sortAlpha` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: These string manipulations can help us organize lists of strings that are included
    in templated functions.
  prefs: []
  type: TYPE_NORMAL
- en: Default functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sprig''s default functions return default values for templated functions. We
    can check the default values for particular data structures and whether or not
    they are *empty*.  Empty is defined for each data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Numeric | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| String | `""` (empty string) |'
  prefs: []
  type: TYPE_TB
- en: '| Lists | `[]` (empty list) |'
  prefs: []
  type: TYPE_TB
- en: '| Dicts | `{}` (empty dict) |'
  prefs: []
  type: TYPE_TB
- en: '| Boolean | `false` |'
  prefs: []
  type: TYPE_TB
- en: '| And always | Nil (also referred to as null) |'
  prefs: []
  type: TYPE_TB
- en: '| Structs | No definition for empty; will never return the default |'
  prefs: []
  type: TYPE_TB
- en: 'We start with our imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we set up our empty and non-empty template variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we validate our empty and non-empty templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This is useful when we have template inputs where we need to verify the input
    is not empty. Our resulting output shows us what we expect: the empty template
    is marked as true, while the full template is marked as false:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00f6e52b-3879-478f-a61d-e01425972e22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also encode JSON literals as JSON strings and pretty-print them. This
    is especially helpful if you are taking an HTML-created template that needs to
    return a JSON array to an end user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In our resulting output, we can see a pretty-printed JSON blob based on our
    `jsonDict` input:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44223726-7492-4c51-8935-b7fa80b99d4d.png)'
  prefs: []
  type: TYPE_IMG
- en: This is extremely useful when used with the HTML/template builtin and an added
    `content-encoding:json` HTTP header.
  prefs: []
  type: TYPE_NORMAL
- en: The Sprig library has quite a few functionalities, some of which we will discuss
    within this section of the book.
  prefs: []
  type: TYPE_NORMAL
- en: A full list of the functionality that's available via Sprig can be found at
    [http://masterminds.github.io/sprig/](http://masterminds.github.io/sprig/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed generating Go code. We talked about how to do
    so for one of the most commonly generated pieces of go code, gRPC protobufs. Then,
    we talked about the using link toolchain to add command-line arguments and `spf13/cobra`
    and `spf13/viper` to create metaprogrammed CLI tooling.  Lastly, we talked about
    templated programming using the text/template, HTML/template, and Sprig libraries.
    Using all of these packages will help us make readable, reusable, performant Go
    code. These templates will also save us a lot of work in the long run as they
    tend to be reusable and scalable.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll discuss how to optimize for memory resource management.
  prefs: []
  type: TYPE_NORMAL
